{"version":3,"file":"main.js","mappings":"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","sources":["webpack:///../common/Settings.ts","webpack:///./src/AngleSnaps.ts","webpack:///./src/SnapIntersect.ts","webpack:///./src/SquareTemplate.ts","webpack:///./src/TemplateTargeting.ts","webpack:///./src/LineToBoxCollision.ts","webpack:///./src/TemplateConfig.ts","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./src/df-templates.ts"],"sourcesContent":["\ndeclare global {\n\tinterface LenientGlobalVariableTypes {\n\t\tgame: never;\n\t\tcanvas: never;\n\t}\n\tinterface String {\n\t\t/** Localizes the string via the global `game.i18n.localize()` function. */\n\t\tlocalize(): string\n\t}\n\ttype AnyFunction = (...args: any) => any;\n}\n\nexport default class SETTINGS {\n\tstatic MOD_NAME: string;\n\tstatic init(moduleName: string) {\n\t\tthis.MOD_NAME = moduleName;\n\t\tif (!String.prototype.localize) {\n\t\t\tString.prototype.localize = function () {\n\t\t\t\treturn game.i18n.localize(this.valueOf());\n\t\t\t};\n\t\t}\n\t}\n\tstatic register<T>(key: string, config: ClientSettings.PartialSetting<T>) { game.settings.register(SETTINGS.MOD_NAME, key, config); }\n\tstatic registerMenu(key: string, config: ClientSettings.PartialMenuSetting) { game.settings.registerMenu(SETTINGS.MOD_NAME, key, config); }\n\tstatic get<T>(key: string): T { return <T>game.settings.get(SETTINGS.MOD_NAME, key); }\n\tstatic async set<T>(key: string, value: T): Promise<T> { return await game.settings.set(SETTINGS.MOD_NAME, key, value); }\n\tstatic default<T>(key: string): T { return <T>game.settings.settings.get(SETTINGS.MOD_NAME + '.' + key).default; }\n\t/** helper for referencing a Typed constructor for the `type` field of a setting { type: SETTINGS.typeOf<MyClass>() } */\n\tstatic typeOf<T>(): ConstructorOf<T> { return Object as any; }\n}\n","import SETTINGS from \"../../common/Settings\";\nimport DnD5eAbilityTemplateHandlers from \"./DnD5eAbilityTemplateHandlers\";\n\nexport default class AngleSnaps {\n\tstatic init() {\n\t\tSETTINGS.register<number>('angle-snap-macro', {\n\t\t\tconfig: true,\n\t\t\tscope: 'world',\n\t\t\tname: 'DF_TEMPLATES.AngleSnap.MacroName',\n\t\t\thint: 'DF_TEMPLATES.AngleSnap.MacroHint',\n\t\t\ttype: Number,\n\t\t\trange: {\n\t\t\t\tmin: 4,\n\t\t\t\tmax: 24,\n\t\t\t\tstep: 4\n\t\t\t},\n\t\t\tdefault: 24\n\t\t});\n\t\tSETTINGS.register<number>('angle-snap-micro', {\n\t\t\tconfig: true,\n\t\t\tscope: 'world',\n\t\t\tname: 'DF_TEMPLATES.AngleSnap.MicroName',\n\t\t\thint: 'DF_TEMPLATES.AngleSnap.MicroHint',\n\t\t\ttype: Number,\n\t\t\trange: {\n\t\t\t\tmin: 1,\n\t\t\t\tmax: 4,\n\t\t\t\tstep: 1\n\t\t\t},\n\t\t\tdefault: 3\n\t\t});\n\t}\n\n\tstatic ready() {\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'canvas.templates._onMouseWheel', function (this: TemplateLayer, event: MouseEvent): any {\n\t\t\t// Determine whether we have a hovered template?\n\t\t\tconst template = this._hover;\n\t\t\tif (!template) return;\n\t\t\t// Determine the incremental angle of rotation from event data\n\t\t\tconst snapCount = SETTINGS.get<number>('angle-snap-macro');\n\t\t\tlet snap = 360 / snapCount;\n\t\t\tif (!event.shiftKey)\n\t\t\t\tsnap /= SETTINGS.get<number>('angle-snap-micro');\n\n\t\t\tconst sign = Math.sign((event as any).deltaY);\n\t\t\tconst delta = snap * sign;\n\t\t\tlet direction = template.data.direction - (template.data.direction % snap);\n\t\t\tif (template.data.direction % snap !== 0 && sign < 0)\n\t\t\t\tdirection += snap;\n\t\t\treturn template.rotate(direction + delta, snap);\n\t\t}, 'OVERRIDE');\n\t}\n\n\tstatic handleDnD5eAbilityTemplate(abilityTemplate: any, handlers: DnD5eAbilityTemplateHandlers) {\n\t\thandlers.mw = event => {\n\t\t\tif (event.ctrlKey) event.preventDefault(); // Avoid zooming the browser window\n\t\t\tevent.stopPropagation();\n\t\t\tconst snapCount = SETTINGS.get<number>('angle-snap-macro');\n\t\t\tlet snap = 360 / snapCount;\n\t\t\tif (event.shiftKey)\n\t\t\t\tsnap /= SETTINGS.get<number>('angle-snap-micro');\n\n\t\t\tconst sign = Math.sign(event.deltaY);\n\t\t\tlet direction = abilityTemplate.data.direction;\n\t\t\tif (direction < 0) direction += 360;\n\t\t\tdirection = direction - (direction % snap);\n\t\t\tif (abilityTemplate.data.direction % snap !== 0 && sign < 0)\n\t\t\t\tdirection += snap;\n\n\t\t\tabilityTemplate.data.update({ direction: direction + (snap * sign) });\n\t\t\tabilityTemplate.refresh();\n\t\t};\n\t}\n}","import SETTINGS from \"../../common/Settings\";\nimport DnD5eAbilityTemplateHandlers from \"./DnD5eAbilityTemplateHandlers\";\n\nexport default class SnapIntersect {\n\tstatic init() {\n\t\tSETTINGS.register('SnapIntersect', {\n\t\t\tconfig: true,\n\t\t\tscope: 'world',\n\t\t\tname: 'DF_TEMPLATES.SnapIntersectName',\n\t\t\thint: 'DF_TEMPLATES.SnapIntersectHint',\n\t\t\ttype: Boolean,\n\t\t\tdefault: false,\n\t\t\tonChange: (toggled) => toggled ? this.patch() : this.unpatch()\n\t\t});\n\t}\n\n\tstatic ready() {\n\t\tif (SETTINGS.get<boolean>('SnapIntersect'))\n\t\t\tthis.patch();\n\t}\n\n\tprivate static patch() {\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'canvas.templates.gridPrecision', SnapIntersect.TemplateLayer_gridPrecision, 'OVERRIDE');\n\t}\n\tprivate static unpatch() {\n\t\tlibWrapper.unregister(SETTINGS.MOD_NAME, 'canvas.templates.gridPrecision', false);\n\t}\n\n\tprivate static TemplateLayer_gridPrecision() {\n\t\treturn canvas.grid.type === CONST.GRID_TYPES.GRIDLESS ? 0 : 1;\n\t}\n\n\tstatic handleDnD5eAbilityTemplate(abilityTemplate: any, handlers: DnD5eAbilityTemplateHandlers) {\n\t\t/***************** THIS IS COPIED FROM THE DnD 5e CODE BASE `AbilityTemplate.prototype.activatePreviewListeners` ***************/\n\t\tlet moveTime = 0;\n\t\t// Update placement (mouse-move)\n\t\thandlers.mm = event => {\n\t\t\tevent.stopPropagation();\n\t\t\tconst now = Date.now(); // Apply a 20ms throttle\n\t\t\tif (now - moveTime <= 20) return;\n\t\t\tconst center = event.data.getLocalPosition(abilityTemplate.layer);\n\t\t\t/**** MODIFIED THIS `getSnappedPosition` TO HAVE INTERVAL 1 INSTEAD OF 2 IF ENABLED ****/\n\t\t\tconst snapped = canvas.grid.getSnappedPosition(center.x, center.y, SETTINGS.get('SnapIntersect') ? 1 : 2);\n\t\t\tabilityTemplate.data.update({ x: snapped.x, y: snapped.y });\n\t\t\tabilityTemplate.refresh();\n\t\t\tmoveTime = now;\n\t\t};\n\t\t/***************** END OF COPY ***************/\n\t}\n}","import SETTINGS from \"../../common/Settings\";\n\nexport default class SquareTemplate {\n\tstatic readonly FIX_ROTATION_PREF = 'fix-square-rotation';\n\n\tstatic init() {\n\t\tSETTINGS.register(SquareTemplate.FIX_ROTATION_PREF, {\n\t\t\tconfig: true,\n\t\t\tscope: 'world',\n\t\t\tname: 'DF_TEMPLATES.SquareRotateName',\n\t\t\thint: 'DF_TEMPLATES.SquareRotateHint',\n\t\t\ttype: Boolean,\n\t\t\tdefault: true,\n\t\t\tonChange: (toggled) => toggled ? SquareTemplate.patch() : SquareTemplate.unpatch()\n\t\t});\n\t\tif (SETTINGS.get(SquareTemplate.FIX_ROTATION_PREF))\n\t\t\tSquareTemplate.patch();\n\t}\n\n\tprivate static patch() {\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'MeasuredTemplate.prototype._getRectShape', SquareTemplate.MeasuredTemplate_getRectShape, 'OVERRIDE');\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'MeasuredTemplate.prototype._refreshRulerText', SquareTemplate.MeasuredTemplate_refreshRulerText, 'WRAPPER');\n\t}\n\tprivate static unpatch() {\n\t\tlibWrapper.unregister(SETTINGS.MOD_NAME, 'MeasuredTemplate.prototype._getRectShape', false);\n\t\tlibWrapper.unregister(SETTINGS.MOD_NAME, 'MeasuredTemplate.prototype._refreshRulerText', false);\n\t}\n\n\tstatic MeasuredTemplate_getRectShape(this: MeasuredTemplate, direction: number, distance: number, adjustForRoundingError = false): PIXI.Polygon {\n\t\t// Generate a rotation matrix to apply the rect against. The base rotation must be rotated\n\t\t// CCW by 45° before applying the real direction rotation.\n\t\tconst matrix = PIXI.Matrix.IDENTITY.rotate((-45 * (Math.PI / 180)) + direction);\n\t\t// If the shape will be used for collision, shrink the rectangle by a fixed EPSILON amount to account for rounding errors\n\t\tconst EPSILON = adjustForRoundingError ? 0.0001 : 0;\n\t\t// Use simple Pythagoras to calculate the square's size from the diagonal \"distance\".\n\t\tconst size = Math.sqrt((distance * distance) / 2) - EPSILON;\n\t\t// Create the square's 4 corners with origin being the Top-Left corner and apply the\n\t\t// rotation matrix against each.\n\t\tconst topLeft = matrix.apply(new PIXI.Point(EPSILON, EPSILON));\n\t\tconst topRight = matrix.apply(new PIXI.Point(size, EPSILON));\n\t\tconst botLeft = matrix.apply(new PIXI.Point(EPSILON, size));\n\t\tconst botRight = matrix.apply(new PIXI.Point(size, size));\n\t\t// Inject the vector data into a Polygon object to create a closed shape.\n\t\tconst shape = <any>new PIXI.Polygon([topLeft.x, topLeft.y, topRight.x, topRight.y, botRight.x, botRight.y, botLeft.x, botLeft.y, topLeft.x, topLeft.y]);\n\t\t// Add these fields so that the Sequencer mod doesn't have a stroke lol\n\t\tshape.x = topLeft.x;\n\t\tshape.y = topLeft.y;\n\t\tshape.width = size;\n\t\tshape.height = size;\n\t\treturn <PIXI.Polygon>shape;\n\t}\n\n\tprivate static MeasuredTemplate_refreshRulerText(this: MeasuredTemplate, wrapped: () => void): void {\n\t\twrapped();\n\t\t// Overwrite the text for the \"rect\" type\n\t\tif (this.data.t === \"rect\") {\n\t\t\t// Use simple Pythagoras to calculate the square's size from the diagonal \"distance\".\n\t\t\tconst size = Math.sqrt((this.data.distance * this.data.distance) / 2).toFixed(1);\n\t\t\tconst text = `${size}${canvas.scene.data.gridUnits}`;\n\t\t\t(<any>this).hud.ruler.text = text;\n\t\t}\n\t}\n}","import SETTINGS from \"../../common/Settings\";\nimport LineToBoxCollision from \"./LineToBoxCollision\";\nimport { TemplateConfig, HighlightMode } from \"./TemplateConfig\";\n\nfunction throttle<T>(fn: AnyFunction, threshhold?: number): T {\n\tthreshhold || (threshhold = 250);\n\tlet last: number;\n\tlet hasTimer = false;\n\tlet mostRecent: any[];\n\treturn <any>function (this: any, ...args: any) {\n\t\t// Preserve the most recent arguments\n\t\tmostRecent = [...args];\n\t\t// Grab the current time\n\t\tconst now = +new Date;\n\t\tconst context = this;\n\t\t// If we have been called before, and we are within the timeout period\n\t\tif (last && now < last + threshhold) {\n\t\t\t// If we already have a timer set, return immediately\n\t\t\tif (hasTimer) return;\n\t\t\t// Create a timeout with the delta from `now` to end of `last + threshold`\n\t\t\thasTimer = true;\n\t\t\tsetTimeout(function () {\n\t\t\t\t// Unset the timer\n\t\t\t\thasTimer = false;\n\t\t\t\t// Update last invocation time\n\t\t\t\tlast = +new Date;\n\t\t\t\t// Invoke the original function\n\t\t\t\tfn.apply(context, mostRecent);\n\t\t\t}, threshhold - (now - last));\n\t\t}\n\t\t// This is the first time we've been called\n\t\telse {\n\t\t\t// Set the last time value\n\t\t\tlast = now;\n\t\t\t// Invoke the original function\n\t\t\tfn.apply(context, mostRecent);\n\t\t}\n\t};\n}\n\nexport default class TemplateTargeting {\n\n\tprivate static readonly PREVIEW_PREF = \"template-preview\";\n\tprivate static readonly TARGETING_TOGGLE_PREF = \"template-targeting-toggle\";\n\tprivate static readonly TARGETING_MODE_PREF = \"template-targeting\";\n\tprivate static readonly GRIDLESS_RESOLUTION_PREF = \"template-gridless-resolution\";\n\tprivate static readonly GRIDLESS_PERCENTAGE_PREF = \"template-gridless-percentage\";\n\n\tprivate static readonly PointGraphContainer = new PIXI.Graphics();\n\n\tstatic init() {\n\t\tTemplateConfig.init();\n\n\t\tSETTINGS.register(TemplateTargeting.TARGETING_TOGGLE_PREF, {\n\t\t\tconfig: false,\n\t\t\tscope: 'client',\n\t\t\ttype: Boolean,\n\t\t\tdefault: true,\n\t\t\tonChange: () => { if (SETTINGS.get(TemplateTargeting.TARGETING_MODE_PREF) !== 'toggle') return; }\n\t\t});\n\t\tSETTINGS.register(TemplateTargeting.TARGETING_MODE_PREF, {\n\t\t\tconfig: true,\n\t\t\tscope: 'world',\n\t\t\tname: 'DF_TEMPLATES.AutoTargetName',\n\t\t\thint: 'DF_TEMPLATES.AutoTargetHint',\n\t\t\ttype: String,\n\t\t\tchoices: {\n\t\t\t\tnever: 'Never',\n\t\t\t\ttoggle: 'Toggle (Add toggle button)',\n\t\t\t\talways: 'Always'\n\t\t\t},\n\t\t\tdefault: 'toggle',\n\t\t\tonChange: () => { ui.controls.initialize(); ui.controls.render(true); }\n\t\t});\n\t\tSETTINGS.register<number>(TemplateTargeting.GRIDLESS_RESOLUTION_PREF, {\n\t\t\tconfig: true,\n\t\t\tscope: 'world',\n\t\t\tname: 'DF_TEMPLATES.GridlessPointResolutionName',\n\t\t\thint: 'DF_TEMPLATES.GridlessPointResolutionHint',\n\t\t\trange: {\n\t\t\t\tmax: 10,\n\t\t\t\tmin: 1,\n\t\t\t\tstep: 1\n\t\t\t},\n\t\t\ttype: Number,\n\t\t\tdefault: 3\n\t\t});\n\t\tSETTINGS.register<number>(TemplateTargeting.GRIDLESS_PERCENTAGE_PREF, {\n\t\t\tconfig: true,\n\t\t\tscope: 'world',\n\t\t\tname: 'DF_TEMPLATES.GridlessPointPercentageName',\n\t\t\thint: 'DF_TEMPLATES.GridlessPointPercentageHint',\n\t\t\trange: {\n\t\t\t\tmax: 100,\n\t\t\t\tmin: 0,\n\t\t\t\tstep: 10\n\t\t\t},\n\t\t\ttype: Number,\n\t\t\tdefault: 0\n\t\t});\n\t\tSETTINGS.register(TemplateTargeting.PREVIEW_PREF, {\n\t\t\tconfig: true,\n\t\t\tscope: 'world',\n\t\t\tname: 'DF_TEMPLATES.PreviewName',\n\t\t\thint: 'DF_TEMPLATES.PreviewHint',\n\t\t\ttype: Boolean,\n\t\t\tdefault: true\n\t\t});\n\t\tHooks.on('getSceneControlButtons', (controls: SceneControl[]) => {\n\t\t\tif (SETTINGS.get(TemplateTargeting.TARGETING_MODE_PREF) !== 'toggle') return;\n\t\t\tconst control = controls.find(x => x.name === 'measure');\n\t\t\tcontrol.tools.splice(0, 0, {\n\t\t\t\ticon: 'fas fa-bullseye',\n\t\t\t\tname: 'autoTarget',\n\t\t\t\ttitle: 'DF_TEMPLATES.ToggleTitle',\n\t\t\t\tvisible: true,\n\t\t\t\ttoggle: true,\n\t\t\t\tactive: SETTINGS.get(TemplateTargeting.TARGETING_TOGGLE_PREF),\n\t\t\t\tonClick: (toggled: boolean) => { SETTINGS.set(TemplateTargeting.TARGETING_TOGGLE_PREF, toggled); }\n\t\t\t});\n\t\t});\n\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'MeasuredTemplate.prototype.highlightGrid', this._MeasuredTemplate_highlightGrid, 'OVERRIDE');\n\t\t// When dragging a template, we need to catch the cancellation in order for us to refresh the template to draw back in its original position.\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'PlaceableObject.prototype._createInteractionManager', function (this: PlaceableObject, wrapper: () => MouseInteractionManager) {\n\t\t\tif (!(this instanceof MeasuredTemplate)) return wrapper();\n\t\t\t// We wrap the interaction manager construction method\n\t\t\tconst manager = wrapper();\n\t\t\t// Replacing the `dragLeftCancel` with our own wrapper function\n\t\t\tmanager.callbacks.dragLeftCancel = function (this: PlaceableObject, event: any) {\n\t\t\t\tthis.refresh();\n\t\t\t\tPlaceableObject.prototype._onDragLeftCancel.apply(this, [event]);\n\t\t\t};\n\t\t\treturn manager;\n\t\t}, 'WRAPPER');\n\t}\n\n\tstatic ready() {\n\t\t// This is used to throttle the number of UI updates made to a set number of Frames Per Second.\n\t\tconst ThrottledTemplateRefresh = throttle<(w?: AnyFunction) => void>(function (this: MeasuredTemplate) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-empty-function\n\t\t\tTemplateTargeting._MeasuredTemplate_highlightGrid.apply(this);\n\t\t}, 1000 / 20);// Throttle to 20fps\n\n\t\t// Register for the D&D5e Ability Template preview\n\t\t// @ts-ignore\n\t\tif (game.dnd5e) {\n\t\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'game.dnd5e.canvas.AbilityTemplate.prototype.refresh', function (this: MeasuredTemplate, wrapper: AnyFunction, ...args: any) {\n\t\t\t\tThrottledTemplateRefresh.apply(this);\n\t\t\t\treturn wrapper(...args);\n\t\t\t}, 'WRAPPER');\n\t\t}\n\t\t// Register for the regular template movement preview\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'MeasuredTemplate.prototype.refresh', function (this: MeasuredTemplate, wrapper: AnyFunction) {\n\t\t\tThrottledTemplateRefresh.apply(this);\n\t\t\treturn wrapper();\n\t\t\t// return wrapper();\n\t\t}, 'WRAPPER');\n\n\t\t// Register for the regular template creation completion and cancellation\n\t\tconst handleTemplateCreation = function (this: TemplateLayer, wrapper: AnyFunction, ...args: any) {\n\t\t\t// clear the highlight preview layer\n\t\t\tcanvas.grid.getHighlightLayer('Template.null')?.clear();\n\t\t\treturn wrapper(...args);\n\t\t};\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'TemplateLayer.prototype._onDragLeftDrop', handleTemplateCreation, 'WRAPPER');\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'TemplateLayer.prototype._onDragLeftCancel', handleTemplateCreation, 'WRAPPER');\n\n\t\t// Add the point graph container to the controls layer for rendering\n\t\tcanvas.controls.addChild(TemplateTargeting.PointGraphContainer);\n\t}\n\n\tprivate static _MeasuredTemplate_highlightGrid(this: MeasuredTemplate) {\n\t\tconst mode = SETTINGS.get<string>(TemplateTargeting.TARGETING_MODE_PREF);\n\t\tconst shouldAutoSelect = mode === 'always' || (mode === 'toggle' && SETTINGS.get<boolean>(TemplateTargeting.TARGETING_TOGGLE_PREF));\n\t\tconst isOwner = this.document.author.id === game.userId;\n\t\t// Release all previously targeted tokens\n\t\tif (isOwner && shouldAutoSelect && canvas.tokens.objects) {\n\t\t\tfor (const t of game.user.targets) {\n\t\t\t\tt.setTarget(false, { releaseOthers: false, groupSelection: true });\n\t\t\t}\n\t\t}\n\t\tTemplateTargeting._handleTouchTemplate.bind(this)(isOwner, shouldAutoSelect);\n\t}\n\n\tprivate static _calculateGridTestArea(this: MeasuredTemplate) {\n\t\tconst shape: {\n\t\t\tradius?: number,\n\t\t\tpoints?: number[],\n\t\t\tx?: number,\n\t\t\ty?: number,\n\t\t\twidth?: number,\n\t\t\theight?: number\n\t\t} = <any>this.shape;\n\t\tconst points: number[] = shape.points ? shape.points :\n\t\t\t(shape.radius ?\n\t\t\t\t[-shape.radius, -shape.radius, shape.radius, shape.radius] :\n\t\t\t\t[shape.x, shape.y, shape.x + shape.width, shape.y + shape.height]);\n\t\tconst shapeBounds = {\n\t\t\tleft: Number.MAX_VALUE, right: Number.MIN_VALUE,\n\t\t\ttop: Number.MAX_VALUE, bottom: Number.MIN_VALUE,\n\t\t\twidth: function () { return this.right - this.left; },\n\t\t\theight: function () { return this.bottom - this.top; }\n\t\t};\n\t\tfor (let c = 0; c < points.length; c += 2) {\n\t\t\tif (points[c] < shapeBounds.left) shapeBounds.left = points[c];\n\t\t\tif (points[c] > shapeBounds.right) shapeBounds.right = points[c];\n\t\t\tif (points[c + 1] < shapeBounds.top) shapeBounds.top = points[c + 1];\n\t\t\tif (points[c + 1] > shapeBounds.bottom) shapeBounds.bottom = points[c + 1];\n\t\t}\n\t\tconst snappedTopLeft = canvas.grid.grid.getSnappedPosition(shapeBounds.left, shapeBounds.top, 1);\n\t\tconst snappedBottomRight = canvas.grid.grid.getSnappedPosition(shapeBounds.right, shapeBounds.bottom, 1);\n\t\t[shapeBounds.left, shapeBounds.top] = [snappedTopLeft.x, snappedTopLeft.y];\n\t\t[shapeBounds.right, shapeBounds.bottom] = [snappedBottomRight.x, snappedBottomRight.y];\n\t\treturn shapeBounds;\n\t}\n\n\tprivate static _handleTouchTemplate(this: MeasuredTemplate, isOwner: boolean, shouldAutoSelect: boolean) {\n\t\t/************** THIS CODE IS DIRECTLY COPIED FROM 'MeasuredTemplate.prototype.highlightGrid' ****************/\n\t\tconst grid = canvas.grid;\n\t\tconst d = canvas.dimensions;\n\t\tconst border = <number>this.borderColor;\n\t\tconst color = <number>this.fillColor;\n\t\tconst DEBUG = SETTINGS.get('template-debug');\n\n\t\t// Only highlight for objects which have a defined shape\n\t\tconst id: string = this.id ?? (<any>this)['_original']?.id;\n\t\tif ((!this.id && !SETTINGS.get(TemplateTargeting.PREVIEW_PREF)) || !this.shape) return;\n\n\t\t// Clear existing highlight\n\t\tconst hl = grid.getHighlightLayer(`Template.${id ?? null}`);\n\t\thl?.clear();\n\n\t\t// If we are in gridless mode, highlight the shape directly\n\t\tif (grid.type === CONST.GRID_TYPES.GRIDLESS) {\n\t\t\tconst shape = this.shape.clone();\n\t\t\t//* ADDED CODE: This try-catch was added to handle a random error that occurs where\n\t\t\t//* Foundry Core tries to update the MeasuredTemplate when it doesn't have a position.\n\t\t\ttry {\n\t\t\t\tif (\"points\" in shape) {\n\t\t\t\t\tshape.points = shape.points.map((p, i) => {\n\t\t\t\t\t\tif (i % 2) return this.y + p;\n\t\t\t\t\t\telse return this.x + p;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tshape.x += this.x;\n\t\t\t\t\tshape.y += this.y;\n\t\t\t\t}\n\t\t\t}// eslint-disable-next-line no-empty\n\t\t\tcatch (error) { }\n\t\t\tgrid.grid.highlightGridPosition(hl, { border, color: <any>color, shape: <any>shape });\n\t\t\tTemplateTargeting._selectTokensByPointContainment.bind(this)(isOwner, shouldAutoSelect, this.data, <PIXI.Polygon>this.shape, true);\n\t\t\treturn;\n\t\t}\n\n\t\t// Get number of rows and columns\n\t\tconst shapeBounds = TemplateTargeting._calculateGridTestArea.apply(this);\n\t\tconst colCount = Math.ceil(shapeBounds.width() / grid.w) + 2; //? Add a padding ring around for any outlier cases\n\t\tconst rowCount = Math.ceil(shapeBounds.height() / grid.h) + 2; //? Add a padding ring around for any outlier cases\n\n\t\t// Get the offset of the template origin relative to the top-left grid space\n\t\tconst [tx, ty] = canvas.grid.getTopLeft(this.data.x, this.data.y);\n\t\tconst [row0, col0] = grid.grid.getGridPositionFromPixels(shapeBounds.left + tx, shapeBounds.top + ty);\n\t\tconst hx = canvas.grid.w / 2;\n\t\tconst hy = canvas.grid.h / 2;\n\n\t\t/***** START OF CODE EDIT *****/\n\t\t// Extract and prepare data\n\t\tlet { direction, distance, angle, width } = this.data;\n\t\tdistance *= (d.size / d.distance);\n\t\twidth *= (d.size / d.distance);\n\t\tangle = Math.toRadians(angle);\n\t\tdirection = Math.toRadians((direction % 360) + 360);\n\t\t// If we are round, the side is of length `distance`, otherwise calculate the true length of the hypotenouse\n\t\tconst isRound = game.settings.get(\"core\", \"coneTemplateType\") === 'round';\n\t\tconst rayLength = isRound ? distance : (distance / Math.sin((Math.PI / 2) - (angle / 2))) * Math.sin(Math.PI / 2);\n\n\t\tlet [ax1, ay1, bx1, by1] = [0, 0, 0, 0];\n\t\tlet [ax2, ay2, bx2, by2] = [0, 0, 0, 0];\n\t\tlet coneInitialized = false;\n\t\tconst generateConeData = () => {\n\t\t\tif (coneInitialized) return;\n\t\t\tconeInitialized = true;\n\t\t\t[ax1, ay1, bx1, by1] = [\n\t\t\t\tthis.data.x,\n\t\t\t\tthis.data.y,\n\t\t\t\tthis.data.x + (Math.cos(direction - (angle / 2)) * rayLength),\n\t\t\t\tthis.data.y + (Math.sin(direction - (angle / 2)) * rayLength)\n\t\t\t];\n\t\t\t[ax2, ay2, bx2, by2] = [\n\t\t\t\tthis.data.x,\n\t\t\t\tthis.data.y,\n\t\t\t\tthis.data.x + (Math.cos(direction + (angle / 2)) * rayLength),\n\t\t\t\tthis.data.y + (Math.sin(direction + (angle / 2)) * rayLength)\n\t\t\t];\n\t\t};\n\t\tconst generateRayData = () => {\n\t\t\tif (coneInitialized) return;\n\t\t\t[ax1, ay1] = [\n\t\t\t\tthis.data.x + (Math.cos(direction - (Math.PI / 2)) * (width / 2)),\n\t\t\t\tthis.data.y + (Math.sin(direction - (Math.PI / 2)) * (width / 2))\n\t\t\t];\n\t\t\t[bx1, by1] = [\n\t\t\t\tax1 + (Math.cos(direction) * distance),\n\t\t\t\tay1 + (Math.sin(direction) * distance)\n\t\t\t];\n\t\t\t[ax2, ay2] = [\n\t\t\t\tthis.data.x + (Math.cos(direction + (Math.PI / 2)) * (width / 2)),\n\t\t\t\tthis.data.y + (Math.sin(direction + (Math.PI / 2)) * (width / 2))\n\t\t\t];\n\t\t\t[bx2, by2] = [\n\t\t\t\tax2 + (Math.cos(direction) * distance),\n\t\t\t\tay2 + (Math.sin(direction) * distance)\n\t\t\t];\n\t\t};\n\t\t// Identify grid coordinates covered by the template Graphics\n\t\t//? Start on -1 to account for padding ring of cells around test area\n\t\tfor (let r = -1; r < rowCount; r++) {\n\t\t\t//? Start on -1 to account for padding ring of cells around test area\n\t\t\tfor (let c = -1; c < colCount; c++) {\n\t\t\t\tconst [gx, gy] = canvas.grid.grid.getPixelsFromGridPosition(row0 + r, col0 + c);\n\t\t\t\tconst testX = gx + hx;\n\t\t\t\tconst testY = gy + hy;\n\t\t\t\tconst testRect = new NormalizedRectangle(gx, gy, canvas.grid.w, canvas.grid.h);\n\t\t\t\tlet contains = false;\n\t\t\t\tswitch (this.data.t) {\n\t\t\t\t\tcase \"circle\": {\n\t\t\t\t\t\t// Calculate the vector from the PoI to the grid square center\n\t\t\t\t\t\tconst [rcx, rcy] = [testX - this.data.x, testY - this.data.y];\n\t\t\t\t\t\t// If the distance between the centres is <= the circle's radius\n\t\t\t\t\t\tcontains = ((rcx * rcx) + (rcy * rcy)) <= (distance * distance);\n\t\t\t\t\t\tif (contains || TemplateConfig.config.circle === HighlightMode.CENTER) break;\n\n\t\t\t\t\t\tconst sqrDistance = distance * distance;\n\t\t\t\t\t\tlet [vx, vy] = [0, 0];\n\t\t\t\t\t\tconst testPoint = (x: number, y: number) => {\n\t\t\t\t\t\t\t[vx, vy] = [x - this.data.x, y - this.data.y];\n\t\t\t\t\t\t\treturn (vx * vx + vy * vy) < sqrDistance;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tcontains = testPoint(testRect.left, testRect.top)\n\t\t\t\t\t\t\t|| testPoint(testRect.right, testRect.top)\n\t\t\t\t\t\t\t|| testPoint(testRect.left, testRect.bottom)\n\t\t\t\t\t\t\t|| testPoint(testRect.right, testRect.bottom);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"rect\": {\n\t\t\t\t\t\tconst rect = (this as any)._getRectShape(direction, distance, true);\n\t\t\t\t\t\tif (rect instanceof PIXI.Polygon) {\n\t\t\t\t\t\t\tcontains = this.shape.contains(testX - this.data.x, testY - this.data.y);\n\t\t\t\t\t\t\tif (contains || TemplateConfig.config.rect === HighlightMode.CENTER) break;\n\t\t\t\t\t\t\t/* Rectangle vertex data order\n\t\t\t\t\t\t\t\tA1───▶B1\n\t\t\t\t\t\t\t\t▲      │\n\t\t\t\t\t\t\t\t│      ▼\n\t\t\t\t\t\t\t\tA2◀───B2\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t// Translate points to the position of the MeasuredTemplate and map the points to the dataset\n\t\t\t\t\t\t\t[ax1, ay1, bx1, by1, bx2, by2, ax2, ay2] = rect.points.map((e, i) => e + (i % 2 ? this.data.y : this.data.x));\n\t\t\t\t\t\t\t// check the top line\n\t\t\t\t\t\t\tcontains = LineToBoxCollision.cohenSutherlandLineClipAndDraw(ax1, ay1, bx1, by1, testRect)\n\t\t\t\t\t\t\t\t// check the right line\n\t\t\t\t\t\t\t\t|| LineToBoxCollision.cohenSutherlandLineClipAndDraw(bx1, by1, bx2, by2, testRect)\n\t\t\t\t\t\t\t\t// check the bottom line\n\t\t\t\t\t\t\t\t|| LineToBoxCollision.cohenSutherlandLineClipAndDraw(bx2, by2, ax2, ay2, testRect)\n\t\t\t\t\t\t\t\t// check the left line\n\t\t\t\t\t\t\t\t|| LineToBoxCollision.cohenSutherlandLineClipAndDraw(ax2, ay2, ax1, ay1, testRect);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trect.x += this.data.x;\n\t\t\t\t\t\t\trect.y += this.data.y;\n\t\t\t\t\t\t\t// The normalized rectangle always adds 1 to the width and height\n\t\t\t\t\t\t\trect.width -= 1;\n\t\t\t\t\t\t\trect.height -= 1;\n\t\t\t\t\t\t\t// Standard 2D Box Collision detection\n\t\t\t\t\t\t\tcontains = !(rect.left >= testRect.right || rect.right <= testRect.left\n\t\t\t\t\t\t\t\t|| rect.top >= testRect.bottom || rect.bottom <= testRect.top);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"cone\": {\n\t\t\t\t\t\tcontains = this.shape.contains(testX - this.data.x, testY - this.data.y);\n\t\t\t\t\t\tif (contains || TemplateConfig.config.cone === HighlightMode.CENTER) break;\n\t\t\t\t\t\tgenerateConeData();\n\t\t\t\t\t\t// check the top line\n\t\t\t\t\t\tcontains = LineToBoxCollision.cohenSutherlandLineClipAndDraw(ax1, ay1, bx1, by1, testRect);\n\t\t\t\t\t\tif (contains) break;\n\t\t\t\t\t\t// check the bottom line\n\t\t\t\t\t\tcontains = LineToBoxCollision.cohenSutherlandLineClipAndDraw(ax2, ay2, bx2, by2, testRect);\n\t\t\t\t\t\tif (contains) break;\n\t\t\t\t\t\t// check the end-cap\n\t\t\t\t\t\tif (isRound) {\n\t\t\t\t\t\t\tconst sqrDistance = distance * distance;\n\t\t\t\t\t\t\tlet [vx, vy] = [0, 0];\n\t\t\t\t\t\t\tlet mag = 0;\n\t\t\t\t\t\t\tlet vecAngle = 0;\n\t\t\t\t\t\t\tconst testPoint = (x: number, y: number) => {\n\t\t\t\t\t\t\t\t[vx, vy] = [x - this.data.x, y - this.data.y];\n\t\t\t\t\t\t\t\treturn (vx * vx + vy * vy) < sqrDistance;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tconst testAngle: () => boolean = () => {\n\t\t\t\t\t\t\t\t// calculate vector magnitude\n\t\t\t\t\t\t\t\tmag = Math.sqrt(vx * vx + vy * vy);\n\t\t\t\t\t\t\t\t// normalize the vector\n\t\t\t\t\t\t\t\tvx /= mag;\n\t\t\t\t\t\t\t\t// Calculate the vector's angle, adjusting for bottom hemisphere if Y is negative\n\t\t\t\t\t\t\t\tvecAngle = Math.acos(vx);\n\t\t\t\t\t\t\t\tif (vy < 0) vecAngle = (Math.PI * 2) - vecAngle;\n\t\t\t\t\t\t\t\tconst minAngle = direction - (angle / 2);\n\t\t\t\t\t\t\t\tconst maxAngle = direction + (angle / 2);\n\t\t\t\t\t\t\t\tif (minAngle < 0)\n\t\t\t\t\t\t\t\t\treturn vecAngle <= maxAngle || vecAngle >= ((Math.PI * 2) + minAngle);\n\t\t\t\t\t\t\t\telse if (maxAngle > Math.PI * 2)\n\t\t\t\t\t\t\t\t\treturn vecAngle <= (maxAngle - (Math.PI * 2)) || vecAngle >= minAngle;\n\t\t\t\t\t\t\t\telse return vecAngle <= maxAngle && vecAngle >= minAngle;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (testPoint(testRect.left, testRect.top)) {\n\t\t\t\t\t\t\t\tcontains = testAngle();\n\t\t\t\t\t\t\t\tif (contains) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (testPoint(testRect.right, testRect.top)) {\n\t\t\t\t\t\t\t\tcontains = testAngle();\n\t\t\t\t\t\t\t\tif (contains) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (testPoint(testRect.left, testRect.bottom)) {\n\t\t\t\t\t\t\t\tcontains = testAngle();\n\t\t\t\t\t\t\t\tif (contains) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (testPoint(testRect.right, testRect.bottom)) {\n\t\t\t\t\t\t\t\tcontains = testAngle();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tcontains = LineToBoxCollision.cohenSutherlandLineClipAndDraw(bx1, by1, bx2, by2, testRect);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"ray\": {\n\t\t\t\t\t\tcontains = this.shape.contains(testX - this.data.x, testY - this.data.y);\n\t\t\t\t\t\tif (contains || TemplateConfig.config.ray === HighlightMode.CENTER) break;\n\t\t\t\t\t\tgenerateRayData();\n\t\t\t\t\t\t// check the top line\n\t\t\t\t\t\tcontains = LineToBoxCollision.cohenSutherlandLineClipAndDraw(ax1, ay1, bx1, by1, testRect)\n\t\t\t\t\t\t\t// check the bottom line\n\t\t\t\t\t\t\t|| LineToBoxCollision.cohenSutherlandLineClipAndDraw(ax2, ay2, bx2, by2, testRect)\n\t\t\t\t\t\t\t// check the left endcap line\n\t\t\t\t\t\t\t|| LineToBoxCollision.cohenSutherlandLineClipAndDraw(ax1, ay1, ax2, ay2, testRect)\n\t\t\t\t\t\t\t// check the right endcap line\n\t\t\t\t\t\t\t|| LineToBoxCollision.cohenSutherlandLineClipAndDraw(bx1, by1, bx2, by2, testRect);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!DEBUG && !contains) continue;\n\t\t\t\ttry { grid.grid.highlightGridPosition(hl, { x: gx, y: gy, border, color: DEBUG ? (contains ? 0x00FF00 : 0xFF0000) : color }); }\n\t\t\t\tcatch (error) {\n\t\t\t\t\t// Catches a specific \"highlight\" error that will randomly occur inside of `grid.grid.highlightGridPosition()`\n\t\t\t\t\tif (!(error instanceof Error) || !error.message.includes(\"'highlight'\")) throw error;\n\t\t\t\t}\n\t\t\t\tif (!contains) continue;\n\n\t\t\t\t// Ignore changing the target selection if we don't own the template, or `shouldAutoSelect` is false\n\t\t\t\tif (!isOwner || !shouldAutoSelect) continue;\n\n\t\t\t\t// If we are using Point based targetting for this template\n\t\t\t\tif (TemplateConfig.config[this.data.t] === HighlightMode.POINTS) {\n\t\t\t\t\tTemplateTargeting._selectTokensByPointContainment.bind(this)(isOwner, shouldAutoSelect, this.data, <PIXI.Polygon>this.shape, true);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Iterate over all existing tokens and target the ones within the template area\n\t\t\t\tfor (const token of canvas.tokens.placeables) {\n\t\t\t\t\tconst tokenRect = new NormalizedRectangle(token.x, token.y, token.w, token.h);\n\t\t\t\t\tif (testRect.left >= tokenRect.right || testRect.right <= tokenRect.left\n\t\t\t\t\t\t|| testRect.top >= tokenRect.bottom || testRect.bottom <= tokenRect.top) continue;\n\t\t\t\t\ttoken.setTarget(true, { user: game.user, releaseOthers: false, groupSelection: true });\n\t\t\t\t}\n\t\t\t\t/****** END OF CODE EDIT ******/\n\t\t\t}\n\t\t}\n\t\t/******************************************** END OF COPIED CODE ********************************************/\n\t}\n\n\tprivate static _selectTokensByPointContainment(this: MeasuredTemplate, isOwner: boolean, shouldAutoSelect: boolean, data: { x: number, y: number }, shape: PIXI.Polygon, useMultiPointTest: boolean = false) {\n\t\t//* THIS CODE WAS ORIGINALLY COPIED FROM `MeasuredTemplate.prototype.highlightGrid`\n\t\t// Ignore changing the target selection if we don't own the template, or `shouldAutoSelect` is false\n\t\tif (!isOwner || !shouldAutoSelect) return;\n\n\t\tconst DebugMode = SETTINGS.get<boolean>('template-debug');\n\t\tTemplateTargeting.PointGraphContainer.clear();\n\t\tTemplateTargeting.PointGraphContainer.removeChildren();\n\t\tlet pointGraphics: PIXI.Graphics;\n\t\tif (DebugMode) {\n\t\t\tpointGraphics = new PIXI.Graphics();\n\t\t\tTemplateTargeting.PointGraphContainer.addChild(pointGraphics);\n\t\t}\n\t\t// If we are multi-point grab the gridless resolution, otherwise we test for each grid square center\n\t\tconst pointResolution = useMultiPointTest ? SETTINGS.get<number>(TemplateTargeting.GRIDLESS_RESOLUTION_PREF) : 1;\n\t\t// Iterate over all existing tokens and target the ones within the template area\n\t\tfor (const token of canvas.tokens.placeables) {\n\t\t\t// Get the center offset of the token\n\t\t\tconst hx = token.w / 2;\n\t\t\tconst hy = token.h / 2;\n\t\t\t// Adjust the token position to be relative to the template\n\t\t\tconst [tokenX, tokenY] = [token.x - data.x, token.y - data.y];\n\t\t\t// Calculate how many points there should be along the X and Y axes\n\t\t\tlet horPoints = pointResolution > 1 ? Math.roundDecimals(token.w / canvas.grid.w, 1) * (pointResolution - 1) + 1 : Math.ceil(token.w / canvas.grid.w);\n\t\t\tlet verPoints = pointResolution > 1 ? Math.roundDecimals(token.h / canvas.grid.h, 1) * (pointResolution - 1) + 1 : Math.ceil(token.h / canvas.grid.h);\n\t\t\t// Make a small adjustment for tokens smaller than 1x1\n\t\t\tif (token.w / canvas.grid.w < 1) horPoints = Math.floor(horPoints);\n\t\t\tif (token.h / canvas.grid.h < 1) verPoints = Math.floor(verPoints);\n\t\t\t// Calculate the distance between each point on the vertical and horizontal\n\t\t\tconst horStep = horPoints > 1 ? token.w / (horPoints - 1) : token.w;\n\t\t\tconst verStep = verPoints > 1 ? token.h / (verPoints - 1) : token.h;\n\t\t\t// Generate the points relative to the token position\n\t\t\tlet x = 0;\n\t\t\tlet y = 0;\n\t\t\tlet pointFound = false;\n\t\t\tif (DebugMode) pointGraphics.beginFill(0xFF0000);\n\t\t\tconst percentage = SETTINGS.get<number>(TemplateTargeting.GRIDLESS_PERCENTAGE_PREF) / 100;\n\t\t\tconst pointCount = verPoints * horPoints;\n\t\t\tlet hitCount = 0;\n\t\t\tfor (let row = 0; !pointFound && row < verPoints; row++) {\n\t\t\t\tfor (let col = 0; col < horPoints; col++) {\n\t\t\t\t\tif (pointResolution > 1) {\n\t\t\t\t\t\tx = horPoints > 1 ? tokenX + (horStep * col) : tokenX + hx;\n\t\t\t\t\t\ty = verPoints > 1 ? tokenY + (verStep * row) : tokenY + hy;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tx = horPoints > 1 ? tokenX + (canvas.grid.w * col) + (canvas.grid.w / 2) : tokenX + hx;\n\t\t\t\t\t\ty = verPoints > 1 ? tokenY + (canvas.grid.h * row) + (canvas.grid.h / 2) : tokenY + hy;\n\t\t\t\t\t}\n\t\t\t\t\tif (DebugMode) pointGraphics.drawCircle(x + data.x, y + data.y, 3);\n\t\t\t\t\t// If the point is not contained in the shape, ignore it\n\t\t\t\t\tif (!shape.contains(x, y)) continue;\n\t\t\t\t\t// Increment our hit count for percentage based targetting\n\t\t\t\t\thitCount++;\n\t\t\t\t\t// If we target on touch or hit our required percentage\n\t\t\t\t\tif (percentage === 0 || Math.roundDecimals(hitCount / pointCount, 1) >= percentage) {\n\t\t\t\t\t\t// Mark the token as selected\n\t\t\t\t\t\ttoken.setTarget(true, { user: game.user, releaseOthers: false, groupSelection: true });\n\t\t\t\t\t\tif (!DebugMode) {\n\t\t\t\t\t\t\tpointFound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (DebugMode) pointGraphics.endFill();\n\t\t}\n\t}\n}\n","\n\nenum OutCode {\n\tINSIDE = 0x0000,\n\tLEFT = 0x0001,\n\tRIGHT = 0x0010,\n\tBOTTOM = 0x0100,\n\tTOP = 0x1000\n}\n/**\n * Uses the highly optimized Cohen–Sutherland algorithm for detecting if a line segment passes through a rectangle on a 2D plane.\n * https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm\n */\nexport default class LineToBoxCollision {\n\tprivate static _computeOutCode(x: number, y: number, bounds: { left: number, right: number, top: number, bottom: number }): OutCode {\n\t\tlet code: OutCode;\n\t\tcode = OutCode.INSIDE;          // initialised as being inside of [[clip window]]\n\t\tif (x <= bounds.left)           // to the left of clip window\n\t\t\tcode |= OutCode.LEFT;\n\t\telse if (x >= bounds.right)      // to the right of clip window\n\t\t\tcode |= OutCode.RIGHT;\n\t\tif (y <= bounds.top)           // below the clip window\n\t\t\tcode |= OutCode.BOTTOM;\n\t\telse if (y >= bounds.bottom)      // above the clip window\n\t\t\tcode |= OutCode.TOP;\n\t\treturn code;\n\t}\n\n\t// Cohen–Sutherland clipping algorithm clips a line from\n\t// P0 = (x0, y0) to P1 = (x1, y1) against a rectangle with \n\t// diagonal from (left, top) to (right, bottom).\n\tstatic cohenSutherlandLineClipAndDraw(x0: number, y0: number, x1: number, y1: number,\n\t\tbounds: { left: number, right: number, top: number, bottom: number }): boolean {\n\t\t// compute outcodes for P0, P1, and whatever point lies outside the clip rectangle\n\t\tlet outcode0: OutCode = this._computeOutCode(x0, y0, bounds);\n\t\tlet outcode1: OutCode = this._computeOutCode(x1, y1, bounds);\n\t\tlet accept = false;\n\n\t\twhile (true) {\n\t\t\tif (!(outcode0 | outcode1)) {\n\t\t\t\t// bitwise OR is 0: both points inside window; trivially accept and exit loop\n\t\t\t\taccept = true;\n\t\t\t\tbreak;\n\t\t\t} else if (outcode0 & outcode1) {\n\t\t\t\t// bitwise AND is not 0: both points share an outside zone (LEFT, RIGHT, TOP,\n\t\t\t\t// or BOTTOM), so both must be outside window; exit loop (accept is false)\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// failed both tests, so calculate the line segment to clip\n\t\t\t\t// from an outside point to an intersection with clip edge\n\t\t\t\tlet [x, y] = [0, 0];\n\n\t\t\t\t// At least one endpoint is outside the clip rectangle; pick it.\n\t\t\t\tconst outcodeOut: OutCode = outcode1 > outcode0 ? outcode1 : outcode0;\n\n\t\t\t\t// Now find the intersection point;\n\t\t\t\t// use formulas:\n\t\t\t\t//   slope = (y1 - y0) / (x1 - x0)\n\t\t\t\t//   x = x0 + (1 / slope) * (ym - y0), where ym is top or bottom\n\t\t\t\t//   y = y0 + slope * (xm - x0), where xm is left or right\n\t\t\t\t// No need to worry about divide-by-zero because, in each case, the\n\t\t\t\t// outcode bit being tested guarantees the denominator is non-zero\n\t\t\t\tif (outcodeOut & OutCode.TOP) {           // point is above the clip window\n\t\t\t\t\tx = x0 + (x1 - x0) * (bounds.bottom - y0) / (y1 - y0);\n\t\t\t\t\ty = bounds.bottom - 1;\n\t\t\t\t} else if (outcodeOut & OutCode.BOTTOM) { // point is below the clip window\n\t\t\t\t\tx = x0 + (x1 - x0) * (bounds.top - y0) / (y1 - y0);\n\t\t\t\t\ty = bounds.top + 1;\n\t\t\t\t} else if (outcodeOut & OutCode.RIGHT) {  // point is to the right of clip window\n\t\t\t\t\ty = y0 + (y1 - y0) * (bounds.right - x0) / (x1 - x0);\n\t\t\t\t\tx = bounds.right - 1;\n\t\t\t\t} else if (outcodeOut & OutCode.LEFT) {   // point is to the left of clip window\n\t\t\t\t\ty = y0 + (y1 - y0) * (bounds.left - x0) / (x1 - x0);\n\t\t\t\t\tx = bounds.left + 1;\n\t\t\t\t}\n\n\t\t\t\t// Now we move outside point to intersection point to clip\n\t\t\t\t// and get ready for next pass.\n\t\t\t\tif (outcodeOut == outcode0) {\n\t\t\t\t\tx0 = x;\n\t\t\t\t\ty0 = y;\n\t\t\t\t\toutcode0 = this._computeOutCode(x0, y0, bounds);\n\t\t\t\t} else {\n\t\t\t\t\tx1 = x;\n\t\t\t\t\ty1 = y;\n\t\t\t\t\toutcode1 = this._computeOutCode(x1, y1, bounds);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn accept;\n\t}\n}","import SETTINGS from \"../../common/Settings\";\n\n\ninterface Option {\n\ttype?: string;\n\tlabel: string;\n\tdesc: string;\n}\n\ninterface Config {\n\tcircle: string;\n\tcone: string;\n\trect: string;\n\tray: string;\n}\n\ninterface Data extends Config {\n\toptions: Option[];\n}\n\nexport enum HighlightMode {\n\tCENTER = 'center',\n\tTOUCH = 'touch',\n\tPOINTS = 'points'\n}\n\nexport class TemplateConfig extends FormApplication<any, Data> {\n\tprivate static readonly CONFIG_PREF = 'template-config';\n\tprivate static readonly PATCH_5E_PREF = \"template-targeting-patch5e\";\n\tprivate static readonly PATCH_5E_CIRCLE_PREF = \"template-targeting-patch5e-circle\";\n\tprivate static _options: Option[];\n\tprivate static get options(): Option[] {\n\t\tif (!this._options) {\n\t\t\tconst root: Record<string, Option> =\n\t\t\t\t<any>(game.i18n.translations['DF_TEMPLATES'] ?? (game.i18n as any)._fallback['DF_TEMPLATES'])['TemplateConfig']['Options'];\n\t\t\tthis._options = Object.keys(root).map(key => {\n\t\t\t\troot[key].type = key;\n\t\t\t\treturn root[key];\n\t\t\t});\n\t\t}\n\t\treturn this._options;\n\t}\n\n\tstatic get defaultOptions(): FormApplication.Options {\n\t\tconst options = mergeObject(super.defaultOptions, {\n\t\t\tresizable: false,\n\t\t\tsubmitOnChange: false,\n\t\t\tcloseOnSubmit: true,\n\t\t\teditable: true,\n\t\t\tsubmitOnClose: false,\n\t\t\twidth: 500,\n\t\t\tpopOut: true,\n\t\t\tminimizable: false,\n\t\t\ttitle: 'DF_TEMPLATES.TemplateConfig.Title',\n\t\t\ttemplate: 'modules/df-templates/templates/template-config.hbs'\n\t\t});\n\t\treturn options;\n\t}\n\n\tstatic get config(): Config { return SETTINGS.get(this.CONFIG_PREF); }\n\tstatic get isNotDefault(): boolean {\n\t\tconst config = this.config;\n\t\treturn config.circle !== HighlightMode.CENTER\n\t\t\t|| config.cone !== HighlightMode.CENTER\n\t\t\t|| config.rect !== HighlightMode.CENTER\n\t\t\t|| config.ray !== HighlightMode.CENTER;\n\t}\n\n\tstatic init() {\n\t\tSETTINGS.register(this.PATCH_5E_PREF, {\n\t\t\tconfig: false,\n\t\t\ttype: Boolean,\n\t\t\tdefault: false,\n\t\t\tscope: 'world'\n\t\t});\n\t\tSETTINGS.register(this.PATCH_5E_CIRCLE_PREF, {\n\t\t\tconfig: false,\n\t\t\ttype: Boolean,\n\t\t\tdefault: false,\n\t\t\tscope: 'world'\n\t\t});\n\n\t\tconst old5ePatch = SETTINGS.get<boolean>(this.PATCH_5E_PREF);\n\t\tconst old5eCirclePatch = SETTINGS.get<boolean>(this.PATCH_5E_CIRCLE_PREF);\n\n\t\tSETTINGS.register<Config>(this.CONFIG_PREF, {\n\t\t\tconfig: false,\n\t\t\tscope: 'world',\n\t\t\ttype: <any>Object,\n\t\t\tdefault: {\n\t\t\t\tcircle: old5eCirclePatch ? HighlightMode.TOUCH : HighlightMode.CENTER,\n\t\t\t\tcone: old5ePatch ? HighlightMode.TOUCH : HighlightMode.CENTER,\n\t\t\t\trect: old5ePatch ? HighlightMode.TOUCH : HighlightMode.CENTER,\n\t\t\t\tray: old5ePatch ? HighlightMode.TOUCH : HighlightMode.CENTER\n\t\t\t},\n\t\t\tonChange: () => canvas.templates?.placeables.filter((t: MeasuredTemplate) => t.data.t === \"circle\")\n\t\t\t\t.forEach((t: MeasuredTemplate) => t.draw())\n\t\t});\n\n\t\tSETTINGS.registerMenu('template-config', {\n\t\t\trestricted: true,\n\t\t\ttype: TemplateConfig,\n\t\t\tlabel: \"DF_TEMPLATES.TemplateConfig.Title\"\n\t\t});\n\t}\n\n\tgetData(_options?: Partial<any>): Data | Promise<Data> {\n\t\tconst data = mergeObject(TemplateConfig.config, {\n\t\t\toptions: TemplateConfig.options\n\t\t});\n\t\treturn data;\n\t}\n\n\tactivateListeners(html: JQuery<HTMLElement>): void {\n\t\thtml.find('#dfte-set-foundry').on('click', e => {\n\t\t\te.preventDefault();\n\t\t\thtml.find(`select[name=\"circle\"]`).val(HighlightMode.CENTER);\n\t\t\thtml.find(`select[name=\"cone\"]`).val(HighlightMode.CENTER);\n\t\t\thtml.find(`select[name=\"rect\"]`).val(HighlightMode.CENTER);\n\t\t\thtml.find(`select[name=\"ray\"]`).val(HighlightMode.CENTER);\n\t\t});\n\t\thtml.find('#dfte-set-dnd5e').on('click', e => {\n\t\t\te.preventDefault();\n\t\t\thtml.find(`select[name=\"circle\"]`).val(HighlightMode.CENTER);\n\t\t\thtml.find(`select[name=\"cone\"]`).val(HighlightMode.TOUCH);\n\t\t\thtml.find(`select[name=\"rect\"]`).val(HighlightMode.TOUCH);\n\t\t\thtml.find(`select[name=\"ray\"]`).val(HighlightMode.TOUCH);\n\t\t});\n\t\thtml.find('#cancel').on('click', e => {\n\t\t\te.preventDefault();\n\t\t\tthis.close();\n\t\t});\n\t}\n\n\tprotected async _updateObject(_event: Event, formData?: any): Promise<void> {\n\t\tawait SETTINGS.set(TemplateConfig.CONFIG_PREF, formData);\n\t}\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import SETTINGS from \"../../common/Settings\";\nimport AngleSnaps from \"./AngleSnaps\";\nimport DnD5eAbilityTemplateHandlers from \"./DnD5eAbilityTemplateHandlers\";\nimport SnapIntersect from \"./SnapIntersect\";\nimport SquareTemplate from \"./SquareTemplate\";\nimport TemplateTargeting from \"./TemplateTargeting\";\n\nSETTINGS.init('df-templates');\n\nHooks.once('init', function () {\n\tTemplateTargeting.init();\n\tSnapIntersect.init();\n\tAngleSnaps.init();\n\tSquareTemplate.init();\n\n\t// DEBUG SETTINGS\n\tSETTINGS.register('template-debug', {\n\t\tconfig: true,\n\t\tscope: 'client',\n\t\tname: 'DF_TEMPLATES.DebugName',\n\t\thint: 'DF_TEMPLATES.DebugHint',\n\t\ttype: Boolean,\n\t\tdefault: false\n\t});\n});\n\nHooks.once('ready', function () {\n\tif (!game.modules.get('lib-wrapper')?.active) {\n\t\tconsole.error('Missing libWrapper module dependency');\n\t\tif (game.user.isGM)\n\t\t\tui.notifications.error(game.i18n.localize('DF-QOL.errorLibWrapperMissing'));\n\t\treturn;\n\t}\n\tTemplateTargeting.ready();\n\tSnapIntersect.ready();\n\tAngleSnaps.ready();\n\n\tif ((game as any).dnd5e) {\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'game.dnd5e.canvas.AbilityTemplate.prototype.activatePreviewListeners',\n\t\t\tfunction (this: any, initialLayer: CanvasLayer) {\n\t\t\t\tconst handlers: DnD5eAbilityTemplateHandlers = {};\n\n\t\t\t\t/***************** THIS IS COPIED FROM THE DnD 5e CODE BASE `AbilityTemplate.prototype.activatePreviewListeners` ***************/\n\t\t\t\t// Cancel the workflow (right-click)\n\t\t\t\thandlers.rc = event => {\n\t\t\t\t\tthis.layer._onDragLeftCancel(event);\n\t\t\t\t\tcanvas.stage.off(\"mousemove\", handlers.mm);\n\t\t\t\t\tcanvas.stage.off(\"mousedown\", handlers.lc);\n\t\t\t\t\tcanvas.app.view.oncontextmenu = null;\n\t\t\t\t\tcanvas.app.view.onwheel = null;\n\t\t\t\t\tinitialLayer.activate();\n\t\t\t\t\tthis.actorSheet?.maximize();\n\t\t\t\t};\n\t\t\t\t// Confirm the workflow (left-click)\n\t\t\t\thandlers.lc = event => {\n\t\t\t\t\thandlers.rc(event);\n\t\t\t\t\tconst destination = canvas.grid.getSnappedPosition(this.data.x, this.data.y, 2);\n\t\t\t\t\tthis.data.update(destination);\n\t\t\t\t\tcanvas.scene.createEmbeddedDocuments(\"MeasuredTemplate\", [this.data]);\n\t\t\t\t};\n\t\t\t\t/***************** END OF COPY ***************/\n\n\t\t\t\tSnapIntersect.handleDnD5eAbilityTemplate(this, handlers);\n\t\t\t\tAngleSnaps.handleDnD5eAbilityTemplate(this, handlers);\n\n\t\t\t\t/***************** THIS IS COPIED FROM THE DnD 5e CODE BASE `AbilityTemplate.prototype.activatePreviewListeners` ***************/\n\t\t\t\tcanvas.stage.on(\"mousemove\", handlers.mm);\n\t\t\t\tcanvas.stage.on(\"mousedown\", handlers.lc);\n\t\t\t\tcanvas.app.view.oncontextmenu = handlers.rc;\n\t\t\t\tcanvas.app.view.onwheel = handlers.mw;\n\t\t\t\t/***************** END OF COPY ***************/\n\t\t\t}, 'OVERRIDE');\n\t}\n});\n"],"names":["SETTINGS","static","moduleName","this","MOD_NAME","String","prototype","localize","game","i18n","valueOf","key","config","settings","register","registerMenu","get","value","set","default","Object","AngleSnaps","scope","name","hint","type","Number","range","min","max","step","libWrapper","event","template","_hover","snap","shiftKey","sign","Math","deltaY","delta","direction","data","rotate","abilityTemplate","handlers","mw","ctrlKey","preventDefault","stopPropagation","update","refresh","SnapIntersect","Boolean","onChange","toggled","patch","unpatch","TemplateLayer_gridPrecision","unregister","canvas","grid","CONST","GRID_TYPES","GRIDLESS","moveTime","mm","now","Date","center","getLocalPosition","layer","snapped","getSnappedPosition","x","y","SquareTemplate","FIX_ROTATION_PREF","MeasuredTemplate_getRectShape","MeasuredTemplate_refreshRulerText","distance","adjustForRoundingError","matrix","PIXI","Matrix","IDENTITY","PI","EPSILON","size","sqrt","topLeft","apply","Point","topRight","botLeft","botRight","shape","Polygon","width","height","wrapped","t","text","toFixed","scene","gridUnits","hud","ruler","TemplateTargeting","TemplateConfig","TARGETING_TOGGLE_PREF","TARGETING_MODE_PREF","choices","never","toggle","always","ui","controls","initialize","render","GRIDLESS_RESOLUTION_PREF","GRIDLESS_PERCENTAGE_PREF","PREVIEW_PREF","Hooks","on","find","tools","splice","icon","title","visible","active","onClick","_MeasuredTemplate_highlightGrid","wrapper","MeasuredTemplate","manager","callbacks","dragLeftCancel","PlaceableObject","_onDragLeftCancel","ThrottledTemplateRefresh","throttle","fn","threshhold","last","mostRecent","hasTimer","args","context","setTimeout","dnd5e","handleTemplateCreation","getHighlightLayer","clear","addChild","PointGraphContainer","mode","shouldAutoSelect","isOwner","document","author","id","userId","tokens","objects","user","targets","setTarget","releaseOthers","groupSelection","_handleTouchTemplate","bind","points","radius","shapeBounds","left","MAX_VALUE","right","MIN_VALUE","top","bottom","c","length","snappedTopLeft","snappedBottomRight","d","dimensions","border","borderColor","color","fillColor","DEBUG","hl","clone","map","p","i","error","highlightGridPosition","_selectTokensByPointContainment","_calculateGridTestArea","colCount","ceil","w","rowCount","h","tx","ty","getTopLeft","row0","col0","getGridPositionFromPixels","hx","hy","angle","toRadians","isRound","rayLength","sin","ax1","ay1","bx1","by1","ax2","ay2","bx2","by2","coneInitialized","generateConeData","cos","generateRayData","r","gx","gy","getPixelsFromGridPosition","testX","testY","testRect","NormalizedRectangle","contains","rcx","rcy","HighlightMode","sqrDistance","vx","vy","testPoint","rect","_getRectShape","e","mag","vecAngle","testAngle","acos","minAngle","maxAngle","Error","message","includes","token","placeables","tokenRect","useMultiPointTest","DebugMode","pointGraphics","removeChildren","Graphics","pointResolution","tokenX","tokenY","horPoints","roundDecimals","verPoints","floor","horStep","verStep","pointFound","beginFill","percentage","pointCount","hitCount","row","col","drawCircle","endFill","OutCode","LineToBoxCollision","bounds","code","INSIDE","LEFT","RIGHT","BOTTOM","TOP","x0","y0","x1","y1","outcode0","_computeOutCode","outcode1","accept","outcodeOut","FormApplication","options","_options","root","translations","_fallback","keys","defaultOptions","mergeObject","super","resizable","submitOnChange","closeOnSubmit","editable","submitOnClose","popOut","minimizable","CONFIG_PREF","isNotDefault","circle","CENTER","cone","ray","PATCH_5E_PREF","PATCH_5E_CIRCLE_PREF","old5ePatch","old5eCirclePatch","TOUCH","templates","filter","forEach","draw","restricted","label","getData","activateListeners","html","val","close","async","_event","formData","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","definition","o","defineProperty","enumerable","obj","prop","hasOwnProperty","call","Symbol","toStringTag","once","modules","console","isGM","notifications","initialLayer","rc","stage","off","lc","app","view","oncontextmenu","onwheel","activate","actorSheet","maximize","destination","createEmbeddedDocuments"],"sourceRoot":""}