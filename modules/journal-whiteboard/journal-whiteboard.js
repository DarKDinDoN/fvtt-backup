function N7(t, e) {
  for (var n = 0; n < e.length; n++) {
    const r = e[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const a in r)
        if (a !== "default" && !(a in t)) {
          const s = Object.getOwnPropertyDescriptor(r, a);
          s && Object.defineProperty(t, a, s.get ? s : {
            enumerable: !0,
            get: () => r[a]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
const Nu = "journal-whiteboard", xw = "Journal Whiteboard";
class L7 {
  constructor(e) {
    this.debugSettings = e;
  }
  log(...e) {
    this.debugSettings.debug && console.log(`${xw} |`, ...e);
  }
  info(...e) {
    this.debugSettings.debug && ui.notifications.info(`${xw} | ${e.join(" ")}`);
  }
  error(...e) {
    this.debugSettings.debug && ui.notifications.error(`${xw} | ${e.join(" ")}`);
  }
  warn(...e) {
    this.debugSettings.debug && ui.notifications.warn(`${xw} | ${e.join(" ")}`);
  }
}
class j7 {
  registerSettings() {
    game.settings.register(Nu, "debug", {
      name: game.i18n.localize("JW.Debug"),
      hint: game.i18n.localize("JW.DebugHint"),
      scope: "world",
      config: !0,
      default: !1,
      type: Boolean
    });
  }
  get debug() {
    return game.settings.get(Nu, "debug");
  }
}
let vT, zr;
const z7 = {
  hooks: {
    init() {
      vT = new j7(), vT.registerSettings(), zr = new L7(vT);
    }
  }
}, U7 = (t) => {
  const e = {};
  for (const [n, r] of Object.entries(t))
    e[n] = {
      get() {
        return game.i18n.localize(r);
      }
    };
  return Object.defineProperties(t, e);
}, B7 = U7({
  light: "JW.ThemeLight",
  dark: "JW.ThemeDark"
});
class F7 {
  registerSettings() {
    game.settings.register(Nu, "theme", {
      name: game.i18n.localize("JW.Theme"),
      hint: game.i18n.localize("JW.ThemeHint"),
      scope: "world",
      config: !0,
      default: "light",
      choices: B7,
      type: String
    });
  }
  get theme() {
    return game.settings.get(Nu, "theme");
  }
}
let jk;
const H7 = {
  hooks: {
    init() {
      jk = new F7(), jk.registerSettings();
    }
  }
};
class V7 extends foundry.abstract.TypeDataModel {
  static defineSchema() {
    const e = foundry.data.fields;
    return {
      whiteboard: new e.JSONField()
    };
  }
}
var da = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function jp(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var zk = { exports: {} }, _y = {}, Uk = { exports: {} }, Tn = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var CA;
function Y7() {
  if (CA)
    return Tn;
  CA = 1;
  var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), c = Symbol.for("react.context"), f = Symbol.for("react.forward_ref"), p = Symbol.for("react.suspense"), g = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), v = Symbol.iterator;
  function S(W) {
    return W === null || typeof W != "object" ? null : (W = v && W[v] || W["@@iterator"], typeof W == "function" ? W : null);
  }
  var x = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, _ = Object.assign, T = {};
  function I(W, fe, ce) {
    this.props = W, this.context = fe, this.refs = T, this.updater = ce || x;
  }
  I.prototype.isReactComponent = {}, I.prototype.setState = function(W, fe) {
    if (typeof W != "object" && typeof W != "function" && W != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, W, fe, "setState");
  }, I.prototype.forceUpdate = function(W) {
    this.updater.enqueueForceUpdate(this, W, "forceUpdate");
  };
  function D() {
  }
  D.prototype = I.prototype;
  function N(W, fe, ce) {
    this.props = W, this.context = fe, this.refs = T, this.updater = ce || x;
  }
  var j = N.prototype = new D();
  j.constructor = N, _(j, I.prototype), j.isPureReactComponent = !0;
  var L = Array.isArray, z = Object.prototype.hasOwnProperty, F = { current: null }, K = { key: !0, ref: !0, __self: !0, __source: !0 };
  function X(W, fe, ce) {
    var xe, $e = {}, Me = null, re = null;
    if (fe != null)
      for (xe in fe.ref !== void 0 && (re = fe.ref), fe.key !== void 0 && (Me = "" + fe.key), fe)
        z.call(fe, xe) && !K.hasOwnProperty(xe) && ($e[xe] = fe[xe]);
    var Qe = arguments.length - 2;
    if (Qe === 1)
      $e.children = ce;
    else if (1 < Qe) {
      for (var ke = Array(Qe), rt = 0; rt < Qe; rt++)
        ke[rt] = arguments[rt + 2];
      $e.children = ke;
    }
    if (W && W.defaultProps)
      for (xe in Qe = W.defaultProps, Qe)
        $e[xe] === void 0 && ($e[xe] = Qe[xe]);
    return { $$typeof: t, type: W, key: Me, ref: re, props: $e, _owner: F.current };
  }
  function se(W, fe) {
    return { $$typeof: t, type: W.type, key: fe, ref: W.ref, props: W.props, _owner: W._owner };
  }
  function ue(W) {
    return typeof W == "object" && W !== null && W.$$typeof === t;
  }
  function pe(W) {
    var fe = { "=": "=0", ":": "=2" };
    return "$" + W.replace(/[=:]/g, function(ce) {
      return fe[ce];
    });
  }
  var Pe = /\/+/g;
  function ve(W, fe) {
    return typeof W == "object" && W !== null && W.key != null ? pe("" + W.key) : fe.toString(36);
  }
  function Y(W, fe, ce, xe, $e) {
    var Me = typeof W;
    (Me === "undefined" || Me === "boolean") && (W = null);
    var re = !1;
    if (W === null)
      re = !0;
    else
      switch (Me) {
        case "string":
        case "number":
          re = !0;
          break;
        case "object":
          switch (W.$$typeof) {
            case t:
            case e:
              re = !0;
          }
      }
    if (re)
      return re = W, $e = $e(re), W = xe === "" ? "." + ve(re, 0) : xe, L($e) ? (ce = "", W != null && (ce = W.replace(Pe, "$&/") + "/"), Y($e, fe, ce, "", function(rt) {
        return rt;
      })) : $e != null && (ue($e) && ($e = se($e, ce + (!$e.key || re && re.key === $e.key ? "" : ("" + $e.key).replace(Pe, "$&/") + "/") + W)), fe.push($e)), 1;
    if (re = 0, xe = xe === "" ? "." : xe + ":", L(W))
      for (var Qe = 0; Qe < W.length; Qe++) {
        Me = W[Qe];
        var ke = xe + ve(Me, Qe);
        re += Y(Me, fe, ce, ke, $e);
      }
    else if (ke = S(W), typeof ke == "function")
      for (W = ke.call(W), Qe = 0; !(Me = W.next()).done; )
        Me = Me.value, ke = xe + ve(Me, Qe++), re += Y(Me, fe, ce, ke, $e);
    else if (Me === "object")
      throw fe = String(W), Error("Objects are not valid as a React child (found: " + (fe === "[object Object]" ? "object with keys {" + Object.keys(W).join(", ") + "}" : fe) + "). If you meant to render a collection of children, use an array instead.");
    return re;
  }
  function le(W, fe, ce) {
    if (W == null)
      return W;
    var xe = [], $e = 0;
    return Y(W, xe, "", "", function(Me) {
      return fe.call(ce, Me, $e++);
    }), xe;
  }
  function Re(W) {
    if (W._status === -1) {
      var fe = W._result;
      fe = fe(), fe.then(function(ce) {
        (W._status === 0 || W._status === -1) && (W._status = 1, W._result = ce);
      }, function(ce) {
        (W._status === 0 || W._status === -1) && (W._status = 2, W._result = ce);
      }), W._status === -1 && (W._status = 0, W._result = fe);
    }
    if (W._status === 1)
      return W._result.default;
    throw W._result;
  }
  var he = { current: null }, te = { transition: null }, de = { ReactCurrentDispatcher: he, ReactCurrentBatchConfig: te, ReactCurrentOwner: F };
  return Tn.Children = { map: le, forEach: function(W, fe, ce) {
    le(W, function() {
      fe.apply(this, arguments);
    }, ce);
  }, count: function(W) {
    var fe = 0;
    return le(W, function() {
      fe++;
    }), fe;
  }, toArray: function(W) {
    return le(W, function(fe) {
      return fe;
    }) || [];
  }, only: function(W) {
    if (!ue(W))
      throw Error("React.Children.only expected to receive a single React element child.");
    return W;
  } }, Tn.Component = I, Tn.Fragment = n, Tn.Profiler = a, Tn.PureComponent = N, Tn.StrictMode = r, Tn.Suspense = p, Tn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = de, Tn.cloneElement = function(W, fe, ce) {
    if (W == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + W + ".");
    var xe = _({}, W.props), $e = W.key, Me = W.ref, re = W._owner;
    if (fe != null) {
      if (fe.ref !== void 0 && (Me = fe.ref, re = F.current), fe.key !== void 0 && ($e = "" + fe.key), W.type && W.type.defaultProps)
        var Qe = W.type.defaultProps;
      for (ke in fe)
        z.call(fe, ke) && !K.hasOwnProperty(ke) && (xe[ke] = fe[ke] === void 0 && Qe !== void 0 ? Qe[ke] : fe[ke]);
    }
    var ke = arguments.length - 2;
    if (ke === 1)
      xe.children = ce;
    else if (1 < ke) {
      Qe = Array(ke);
      for (var rt = 0; rt < ke; rt++)
        Qe[rt] = arguments[rt + 2];
      xe.children = Qe;
    }
    return { $$typeof: t, type: W.type, key: $e, ref: Me, props: xe, _owner: re };
  }, Tn.createContext = function(W) {
    return W = { $$typeof: c, _currentValue: W, _currentValue2: W, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, W.Provider = { $$typeof: s, _context: W }, W.Consumer = W;
  }, Tn.createElement = X, Tn.createFactory = function(W) {
    var fe = X.bind(null, W);
    return fe.type = W, fe;
  }, Tn.createRef = function() {
    return { current: null };
  }, Tn.forwardRef = function(W) {
    return { $$typeof: f, render: W };
  }, Tn.isValidElement = ue, Tn.lazy = function(W) {
    return { $$typeof: y, _payload: { _status: -1, _result: W }, _init: Re };
  }, Tn.memo = function(W, fe) {
    return { $$typeof: g, type: W, compare: fe === void 0 ? null : fe };
  }, Tn.startTransition = function(W) {
    var fe = te.transition;
    te.transition = {};
    try {
      W();
    } finally {
      te.transition = fe;
    }
  }, Tn.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  }, Tn.useCallback = function(W, fe) {
    return he.current.useCallback(W, fe);
  }, Tn.useContext = function(W) {
    return he.current.useContext(W);
  }, Tn.useDebugValue = function() {
  }, Tn.useDeferredValue = function(W) {
    return he.current.useDeferredValue(W);
  }, Tn.useEffect = function(W, fe) {
    return he.current.useEffect(W, fe);
  }, Tn.useId = function() {
    return he.current.useId();
  }, Tn.useImperativeHandle = function(W, fe, ce) {
    return he.current.useImperativeHandle(W, fe, ce);
  }, Tn.useInsertionEffect = function(W, fe) {
    return he.current.useInsertionEffect(W, fe);
  }, Tn.useLayoutEffect = function(W, fe) {
    return he.current.useLayoutEffect(W, fe);
  }, Tn.useMemo = function(W, fe) {
    return he.current.useMemo(W, fe);
  }, Tn.useReducer = function(W, fe, ce) {
    return he.current.useReducer(W, fe, ce);
  }, Tn.useRef = function(W) {
    return he.current.useRef(W);
  }, Tn.useState = function(W) {
    return he.current.useState(W);
  }, Tn.useSyncExternalStore = function(W, fe, ce) {
    return he.current.useSyncExternalStore(W, fe, ce);
  }, Tn.useTransition = function() {
    return he.current.useTransition();
  }, Tn.version = "18.2.0", Tn;
}
var Ny = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Ny.exports;
var _A;
function K7() {
  return _A || (_A = 1, function(t, e) {
    ({}).NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var n = "18.2.0", r = Symbol.for("react.element"), a = Symbol.for("react.portal"), s = Symbol.for("react.fragment"), c = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), p = Symbol.for("react.provider"), g = Symbol.for("react.context"), y = Symbol.for("react.forward_ref"), v = Symbol.for("react.suspense"), S = Symbol.for("react.suspense_list"), x = Symbol.for("react.memo"), _ = Symbol.for("react.lazy"), T = Symbol.for("react.offscreen"), I = Symbol.iterator, D = "@@iterator";
      function N(U) {
        if (U === null || typeof U != "object")
          return null;
        var Z = I && U[I] || U[D];
        return typeof Z == "function" ? Z : null;
      }
      var j = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, L = {
        transition: null
      }, z = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, F = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, K = {}, X = null;
      function se(U) {
        X = U;
      }
      K.setExtraStackFrame = function(U) {
        X = U;
      }, K.getCurrentStack = null, K.getStackAddendum = function() {
        var U = "";
        X && (U += X);
        var Z = K.getCurrentStack;
        return Z && (U += Z() || ""), U;
      };
      var ue = !1, pe = !1, Pe = !1, ve = !1, Y = !1, le = {
        ReactCurrentDispatcher: j,
        ReactCurrentBatchConfig: L,
        ReactCurrentOwner: F
      };
      le.ReactDebugCurrentFrame = K, le.ReactCurrentActQueue = z;
      function Re(U) {
        {
          for (var Z = arguments.length, ye = new Array(Z > 1 ? Z - 1 : 0), Ee = 1; Ee < Z; Ee++)
            ye[Ee - 1] = arguments[Ee];
          te("warn", U, ye);
        }
      }
      function he(U) {
        {
          for (var Z = arguments.length, ye = new Array(Z > 1 ? Z - 1 : 0), Ee = 1; Ee < Z; Ee++)
            ye[Ee - 1] = arguments[Ee];
          te("error", U, ye);
        }
      }
      function te(U, Z, ye) {
        {
          var Ee = le.ReactDebugCurrentFrame, Fe = Ee.getStackAddendum();
          Fe !== "" && (Z += "%s", ye = ye.concat([Fe]));
          var ht = ye.map(function(Ze) {
            return String(Ze);
          });
          ht.unshift("Warning: " + Z), Function.prototype.apply.call(console[U], console, ht);
        }
      }
      var de = {};
      function W(U, Z) {
        {
          var ye = U.constructor, Ee = ye && (ye.displayName || ye.name) || "ReactClass", Fe = Ee + "." + Z;
          if (de[Fe])
            return;
          he("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", Z, Ee), de[Fe] = !0;
        }
      }
      var fe = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(U) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(U, Z, ye) {
          W(U, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(U, Z, ye, Ee) {
          W(U, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(U, Z, ye, Ee) {
          W(U, "setState");
        }
      }, ce = Object.assign, xe = {};
      Object.freeze(xe);
      function $e(U, Z, ye) {
        this.props = U, this.context = Z, this.refs = xe, this.updater = ye || fe;
      }
      $e.prototype.isReactComponent = {}, $e.prototype.setState = function(U, Z) {
        if (typeof U != "object" && typeof U != "function" && U != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, U, Z, "setState");
      }, $e.prototype.forceUpdate = function(U) {
        this.updater.enqueueForceUpdate(this, U, "forceUpdate");
      };
      {
        var Me = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, re = function(U, Z) {
          Object.defineProperty($e.prototype, U, {
            get: function() {
              Re("%s(...) is deprecated in plain JavaScript React classes. %s", Z[0], Z[1]);
            }
          });
        };
        for (var Qe in Me)
          Me.hasOwnProperty(Qe) && re(Qe, Me[Qe]);
      }
      function ke() {
      }
      ke.prototype = $e.prototype;
      function rt(U, Z, ye) {
        this.props = U, this.context = Z, this.refs = xe, this.updater = ye || fe;
      }
      var St = rt.prototype = new ke();
      St.constructor = rt, ce(St, $e.prototype), St.isPureReactComponent = !0;
      function Tt() {
        var U = {
          current: null
        };
        return Object.seal(U), U;
      }
      var Le = Array.isArray;
      function Nt(U) {
        return Le(U);
      }
      function Ke(U) {
        {
          var Z = typeof Symbol == "function" && Symbol.toStringTag, ye = Z && U[Symbol.toStringTag] || U.constructor.name || "Object";
          return ye;
        }
      }
      function yt(U) {
        try {
          return Xt(U), !1;
        } catch {
          return !0;
        }
      }
      function Xt(U) {
        return "" + U;
      }
      function kt(U) {
        if (yt(U))
          return he("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ke(U)), Xt(U);
      }
      function yn(U, Z, ye) {
        var Ee = U.displayName;
        if (Ee)
          return Ee;
        var Fe = Z.displayName || Z.name || "";
        return Fe !== "" ? ye + "(" + Fe + ")" : ye;
      }
      function Er(U) {
        return U.displayName || "Context";
      }
      function tn(U) {
        if (U == null)
          return null;
        if (typeof U.tag == "number" && he("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof U == "function")
          return U.displayName || U.name || null;
        if (typeof U == "string")
          return U;
        switch (U) {
          case s:
            return "Fragment";
          case a:
            return "Portal";
          case f:
            return "Profiler";
          case c:
            return "StrictMode";
          case v:
            return "Suspense";
          case S:
            return "SuspenseList";
        }
        if (typeof U == "object")
          switch (U.$$typeof) {
            case g:
              var Z = U;
              return Er(Z) + ".Consumer";
            case p:
              var ye = U;
              return Er(ye._context) + ".Provider";
            case y:
              return yn(U, U.render, "ForwardRef");
            case x:
              var Ee = U.displayName || null;
              return Ee !== null ? Ee : tn(U.type) || "Memo";
            case _: {
              var Fe = U, ht = Fe._payload, Ze = Fe._init;
              try {
                return tn(Ze(ht));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var Mr = Object.prototype.hasOwnProperty, Ur = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, Hn, xt, cn;
      cn = {};
      function ni(U) {
        if (Mr.call(U, "ref")) {
          var Z = Object.getOwnPropertyDescriptor(U, "ref").get;
          if (Z && Z.isReactWarning)
            return !1;
        }
        return U.ref !== void 0;
      }
      function An(U) {
        if (Mr.call(U, "key")) {
          var Z = Object.getOwnPropertyDescriptor(U, "key").get;
          if (Z && Z.isReactWarning)
            return !1;
        }
        return U.key !== void 0;
      }
      function qn(U, Z) {
        var ye = function() {
          Hn || (Hn = !0, he("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Z));
        };
        ye.isReactWarning = !0, Object.defineProperty(U, "key", {
          get: ye,
          configurable: !0
        });
      }
      function Go(U, Z) {
        var ye = function() {
          xt || (xt = !0, he("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Z));
        };
        ye.isReactWarning = !0, Object.defineProperty(U, "ref", {
          get: ye,
          configurable: !0
        });
      }
      function Cr(U) {
        if (typeof U.ref == "string" && F.current && U.__self && F.current.stateNode !== U.__self) {
          var Z = tn(F.current.type);
          cn[Z] || (he('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Z, U.ref), cn[Z] = !0);
        }
      }
      var Je = function(U, Z, ye, Ee, Fe, ht, Ze) {
        var bt = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: r,
          // Built-in properties that belong on the element
          type: U,
          key: Z,
          ref: ye,
          props: Ze,
          // Record the component responsible for creating this element.
          _owner: ht
        };
        return bt._store = {}, Object.defineProperty(bt._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(bt, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Ee
        }), Object.defineProperty(bt, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Fe
        }), Object.freeze && (Object.freeze(bt.props), Object.freeze(bt)), bt;
      };
      function Et(U, Z, ye) {
        var Ee, Fe = {}, ht = null, Ze = null, bt = null, Yt = null;
        if (Z != null) {
          ni(Z) && (Ze = Z.ref, Cr(Z)), An(Z) && (kt(Z.key), ht = "" + Z.key), bt = Z.__self === void 0 ? null : Z.__self, Yt = Z.__source === void 0 ? null : Z.__source;
          for (Ee in Z)
            Mr.call(Z, Ee) && !Ur.hasOwnProperty(Ee) && (Fe[Ee] = Z[Ee]);
        }
        var gn = arguments.length - 2;
        if (gn === 1)
          Fe.children = ye;
        else if (gn > 1) {
          for (var Ln = Array(gn), In = 0; In < gn; In++)
            Ln[In] = arguments[In + 2];
          Object.freeze && Object.freeze(Ln), Fe.children = Ln;
        }
        if (U && U.defaultProps) {
          var ar = U.defaultProps;
          for (Ee in ar)
            Fe[Ee] === void 0 && (Fe[Ee] = ar[Ee]);
        }
        if (ht || Ze) {
          var dr = typeof U == "function" ? U.displayName || U.name || "Unknown" : U;
          ht && qn(Fe, dr), Ze && Go(Fe, dr);
        }
        return Je(U, ht, Ze, bt, Yt, F.current, Fe);
      }
      function nn(U, Z) {
        var ye = Je(U.type, Z, U.ref, U._self, U._source, U._owner, U.props);
        return ye;
      }
      function kn(U, Z, ye) {
        if (U == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + U + ".");
        var Ee, Fe = ce({}, U.props), ht = U.key, Ze = U.ref, bt = U._self, Yt = U._source, gn = U._owner;
        if (Z != null) {
          ni(Z) && (Ze = Z.ref, gn = F.current), An(Z) && (kt(Z.key), ht = "" + Z.key);
          var Ln;
          U.type && U.type.defaultProps && (Ln = U.type.defaultProps);
          for (Ee in Z)
            Mr.call(Z, Ee) && !Ur.hasOwnProperty(Ee) && (Z[Ee] === void 0 && Ln !== void 0 ? Fe[Ee] = Ln[Ee] : Fe[Ee] = Z[Ee]);
        }
        var In = arguments.length - 2;
        if (In === 1)
          Fe.children = ye;
        else if (In > 1) {
          for (var ar = Array(In), dr = 0; dr < In; dr++)
            ar[dr] = arguments[dr + 2];
          Fe.children = ar;
        }
        return Je(U.type, ht, Ze, bt, Yt, gn, Fe);
      }
      function xn(U) {
        return typeof U == "object" && U !== null && U.$$typeof === r;
      }
      var _r = ".", ur = ":";
      function mi(U) {
        var Z = /[=:]/g, ye = {
          "=": "=0",
          ":": "=2"
        }, Ee = U.replace(Z, function(Fe) {
          return ye[Fe];
        });
        return "$" + Ee;
      }
      var pn = !1, vi = /\/+/g;
      function On(U) {
        return U.replace(vi, "$&/");
      }
      function Dn(U, Z) {
        return typeof U == "object" && U !== null && U.key != null ? (kt(U.key), mi("" + U.key)) : Z.toString(36);
      }
      function ao(U, Z, ye, Ee, Fe) {
        var ht = typeof U;
        (ht === "undefined" || ht === "boolean") && (U = null);
        var Ze = !1;
        if (U === null)
          Ze = !0;
        else
          switch (ht) {
            case "string":
            case "number":
              Ze = !0;
              break;
            case "object":
              switch (U.$$typeof) {
                case r:
                case a:
                  Ze = !0;
              }
          }
        if (Ze) {
          var bt = U, Yt = Fe(bt), gn = Ee === "" ? _r + Dn(bt, 0) : Ee;
          if (Nt(Yt)) {
            var Ln = "";
            gn != null && (Ln = On(gn) + "/"), ao(Yt, Z, Ln, "", function(bm) {
              return bm;
            });
          } else
            Yt != null && (xn(Yt) && (Yt.key && (!bt || bt.key !== Yt.key) && kt(Yt.key), Yt = nn(
              Yt,
              // Keep both the (mapped) and old keys if they differ, just as
              // traverseAllChildren used to do for objects as children
              ye + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
              (Yt.key && (!bt || bt.key !== Yt.key) ? (
                // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                // eslint-disable-next-line react-internal/safe-string-coercion
                On("" + Yt.key) + "/"
              ) : "") + gn
            )), Z.push(Yt));
          return 1;
        }
        var In, ar, dr = 0, Sn = Ee === "" ? _r : Ee + ur;
        if (Nt(U))
          for (var tl = 0; tl < U.length; tl++)
            In = U[tl], ar = Sn + Dn(In, tl), dr += ao(In, Z, ye, ar, Fe);
        else {
          var Ku = N(U);
          if (typeof Ku == "function") {
            var mf = U;
            Ku === mf.entries && (pn || Re("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), pn = !0);
            for (var ym = Ku.call(mf), es, vf = 0; !(es = ym.next()).done; )
              In = es.value, ar = Sn + Dn(In, vf++), dr += ao(In, Z, ye, ar, Fe);
          } else if (ht === "object") {
            var yf = String(U);
            throw new Error("Objects are not valid as a React child (found: " + (yf === "[object Object]" ? "object with keys {" + Object.keys(U).join(", ") + "}" : yf) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return dr;
      }
      function yi(U, Z, ye) {
        if (U == null)
          return U;
        var Ee = [], Fe = 0;
        return ao(U, Ee, "", "", function(ht) {
          return Z.call(ye, ht, Fe++);
        }), Ee;
      }
      function Sa(U) {
        var Z = 0;
        return yi(U, function() {
          Z++;
        }), Z;
      }
      function Qa(U, Z, ye) {
        yi(U, function() {
          Z.apply(this, arguments);
        }, ye);
      }
      function vs(U) {
        return yi(U, function(Z) {
          return Z;
        }) || [];
      }
      function so(U) {
        if (!xn(U))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return U;
      }
      function ys(U) {
        var Z = {
          $$typeof: g,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: U,
          _currentValue2: U,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        Z.Provider = {
          $$typeof: p,
          _context: Z
        };
        var ye = !1, Ee = !1, Fe = !1;
        {
          var ht = {
            $$typeof: g,
            _context: Z
          };
          Object.defineProperties(ht, {
            Provider: {
              get: function() {
                return Ee || (Ee = !0, he("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), Z.Provider;
              },
              set: function(Ze) {
                Z.Provider = Ze;
              }
            },
            _currentValue: {
              get: function() {
                return Z._currentValue;
              },
              set: function(Ze) {
                Z._currentValue = Ze;
              }
            },
            _currentValue2: {
              get: function() {
                return Z._currentValue2;
              },
              set: function(Ze) {
                Z._currentValue2 = Ze;
              }
            },
            _threadCount: {
              get: function() {
                return Z._threadCount;
              },
              set: function(Ze) {
                Z._threadCount = Ze;
              }
            },
            Consumer: {
              get: function() {
                return ye || (ye = !0, he("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), Z.Consumer;
              }
            },
            displayName: {
              get: function() {
                return Z.displayName;
              },
              set: function(Ze) {
                Fe || (Re("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", Ze), Fe = !0);
              }
            }
          }), Z.Consumer = ht;
        }
        return Z._currentRenderer = null, Z._currentRenderer2 = null, Z;
      }
      var lo = -1, wa = 0, co = 1, xa = 2;
      function bi(U) {
        if (U._status === lo) {
          var Z = U._result, ye = Z();
          if (ye.then(function(ht) {
            if (U._status === wa || U._status === lo) {
              var Ze = U;
              Ze._status = co, Ze._result = ht;
            }
          }, function(ht) {
            if (U._status === wa || U._status === lo) {
              var Ze = U;
              Ze._status = xa, Ze._result = ht;
            }
          }), U._status === lo) {
            var Ee = U;
            Ee._status = wa, Ee._result = ye;
          }
        }
        if (U._status === co) {
          var Fe = U._result;
          return Fe === void 0 && he(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, Fe), "default" in Fe || he(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, Fe), Fe.default;
        } else
          throw U._result;
      }
      function Mi(U) {
        var Z = {
          // We use these fields to store the result.
          _status: lo,
          _result: U
        }, ye = {
          $$typeof: _,
          _payload: Z,
          _init: bi
        };
        {
          var Ee, Fe;
          Object.defineProperties(ye, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return Ee;
              },
              set: function(ht) {
                he("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Ee = ht, Object.defineProperty(ye, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return Fe;
              },
              set: function(ht) {
                he("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Fe = ht, Object.defineProperty(ye, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return ye;
      }
      function Si(U) {
        U != null && U.$$typeof === x ? he("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof U != "function" ? he("forwardRef requires a render function but was given %s.", U === null ? "null" : typeof U) : U.length !== 0 && U.length !== 2 && he("forwardRef render functions accept exactly two parameters: props and ref. %s", U.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), U != null && (U.defaultProps != null || U.propTypes != null) && he("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var Z = {
          $$typeof: y,
          render: U
        };
        {
          var ye;
          Object.defineProperty(Z, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return ye;
            },
            set: function(Ee) {
              ye = Ee, !U.name && !U.displayName && (U.displayName = Ee);
            }
          });
        }
        return Z;
      }
      var J;
      J = Symbol.for("react.module.reference");
      function Be(U) {
        return !!(typeof U == "string" || typeof U == "function" || U === s || U === f || Y || U === c || U === v || U === S || ve || U === T || ue || pe || Pe || typeof U == "object" && U !== null && (U.$$typeof === _ || U.$$typeof === x || U.$$typeof === p || U.$$typeof === g || U.$$typeof === y || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        U.$$typeof === J || U.getModuleId !== void 0));
      }
      function et(U, Z) {
        Be(U) || he("memo: The first argument must be a component. Instead received: %s", U === null ? "null" : typeof U);
        var ye = {
          $$typeof: x,
          type: U,
          compare: Z === void 0 ? null : Z
        };
        {
          var Ee;
          Object.defineProperty(ye, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return Ee;
            },
            set: function(Fe) {
              Ee = Fe, !U.name && !U.displayName && (U.displayName = Fe);
            }
          });
        }
        return ye;
      }
      function st() {
        var U = j.current;
        return U === null && he(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), U;
      }
      function Kt(U) {
        var Z = st();
        if (U._context !== void 0) {
          var ye = U._context;
          ye.Consumer === U ? he("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : ye.Provider === U && he("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return Z.useContext(U);
      }
      function qt(U) {
        var Z = st();
        return Z.useState(U);
      }
      function Qt(U, Z, ye) {
        var Ee = st();
        return Ee.useReducer(U, Z, ye);
      }
      function Rt(U) {
        var Z = st();
        return Z.useRef(U);
      }
      function Br(U, Z) {
        var ye = st();
        return ye.useEffect(U, Z);
      }
      function Qn(U, Z) {
        var ye = st();
        return ye.useInsertionEffect(U, Z);
      }
      function Zn(U, Z) {
        var ye = st();
        return ye.useLayoutEffect(U, Z);
      }
      function hr(U, Z) {
        var ye = st();
        return ye.useCallback(U, Z);
      }
      function Ea(U, Z) {
        var ye = st();
        return ye.useMemo(U, Z);
      }
      function jl(U, Z, ye) {
        var Ee = st();
        return Ee.useImperativeHandle(U, Z, ye);
      }
      function bn(U, Z) {
        {
          var ye = st();
          return ye.useDebugValue(U, Z);
        }
      }
      function hf() {
        var U = st();
        return U.useTransition();
      }
      function Xo(U) {
        var Z = st();
        return Z.useDeferredValue(U);
      }
      function Jt() {
        var U = st();
        return U.useId();
      }
      function Ca(U, Z, ye) {
        var Ee = st();
        return Ee.useSyncExternalStore(U, Z, ye);
      }
      var bs = 0, uo, Ss, Wi, jc, Ai, zc, Uc;
      function Qs() {
      }
      Qs.__reactDisabledLog = !0;
      function zl() {
        {
          if (bs === 0) {
            uo = console.log, Ss = console.info, Wi = console.warn, jc = console.error, Ai = console.group, zc = console.groupCollapsed, Uc = console.groupEnd;
            var U = {
              configurable: !0,
              enumerable: !0,
              value: Qs,
              writable: !0
            };
            Object.defineProperties(console, {
              info: U,
              log: U,
              warn: U,
              error: U,
              group: U,
              groupCollapsed: U,
              groupEnd: U
            });
          }
          bs++;
        }
      }
      function Po() {
        {
          if (bs--, bs === 0) {
            var U = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: ce({}, U, {
                value: uo
              }),
              info: ce({}, U, {
                value: Ss
              }),
              warn: ce({}, U, {
                value: Wi
              }),
              error: ce({}, U, {
                value: jc
              }),
              group: ce({}, U, {
                value: Ai
              }),
              groupCollapsed: ce({}, U, {
                value: zc
              }),
              groupEnd: ce({}, U, {
                value: Uc
              })
            });
          }
          bs < 0 && he("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var Io = le.ReactCurrentDispatcher, wi;
      function ws(U, Z, ye) {
        {
          if (wi === void 0)
            try {
              throw Error();
            } catch (Fe) {
              var Ee = Fe.stack.trim().match(/\n( *(at )?)/);
              wi = Ee && Ee[1] || "";
            }
          return `
` + wi + U;
        }
      }
      var xs = !1, Es;
      {
        var Ul = typeof WeakMap == "function" ? WeakMap : Map;
        Es = new Ul();
      }
      function Zs(U, Z) {
        if (!U || xs)
          return "";
        {
          var ye = Es.get(U);
          if (ye !== void 0)
            return ye;
        }
        var Ee;
        xs = !0;
        var Fe = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var ht;
        ht = Io.current, Io.current = null, zl();
        try {
          if (Z) {
            var Ze = function() {
              throw Error();
            };
            if (Object.defineProperty(Ze.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Ze, []);
              } catch (Sn) {
                Ee = Sn;
              }
              Reflect.construct(U, [], Ze);
            } else {
              try {
                Ze.call();
              } catch (Sn) {
                Ee = Sn;
              }
              U.call(Ze.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Sn) {
              Ee = Sn;
            }
            U();
          }
        } catch (Sn) {
          if (Sn && Ee && typeof Sn.stack == "string") {
            for (var bt = Sn.stack.split(`
`), Yt = Ee.stack.split(`
`), gn = bt.length - 1, Ln = Yt.length - 1; gn >= 1 && Ln >= 0 && bt[gn] !== Yt[Ln]; )
              Ln--;
            for (; gn >= 1 && Ln >= 0; gn--, Ln--)
              if (bt[gn] !== Yt[Ln]) {
                if (gn !== 1 || Ln !== 1)
                  do
                    if (gn--, Ln--, Ln < 0 || bt[gn] !== Yt[Ln]) {
                      var In = `
` + bt[gn].replace(" at new ", " at ");
                      return U.displayName && In.includes("<anonymous>") && (In = In.replace("<anonymous>", U.displayName)), typeof U == "function" && Es.set(U, In), In;
                    }
                  while (gn >= 1 && Ln >= 0);
                break;
              }
          }
        } finally {
          xs = !1, Io.current = ht, Po(), Error.prepareStackTrace = Fe;
        }
        var ar = U ? U.displayName || U.name : "", dr = ar ? ws(ar) : "";
        return typeof U == "function" && Es.set(U, dr), dr;
      }
      function Za(U, Z, ye) {
        return Zs(U, !1);
      }
      function gf(U) {
        var Z = U.prototype;
        return !!(Z && Z.isReactComponent);
      }
      function qo(U, Z, ye) {
        if (U == null)
          return "";
        if (typeof U == "function")
          return Zs(U, gf(U));
        if (typeof U == "string")
          return ws(U);
        switch (U) {
          case v:
            return ws("Suspense");
          case S:
            return ws("SuspenseList");
        }
        if (typeof U == "object")
          switch (U.$$typeof) {
            case y:
              return Za(U.render);
            case x:
              return qo(U.type, Z, ye);
            case _: {
              var Ee = U, Fe = Ee._payload, ht = Ee._init;
              try {
                return qo(ht(Fe), Z, ye);
              } catch {
              }
            }
          }
        return "";
      }
      var hn = {}, Qo = le.ReactDebugCurrentFrame;
      function Js(U) {
        if (U) {
          var Z = U._owner, ye = qo(U.type, U._source, Z ? Z.type : null);
          Qo.setExtraStackFrame(ye);
        } else
          Qo.setExtraStackFrame(null);
      }
      function Bl(U, Z, ye, Ee, Fe) {
        {
          var ht = Function.call.bind(Mr);
          for (var Ze in U)
            if (ht(U, Ze)) {
              var bt = void 0;
              try {
                if (typeof U[Ze] != "function") {
                  var Yt = Error((Ee || "React class") + ": " + ye + " type `" + Ze + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof U[Ze] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Yt.name = "Invariant Violation", Yt;
                }
                bt = U[Ze](Z, Ze, Ee, ye, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (gn) {
                bt = gn;
              }
              bt && !(bt instanceof Error) && (Js(Fe), he("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ee || "React class", ye, Ze, typeof bt), Js(null)), bt instanceof Error && !(bt.message in hn) && (hn[bt.message] = !0, Js(Fe), he("Failed %s type: %s", ye, bt.message), Js(null));
            }
        }
      }
      function rn(U) {
        if (U) {
          var Z = U._owner, ye = qo(U.type, U._source, Z ? Z.type : null);
          se(ye);
        } else
          se(null);
      }
      var Fl;
      Fl = !1;
      function Hl() {
        if (F.current) {
          var U = tn(F.current.type);
          if (U)
            return `

Check the render method of \`` + U + "`.";
        }
        return "";
      }
      function Ft(U) {
        if (U !== void 0) {
          var Z = U.fileName.replace(/^.*[\\\/]/, ""), ye = U.lineNumber;
          return `

Check your code at ` + Z + ":" + ye + ".";
        }
        return "";
      }
      function el(U) {
        return U != null ? Ft(U.__source) : "";
      }
      var gr = {};
      function Fr(U) {
        var Z = Hl();
        if (!Z) {
          var ye = typeof U == "string" ? U : U.displayName || U.name;
          ye && (Z = `

Check the top-level render call using <` + ye + ">.");
        }
        return Z;
      }
      function xi(U, Z) {
        if (!(!U._store || U._store.validated || U.key != null)) {
          U._store.validated = !0;
          var ye = Fr(Z);
          if (!gr[ye]) {
            gr[ye] = !0;
            var Ee = "";
            U && U._owner && U._owner !== F.current && (Ee = " It was passed a child from " + tn(U._owner.type) + "."), rn(U), he('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ye, Ee), rn(null);
          }
        }
      }
      function Cs(U, Z) {
        if (typeof U == "object") {
          if (Nt(U))
            for (var ye = 0; ye < U.length; ye++) {
              var Ee = U[ye];
              xn(Ee) && xi(Ee, Z);
            }
          else if (xn(U))
            U._store && (U._store.validated = !0);
          else if (U) {
            var Fe = N(U);
            if (typeof Fe == "function" && Fe !== U.entries)
              for (var ht = Fe.call(U), Ze; !(Ze = ht.next()).done; )
                xn(Ze.value) && xi(Ze.value, Z);
          }
        }
      }
      function or(U) {
        {
          var Z = U.type;
          if (Z == null || typeof Z == "string")
            return;
          var ye;
          if (typeof Z == "function")
            ye = Z.propTypes;
          else if (typeof Z == "object" && (Z.$$typeof === y || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          Z.$$typeof === x))
            ye = Z.propTypes;
          else
            return;
          if (ye) {
            var Ee = tn(Z);
            Bl(ye, U.props, "prop", Ee, U);
          } else if (Z.PropTypes !== void 0 && !Fl) {
            Fl = !0;
            var Fe = tn(Z);
            he("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Fe || "Unknown");
          }
          typeof Z.getDefaultProps == "function" && !Z.getDefaultProps.isReactClassApproved && he("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function Nn(U) {
        {
          for (var Z = Object.keys(U.props), ye = 0; ye < Z.length; ye++) {
            var Ee = Z[ye];
            if (Ee !== "children" && Ee !== "key") {
              rn(U), he("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ee), rn(null);
              break;
            }
          }
          U.ref !== null && (rn(U), he("Invalid attribute `ref` supplied to `React.Fragment`."), rn(null));
        }
      }
      function Vl(U, Z, ye) {
        var Ee = Be(U);
        if (!Ee) {
          var Fe = "";
          (U === void 0 || typeof U == "object" && U !== null && Object.keys(U).length === 0) && (Fe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var ht = el(Z);
          ht ? Fe += ht : Fe += Hl();
          var Ze;
          U === null ? Ze = "null" : Nt(U) ? Ze = "array" : U !== void 0 && U.$$typeof === r ? (Ze = "<" + (tn(U.type) || "Unknown") + " />", Fe = " Did you accidentally export a JSX literal instead of a component?") : Ze = typeof U, he("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ze, Fe);
        }
        var bt = Et.apply(this, arguments);
        if (bt == null)
          return bt;
        if (Ee)
          for (var Yt = 2; Yt < arguments.length; Yt++)
            Cs(arguments[Yt], U);
        return U === s ? Nn(bt) : or(bt), bt;
      }
      var Gi = !1;
      function Gr(U) {
        var Z = Vl.bind(null, U);
        return Z.type = U, Gi || (Gi = !0, Re("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(Z, "type", {
          enumerable: !1,
          get: function() {
            return Re("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: U
            }), U;
          }
        }), Z;
      }
      function Zo(U, Z, ye) {
        for (var Ee = kn.apply(this, arguments), Fe = 2; Fe < arguments.length; Fe++)
          Cs(arguments[Fe], Ee.type);
        return or(Ee), Ee;
      }
      function Bc(U, Z) {
        var ye = L.transition;
        L.transition = {};
        var Ee = L.transition;
        L.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          U();
        } finally {
          if (L.transition = ye, ye === null && Ee._updatedFibers) {
            var Fe = Ee._updatedFibers.size;
            Fe > 10 && Re("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), Ee._updatedFibers.clear();
          }
        }
      }
      var fo = !1, Ja = null;
      function Yu(U) {
        if (Ja === null)
          try {
            var Z = ("require" + Math.random()).slice(0, 7), ye = t && t[Z];
            Ja = ye.call(t, "timers").setImmediate;
          } catch {
            Ja = function(Fe) {
              fo === !1 && (fo = !0, typeof MessageChannel > "u" && he("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var ht = new MessageChannel();
              ht.port1.onmessage = Fe, ht.port2.postMessage(void 0);
            };
          }
        return Ja(U);
      }
      var Ro = 0, _s = !1;
      function q(U) {
        {
          var Z = Ro;
          Ro++, z.current === null && (z.current = []);
          var ye = z.isBatchingLegacy, Ee;
          try {
            if (z.isBatchingLegacy = !0, Ee = U(), !ye && z.didScheduleLegacyUpdate) {
              var Fe = z.current;
              Fe !== null && (z.didScheduleLegacyUpdate = !1, Pn(Fe));
            }
          } catch (ar) {
            throw ie(Z), ar;
          } finally {
            z.isBatchingLegacy = ye;
          }
          if (Ee !== null && typeof Ee == "object" && typeof Ee.then == "function") {
            var ht = Ee, Ze = !1, bt = {
              then: function(ar, dr) {
                Ze = !0, ht.then(function(Sn) {
                  ie(Z), Ro === 0 ? Ue(Sn, ar, dr) : ar(Sn);
                }, function(Sn) {
                  ie(Z), dr(Sn);
                });
              }
            };
            return !_s && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              Ze || (_s = !0, he("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), bt;
          } else {
            var Yt = Ee;
            if (ie(Z), Ro === 0) {
              var gn = z.current;
              gn !== null && (Pn(gn), z.current = null);
              var Ln = {
                then: function(ar, dr) {
                  z.current === null ? (z.current = [], Ue(Yt, ar, dr)) : ar(Yt);
                }
              };
              return Ln;
            } else {
              var In = {
                then: function(ar, dr) {
                  ar(Yt);
                }
              };
              return In;
            }
          }
        }
      }
      function ie(U) {
        U !== Ro - 1 && he("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), Ro = U;
      }
      function Ue(U, Z, ye) {
        {
          var Ee = z.current;
          if (Ee !== null)
            try {
              Pn(Ee), Yu(function() {
                Ee.length === 0 ? (z.current = null, Z(U)) : Ue(U, Z, ye);
              });
            } catch (Fe) {
              ye(Fe);
            }
          else
            Z(U);
        }
      }
      var it = !1;
      function Pn(U) {
        if (!it) {
          it = !0;
          var Z = 0;
          try {
            for (; Z < U.length; Z++) {
              var ye = U[Z];
              do
                ye = ye(!0);
              while (ye !== null);
            }
            U.length = 0;
          } catch (Ee) {
            throw U = U.slice(Z + 1), Ee;
          } finally {
            it = !1;
          }
        }
      }
      var Ut = Vl, Kn = Zo, Tr = Gr, Wn = {
        map: yi,
        forEach: Qa,
        count: Sa,
        toArray: vs,
        only: so
      };
      e.Children = Wn, e.Component = $e, e.Fragment = s, e.Profiler = f, e.PureComponent = rt, e.StrictMode = c, e.Suspense = v, e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = le, e.cloneElement = Kn, e.createContext = ys, e.createElement = Ut, e.createFactory = Tr, e.createRef = Tt, e.forwardRef = Si, e.isValidElement = xn, e.lazy = Mi, e.memo = et, e.startTransition = Bc, e.unstable_act = q, e.useCallback = hr, e.useContext = Kt, e.useDebugValue = bn, e.useDeferredValue = Xo, e.useEffect = Br, e.useId = Jt, e.useImperativeHandle = jl, e.useInsertionEffect = Qn, e.useLayoutEffect = Zn, e.useMemo = Ea, e.useReducer = Qt, e.useRef = Rt, e.useState = qt, e.useSyncExternalStore = Ca, e.useTransition = hf, e.version = n, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(Ny, Ny.exports)), Ny.exports;
}
({}).NODE_ENV === "production" ? Uk.exports = Y7() : Uk.exports = K7();
var k = Uk.exports;
const It = /* @__PURE__ */ jp(k), W7 = /* @__PURE__ */ N7({
  __proto__: null,
  default: It
}, [k]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var TA;
function G7() {
  if (TA)
    return _y;
  TA = 1;
  var t = k, e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, a = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function c(f, p, g) {
    var y, v = {}, S = null, x = null;
    g !== void 0 && (S = "" + g), p.key !== void 0 && (S = "" + p.key), p.ref !== void 0 && (x = p.ref);
    for (y in p)
      r.call(p, y) && !s.hasOwnProperty(y) && (v[y] = p[y]);
    if (f && f.defaultProps)
      for (y in p = f.defaultProps, p)
        v[y] === void 0 && (v[y] = p[y]);
    return { $$typeof: e, type: f, key: S, ref: x, props: v, _owner: a.current };
  }
  return _y.Fragment = n, _y.jsx = c, _y.jsxs = c, _y;
}
var Ty = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var kA;
function X7() {
  return kA || (kA = 1, {}.NODE_ENV !== "production" && function() {
    var t = k, e = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), a = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), c = Symbol.for("react.provider"), f = Symbol.for("react.context"), p = Symbol.for("react.forward_ref"), g = Symbol.for("react.suspense"), y = Symbol.for("react.suspense_list"), v = Symbol.for("react.memo"), S = Symbol.for("react.lazy"), x = Symbol.for("react.offscreen"), _ = Symbol.iterator, T = "@@iterator";
    function I(J) {
      if (J === null || typeof J != "object")
        return null;
      var Be = _ && J[_] || J[T];
      return typeof Be == "function" ? Be : null;
    }
    var D = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function N(J) {
      {
        for (var Be = arguments.length, et = new Array(Be > 1 ? Be - 1 : 0), st = 1; st < Be; st++)
          et[st - 1] = arguments[st];
        j("error", J, et);
      }
    }
    function j(J, Be, et) {
      {
        var st = D.ReactDebugCurrentFrame, Kt = st.getStackAddendum();
        Kt !== "" && (Be += "%s", et = et.concat([Kt]));
        var qt = et.map(function(Qt) {
          return String(Qt);
        });
        qt.unshift("Warning: " + Be), Function.prototype.apply.call(console[J], console, qt);
      }
    }
    var L = !1, z = !1, F = !1, K = !1, X = !1, se;
    se = Symbol.for("react.module.reference");
    function ue(J) {
      return !!(typeof J == "string" || typeof J == "function" || J === r || J === s || X || J === a || J === g || J === y || K || J === x || L || z || F || typeof J == "object" && J !== null && (J.$$typeof === S || J.$$typeof === v || J.$$typeof === c || J.$$typeof === f || J.$$typeof === p || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      J.$$typeof === se || J.getModuleId !== void 0));
    }
    function pe(J, Be, et) {
      var st = J.displayName;
      if (st)
        return st;
      var Kt = Be.displayName || Be.name || "";
      return Kt !== "" ? et + "(" + Kt + ")" : et;
    }
    function Pe(J) {
      return J.displayName || "Context";
    }
    function ve(J) {
      if (J == null)
        return null;
      if (typeof J.tag == "number" && N("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof J == "function")
        return J.displayName || J.name || null;
      if (typeof J == "string")
        return J;
      switch (J) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case s:
          return "Profiler";
        case a:
          return "StrictMode";
        case g:
          return "Suspense";
        case y:
          return "SuspenseList";
      }
      if (typeof J == "object")
        switch (J.$$typeof) {
          case f:
            var Be = J;
            return Pe(Be) + ".Consumer";
          case c:
            var et = J;
            return Pe(et._context) + ".Provider";
          case p:
            return pe(J, J.render, "ForwardRef");
          case v:
            var st = J.displayName || null;
            return st !== null ? st : ve(J.type) || "Memo";
          case S: {
            var Kt = J, qt = Kt._payload, Qt = Kt._init;
            try {
              return ve(Qt(qt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Y = Object.assign, le = 0, Re, he, te, de, W, fe, ce;
    function xe() {
    }
    xe.__reactDisabledLog = !0;
    function $e() {
      {
        if (le === 0) {
          Re = console.log, he = console.info, te = console.warn, de = console.error, W = console.group, fe = console.groupCollapsed, ce = console.groupEnd;
          var J = {
            configurable: !0,
            enumerable: !0,
            value: xe,
            writable: !0
          };
          Object.defineProperties(console, {
            info: J,
            log: J,
            warn: J,
            error: J,
            group: J,
            groupCollapsed: J,
            groupEnd: J
          });
        }
        le++;
      }
    }
    function Me() {
      {
        if (le--, le === 0) {
          var J = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Y({}, J, {
              value: Re
            }),
            info: Y({}, J, {
              value: he
            }),
            warn: Y({}, J, {
              value: te
            }),
            error: Y({}, J, {
              value: de
            }),
            group: Y({}, J, {
              value: W
            }),
            groupCollapsed: Y({}, J, {
              value: fe
            }),
            groupEnd: Y({}, J, {
              value: ce
            })
          });
        }
        le < 0 && N("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var re = D.ReactCurrentDispatcher, Qe;
    function ke(J, Be, et) {
      {
        if (Qe === void 0)
          try {
            throw Error();
          } catch (Kt) {
            var st = Kt.stack.trim().match(/\n( *(at )?)/);
            Qe = st && st[1] || "";
          }
        return `
` + Qe + J;
      }
    }
    var rt = !1, St;
    {
      var Tt = typeof WeakMap == "function" ? WeakMap : Map;
      St = new Tt();
    }
    function Le(J, Be) {
      if (!J || rt)
        return "";
      {
        var et = St.get(J);
        if (et !== void 0)
          return et;
      }
      var st;
      rt = !0;
      var Kt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var qt;
      qt = re.current, re.current = null, $e();
      try {
        if (Be) {
          var Qt = function() {
            throw Error();
          };
          if (Object.defineProperty(Qt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Qt, []);
            } catch (bn) {
              st = bn;
            }
            Reflect.construct(J, [], Qt);
          } else {
            try {
              Qt.call();
            } catch (bn) {
              st = bn;
            }
            J.call(Qt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (bn) {
            st = bn;
          }
          J();
        }
      } catch (bn) {
        if (bn && st && typeof bn.stack == "string") {
          for (var Rt = bn.stack.split(`
`), Br = st.stack.split(`
`), Qn = Rt.length - 1, Zn = Br.length - 1; Qn >= 1 && Zn >= 0 && Rt[Qn] !== Br[Zn]; )
            Zn--;
          for (; Qn >= 1 && Zn >= 0; Qn--, Zn--)
            if (Rt[Qn] !== Br[Zn]) {
              if (Qn !== 1 || Zn !== 1)
                do
                  if (Qn--, Zn--, Zn < 0 || Rt[Qn] !== Br[Zn]) {
                    var hr = `
` + Rt[Qn].replace(" at new ", " at ");
                    return J.displayName && hr.includes("<anonymous>") && (hr = hr.replace("<anonymous>", J.displayName)), typeof J == "function" && St.set(J, hr), hr;
                  }
                while (Qn >= 1 && Zn >= 0);
              break;
            }
        }
      } finally {
        rt = !1, re.current = qt, Me(), Error.prepareStackTrace = Kt;
      }
      var Ea = J ? J.displayName || J.name : "", jl = Ea ? ke(Ea) : "";
      return typeof J == "function" && St.set(J, jl), jl;
    }
    function Nt(J, Be, et) {
      return Le(J, !1);
    }
    function Ke(J) {
      var Be = J.prototype;
      return !!(Be && Be.isReactComponent);
    }
    function yt(J, Be, et) {
      if (J == null)
        return "";
      if (typeof J == "function")
        return Le(J, Ke(J));
      if (typeof J == "string")
        return ke(J);
      switch (J) {
        case g:
          return ke("Suspense");
        case y:
          return ke("SuspenseList");
      }
      if (typeof J == "object")
        switch (J.$$typeof) {
          case p:
            return Nt(J.render);
          case v:
            return yt(J.type, Be, et);
          case S: {
            var st = J, Kt = st._payload, qt = st._init;
            try {
              return yt(qt(Kt), Be, et);
            } catch {
            }
          }
        }
      return "";
    }
    var Xt = Object.prototype.hasOwnProperty, kt = {}, yn = D.ReactDebugCurrentFrame;
    function Er(J) {
      if (J) {
        var Be = J._owner, et = yt(J.type, J._source, Be ? Be.type : null);
        yn.setExtraStackFrame(et);
      } else
        yn.setExtraStackFrame(null);
    }
    function tn(J, Be, et, st, Kt) {
      {
        var qt = Function.call.bind(Xt);
        for (var Qt in J)
          if (qt(J, Qt)) {
            var Rt = void 0;
            try {
              if (typeof J[Qt] != "function") {
                var Br = Error((st || "React class") + ": " + et + " type `" + Qt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof J[Qt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Br.name = "Invariant Violation", Br;
              }
              Rt = J[Qt](Be, Qt, st, et, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Qn) {
              Rt = Qn;
            }
            Rt && !(Rt instanceof Error) && (Er(Kt), N("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", st || "React class", et, Qt, typeof Rt), Er(null)), Rt instanceof Error && !(Rt.message in kt) && (kt[Rt.message] = !0, Er(Kt), N("Failed %s type: %s", et, Rt.message), Er(null));
          }
      }
    }
    var Mr = Array.isArray;
    function Ur(J) {
      return Mr(J);
    }
    function Hn(J) {
      {
        var Be = typeof Symbol == "function" && Symbol.toStringTag, et = Be && J[Symbol.toStringTag] || J.constructor.name || "Object";
        return et;
      }
    }
    function xt(J) {
      try {
        return cn(J), !1;
      } catch {
        return !0;
      }
    }
    function cn(J) {
      return "" + J;
    }
    function ni(J) {
      if (xt(J))
        return N("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Hn(J)), cn(J);
    }
    var An = D.ReactCurrentOwner, qn = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Go, Cr, Je;
    Je = {};
    function Et(J) {
      if (Xt.call(J, "ref")) {
        var Be = Object.getOwnPropertyDescriptor(J, "ref").get;
        if (Be && Be.isReactWarning)
          return !1;
      }
      return J.ref !== void 0;
    }
    function nn(J) {
      if (Xt.call(J, "key")) {
        var Be = Object.getOwnPropertyDescriptor(J, "key").get;
        if (Be && Be.isReactWarning)
          return !1;
      }
      return J.key !== void 0;
    }
    function kn(J, Be) {
      if (typeof J.ref == "string" && An.current && Be && An.current.stateNode !== Be) {
        var et = ve(An.current.type);
        Je[et] || (N('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', ve(An.current.type), J.ref), Je[et] = !0);
      }
    }
    function xn(J, Be) {
      {
        var et = function() {
          Go || (Go = !0, N("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Be));
        };
        et.isReactWarning = !0, Object.defineProperty(J, "key", {
          get: et,
          configurable: !0
        });
      }
    }
    function _r(J, Be) {
      {
        var et = function() {
          Cr || (Cr = !0, N("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Be));
        };
        et.isReactWarning = !0, Object.defineProperty(J, "ref", {
          get: et,
          configurable: !0
        });
      }
    }
    var ur = function(J, Be, et, st, Kt, qt, Qt) {
      var Rt = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: J,
        key: Be,
        ref: et,
        props: Qt,
        // Record the component responsible for creating this element.
        _owner: qt
      };
      return Rt._store = {}, Object.defineProperty(Rt._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Rt, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: st
      }), Object.defineProperty(Rt, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Kt
      }), Object.freeze && (Object.freeze(Rt.props), Object.freeze(Rt)), Rt;
    };
    function mi(J, Be, et, st, Kt) {
      {
        var qt, Qt = {}, Rt = null, Br = null;
        et !== void 0 && (ni(et), Rt = "" + et), nn(Be) && (ni(Be.key), Rt = "" + Be.key), Et(Be) && (Br = Be.ref, kn(Be, Kt));
        for (qt in Be)
          Xt.call(Be, qt) && !qn.hasOwnProperty(qt) && (Qt[qt] = Be[qt]);
        if (J && J.defaultProps) {
          var Qn = J.defaultProps;
          for (qt in Qn)
            Qt[qt] === void 0 && (Qt[qt] = Qn[qt]);
        }
        if (Rt || Br) {
          var Zn = typeof J == "function" ? J.displayName || J.name || "Unknown" : J;
          Rt && xn(Qt, Zn), Br && _r(Qt, Zn);
        }
        return ur(J, Rt, Br, Kt, st, An.current, Qt);
      }
    }
    var pn = D.ReactCurrentOwner, vi = D.ReactDebugCurrentFrame;
    function On(J) {
      if (J) {
        var Be = J._owner, et = yt(J.type, J._source, Be ? Be.type : null);
        vi.setExtraStackFrame(et);
      } else
        vi.setExtraStackFrame(null);
    }
    var Dn;
    Dn = !1;
    function ao(J) {
      return typeof J == "object" && J !== null && J.$$typeof === e;
    }
    function yi() {
      {
        if (pn.current) {
          var J = ve(pn.current.type);
          if (J)
            return `

Check the render method of \`` + J + "`.";
        }
        return "";
      }
    }
    function Sa(J) {
      {
        if (J !== void 0) {
          var Be = J.fileName.replace(/^.*[\\\/]/, ""), et = J.lineNumber;
          return `

Check your code at ` + Be + ":" + et + ".";
        }
        return "";
      }
    }
    var Qa = {};
    function vs(J) {
      {
        var Be = yi();
        if (!Be) {
          var et = typeof J == "string" ? J : J.displayName || J.name;
          et && (Be = `

Check the top-level render call using <` + et + ">.");
        }
        return Be;
      }
    }
    function so(J, Be) {
      {
        if (!J._store || J._store.validated || J.key != null)
          return;
        J._store.validated = !0;
        var et = vs(Be);
        if (Qa[et])
          return;
        Qa[et] = !0;
        var st = "";
        J && J._owner && J._owner !== pn.current && (st = " It was passed a child from " + ve(J._owner.type) + "."), On(J), N('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', et, st), On(null);
      }
    }
    function ys(J, Be) {
      {
        if (typeof J != "object")
          return;
        if (Ur(J))
          for (var et = 0; et < J.length; et++) {
            var st = J[et];
            ao(st) && so(st, Be);
          }
        else if (ao(J))
          J._store && (J._store.validated = !0);
        else if (J) {
          var Kt = I(J);
          if (typeof Kt == "function" && Kt !== J.entries)
            for (var qt = Kt.call(J), Qt; !(Qt = qt.next()).done; )
              ao(Qt.value) && so(Qt.value, Be);
        }
      }
    }
    function lo(J) {
      {
        var Be = J.type;
        if (Be == null || typeof Be == "string")
          return;
        var et;
        if (typeof Be == "function")
          et = Be.propTypes;
        else if (typeof Be == "object" && (Be.$$typeof === p || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Be.$$typeof === v))
          et = Be.propTypes;
        else
          return;
        if (et) {
          var st = ve(Be);
          tn(et, J.props, "prop", st, J);
        } else if (Be.PropTypes !== void 0 && !Dn) {
          Dn = !0;
          var Kt = ve(Be);
          N("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Kt || "Unknown");
        }
        typeof Be.getDefaultProps == "function" && !Be.getDefaultProps.isReactClassApproved && N("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function wa(J) {
      {
        for (var Be = Object.keys(J.props), et = 0; et < Be.length; et++) {
          var st = Be[et];
          if (st !== "children" && st !== "key") {
            On(J), N("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", st), On(null);
            break;
          }
        }
        J.ref !== null && (On(J), N("Invalid attribute `ref` supplied to `React.Fragment`."), On(null));
      }
    }
    function co(J, Be, et, st, Kt, qt) {
      {
        var Qt = ue(J);
        if (!Qt) {
          var Rt = "";
          (J === void 0 || typeof J == "object" && J !== null && Object.keys(J).length === 0) && (Rt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Br = Sa(Kt);
          Br ? Rt += Br : Rt += yi();
          var Qn;
          J === null ? Qn = "null" : Ur(J) ? Qn = "array" : J !== void 0 && J.$$typeof === e ? (Qn = "<" + (ve(J.type) || "Unknown") + " />", Rt = " Did you accidentally export a JSX literal instead of a component?") : Qn = typeof J, N("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Qn, Rt);
        }
        var Zn = mi(J, Be, et, Kt, qt);
        if (Zn == null)
          return Zn;
        if (Qt) {
          var hr = Be.children;
          if (hr !== void 0)
            if (st)
              if (Ur(hr)) {
                for (var Ea = 0; Ea < hr.length; Ea++)
                  ys(hr[Ea], J);
                Object.freeze && Object.freeze(hr);
              } else
                N("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ys(hr, J);
        }
        return J === r ? wa(Zn) : lo(Zn), Zn;
      }
    }
    function xa(J, Be, et) {
      return co(J, Be, et, !0);
    }
    function bi(J, Be, et) {
      return co(J, Be, et, !1);
    }
    var Mi = bi, Si = xa;
    Ty.Fragment = r, Ty.jsx = Mi, Ty.jsxs = Si;
  }()), Ty;
}
({}).NODE_ENV === "production" ? zk.exports = G7() : zk.exports = X7();
var E = zk.exports, Ew = function(t) {
  return t && t.Math == Math && t;
}, Xa = (
  // eslint-disable-next-line es/no-global-this -- safe
  Ew(typeof globalThis == "object" && globalThis) || Ew(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  Ew(typeof self == "object" && self) || Ew(typeof da == "object" && da) || // eslint-disable-next-line no-new-func -- fallback
  function() {
    return this;
  }() || da || Function("return this")()
), KP = {}, ga = function(t) {
  try {
    return !!t();
  } catch {
    return !0;
  }
}, q7 = ga, sf = !q7(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
}), Q7 = ga, Zx = !Q7(function() {
  var t = function() {
  }.bind();
  return typeof t != "function" || t.hasOwnProperty("prototype");
}), Z7 = Zx, Cw = Function.prototype.call, lf = Z7 ? Cw.bind(Cw) : function() {
  return Cw.apply(Cw, arguments);
}, i3 = {}, o3 = {}.propertyIsEnumerable, a3 = Object.getOwnPropertyDescriptor, J7 = a3 && !o3.call({ 1: 2 }, 1);
i3.f = J7 ? function(e) {
  var n = a3(this, e);
  return !!n && n.enumerable;
} : o3;
var s3 = function(t, e) {
  return {
    enumerable: !(t & 1),
    configurable: !(t & 2),
    writable: !(t & 4),
    value: e
  };
}, l3 = Zx, c3 = Function.prototype, Bk = c3.call, e9 = l3 && c3.bind.bind(Bk, Bk), oo = l3 ? e9 : function(t) {
  return function() {
    return Bk.apply(t, arguments);
  };
}, u3 = oo, t9 = u3({}.toString), n9 = u3("".slice), rm = function(t) {
  return n9(t9(t), 8, -1);
}, r9 = oo, i9 = ga, o9 = rm, yT = Object, a9 = r9("".split), s9 = i9(function() {
  return !yT("z").propertyIsEnumerable(0);
}) ? function(t) {
  return o9(t) == "String" ? a9(t, "") : yT(t);
} : yT, Jx = function(t) {
  return t == null;
}, l9 = Jx, c9 = TypeError, im = function(t) {
  if (l9(t))
    throw c9("Can't call method on " + t);
  return t;
}, u9 = s9, d9 = im, e1 = function(t) {
  return u9(d9(t));
}, Fk = typeof document == "object" && document.all, f9 = typeof Fk > "u" && Fk !== void 0, d3 = {
  all: Fk,
  IS_HTMLDDA: f9
}, f3 = d3, p9 = f3.all, ma = f3.IS_HTMLDDA ? function(t) {
  return typeof t == "function" || t === p9;
} : function(t) {
  return typeof t == "function";
}, PA = ma, p3 = d3, h9 = p3.all, zp = p3.IS_HTMLDDA ? function(t) {
  return typeof t == "object" ? t !== null : PA(t) || t === h9;
} : function(t) {
  return typeof t == "object" ? t !== null : PA(t);
}, bT = Xa, g9 = ma, m9 = function(t) {
  return g9(t) ? t : void 0;
}, t1 = function(t, e) {
  return arguments.length < 2 ? m9(bT[t]) : bT[t] && bT[t][e];
}, v9 = oo, h3 = v9({}.isPrototypeOf), y9 = typeof navigator < "u" && String(navigator.userAgent) || "", g3 = Xa, ST = y9, IA = g3.process, RA = g3.Deno, $A = IA && IA.versions || RA && RA.version, MA = $A && $A.v8, Rl, yx;
MA && (Rl = MA.split("."), yx = Rl[0] > 0 && Rl[0] < 4 ? 1 : +(Rl[0] + Rl[1]));
!yx && ST && (Rl = ST.match(/Edge\/(\d+)/), (!Rl || Rl[1] >= 74) && (Rl = ST.match(/Chrome\/(\d+)/), Rl && (yx = +Rl[1])));
var b9 = yx, AA = b9, S9 = ga, w9 = Xa, x9 = w9.String, m3 = !!Object.getOwnPropertySymbols && !S9(function() {
  var t = Symbol();
  return !x9(t) || !(Object(t) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && AA && AA < 41;
}), E9 = m3, v3 = E9 && !Symbol.sham && typeof Symbol.iterator == "symbol", C9 = t1, _9 = ma, T9 = h3, k9 = v3, P9 = Object, y3 = k9 ? function(t) {
  return typeof t == "symbol";
} : function(t) {
  var e = C9("Symbol");
  return _9(e) && T9(e.prototype, P9(t));
}, I9 = String, R9 = function(t) {
  try {
    return I9(t);
  } catch {
    return "Object";
  }
}, $9 = ma, M9 = R9, A9 = TypeError, WP = function(t) {
  if ($9(t))
    return t;
  throw A9(M9(t) + " is not a function");
}, O9 = WP, D9 = Jx, GP = function(t, e) {
  var n = t[e];
  return D9(n) ? void 0 : O9(n);
}, wT = lf, xT = ma, ET = zp, N9 = TypeError, L9 = function(t, e) {
  var n, r;
  if (e === "string" && xT(n = t.toString) && !ET(r = wT(n, t)) || xT(n = t.valueOf) && !ET(r = wT(n, t)) || e !== "string" && xT(n = t.toString) && !ET(r = wT(n, t)))
    return r;
  throw N9("Can't convert object to primitive value");
}, b3 = { exports: {} }, OA = Xa, j9 = Object.defineProperty, XP = function(t, e) {
  try {
    j9(OA, t, { value: e, configurable: !0, writable: !0 });
  } catch {
    OA[t] = e;
  }
  return e;
}, z9 = Xa, U9 = XP, DA = "__core-js_shared__", B9 = z9[DA] || U9(DA, {}), qP = B9, NA = qP;
(b3.exports = function(t, e) {
  return NA[t] || (NA[t] = e !== void 0 ? e : {});
})("versions", []).push({
  version: "3.30.2",
  mode: "global",
  copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.30.2/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var QP = b3.exports, F9 = im, H9 = Object, gb = function(t) {
  return H9(F9(t));
}, V9 = oo, Y9 = gb, K9 = V9({}.hasOwnProperty), cf = Object.hasOwn || function(e, n) {
  return K9(Y9(e), n);
}, W9 = oo, G9 = 0, X9 = Math.random(), q9 = W9(1 .toString), S3 = function(t) {
  return "Symbol(" + (t === void 0 ? "" : t) + ")_" + q9(++G9 + X9, 36);
}, Q9 = Xa, Z9 = QP, LA = cf, J9 = S3, eH = m3, tH = v3, Bg = Q9.Symbol, CT = Z9("wks"), nH = tH ? Bg.for || Bg : Bg && Bg.withoutSetter || J9, Bu = function(t) {
  return LA(CT, t) || (CT[t] = eH && LA(Bg, t) ? Bg[t] : nH("Symbol." + t)), CT[t];
}, rH = lf, jA = zp, zA = y3, iH = GP, oH = L9, aH = Bu, sH = TypeError, lH = aH("toPrimitive"), cH = function(t, e) {
  if (!jA(t) || zA(t))
    return t;
  var n = iH(t, lH), r;
  if (n) {
    if (e === void 0 && (e = "default"), r = rH(n, t, e), !jA(r) || zA(r))
      return r;
    throw sH("Can't convert object to primitive value");
  }
  return e === void 0 && (e = "number"), oH(t, e);
}, uH = cH, dH = y3, w3 = function(t) {
  var e = uH(t, "string");
  return dH(e) ? e : e + "";
}, fH = Xa, UA = zp, Hk = fH.document, pH = UA(Hk) && UA(Hk.createElement), x3 = function(t) {
  return pH ? Hk.createElement(t) : {};
}, hH = sf, gH = ga, mH = x3, E3 = !hH && !gH(function() {
  return Object.defineProperty(mH("div"), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
}), vH = sf, yH = lf, bH = i3, SH = s3, wH = e1, xH = w3, EH = cf, CH = E3, BA = Object.getOwnPropertyDescriptor;
KP.f = vH ? BA : function(e, n) {
  if (e = wH(e), n = xH(n), CH)
    try {
      return BA(e, n);
    } catch {
    }
  if (EH(e, n))
    return SH(!yH(bH.f, e, n), e[n]);
};
var om = {}, _H = sf, TH = ga, C3 = _H && TH(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: !1
  }).prototype != 42;
}), kH = zp, PH = String, IH = TypeError, Up = function(t) {
  if (kH(t))
    return t;
  throw IH(PH(t) + " is not an object");
}, RH = sf, $H = E3, MH = C3, _w = Up, FA = w3, AH = TypeError, _T = Object.defineProperty, OH = Object.getOwnPropertyDescriptor, TT = "enumerable", kT = "configurable", PT = "writable";
om.f = RH ? MH ? function(e, n, r) {
  if (_w(e), n = FA(n), _w(r), typeof e == "function" && n === "prototype" && "value" in r && PT in r && !r[PT]) {
    var a = OH(e, n);
    a && a[PT] && (e[n] = r.value, r = {
      configurable: kT in r ? r[kT] : a[kT],
      enumerable: TT in r ? r[TT] : a[TT],
      writable: !1
    });
  }
  return _T(e, n, r);
} : _T : function(e, n, r) {
  if (_w(e), n = FA(n), _w(r), $H)
    try {
      return _T(e, n, r);
    } catch {
    }
  if ("get" in r || "set" in r)
    throw AH("Accessors not supported");
  return "value" in r && (e[n] = r.value), e;
};
var DH = sf, NH = om, LH = s3, ZP = DH ? function(t, e, n) {
  return NH.f(t, e, LH(1, n));
} : function(t, e, n) {
  return t[e] = n, t;
}, _3 = { exports: {} }, Vk = sf, jH = cf, T3 = Function.prototype, zH = Vk && Object.getOwnPropertyDescriptor, JP = jH(T3, "name"), UH = JP && function() {
}.name === "something", BH = JP && (!Vk || Vk && zH(T3, "name").configurable), FH = {
  EXISTS: JP,
  PROPER: UH,
  CONFIGURABLE: BH
}, HH = oo, VH = ma, Yk = qP, YH = HH(Function.toString);
VH(Yk.inspectSource) || (Yk.inspectSource = function(t) {
  return YH(t);
});
var k3 = Yk.inspectSource, KH = Xa, WH = ma, HA = KH.WeakMap, GH = WH(HA) && /native code/.test(String(HA)), XH = QP, qH = S3, VA = XH("keys"), P3 = function(t) {
  return VA[t] || (VA[t] = qH(t));
}, eI = {}, QH = GH, I3 = Xa, ZH = zp, JH = ZP, IT = cf, RT = qP, eV = P3, tV = eI, YA = "Object already initialized", Kk = I3.TypeError, nV = I3.WeakMap, bx, Gy, Sx, rV = function(t) {
  return Sx(t) ? Gy(t) : bx(t, {});
}, iV = function(t) {
  return function(e) {
    var n;
    if (!ZH(e) || (n = Gy(e)).type !== t)
      throw Kk("Incompatible receiver, " + t + " required");
    return n;
  };
};
if (QH || RT.state) {
  var wc = RT.state || (RT.state = new nV());
  wc.get = wc.get, wc.has = wc.has, wc.set = wc.set, bx = function(t, e) {
    if (wc.has(t))
      throw Kk(YA);
    return e.facade = t, wc.set(t, e), e;
  }, Gy = function(t) {
    return wc.get(t) || {};
  }, Sx = function(t) {
    return wc.has(t);
  };
} else {
  var kg = eV("state");
  tV[kg] = !0, bx = function(t, e) {
    if (IT(t, kg))
      throw Kk(YA);
    return e.facade = t, JH(t, kg, e), e;
  }, Gy = function(t) {
    return IT(t, kg) ? t[kg] : {};
  }, Sx = function(t) {
    return IT(t, kg);
  };
}
var R3 = {
  set: bx,
  get: Gy,
  has: Sx,
  enforce: rV,
  getterFor: iV
}, tI = oo, oV = ga, aV = ma, Tw = cf, Wk = sf, sV = FH.CONFIGURABLE, lV = k3, $3 = R3, cV = $3.enforce, uV = $3.get, KA = String, ax = Object.defineProperty, dV = tI("".slice), fV = tI("".replace), pV = tI([].join), hV = Wk && !oV(function() {
  return ax(function() {
  }, "length", { value: 8 }).length !== 8;
}), gV = String(String).split("String"), mV = _3.exports = function(t, e, n) {
  dV(KA(e), 0, 7) === "Symbol(" && (e = "[" + fV(KA(e), /^Symbol\(([^)]*)\)/, "$1") + "]"), n && n.getter && (e = "get " + e), n && n.setter && (e = "set " + e), (!Tw(t, "name") || sV && t.name !== e) && (Wk ? ax(t, "name", { value: e, configurable: !0 }) : t.name = e), hV && n && Tw(n, "arity") && t.length !== n.arity && ax(t, "length", { value: n.arity });
  try {
    n && Tw(n, "constructor") && n.constructor ? Wk && ax(t, "prototype", { writable: !1 }) : t.prototype && (t.prototype = void 0);
  } catch {
  }
  var r = cV(t);
  return Tw(r, "source") || (r.source = pV(gV, typeof e == "string" ? e : "")), t;
};
Function.prototype.toString = mV(function() {
  return aV(this) && uV(this).source || lV(this);
}, "toString");
var vV = _3.exports, yV = ma, bV = om, SV = vV, wV = XP, M3 = function(t, e, n, r) {
  r || (r = {});
  var a = r.enumerable, s = r.name !== void 0 ? r.name : e;
  if (yV(n) && SV(n, s, r), r.global)
    a ? t[e] = n : wV(e, n);
  else {
    try {
      r.unsafe ? t[e] && (a = !0) : delete t[e];
    } catch {
    }
    a ? t[e] = n : bV.f(t, e, {
      value: n,
      enumerable: !1,
      configurable: !r.nonConfigurable,
      writable: !r.nonWritable
    });
  }
  return t;
}, A3 = {}, xV = Math.ceil, EV = Math.floor, CV = Math.trunc || function(e) {
  var n = +e;
  return (n > 0 ? EV : xV)(n);
}, _V = CV, Bp = function(t) {
  var e = +t;
  return e !== e || e === 0 ? 0 : _V(e);
}, TV = Bp, kV = Math.max, PV = Math.min, IV = function(t, e) {
  var n = TV(t);
  return n < 0 ? kV(n + e, 0) : PV(n, e);
}, RV = Bp, $V = Math.min, O3 = function(t) {
  return t > 0 ? $V(RV(t), 9007199254740991) : 0;
}, MV = O3, mb = function(t) {
  return MV(t.length);
}, AV = e1, OV = IV, DV = mb, WA = function(t) {
  return function(e, n, r) {
    var a = AV(e), s = DV(a), c = OV(r, s), f;
    if (t && n != n) {
      for (; s > c; )
        if (f = a[c++], f != f)
          return !0;
    } else
      for (; s > c; c++)
        if ((t || c in a) && a[c] === n)
          return t || c || 0;
    return !t && -1;
  };
}, NV = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: WA(!0),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: WA(!1)
}, LV = oo, $T = cf, jV = e1, zV = NV.indexOf, UV = eI, GA = LV([].push), D3 = function(t, e) {
  var n = jV(t), r = 0, a = [], s;
  for (s in n)
    !$T(UV, s) && $T(n, s) && GA(a, s);
  for (; e.length > r; )
    $T(n, s = e[r++]) && (~zV(a, s) || GA(a, s));
  return a;
}, nI = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
], BV = D3, FV = nI, HV = FV.concat("length", "prototype");
A3.f = Object.getOwnPropertyNames || function(e) {
  return BV(e, HV);
};
var N3 = {};
N3.f = Object.getOwnPropertySymbols;
var VV = t1, YV = oo, KV = A3, WV = N3, GV = Up, XV = YV([].concat), qV = VV("Reflect", "ownKeys") || function(e) {
  var n = KV.f(GV(e)), r = WV.f;
  return r ? XV(n, r(e)) : n;
}, XA = cf, QV = qV, ZV = KP, JV = om, eY = function(t, e, n) {
  for (var r = QV(e), a = JV.f, s = ZV.f, c = 0; c < r.length; c++) {
    var f = r[c];
    !XA(t, f) && !(n && XA(n, f)) && a(t, f, s(e, f));
  }
}, tY = ga, nY = ma, rY = /#|\.prototype\./, vb = function(t, e) {
  var n = oY[iY(t)];
  return n == sY ? !0 : n == aY ? !1 : nY(e) ? tY(e) : !!e;
}, iY = vb.normalize = function(t) {
  return String(t).replace(rY, ".").toLowerCase();
}, oY = vb.data = {}, aY = vb.NATIVE = "N", sY = vb.POLYFILL = "P", lY = vb, MT = Xa, cY = KP.f, uY = ZP, dY = M3, fY = XP, pY = eY, hY = lY, am = function(t, e) {
  var n = t.target, r = t.global, a = t.stat, s, c, f, p, g, y;
  if (r ? c = MT : a ? c = MT[n] || fY(n, {}) : c = (MT[n] || {}).prototype, c)
    for (f in e) {
      if (g = e[f], t.dontCallGetSet ? (y = cY(c, f), p = y && y.value) : p = c[f], s = hY(r ? f : n + (a ? "." : "#") + f, t.forced), !s && p !== void 0) {
        if (typeof g == typeof p)
          continue;
        pY(g, p);
      }
      (t.sham || p && p.sham) && uY(g, "sham", !0), dY(c, f, g, t);
    }
}, L3 = {}, gY = D3, mY = nI, vY = Object.keys || function(e) {
  return gY(e, mY);
}, yY = sf, bY = C3, SY = om, wY = Up, xY = e1, EY = vY;
L3.f = yY && !bY ? Object.defineProperties : function(e, n) {
  wY(e);
  for (var r = xY(n), a = EY(n), s = a.length, c = 0, f; s > c; )
    SY.f(e, f = a[c++], r[f]);
  return e;
};
var CY = t1, _Y = CY("document", "documentElement"), TY = Up, kY = L3, qA = nI, PY = eI, IY = _Y, RY = x3, $Y = P3, QA = ">", ZA = "<", Gk = "prototype", Xk = "script", j3 = $Y("IE_PROTO"), AT = function() {
}, z3 = function(t) {
  return ZA + Xk + QA + t + ZA + "/" + Xk + QA;
}, JA = function(t) {
  t.write(z3("")), t.close();
  var e = t.parentWindow.Object;
  return t = null, e;
}, MY = function() {
  var t = RY("iframe"), e = "java" + Xk + ":", n;
  return t.style.display = "none", IY.appendChild(t), t.src = String(e), n = t.contentWindow.document, n.open(), n.write(z3("document.F=Object")), n.close(), n.F;
}, kw, sx = function() {
  try {
    kw = new ActiveXObject("htmlfile");
  } catch {
  }
  sx = typeof document < "u" ? document.domain && kw ? JA(kw) : MY() : JA(kw);
  for (var t = qA.length; t--; )
    delete sx[Gk][qA[t]];
  return sx();
};
PY[j3] = !0;
var U3 = Object.create || function(e, n) {
  var r;
  return e !== null ? (AT[Gk] = TY(e), r = new AT(), AT[Gk] = null, r[j3] = e) : r = sx(), n === void 0 ? r : kY.f(r, n);
}, AY = Bu, OY = U3, DY = om.f, qk = AY("unscopables"), Qk = Array.prototype;
Qk[qk] == null && DY(Qk, qk, {
  configurable: !0,
  value: OY(null)
});
var rI = function(t) {
  Qk[qk][t] = !0;
}, NY = am, LY = gb, jY = mb, zY = Bp, UY = rI;
NY({ target: "Array", proto: !0 }, {
  at: function(e) {
    var n = LY(this), r = jY(n), a = zY(e), s = a >= 0 ? a : r + a;
    return s < 0 || s >= r ? void 0 : n[s];
  }
});
UY("at");
var BY = Xa, FY = oo, yb = function(t, e) {
  return FY(BY[t].prototype[e]);
}, HY = yb;
HY("Array", "at");
var VY = rm, B3 = Array.isArray || function(e) {
  return VY(e) == "Array";
}, YY = TypeError, KY = 9007199254740991, WY = function(t) {
  if (t > KY)
    throw YY("Maximum allowed index exceeded");
  return t;
}, GY = rm, XY = oo, F3 = function(t) {
  if (GY(t) === "Function")
    return XY(t);
}, eO = F3, qY = WP, QY = Zx, ZY = eO(eO.bind), JY = function(t, e) {
  return qY(t), e === void 0 ? t : QY ? ZY(t, e) : function() {
    return t.apply(e, arguments);
  };
}, eK = B3, tK = mb, nK = WY, rK = JY, H3 = function(t, e, n, r, a, s, c, f) {
  for (var p = a, g = 0, y = c ? rK(c, f) : !1, v, S; g < r; )
    g in n && (v = y ? y(n[g], g, e) : n[g], s > 0 && eK(v) ? (S = tK(v), p = H3(t, e, v, S, p, s - 1) - 1) : (nK(p + 1), t[p] = v), p++), g++;
  return p;
}, V3 = H3, iK = Bu, oK = iK("toStringTag"), Y3 = {};
Y3[oK] = "z";
var aK = String(Y3) === "[object z]", sK = aK, lK = ma, lx = rm, cK = Bu, uK = cK("toStringTag"), dK = Object, fK = lx(function() {
  return arguments;
}()) == "Arguments", pK = function(t, e) {
  try {
    return t[e];
  } catch {
  }
}, K3 = sK ? lx : function(t) {
  var e, n, r;
  return t === void 0 ? "Undefined" : t === null ? "Null" : typeof (n = pK(e = dK(t), uK)) == "string" ? n : fK ? lx(e) : (r = lx(e)) == "Object" && lK(e.callee) ? "Arguments" : r;
}, hK = oo, gK = ga, W3 = ma, mK = K3, vK = t1, yK = k3, G3 = function() {
}, bK = [], X3 = vK("Reflect", "construct"), iI = /^\s*(?:class|function)\b/, SK = hK(iI.exec), wK = !iI.exec(G3), ky = function(e) {
  if (!W3(e))
    return !1;
  try {
    return X3(G3, bK, e), !0;
  } catch {
    return !1;
  }
}, q3 = function(e) {
  if (!W3(e))
    return !1;
  switch (mK(e)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return !1;
  }
  try {
    return wK || !!SK(iI, yK(e));
  } catch {
    return !0;
  }
};
q3.sham = !0;
var xK = !X3 || gK(function() {
  var t;
  return ky(ky.call) || !ky(Object) || !ky(function() {
    t = !0;
  }) || t;
}) ? q3 : ky, tO = B3, EK = xK, CK = zp, _K = Bu, TK = _K("species"), nO = Array, kK = function(t) {
  var e;
  return tO(t) && (e = t.constructor, EK(e) && (e === nO || tO(e.prototype)) ? e = void 0 : CK(e) && (e = e[TK], e === null && (e = void 0))), e === void 0 ? nO : e;
}, PK = kK, Q3 = function(t, e) {
  return new (PK(t))(e === 0 ? 0 : e);
}, IK = am, RK = V3, $K = gb, MK = mb, AK = Bp, OK = Q3;
IK({ target: "Array", proto: !0 }, {
  flat: function() {
    var e = arguments.length ? arguments[0] : void 0, n = $K(this), r = MK(n), a = OK(n, 0);
    return a.length = RK(a, n, n, r, 0, e === void 0 ? 1 : AK(e)), a;
  }
});
var DK = rI;
DK("flat");
var NK = yb;
NK("Array", "flat");
var LK = am, jK = V3, zK = WP, UK = gb, BK = mb, FK = Q3;
LK({ target: "Array", proto: !0 }, {
  flatMap: function(e) {
    var n = UK(this), r = BK(n), a;
    return zK(e), a = FK(n, 0), a.length = jK(a, n, n, r, 0, 1, e, arguments.length > 1 ? arguments[1] : void 0), a;
  }
});
var HK = rI;
HK("flatMap");
var VK = yb;
VK("Array", "flatMap");
var YK = K3, KK = String, bb = function(t) {
  if (YK(t) === "Symbol")
    throw TypeError("Cannot convert a Symbol value to a string");
  return KK(t);
}, WK = am, GK = oo, XK = im, qK = Bp, QK = bb, ZK = ga, JK = GK("".charAt), eW = ZK(function() {
  return "𠮷".at(-2) !== "\uD842";
});
WK({ target: "String", proto: !0, forced: eW }, {
  at: function(e) {
    var n = QK(XK(this)), r = n.length, a = qK(e), s = a >= 0 ? a : r + a;
    return s < 0 || s >= r ? void 0 : JK(n, s);
  }
});
var tW = yb;
tW("String", "at");
var nW = Up, Z3 = function() {
  var t = nW(this), e = "";
  return t.hasIndices && (e += "d"), t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.unicodeSets && (e += "v"), t.sticky && (e += "y"), e;
}, oI = ga, rW = Xa, aI = rW.RegExp, sI = oI(function() {
  var t = aI("a", "y");
  return t.lastIndex = 2, t.exec("abcd") != null;
}), iW = sI || oI(function() {
  return !aI("a", "y").sticky;
}), oW = sI || oI(function() {
  var t = aI("^r", "gy");
  return t.lastIndex = 2, t.exec("str") != null;
}), aW = {
  BROKEN_CARET: oW,
  MISSED_STICKY: iW,
  UNSUPPORTED_Y: sI
}, sW = ga, lW = Xa, cW = lW.RegExp, uW = sW(function() {
  var t = cW(".", "s");
  return !(t.dotAll && t.exec(`
`) && t.flags === "s");
}), dW = ga, fW = Xa, pW = fW.RegExp, hW = dW(function() {
  var t = pW("(?<a>b)", "g");
  return t.exec("b").groups.a !== "b" || "b".replace(t, "$<a>c") !== "bc";
}), Fg = lf, n1 = oo, gW = bb, mW = Z3, vW = aW, yW = QP, bW = U3, SW = R3.get, wW = uW, xW = hW, EW = yW("native-string-replace", String.prototype.replace), wx = RegExp.prototype.exec, Zk = wx, CW = n1("".charAt), _W = n1("".indexOf), TW = n1("".replace), OT = n1("".slice), Jk = function() {
  var t = /a/, e = /b*/g;
  return Fg(wx, t, "a"), Fg(wx, e, "a"), t.lastIndex !== 0 || e.lastIndex !== 0;
}(), J3 = vW.BROKEN_CARET, eP = /()??/.exec("")[1] !== void 0, kW = Jk || eP || J3 || wW || xW;
kW && (Zk = function(e) {
  var n = this, r = SW(n), a = gW(e), s = r.raw, c, f, p, g, y, v, S;
  if (s)
    return s.lastIndex = n.lastIndex, c = Fg(Zk, s, a), n.lastIndex = s.lastIndex, c;
  var x = r.groups, _ = J3 && n.sticky, T = Fg(mW, n), I = n.source, D = 0, N = a;
  if (_ && (T = TW(T, "y", ""), _W(T, "g") === -1 && (T += "g"), N = OT(a, n.lastIndex), n.lastIndex > 0 && (!n.multiline || n.multiline && CW(a, n.lastIndex - 1) !== `
`) && (I = "(?: " + I + ")", N = " " + N, D++), f = new RegExp("^(?:" + I + ")", T)), eP && (f = new RegExp("^" + I + "$(?!\\s)", T)), Jk && (p = n.lastIndex), g = Fg(wx, _ ? f : n, N), _ ? g ? (g.input = OT(g.input, D), g[0] = OT(g[0], D), g.index = n.lastIndex, n.lastIndex += g[0].length) : n.lastIndex = 0 : Jk && g && (n.lastIndex = n.global ? g.index + g[0].length : p), eP && g && g.length > 1 && Fg(EW, g[0], f, function() {
    for (y = 1; y < arguments.length - 2; y++)
      arguments[y] === void 0 && (g[y] = void 0);
  }), g && x)
    for (g.groups = v = bW(null), y = 0; y < x.length; y++)
      S = x[y], v[S[0]] = g[S[1]];
  return g;
});
var lI = Zk, PW = am, rO = lI;
PW({ target: "RegExp", proto: !0, forced: /./.exec !== rO }, {
  exec: rO
});
var IW = Zx, eL = Function.prototype, iO = eL.apply, oO = eL.call, RW = typeof Reflect == "object" && Reflect.apply || (IW ? oO.bind(iO) : function() {
  return oO.apply(iO, arguments);
}), aO = F3, sO = M3, $W = lI, lO = ga, tL = Bu, MW = ZP, AW = tL("species"), DT = RegExp.prototype, OW = function(t, e, n, r) {
  var a = tL(t), s = !lO(function() {
    var g = {};
    return g[a] = function() {
      return 7;
    }, ""[t](g) != 7;
  }), c = s && !lO(function() {
    var g = !1, y = /a/;
    return t === "split" && (y = {}, y.constructor = {}, y.constructor[AW] = function() {
      return y;
    }, y.flags = "", y[a] = /./[a]), y.exec = function() {
      return g = !0, null;
    }, y[a](""), !g;
  });
  if (!s || !c || n) {
    var f = aO(/./[a]), p = e(a, ""[t], function(g, y, v, S, x) {
      var _ = aO(g), T = y.exec;
      return T === $W || T === DT.exec ? s && !x ? { done: !0, value: f(y, v, S) } : { done: !0, value: _(v, y, S) } : { done: !1 };
    });
    sO(String.prototype, t, p[0]), sO(DT, a, p[1]);
  }
  r && MW(DT[a], "sham", !0);
}, cI = oo, DW = Bp, NW = bb, LW = im, jW = cI("".charAt), cO = cI("".charCodeAt), zW = cI("".slice), uO = function(t) {
  return function(e, n) {
    var r = NW(LW(e)), a = DW(n), s = r.length, c, f;
    return a < 0 || a >= s ? t ? "" : void 0 : (c = cO(r, a), c < 55296 || c > 56319 || a + 1 === s || (f = cO(r, a + 1)) < 56320 || f > 57343 ? t ? jW(r, a) : c : t ? zW(r, a, a + 2) : (c - 55296 << 10) + (f - 56320) + 65536);
  };
}, UW = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: uO(!1),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: uO(!0)
}, BW = UW.charAt, FW = function(t, e, n) {
  return e + (n ? BW(t, e).length : 1);
}, uI = oo, HW = gb, VW = Math.floor, NT = uI("".charAt), YW = uI("".replace), LT = uI("".slice), KW = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, WW = /\$([$&'`]|\d{1,2})/g, nL = function(t, e, n, r, a, s) {
  var c = n + t.length, f = r.length, p = WW;
  return a !== void 0 && (a = HW(a), p = KW), YW(s, p, function(g, y) {
    var v;
    switch (NT(y, 0)) {
      case "$":
        return "$";
      case "&":
        return t;
      case "`":
        return LT(e, 0, n);
      case "'":
        return LT(e, c);
      case "<":
        v = a[LT(y, 1, -1)];
        break;
      default:
        var S = +y;
        if (S === 0)
          return g;
        if (S > f) {
          var x = VW(S / 10);
          return x === 0 ? g : x <= f ? r[x - 1] === void 0 ? NT(y, 1) : r[x - 1] + NT(y, 1) : g;
        }
        v = r[S - 1];
    }
    return v === void 0 ? "" : v;
  });
}, dO = lf, GW = Up, XW = ma, qW = rm, QW = lI, ZW = TypeError, JW = function(t, e) {
  var n = t.exec;
  if (XW(n)) {
    var r = dO(n, t, e);
    return r !== null && GW(r), r;
  }
  if (qW(t) === "RegExp")
    return dO(QW, t, e);
  throw ZW("RegExp#exec called on incompatible receiver");
}, eG = RW, fO = lf, r1 = oo, tG = OW, nG = ga, rG = Up, iG = ma, oG = Jx, aG = Bp, sG = O3, Pg = bb, lG = im, cG = FW, uG = GP, dG = nL, fG = JW, pG = Bu, tP = pG("replace"), hG = Math.max, gG = Math.min, mG = r1([].concat), jT = r1([].push), pO = r1("".indexOf), hO = r1("".slice), vG = function(t) {
  return t === void 0 ? t : String(t);
}, yG = function() {
  return "a".replace(/./, "$0") === "$0";
}(), gO = function() {
  return /./[tP] ? /./[tP]("a", "$0") === "" : !1;
}(), bG = !nG(function() {
  var t = /./;
  return t.exec = function() {
    var e = [];
    return e.groups = { a: "7" }, e;
  }, "".replace(t, "$<a>") !== "7";
});
tG("replace", function(t, e, n) {
  var r = gO ? "$" : "$0";
  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function(s, c) {
      var f = lG(this), p = oG(s) ? void 0 : uG(s, tP);
      return p ? fO(p, s, f, c) : fO(e, Pg(f), s, c);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function(a, s) {
      var c = rG(this), f = Pg(a);
      if (typeof s == "string" && pO(s, r) === -1 && pO(s, "$<") === -1) {
        var p = n(e, c, f, s);
        if (p.done)
          return p.value;
      }
      var g = iG(s);
      g || (s = Pg(s));
      var y = c.global;
      if (y) {
        var v = c.unicode;
        c.lastIndex = 0;
      }
      for (var S = []; ; ) {
        var x = fG(c, f);
        if (x === null || (jT(S, x), !y))
          break;
        var _ = Pg(x[0]);
        _ === "" && (c.lastIndex = cG(f, sG(c.lastIndex), v));
      }
      for (var T = "", I = 0, D = 0; D < S.length; D++) {
        x = S[D];
        for (var N = Pg(x[0]), j = hG(gG(aG(x.index), f.length), 0), L = [], z = 1; z < x.length; z++)
          jT(L, vG(x[z]));
        var F = x.groups;
        if (g) {
          var K = mG([N], L, j, f);
          F !== void 0 && jT(K, F);
          var X = Pg(eG(s, void 0, K));
        } else
          X = dG(N, f, j, L, F, s);
        j >= I && (T += hO(f, I, j) + X, I = j + N.length);
      }
      return T + hO(f, I);
    }
  ];
}, !bG || !yG || gO);
var SG = zp, wG = rm, xG = Bu, EG = xG("match"), CG = function(t) {
  var e;
  return SG(t) && ((e = t[EG]) !== void 0 ? !!e : wG(t) == "RegExp");
}, _G = lf, TG = cf, kG = h3, PG = Z3, mO = RegExp.prototype, IG = function(t) {
  var e = t.flags;
  return e === void 0 && !("flags" in mO) && !TG(t, "flags") && kG(mO, t) ? _G(PG, t) : e;
}, RG = am, $G = lf, dI = oo, vO = im, MG = ma, AG = Jx, OG = CG, Py = bb, DG = GP, NG = IG, LG = nL, jG = Bu, zG = jG("replace"), UG = TypeError, rL = dI("".indexOf);
dI("".replace);
var yO = dI("".slice), BG = Math.max, bO = function(t, e, n) {
  return n > t.length ? -1 : e === "" ? n : rL(t, e, n);
};
RG({ target: "String", proto: !0 }, {
  replaceAll: function(e, n) {
    var r = vO(this), a, s, c, f, p, g, y, v, S, x = 0, _ = 0, T = "";
    if (!AG(e)) {
      if (a = OG(e), a && (s = Py(vO(NG(e))), !~rL(s, "g")))
        throw UG("`.replaceAll` does not allow non-global regexes");
      if (c = DG(e, zG), c)
        return $G(c, e, r, n);
    }
    for (f = Py(r), p = Py(e), g = MG(n), g || (n = Py(n)), y = p.length, v = BG(1, y), x = bO(f, p, 0); x !== -1; )
      S = g ? Py(n(p, x, f)) : LG(p, f, x, [], void 0, n), T += yO(f, _, x) + S, _ = x + y, x = bO(f, p, x + v);
    return _ < f.length && (T += yO(f, _)), T;
  }
});
var FG = yb;
FG("String", "replaceAll");
function xx(t, e) {
  const n = [];
  e:
    for (const r of t) {
      for (const a of n)
        if (e ? e(r, a) : r === a)
          continue e;
      n.push(r);
    }
  return n;
}
function Gt(t) {
  return t.filter((e) => e != null);
}
function Hs(t) {
  return t[t.length - 1];
}
function HG(t, e) {
  let n, r = 1 / 0;
  for (const a of t) {
    const s = e(a);
    s < r && (n = a, r = s);
  }
  return n;
}
function VG(t, e) {
  const n = [], r = [];
  for (const a of t)
    e(a) ? n.push(a) : r.push(a);
  return [n, r];
}
function iL(t) {
  const e = (...n) => {
    try {
      return t(...n);
    } catch (r) {
      throw r instanceof Error && Error.captureStackTrace && Error.captureStackTrace(r, e), r;
    }
  };
  return e;
}
function YG(t, e) {
  const n = e && t && typeof t == "object" && e in t ? t[e] : t;
  throw new Error(`Unknown switch case ${n}`);
}
const oL = iL(
  (t, e) => {
    if (!t)
      throw new Error(e || "Assertion Error");
  }
), KG = iL((t, e) => {
  if (t == null)
    throw new Error(e ?? "value must be defined");
  return t;
});
function fI(t, e) {
  let n;
  const r = (...a) => (n || (n = {}, n.promise = new Promise((s, c) => {
    n.resolve = s, n.reject = c;
  })), clearTimeout(n.timeout), n.latestArgs = a, n.timeout = setTimeout(() => {
    const s = n;
    n = void 0;
    try {
      s.resolve(t(...s.latestArgs));
    } catch (c) {
      s.reject(c);
    }
  }, e), n.promise);
  return r.cancel = () => {
    n && clearTimeout(n.timeout);
  }, r;
}
const SO = /* @__PURE__ */ new WeakMap();
function pI(t, e) {
  if (typeof t != "object" || t === null)
    return;
  let n = SO.get(t);
  n || (n = { tags: {}, extras: {} }, SO.set(t, n)), e.tags && (n.tags = {
    ...n.tags,
    ...e.tags
  }), e.extras && (n.extras = {
    ...n.extras,
    ...e.extras
  });
}
function i1(t) {
  let e = 0;
  for (let n = 0; n < t.length; n++)
    e = (e << 5) - e + t.charCodeAt(n), e |= 0;
  return e + "";
}
function By(t = "") {
  let e = 0, n = 0, r = 0, a = 0;
  function s() {
    const c = e ^ e << 11;
    return e = n, n = r, r = a, a ^= (a >>> 19 ^ c ^ c >>> 8) >>> 0, a / 4294967296 * 2;
  }
  for (let c = 0; c < t.length + 64; c++)
    e ^= t.charCodeAt(c) | 0, s();
  return s;
}
function nP(t, e, n, r = !1) {
  const [a, s] = e, [c, f] = n, p = c + (t - a) / (s - a) * (f - c);
  return r ? c < f ? Math.max(Math.min(p, f), c) : Math.max(Math.min(p, c), f) : p;
}
function hI(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function Ex(t, e) {
  if (hI(t, e))
    return t[e];
}
function Tc(t) {
  if (!t)
    return t;
  if (Array.isArray(t)) {
    const e = [], n = t.length;
    for (let r = 0; r < n; r++)
      e.push(Tc(t[r]));
    return e;
  } else if (typeof t == "object") {
    const e = Object.keys(t), n = e.length, r = {};
    for (let a = 0; a < n; a++) {
      const s = e[a];
      r[s] = Tc(t[s]);
    }
    return r;
  }
  return t;
}
function wO(t) {
  return Object.values(t);
}
function aL(t) {
  return Object.entries(t);
}
function WG(t) {
  return t !== null;
}
function GG(t) {
  return t != null;
}
const Lu = typeof window < "u" && window.structuredClone ? window.structuredClone : (t) => t && JSON.parse(JSON.stringify(t));
class cx {
  constructor(e) {
    this.previousValue = e;
  }
  /**
   * The next value of the set.
   *
   * @internal
   */
  nextValue;
  /**
   * The diff of the set.
   *
   * @internal
   */
  diff;
  /**
   * Get the next value of the set.
   *
   * @public
   */
  get() {
    const e = this.diff?.removed?.size ?? 0, n = this.diff?.added?.size ?? 0;
    if (!(e === 0 && n === 0))
      return { value: this.nextValue, diff: this.diff };
  }
  /**
   * Add an item to the set.
   *
   * @param item - The item to add.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   *
   * @internal
   */
  _add(e, n) {
    this.nextValue ??= new Set(this.previousValue), this.nextValue.add(e), this.diff ??= {}, n ? this.diff.removed?.delete(e) : (this.diff.added ??= /* @__PURE__ */ new Set(), this.diff.added.add(e));
  }
  /**
   * Add an item to the set.
   *
   * @param item - The item to add.
   *
   * @public
   */
  add(e) {
    const n = this.previousValue.has(e);
    if (n)
      return this.diff?.removed?.has(e) ? this._add(e, n) : void 0;
    this.nextValue?.has(e) || this._add(e, n);
  }
  /**
   * Remove an item from the set.
   *
   * @param item - The item to remove.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   *
   * @internal
   */
  _remove(e, n) {
    this.nextValue ??= new Set(this.previousValue), this.nextValue.delete(e), this.diff ??= {}, n ? (this.diff.removed ??= /* @__PURE__ */ new Set(), this.diff.removed.add(e)) : this.diff.added?.delete(e);
  }
  /**
   * Remove an item from the set.
   *
   * @param item - The item to remove.
   *
   * @public
   */
  remove(e) {
    const n = this.previousValue.has(e);
    if (!n)
      return this.diff?.added?.has(e) ? this._remove(e, n) : void 0;
    this.diff?.removed?.has(e) || this._remove(e, n);
  }
}
let gI = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce((e, n) => (n &= 63, n < 36 ? e += n.toString(36) : n < 62 ? e += (n - 26).toString(36).toUpperCase() : n > 62 ? e += "-" : e += "_", e), "");
class mI {
  constructor(e, n) {
    this.typeName = e, this.createDefaultProperties = n.createDefaultProperties, this.migrations = n.migrations, this.validator = n.validator ?? { validate: (r) => r };
  }
  createDefaultProperties;
  migrations;
  validator;
  /**
   * Create a new record of this type.
   *
   * @param properties - The properties of the record.
   *
   * @returns The new record.
   */
  create(e) {
    const n = { ...this.createDefaultProperties(), id: this.createId() };
    for (const [r, a] of Object.entries(e))
      a !== void 0 && (n[r] = a);
    return n.typeName = this.typeName, n;
  }
  /**
   * Clone a record of this type.
   *
   * @param record - The record to clone.
   * @public
   * @returns The cloned record.
   */
  clone(e) {
    return { ...Lu(e), id: this.createId() };
  }
  /**
   * Create a new ID for this record type.
   *
   * @example
   * ```ts
   * const id = recordType.createId()
   * ```
   *
   * @public
   * @returns The new ID.
   */
  createId() {
    return this.typeName + ":" + gI();
  }
  /**
   * Create a new ID for this record type based on the given ID.
   *
   * @example
   * ```ts
   * const id = recordType.createCustomId("myId")
   * ```
   *
   * @param id - The ID to base the new ID on.
   * @returns The new ID.
   */
  createCustomId(e) {
    return this.typeName + ":" + e;
  }
  /**
   * Check whether a record is an instance of this record type.
   *
   * @example
   * ```ts
   * const result = recordType.isInstance(someRecord)
   * ```
   *
   * @param record - The record to check.
   * @returns Whether the record is an instance of this record type.
   */
  isInstance = (e) => e?.typeName === this.typeName;
  /**
   * Check whether an id is an id of this type.
   *
   * @example
   * ```ts
   * const result = recordType.isIn("someId")
   * ```
   *
   * @param id - The id to check.
   * @returns Whether the id is an id of this type.
   */
  isId(e) {
    if (!e)
      return !1;
    for (let n = 0; n < this.typeName.length; n++)
      if (e[n] !== this.typeName[n])
        return !1;
    return e[this.typeName.length] === ":";
  }
  /**
   * Create a new RecordType that has the same type name as this RecordType and includes the given default properties.
   *
   * @example
   * ```ts
   * const authorType = createRecordType('author', () => ({ living: true }))
   * const deadAuthorType = authorType.withDefaultProperties({ living: false })
   * ```
   *
   * @param fn - A function that returns the default properties of the new RecordType.
   *
   * @returns The new RecordType.
   */
  withDefaultProperties(e) {
    return new mI(this.typeName, {
      createDefaultProperties: e,
      migrations: this.migrations,
      validator: this.validator
    });
  }
  /**
   * Check that the passed in record passes the validations for this type.
   * Returns its input correctly typed if it does, but throws an error
   * otherwise.
   */
  validate(e) {
    return this.validator.validate(e);
  }
}
function $c(t, e) {
  return new mI(t, {
    createDefaultProperties: () => ({}),
    migrations: e.migrations ?? { currentVersion: 0, firstVersion: 0, migrators: {} },
    validator: e.validator
  });
}
var xO = 8, sL = class {
  arraySize = 0;
  array = Array(xO);
  set = null;
  /**
   * Get whether this ArraySet has any elements.
   *
   * @returns True if this ArraySet has any elements, false otherwise.
   */
  get isEmpty() {
    if (this.array)
      return this.arraySize === 0;
    if (this.set)
      return this.set.size === 0;
    throw new Error("no set or array");
  }
  /**
   * Add an item to the ArraySet if it is not already present.
   *
   * @param elem - The element to add.
   */
  add(t) {
    if (this.array)
      return this.array.indexOf(t) !== -1 ? !1 : this.arraySize < xO ? (this.array[this.arraySize] = t, this.arraySize++, !0) : (this.set = new Set(this.array), this.array = null, this.set.add(t), !0);
    if (this.set)
      return this.set.has(t) ? !1 : (this.set.add(t), !0);
    throw new Error("no set or array");
  }
  /**
   * Remove an item from the ArraySet if it is present.
   *
   * @param elem - The element to remove
   */
  remove(t) {
    if (this.array) {
      const e = this.array.indexOf(t);
      return e === -1 ? !1 : (this.array[e] = void 0, this.arraySize--, e !== this.arraySize && (this.array[e] = this.array[this.arraySize], this.array[this.arraySize] = void 0), !0);
    }
    if (this.set)
      return this.set.has(t) ? (this.set.delete(t), !0) : !1;
    throw new Error("no set or array");
  }
  /**
   * Run a callback for each element in the ArraySet.
   *
   * @param visitor The callback to run for each element.
   */
  visit(t) {
    if (this.array) {
      for (let e = 0; e < this.arraySize; e++) {
        const n = this.array[e];
        typeof n < "u" && t(n);
      }
      return;
    }
    if (this.set) {
      this.set.forEach(t);
      return;
    }
    throw new Error("no set or array");
  }
};
function lL(t) {
  return t && typeof t == "object" && "parents" in t;
}
function cL(t) {
  for (let e = 0, n = t.parents.length; e < n; e++)
    if (t.parents[e].__unsafe__getWithoutCapture(), t.parents[e].lastChangedEpoch !== t.parentEpochs[e])
      return !0;
  return !1;
}
var Cx = (t, e) => {
  if (t.children.remove(e) && t.children.isEmpty && lL(t))
    for (let n = 0, r = t.parents.length; n < r; n++)
      Cx(t.parents[n], t);
}, vI = (t, e) => {
  if (t.children.add(e) && lL(t))
    for (let n = 0, r = t.parents.length; n < r; n++)
      vI(t.parents[n], t);
};
function uL(t, e) {
  return t === e || Object.is(t, e) || !!(t && e && typeof t.equals == "function" && t.equals(e));
}
var Ws = Object.freeze([]), EO = Symbol.for("__signia__"), CO = globalThis;
CO[EO] ? console.error(
  'Multiple versions of signia detected. This will cause unexpected behavior. Please add "resolutions" (yarn/pnpm) or "overrides" (npm) in your package.json to ensure only one version of signia is loaded.'
) : CO[EO] = !0;
var XG = class {
  constructor(t, e) {
    this.below = t, this.child = e;
  }
  offset = 0;
  numNewParents = 0;
  maybeRemoved;
}, Lr = null;
function dL(t) {
  Lr = new XG(Lr, t);
}
function fL() {
  const t = Lr;
  if (Lr = t.below, t.numNewParents > 0 || t.offset !== t.child.parents.length) {
    for (let n = t.offset; n < t.child.parents.length; n++) {
      const r = t.child.parents[n];
      t.child.parents.indexOf(r) >= t.offset && Cx(r, t.child);
    }
    if (t.child.parents.length = t.offset, t.child.parentEpochs.length = t.offset, Lr?.maybeRemoved)
      for (let n = 0; n < Lr.maybeRemoved.length; n++) {
        const r = Lr.maybeRemoved[n];
        t.child.parents.indexOf(r) === -1 && Cx(r, t.child);
      }
  }
}
function rP(t) {
  if (Lr) {
    const e = Lr.child.parents.indexOf(t);
    if (e < 0 && (Lr.numNewParents++, Lr.child.isActivelyListening && vI(t, Lr.child)), e < 0 || e >= Lr.offset) {
      if (e !== Lr.offset && e > 0) {
        const n = Lr.child.parents[Lr.offset];
        Lr.maybeRemoved ? Lr.maybeRemoved.indexOf(n) === -1 && Lr.maybeRemoved.push(n) : Lr.maybeRemoved = [n];
      }
      Lr.child.parents[Lr.offset] = t, Lr.child.parentEpochs[Lr.offset] = t.lastChangedEpoch, Lr.offset++;
    }
  }
}
var fs = Symbol("RESET_VALUE"), pL = class {
  constructor(t) {
    this.capacity = t, this.buffer = new Array(t);
  }
  index = 0;
  // use a wrap around buffer to store the last N values
  buffer;
  /**
   * Add a diff to the history buffer.
   *
   * @param lastComputedEpoch The epoch when the diff was computed.
   * @param currentEpoch The current epoch.
   * @param diff (optional) The diff to add, or else a reset value.
   */
  pushEntry(t, e, n) {
    if (n !== void 0) {
      if (n === fs) {
        this.clear();
        return;
      }
      this.buffer[this.index] = [t, e, n], this.index = (this.index + 1) % this.capacity;
    }
  }
  /**
   * Clear the history buffer.
   */
  clear() {
    this.index = 0, this.buffer.fill(void 0);
  }
  /**
   * Get the diffs since the given epoch.
   *
   * @param epoch The epoch to get diffs since.
   * @returns An array of diffs or a flag to reset the history buffer.
   */
  getChangesSince(t) {
    const { index: e, capacity: n, buffer: r } = this;
    for (let a = 0; a < n; a++) {
      const s = (e - 1 + n - a) % n, c = r[s];
      if (!c)
        return fs;
      const [f, p] = c;
      if (a === 0 && t >= p)
        return [];
      if (f <= t && t < p) {
        const g = a + 1, y = new Array(g);
        for (let v = 0; v < g; v++)
          y[v] = r[(s + v) % n][2];
        return y;
      }
    }
    return fs;
  }
}, _p = -1, Co = _p + 1, zT = !1;
function qG() {
  Co++;
}
var QG = class {
  constructor(t) {
    this.parent = t;
  }
  initialAtomValues = /* @__PURE__ */ new Map();
  /**
   * Get whether this transaction is a root (no parents).
   *
   * @public
   */
  get isRoot() {
    return this.parent === null;
  }
  /**
   * Commit the transaction's changes.
   *
   * @public
   */
  commit() {
    if (this.isRoot) {
      const t = this.initialAtomValues;
      this.initialAtomValues = /* @__PURE__ */ new Map(), hL(t.keys());
    } else
      this.initialAtomValues.forEach((t, e) => {
        this.parent.initialAtomValues.has(e) || this.parent.initialAtomValues.set(e, t);
      });
  }
  /**
   * Abort the transaction.
   *
   * @public
   */
  abort() {
    Co++, this.initialAtomValues.forEach((t, e) => {
      e.set(t), e.historyBuffer?.clear();
    }), this.commit();
  }
};
function hL(t) {
  if (zT)
    throw new Error("cannot change atoms during reaction cycle");
  try {
    zT = !0;
    const e = /* @__PURE__ */ new Set(), n = (r) => {
      r.lastTraversedEpoch !== Co && (r.lastTraversedEpoch = Co, "maybeScheduleEffect" in r ? e.add(r) : r.children.visit(n));
    };
    for (const r of t)
      r.children.visit(n);
    for (const r of e)
      r.maybeScheduleEffect();
  } finally {
    zT = !1;
  }
}
function ZG(t, e) {
  Kd ? Kd.initialAtomValues.has(t) || Kd.initialAtomValues.set(t, e) : hL([t]);
}
var Kd = null;
function JG(t) {
  const e = new QG(Kd);
  Kd = e;
  try {
    let n = !1;
    const r = t(() => n = !0);
    return n ? e.abort() : e.commit(), r;
  } catch (n) {
    throw e.abort(), n;
  } finally {
    Kd = Kd.parent;
  }
}
function Ru(t) {
  return Kd ? t() : JG(t);
}
var eX = class {
  constructor(t, e, n) {
    this.name = t, this.current = e, this.isEqual = n?.isEqual ?? null, n && (n.historyLength && (this.historyBuffer = new pL(n.historyLength)), this.computeDiff = n.computeDiff);
  }
  isEqual;
  computeDiff;
  lastChangedEpoch = Co;
  children = new sL();
  historyBuffer;
  __unsafe__getWithoutCapture() {
    return this.current;
  }
  get value() {
    return rP(this), this.current;
  }
  set(t, e) {
    if (this.isEqual?.(this.current, t) ?? uL(this.current, t))
      return this.current;
    qG(), this.historyBuffer && this.historyBuffer.pushEntry(
      this.lastChangedEpoch,
      Co,
      e ?? this.computeDiff?.(this.current, t, this.lastChangedEpoch, Co) ?? fs
    ), this.lastChangedEpoch = Co;
    const n = this.current;
    return this.current = t, ZG(this, n), t;
  }
  update(t) {
    return this.set(t(this.current));
  }
  getDiffSince(t) {
    return rP(this), t >= this.lastChangedEpoch ? Ws : this.historyBuffer?.getChangesSince(t) ?? fs;
  }
};
function hi(t, e, n) {
  return new eX(t, e, n);
}
var iP = Symbol("UNINITIALIZED"), Wg = (t) => t === iP, oP = class {
  constructor(t, e) {
    this.value = t, this.diff = e;
  }
};
function Ly(t, e) {
  return new oP(t, e);
}
var gL = class {
  constructor(t, e, n) {
    this.name = t, this.derive = e, n?.historyLength && (this.historyBuffer = new pL(n.historyLength)), this.computeDiff = n?.computeDiff, this.isEqual = n?.isEqual ?? uL;
  }
  lastChangedEpoch = _p;
  lastTraversedEpoch = _p;
  /**
   * The epoch when the reactor was last checked.
   */
  lastCheckedEpoch = _p;
  parents = [];
  parentEpochs = [];
  children = new sL();
  get isActivelyListening() {
    return !this.children.isEmpty;
  }
  historyBuffer;
  // The last-computed value of this signal.
  state = iP;
  computeDiff;
  isEqual;
  __unsafe__getWithoutCapture() {
    const t = this.lastChangedEpoch === _p;
    if (!t && (this.lastCheckedEpoch === Co || !cL(this)))
      return this.lastCheckedEpoch = Co, this.state;
    try {
      dL(this);
      const e = this.derive(this.state, this.lastCheckedEpoch), n = e instanceof oP ? e.value : e;
      if (this.state === iP || !this.isEqual(n, this.state)) {
        if (this.historyBuffer && !t) {
          const r = e instanceof oP ? e.diff : void 0;
          this.historyBuffer.pushEntry(
            this.lastChangedEpoch,
            Co,
            r ?? this.computeDiff?.(this.state, n, this.lastCheckedEpoch, Co) ?? fs
          );
        }
        this.lastChangedEpoch = Co, this.state = n;
      }
      return this.lastCheckedEpoch = Co, this.state;
    } finally {
      fL();
    }
  }
  get value() {
    const t = this.__unsafe__getWithoutCapture();
    return rP(this), t;
  }
  getDiffSince(t) {
    return this.value, t >= this.lastChangedEpoch ? Ws : this.historyBuffer?.getChangesSince(t) ?? fs;
  }
};
function _O(t = {}, e, n, r) {
  const a = r.get, s = Symbol.for("__signia__computed__" + n);
  return r.get = function() {
    let c = this[s];
    return c || (c = new gL(n, a.bind(this), t), Object.defineProperty(this, s, {
      enumerable: !1,
      configurable: !1,
      writable: !1,
      value: c
    })), c.value;
  }, r;
}
function pt() {
  if (arguments.length === 1) {
    const t = arguments[0];
    return (e, n, r) => _O(t, e, n, r);
  } else
    return typeof arguments[0] == "string" ? new gL(arguments[0], arguments[1], arguments[2]) : _O(void 0, arguments[0], arguments[1], arguments[2]);
}
var Sb = class {
  constructor(t, e, n) {
    this.name = t, this.runEffect = e, this._scheduleEffect = n?.scheduleEffect;
  }
  _isActivelyListening = !1;
  /**
   * Whether this scheduler is attached and actively listening to its parents.
   * @public
   */
  get isActivelyListening() {
    return this._isActivelyListening;
  }
  /** @internal */
  lastTraversedEpoch = _p;
  lastReactedEpoch = _p;
  _scheduleCount = 0;
  /**
   * The number of times this effect has been scheduled.
   * @public
   */
  get scheduleCount() {
    return this._scheduleCount;
  }
  /** @internal */
  parentEpochs = [];
  /** @internal */
  parents = [];
  _scheduleEffect;
  /** @internal */
  maybeScheduleEffect() {
    if (this._isActivelyListening && this.lastReactedEpoch !== Co) {
      if (this.parents.length && !cL(this)) {
        this.lastReactedEpoch = Co;
        return;
      }
      this.scheduleEffect();
    }
  }
  /** @internal */
  scheduleEffect() {
    this._scheduleCount++, this._scheduleEffect ? this._scheduleEffect(this.maybeExecute) : this.execute();
  }
  maybeExecute = () => {
    this._isActivelyListening && this.execute();
  };
  /**
   * Makes this scheduler become 'actively listening' to its parents.
   * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.
   * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling [[EffectScheduler.execute]].
   * @public
   */
  attach() {
    this._isActivelyListening = !0;
    for (let t = 0, e = this.parents.length; t < e; t++)
      vI(this.parents[t], this);
  }
  /**
   * Makes this scheduler stop 'actively listening' to its parents.
   * It will no longer be eligible to receive 'maybeScheduleEffect' calls until [[EffectScheduler.attach]] is called again.
   */
  detach() {
    this._isActivelyListening = !1;
    for (let t = 0, e = this.parents.length; t < e; t++)
      Cx(this.parents[t], this);
  }
  /**
   * Executes the effect immediately and returns the result.
   * @returns The result of the effect.
   */
  execute() {
    try {
      dL(this);
      const t = this.runEffect(this.lastReactedEpoch);
      return this.lastReactedEpoch = Co, t;
    } finally {
      fL();
    }
  }
};
function o1(t, e, n) {
  const r = new Sb(t, e, n);
  return r.attach(), r.scheduleEffect(), () => {
    r.detach();
  };
}
function tX(t, e, n) {
  const r = new Sb(t, e, n);
  return {
    scheduler: r,
    start: (a) => {
      const s = a?.force ?? !1;
      r.attach(), s ? r.scheduleEffect() : r.maybeScheduleEffect();
    },
    stop: () => {
      r.detach();
    }
  };
}
class TO {
  /** The map of items to their cached values. */
  items = /* @__PURE__ */ new WeakMap();
  /**
   * Get the cached value for a given record. If the record is not present in the map, the callback
   * will be used to create the value (with the result being stored in the cache for next time).
   *
   * @param item - The item to get.
   * @param cb - The callback to use to create the value when a cached value is not found.
   */
  get(e, n) {
    return this.items.has(e) || this.items.set(e, n(e)), this.items.get(e);
  }
}
function _x(t) {
  if ({}.NODE_ENV === "production")
    return t;
  const e = Object.getPrototypeOf(t);
  if (e && !(e === Array.prototype || e === Object.prototype))
    throw console.error("cannot include non-js data in a record", t), new Error("cannot include non-js data in a record");
  const n = Object.getOwnPropertyNames(t);
  for (const r of n) {
    const a = t[r];
    a && typeof a == "object" && _x(a);
  }
  return Object.freeze(t);
}
var Tx = { exports: {} };
Tx.exports;
(function(t, e) {
  var n = 200, r = "__lodash_hash_undefined__", a = 1, s = 2, c = 9007199254740991, f = "[object Arguments]", p = "[object Array]", g = "[object AsyncFunction]", y = "[object Boolean]", v = "[object Date]", S = "[object Error]", x = "[object Function]", _ = "[object GeneratorFunction]", T = "[object Map]", I = "[object Number]", D = "[object Null]", N = "[object Object]", j = "[object Promise]", L = "[object Proxy]", z = "[object RegExp]", F = "[object Set]", K = "[object String]", X = "[object Symbol]", se = "[object Undefined]", ue = "[object WeakMap]", pe = "[object ArrayBuffer]", Pe = "[object DataView]", ve = "[object Float32Array]", Y = "[object Float64Array]", le = "[object Int8Array]", Re = "[object Int16Array]", he = "[object Int32Array]", te = "[object Uint8Array]", de = "[object Uint8ClampedArray]", W = "[object Uint16Array]", fe = "[object Uint32Array]", ce = /[\\^$.*+?()[\]{}|]/g, xe = /^\[object .+?Constructor\]$/, $e = /^(?:0|[1-9]\d*)$/, Me = {};
  Me[ve] = Me[Y] = Me[le] = Me[Re] = Me[he] = Me[te] = Me[de] = Me[W] = Me[fe] = !0, Me[f] = Me[p] = Me[pe] = Me[y] = Me[Pe] = Me[v] = Me[S] = Me[x] = Me[T] = Me[I] = Me[N] = Me[z] = Me[F] = Me[K] = Me[ue] = !1;
  var re = typeof da == "object" && da && da.Object === Object && da, Qe = typeof self == "object" && self && self.Object === Object && self, ke = re || Qe || Function("return this")(), rt = e && !e.nodeType && e, St = rt && !0 && t && !t.nodeType && t, Tt = St && St.exports === rt, Le = Tt && re.process, Nt = function() {
    try {
      return Le && Le.binding && Le.binding("util");
    } catch {
    }
  }(), Ke = Nt && Nt.isTypedArray;
  function yt(q, ie) {
    for (var Ue = -1, it = q == null ? 0 : q.length, Pn = 0, Ut = []; ++Ue < it; ) {
      var Kn = q[Ue];
      ie(Kn, Ue, q) && (Ut[Pn++] = Kn);
    }
    return Ut;
  }
  function Xt(q, ie) {
    for (var Ue = -1, it = ie.length, Pn = q.length; ++Ue < it; )
      q[Pn + Ue] = ie[Ue];
    return q;
  }
  function kt(q, ie) {
    for (var Ue = -1, it = q == null ? 0 : q.length; ++Ue < it; )
      if (ie(q[Ue], Ue, q))
        return !0;
    return !1;
  }
  function yn(q, ie) {
    for (var Ue = -1, it = Array(q); ++Ue < q; )
      it[Ue] = ie(Ue);
    return it;
  }
  function Er(q) {
    return function(ie) {
      return q(ie);
    };
  }
  function tn(q, ie) {
    return q.has(ie);
  }
  function Mr(q, ie) {
    return q?.[ie];
  }
  function Ur(q) {
    var ie = -1, Ue = Array(q.size);
    return q.forEach(function(it, Pn) {
      Ue[++ie] = [Pn, it];
    }), Ue;
  }
  function Hn(q, ie) {
    return function(Ue) {
      return q(ie(Ue));
    };
  }
  function xt(q) {
    var ie = -1, Ue = Array(q.size);
    return q.forEach(function(it) {
      Ue[++ie] = it;
    }), Ue;
  }
  var cn = Array.prototype, ni = Function.prototype, An = Object.prototype, qn = ke["__core-js_shared__"], Go = ni.toString, Cr = An.hasOwnProperty, Je = function() {
    var q = /[^.]+$/.exec(qn && qn.keys && qn.keys.IE_PROTO || "");
    return q ? "Symbol(src)_1." + q : "";
  }(), Et = An.toString, nn = RegExp(
    "^" + Go.call(Cr).replace(ce, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), kn = Tt ? ke.Buffer : void 0, xn = ke.Symbol, _r = ke.Uint8Array, ur = An.propertyIsEnumerable, mi = cn.splice, pn = xn ? xn.toStringTag : void 0, vi = Object.getOwnPropertySymbols, On = kn ? kn.isBuffer : void 0, Dn = Hn(Object.keys, Object), ao = Qo(ke, "DataView"), yi = Qo(ke, "Map"), Sa = Qo(ke, "Promise"), Qa = Qo(ke, "Set"), vs = Qo(ke, "WeakMap"), so = Qo(Object, "create"), ys = Fr(ao), lo = Fr(yi), wa = Fr(Sa), co = Fr(Qa), xa = Fr(vs), bi = xn ? xn.prototype : void 0, Mi = bi ? bi.valueOf : void 0;
  function Si(q) {
    var ie = -1, Ue = q == null ? 0 : q.length;
    for (this.clear(); ++ie < Ue; ) {
      var it = q[ie];
      this.set(it[0], it[1]);
    }
  }
  function J() {
    this.__data__ = so ? so(null) : {}, this.size = 0;
  }
  function Be(q) {
    var ie = this.has(q) && delete this.__data__[q];
    return this.size -= ie ? 1 : 0, ie;
  }
  function et(q) {
    var ie = this.__data__;
    if (so) {
      var Ue = ie[q];
      return Ue === r ? void 0 : Ue;
    }
    return Cr.call(ie, q) ? ie[q] : void 0;
  }
  function st(q) {
    var ie = this.__data__;
    return so ? ie[q] !== void 0 : Cr.call(ie, q);
  }
  function Kt(q, ie) {
    var Ue = this.__data__;
    return this.size += this.has(q) ? 0 : 1, Ue[q] = so && ie === void 0 ? r : ie, this;
  }
  Si.prototype.clear = J, Si.prototype.delete = Be, Si.prototype.get = et, Si.prototype.has = st, Si.prototype.set = Kt;
  function qt(q) {
    var ie = -1, Ue = q == null ? 0 : q.length;
    for (this.clear(); ++ie < Ue; ) {
      var it = q[ie];
      this.set(it[0], it[1]);
    }
  }
  function Qt() {
    this.__data__ = [], this.size = 0;
  }
  function Rt(q) {
    var ie = this.__data__, Ue = Qs(ie, q);
    if (Ue < 0)
      return !1;
    var it = ie.length - 1;
    return Ue == it ? ie.pop() : mi.call(ie, Ue, 1), --this.size, !0;
  }
  function Br(q) {
    var ie = this.__data__, Ue = Qs(ie, q);
    return Ue < 0 ? void 0 : ie[Ue][1];
  }
  function Qn(q) {
    return Qs(this.__data__, q) > -1;
  }
  function Zn(q, ie) {
    var Ue = this.__data__, it = Qs(Ue, q);
    return it < 0 ? (++this.size, Ue.push([q, ie])) : Ue[it][1] = ie, this;
  }
  qt.prototype.clear = Qt, qt.prototype.delete = Rt, qt.prototype.get = Br, qt.prototype.has = Qn, qt.prototype.set = Zn;
  function hr(q) {
    var ie = -1, Ue = q == null ? 0 : q.length;
    for (this.clear(); ++ie < Ue; ) {
      var it = q[ie];
      this.set(it[0], it[1]);
    }
  }
  function Ea() {
    this.size = 0, this.__data__ = {
      hash: new Si(),
      map: new (yi || qt)(),
      string: new Si()
    };
  }
  function jl(q) {
    var ie = hn(this, q).delete(q);
    return this.size -= ie ? 1 : 0, ie;
  }
  function bn(q) {
    return hn(this, q).get(q);
  }
  function hf(q) {
    return hn(this, q).has(q);
  }
  function Xo(q, ie) {
    var Ue = hn(this, q), it = Ue.size;
    return Ue.set(q, ie), this.size += Ue.size == it ? 0 : 1, this;
  }
  hr.prototype.clear = Ea, hr.prototype.delete = jl, hr.prototype.get = bn, hr.prototype.has = hf, hr.prototype.set = Xo;
  function Jt(q) {
    var ie = -1, Ue = q == null ? 0 : q.length;
    for (this.__data__ = new hr(); ++ie < Ue; )
      this.add(q[ie]);
  }
  function Ca(q) {
    return this.__data__.set(q, r), this;
  }
  function bs(q) {
    return this.__data__.has(q);
  }
  Jt.prototype.add = Jt.prototype.push = Ca, Jt.prototype.has = bs;
  function uo(q) {
    var ie = this.__data__ = new qt(q);
    this.size = ie.size;
  }
  function Ss() {
    this.__data__ = new qt(), this.size = 0;
  }
  function Wi(q) {
    var ie = this.__data__, Ue = ie.delete(q);
    return this.size = ie.size, Ue;
  }
  function jc(q) {
    return this.__data__.get(q);
  }
  function Ai(q) {
    return this.__data__.has(q);
  }
  function zc(q, ie) {
    var Ue = this.__data__;
    if (Ue instanceof qt) {
      var it = Ue.__data__;
      if (!yi || it.length < n - 1)
        return it.push([q, ie]), this.size = ++Ue.size, this;
      Ue = this.__data__ = new hr(it);
    }
    return Ue.set(q, ie), this.size = Ue.size, this;
  }
  uo.prototype.clear = Ss, uo.prototype.delete = Wi, uo.prototype.get = jc, uo.prototype.has = Ai, uo.prototype.set = zc;
  function Uc(q, ie) {
    var Ue = or(q), it = !Ue && Cs(q), Pn = !Ue && !it && Vl(q), Ut = !Ue && !it && !Pn && Ja(q), Kn = Ue || it || Pn || Ut, Tr = Kn ? yn(q.length, String) : [], Wn = Tr.length;
    for (var U in q)
      (ie || Cr.call(q, U)) && !(Kn && // Safari 9 has enumerable `arguments.length` in strict mode.
      (U == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      Pn && (U == "offset" || U == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Ut && (U == "buffer" || U == "byteLength" || U == "byteOffset") || // Skip index properties.
      Fl(U, Wn))) && Tr.push(U);
    return Tr;
  }
  function Qs(q, ie) {
    for (var Ue = q.length; Ue--; )
      if (xi(q[Ue][0], ie))
        return Ue;
    return -1;
  }
  function zl(q, ie, Ue) {
    var it = ie(q);
    return or(q) ? it : Xt(it, Ue(q));
  }
  function Po(q) {
    return q == null ? q === void 0 ? se : D : pn && pn in Object(q) ? Js(q) : gr(q);
  }
  function Io(q) {
    return fo(q) && Po(q) == f;
  }
  function wi(q, ie, Ue, it, Pn) {
    return q === ie ? !0 : q == null || ie == null || !fo(q) && !fo(ie) ? q !== q && ie !== ie : ws(q, ie, Ue, it, wi, Pn);
  }
  function ws(q, ie, Ue, it, Pn, Ut) {
    var Kn = or(q), Tr = or(ie), Wn = Kn ? p : rn(q), U = Tr ? p : rn(ie);
    Wn = Wn == f ? N : Wn, U = U == f ? N : U;
    var Z = Wn == N, ye = U == N, Ee = Wn == U;
    if (Ee && Vl(q)) {
      if (!Vl(ie))
        return !1;
      Kn = !0, Z = !1;
    }
    if (Ee && !Z)
      return Ut || (Ut = new uo()), Kn || Ja(q) ? Zs(q, ie, Ue, it, Pn, Ut) : Za(q, ie, Wn, Ue, it, Pn, Ut);
    if (!(Ue & a)) {
      var Fe = Z && Cr.call(q, "__wrapped__"), ht = ye && Cr.call(ie, "__wrapped__");
      if (Fe || ht) {
        var Ze = Fe ? q.value() : q, bt = ht ? ie.value() : ie;
        return Ut || (Ut = new uo()), Pn(Ze, bt, Ue, it, Ut);
      }
    }
    return Ee ? (Ut || (Ut = new uo()), gf(q, ie, Ue, it, Pn, Ut)) : !1;
  }
  function xs(q) {
    if (!Bc(q) || Ft(q))
      return !1;
    var ie = Gr(q) ? nn : xe;
    return ie.test(Fr(q));
  }
  function Es(q) {
    return fo(q) && Zo(q.length) && !!Me[Po(q)];
  }
  function Ul(q) {
    if (!el(q))
      return Dn(q);
    var ie = [];
    for (var Ue in Object(q))
      Cr.call(q, Ue) && Ue != "constructor" && ie.push(Ue);
    return ie;
  }
  function Zs(q, ie, Ue, it, Pn, Ut) {
    var Kn = Ue & a, Tr = q.length, Wn = ie.length;
    if (Tr != Wn && !(Kn && Wn > Tr))
      return !1;
    var U = Ut.get(q);
    if (U && Ut.get(ie))
      return U == ie;
    var Z = -1, ye = !0, Ee = Ue & s ? new Jt() : void 0;
    for (Ut.set(q, ie), Ut.set(ie, q); ++Z < Tr; ) {
      var Fe = q[Z], ht = ie[Z];
      if (it)
        var Ze = Kn ? it(ht, Fe, Z, ie, q, Ut) : it(Fe, ht, Z, q, ie, Ut);
      if (Ze !== void 0) {
        if (Ze)
          continue;
        ye = !1;
        break;
      }
      if (Ee) {
        if (!kt(ie, function(bt, Yt) {
          if (!tn(Ee, Yt) && (Fe === bt || Pn(Fe, bt, Ue, it, Ut)))
            return Ee.push(Yt);
        })) {
          ye = !1;
          break;
        }
      } else if (!(Fe === ht || Pn(Fe, ht, Ue, it, Ut))) {
        ye = !1;
        break;
      }
    }
    return Ut.delete(q), Ut.delete(ie), ye;
  }
  function Za(q, ie, Ue, it, Pn, Ut, Kn) {
    switch (Ue) {
      case Pe:
        if (q.byteLength != ie.byteLength || q.byteOffset != ie.byteOffset)
          return !1;
        q = q.buffer, ie = ie.buffer;
      case pe:
        return !(q.byteLength != ie.byteLength || !Ut(new _r(q), new _r(ie)));
      case y:
      case v:
      case I:
        return xi(+q, +ie);
      case S:
        return q.name == ie.name && q.message == ie.message;
      case z:
      case K:
        return q == ie + "";
      case T:
        var Tr = Ur;
      case F:
        var Wn = it & a;
        if (Tr || (Tr = xt), q.size != ie.size && !Wn)
          return !1;
        var U = Kn.get(q);
        if (U)
          return U == ie;
        it |= s, Kn.set(q, ie);
        var Z = Zs(Tr(q), Tr(ie), it, Pn, Ut, Kn);
        return Kn.delete(q), Z;
      case X:
        if (Mi)
          return Mi.call(q) == Mi.call(ie);
    }
    return !1;
  }
  function gf(q, ie, Ue, it, Pn, Ut) {
    var Kn = Ue & a, Tr = qo(q), Wn = Tr.length, U = qo(ie), Z = U.length;
    if (Wn != Z && !Kn)
      return !1;
    for (var ye = Wn; ye--; ) {
      var Ee = Tr[ye];
      if (!(Kn ? Ee in ie : Cr.call(ie, Ee)))
        return !1;
    }
    var Fe = Ut.get(q);
    if (Fe && Ut.get(ie))
      return Fe == ie;
    var ht = !0;
    Ut.set(q, ie), Ut.set(ie, q);
    for (var Ze = Kn; ++ye < Wn; ) {
      Ee = Tr[ye];
      var bt = q[Ee], Yt = ie[Ee];
      if (it)
        var gn = Kn ? it(Yt, bt, Ee, ie, q, Ut) : it(bt, Yt, Ee, q, ie, Ut);
      if (!(gn === void 0 ? bt === Yt || Pn(bt, Yt, Ue, it, Ut) : gn)) {
        ht = !1;
        break;
      }
      Ze || (Ze = Ee == "constructor");
    }
    if (ht && !Ze) {
      var Ln = q.constructor, In = ie.constructor;
      Ln != In && "constructor" in q && "constructor" in ie && !(typeof Ln == "function" && Ln instanceof Ln && typeof In == "function" && In instanceof In) && (ht = !1);
    }
    return Ut.delete(q), Ut.delete(ie), ht;
  }
  function qo(q) {
    return zl(q, Yu, Bl);
  }
  function hn(q, ie) {
    var Ue = q.__data__;
    return Hl(ie) ? Ue[typeof ie == "string" ? "string" : "hash"] : Ue.map;
  }
  function Qo(q, ie) {
    var Ue = Mr(q, ie);
    return xs(Ue) ? Ue : void 0;
  }
  function Js(q) {
    var ie = Cr.call(q, pn), Ue = q[pn];
    try {
      q[pn] = void 0;
      var it = !0;
    } catch {
    }
    var Pn = Et.call(q);
    return it && (ie ? q[pn] = Ue : delete q[pn]), Pn;
  }
  var Bl = vi ? function(q) {
    return q == null ? [] : (q = Object(q), yt(vi(q), function(ie) {
      return ur.call(q, ie);
    }));
  } : Ro, rn = Po;
  (ao && rn(new ao(new ArrayBuffer(1))) != Pe || yi && rn(new yi()) != T || Sa && rn(Sa.resolve()) != j || Qa && rn(new Qa()) != F || vs && rn(new vs()) != ue) && (rn = function(q) {
    var ie = Po(q), Ue = ie == N ? q.constructor : void 0, it = Ue ? Fr(Ue) : "";
    if (it)
      switch (it) {
        case ys:
          return Pe;
        case lo:
          return T;
        case wa:
          return j;
        case co:
          return F;
        case xa:
          return ue;
      }
    return ie;
  });
  function Fl(q, ie) {
    return ie = ie ?? c, !!ie && (typeof q == "number" || $e.test(q)) && q > -1 && q % 1 == 0 && q < ie;
  }
  function Hl(q) {
    var ie = typeof q;
    return ie == "string" || ie == "number" || ie == "symbol" || ie == "boolean" ? q !== "__proto__" : q === null;
  }
  function Ft(q) {
    return !!Je && Je in q;
  }
  function el(q) {
    var ie = q && q.constructor, Ue = typeof ie == "function" && ie.prototype || An;
    return q === Ue;
  }
  function gr(q) {
    return Et.call(q);
  }
  function Fr(q) {
    if (q != null) {
      try {
        return Go.call(q);
      } catch {
      }
      try {
        return q + "";
      } catch {
      }
    }
    return "";
  }
  function xi(q, ie) {
    return q === ie || q !== q && ie !== ie;
  }
  var Cs = Io(function() {
    return arguments;
  }()) ? Io : function(q) {
    return fo(q) && Cr.call(q, "callee") && !ur.call(q, "callee");
  }, or = Array.isArray;
  function Nn(q) {
    return q != null && Zo(q.length) && !Gr(q);
  }
  var Vl = On || _s;
  function Gi(q, ie) {
    return wi(q, ie);
  }
  function Gr(q) {
    if (!Bc(q))
      return !1;
    var ie = Po(q);
    return ie == x || ie == _ || ie == g || ie == L;
  }
  function Zo(q) {
    return typeof q == "number" && q > -1 && q % 1 == 0 && q <= c;
  }
  function Bc(q) {
    var ie = typeof q;
    return q != null && (ie == "object" || ie == "function");
  }
  function fo(q) {
    return q != null && typeof q == "object";
  }
  var Ja = Ke ? Er(Ke) : Es;
  function Yu(q) {
    return Nn(q) ? Uc(q) : Ul(q);
  }
  function Ro() {
    return [];
  }
  function _s() {
    return !1;
  }
  t.exports = Gi;
})(Tx, Tx.exports);
var nX = Tx.exports;
const rX = /* @__PURE__ */ jp(nX);
function iX(t) {
  if (t.length === 0)
    return /* @__PURE__ */ new Set();
  const e = t[0], n = t.slice(1), r = /* @__PURE__ */ new Set();
  for (const a of e)
    n.every((s) => s.has(a)) && r.add(a);
  return r;
}
function oX(t, e) {
  const n = {};
  for (const r of e)
    t.has(r) || (n.added ??= /* @__PURE__ */ new Set(), n.added.add(r));
  for (const r of t)
    e.has(r) || (n.removed ??= /* @__PURE__ */ new Set(), n.removed.add(r));
  return n.added || n.removed ? n : void 0;
}
function kO(t, e) {
  for (const [n, r] of Object.entries(t)) {
    const a = r, s = e[n];
    if ("eq" in a && s !== a.eq || "neq" in a && s === a.neq || "gt" in a && (typeof s != "number" || s <= a.gt))
      return !1;
  }
  return !0;
}
function PO(t, e, n) {
  const r = Object.fromEntries(Object.keys(n).map((a) => [a, /* @__PURE__ */ new Set()]));
  for (const [a, s] of Object.entries(n))
    if ("eq" in s) {
      const f = t.index(e, a).value.get(s.eq);
      if (f)
        for (const p of f)
          r[a].add(p);
    } else if ("neq" in s) {
      const c = t.index(e, a);
      for (const [f, p] of c.value)
        if (f !== s.neq)
          for (const g of p)
            r[a].add(g);
    } else if ("gt" in s) {
      const c = t.index(e, a);
      for (const [f, p] of c.value)
        if (f > s.gt)
          for (const g of p)
            r[a].add(g);
    }
  return iX(Object.values(r));
}
class aX {
  constructor(e, n) {
    this.atoms = e, this.history = n;
  }
  /**
   * A cache of derivations (indexes).
   *
   * @internal
   */
  indexCache = /* @__PURE__ */ new Map();
  /**
   * A cache of derivations (filtered histories).
   *
   * @internal
   */
  historyCache = /* @__PURE__ */ new Map();
  /**
   * Create a derivation that contains the hisotry for a given type
   *
   * @param typeName - The name of the type to filter by.
   *
   * @returns A derivation that returns the ids of all records of the given type.
   * @public
   */
  filterHistory(e) {
    if (this.historyCache.has(e))
      return this.historyCache.get(e);
    const n = pt(
      "filterHistory:" + e,
      (r, a) => {
        if (Wg(r))
          return this.history.value;
        const s = this.history.getDiffSince(a);
        if (s === fs)
          return this.history.value;
        const c = { added: {}, removed: {}, updated: {} };
        let f = 0, p = 0, g = 0;
        for (const y of s) {
          for (const v of Object.values(y.added))
            if (v.typeName === e)
              if (c.removed[v.id]) {
                const S = c.removed[v.id];
                delete c.removed[v.id], p--, S !== v && (c.updated[v.id] = [S, v], g++);
              } else
                c.added[v.id] = v, f++;
          for (const [v, S] of Object.values(y.updated))
            S.typeName === e && (c.added[S.id] ? c.added[S.id] = S : c.updated[S.id] ? c.updated[S.id] = [c.updated[S.id][0], S] : (c.updated[S.id] = [v, S], g++));
          for (const v of Object.values(y.removed))
            v.typeName === e && (c.added[v.id] ? (delete c.added[v.id], f--) : c.updated[v.id] ? (c.removed[v.id] = c.updated[v.id][0], delete c.updated[v.id], g--, p++) : (c.removed[v.id] = v, p++));
        }
        return f || p || g ? Ly(this.history.value, c) : r;
      },
      { historyLength: 100 }
    );
    return this.historyCache.set(e, n), n;
  }
  /**
   * Create a derivation that returns an index on a property for the given type.
   *
   * @param typeName - The name of the type.
   * @param property - The name of the property.
   *
   * @public
   */
  index(e, n) {
    const r = e + ":" + n;
    if (this.indexCache.has(r))
      return this.indexCache.get(r);
    const a = this.__uncached_createIndex(e, n);
    return this.indexCache.set(r, a), a;
  }
  /**
   * Create a derivation that returns an index on a property for the given type.
   *
   * @param typeName - The name of the type?.
   * @param property - The name of the property?.
   *
   * @internal
   */
  __uncached_createIndex(e, n) {
    const r = this.filterHistory(e), a = () => {
      r.value;
      const s = /* @__PURE__ */ new Map();
      for (const c of Object.values(this.atoms.value)) {
        const f = c.value;
        if (f.typeName === e) {
          const p = f[n];
          s.has(p) || s.set(p, /* @__PURE__ */ new Set()), s.get(p).add(f.id);
        }
      }
      return s;
    };
    return pt(
      "index:" + e + ":" + n,
      (s, c) => {
        if (Wg(s))
          return a();
        const f = r.getDiffSince(c);
        if (f === fs)
          return a();
        const p = /* @__PURE__ */ new Map(), g = (x, _) => {
          let T = p.get(x);
          T || (T = new cx(s.get(x) ?? /* @__PURE__ */ new Set())), T.add(_), p.set(x, T);
        }, y = (x, _) => {
          let T = p.get(x);
          T || (T = new cx(s.get(x) ?? /* @__PURE__ */ new Set())), T.remove(_), p.set(x, T);
        };
        for (const x of f) {
          for (const _ of Object.values(x.added))
            if (_.typeName === e) {
              const T = _[n];
              g(T, _.id);
            }
          for (const [_, T] of Object.values(x.updated))
            if (T.typeName === e) {
              const I = _[n], D = T[n];
              I !== D && (y(I, T.id), g(D, T.id));
            }
          for (const _ of Object.values(x.removed))
            if (_.typeName === e) {
              const T = _[n];
              y(T, _.id);
            }
        }
        let v, S;
        for (const [x, _] of p) {
          const T = _.get();
          T && (v || (v = new Map(s)), S || (S = /* @__PURE__ */ new Map()), T.value.size === 0 ? v.delete(x) : v.set(x, T.value), S.set(x, T.diff));
        }
        return v && S ? Ly(v, S) : s;
      },
      { historyLength: 100 }
    );
  }
  /**
   * Create a derivation that will return a signle record matching the given query.
   *
   * It will return undefined if there is no matching record
   *
   * @param typeName - The name of the type?
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */
  record(e, n = () => ({}), r = "record:" + e + (n ? ":" + n.toString() : "")) {
    const a = this.ids(e, n, r);
    return pt(r, () => {
      for (const s of a.value)
        return this.atoms.value[s]?.value;
    });
  }
  /**
   * Create a derivation that will return an array of records matching the given query
   *
   * @param typeName - The name of the type?
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */
  records(e, n = () => ({}), r = "records:" + e + (n ? ":" + n.toString() : "")) {
    const a = this.ids(e, n, "ids:" + r);
    return pt(r, () => [...a.value].map((s) => {
      const c = this.atoms.value[s];
      if (!c)
        throw new Error("no atom found for record id: " + s);
      return c.value;
    }));
  }
  /**
   * Create a derivation that will return the ids of all records of the given type.
   *
   * @param typeName - The name of the type.
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */
  ids(e, n = () => ({}), r = "ids:" + e + (n ? ":" + n.toString() : "")) {
    const a = this.filterHistory(e), s = () => {
      a.value;
      const p = n();
      return Object.keys(p).length === 0 ? new Set(
        Object.values(this.atoms.value).flatMap((g) => {
          const y = g.value;
          return y.typeName === e ? y.id : [];
        })
      ) : PO(this, e, p);
    }, c = (p) => {
      const g = s(), y = oX(p, g);
      return y ? Ly(g, y) : p;
    }, f = pt("ids_query:" + r, n, {
      isEqual: rX
    });
    return pt(
      "query:" + r,
      (p, g) => {
        const y = f.value;
        if (Wg(p))
          return s();
        if (g < f.lastChangedEpoch)
          return c(p);
        const v = a.getDiffSince(g);
        if (v === fs)
          return c(p);
        const S = new cx(
          p
        );
        for (const _ of v) {
          for (const T of Object.values(_.added))
            T.typeName === e && kO(y, T) && S.add(T.id);
          for (const [T, I] of Object.values(_.updated))
            I.typeName === e && (kO(y, I) ? S.add(I.id) : S.remove(I.id));
          for (const T of Object.values(_.removed))
            T.typeName === e && S.remove(T.id);
        }
        const x = S.get();
        return x ? Ly(x.value, x.diff) : p;
      },
      { historyLength: 50 }
    );
  }
  exec(e, n) {
    const r = PO(this, e, n);
    if (r.size === 0)
      return Ws;
    const a = this.atoms.value;
    return [...r].map((s) => a[s].value);
  }
}
class mL {
  /**
   * An atom containing the store's atoms.
   *
   * @internal
   * @readonly
   */
  atoms = hi("store_atoms", {});
  /**
   * An atom containing the store's history.
   *
   * @public
   * @readonly
   */
  history = hi("history", 0, {
    historyLength: 1e3
  });
  /**
   * A StoreQueries instance for this store.
   *
   * @public
   * @readonly
   */
  query = new aX(this.atoms, this.history);
  /**
   * A set containing listeners that have been added to this store.
   *
   * @internal
   */
  listeners = /* @__PURE__ */ new Set();
  /**
   * An array of history entries that have not yet been flushed.
   *
   * @internal
   */
  historyAccumulator = new lX();
  /**
   * A reactor that responds to changes to the history by squashing the
   * accumulated history and notifying listeners of the changes.
   *
   * @internal
   */
  historyReactor;
  schema;
  props;
  constructor(e) {
    const { initialData: n, schema: r } = e;
    this.schema = r, this.props = e.props, n && this.atoms.set(
      Object.fromEntries(
        Object.entries(n).map(([a, s]) => [
          a,
          hi("atom:" + a, this.schema.validateRecord(this, s, "initialize", null))
        ])
      )
    ), this.historyReactor = tX(
      "Store.historyReactor",
      () => {
        this.history.value, this._flushHistory();
      },
      { scheduleEffect: (a) => requestAnimationFrame(a) }
    );
  }
  _flushHistory() {
    if (this.historyAccumulator.hasChanges()) {
      const e = this.historyAccumulator.flush();
      for (const { changes: n, source: r } of e)
        this.listeners.forEach((a) => a({ changes: n, source: r }));
    }
  }
  /**
   * Update the history with a diff of changes.
   *
   * @param changes - The changes to add to the history.
   */
  updateHistory(e) {
    this.historyAccumulator.add({
      changes: e,
      source: this.isMergingRemoteChanges ? "remote" : "user"
    }), this.listeners.size === 0 && this.historyAccumulator.clear(), this.history.set(this.history.value + 1, e);
  }
  validate(e) {
    this.allRecords().forEach((n) => this.schema.validateRecord(this, n, e, null));
  }
  /**
   * A callback fired after a record is created. Use this to perform
   * related updates to other records in the store.
   *
   * @param record - The record to be created
   */
  onAfterCreate;
  /**
   * A callback fired after each record's change.
   *
   * @param prev - The previous value, if any.
   * @param next - The next value.
   */
  onAfterChange;
  /**
   * A callback fired before a record is deleted.
   *
   * @param prev - The record that will be deleted.
   */
  onBeforeDelete;
  /**
   * A callback fired after a record is deleted.
   *
   * @param prev - The record that will be deleted.
   */
  onAfterDelete;
  // used to avoid running callbacks when rolling back changes in sync client
  _runCallbacks = !0;
  /**
   * Add some records to the store. It's an error if they already exist.
   *
   * @param records - The records to add.
   * @public
   */
  put = (e, n) => {
    Ru(() => {
      const r = {}, a = {}, s = this.atoms.__unsafe__getWithoutCapture();
      let c = null, f, p = !1;
      for (let v = 0, S = e.length; v < S; v++) {
        f = e[v];
        const x = (c ?? s)[f.id];
        if (x) {
          const _ = x.__unsafe__getWithoutCapture();
          f = this.schema.validateRecord(
            this,
            f,
            n ?? "updateRecord",
            _
          ), x.set(_x(f));
          const T = x.__unsafe__getWithoutCapture();
          _ !== T && (p = !0, r[f.id] = [_, T]);
        } else
          p = !0, f = this.schema.validateRecord(
            this,
            f,
            n ?? "createRecord",
            null
          ), a[f.id] = f, c || (c = { ...s }), c[f.id] = hi("atom:" + f.id, f);
      }
      if (c && this.atoms.set(c), !p)
        return;
      this.updateHistory({
        added: a,
        updated: r,
        removed: {}
      });
      const { onAfterCreate: g, onAfterChange: y } = this;
      g && this._runCallbacks && Object.values(a).forEach((v) => {
        g(v);
      }), y && this._runCallbacks && Object.values(r).forEach(([v, S]) => {
        y(v, S);
      });
    });
  };
  /**
   * Remove some records from the store via their ids.
   *
   * @param ids - The ids of the records to remove.
   * @public
   */
  remove = (e) => {
    Ru(() => {
      if (this.onBeforeDelete && this._runCallbacks)
        for (const r of e) {
          const a = this.atoms.__unsafe__getWithoutCapture()[r];
          a && this.onBeforeDelete(a.value);
        }
      let n;
      if (this.atoms.update((r) => {
        let a;
        for (const s of e)
          s in r && (a || (a = { ...r }), n || (n = {}), delete a[s], n[s] = r[s].value);
        return a ?? r;
      }), !!n && (this.updateHistory({ added: {}, updated: {}, removed: n }), this.onAfterDelete && this._runCallbacks))
        for (let r = 0, a = e.length; r < a; r++)
          this.onAfterDelete(n[e[r]]);
    });
  };
  /**
   * Get the value of a store record by its id.
   *
   * @param id - The id of the record to get.
   * @public
   */
  get = (e) => this.atoms.value[e]?.value;
  /**
   * Get the value of a store record by its id without updating its epoch.
   *
   * @param id - The id of the record to get.
   * @public
   */
  unsafeGetWithoutCapture = (e) => this.atoms.value[e]?.__unsafe__getWithoutCapture();
  /**
   * Opposite of `deserialize`. Creates a JSON payload from the record store.
   *
   * @param filter - A function to filter structs that do not satisfy the predicate.
   * @returns The record store snapshot as a JSON payload.
   */
  serialize = (e) => {
    const n = {};
    for (const [r, a] of Object.entries(this.atoms.value)) {
      const s = a.value;
      typeof e == "function" && !e(s) || (n[r] = s);
    }
    return n;
  };
  /**
   * Opposite of `serialize`. Replace the store's current records with records as defined by a simple JSON structure into the stores.
   *
   * @param snapshot - The JSON snapshot to deserialize.
   * @public
   */
  deserialize = (e) => {
    Ru(() => {
      this.clear(), this.put(Object.values(e));
    });
  };
  /**
   * Get an array of all values in the store.
   *
   * @public
   * @returns An array of all values in the store.
   */
  allRecords = () => Object.values(this.atoms.value).map((e) => e.value);
  /**
   * Removes all records from the store.
   *
   * @public
   */
  clear = () => {
    this.remove(Object.keys(this.atoms.value));
  };
  /**
   * Update a record. To update multiple records at once, use the `update` method of the `TypedStore` class.
   *
   * @param id - The id of the record to update.
   * @param updater - A function that updates the record.
   */
  update = (e, n) => {
    const r = this.atoms.value[e];
    if (!r) {
      console.error(`Record ${e} not found. This is probably an error`);
      return;
    }
    this.put([n(r.__unsafe__getWithoutCapture())]);
  };
  /**
   * Get whether the record store has a id.
   *
   * @param id - The id of the record to check.
   * @public
   */
  has = (e) => !!this.atoms.value[e];
  /**
   * Add a new listener to the store.
   *
   * @param listener - The listener to call when the store updates.
   * @returns A function to remove the listener.
   */
  listen = (e) => (this._flushHistory(), this.listeners.add(e), this.historyReactor.scheduler.isActivelyListening || this.historyReactor.start(), () => {
    this.listeners.delete(e), this.listeners.size === 0 && this.historyReactor.stop();
  });
  isMergingRemoteChanges = !1;
  /**
   * Merge changes from a remote source without triggering listeners.
   *
   * @param fn - A function that merges the external changes.
   * @public
   */
  mergeRemoteChanges = (e) => {
    if (this.isMergingRemoteChanges)
      return e();
    try {
      this.isMergingRemoteChanges = !0, Ru(e);
    } finally {
      this.isMergingRemoteChanges = !1;
    }
  };
  extractingChanges(e) {
    const n = [], r = this.historyAccumulator.intercepting((a) => n.push(a.changes));
    try {
      return Ru(e), vL(n);
    } finally {
      r();
    }
  }
  applyDiff(e, n = !0) {
    const r = this._runCallbacks;
    try {
      this._runCallbacks = n, Ru(() => {
        const a = Object.values(e.added).concat(
          Object.values(e.updated).map(([c, f]) => f)
        ), s = Object.keys(e.removed);
        a.length && this.put(a), s.length && this.remove(s);
      });
    } finally {
      this._runCallbacks = r;
    }
  }
  /**
   * Create a computed cache.
   *
   * @param name - The name of the derivation cache.
   * @param derive - A function used to derive the value of the cache.
   * @public
   */
  createComputedCache = (e, n) => {
    const r = new TO();
    return {
      get: (a) => {
        const s = this.atoms.value[a];
        if (s)
          return r.get(
            s,
            () => pt(e + ":" + a, () => n(s.value))
          ).value;
      }
    };
  };
  /**
   * Create a computed cache from a selector
   *
   * @param name - The name of the derivation cache.
   * @param selector - A function that returns a subset of the original shape
   * @param derive - A function used to derive the value of the cache.
   * @public
   */
  createSelectedComputedCache = (e, n, r) => {
    const a = new TO();
    return {
      get: (s) => {
        const c = this.atoms.value[s];
        if (!c)
          return;
        const f = pt(
          e + ":" + s + ":selector",
          () => n(c.value)
        );
        return a.get(
          c,
          () => pt(e + ":" + s, () => r(f.value))
        ).value;
      }
    };
  };
  /** @internal */
  ensureStoreIsUsable() {
    this.schema.ensureStoreIsUsable(this);
  }
  _isPossiblyCorrupted = !1;
  /** @internal */
  markAsPossiblyCorrupted() {
    this._isPossiblyCorrupted = !0;
  }
  /** @internal */
  isPossiblyCorrupted() {
    return this._isPossiblyCorrupted;
  }
}
function vL(t) {
  const e = { added: {}, removed: {}, updated: {} };
  for (const n of t) {
    for (const [r, a] of Object.entries(n.added))
      if (e.removed[r]) {
        const s = e.removed[r];
        delete e.removed[r], s !== a && (e.updated[r] = [s, a]);
      } else
        e.added[r] = a;
    for (const [r, [a, s]] of Object.entries(n.updated)) {
      if (e.added[r]) {
        e.added[r] = s, delete e.updated[r], delete e.removed[r];
        continue;
      }
      if (e.updated[r]) {
        e.updated[r][1] = s, delete e.removed[r];
        continue;
      }
      e.updated[r] = n.updated[r], delete e.removed[r];
    }
    for (const [r, a] of Object.entries(n.removed))
      e.added[r] ? delete e.added[r] : e.updated[r] ? (e.removed[r] = e.updated[r][0], delete e.updated[r]) : e.removed[r] = a;
  }
  return e;
}
function sX(t) {
  const e = [];
  let n = t[0], r;
  for (let a = 1, s = t.length; a < s; a++)
    r = t[a], n.source !== r.source ? (e.push(n), n = r) : n = {
      source: n.source,
      changes: vL([n.changes, r.changes])
    };
  return e.push(n), e;
}
class lX {
  _history = [];
  _inteceptors = /* @__PURE__ */ new Set();
  intercepting(e) {
    return this._inteceptors.add(e), () => {
      this._inteceptors.delete(e);
    };
  }
  add(e) {
    this._history.push(e);
    for (const n of this._inteceptors)
      n(e);
  }
  flush() {
    const e = sX(this._history);
    return this._history = [], e;
  }
  clear() {
    this._history = [];
  }
  hasChanges() {
    return this._history.length > 0;
  }
  /**
   * Ensure that the store is usable. A class that extends this store should override this method.
   *
   * @param config - The configuration object. This can be any object that allows the store to validate that it is usable; the extending class should specify the type.
   *
   * @public
   */
  ensureStoreIsUsable(e = {}) {
  }
}
function cX(t) {
  return typeof t == "object" && t !== null && "id" in t && "typeName" in t;
}
function xr({
  firstVersion: t,
  currentVersion: e,
  migrators: n,
  subTypeKey: r,
  subTypeMigrations: a
}) {
  return { currentVersion: e, firstVersion: t, migrators: n, subTypeKey: r, subTypeMigrations: a };
}
var jy = /* @__PURE__ */ ((t) => (t.IncompatibleSubtype = "incompatible-subtype", t.UnknownType = "unknown-type", t.TargetVersionTooNew = "target-version-too-new", t.TargetVersionTooOld = "target-version-too-old", t.MigrationError = "migration-error", t.UnrecognizedSubtype = "unrecognized-subtype", t))(jy || {});
function Pw({
  record: t,
  migrations: e,
  fromVersion: n,
  toVersion: r
}) {
  let a = n;
  if (!cX(t))
    throw new Error("[migrateRecord] object is not a record");
  const { typeName: s, id: c, ...f } = t;
  let p = f;
  for (; a < r; ) {
    const g = a + 1, y = e.migrators[g];
    if (!y)
      return {
        type: "error",
        reason: "target-version-too-new"
        /* TargetVersionTooNew */
      };
    p = y.up(p), a = g;
  }
  for (; a > r; ) {
    const g = a - 1, y = e.migrators[a];
    if (!y)
      return {
        type: "error",
        reason: "target-version-too-old"
        /* TargetVersionTooOld */
      };
    p = y.down(p), a = g;
  }
  return {
    type: "success",
    value: { ...p, id: c, typeName: s }
  };
}
function uX({
  value: t,
  migrations: e,
  fromVersion: n,
  toVersion: r
}) {
  let a = n;
  for (; a < r; ) {
    const s = a + 1, c = e.migrators[s];
    if (!c)
      return {
        type: "error",
        reason: "target-version-too-new"
        /* TargetVersionTooNew */
      };
    t = c.up(t), a = s;
  }
  for (; a > r; ) {
    const s = a - 1, c = e.migrators[a];
    if (!c)
      return {
        type: "error",
        reason: "target-version-too-old"
        /* TargetVersionTooOld */
      };
    t = c.down(t), a = s;
  }
  return {
    type: "success",
    value: t
  };
}
class yI {
  constructor(e, n) {
    this.types = e, this.options = n;
  }
  static create(e, n) {
    return new yI(e, n ?? {});
  }
  get currentStoreVersion() {
    return this.options.snapshotMigrations?.currentVersion ?? 0;
  }
  validateRecord(e, n, r, a) {
    try {
      const s = Ex(this.types, n.typeName);
      if (!s)
        throw new Error(`Missing definition for record type ${n.typeName}`);
      return s.validate(n);
    } catch (s) {
      if (this.options.onValidationFailure)
        return this.options.onValidationFailure({
          store: e,
          record: n,
          phase: r,
          recordBefore: a,
          error: s
        });
      throw s;
    }
  }
  migratePersistedRecord(e, n, r = "up") {
    const a = Ex(this.types, e.typeName), s = n.recordVersions[e.typeName];
    if (!s || !a)
      return { type: "error", reason: jy.UnknownType };
    const c = a.migrations.currentVersion, f = s.version;
    if (c !== f) {
      const v = Pw(r === "up" ? {
        record: e,
        migrations: a.migrations,
        fromVersion: f,
        toVersion: c
      } : {
        record: e,
        migrations: a.migrations,
        fromVersion: c,
        toVersion: f
      });
      if (v.type === "error")
        return v;
      e = v.value;
    }
    if (!a.migrations.subTypeKey)
      return { type: "success", value: e };
    const p = a.migrations.subTypeMigrations?.[e[a.migrations.subTypeKey]], g = "subTypeVersions" in s ? s.subTypeVersions[e[a.migrations.subTypeKey]] : null;
    if (p === void 0)
      return { type: "error", reason: jy.UnrecognizedSubtype };
    if (g == null)
      return { type: "error", reason: jy.IncompatibleSubtype };
    const y = Pw(r === "up" ? {
      record: e,
      migrations: p,
      fromVersion: g,
      toVersion: p.currentVersion
    } : {
      record: e,
      migrations: p,
      fromVersion: p.currentVersion,
      toVersion: g
    });
    return y.type === "error" ? y : { type: "success", value: y.value };
  }
  migrateStoreSnapshot(e, n) {
    const r = this.options.snapshotMigrations;
    if (!r)
      return { type: "success", value: e };
    const a = r.currentVersion, s = n.storeVersion ?? 0;
    if (a < s)
      return { type: "error", reason: jy.TargetVersionTooOld };
    if (a > s) {
      const f = uX({
        value: e,
        migrations: r,
        fromVersion: s,
        toVersion: a
      });
      if (f.type === "error")
        return f;
      e = f.value;
    }
    const c = [];
    for (const f of Object.values(e)) {
      const p = this.migratePersistedRecord(f, n);
      if (p.type === "error")
        return p;
      p.value && p.value !== f && c.push(p.value);
    }
    if (c.length) {
      e = { ...e };
      for (const f of c)
        e[f.id] = f;
    }
    return { type: "success", value: e };
  }
  /** @internal */
  ensureStoreIsUsable(e) {
    this.options.ensureStoreIsUsable?.(e);
  }
  serialize() {
    return {
      schemaVersion: 1,
      storeVersion: this.options.snapshotMigrations?.currentVersion ?? 0,
      recordVersions: Object.fromEntries(
        wO(this.types).map((e) => [
          e.typeName,
          e.migrations.subTypeKey && e.migrations.subTypeMigrations ? {
            version: e.migrations.currentVersion,
            subTypeKey: e.migrations.subTypeKey,
            subTypeVersions: e.migrations.subTypeMigrations ? Object.fromEntries(
              Object.entries(e.migrations.subTypeMigrations).map(([n, r]) => [
                n,
                r.currentVersion
              ])
            ) : void 0
          } : {
            version: e.migrations.currentVersion
          }
        ])
      )
    };
  }
  serializeEarliestVersion() {
    return {
      schemaVersion: 1,
      storeVersion: this.options.snapshotMigrations?.firstVersion ?? 0,
      recordVersions: Object.fromEntries(
        wO(this.types).map((e) => [
          e.typeName,
          e.migrations.subTypeKey && e.migrations.subTypeMigrations ? {
            version: e.migrations.firstVersion,
            subTypeKey: e.migrations.subTypeKey,
            subTypeVersions: e.migrations.subTypeMigrations ? Object.fromEntries(
              Object.entries(e.migrations.subTypeMigrations).map(([n, r]) => [
                n,
                r.firstVersion
              ])
            ) : void 0
          } : {
            version: e.migrations.firstVersion
          }
        ])
      )
    };
  }
}
const dX = (t, e) => {
  if (t.schemaVersion > e.schemaVersion)
    return 1;
  if (t.schemaVersion < e.schemaVersion)
    return -1;
  if (t.storeVersion > e.storeVersion)
    return 1;
  if (t.storeVersion < e.storeVersion)
    return -1;
  for (const n of Object.keys(t.recordVersions)) {
    const r = t.recordVersions[n], a = e.recordVersions[n];
    if (r.version > a.version)
      return 1;
    if (r.version < a.version)
      return -1;
    if ("subTypeVersions" in r && !("subTypeVersions" in a))
      return 1;
    if (!("subTypeVersions" in r) && "subTypeVersions" in a)
      return -1;
    if (!(!("subTypeVersions" in r) || !("subTypeVersions" in a)))
      for (const s of Object.keys(r.subTypeVersions)) {
        const c = r.subTypeVersions[s], f = a.subTypeVersions[s];
        if (c > f)
          return 1;
        if (c < f)
          return -1;
      }
  }
  return 0;
};
function fX(t) {
  if (!t.length)
    return null;
  let e = "";
  for (const n of t)
    typeof n == "number" ? e += `.${n}` : n.startsWith("(") ? e.endsWith(")") ? e = `${e.slice(0, -1)}, ${n.slice(1)}` : e += n : e += `.${n}`;
  return e.startsWith(".") ? e.slice(1) : e;
}
class ti extends Error {
  constructor(e, n = []) {
    const r = fX(n), a = e.split(`
`).map((s, c) => c === 0 ? s : `  ${s}`).join(`
`);
    super(n ? `At ${r}: ${a}` : a), this.rawMessage = e, this.path = n;
  }
  name = "ValidationError";
}
function sm(t, e) {
  try {
    return e();
  } catch (n) {
    throw n instanceof ti ? new ti(n.rawMessage, [t, ...n.path]) : new ti(n.toString(), [t]);
  }
}
function Zg(t) {
  if (t === null)
    return "null";
  if (Array.isArray(t))
    return "an array";
  const e = typeof t;
  switch (e) {
    case "bigint":
    case "boolean":
    case "function":
    case "number":
    case "string":
    case "symbol":
      return `a ${e}`;
    case "object":
      return `an ${e}`;
    case "undefined":
      return "undefined";
    default:
      YG(e);
  }
}
class ps {
  constructor(e) {
    this.validationFn = e;
  }
  /**
   * Asserts that the passed value is of the correct type and returns it. The
   * returned value is guaranteed to be referentially equal to the passed
   * value.
   */
  validate(e) {
    const n = this.validationFn(e);
    if ({}.NODE_ENV !== "production" && !Object.is(e, n))
      throw new ti("Validator functions must return the same value they were passed");
    return n;
  }
  /**
   * Returns a new validator that also accepts null or undefined. The
   * resulting value will always be null.
   */
  nullable() {
    return new ps((e) => e === null ? null : this.validate(e));
  }
  /**
   * Returns a new validator that also accepts null or undefined. The
   * resulting value will always be null.
   */
  optional() {
    return new ps((e) => {
      if (e !== void 0)
        return this.validate(e);
    });
  }
  /**
   * Refine this validation to a new type. The passed-in validation function
   * should throw an error if the value can't be converted to the new type, or
   * return the new type otherwise.
   */
  refine(e) {
    return new ps((n) => e(this.validate(n)));
  }
  check(e, n) {
    return typeof e == "string" ? this.refine((r) => (sm(`(check ${e})`, () => n(r)), r)) : this.refine((r) => (e(r), r));
  }
}
class pX extends ps {
  constructor(e) {
    super((n) => {
      const r = gX.validate(n);
      for (let a = 0; a < r.length; a++)
        sm(a, () => e.validate(r[a]));
      return r;
    }), this.itemValidator = e;
  }
  nonEmpty() {
    return this.check((e) => {
      if (e.length === 0)
        throw new ti("Expected a non-empty array");
    });
  }
  lengthGreaterThan1() {
    return this.check((e) => {
      if (e.length <= 1)
        throw new ti("Expected an array with length greater than 1");
    });
  }
}
class kx extends ps {
  constructor(e, n = !1) {
    super((r) => {
      if (typeof r != "object" || r === null)
        throw new ti(`Expected object, got ${Zg(r)}`);
      for (const [a, s] of Object.entries(e))
        sm(a, () => {
          s.validate(Ex(r, a));
        });
      if (!n) {
        for (const a of Object.keys(r))
          if (!hI(e, a))
            throw new ti("Unexpected property", [a]);
      }
      return r;
    }), this.config = e, this.shouldAllowUnknownProperties = n;
  }
  allowUnknownProperties() {
    return new kx(this.config, !0);
  }
  /**
   * Extend an object validator by adding additional properties.
   *
   * @example
   * ```ts
   *  const animalValidator = T.object({
   *      name: T.string,
   *  })
   *  const catValidator = animalValidator.extend({
   *      meowVolume: T.number,
   *  })
   * ```
   */
  extend(e) {
    return new kx({ ...this.config, ...e });
  }
}
class bI extends ps {
  constructor(e, n, r) {
    super((a) => {
      if (typeof a != "object" || a === null)
        throw new ti(`Expected an object, got ${Zg(a)}`, []);
      const s = Ex(a, e);
      if (typeof s != "string")
        throw new ti(
          `Expected a string for key "${e}", got ${Zg(s)}`
        );
      const c = hI(n, s) ? n[s] : void 0;
      return c === void 0 ? this.unknownValueValidation(a, s) : sm(`(${e} = ${s})`, () => c.validate(a));
    }), this.key = e, this.config = n, this.unknownValueValidation = r;
  }
  validateUnknownVariants(e) {
    return new bI(this.key, this.config, e);
  }
}
class hX extends ps {
  constructor(e, n) {
    super((r) => {
      if (typeof r != "object" || r === null)
        throw new ti(`Expected object, got ${Zg(r)}`);
      for (const [a, s] of Object.entries(r))
        sm(a, () => {
          e.validate(a), n.validate(s);
        });
      return r;
    }), this.keyValidator = e, this.valueValidator = n;
  }
}
function SI(t) {
  return new ps((e) => {
    if (typeof e !== t)
      throw new ti(`Expected ${t}, got ${Zg(e)}`);
    return e;
  });
}
const Bn = SI("string"), Xn = SI("number").check((t) => {
  if (Number.isNaN(t))
    throw new ti("Expected a number, got NaN");
  if (!Number.isFinite(t))
    throw new ti(`Expected a finite number, got ${t}`);
}), wI = Xn.check((t) => {
  if (t < 0)
    throw new ti(`Expected a positive number, got ${t}`);
}), Ga = Xn.check((t) => {
  if (t <= 0)
    throw new ti(`Expected a non-zero positive number, got ${t}`);
}), yL = Xn.check((t) => {
  if (!Number.isInteger(t))
    throw new ti(`Expected an integer, got ${t}`);
});
yL.check((t) => {
  if (t < 0)
    throw new ti(`Expected a positive integer, got ${t}`);
});
yL.check((t) => {
  if (t <= 0)
    throw new ti(`Expected a non-zero positive integer, got ${t}`);
});
const Jr = SI("boolean");
function pa(t) {
  return new ps((e) => {
    if (e !== t)
      throw new ti(`Expected ${t}, got ${JSON.stringify(e)}`);
    return t;
  });
}
const gX = new ps((t) => {
  if (!Array.isArray(t))
    throw new ti(`Expected an array, got ${Zg(t)}`);
  return t;
});
function Gg(t) {
  return new pX(t);
}
function Mn(t) {
  return new kx(t);
}
function bL(t, e) {
  return new hX(t, e);
}
function xI(t, e) {
  return new bI(t, e, (n, r) => {
    throw new ti(
      `Expected one of ${Object.keys(e).map((a) => JSON.stringify(a)).join(" or ")}, got ${JSON.stringify(r)}`,
      [t]
    );
  });
}
function Mc(t, e) {
  return new ps((n) => {
    const r = n && typeof n == "object" && "id" in n && typeof n.id == "string" ? `${t}(id = ${n.id})` : t;
    return sm(r, () => e.validate(n));
  });
}
function ko(t) {
  return new ps((e) => {
    if (!t.has(e)) {
      const n = Array.from(t, (r) => JSON.stringify(r)).join(" or ");
      throw new ti(`Expected ${n}, got ${e}`);
    }
    return e;
  });
}
const a1 = Mn({
  x: Xn,
  y: Xn,
  z: Xn.optional()
}), IO = Mn({
  x: Xn,
  y: Xn,
  w: Xn,
  h: Xn
}), SL = /* @__PURE__ */ new Set([
  "color",
  "labelColor",
  "dash",
  "fill",
  "size",
  "opacity",
  "font",
  "align",
  "icon",
  "geo",
  "arrowheadStart",
  "arrowheadEnd",
  "spline"
]), mX = /* @__PURE__ */ new Set([
  "black",
  "grey",
  "light-violet",
  "violet",
  "blue",
  "light-blue",
  "yellow",
  "orange",
  "green",
  "light-green",
  "light-red",
  "red"
]), vX = /* @__PURE__ */ new Set(["draw", "solid", "dashed", "dotted"]), yX = /* @__PURE__ */ new Set(["none", "semi", "solid", "pattern"]), bX = /* @__PURE__ */ new Set(["s", "m", "l", "xl"]), SX = /* @__PURE__ */ new Set(["0.1", "0.25", "0.5", "0.75", "1"]), wX = /* @__PURE__ */ new Set(["draw", "sans", "serif", "mono"]), xX = /* @__PURE__ */ new Set(["start", "middle", "end", "justify"]), wL = /* @__PURE__ */ new Set([
  "rectangle",
  "ellipse",
  "triangle",
  "diamond",
  "pentagon",
  "hexagon",
  "octagon",
  "star",
  "rhombus",
  "rhombus-2",
  "oval",
  "trapezoid",
  "arrow-right",
  "arrow-left",
  "arrow-up",
  "arrow-down",
  "x-box"
]), EX = /* @__PURE__ */ new Set([
  "arrow",
  "triangle",
  "square",
  "dot",
  "pipe",
  "diamond",
  "inverted",
  "bar",
  "none"
]), CX = /* @__PURE__ */ new Set(["cubic", "line"]), _X = /* @__PURE__ */ new Set([
  "activity",
  "airplay",
  "alert-circle",
  "alert-octagon",
  "alert-triangle",
  "align-center",
  "align-justify",
  "align-left",
  "align-right",
  "anchor",
  "aperture",
  "archive",
  "arrow-down-circle",
  "arrow-down-left",
  "arrow-down-right",
  "arrow-down",
  "arrow-left-circle",
  "arrow-left",
  "arrow-right-circle",
  "arrow-right",
  "arrow-up-circle",
  "arrow-up-left",
  "arrow-up-right",
  "arrow-up",
  "at-sign",
  "award",
  "bar-chart-2",
  "bar-chart",
  "battery-charging",
  "battery",
  "bell-off",
  "bell",
  "bluetooth",
  "bold",
  "book-open",
  "book",
  "bookmark",
  "geo",
  "briefcase",
  "calendar",
  "camera-off",
  "camera",
  "cast",
  "check-circle",
  "check-square",
  "check",
  "chevron-down",
  "chevron-left",
  "chevron-right",
  "chevron-up",
  "chevrons-down",
  "chevrons-left",
  "chevrons-right",
  "chevrons-up",
  "chrome",
  "circle",
  "clipboard",
  "clock",
  "cloud-drizzle",
  "cloud-lightning",
  "cloud-off",
  "cloud-rain",
  "cloud-snow",
  "cloud",
  "codepen",
  "codesandbox",
  "coffee",
  "columns",
  "command",
  "compass",
  "copy",
  "corner-down-left",
  "corner-down-right",
  "corner-left-down",
  "corner-left-up",
  "corner-right-down",
  "corner-right-up",
  "corner-up-left",
  "corner-up-right",
  "cpu",
  "credit-card",
  "crop",
  "crosshair",
  "database",
  "delete",
  "disc",
  "divide-circle",
  "divide-square",
  "divide",
  "dollar-sign",
  "download-cloud",
  "download",
  "dribbble",
  "droplet",
  "edit-2",
  "edit-3",
  "edit",
  "external-link",
  "eye-off",
  "eye",
  "facebook",
  "fast-forward",
  "feather",
  "figma",
  "file-minus",
  "file-plus",
  "file-text",
  "file",
  "film",
  "filter",
  "flag",
  "folder-minus",
  "folder-plus",
  "folder",
  "framer",
  "frown",
  "gift",
  "git-branch",
  "git-commit",
  "git-merge",
  "git-pull-request",
  "github",
  "gitlab",
  "globe",
  "grid",
  "hard-drive",
  "hash",
  "headphones",
  "heart",
  "help-circle",
  "hexagon",
  "home",
  "image",
  "inbox",
  "info",
  "instagram",
  "italic",
  "key",
  "layers",
  "layout",
  "life-buoy",
  "link-2",
  "link",
  "linkedin",
  "list",
  "loader",
  "lock",
  "log-in",
  "log-out",
  "mail",
  "map-pin",
  "map",
  "maximize-2",
  "maximize",
  "meh",
  "menu",
  "message-circle",
  "message-square",
  "mic-off",
  "mic",
  "minimize-2",
  "minimize",
  "minus-circle",
  "minus-square",
  "minus",
  "monitor",
  "moon",
  "more-horizontal",
  "more-vertical",
  "mouse-pointer",
  "move",
  "music",
  "navigation-2",
  "navigation",
  "octagon",
  "package",
  "paperclip",
  "pause-circle",
  "pause",
  "pen-tool",
  "percent",
  "phone-call",
  "phone-forwarded",
  "phone-incoming",
  "phone-missed",
  "phone-off",
  "phone-outgoing",
  "phone",
  "pie-chart",
  "play-circle",
  "play",
  "plus-circle",
  "plus-square",
  "plus",
  "pocket",
  "power",
  "printer",
  "radio",
  "refresh-ccw",
  "refresh-cw",
  "repeat",
  "rewind",
  "rotate-ccw",
  "rotate-cw",
  "rss",
  "save",
  "scissors",
  "search",
  "send",
  "server",
  "settings",
  "share-2",
  "share",
  "shield-off",
  "shield",
  "shopping-bag",
  "shopping-cart",
  "shuffle",
  "sidebar",
  "skip-back",
  "skip-forward",
  "slack",
  "slash",
  "sliders",
  "smartphone",
  "smile",
  "speaker",
  "square",
  "star",
  "stop-circle",
  "sun",
  "sunrise",
  "sunset",
  "table",
  "tablet",
  "tag",
  "target",
  "terminal",
  "thermometer",
  "thumbs-down",
  "thumbs-up",
  "toggle-left",
  "toggle-right",
  "tool",
  "trash-2",
  "trash",
  "trello",
  "trending-down",
  "trending-up",
  "triangle",
  "truck",
  "tv",
  "twitch",
  "twitter",
  "type",
  "umbrella",
  "underline",
  "unlock",
  "upload-cloud",
  "upload",
  "user-check",
  "user-minus",
  "user-plus",
  "user-x",
  "user",
  "users",
  "video-off",
  "video",
  "voicemail",
  "volume-1",
  "volume-2",
  "volume-x",
  "volume",
  "watch",
  "wifi-off",
  "wifi",
  "wind",
  "x-circle",
  "x-octagon",
  "x-square",
  "x",
  "youtube",
  "zap-off",
  "zap",
  "zoom-in",
  "zoom-out"
]);
function Al(t) {
  return Bn.refine((e) => {
    if (!e.startsWith(`${t}:`))
      throw new Error(`${t} ID must start with "${t}:"`);
    return e;
  });
}
const s1 = Al("user"), l1 = Al("asset"), c1 = Al("page"), Hd = Al("shape"), EI = Al("instance"), TX = Bn.refine((t) => {
  if (!t.startsWith("page:") && !t.startsWith("shape:"))
    throw new Error('Parent ID must start with "page:" or "shape:"');
  return t;
}), Ol = ko(mX), lm = ko(vX), u1 = ko(yX), xL = ko(wL), uf = ko(bX), wb = ko(wX), d1 = ko(xX), Px = ko(EX), qa = ko(SX), EL = ko(_X), CL = ko(CX), kX = Mc(
  "camera",
  Mn({
    typeName: pa("camera"),
    id: Al("camera"),
    x: Xn,
    y: Xn,
    z: Xn
  })
), RO = {
  Initial: 0
}, PX = xr({
  firstVersion: RO.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: RO.Initial,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {}
}), Xy = $c("camera", {
  migrations: PX,
  validator: kX
}).withDefaultProperties(
  () => ({
    x: 0,
    y: 0,
    z: 1
  })
), IX = Mc(
  "document",
  Mn({
    typeName: pa("document"),
    id: pa("document:document"),
    gridSize: Xn
  })
), $O = {
  Initial: 0
}, RX = xr({
  firstVersion: $O.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: $O.Initial,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {}
}), CI = $c("document", {
  migrations: RX,
  validator: IX
}).withDefaultProperties(
  () => ({
    gridSize: 10
  })
), Ix = CI.createCustomId("document"), $X = /* @__PURE__ */ new Set([
  "accent",
  "white",
  "black",
  "selection-stroke",
  "selection-fill",
  "muted-1"
]), _L = ko($X), MX = /* @__PURE__ */ new Set([
  "none",
  "default",
  "pointer",
  "cross",
  "grab",
  "rotate",
  "grabbing",
  "resize-edge",
  "resize-corner",
  "text",
  "move",
  "ew-resize",
  "ns-resize",
  "nesw-resize",
  "nwse-resize",
  "nesw-rotate",
  "nwse-rotate",
  "swne-rotate",
  "senw-rotate"
]), AX = ko(MX), OX = Mn({
  color: _L,
  type: AX,
  rotation: Xn
}), DX = /* @__PURE__ */ new Set(["starting", "paused", "active", "stopping"]), NX = Mn({
  points: Gg(a1),
  size: wI,
  color: _L,
  opacity: Xn,
  state: ko(DX)
}), LX = /* @__PURE__ */ new Set(["vertex", "virtual", "create"]), jX = Mn({
  id: Bn,
  type: ko(LX),
  canBind: Jr.optional(),
  index: Bn,
  x: Xn,
  y: Xn
}), zX = Mc(
  "instance",
  Mn({
    typeName: pa("instance"),
    id: Al("instance"),
    userId: s1,
    currentPageId: c1,
    brush: IO.nullable(),
    propsForNextShape: Mn({
      color: Ol,
      labelColor: Ol,
      dash: lm,
      fill: u1,
      size: uf,
      opacity: qa,
      font: wb,
      align: d1,
      icon: EL,
      geo: xL,
      arrowheadStart: Px,
      arrowheadEnd: Px,
      spline: CL
    }),
    cursor: OX,
    scribble: NX.nullable(),
    isFocusMode: Jr,
    isDebugMode: Jr,
    isToolLocked: Jr,
    exportBackground: Jr,
    screenBounds: IO
  })
), mp = {
  Initial: 0,
  AddTransparentExportBgs: 1,
  RemoveDialog: 2,
  AddToolLockMode: 3,
  RemoveExtraPropsForNextShape: 4,
  AddLabelColor: 5
}, UX = xr({
  firstVersion: mp.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: mp.AddLabelColor,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {
    [mp.AddTransparentExportBgs]: {
      up: (t) => ({ ...t, exportBackground: !0 }),
      down: ({ exportBackground: t, ...e }) => e
    },
    [mp.RemoveDialog]: {
      up: ({ dialog: t, ...e }) => e,
      down: (t) => ({ ...t, dialog: null })
    },
    [mp.AddToolLockMode]: {
      up: (t) => ({ ...t, isToolLocked: !1 }),
      down: ({ isToolLocked: t, ...e }) => e
    },
    [mp.RemoveExtraPropsForNextShape]: {
      up: ({ propsForNextShape: t, ...e }) => ({
        ...e,
        propsForNextShape: Object.fromEntries(
          Object.entries(t).filter(
            ([n]) => SL.has(n)
          )
        )
      }),
      down: (t) => t
    },
    [mp.AddLabelColor]: {
      up: ({ propsForNextShape: t, ...e }) => ({
        ...e,
        propsForNextShape: {
          ...t,
          labelColor: "black"
        }
      }),
      down: (t) => {
        const { labelColor: e, ...n } = t.propsForNextShape;
        return {
          ...t,
          propsForNextShape: {
            ...n
          }
        };
      }
    }
  }
}), Rp = $c("instance", {
  migrations: UX,
  validator: zX
}).withDefaultProperties(
  () => ({
    propsForNextShape: {
      opacity: "1",
      color: "black",
      labelColor: "black",
      dash: "draw",
      fill: "none",
      size: "m",
      icon: "file",
      font: "draw",
      align: "middle",
      geo: "rectangle",
      arrowheadStart: "none",
      arrowheadEnd: "arrow",
      spline: "line"
    },
    brush: null,
    scribble: null,
    cursor: {
      type: "default",
      color: "black",
      rotation: 0
    },
    isFocusMode: !1,
    exportBackground: !1,
    isDebugMode: {}.NODE_ENV === "development",
    isToolLocked: !1,
    screenBounds: { x: 0, y: 0, w: 1080, h: 720 }
  })
), BX = Mc(
  "instance_page_state",
  Mn({
    typeName: pa("instance_page_state"),
    id: Al("instance_page_state"),
    instanceId: EI,
    pageId: c1,
    cameraId: Al("camera"),
    selectedIds: Gg(Hd),
    hintingIds: Gg(Hd),
    erasingIds: Gg(Hd),
    hoveredId: Hd.nullable(),
    editingId: Hd.nullable(),
    focusLayerId: Hd.nullable()
  })
), MO = {
  Initial: 0
}, FX = xr({
  currentVersion: MO.Initial,
  // STEP 2: Update the current version to point to your latest version
  firstVersion: MO.Initial,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {}
}), qy = $c("instance_page_state", {
  migrations: FX,
  validator: BX
}).withDefaultProperties(
  () => ({
    editingId: null,
    selectedIds: [],
    hoveredId: null,
    erasingIds: [],
    hintingIds: [],
    focusLayerId: null
  })
), HX = Mc(
  "page",
  Mn({
    typeName: pa("page"),
    id: c1,
    name: Bn,
    index: Bn
  })
), AO = {
  Initial: 0
}, VX = xr({
  firstVersion: AO.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: AO.Initial,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {}
}), fr = $c("page", {
  migrations: VX,
  validator: HX
}), YX = [
  { locale: "ar", label: "عربي" },
  { locale: "ca", label: "Català" },
  { locale: "da", label: "Danish" },
  { locale: "de", label: "Deutsch" },
  { locale: "en", label: "English" },
  { locale: "es", label: "Español" },
  { locale: "fa", label: "فارسی" },
  { locale: "fi", label: "Suomi" },
  { locale: "fr", label: "Français" },
  { locale: "gl", label: "Galego" },
  { locale: "he", label: "עברית" },
  { locale: "it", label: "Italiano" },
  { locale: "ja", label: "日本語" },
  { locale: "ko-kr", label: "한국어" },
  { locale: "ku", label: "کوردی" },
  { locale: "hi-in", label: "हिन्दी" },
  { locale: "hu", label: "Magyar" },
  { locale: "my", label: "မြန်မာစာ" },
  { locale: "ne", label: "नेपाली" },
  { locale: "no", label: "Norwegian" },
  { locale: "pl", label: "Polski" },
  { locale: "pt-br", label: "Português - Brasil" },
  { locale: "pt-pt", label: "Português - Europeu" },
  { locale: "ro", label: "Română" },
  { locale: "ru", label: "Russian" },
  { locale: "sv", label: "Svenska" },
  { locale: "te", label: "తెలుగు" },
  { locale: "th", label: "ภาษาไทย" },
  { locale: "tr", label: "Türkçe" },
  { locale: "uk", label: "Ukrainian" },
  { locale: "vi", label: "Tiếng Việt" },
  { locale: "zh-cn", label: "Chinese - Simplified" },
  { locale: "zh-tw", label: "繁體中文 (台灣)" }
], KX = Mc(
  "user",
  Mn({
    typeName: pa("user"),
    id: s1,
    name: Bn,
    locale: Bn
  })
), OO = {
  Initial: 0
}, WX = xr({
  // STEP 2: Update the current version to point to your latest version
  currentVersion: OO.Initial,
  firstVersion: OO.Initial,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
  }
}), $p = $c("user", {
  migrations: WX,
  validator: KX
}).withDefaultProperties(() => {
  let t;
  if (typeof window < "u" && window.navigator) {
    const e = YX.map(({ locale: n }) => n);
    t = window.navigator.languages.find((n) => e.indexOf(n) > -1);
  }
  return {
    name: "New User",
    locale: t ?? "en"
  };
}), GX = Mc(
  "user_document",
  Mn({
    typeName: pa("user_document"),
    id: Al("user_document"),
    userId: s1,
    isReadOnly: Jr,
    isPenMode: Jr,
    isGridMode: Jr,
    isDarkMode: Jr,
    isMobileMode: Jr,
    isSnapMode: Jr,
    lastUpdatedPageId: c1.nullable(),
    lastUsedTabId: EI.nullable()
  })
), Iw = {
  Initial: 0,
  AddSnapMode: 1,
  AddMissingIsMobileMode: 2
}, XX = xr({
  firstVersion: Iw.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: Iw.AddMissingIsMobileMode,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {
    [Iw.AddSnapMode]: {
      up: (t) => ({ ...t, isSnapMode: !1 }),
      down: ({ isSnapMode: t, ...e }) => e
    },
    [Iw.AddMissingIsMobileMode]: {
      up: (t) => ({ ...t, isMobileMode: t.isMobileMode ?? !1 }),
      down: ({ isMobileMode: t, ...e }) => e
    }
  }
}), aP = $c("user_document", {
  migrations: XX,
  validator: GX
}).withDefaultProperties(
  () => ({
    /* STEP 6: Add any new default values for properties here */
    isReadOnly: !1,
    isPenMode: !1,
    isGridMode: !1,
    isDarkMode: !1,
    isMobileMode: !1,
    isSnapMode: !1,
    lastUpdatedPageId: null,
    lastUsedTabId: null
  })
), qX = Mc(
  "user_presence",
  Mn({
    typeName: pa("user_presence"),
    id: Al("user_presence"),
    userId: s1,
    lastUsedInstanceId: EI.nullable(),
    lastActivityTimestamp: Xn,
    cursor: a1,
    color: Bn
  })
), DO = {
  Initial: 0
}, QX = xr({
  // STEP 2: Update the current version to point to your latest version
  currentVersion: DO.Initial,
  firstVersion: DO.Initial,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
  }
}), sP = $c("user_presence", {
  migrations: QX,
  validator: qX
}).withDefaultProperties(
  () => ({
    lastUsedInstanceId: null,
    lastActivityTimestamp: 0,
    cursor: { x: 0, y: 0 },
    color: "#000000"
  })
);
function ZX(t, e) {
  return t.index < e.index ? -1 : t.index > e.index ? 1 : 0;
}
const NO = [
  "#FF802B",
  "#EC5E41",
  "#F2555A",
  "#F04F88",
  "#E34BA9",
  "#BD54C6",
  "#9D5BD2",
  "#7B66DC",
  "#02B1CC",
  "#11B3A3",
  "#39B178",
  "#55B467"
];
function LO(t) {
  t.typeName === "asset" && ("src" in t && (t.src = "<redacted>"), "src" in t.props && (t.props.src = "<redacted>"));
}
const JX = ({ error: t, phase: e, record: n, recordBefore: r }) => {
  throw pI(t, {
    tags: {
      origin: "store.validateRecord",
      storePhase: e,
      isExistingValidationIssue: (
        // if we're initializing the store for the first time, we should
        // allow invalid records so people can load old buggy data:
        e === "initialize"
      )
    },
    extras: {
      recordBefore: r ? LO(Lu(r)) : void 0,
      recordAfter: LO(Lu(n))
    }
  }), t;
};
function eq() {
  return NO[Math.floor(Math.random() * NO.length)];
}
function tq() {
  return [fr.create({ name: "Page 1", index: "a1" })];
}
function xc(t) {
  const { userId: e, instanceId: n } = t.props;
  if (!t.has(Ix))
    return t.put([CI.create({ id: Ix })]), xc(t);
  const r = t.allRecords(), a = r.filter(aP.isInstance).find((g) => g.userId === e);
  if (!a)
    return t.put([aP.create({ userId: e })]), xc(t);
  const s = r.filter(fr.isInstance).sort(ZX);
  if (s.length === 0)
    return t.put(tq()), xc(t);
  const c = r.filter(Rp.isInstance).find((g) => g.id === n);
  if (!c) {
    const g = a.lastUsedTabId ? t.get(a.lastUsedTabId)?.propsForNextShape : void 0, y = a?.lastUpdatedPageId ?? s[0].id;
    return t.put([
      Rp.create({
        id: n,
        userId: e,
        currentPageId: y,
        propsForNextShape: g,
        exportBackground: !0
      })
    ]), xc(t);
  }
  let f = c.currentPageId;
  if (!s.find((g) => g.id === f))
    return f = s[0].id, t.put([{ ...c, currentPageId: f }]), xc(t);
  if (!r.find((g) => g.id === e))
    return t.put([$p.create({ id: e })]), xc(t);
  const p = r.filter(sP.isInstance).filter((g) => g.userId === e);
  if (p.length === 0)
    return t.put([sP.create({ userId: e, color: eq() })]), xc(t);
  p.length > 1 && t.remove(p.slice(1).map((g) => g.id));
  for (const g of s) {
    const y = r.filter(qy.isInstance).filter((S) => S.pageId === g.id && S.instanceId === n);
    if (y.length > 1)
      t.remove(y.slice(1).map((S) => S.id));
    else if (y.length === 0) {
      const S = Xy.create({});
      return t.put([
        S,
        qy.create({ pageId: g.id, instanceId: n, cameraId: S.id })
      ]), xc(t);
    }
    if (t.put([
      {
        ...y[0],
        erasingIds: [],
        hoveredId: null,
        editingId: null
      }
    ]), !t.get(y[0].cameraId))
      return t.put([Xy.create({ id: y[0].cameraId })]), xc(t);
  }
}
function _I(t, e) {
  return Mn({
    id: l1,
    typeName: pa("asset"),
    type: pa(t),
    props: e
  });
}
const nq = _I(
  "bookmark",
  Mn({
    title: Bn,
    description: Bn,
    image: Bn,
    src: Bn.nullable()
  })
), jO = {
  Initial: 0
}, rq = xr({
  firstVersion: jO.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: jO.Initial,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {}
}), iq = _I(
  "image",
  Mn({
    w: Xn,
    h: Xn,
    name: Bn,
    isAnimated: Jr,
    mimeType: Bn.nullable(),
    src: Bn.nullable()
  })
), Rw = {
  Initial: 0,
  AddIsAnimated: 1,
  RenameWidthHeight: 2
}, oq = xr({
  firstVersion: Rw.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: Rw.RenameWidthHeight,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {
    [Rw.AddIsAnimated]: {
      up: (t) => ({
        ...t,
        props: {
          ...t.props,
          isAnimated: !1
        }
      }),
      down: (t) => {
        const { isAnimated: e, ...n } = t.props;
        return {
          ...t,
          props: n
        };
      }
    },
    [Rw.RenameWidthHeight]: {
      up: (t) => {
        const { width: e, height: n, ...r } = t.props;
        return { ...t, props: { w: e, h: n, ...r } };
      },
      down: (t) => {
        const { w: e, h: n, ...r } = t.props;
        return { ...t, props: { width: e, height: n, ...r } };
      }
    }
  }
}), aq = _I(
  "video",
  Mn({
    w: Xn,
    h: Xn,
    name: Bn,
    isAnimated: Jr,
    mimeType: Bn.nullable(),
    src: Bn.nullable()
  })
), $w = {
  Initial: 0,
  AddIsAnimated: 1,
  RenameWidthHeight: 2
}, sq = xr({
  firstVersion: $w.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: $w.RenameWidthHeight,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {
    [$w.AddIsAnimated]: {
      up: (t) => ({
        ...t,
        props: {
          ...t.props,
          isAnimated: !1
        }
      }),
      down: (t) => {
        const { isAnimated: e, ...n } = t.props;
        return {
          ...t,
          props: n
        };
      }
    },
    [$w.RenameWidthHeight]: {
      up: (t) => {
        const { width: e, height: n, ...r } = t.props;
        return { ...t, props: { w: e, h: n, ...r } };
      },
      down: (t) => {
        const { w: e, h: n, ...r } = t.props;
        return { ...t, props: { width: e, height: n, ...r } };
      }
    }
  }
});
function lq(t) {
  const e = Object.values(t);
  for (let n = 0; n < e.length; n++) {
    if (!e[n])
      continue;
    const { record: r } = cq(e[n]);
    r ? t[e[n].id] = r : delete t[e[n].id];
  }
  return t;
}
function cq(t) {
  const e = [];
  let n = JSON.parse(JSON.stringify(t));
  switch (n.typeName) {
    case "user_presence": {
      n.cursor || (e.push("no cursor"), n.cursor = { x: 0, y: 0 }), (n.cursor.x === void 0 || n.cursor.x === null) && (e.push("no cursor x"), n.cursor.x = 0), (n.cursor.y === void 0 || n.cursor.y === null) && (e.push("no cursor y"), n.cursor.y = 0);
      break;
    }
    case "asset": {
      switch (n.type) {
        case "image":
        case "video": {
          n.props || (e.push("no props in asset"), n.props = {
            w: 100,
            h: 100,
            name: "old_asset",
            isAnimated: !1,
            mimeType: null,
            src: null
          }), n.props.mimeType || (e.push("no mimeType in asset props"), n.props.mimeType = "image/png"), n.props.src || (e.push("no src in asset props"), n.props.src = ""), n.props.isAnimated == null && (e.push("no isAnimated in asset props"), n.props.isAnimated = !1), n.props.name === void 0 && (n.props.name = "asset"), "width" in n && (e.push("width in asset"), n.props.w = n.width, delete n.width), "width" in n.props && typeof n.props.width == "number" && n.props.width && (e.push("no w in asset props"), n.props.w = n.props.width, delete n.props.width), "height" in n && (e.push("height in asset"), n.props.h = n.height, delete n.height), "height" in n.props && typeof n.props.height == "number" && n.props.height && (e.push("no h in asset props"), n.props.h = n.props.height, delete n.props.height), n.props.w || (e.push("no w in asset props"), n.props.w = 100), n.props.h || (e.push("no h in asset props"), n.props.h = 100), "src" in n && (e.push("src in asset"), n.props.src = n.src, delete n.src), "name" in n && (e.push("name in asset"), delete n.name);
          break;
        }
        case "bookmark":
          n.props || (e.push("no asset props"), n.props = {
            title: "",
            description: "",
            image: "",
            src: "url" in n && typeof n.url == "string" ? n.url : ""
          }), n.props.title || (e.push("no title in bookmark asset props"), n.props.title = ""), n.props.description || (e.push("no description in bookmark asset props"), n.props.description = ""), n.props.image || (e.push("no image in bookmark asset props"), n.props.image = ""), "src" in n && (e.push("leftover src in bookmark asset"), delete n.src), "width" in n && (e.push("leftover width in bookmark asset"), delete n.width), "height" in n && (e.push("leftover height in bookmark asset"), delete n.height), "name" in n && (e.push("leftover name in bookmark asset"), delete n.name), "meta" in n && delete n.meta;
          break;
      }
      break;
    }
    case "camera": {
      (n.x === void 0 || n.x === null) && (e.push("no x in camera"), n.x = 0), (n.y === void 0 || n.y === null) && (e.push("no y in camera"), n.y = 0);
      break;
    }
    case "instance": {
      "props" in n && (e.push("leftover props in instance"), delete n.props), n.isToolLocked === void 0 && (e.push("no isToolLocked in instance"), n.isToolLocked = !1), n.propsForNextShape === void 0 && (e.push("no props in instance"), n.propsForNextShape = {
        opacity: "1",
        color: "black",
        dash: "draw",
        fill: "none",
        size: "m",
        icon: "file",
        font: "draw",
        align: "middle",
        geo: "rectangle",
        arrowheadStart: "none",
        arrowheadEnd: "arrow",
        spline: "line"
      }), "url" in n.propsForNextShape && (e.push("leftover url in instance.propsForNextShape"), delete n.propsForNextShape.url), "lang" in n.propsForNextShape && (e.push("leftover lang in instance.propsForNextShape"), delete n.propsForNextShape.lang), n.exportBackground === void 0 && (e.push(`no export background in ${n.typeName}`), n.exportBackground = !1), n.brush === void 0 && (e.push(`no brush in ${n.typeName}`), n.brush = null), n.scribble === void 0 && (e.push(`no scribble in ${n.typeName}`), n.scribble = null), n.dialog !== void 0 && (e.push(`no dialog in ${n.typeName}`), delete n.dialog), n.screenBounds === void 0 && (e.push(`no screen bounds in ${n.typeName}`), n.screenBounds = { x: 0, y: 0, w: 1080, h: 720 });
      break;
    }
    case "user": {
      n.name || (e.push("no name in user"), n.name = "User"), n.locale || (e.push("no locale in user"), n.locale = "en"), "cursor" in n && (e.push("leftover cursor in user"), delete n.cursor), "color" in n && (e.push("leftover color in user"), delete n.color), "brush" in n && (e.push("leftover brush in user"), delete n.brush), "selectedIds" in n && (e.push("leftover selectedIds in user"), delete n.selectedIds), "scribble" in n && (e.push("leftover scribble in user"), delete n.scribble), "currentPageId" in n && (e.push("leftover currentPageId in user"), delete n.currentPageId);
      break;
    }
    case "user_document": {
      n.isMobileMode === void 0 && (e.push("no ismobilemode in user document"), n.isMobileMode = !1), n.isSnapMode === void 0 && (e.push("no issnapmode in user document"), n.isSnapMode = !1);
      break;
    }
    case "shape": {
      if ("url" in n && delete n.url, (n.x === void 0 || n.x === null) && (e.push(`some bug in ${n.typeName} ${n.type}`), n.x = 0), (n.y === void 0 || n.y === null) && (e.push(`some bug in ${n.typeName} ${n.type}`), n.y = 0), n.type === "image" && (n.props.playing === void 0 && (e.push(`some bug in ${n.typeName} ${n.type}`), n.props.playing = !1), "loaded" in n.props && delete n.props.loaded), n.type === "arrow" && (n.props.start.type === "binding" ? ((n.props.start.normalizedAnchor.x === void 0 || n.props.start.normalizedAnchor.x === null) && (e.push(`some bug in ${n.typeName} ${n.type}`), n.props.start.normalizedAnchor.x = 0), (n.props.start.normalizedAnchor.y === void 0 || n.props.start.normalizedAnchor.y === null) && (e.push(`some bug in ${n.typeName} ${n.type}`), n.props.start.normalizedAnchor.y = 0)) : ((n.props.start.x === void 0 || n.props.start.x === null) && (e.push(`some bug in ${n.typeName} ${n.type}`), n.props.start.x = 0), (n.props.start.y === void 0 || n.props.start.y === null) && (e.push(`some bug in ${n.typeName} ${n.type}`), n.props.start.y = 0), "boundShapeId" in n.props.start && (e.push("leftover bound shape id in arrow"), delete n.props.start.boundShapeId), "normalizedAnchor" in n.props.start && (e.push("leftover normalize anchor in arrow"), delete n.props.start.normalizedAnchor), "isExact" in n.props.start && (e.push("leftover isExact in arrow"), delete n.props.start.isExact)), n.props.end.type === "binding" ? ((n.props.end.normalizedAnchor.x === void 0 || n.props.end.normalizedAnchor.x === null) && (e.push(`some bug in ${n.typeName}  ${n.type}`), n.props.end.normalizedAnchor.x = 0), (n.props.end.normalizedAnchor.y === void 0 || n.props.end.normalizedAnchor.y === null) && (e.push(`some bug in ${n.typeName} ${n.type}`), n.props.end.normalizedAnchor.y = 0)) : ((n.props.end.x === void 0 || n.props.end.x === null) && (e.push("no x in arrow end"), n.props.end.x = 0), (n.props.end.y === void 0 || n.props.end.y === null) && (e.push("no y in arrow end"), n.props.end.y = 0), "boundShapeId" in n.props.end && (e.push("leftover bound shape id in arrow"), delete n.props.end.boundShapeId), "normalizedAnchor" in n.props.end && (e.push("leftover normalize anchor in arrow"), delete n.props.end.normalizedAnchor), "isExact" in n.props.end && (e.push("leftover isExact in arrow"), delete n.props.end.isExact))), (n.type === "note" || n.type === "video" || n.type === "image" || n.type === "geo" || n.type === "bookmark") && n.props.url === void 0 && (e.push(`missing url prop in ${n.type} shape`), n.props.url = ""), n.type === "bookmark" && (n.props.assetId === void 0 && (e.push(`some bug in ${n.typeName}  ${n.type}`), n.props.assetId = null), "src" in n && (e.push("leftover src in bookmark"), delete n.src)), n.type === "geo" && ("width" in n.props && (e.push("leftover width in geo"), delete n.props.width), "height" in n.props && (e.push("leftover height in geo"), delete n.props.height)), n.type === "draw") {
        n.props.segments === void 0 && (e.push(`some bug in ${n.typeName}  ${n.type}`), n.props.segments = [
          {
            points: [
              { x: 0, y: 0, z: 0.5 },
              { x: 1, y: 1, z: 0.5 }
            ],
            type: "free"
          }
        ]);
        for (const r of n.props.segments)
          for (const a of r.points)
            (a.x === void 0 || a.y === null) && (e.push(`some bug in ${n.typeName}`), a.x = 0), (a.y === void 0 || a.y === null) && (e.push(`some bug in ${n.typeName}`), a.y = 0);
        "points" in n.props && delete n.props.points;
      }
      n.type === "bookmark" && "loaded" in n.props && (e.push("leftover loaded in bookmark"), delete n.props.loaded), n.type === "draw" && "points" in n.props && n.props.segments === void 0 && (n.props.segments = [{ type: "free", points: n.props.points }]), n.type === "image" && (n.props.w < 1 && (n.props.w = 1, e.push(`zero w image in ${n.typeName}`)), n.props.h < 1 && (n.props.h = 1, e.push(`zero h image in ${n.typeName}`))), n.type === "embed" && "loaded" in n.props && (e.push("leftover loaded in embed"), delete n.props.loaded);
      break;
    }
    case void 0:
      n = null;
  }
  return { record: n, issues: e };
}
const uq = Mc(
  "asset",
  xI("type", {
    image: iq,
    video: aq,
    bookmark: nq
  })
), zO = {
  Initial: 0
}, dq = xr({
  firstVersion: zO.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: zO.Initial,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {},
  subTypeKey: "type",
  subTypeMigrations: {
    image: oq,
    video: sq,
    bookmark: rq
  }
}), cm = $c("asset", {
  migrations: dq,
  validator: uq
}), UT = {
  Initial: 0,
  AddIsLocked: 1
}, BT = xr({
  // STEP 2: Update the current version to point to your latest version
  currentVersion: UT.AddIsLocked,
  firstVersion: UT.Initial,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
    [UT.AddIsLocked]: {
      up: (t) => ({
        ...t,
        isLocked: !1
      }),
      down: (t) => {
        const { isLocked: e, ...n } = t;
        return {
          ...n
        };
      }
    }
  }
});
function Tp(t) {
  return t ? t.typeName === "shape" : !1;
}
function Fs(t) {
  return t ? t.startsWith("shape:") : !1;
}
function io() {
  return `shape:${gI()}`;
}
function fq(t) {
  return `shape:${t}`;
}
const FT = {
  Initial: 0,
  RemoveCodeAndIconShapeTypes: 1
}, pq = xr({
  // STEP 2: Update the current version to point to your latest version
  firstVersion: FT.Initial,
  currentVersion: FT.RemoveCodeAndIconShapeTypes,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
    [FT.RemoveCodeAndIconShapeTypes]: {
      up: (t) => Object.fromEntries(
        Object.entries(t).filter(
          ([e, n]) => n.typeName !== "shape" || n.type !== "icon" && n.type !== "code"
        )
      ),
      down: (t) => t
    }
  }
});
function ms(t, e) {
  return Mn({
    id: Hd,
    typeName: pa("shape"),
    x: Xn,
    y: Xn,
    rotation: Xn,
    index: Bn,
    parentId: TX,
    type: pa(t),
    isLocked: Jr,
    props: e
  });
}
const UO = xI("type", {
  binding: Mn({
    type: pa("binding"),
    boundShapeId: Hd,
    normalizedAnchor: a1,
    isExact: Jr
  }),
  point: Mn({
    type: pa("point"),
    x: Xn,
    y: Xn
  })
}), hq = ms(
  "arrow",
  Mn({
    labelColor: Ol,
    color: Ol,
    fill: u1,
    dash: lm,
    size: uf,
    opacity: qa,
    arrowheadStart: Px,
    arrowheadEnd: Px,
    font: wb,
    start: UO,
    end: UO,
    bend: Xn,
    text: Bn
  })
), HT = {
  Initial: 0,
  AddLabelColor: 1
}, gq = xr({
  // STEP 2: Update the current version to point to your latest version
  currentVersion: HT.AddLabelColor,
  firstVersion: HT.Initial,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
    [HT.AddLabelColor]: {
      up: (t) => ({
        ...t,
        props: {
          ...t.props,
          labelColor: "black"
        }
      }),
      down: (t) => {
        const { labelColor: e, ...n } = t.props;
        return {
          ...t,
          props: n
        };
      }
    }
  }
}), mq = ms(
  "bookmark",
  Mn({
    opacity: qa,
    w: Ga,
    h: Ga,
    assetId: l1.nullable(),
    url: Bn
  })
), VT = {
  Initial: 0,
  NullAssetId: 1
}, vq = xr({
  firstVersion: VT.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: VT.NullAssetId,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {
    [VT.NullAssetId]: {
      up: (t) => t.props.assetId === void 0 ? { ...t, props: { ...t.props, assetId: null } } : t,
      down: (t) => {
        if (t.props.assetId === null) {
          const { assetId: e, ...n } = t.props;
          return { ...t, props: n };
        }
        return t;
      }
    }
  }
}), yq = /* @__PURE__ */ new Set(["free", "straight"]), bq = ms(
  "draw",
  Mn({
    color: Ol,
    fill: u1,
    dash: lm,
    size: uf,
    opacity: qa,
    segments: Gg(
      Mn({
        type: ko(yq),
        points: Gg(a1)
      })
    ),
    isComplete: Jr,
    isClosed: Jr,
    isPen: Jr
  })
), YT = {
  Initial: 0,
  AddInPen: 1
}, Sq = xr({
  // STEP 2: Update the current version to point to your latest version
  firstVersion: YT.Initial,
  currentVersion: YT.AddInPen,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
    [YT.AddInPen]: {
      up: (t) => {
        const { points: e } = t.props.segments[0];
        if (e.length === 0)
          return {
            ...t,
            props: {
              ...t.props,
              isPen: !1
            }
          };
        let n = !(e[0].z === 0 || e[0].z === 0.5);
        return e[1] && (n = n && !(e[1].z === 0 || e[1].z === 0.5)), {
          ...t,
          props: {
            ...t.props,
            isPen: n
          }
        };
      },
      down: (t) => {
        const { isPen: e, ...n } = t.props;
        return {
          ...t,
          props: {
            ...n
          }
        };
      }
    }
  }
}), TL = {
  // ========================================================================================
  // Disabled permissions
  // ========================================================================================
  // [MDN] Experimental: Allows for downloads to occur without a gesture from the user.
  // [REASON] Disabled because otherwise the <iframe/> trick the user on behalf of us to performing an action
  "allow-downloads-without-user-activation": !1,
  // [MDN] Allows for downloads to occur with a gesture from the user.
  // [REASON] Disabled because otherwise the <iframe/> trick the user on behalf of us to performing an action
  "allow-downloads": !1,
  // [MDN] Lets the resource open modal windows.
  // [REASON] The <iframe/> could 'window.prompt("Enter your tldraw password")'
  "allow-modals": !1,
  // [MDN] Lets the resource lock the screen orientation.
  // [REASON] Would interfer with tldraw interface
  "allow-orientation-lock": !1,
  // [MDN] Lets the resource use the Pointer Lock API.
  // [REASON] Maybe we should allow this for games embeds (scratch/codepen/codesandbox)
  "allow-pointer-lock": !1,
  // [MDN] Allows popups (such as window.open(), target="_blank", or showModalDialog()). If this keyword is not used, the popup will silently fail to open.
  // [REASON] We shouldn't allow popups as a embed could pretend to be us by opening a mocked version of tldraw. This is very unobvious when it is performed as an action within out app
  "allow-popups": !0,
  // [MDN] Lets the sandboxed document open new windows without those windows inheriting the sandboxing. For example, this can safely sandbox an advertisement without forcing the same restrictions upon the page the ad links to.
  // [REASON] We're alread disabling popups.
  "allow-popups-to-escape-sandbox": !1,
  // [MDN] Lets the resource start a presentation session.
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us
  "allow-presentation": !1,
  // [MDN] Experimental: Lets the resource request access to the parent's storage capabilities with the Storage Access API.
  // [REASON] We don't want anyone else to access our storage
  "allow-storage-access-by-user-activation": !1,
  // [MDN] Lets the resource navigate the top-level browsing context (the one named _top).
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us
  "allow-top-navigation": !1,
  // [MDN] Lets the resource navigate the top-level browsing context, but only if initiated by a user gesture.
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us
  "allow-top-navigation-by-user-activation": !1,
  // ========================================================================================
  // Enabled permissions
  // ========================================================================================
  // [MDN] Lets the resource run scripts (but not create popup windows).
  "allow-scripts": !0,
  // [MDN] If this token is not used, the resource is treated as being from a special origin that always fails the same-origin policy (potentially preventing access to data storage/cookies and some JavaScript APIs).
  "allow-same-origin": !0,
  // [MDN] Allows the resource to submit forms. If this keyword is not used, form submission is blocked.
  "allow-forms": !0
}, wq = ms(
  "embed",
  Mn({
    opacity: qa,
    w: Ga,
    h: Ga,
    url: Bn,
    tmpOldUrl: Bn.optional(),
    doesResize: Jr,
    overridePermissions: bL(
      ko(
        new Set(Object.keys(TL))
      ),
      Jr.optional()
    ).optional()
  })
), BO = /(^\/r\/[^/]+\/?$)/, Ir = (t) => {
  try {
    return new URL(t);
  } catch {
    return;
  }
}, Jg = [
  {
    type: "tldraw",
    title: "tldraw",
    hostnames: ["beta.tldraw.com", "lite.tldraw.com"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(BO))
        return t;
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(BO))
        return t;
    }
  },
  {
    type: "codesandbox",
    title: "CodeSandbox",
    hostnames: ["codesandbox.io"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t), n = e && e.pathname.match(/\/s\/([^/]+)\/?/);
      if (n)
        return `https://codesandbox.io/embed/${n[1]}`;
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t), n = e && e.pathname.match(/\/embed\/([^/]+)\/?/);
      if (n)
        return `https://codesandbox.io/s/${n[1]}`;
    }
  },
  {
    type: "codepen",
    title: "Codepen",
    hostnames: ["codepen.io"],
    minWidth: 300,
    minHeight: 300,
    width: 520,
    height: 400,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = /https:\/\/codepen.io\/([^/]+)\/pen\/([^/]+)/, n = t.match(e);
      if (n) {
        const [r, a, s] = n;
        return `https://codepen.io/${a}/embed/${s}`;
      }
    },
    fromEmbedUrl: (t) => {
      const e = /https:\/\/codepen.io\/([^/]+)\/embed\/([^/]+)/, n = t.match(e);
      if (n) {
        const [r, a, s] = n;
        return `https://codepen.io/${a}/pen/${s}`;
      }
    }
  },
  {
    type: "scratch",
    title: "Scratch",
    hostnames: ["scratch.mit.edu"],
    width: 520,
    height: 400,
    doesResize: !1,
    toEmbedUrl: (t) => {
      const e = /https?:\/\/scratch.mit.edu\/projects\/([^/]+)/, n = t.match(e);
      if (n) {
        const [r, a] = n;
        return `https://scratch.mit.edu/projects/embed/${a}`;
      }
    },
    fromEmbedUrl: (t) => {
      const e = /https:\/\/scratch.mit.edu\/projects\/embed\/([^/]+)/, n = t.match(e);
      if (n) {
        const [r, a] = n;
        return `https://scratch.mit.edu/projects/${a}`;
      }
    }
  },
  {
    type: "youtube",
    title: "YouTube",
    hostnames: ["*.youtube.com", "youtube.com", "youtu.be"],
    width: 800,
    height: 450,
    doesResize: !0,
    overridePermissions: {
      "allow-presentation": !0
    },
    isAspectRatioLocked: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (!e)
        return;
      const n = e.hostname.replace(/^www./, "");
      if (n === "youtu.be")
        return `https://www.youtube.com/embed/${e.pathname.split("/").filter(Boolean)[0]}`;
      if ((n === "youtube.com" || n === "m.youtube.com") && e.pathname.match(/^\/watch/))
        return `https://www.youtube.com/embed/${e.searchParams.get("v")}`;
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (!e)
        return;
      if (e.hostname.replace(/^www./, "") === "youtube.com") {
        const r = e.pathname.match(/^\/embed\/([^/]+)\/?/);
        if (r)
          return `https://www.youtube.com/watch?v=${r[1]}`;
      }
    }
  },
  {
    type: "figma",
    title: "Figma",
    hostnames: ["figma.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      if (t.match(
        // eslint-disable-next-line no-useless-escape
        /https:\/\/([\w\.-]+\.)?figma.com\/(file|proto)\/([0-9a-zA-Z]{22,128})(?:\/.*)?$/
      ) && !t.includes("figma.com/embed"))
        return `https://www.figma.com/embed?embed_host=share&url=${t}`;
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/^\/embed\/?$/)) {
        const n = e.searchParams.get("url");
        if (n)
          return n;
      }
    }
  },
  {
    type: "google_maps",
    title: "Google Maps",
    hostnames: ["google.*"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      if (t.includes("/maps/")) {
        const e = t.match(/@(.*),(.*),(.*)z/);
        let n;
        if (e) {
          const [, r, a, s] = e;
          n = `https://${new URL(t).host.replace("www.", "")}/maps/embed/v1/view?key=${{}.NEXT_PUBLIC_GC_API_KEY}&center=${r},${a}&zoom=${s}`;
        } else
          n = "";
        return n;
      }
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (!e)
        return;
      if (e.pathname.match(/^\/maps\/embed\/v1\/view\/?$/) && e.searchParams.has("center") && e.searchParams.get("zoom")) {
        const r = e.searchParams.get("zoom"), [a, s] = e.searchParams.get("center").split(",");
        return `https://www.google.com/maps/@${a},${s},${r}z`;
      }
    }
  },
  {
    type: "google_calendar",
    title: "Google Calendar",
    hostnames: ["calendar.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: !0,
    instructionLink: "https://support.google.com/calendar/answer/41207?hl=en",
    toEmbedUrl: (t) => {
      const e = Ir(t), n = e?.searchParams.get("cid");
      if (e?.pathname.match(/\/calendar\/u\/0/) && n) {
        e.pathname = "/calendar/embed";
        const r = Array.from(e.searchParams.keys());
        for (const a of r)
          e.searchParams.delete(a);
        return e.searchParams.set("src", n), e.href;
      }
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t), n = e?.searchParams.get("src");
      if (e?.pathname.match(/\/calendar\/embed/) && n) {
        e.pathname = "/calendar/u/0";
        const r = Array.from(e.searchParams.keys());
        for (const a of r)
          e.searchParams.delete(a);
        return e.searchParams.set("cid", n), e.href;
      }
    }
  },
  {
    type: "google_slides",
    title: "Google Slides",
    hostnames: ["docs.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (e?.pathname.match(/^\/presentation/) && e?.pathname.match(/\/pub\/?$/)) {
        e.pathname = e.pathname.replace(/\/pub$/, "/embed");
        const n = Array.from(e.searchParams.keys());
        for (const r of n)
          e.searchParams.delete(r);
        return e.href;
      }
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e?.pathname.match(/^\/presentation/) && e?.pathname.match(/\/embed\/?$/)) {
        e.pathname = e.pathname.replace(/\/embed$/, "/pub");
        const n = Array.from(e.searchParams.keys());
        for (const r of n)
          e.searchParams.delete(r);
        return e.href;
      }
    }
  },
  {
    type: "github_gist",
    title: "GitHub Gist",
    hostnames: ["gist.github.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/\/([^/]+)\/([^/]+)/))
        return t;
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/\/([^/]+)\/([^/]+)/))
        return t;
    }
  },
  {
    type: "replit",
    title: "Replit",
    hostnames: ["replit.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/\/@([^/]+)\/([^/]+)/))
        return `${t}?embed=true`;
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/\/@([^/]+)\/([^/]+)/) && e.searchParams.has("embed"))
        return e.searchParams.delete("embed"), e.href;
    }
  },
  {
    type: "felt",
    title: "Felt",
    hostnames: ["felt.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/^\/map\//))
        return e.origin + "/embed" + e.pathname;
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/^\/embed\/map\//))
        return e.pathname = e.pathname.replace(/^\/embed/, ""), e.href;
    }
  },
  {
    type: "spotify",
    title: "Spotify",
    hostnames: ["open.spotify.com"],
    width: 720,
    height: 500,
    minHeight: 500,
    overrideOutlineRadius: 12,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/^\/(artist|album)\//))
        return e.origin + "/embed" + e.pathname;
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/^\/embed\/(artist|album)\//))
        return e.origin + e.pathname.replace(/^\/embed/, "");
    }
  },
  {
    type: "vimeo",
    title: "Vimeo",
    hostnames: ["vimeo.com", "player.vimeo.com"],
    width: 640,
    height: 360,
    doesResize: !0,
    isAspectRatioLocked: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.hostname === "vimeo.com" && e.pathname.match(/^\/[0-9]+/))
        return "https://player.vimeo.com/video/" + e.pathname.split("/")[1] + "?title=0&byline=0";
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.hostname === "player.vimeo.com") {
        const n = e.pathname.match(/^\/video\/([^/]+)\/?$/);
        if (n)
          return "https://vimeo.com/" + n[1];
      }
    }
  },
  {
    type: "excalidraw",
    title: "Excalidraw",
    hostnames: ["excalidraw.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    isAspectRatioLocked: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.hash.match(/#room=/))
        return t;
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.hash.match(/#room=/))
        return t;
    }
  },
  {
    type: "observable",
    title: "Observable",
    hostnames: ["observablehq.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    isAspectRatioLocked: !1,
    backgroundColor: "#fff",
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/^\/@([^/]+)\/([^/]+)\/?$/))
        return `${e.origin}/embed${e.pathname}?cell=*`;
      if (e && e.pathname.match(/^\/d\/([^/]+)\/?$/)) {
        const n = e.pathname.replace(/^\/d/, "");
        return `${e.origin}/embed${n}?cell=*`;
      }
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/^\/embed\/@([^/]+)\/([^/]+)\/?$/))
        return `${e.origin}${e.pathname.replace("/embed", "")}#cell-*`;
      if (e && e.pathname.match(/^\/embed\/([^/]+)\/?$/))
        return `${e.origin}${e.pathname.replace("/embed", "/d")}#cell-*`;
    }
  }
], KT = {
  Initial: 0,
  GenOriginalUrlInEmbed: 1
}, xq = xr({
  // STEP 2: Update the current version to point to your latest version
  currentVersion: KT.GenOriginalUrlInEmbed,
  firstVersion: KT.Initial,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
    [KT.GenOriginalUrlInEmbed]: {
      // add tmpOldUrl property
      up: (t) => {
        const e = t.props.url, n = new URL(e).host.replace("www.", "");
        let r;
        for (const a of Jg)
          if (a.hostnames.includes(n))
            try {
              r = a.fromEmbedUrl(e);
            } catch (s) {
              console.warn(s);
            }
        return {
          ...t,
          props: {
            ...t.props,
            tmpOldUrl: t.props.url,
            url: r ?? ""
          }
        };
      },
      // remove tmpOldUrl property
      down: (t) => {
        let e = t.props.tmpOldUrl;
        if (!e || e === "") {
          const a = t.props.url, s = new URL(a).host.replace("www.", "");
          for (const c of Jg)
            if (c.hostnames.includes(s))
              try {
                e = c.toEmbedUrl(a);
              } catch (f) {
                console.warn(f);
              }
        }
        const { tmpOldUrl: n, ...r } = t.props;
        return {
          ...t,
          props: {
            ...r,
            url: e ?? ""
          }
        };
      }
    }
  }
}), Eq = ms(
  "frame",
  Mn({
    opacity: qa,
    w: Ga,
    h: Ga,
    name: Bn
  })
), FO = {
  Initial: 0
}, Cq = xr({
  // STEP 2: Update the current version to point to your latest version
  currentVersion: FO.Initial,
  firstVersion: FO.Initial,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
  }
}), _q = ms(
  "geo",
  Mn({
    geo: xL,
    labelColor: Ol,
    color: Ol,
    fill: u1,
    dash: lm,
    size: uf,
    opacity: qa,
    font: wb,
    align: d1,
    url: Bn,
    w: Ga,
    h: Ga,
    growY: wI,
    text: Bn
  })
), Mw = {
  Initial: 0,
  AddUrlProp: 1,
  AddLabelColor: 2
}, Tq = xr({
  // STEP 2: Update the current version to point to your latest version
  firstVersion: Mw.Initial,
  currentVersion: Mw.AddLabelColor,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
    [Mw.AddUrlProp]: {
      up: (t) => ({ ...t, props: { ...t.props, url: "" } }),
      down: (t) => {
        const { url: e, ...n } = t.props;
        return { ...t, props: n };
      }
    },
    [Mw.AddLabelColor]: {
      up: (t) => ({
        ...t,
        props: {
          ...t.props,
          labelColor: "black"
        }
      }),
      down: (t) => {
        const { labelColor: e, ...n } = t.props;
        return {
          ...t,
          props: n
        };
      }
    }
  }
}), kq = ms(
  "group",
  Mn({
    opacity: qa
  })
), HO = {
  Initial: 0
}, Pq = xr({
  // STEP 2: Update the current version to point to your latest version
  currentVersion: HO.Initial,
  firstVersion: HO.Initial,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
  }
});
ms(
  "icon",
  Mn({
    size: uf,
    icon: EL,
    dash: lm,
    color: Ol,
    opacity: qa,
    scale: Xn
  })
);
const Iq = ms(
  "image",
  Mn({
    opacity: qa,
    w: Ga,
    h: Ga,
    playing: Jr,
    url: Bn,
    assetId: l1.nullable()
  })
), WT = {
  Initial: 0,
  AddUrlProp: 1
}, Rq = xr({
  // STEP 2: Update the current version to point to your latest version
  firstVersion: WT.Initial,
  currentVersion: WT.AddUrlProp,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
    [WT.AddUrlProp]: {
      up: (t) => ({ ...t, props: { ...t.props, url: "" } }),
      down: (t) => {
        const { url: e, ...n } = t.props;
        return { ...t, props: n };
      }
    }
  }
}), $q = ms(
  "line",
  Mn({
    color: Ol,
    dash: lm,
    size: uf,
    opacity: qa,
    spline: CL,
    handles: bL(Bn, jX)
  })
), VO = {
  Initial: 0
}, Mq = xr({
  // STEP 2: Update the current version to point to your latest version
  currentVersion: VO.Initial,
  firstVersion: VO.Initial,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
  }
}), Aq = ms(
  "note",
  Mn({
    color: Ol,
    size: uf,
    font: wb,
    align: d1,
    opacity: qa,
    growY: wI,
    url: Bn,
    text: Bn
  })
), GT = {
  Initial: 0,
  AddUrlProp: 1
}, Oq = xr({
  // STEP 2: Update the current version to point to your latest version
  firstVersion: GT.Initial,
  currentVersion: GT.AddUrlProp,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
    [GT.AddUrlProp]: {
      up: (t) => ({ ...t, props: { ...t.props, url: "" } }),
      down: (t) => {
        const { url: e, ...n } = t.props;
        return { ...t, props: n };
      }
    }
  }
}), Dq = ms(
  "text",
  Mn({
    color: Ol,
    size: uf,
    font: wb,
    align: d1,
    opacity: qa,
    w: Ga,
    text: Bn,
    scale: Ga,
    autoSize: Jr
  })
), YO = {
  Initial: 0
}, Nq = xr({
  // STEP 2: Update the current version to point to your latest version
  firstVersion: YO.Initial,
  currentVersion: YO.Initial,
  migrators: {}
}), Lq = ms(
  "video",
  Mn({
    opacity: qa,
    w: Ga,
    h: Ga,
    time: Xn,
    playing: Jr,
    url: Bn,
    assetId: l1.nullable()
  })
), XT = {
  Initial: 0,
  AddUrlProp: 1
}, jq = xr({
  // STEP 2: Update the current version to point to your latest version
  firstVersion: XT.Initial,
  currentVersion: XT.AddUrlProp,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
    [XT.AddUrlProp]: {
      up: (t) => ({ ...t, props: { ...t.props, url: "" } }),
      down: (t) => {
        const { url: e, ...n } = t.props;
        return { ...t, props: n };
      }
    }
  }
}), fa = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => t * (2 - t),
  easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => --t * t * t + 1,
  easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => 1 - --t * t * t * t,
  easeInOutQuart: (t) => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t,
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => 1 + --t * t * t * t * t,
  easeInOutQuint: (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t,
  easeInSine: (t) => 1 - Math.cos(t * Math.PI / 2),
  easeOutSine: (t) => Math.sin(t * Math.PI / 2),
  easeInOutSine: (t) => -(Math.cos(Math.PI * t) - 1) / 2,
  easeInExpo: (t) => t <= 0 ? 0 : Math.pow(2, 10 * t - 10),
  easeOutExpo: (t) => t >= 1 ? 1 : 1 - Math.pow(2, -10 * t),
  easeInOutExpo: (t) => t <= 0 ? 0 : t >= 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2
};
class O {
  constructor(e = 0, n = 0, r = 1) {
    this.x = e, this.y = n, this.z = r;
  }
  get pressure() {
    return this.z;
  }
  set(e = this.x, n = this.y, r = this.z) {
    return this.x = e, this.y = n, this.z = r, this;
  }
  setTo({ x: e = 0, y: n = 0, z: r = 1 }) {
    return this.x = e, this.y = n, this.z = r, this;
  }
  rot(e) {
    if (e === 0)
      return this;
    const { x: n, y: r } = this, a = Math.sin(e), s = Math.cos(e);
    return this.x = n * s - r * a, this.y = n * a + r * s, this;
  }
  rotWith(e, n) {
    if (n === 0)
      return this;
    const r = this.x - e.x, a = this.y - e.y, s = Math.sin(n), c = Math.cos(n);
    return this.x = e.x + (r * c - a * s), this.y = e.y + (r * s + a * c), this;
  }
  clone() {
    const { x: e, y: n, z: r } = this;
    return new O(e, n, r);
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subXY(e, n) {
    return this.x -= e, this.y -= n, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addXY(e, n) {
    return this.x += e, this.y += n, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  clamp(e, n) {
    return this.x = Math.min(Math.max(this.x, e), n ?? this.x), this.y = Math.min(Math.max(this.y, e), n ?? this.y), this;
  }
  div(e) {
    return this.x /= e, this.y /= e, this;
  }
  divV(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  mul(e) {
    return this.x *= e, this.y *= e, this;
  }
  mulV(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  abs() {
    return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this;
  }
  nudge(e, n) {
    const r = O.Tan(e, this);
    return this.add(r.mul(n));
  }
  neg() {
    return this.x *= -1, this.y *= -1, this;
  }
  cross(e) {
    return this.x = this.y * e.z - this.z * e.y, this.y = this.z * e.x - this.x * e.z, this;
  }
  dpr(e) {
    return O.Dpr(this, e);
  }
  cpr(e) {
    return O.Cpr(this, e);
  }
  len2() {
    return O.Len2(this);
  }
  len() {
    return O.Len(this);
  }
  pry(e) {
    return O.Pry(this, e);
  }
  per() {
    const { x: e, y: n } = this;
    return this.x = n, this.y = -e, this;
  }
  uni() {
    return O.Uni(this);
  }
  tan(e) {
    return O.Tan(this, e);
  }
  dist(e) {
    return O.Dist(this, e);
  }
  distanceToLineSegment(e, n) {
    return O.DistanceToLineSegment(e, n, this);
  }
  slope(e) {
    return O.Slope(this, e);
  }
  snapToGrid(e) {
    return this.x = Math.round(this.x / e) * e, this.y = Math.round(this.y / e) * e, this;
  }
  angle(e) {
    return O.Angle(this, e);
  }
  toAngle() {
    return O.ToAngle(this);
  }
  lrp(e, n) {
    return this.x = this.x + (e.x - this.x) * n, this.y = this.y + (e.y - this.y) * n, this;
  }
  equals(e) {
    return O.Equals(this, e);
  }
  equalsXY(e, n) {
    return O.EqualsXY(this, e, n);
  }
  norm() {
    const e = this.len();
    return this.x = e === 0 ? 0 : this.x / e, this.y = e === 0 ? 0 : this.y / e, this;
  }
  toFixed() {
    return O.ToFixed(this);
  }
  toString() {
    return O.ToString(O.ToFixed(this));
  }
  toJson() {
    return O.ToJson(this);
  }
  toArray() {
    return O.ToArray(this);
  }
  static Add(e, n) {
    return new O(e.x + n.x, e.y + n.y);
  }
  static AddXY(e, n, r) {
    return new O(e.x + n, e.y + r);
  }
  static Sub(e, n) {
    return new O(e.x - n.x, e.y - n.y);
  }
  static SubXY(e, n, r) {
    return new O(e.x - n, e.y - r);
  }
  static AddScalar(e, n) {
    return new O(e.x + n, e.y + n);
  }
  static SubScalar(e, n) {
    return new O(e.x - n, e.y - n);
  }
  static Div(e, n) {
    return new O(e.x / n, e.y / n);
  }
  static Mul(e, n) {
    return new O(e.x * n, e.y * n);
  }
  static DivV(e, n) {
    return new O(e.x / n.x, e.y / n.y);
  }
  static MulV(e, n) {
    return new O(e.x * n.x, e.y * n.y);
  }
  static Neg(e) {
    return new O(-e.x, -e.y);
  }
  static Per(e) {
    return new O(e.y, -e.x);
  }
  static Dist2(e, n) {
    return O.Sub(e, n).len2();
  }
  static Abs(e) {
    return new O(Math.abs(e.x), Math.abs(e.y));
  }
  static Dist(e, n) {
    return Math.hypot(e.y - n.y, e.x - n.x);
  }
  static Dpr(e, n) {
    return e.x * n.x + e.y * n.y;
  }
  static Cross(e, n) {
    return new O(
      e.y * n.z - e.z * n.y,
      e.z * n.x - e.x * n.z
      // A.z = A.x * V.y - A.y * V.x
    );
  }
  static Cpr(e, n) {
    return e.x * n.y - n.x * e.y;
  }
  static Len2(e) {
    return e.x * e.x + e.y * e.y;
  }
  static Len(e) {
    return Math.sqrt(O.Len2(e));
  }
  static Pry(e, n) {
    return O.Dpr(e, n) / O.Len(n);
  }
  static Uni(e) {
    return O.Div(e, O.Len(e));
  }
  static Tan(e, n) {
    return O.Uni(O.Sub(e, n));
  }
  static Min(e, n) {
    return new O(Math.min(e.x, n.x), Math.min(e.y, n.y));
  }
  static Max(e, n) {
    return new O(Math.max(e.x, n.x), Math.max(e.y, n.y));
  }
  static From({ x: e, y: n, z: r = 1 }) {
    return new O(e, n, r);
  }
  static FromArray(e) {
    return new O(e[0], e[1]);
  }
  static Rot(e, n = 0) {
    const r = Math.sin(n), a = Math.cos(n);
    return new O(e.x * a - e.y * r, e.x * r + e.y * a);
  }
  static RotWith(e, n, r) {
    const a = e.x - n.x, s = e.y - n.y, c = Math.sin(r), f = Math.cos(r);
    return new O(n.x + (a * f - s * c), n.y + (a * c + s * f));
  }
  /**
   * Get the nearest point on a line with a known unit vector that passes through point A
   *
   * ```ts
   * Vec.nearestPointOnLineThroughPoint(A, u, Point)
   * ```
   *
   * @param A - Any point on the line
   * @param u - The unit vector for the line.
   * @param P - A point not on the line to test.
   */
  static NearestPointOnLineThroughPoint(e, n, r) {
    return O.Mul(n, O.Sub(r, e).pry(n)).add(e);
  }
  static NearestPointOnLineSegment(e, n, r, a = !0) {
    const s = O.Tan(n, e), c = O.Add(e, O.Mul(s, O.Sub(r, e).pry(s)));
    if (a) {
      if (c.x < Math.min(e.x, n.x))
        return O.Cast(e.x < n.x ? e : n);
      if (c.x > Math.max(e.x, n.x))
        return O.Cast(e.x > n.x ? e : n);
      if (c.y < Math.min(e.y, n.y))
        return O.Cast(e.y < n.y ? e : n);
      if (c.y > Math.max(e.y, n.y))
        return O.Cast(e.y > n.y ? e : n);
    }
    return c;
  }
  static DistanceToLineThroughPoint(e, n, r) {
    return O.Dist(r, O.NearestPointOnLineThroughPoint(e, n, r));
  }
  static DistanceToLineSegment(e, n, r, a = !0) {
    return O.Dist(r, O.NearestPointOnLineSegment(e, n, r, a));
  }
  static Snap(e, n = 1) {
    return new O(Math.round(e.x / n) * n, Math.round(e.y / n) * n);
  }
  static Cast(e) {
    return e instanceof O ? e : O.From(e);
  }
  static Slope(e, n) {
    return e.x === n.y ? NaN : (e.y - n.y) / (e.x - n.x);
  }
  static Angle(e, n) {
    return Math.atan2(n.y - e.y, n.x - e.x);
  }
  static Lrp(e, n, r) {
    return O.Sub(n, e).mul(r).add(e);
  }
  static Med(e, n) {
    return new O((e.x + n.x) / 2, (e.y + n.y) / 2);
  }
  static Equals(e, n) {
    return Math.abs(e.x - n.x) < 1e-4 && Math.abs(e.y - n.y) < 1e-4;
  }
  static EqualsXY(e, n, r) {
    return e.x === n && e.y === r;
  }
  static Clockwise(e, n, r) {
    return (r.x - e.x) * (n.y - e.y) - (n.x - e.x) * (r.y - e.y) < 0;
  }
  static Rescale(e, n) {
    const r = O.Len(e);
    return new O(n * e.x / r, n * e.y / r);
  }
  static ScaleWithOrigin(e, n, r) {
    return O.Sub(e, r).mul(n).add(r);
  }
  static ToFixed(e, n = 2) {
    return new O(+e.x.toFixed(n), +e.y.toFixed(n), +e.z.toFixed(n));
  }
  static Nudge(e, n, r) {
    return O.Add(e, O.Tan(n, e).mul(r));
  }
  static ToString(e) {
    return `${e.x}, ${e.y}`;
  }
  static ToAngle(e) {
    let n = Math.atan2(e.y, e.x);
    return n < 0 && (n += Math.PI * 2), n;
  }
  static ToArray(e) {
    return [e.x, e.y, e.z];
  }
  static ToJson(e) {
    const { x: n, y: r, z: a } = e;
    return { x: n, y: r, z: a };
  }
  static Average(e) {
    const n = e.length, r = new O(0, 0);
    for (let a = 0; a < n; a++)
      r.add(e[a]);
    return r.div(n);
  }
  static Clamp(e, n, r) {
    return new O(
      Math.min(Math.max(e.x, n), r ?? e.x),
      Math.min(Math.max(e.y, n), r ?? e.y)
    );
  }
  /**
   * Get an array of points (with simulated pressure) between two points.
   *
   * @param A - The first point.
   * @param B - The second point.
   * @param steps - The number of points to return.
   */
  static PointsBetween(e, n, r = 6) {
    const a = [];
    for (let s = 0; s < r; s++) {
      const c = fa.easeInQuad(s / (r - 1)), f = O.Lrp(e, n, c);
      f.z = Math.min(1, 0.5 + Math.abs(0.5 - zq(c)) * 0.65), a.push(f);
    }
    return a;
  }
  static SnapToGrid(e, n = 8) {
    return new O(Math.round(e.x / n) * n, Math.round(e.y / n) * n);
  }
}
const zq = (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t, Kr = Math.PI, cr = Kr / 2, Wr = Kr * 2, KO = Math.PI / 180, Uq = Math.sin;
function $u(t, e, n) {
  return Math.max(e, typeof n < "u" ? Math.min(t, n) : t);
}
function Aw(t, e = 1e10) {
  return t ? Math.round(t * e) / e : 0;
}
function Fy(t, e, n = 1e-6) {
  return Math.abs(t - e) <= n;
}
function Qy(t, e) {
  const n = Math.pow(t - e, 2) / Math.pow(t + e, 2);
  return Kr * (t + e) * (1 + 3 * n / (10 + Math.sqrt(4 - 3 * n)));
}
function TI(t) {
  return t = t % Wr, t < 0 ? t = t + Wr : t === 0 && (t = 0), t;
}
function Wd(t, e) {
  const n = (e - t) % Wr;
  return 2 * n % Wr - n;
}
function Bq(t, e) {
  return Wr - Wd(t, e);
}
function vp(t, e, n) {
  return t + Wd(t, e) * n;
}
function kL(t, e) {
  return Wd(t, e);
}
function Fq(t, e, n) {
  return kL(O.Angle(t, e), O.Angle(t, n));
}
function PL(t) {
  return (Wr + t) % Wr;
}
function Rx(t, e) {
  const n = Wr / e;
  let r = Math.floor((PL(t) + n / 2) / n) * n % Wr;
  return r < Kr && (r += Wr), r > Kr && (r -= Wr), r;
}
function IL(t, e) {
  return t === e || Fy(t % (Math.PI / 2) - e % (Math.PI / 2), 0);
}
function Hq(t) {
  return t * Kr / 180;
}
function RL(t) {
  return t * 180 / Kr;
}
function Ow(t, e, n, r) {
  const a = Fq(t, n, r);
  return e * Wr * (a / Wr);
}
function Sp(t, e, n, r) {
  return new O(t + n * Math.cos(r), e + n * Math.sin(r));
}
function qT(t, e, n) {
  const r = t / 2, a = e / 2, s = [];
  for (let c = 0; c < n; c++) {
    const f = Wr / n, p = -cr + c * f;
    s.push(new O(r + r * Math.cos(p), a + a * Math.sin(p)));
  }
  return s;
}
function Iy(t, e, n, r) {
  return t < r && n < e;
}
function Il(t, e, n, r) {
  const a = Math.max(t, n), s = Math.min(e, r);
  return a <= s ? [a, s] : null;
}
const Vq = (t, e, n) => {
  const r = Wr / t / 2, a = Math.floor(t / 4) * 2, s = t * 2 - a, c = 0, f = Math.floor(t / 2) * 2, p = Math.cos(-cr + a * r) * e / 2, g = Math.cos(-cr + s * r) * e / 2, y = Math.sin(-cr + c * r) * n / 2, v = Math.sin(-cr + f * r) * n / 2;
  return new ot(0, 0, p - g, v - y);
};
function WO(t, e, n) {
  return (e.x - t.x) * (n.y - t.y) - (n.x - t.x) * (e.y - t.y);
}
function Uu(t, e) {
  let n = 0, r, a;
  for (let s = 0; s < e.length; s++)
    r = e[s], a = e[(s + 1) % e.length], r.y <= t.y ? a.y > t.y && WO(r, a, t) > 0 && (n += 1) : a.y <= t.y && WO(r, a, t) < 0 && (n -= 1);
  return n !== 0;
}
function Yq(t, e, n = 8) {
  const r = e.length;
  for (let a = 1; a < r; a++) {
    const s = e[a - 1], c = e[a];
    if (O.DistanceToLineSegment(s, c, t) < n)
      return !0;
  }
  return !1;
}
function ze(t) {
  return +t.toFixed(4);
}
class ot {
  constructor(e = 0, n = 0, r = 0, a = 0) {
    this.x = e, this.y = n, this.w = r, this.h = a;
  }
  x = 0;
  y = 0;
  w = 0;
  h = 0;
  get point() {
    return new O(this.x, this.y);
  }
  set point(e) {
    this.x = e.x, this.y = e.y;
  }
  get minX() {
    return this.x;
  }
  set minX(e) {
    this.x = e;
  }
  get midX() {
    return this.x + this.w / 2;
  }
  get maxX() {
    return this.x + this.w;
  }
  get minY() {
    return this.y;
  }
  set minY(e) {
    this.y = e;
  }
  get midY() {
    return this.y + this.h / 2;
  }
  get maxY() {
    return this.y + this.h;
  }
  get width() {
    return this.w;
  }
  set width(e) {
    this.w = e;
  }
  get height() {
    return this.h;
  }
  set height(e) {
    this.h = e;
  }
  get aspectRatio() {
    return this.width / this.height;
  }
  get center() {
    return new O(this.midX, this.midY);
  }
  set center(e) {
    this.minX = e.x - this.width / 2, this.minY = e.y - this.height / 2;
  }
  get corners() {
    return [
      new O(this.minX, this.minY),
      new O(this.maxX, this.minY),
      new O(this.maxX, this.maxY),
      new O(this.minX, this.maxY)
    ];
  }
  get snapPoints() {
    return [
      new O(this.minX, this.minY),
      new O(this.maxX, this.minY),
      new O(this.maxX, this.maxY),
      new O(this.minX, this.maxY),
      this.center
    ];
  }
  get sides() {
    const { corners: e } = this;
    return [
      [e[0], e[1]],
      [e[1], e[2]],
      [e[2], e[3]],
      [e[3], e[0]]
    ];
  }
  get size() {
    return new O(this.w, this.h);
  }
  toFixed() {
    return this.x = Aw(this.x), this.y = Aw(this.y), this.w = Aw(this.w), this.h = Aw(this.h), this;
  }
  setTo(e) {
    return this.x = e.x, this.y = e.y, this.w = e.w, this.h = e.h, this;
  }
  set(e = 0, n = 0, r = 0, a = 0) {
    return this.x = e, this.y = n, this.w = r, this.h = a, this;
  }
  expand(e) {
    const n = Math.min(this.minX, e.minX), r = Math.min(this.minY, e.minY), a = Math.max(this.maxX, e.maxX), s = Math.max(this.maxY, e.maxY);
    return this.x = n, this.y = r, this.w = a - n, this.h = s - r, this;
  }
  expandBy(e) {
    return this.x -= e, this.y -= e, this.w += e * 2, this.h += e * 2, this;
  }
  scale(e) {
    return this.x /= e, this.y /= e, this.w /= e, this.h /= e, this;
  }
  clone() {
    const { x: e, y: n, w: r, h: a } = this;
    return new ot(e, n, r, a);
  }
  translate(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  snapToGrid(e) {
    const n = Math.round(this.minX / e) * e, r = Math.round(this.minY / e) * e, a = Math.round(this.maxX / e) * e, s = Math.round(this.maxY / e) * e;
    this.minX = n, this.minY = r, this.width = Math.max(1, a - n), this.height = Math.max(1, s - r);
  }
  collides(e) {
    return ot.Collides(this, e);
  }
  contains(e) {
    return ot.Contains(this, e);
  }
  includes(e) {
    return ot.Includes(this, e);
  }
  containsPoint(e, n) {
    return ot.ContainsPoint(this, e, n);
  }
  getHandlePoint(e) {
    switch (e) {
      case "top_left":
        return new O(this.minX, this.minY);
      case "top_right":
        return new O(this.maxX, this.minY);
      case "bottom_left":
        return new O(this.minX, this.maxY);
      case "bottom_right":
        return new O(this.maxX, this.maxY);
      case "top":
        return new O(this.midX, this.minY);
      case "right":
        return new O(this.maxX, this.midY);
      case "bottom":
        return new O(this.midX, this.maxY);
      case "left":
        return new O(this.minX, this.midY);
    }
  }
  toJson() {
    return { x: this.minX, y: this.minY, w: this.w, h: this.h };
  }
  resize(e, n, r) {
    const { minX: a, minY: s, maxX: c, maxY: f } = this;
    let { minX: p, minY: g, maxX: y, maxY: v } = this;
    switch (e) {
      case "left":
      case "top_left":
      case "bottom_left": {
        p += n;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        y += n;
        break;
      }
    }
    switch (e) {
      case "top":
      case "top_left":
      case "top_right": {
        g += r;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        v += r;
        break;
      }
    }
    const S = (y - p) / (c - a), x = (v - g) / (f - s), _ = S < 0, T = x < 0;
    if (_) {
      const I = y;
      y = p, p = I;
    }
    if (T) {
      const I = v;
      v = g, g = I;
    }
    this.minX = p, this.minY = g, this.width = Math.abs(y - p), this.height = Math.abs(v - g);
  }
  static From(e) {
    return new ot(e.x, e.y, e.w, e.h);
  }
  static FromPoints(e) {
    if (e.length === 0)
      return new ot();
    let n = 1 / 0, r = 1 / 0, a = -1 / 0, s = -1 / 0, c;
    for (let f = 0, p = e.length; f < p; f++)
      c = e[f], n = Math.min(c.x, n), r = Math.min(c.y, r), a = Math.max(c.x, a), s = Math.max(c.y, s);
    return new ot(n, r, a - n, s - r);
  }
  static Expand(e, n) {
    const r = Math.min(n.minX, e.minX), a = Math.min(n.minY, e.minY), s = Math.max(n.maxX, e.maxX), c = Math.max(n.maxY, e.maxY);
    return new ot(r, a, s - r, c - a);
  }
  static ExpandBy(e, n) {
    return new ot(e.minX - n, e.minY - n, e.width + n * 2, e.height + n * 2);
  }
  static Collides = (e, n) => !(e.maxX < n.minX || e.minX > n.maxX || e.maxY < n.minY || e.minY > n.maxY);
  static Contains = (e, n) => e.minX < n.minX && e.minY < n.minY && e.maxY > n.maxY && e.maxX > n.maxX;
  static Includes = (e, n) => ot.Collides(e, n) || ot.Contains(e, n);
  static ContainsPoint = (e, n, r) => typeof n == "number" ? !(n < e.minX || r < e.minY || n > e.maxX || r > e.maxY) : !(n.x < e.minX || n.y < e.minY || n.x > e.maxX || n.y > e.maxY);
  static Common = (e) => {
    let n = 1 / 0, r = 1 / 0, a = -1 / 0, s = -1 / 0;
    for (let c = 0; c < e.length; c++) {
      const f = e[c];
      n = Math.min(n, f.minX), r = Math.min(r, f.minY), a = Math.max(a, f.maxX), s = Math.max(s, f.maxY);
    }
    return new ot(n, r, a - n, s - r);
  };
  static Sides = (e, n = 0) => {
    const { corners: r } = e;
    return [
      [r[0], r[1]],
      [r[1], r[2]],
      [r[2], r[3]],
      [r[3], r[0]]
    ];
  };
  static Resize(e, n, r, a, s = !1) {
    const { minX: c, minY: f, maxX: p, maxY: g } = e;
    let { minX: y, minY: v, maxX: S, maxY: x } = e;
    switch (n) {
      case "left":
      case "top_left":
      case "bottom_left": {
        y += r;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        S += r;
        break;
      }
    }
    switch (n) {
      case "top":
      case "top_left":
      case "top_right": {
        v += a;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        x += a;
        break;
      }
    }
    const _ = (S - y) / (p - c), T = (x - v) / (g - f), I = _ < 0, D = T < 0;
    if (s) {
      const j = (p - c) / (g - f), L = Math.abs(S - y), z = Math.abs(x - v), F = L * (T < 0 ? 1 : -1) * (1 / j), K = z * (_ < 0 ? 1 : -1) * j, X = j < L / z;
      switch (n) {
        case "top_left": {
          X ? v = x + F : y = S + K;
          break;
        }
        case "top_right": {
          X ? v = x + F : S = y - K;
          break;
        }
        case "bottom_right": {
          X ? x = v - F : S = y - K;
          break;
        }
        case "bottom_left": {
          X ? x = v - F : y = S + K;
          break;
        }
        case "bottom":
        case "top": {
          const se = (y + S) / 2, ue = z * j;
          y = se - ue / 2, S = se + ue / 2;
          break;
        }
        case "left":
        case "right": {
          const se = (v + x) / 2, ue = L / j;
          v = se - ue / 2, x = se + ue / 2;
          break;
        }
      }
    }
    if (I) {
      const j = S;
      S = y, y = j;
    }
    if (D) {
      const j = x;
      x = v, v = j;
    }
    const N = new ot(y, v, Math.abs(S - y), Math.abs(x - v));
    return {
      box: N,
      scaleX: +(N.width / e.width * (_ > 0 ? 1 : -1)).toFixed(5),
      scaleY: +(N.height / e.height * (T > 0 ? 1 : -1)).toFixed(5)
    };
  }
  equals(e) {
    return ot.Equals(this, e);
  }
  static Equals(e, n) {
    return n.x === e.x && n.y === e.y && n.w === e.w && n.h === e.h;
  }
}
function Kq(t) {
  switch (t) {
    case "top":
      return "bottom";
    case "bottom":
      return "top";
    case "top_left":
      return "bottom_left";
    case "top_right":
      return "bottom_right";
    case "bottom_left":
      return "top_left";
    case "bottom_right":
      return "top_right";
    default:
      return t;
  }
}
function Wq(t) {
  switch (t) {
    case "left":
      return "right";
    case "right":
      return "left";
    case "top_left":
      return "top_right";
    case "top_right":
      return "top_left";
    case "bottom_left":
      return "bottom_right";
    case "bottom_right":
      return "bottom_left";
    default:
      return t;
  }
}
function Gq(t) {
  return t === "top_left" || t === "top_right" || t === "bottom_right" || t === "bottom_left";
}
class $L {
  constructor(e) {
    this._values = e;
  }
  /**
   * The segment's values. Do not modify these directly. Instead, use the `values` setter or `update` method.
   *
   * @internal
   */
  _values;
  /**
   * A private set of cached values, used for lookups and computations. Changing any of the
   * segment's values will clear this object.
   *
   * @internal
   */
  _computed = {};
  /**
   * The values for the curve segment.
   *
   * @public
   */
  get values() {
    return this._values;
  }
  set values(e) {
    this._values = e, this._computed = {};
  }
  /**
   * The length of the curve segment.
   *
   * @public
   */
  get length() {
    if (this._computed.length !== void 0)
      return this._computed.length;
    const { lut: e } = this;
    let n = e[0], r = 0;
    for (let a = 1; a < e.length; a++) {
      const s = e[a];
      r += n.dist(s), n = s;
    }
    return this._computed.length = r, r;
  }
  /**
   * The bounding box containing the curve segment.
   *
   * @public
   */
  get bounds() {
    if (this._computed.bounds !== void 0)
      return this._computed.bounds;
    let e = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0;
    const { lut: s } = this;
    for (const f of s)
      e = Math.min(f.x, e), n = Math.min(f.y, n), r = Math.max(f.x, r), a = Math.max(f.y, a);
    const c = new ot(e, n, r - e, a - n);
    return this._computed.bounds = c, c;
  }
  /**
   * A lookup table consisting of values.p points along the segment. Used to compute lengths,
   * closest points, etc. This should only be _computed once (when first requested) per set of values.
   *
   * @public
   */
  get lut() {
    if (this._computed.lut)
      return this._computed.lut;
    const { p: e } = this.values, n = [];
    for (let r = 0; r < e + 1; r++)
      n.push(this.getPoint(r / e));
    return this._computed.lut = n, n;
  }
  /**
   * A point half-way along the length of the segment.
   *
   * @public
   */
  get midPoint() {
    if (this._computed.midPoint)
      return this._computed.midPoint;
    const e = this.getPoint(0.5);
    return this._computed.midPoint = e, e;
  }
  /**
   * An SVG path for the segment.
   *
   * @public
   */
  get path() {
    if (this._computed.path)
      return this._computed.path;
    const e = this.getPath();
    return this._computed.path = e, e;
  }
  /**
   * Evaluate a point at a length along the curve segment.
   *
   * @param length - The length to find the point value.
   * @public
   */
  getPointAtLength(e) {
    const n = Math.max(0, Math.min(1, e / this.length));
    return this.getPoint(n);
  }
  /**
   * Get the normal at distance t along the curve segment.
   *
   * @param t - The distance (0-1) to find the normal.
   * @public
   */
  getNormal(e) {
    return this.getPoint(e - 25e-4).tan(this.getPoint(e + 25e-4)).per().uni().toFixed();
  }
  /**
   * Get the normal at a length along the curve segment.
   *
   * @param length - The length to find the normal.
   * @public
   */
  getNormalAtLength(e) {
    return this.getNormal(e / this.length);
  }
  /**
   * Get the closest point on the segment to an arbitrary point.
   *
   * @param point - The arbitrary point.
   * @public
   */
  getClosestPointTo(e) {
    const { lut: n } = this;
    let r = 0, a = n[0], s = n[0].dist(e);
    for (let f = 1; f < n.length; f++) {
      const p = O.Dist(n[f], e);
      p < s && (s = p, a = n[f], r = f / n.length);
    }
    const c = 1 / this.values.p;
    for (let f = Math.max(0, r - c / 2); f < Math.min(1, r + c / 2); f += c / 10) {
      const p = this.getPoint(f), g = O.Dist(p, e);
      g < s && (s = g, a = p);
    }
    return { point: a, distance: s };
  }
  /**
   * Set one or more values. Updating the segment will clear cached values.
   *
   * @param values - A partial of the segment's values object.
   * @public
   */
  update(e) {
    this._computed = {}, this.values = { ...this.values, ...e };
  }
}
class Xq extends $L {
  constructor(e, n, r, a, s = 25) {
    super({ a: e, b: n, c: r, d: a, p: s });
  }
  [Symbol.iterator] = function* () {
    const { a: e, b: n, c: r, d: a } = this.values;
    yield* [e, n, r, a];
  };
  getPath(e = !0) {
    const { a: n, b: r, c: a, d: s } = this.values;
    return O.Equals(n, s) ? "" : `${e ? `M${n.x.toFixed(2)},${n.y.toFixed(2)}C` : ""}${r.x.toFixed(2)},${r.y.toFixed(
      2
    )} ${a.x.toFixed(2)},${a.y.toFixed(2)} ${s.x.toFixed(2)},${s.y.toFixed(2)}`;
  }
  getPoint(e) {
    const { a: n, b: r, c: a, d: s } = this.values;
    return new O(
      (1 - e) * (1 - e) * (1 - e) * n.x + 3 * ((1 - e) * (1 - e)) * e * r.x + 3 * (1 - e) * (e * e) * a.x + e * e * e * s.x,
      (1 - e) * (1 - e) * (1 - e) * n.y + 3 * ((1 - e) * (1 - e)) * e * r.y + 3 * (1 - e) * (e * e) * a.y + e * e * e * s.y
    );
  }
  getX(e) {
    const { a: n, b: r, c: a, d: s } = this.values;
    return (1 - e) * (1 - e) * (1 - e) * n.x + 3 * ((1 - e) * (1 - e)) * e * r.x + 3 * (1 - e) * (e * e) * a.x + e * e * e * s.x;
  }
  getY(e) {
    const { a: n, b: r, c: a, d: s } = this.values;
    return (1 - e) * (1 - e) * (1 - e) * n.y + 3 * ((1 - e) * (1 - e)) * e * r.y + 3 * (1 - e) * (e * e) * a.y + e * e * e * s.y;
  }
}
class ML {
  constructor(e, n = 50, r = 1) {
    this.points = e, this.p = n, this.k = r;
  }
  computed = {};
  get length() {
    if (this.computed.length !== void 0)
      return this.computed.length;
    const { segments: e } = this, n = e.reduce((r, a) => r + a.length, 0);
    return this.computed.length = n, n;
  }
  get bounds() {
    if (this.computed.bounds !== void 0)
      return this.computed.bounds;
    const { segments: e } = this, n = ot.Common(e.map((r) => r.bounds));
    return this.computed.bounds = n, n;
  }
  get head() {
    const { points: e } = this;
    return e[0];
  }
  get tail() {
    const { points: e } = this;
    return e[e.length - 1];
  }
  get path() {
    if (this.computed.path !== void 0)
      return this.computed.path;
    const e = this.segments.map((n) => n.path).filter((n) => n != null && n !== "").join(" ");
    return this.computed.path = e, e;
  }
  addPoint(e) {
    const { points: n, k: r, p: a } = this;
    return n.push(e), this.computed = {}, this.getSegmentsFromPoints(this.points, a, r), this;
  }
  removePoint(e) {
    const { points: n, k: r, p: a } = this, s = typeof e == "number" ? Math.floor(e) : n.indexOf(e);
    return s === -1 ? this : (n.splice(s, 1), this.computed = {}, this.getSegmentsFromPoints(this.points, a, r), this);
  }
  getPointAtLength(e) {
    const { segments: n } = this;
    let r = e;
    if (e <= 0)
      return n[0].getPoint(0);
    if (e >= this.length)
      return n[n.length - 1].getPoint(1);
    for (let a = 0; a < n.length; a++) {
      const s = n[a], { length: c } = s;
      if (r < c)
        return s.getPoint(r / c);
      r -= s.length;
    }
    return n[n.length - 1].getPoint(1);
  }
  getPoint(e) {
    return e <= 0 ? this.segments[0].getPoint(0) : e >= 1 ? this.segments[this.segments.length - 1].getPoint(1) : this.getPointAtLength(e * this.length);
  }
  getNormal(e) {
    const { length: n } = this;
    return this.getNormalAtLength(e * n);
  }
  getNormalAtLength(e) {
    const { segments: n } = this;
    if (e < 0)
      return new O(0, 0);
    let r = e;
    for (const a of n) {
      const s = a.length;
      if (r <= s)
        return a.getNormal(r / s);
      r -= s;
    }
    return new O(0, 0);
  }
  getClosestPointTo(e) {
    const { head: n, segments: r } = this;
    let a = n, s = O.Dist(e, n);
    for (const c of r) {
      const f = c.getClosestPointTo(e);
      f.distance < s && (s = f.distance, a = f.point);
    }
    return { point: a, distance: s };
  }
}
class kI extends ML {
  constructor(e, n = 1.2, r = 20) {
    super(e, n, r), this.segments = this.getSegmentsFromPoints(e, n, r);
  }
  segments;
  getSegmentsFromPoints(e, n = 1.25, r = 20) {
    const a = e.length, s = a - 2, c = [];
    for (let f = 0; f < a - 1; f++) {
      const p = f === 0 ? e[0] : e[f - 1], g = e[f], y = e[f + 1], v = f === s ? y : e[f + 2];
      c.push(
        new Xq(
          g,
          f === 0 ? p : new O(g.x + (y.x - p.x) / 6 * n, g.y + (y.y - p.y) / 6 * n),
          f === s ? y : new O(y.x - (v.x - g.x) / 6 * n, y.y - (v.y - g.y) / 6 * n),
          y,
          r
        )
      );
    }
    return c;
  }
  static FromPoints(e) {
    return new kI(e);
  }
}
class qq extends $L {
  constructor(e, n, r = 2) {
    super({ a: e, b: n, p: r }), this.a = e, this.b = n, this.values.p = Math.max(10, Math.ceil(this.length / 20));
  }
  get length() {
    return O.Dist(this.a, this.b);
  }
  get tangent() {
    return O.Tan(this.a, this.b);
  }
  get angle() {
    return O.Angle(this.a, this.b);
  }
  get bounds() {
    return ot.FromPoints([this.a, this.b]);
  }
  getX(e) {
    const { a: n, b: r } = this.values;
    return n.x + (r.x - n.x) * e;
  }
  getY(e) {
    const { a: n, b: r } = this.values;
    return n.y + (r.y - n.y) * e;
  }
  getPoint(e) {
    const { a: n, b: r } = this.values;
    return O.Lrp(n, r, e);
  }
  getPath(e = !0) {
    const { a: n, b: r } = this.values;
    return O.Equals(n, r) ? "" : e ? `M${n.x},${n.y}L${r.x},${r.y}` : `${r.x},${r.y}`;
  }
  getNormal() {
    const { a: e, b: n } = this.values;
    return O.Sub(e, n).per().uni().toFixed();
  }
  /**
   * Get the closest point on the segment to an arbitrary point.
   *
   * @param point - The arbitrary point.
   * @public
   */
  getClosestPointTo(e) {
    const { a: n, b: r } = this.values, a = O.NearestPointOnLineSegment(n, r, e), s = a.dist(e);
    return { point: a, distance: s };
  }
  static Length(e) {
    return O.Dist(e.a, e.b);
  }
  static Tangent(e) {
    return O.Tan(e.a, e.b);
  }
  static Angle(e) {
    return O.Angle(e.a, e.b);
  }
}
class De {
  constructor(e, n, r, a, s, c) {
    this.a = e, this.b = n, this.c = r, this.d = a, this.e = s, this.f = c;
  }
  a = 1;
  b = 0;
  c = 0;
  d = 1;
  e = 0;
  f = 0;
  equals(e) {
    return this.a === e.a && this.b === e.b && this.c === e.c && this.d === e.d && this.e === e.e && this.f === e.f;
  }
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this;
  }
  multiply(e) {
    const n = e, { a: r, b: a, c: s, d: c, e: f, f: p } = this;
    return this.a = r * n.a + s * n.b, this.c = r * n.c + s * n.d, this.e = r * n.e + s * n.f + f, this.b = a * n.a + c * n.b, this.d = a * n.c + c * n.d, this.f = a * n.e + c * n.f + p, this;
  }
  rotate(e, n, r) {
    return e === 0 ? this : n === void 0 ? this.multiply(De.Rotate(e)) : this.translate(n, r).multiply(De.Rotate(e)).translate(-n, -r);
  }
  translate(e, n) {
    return this.multiply(De.Translate(e, n));
  }
  scale(e, n) {
    return this.multiply(De.Scale(e, n));
  }
  invert() {
    const { a: e, b: n, c: r, d: a, e: s, f: c } = this, f = e * a - n * r;
    return this.a = a / f, this.b = n / -f, this.c = r / -f, this.d = e / f, this.e = (a * s - r * c) / -f, this.f = (n * s - e * c) / f, this;
  }
  applyToPoint(e) {
    return De.applyToPoint(this, e);
  }
  applyToPoints(e) {
    return De.applyToPoints(this, e);
  }
  decomposed() {
    return De.Decompose(this);
  }
  toCssString() {
    return De.toCssString(this);
  }
  setTo(e) {
    return Object.assign(this, e), this;
  }
  decompose() {
    return De.Decompose(this);
  }
  clone() {
    return new De(this.a, this.b, this.c, this.d, this.e, this.f);
  }
  /* --------------------- Static --------------------- */
  static Identity() {
    return new De(1, 0, 0, 1, 0, 0);
  }
  static Translate(e, n) {
    return new De(1, 0, 0, 1, e, n);
  }
  static Rotate(e, n, r) {
    if (e === 0)
      return De.Identity();
    const a = Math.cos(e), s = Math.sin(e), c = new De(a, s, -s, a, 0, 0);
    return n === void 0 ? c : De.Compose(
      De.Translate(n, r),
      c,
      De.Translate(-n, -r)
    );
  }
  static Scale = (e, n, r, a) => {
    const s = new De(e, 0, 0, 0, n, 0);
    return r === void 0 ? s : De.Compose(
      De.Translate(r, a),
      s,
      De.Translate(-r, -a)
    );
  };
  static Multiply(e, n) {
    return {
      a: e.a * n.a + e.c * n.b,
      c: e.a * n.c + e.c * n.d,
      e: e.a * n.e + e.c * n.f + e.e,
      b: e.b * n.a + e.d * n.b,
      d: e.b * n.c + e.d * n.d,
      f: e.b * n.e + e.d * n.f + e.f
    };
  }
  static Inverse(e) {
    const n = e.a * e.d - e.b * e.c;
    return {
      a: e.d / n,
      b: e.b / -n,
      c: e.c / -n,
      d: e.a / n,
      e: (e.d * e.e - e.c * e.f) / -n,
      f: (e.b * e.e - e.a * e.f) / n
    };
  }
  static Absolute(e) {
    const n = e.a * e.d - e.b * e.c;
    return {
      a: e.d / n,
      b: e.b / -n,
      c: e.c / -n,
      d: e.a / n,
      e: (e.d * e.e - e.c * e.f) / n,
      f: (e.b * e.e - e.a * e.f) / -n
    };
  }
  static Compose(...e) {
    const n = De.Identity();
    for (let r = 0, a = e.length; r < a; r++)
      n.multiply(e[r]);
    return n;
  }
  static Decompose(e) {
    let n, r, a;
    if (e.a !== 0 || e.c !== 0) {
      const s = Math.hypot(e.a, e.c);
      n = s, r = (e.a * e.d - e.b * e.c) / s, a = Math.acos(e.a / s) * (e.c > 0 ? -1 : 1);
    } else if (e.b !== 0 || e.d !== 0) {
      const s = Math.hypot(e.b, e.d);
      n = (e.a * e.d - e.b * e.c) / s, r = s, a = cr + Math.acos(e.b / s) * (e.d > 0 ? -1 : 1);
    } else
      n = 0, r = 0, a = 0;
    return {
      x: e.e,
      y: e.f,
      scaleX: n,
      scaleY: r,
      rotation: PL(a)
    };
  }
  static Smooth(e, n = 1e10) {
    return e.a = Math.round(e.a * n) / n, e.b = Math.round(e.b * n) / n, e.c = Math.round(e.c * n) / n, e.d = Math.round(e.d * n) / n, e.e = Math.round(e.e * n) / n, e.f = Math.round(e.f * n) / n, e;
  }
  static toCssString(e) {
    return `matrix(${ze(e.a)}, ${ze(e.b)}, ${ze(
      e.c
    )}, ${ze(e.d)}, ${ze(e.e)}, ${ze(e.f)})`;
  }
  static applyToPoint(e, n) {
    return new O(
      e.a * n.x + e.c * n.y + e.e,
      e.b * n.x + e.d * n.y + e.f,
      n.z
    );
  }
  static applyToXY(e, n, r) {
    return [e.a * n + e.c * r + e.e, e.b * n + e.d * r + e.f];
  }
  static applyToPoints(e, n) {
    return n.map(
      (r) => new O(e.a * r.x + e.c * r.y + e.e, e.b * r.x + e.d * r.y + e.f, r.z)
    );
  }
  static applyToBounds(e, n) {
    return new ot(e.e + n.minX, e.f + n.minY, n.width, n.height);
  }
  static From(e) {
    return new De(e.a, e.b, e.c, e.d, e.e, e.f);
  }
}
class PI extends ML {
  constructor(e, n = 1.2, r = 20) {
    super(e, n, r), this.segments = this.getSegmentsFromPoints(e, r);
  }
  segments;
  getSegmentsFromPoints(e, n = 50) {
    const r = [];
    for (let a = 0; a < e.length - 1; a++)
      r.push(new qq(e[a], e[a + 1], n));
    return r;
  }
  static FromPoints(e) {
    return new PI(e);
  }
}
const { PI: Qq } = Math, Ig = Qq + 1e-4;
function Zy(t, e = {}) {
  const { size: n = 16, smoothing: r = 0.5, start: a = {}, end: s = {}, last: c = !1 } = e, { cap: f = !0 } = a, { cap: p = !0 } = s;
  if (t.length === 0 || n <= 0)
    return [];
  const g = t[0], y = t[t.length - 1], v = y.runningLength, S = a.taper === !1 ? 0 : a.taper === !0 ? Math.max(n, v) : a.taper, x = s.taper === !1 ? 0 : s.taper === !0 ? Math.max(n, v) : s.taper, _ = Math.pow(n * r, 2), T = [], I = [];
  let D = t[0].vector, N = t[0].point, j = N, L = N, z = j, F = !1, K;
  for (let ve = 0; ve < t.length; ve++) {
    K = t[ve];
    const { point: Y, vector: le } = t[ve], Re = K.vector.dpr(D), he = (ve < t.length - 1 ? t[ve + 1] : t[ve]).vector, te = ve < t.length - 1 ? he.dpr(K.vector) : 1, de = Re < 0 && !F, W = te !== null && te < 0.2;
    if (de || W) {
      if (te > -0.62 && v - K.runningLength > K.radius) {
        const ce = D.clone().mul(K.radius);
        D.clone().cpr(he) < 0 ? (L = O.Add(Y, ce), z = O.Sub(Y, ce)) : (L = O.Sub(Y, ce), z = O.Add(Y, ce)), T.push(L), I.push(z);
      } else {
        const ce = D.clone().mul(K.radius).per(), xe = O.Sub(K.input, ce);
        for (let $e = 1 / 13, Me = 0; Me < 1; Me += $e)
          L = O.RotWith(xe, K.input, Ig * Me), T.push(L), z = O.RotWith(xe, K.input, Ig + Ig * -Me), I.push(z);
      }
      N = L, j = z, W && (F = !0);
      continue;
    }
    if (F = !1, K === g || K === y) {
      const ce = O.Per(le).mul(K.radius);
      T.push(O.Sub(Y, ce)), I.push(O.Add(Y, ce));
      continue;
    }
    const fe = O.Lrp(he, le, te).per().mul(K.radius);
    L = O.Sub(Y, fe), (ve <= 1 || O.Dist2(N, L) > _) && (T.push(L), N = L), z = O.Add(Y, fe), (ve <= 1 || O.Dist2(j, z) > _) && (I.push(z), j = z), D = le;
  }
  const X = g.point, se = t.length > 1 ? t[t.length - 1].point : O.AddXY(g.point, 1, 1);
  if (t.length === 1 && (!(S || x) || c)) {
    const ve = O.Add(
      X,
      O.Sub(X, se).uni().per().mul(-g.radius)
    ), Y = [];
    for (let le = 1 / 13, Re = le; Re <= 1; Re += le)
      Y.push(O.RotWith(ve, X, Ig * 2 * Re));
    return Y;
  }
  const ue = [];
  if (!(S || x && t.length === 1))
    if (f)
      for (let ve = 1 / 8, Y = ve; Y <= 1; Y += ve) {
        const le = O.RotWith(I[0], X, Ig * Y);
        ue.push(le);
      }
    else {
      const ve = O.Sub(T[0], I[0]), Y = O.Mul(ve, 0.5), le = O.Mul(ve, 0.51);
      ue.push(
        O.Sub(X, Y),
        O.Sub(X, le),
        O.Add(X, le),
        O.Add(X, Y)
      );
    }
  const pe = [], Pe = y.vector.clone().per().neg();
  if (x || S && t.length === 1)
    pe.push(se);
  else if (p) {
    const ve = O.Add(se, O.Mul(Pe, y.radius));
    for (let Y = 1 / 29, le = Y; le < 1; le += Y)
      pe.push(O.RotWith(ve, se, Ig * 3 * le));
  } else
    pe.push(
      O.Add(se, O.Mul(Pe, y.radius)),
      O.Add(se, O.Mul(Pe, y.radius * 0.99)),
      O.Sub(se, O.Mul(Pe, y.radius * 0.99)),
      O.Sub(se, O.Mul(Pe, y.radius))
    );
  return T.concat(pe, I.reverse(), ue);
}
const Zq = 0.025, Jq = 0.01;
function kc(t, e = {}) {
  const { streamline: n = 0.5, size: r = 16, simulatePressure: a = !1 } = e;
  if (t.length === 0)
    return [];
  const s = 0.15 + (1 - n) * 0.85;
  let c = t.map(O.From), f = 0;
  if (!a) {
    let I = c[0];
    for (; I && !(I.z >= Zq); )
      c.shift(), I = c[0];
  }
  if (!a) {
    let I = c[c.length - 1];
    for (; I && !(I.z >= Jq); )
      c.pop(), I = c[c.length - 1];
  }
  if (c.length === 0)
    return [
      {
        point: O.From(t[0]),
        input: O.From(t[0]),
        pressure: a ? 0.5 : 0.15,
        vector: new O(1, 1),
        distance: 0,
        runningLength: 0,
        radius: 1
      }
    ];
  let p = c[1];
  for (; p && !(O.Dist(p, c[0]) > r / 3); )
    c[0].z = Math.max(c[0].z, p.z), c.splice(1, 1), p = c[1];
  const g = c.pop();
  for (p = c[c.length - 1]; p && !(O.Dist(p, g) > r / 3); )
    c.pop(), p = c[c.length - 1], f++;
  c.push(g);
  const y = e.last || !e.simulatePressure || c.length > 1 && O.Dist(c[c.length - 1], c[c.length - 2]) < r || f > 0;
  if (c.length === 2 && e.simulatePressure) {
    const I = c[1];
    c = c.slice(0, -1);
    for (let D = 1; D < 5; D++) {
      const N = O.Lrp(c[0], I, D / 4);
      N.z = (c[0].z + (I.z - c[0].z)) * D / 4, c.push(N);
    }
  }
  const v = [
    {
      point: c[0],
      input: c[0],
      pressure: a ? 0.5 : c[0].z,
      vector: new O(1, 1),
      distance: 0,
      runningLength: 0,
      radius: 1
    }
  ];
  let S = 0, x = v[0], _, T;
  y && n > 0 && c.push(c[c.length - 1].clone());
  for (let I = 1, D = c.length; I < D; I++)
    _ = !s || e.last && I === D - 1 ? c[I].clone() : c[I].clone().lrp(x.point, 1 - s), !x.point.equals(_) && (T = O.Dist(_, x.point), S += T, !(I < 4 && S < r) && (x = {
      input: c[I],
      // The adjusted point
      point: _,
      // The input pressure (or .5 if not specified)
      pressure: a ? 0.5 : c[I].z,
      // The vector from the current point to the previous point
      vector: O.Sub(x.point, _).uni(),
      // The distance between the current point and the previous point
      distance: T,
      // The total distance so far
      runningLength: S,
      // The stroke point's radius
      radius: 1
    }, v.push(x)));
  if (v[1]?.vector && (v[0].vector = v[1].vector.clone()), S < 1) {
    const I = Math.max(0.5, ...v.map((D) => D.pressure));
    v.forEach((D) => D.pressure = I);
  }
  return v;
}
const { min: Ud } = Math, QT = 0.275;
function Jy(t, e) {
  const {
    size: n = 16,
    thinning: r = 0.5,
    simulatePressure: a = !0,
    easing: s = (I) => I,
    start: c = {},
    end: f = {}
  } = e, { easing: p = fa.easeOutQuad } = c, { easing: g = fa.easeOutCubic } = f, y = t[t.length - 1].runningLength;
  let v, S = t[0].pressure, x;
  if (!a && y < n) {
    const I = t.reduce((D, N) => Math.max(D, N.pressure), 0.5);
    return t.forEach((D) => {
      D.pressure = I, D.radius = n * s(0.5 - r * (0.5 - D.pressure));
    }), t;
  } else {
    let I;
    for (let D = 0, N = t.length; D < N && (x = t[D], !(x.runningLength > n * 5)); D++) {
      const j = Ud(1, x.distance / n);
      if (a) {
        const L = Ud(1, 1 - j);
        I = Ud(1, S + (L - S) * (j * QT));
      } else
        I = Ud(1, S + (x.pressure - S) * 0.5);
      S = S + (I - S) * 0.5;
    }
    for (let D = 0; D < t.length; D++) {
      if (x = t[D], r) {
        let { pressure: N } = x;
        const j = Ud(1, x.distance / n);
        if (a) {
          const L = Ud(1, 1 - j);
          N = Ud(1, S + (L - S) * (j * QT));
        } else
          N = Ud(
            1,
            S + (N - S) * (j * QT)
          );
        x.radius = n * s(0.5 - r * (0.5 - N)), S = N;
      } else
        x.radius = n / 2;
      v === void 0 && (v = x.radius);
    }
  }
  const _ = c.taper === !1 ? 0 : c.taper === !0 ? Math.max(n, y) : c.taper, T = f.taper === !1 ? 0 : f.taper === !0 ? Math.max(n, y) : f.taper;
  if (_ || T)
    for (let I = 0; I < t.length; I++) {
      x = t[I];
      const { runningLength: D } = x, N = D < _ ? p(D / _) : 1, j = y - D < T ? g((y - D) / T) : 1;
      x.radius = Math.max(0.01, x.radius * Math.min(N, j));
    }
  return t;
}
function f1(t, e = {}) {
  return Zy(
    Jy(kc(t, e), e),
    e
  );
}
function II(t, e, n, r) {
  const a = t.x - n.x, s = t.y - n.y, c = r.x - n.x, f = r.y - n.y, p = e.x - t.x, g = e.y - t.y, y = c * s - f * a, v = p * s - g * a, S = f * p - c * g;
  if (y === 0 || v === 0 || S === 0)
    return null;
  if (S !== 0) {
    const x = y / S, _ = v / S;
    if (0 <= x && x <= 1 && 0 <= _ && _ <= 1)
      return O.AddXY(t, x * p, x * g);
  }
  return null;
}
function AL(t, e, n, r) {
  const a = (e.x - t.x) * (e.x - t.x) + (e.y - t.y) * (e.y - t.y), s = 2 * ((e.x - t.x) * (t.x - n.x) + (e.y - t.y) * (t.y - n.y)), c = n.x * n.x + n.y * n.y + t.x * t.x + t.y * t.y - 2 * (n.x * t.x + n.y * t.y) - r * r, f = s * s - 4 * a * c;
  if (f < 0 || f === 0)
    return null;
  const p = Math.sqrt(f), g = (-s + p) / (2 * a), y = (-s - p) / (2 * a);
  if ((g < 0 || g > 1) && (y < 0 || y > 1))
    return null;
  const v = [];
  return 0 <= g && g <= 1 && v.push(O.Lrp(t, e, g)), 0 <= y && y <= 1 && v.push(O.Lrp(t, e, y)), v.length === 0 ? null : v;
}
function RI(t, e, n) {
  const r = [];
  let a;
  for (let s = 0, c = n.length - 1; s < c; s++)
    a = II(t, e, n[s], n[s + 1]), a && r.push(a);
  return r.length === 0 ? null : r;
}
function eQ(t, e, n) {
  const r = [];
  let a;
  for (let s = 1, c = n.length; s < c + 1; s++)
    a = II(
      t,
      e,
      n[s - 1],
      n[s % n.length]
    ), a && r.push(a);
  return r.length === 0 ? null : r;
}
function tQ(t, e, n, r) {
  let a = n.x - t.x, s = n.y - t.y;
  const c = Math.sqrt(a * a + s * s), f = (c * c - r * r + e * e) / (2 * c), p = Math.sqrt(e * e - f * f);
  return a /= c, s /= c, [
    new O(t.x + a * f - s * p, t.y + s * f + a * p),
    new O(t.x + a * f + s * p, t.y + s * f - a * p)
  ];
}
function GO(t, e, n) {
  const r = [];
  let a, s, c;
  for (let f = 0, p = n.length; f < p; f++)
    a = n[f], s = n[(f + 1) % n.length], c = AL(a, s, t, e), c && r.push(...c);
  return r.length === 0 ? null : r;
}
function XO(t, e, n) {
  const r = [];
  let a, s, c;
  for (let f = 1, p = n.length; f < p; f++)
    a = n[f - 1], s = n[f], c = AL(a, s, t, e), c && r.push(...c);
  return r.length === 0 ? null : r;
}
function Dw(t, e, n) {
  return (n.y - t.y) * (e.x - t.x) > (e.y - t.y) * (n.x - t.x);
}
function ef(t, e, n, r) {
  return Dw(t, n, r) !== Dw(e, n, r) && Dw(t, e, n) !== Dw(t, e, r);
}
function lP(t, e) {
  const n = [];
  let r, a, s, c;
  for (let f = 0, p = t.length; f < p; f++)
    r = t[f], Uu(r, e) && n.push(r);
  for (let f = 0, p = e.length; f < p; f++)
    r = e[f], Uu(r, t) && n.push(r);
  for (let f = 0, p = t.length; f < p; f++) {
    r = t[f], a = t[(f + 1) % t.length];
    for (let g = 0, y = e.length; g < y; g++) {
      s = e[g], c = e[(g + 1) % e.length];
      const v = II(r, a, s, c);
      v !== null && n.push(v);
    }
  }
  return n.length === 0 ? null : nQ(n);
}
function nQ(t) {
  const e = O.Average(t);
  return t.sort((n, r) => O.Angle(e, n) - O.Angle(e, r));
}
function rQ(t, e) {
  let n, r, a, s;
  for (let c = 0, f = t.length; c < f; c++) {
    n = t[c], r = t[(c + 1) % f];
    for (let p = 0, g = e.length; p < g; p++)
      if (a = e[p], s = e[(p + 1) % g], ef(n, r, a, s))
        return !0;
  }
  return !1;
}
var OL = { exports: {} };
(function(t) {
  var e = Object.prototype.hasOwnProperty, n = "~";
  function r() {
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1));
  function a(p, g, y) {
    this.fn = p, this.context = g, this.once = y || !1;
  }
  function s(p, g, y, v, S) {
    if (typeof y != "function")
      throw new TypeError("The listener must be a function");
    var x = new a(y, v || p, S), _ = n ? n + g : g;
    return p._events[_] ? p._events[_].fn ? p._events[_] = [p._events[_], x] : p._events[_].push(x) : (p._events[_] = x, p._eventsCount++), p;
  }
  function c(p, g) {
    --p._eventsCount === 0 ? p._events = new r() : delete p._events[g];
  }
  function f() {
    this._events = new r(), this._eventsCount = 0;
  }
  f.prototype.eventNames = function() {
    var g = [], y, v;
    if (this._eventsCount === 0)
      return g;
    for (v in y = this._events)
      e.call(y, v) && g.push(n ? v.slice(1) : v);
    return Object.getOwnPropertySymbols ? g.concat(Object.getOwnPropertySymbols(y)) : g;
  }, f.prototype.listeners = function(g) {
    var y = n ? n + g : g, v = this._events[y];
    if (!v)
      return [];
    if (v.fn)
      return [v.fn];
    for (var S = 0, x = v.length, _ = new Array(x); S < x; S++)
      _[S] = v[S].fn;
    return _;
  }, f.prototype.listenerCount = function(g) {
    var y = n ? n + g : g, v = this._events[y];
    return v ? v.fn ? 1 : v.length : 0;
  }, f.prototype.emit = function(g, y, v, S, x, _) {
    var T = n ? n + g : g;
    if (!this._events[T])
      return !1;
    var I = this._events[T], D = arguments.length, N, j;
    if (I.fn) {
      switch (I.once && this.removeListener(g, I.fn, void 0, !0), D) {
        case 1:
          return I.fn.call(I.context), !0;
        case 2:
          return I.fn.call(I.context, y), !0;
        case 3:
          return I.fn.call(I.context, y, v), !0;
        case 4:
          return I.fn.call(I.context, y, v, S), !0;
        case 5:
          return I.fn.call(I.context, y, v, S, x), !0;
        case 6:
          return I.fn.call(I.context, y, v, S, x, _), !0;
      }
      for (j = 1, N = new Array(D - 1); j < D; j++)
        N[j - 1] = arguments[j];
      I.fn.apply(I.context, N);
    } else {
      var L = I.length, z;
      for (j = 0; j < L; j++)
        switch (I[j].once && this.removeListener(g, I[j].fn, void 0, !0), D) {
          case 1:
            I[j].fn.call(I[j].context);
            break;
          case 2:
            I[j].fn.call(I[j].context, y);
            break;
          case 3:
            I[j].fn.call(I[j].context, y, v);
            break;
          case 4:
            I[j].fn.call(I[j].context, y, v, S);
            break;
          default:
            if (!N)
              for (z = 1, N = new Array(D - 1); z < D; z++)
                N[z - 1] = arguments[z];
            I[j].fn.apply(I[j].context, N);
        }
    }
    return !0;
  }, f.prototype.on = function(g, y, v) {
    return s(this, g, y, v, !1);
  }, f.prototype.once = function(g, y, v) {
    return s(this, g, y, v, !0);
  }, f.prototype.removeListener = function(g, y, v, S) {
    var x = n ? n + g : g;
    if (!this._events[x])
      return this;
    if (!y)
      return c(this, x), this;
    var _ = this._events[x];
    if (_.fn)
      _.fn === y && (!S || _.once) && (!v || _.context === v) && c(this, x);
    else {
      for (var T = 0, I = [], D = _.length; T < D; T++)
        (_[T].fn !== y || S && !_[T].once || v && _[T].context !== v) && I.push(_[T]);
      I.length ? this._events[x] = I.length === 1 ? I[0] : I : c(this, x);
    }
    return this;
  }, f.prototype.removeAllListeners = function(g) {
    var y;
    return g ? (y = n ? n + g : g, this._events[y] && c(this, y)) : (this._events = new r(), this._eventsCount = 0), this;
  }, f.prototype.off = f.prototype.removeListener, f.prototype.addListener = f.prototype.on, f.prefixed = n, f.EventEmitter = f, t.exports = f;
})(OL);
var iQ = OL.exports;
function Mp({ children: t, className: e = "", ...n }) {
  return /* @__PURE__ */ E.jsx("svg", { ...n, className: `rs-svg-container ${e}`, children: t });
}
function gi({
  type: t,
  getShapeUtil: e,
  validator: n,
  migrations: r = { currentVersion: 0, firstVersion: 0, migrators: {} }
}) {
  return !n && {}.NODE_ENV === "development" && console.warn(
    `No validator provided for shape type ${t}! Validators are highly recommended for use in production.`
  ), {
    type: t,
    createShapeUtils: (a) => {
      const s = e();
      return new s(a, t);
    },
    is: (a) => a.type === t,
    validator: n,
    migrations: r
  };
}
const wp = 2e3, $x = 40, Au = 320, Rg = [0.1, 0.25, 0.5, 1, 2, 4, 8], Nw = 0.1, kp = 8, oQ = 10, aQ = 1, sQ = 1e3, lQ = 1e3, cQ = 5, uQ = {
  left: { x: -1, y: 0 },
  right: { x: 1, y: 0 },
  up: { x: 0, y: -1 },
  down: { x: 0, y: 1 },
  upLeft: { x: -1, y: -1 },
  upRight: { x: 1, y: -1 },
  downLeft: { x: -1, y: 1 },
  downRight: { x: 1, y: 1 }
}, dQ = 450, fQ = 200, eb = 4, pQ = 32, Mx = {};
for (let t = 1; t <= Math.ceil(kp); t++)
  Mx[t + "_dark"] = `hash_pattern_zoom_${t}_dark`, Mx[t + "_light"] = `hash_pattern_zoom_${t}_light`;
const qO = {
  duration: 0,
  easing: fa.easeInOutCubic
}, ux = 0.09, Pp = 48, Ax = 10, hQ = 10, DL = 300, NL = 320, $I = [
  {
    offsetX: 0,
    offsetY: 2,
    blur: 4,
    spread: 0,
    color: "#00000029"
  },
  {
    offsetX: 0,
    offsetY: 3,
    blur: 6,
    spread: 0,
    color: "#0000001f"
  }
], QO = [
  { min: -1, mid: 0.15, step: 100 },
  { min: 0.05, mid: 0.375, step: 25 },
  { min: 0.15, mid: 1, step: 5 },
  { min: 0.7, mid: 2.5, step: 1 }
], Ki = {
  lineHeight: 1.35,
  fontWeight: "normal",
  fontVariant: "normal",
  fontStyle: "normal",
  padding: "0px",
  maxWidth: "auto"
}, Hg = {
  s: 18,
  m: 24,
  l: 36,
  xl: 44
}, Xd = {
  s: 18,
  m: 22,
  l: 26,
  xl: 32
}, Vd = {
  s: 18,
  m: 20,
  l: 24,
  xl: 28
}, qd = {
  draw: "var(--rs-font-draw)",
  sans: "var(--rs-font-sans)",
  serif: "var(--rs-font-serif)",
  mono: "var(--rs-font-mono)"
}, Lw = {
  color: [
    { id: "black", type: "color", icon: "color" },
    { id: "grey", type: "color", icon: "color" },
    { id: "light-violet", type: "color", icon: "color" },
    { id: "violet", type: "color", icon: "color" },
    { id: "blue", type: "color", icon: "color" },
    { id: "light-blue", type: "color", icon: "color" },
    { id: "yellow", type: "color", icon: "color" },
    { id: "orange", type: "color", icon: "color" },
    { id: "green", type: "color", icon: "color" },
    { id: "light-green", type: "color", icon: "color" },
    { id: "light-red", type: "color", icon: "color" },
    { id: "red", type: "color", icon: "color" }
  ],
  fill: [
    { id: "none", type: "fill", icon: "fill-none" },
    { id: "semi", type: "fill", icon: "fill-semi" },
    { id: "solid", type: "fill", icon: "fill-solid" },
    { id: "pattern", type: "fill", icon: "fill-pattern" }
  ],
  dash: [
    { id: "draw", type: "dash", icon: "dash-draw" },
    { id: "dashed", type: "dash", icon: "dash-dashed" },
    { id: "dotted", type: "dash", icon: "dash-dotted" },
    { id: "solid", type: "dash", icon: "dash-solid" }
  ],
  size: [
    { id: "s", type: "size", icon: "size-small" },
    { id: "m", type: "size", icon: "size-medium" },
    { id: "l", type: "size", icon: "size-large" },
    { id: "xl", type: "size", icon: "size-extra-large" }
  ],
  opacity: [
    { id: "0.1", type: "opacity", icon: "color" },
    { id: "0.25", type: "opacity", icon: "color" },
    { id: "0.5", type: "opacity", icon: "color" },
    { id: "0.75", type: "opacity", icon: "color" },
    { id: "1", type: "opacity", icon: "color" }
  ],
  font: [
    { id: "draw", type: "font", icon: "font-draw" },
    { id: "sans", type: "font", icon: "font-sans" },
    { id: "serif", type: "font", icon: "font-serif" },
    { id: "mono", type: "font", icon: "font-mono" }
  ],
  align: [
    { id: "start", type: "align", icon: "text-align-left" },
    { id: "middle", type: "align", icon: "text-align-center" },
    { id: "end", type: "align", icon: "text-align-right" },
    { id: "justify", type: "align", icon: "text-align-justify" }
  ],
  geo: [
    { id: "rectangle", type: "geo", icon: "geo-rectangle" },
    { id: "ellipse", type: "geo", icon: "geo-ellipse" },
    { id: "triangle", type: "geo", icon: "geo-triangle" },
    { id: "diamond", type: "geo", icon: "geo-diamond" },
    { id: "pentagon", type: "geo", icon: "geo-pentagon" },
    { id: "hexagon", type: "geo", icon: "geo-hexagon" },
    { id: "octagon", type: "geo", icon: "geo-octagon" },
    { id: "star", type: "geo", icon: "geo-star" },
    { id: "rhombus", type: "geo", icon: "geo-rhombus" },
    { id: "rhombus-2", type: "geo", icon: "geo-rhombus-2" },
    { id: "oval", type: "geo", icon: "geo-oval" },
    { id: "trapezoid", type: "geo", icon: "geo-trapezoid" },
    { id: "arrow-right", type: "geo", icon: "geo-arrow-right" },
    { id: "arrow-left", type: "geo", icon: "geo-arrow-left" },
    { id: "arrow-up", type: "geo", icon: "geo-arrow-up" },
    { id: "arrow-down", type: "geo", icon: "geo-arrow-down" },
    { id: "x-box", type: "geo", icon: "geo-x-box" }
  ],
  arrowheadStart: [
    { id: "none", type: "arrowheadStart", icon: "arrowhead-none" },
    { id: "arrow", type: "arrowheadStart", icon: "arrowhead-arrow" },
    { id: "triangle", type: "arrowheadStart", icon: "arrowhead-triangle" },
    { id: "square", type: "arrowheadStart", icon: "arrowhead-square" },
    { id: "dot", type: "arrowheadStart", icon: "arrowhead-dot" },
    { id: "diamond", type: "arrowheadStart", icon: "arrowhead-diamond" },
    { id: "inverted", type: "arrowheadStart", icon: "arrowhead-triangle-inverted" },
    { id: "bar", type: "arrowheadStart", icon: "arrowhead-bar" }
  ],
  arrowheadEnd: [
    { id: "none", type: "arrowheadEnd", icon: "arrowhead-none" },
    { id: "arrow", type: "arrowheadEnd", icon: "arrowhead-arrow" },
    { id: "triangle", type: "arrowheadEnd", icon: "arrowhead-triangle" },
    { id: "square", type: "arrowheadEnd", icon: "arrowhead-square" },
    { id: "dot", type: "arrowheadEnd", icon: "arrowhead-dot" },
    { id: "diamond", type: "arrowheadEnd", icon: "arrowhead-diamond" },
    { id: "inverted", type: "arrowheadEnd", icon: "arrowhead-triangle-inverted" },
    { id: "bar", type: "arrowheadEnd", icon: "arrowhead-bar" }
  ],
  spline: [
    { id: "line", type: "spline", icon: "spline-line" },
    { id: "cubic", type: "spline", icon: "spline-cubic" }
  ]
};
function MI(t, e) {
  const n = It.useRef(e);
  n.current = e;
  const [r, a, s] = It.useMemo(() => {
    let c = null;
    const f = (y) => (c = y, () => {
      c = null;
    }), p = new Sb(
      `useStateTracking(${t})`,
      // this is what `scheduler.execute()` will call
      () => n.current?.(),
      // this is what will be invoked when signia detects a change in an upstream reactive value
      {
        scheduleEffect() {
          c?.();
        }
      }
    );
    return [p, f, () => p.scheduleCount];
  }, [t]);
  return It.useSyncExternalStore(a, s, s), It.useEffect(() => (r.attach(), r.maybeScheduleEffect(), () => {
    r.detach();
  }), [r]), r.execute();
}
var ZO = {
  /**
   * This is a function call trap for functional components. When this is called, we know it means
   * React did run 'Component()', that means we can use any hooks here to setup our effect and
   * store.
   *
   * With the native Proxy, all other calls such as access/setting to/of properties will be
   * forwarded to the target Component, so we don't need to copy the Component's own or inherited
   * properties.
   *
   * @see https://github.com/facebook/react/blob/2d80a0cd690bb5650b6c8a6c079a87b5dc42bd15/packages/react-reconciler/src/ReactFiberHooks.old.js#L460
   */
  apply(t, e, n) {
    return MI(
      t.displayName ?? t.name ?? "tracked(???)",
      () => t.apply(e, n)
    );
  }
}, gQ = Symbol.for("react.memo"), mQ = Symbol.for("react.forward_ref");
function dn(t) {
  let e = null;
  const n = t.$$typeof;
  return n === gQ && (t = t.type, e = t.compare), n === mQ ? k.memo(k.forwardRef(new Proxy(t.render, ZO))) : k.memo(new Proxy(t, ZO), e);
}
function LL(t, e, n) {
  return k.useMemo(() => {
    const r = typeof e == "function" ? e() : e;
    return hi(`useAtom(${t})`, r, n);
  }, []);
}
function un() {
  const t = arguments, e = t.length === 3 ? t[2] : [t[0]], n = t.length === 3 ? t[0] : `useValue(${t[0].name})`, r = k.useRef(!0);
  r.current = !0;
  const a = k.useMemo(() => t.length === 1 ? t[0] : pt(n, () => {
    if (r.current)
      return t[1]();
    try {
      return t[1]();
    } catch {
      return {};
    }
  }), e);
  try {
    const { subscribe: s, getSnapshot: c } = k.useMemo(() => ({
      subscribe: (f) => o1(`useValue(${n})`, () => {
        a.value, f();
      }),
      getSnapshot: () => a.value
    }), [a]);
    return k.useSyncExternalStore(s, c, c);
  } finally {
    r.current = !1;
  }
}
const AI = It.createContext({}), Ge = () => It.useContext(AI);
class um {
  items = /* @__PURE__ */ new WeakMap();
  get(e, n) {
    return this.items.has(e) || this.items.set(e, n(e)), this.items.get(e);
  }
  access(e) {
    return this.items.get(e);
  }
  set(e, n) {
    this.items.set(e, n);
  }
  has(e) {
    return this.items.has(e);
  }
  invalidate(e) {
    this.items.delete(e);
  }
  bust() {
    this.items = /* @__PURE__ */ new WeakMap();
  }
}
var vQ = 200, OI = "__lodash_hash_undefined__", yQ = 1 / 0, bQ = "[object Function]", SQ = "[object GeneratorFunction]", wQ = /[\\^$.*+?()[\]{}|]/g, xQ = /^\[object .+?Constructor\]$/, EQ = typeof da == "object" && da && da.Object === Object && da, CQ = typeof self == "object" && self && self.Object === Object && self, DI = EQ || CQ || Function("return this")();
function _Q(t, e) {
  var n = t ? t.length : 0;
  return !!n && PQ(t, e, 0) > -1;
}
function TQ(t, e, n) {
  for (var r = -1, a = t ? t.length : 0; ++r < a; )
    if (n(e, t[r]))
      return !0;
  return !1;
}
function kQ(t, e, n, r) {
  for (var a = t.length, s = n + (r ? 1 : -1); r ? s-- : ++s < a; )
    if (e(t[s], s, t))
      return s;
  return -1;
}
function PQ(t, e, n) {
  if (e !== e)
    return kQ(t, IQ, n);
  for (var r = n - 1, a = t.length; ++r < a; )
    if (t[r] === e)
      return r;
  return -1;
}
function IQ(t) {
  return t !== t;
}
function RQ(t, e) {
  return t.has(e);
}
function $Q(t, e) {
  return t?.[e];
}
function MQ(t) {
  var e = !1;
  if (t != null && typeof t.toString != "function")
    try {
      e = !!(t + "");
    } catch {
    }
  return e;
}
function jL(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(r) {
    n[++e] = r;
  }), n;
}
var AQ = Array.prototype, OQ = Function.prototype, zL = Object.prototype, ZT = DI["__core-js_shared__"], JO = function() {
  var t = /[^.]+$/.exec(ZT && ZT.keys && ZT.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}(), UL = OQ.toString, NI = zL.hasOwnProperty, DQ = zL.toString, NQ = RegExp(
  "^" + UL.call(NI).replace(wQ, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
), LQ = AQ.splice, jQ = LI(DI, "Map"), JT = LI(DI, "Set"), tb = LI(Object, "create");
function Ap(t) {
  var e = -1, n = t ? t.length : 0;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
function zQ() {
  this.__data__ = tb ? tb(null) : {};
}
function UQ(t) {
  return this.has(t) && delete this.__data__[t];
}
function BQ(t) {
  var e = this.__data__;
  if (tb) {
    var n = e[t];
    return n === OI ? void 0 : n;
  }
  return NI.call(e, t) ? e[t] : void 0;
}
function FQ(t) {
  var e = this.__data__;
  return tb ? e[t] !== void 0 : NI.call(e, t);
}
function HQ(t, e) {
  var n = this.__data__;
  return n[t] = tb && e === void 0 ? OI : e, this;
}
Ap.prototype.clear = zQ;
Ap.prototype.delete = UQ;
Ap.prototype.get = BQ;
Ap.prototype.has = FQ;
Ap.prototype.set = HQ;
function dm(t) {
  var e = -1, n = t ? t.length : 0;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
function VQ() {
  this.__data__ = [];
}
function YQ(t) {
  var e = this.__data__, n = p1(e, t);
  if (n < 0)
    return !1;
  var r = e.length - 1;
  return n == r ? e.pop() : LQ.call(e, n, 1), !0;
}
function KQ(t) {
  var e = this.__data__, n = p1(e, t);
  return n < 0 ? void 0 : e[n][1];
}
function WQ(t) {
  return p1(this.__data__, t) > -1;
}
function GQ(t, e) {
  var n = this.__data__, r = p1(n, t);
  return r < 0 ? n.push([t, e]) : n[r][1] = e, this;
}
dm.prototype.clear = VQ;
dm.prototype.delete = YQ;
dm.prototype.get = KQ;
dm.prototype.has = WQ;
dm.prototype.set = GQ;
function fm(t) {
  var e = -1, n = t ? t.length : 0;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
function XQ() {
  this.__data__ = {
    hash: new Ap(),
    map: new (jQ || dm)(),
    string: new Ap()
  };
}
function qQ(t) {
  return h1(this, t).delete(t);
}
function QQ(t) {
  return h1(this, t).get(t);
}
function ZQ(t) {
  return h1(this, t).has(t);
}
function JQ(t, e) {
  return h1(this, t).set(t, e), this;
}
fm.prototype.clear = XQ;
fm.prototype.delete = qQ;
fm.prototype.get = QQ;
fm.prototype.has = ZQ;
fm.prototype.set = JQ;
function Ox(t) {
  var e = -1, n = t ? t.length : 0;
  for (this.__data__ = new fm(); ++e < n; )
    this.add(t[e]);
}
function eZ(t) {
  return this.__data__.set(t, OI), this;
}
function tZ(t) {
  return this.__data__.has(t);
}
Ox.prototype.add = Ox.prototype.push = eZ;
Ox.prototype.has = tZ;
function p1(t, e) {
  for (var n = t.length; n--; )
    if (cZ(t[n][0], e))
      return n;
  return -1;
}
function nZ(t) {
  if (!BL(t) || aZ(t))
    return !1;
  var e = uZ(t) || MQ(t) ? NQ : xQ;
  return e.test(sZ(t));
}
function rZ(t, e, n) {
  var r = -1, a = _Q, s = t.length, c = !0, f = [], p = f;
  if (n)
    c = !1, a = TQ;
  else if (s >= vQ) {
    var g = e ? null : iZ(t);
    if (g)
      return jL(g);
    c = !1, a = RQ, p = new Ox();
  } else
    p = e ? [] : f;
  e:
    for (; ++r < s; ) {
      var y = t[r], v = e ? e(y) : y;
      if (y = n || y !== 0 ? y : 0, c && v === v) {
        for (var S = p.length; S--; )
          if (p[S] === v)
            continue e;
        e && p.push(v), f.push(y);
      } else
        a(p, v, n) || (p !== f && p.push(v), f.push(y));
    }
  return f;
}
var iZ = JT && 1 / jL(new JT([, -0]))[1] == yQ ? function(t) {
  return new JT(t);
} : dZ;
function h1(t, e) {
  var n = t.__data__;
  return oZ(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
}
function LI(t, e) {
  var n = $Q(t, e);
  return nZ(n) ? n : void 0;
}
function oZ(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function aZ(t) {
  return !!JO && JO in t;
}
function sZ(t) {
  if (t != null) {
    try {
      return UL.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
function lZ(t) {
  return t && t.length ? rZ(t) : [];
}
function cZ(t, e) {
  return t === e || t !== t && e !== e;
}
function uZ(t) {
  var e = BL(t) ? DQ.call(t) : "";
  return e == bQ || e == SQ;
}
function BL(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function");
}
function dZ() {
}
var fZ = lZ;
const pZ = /* @__PURE__ */ jp(fZ), hs = {
  preventDefaultLogging: Bd("tldrawPreventDefaultLogging", !1),
  pointerCaptureLogging: Bd("tldrawPointerCaptureLogging", !1),
  pointerCaptureTracking: Bd("tldrawPointerCaptureTracking", !1),
  pointerCaptureTrackingObject: Bd(
    "tldrawPointerCaptureTrackingObject",
    // ideally we wouldn't store this mutable value in an atom but it's not
    // a big deal for debug values
    /* @__PURE__ */ new Map(),
    !1
  ),
  elementRemovalLogging: Bd("tldrawElementRemovalLogging", !1),
  debugSvg: Bd("tldrawDebugSvg", !1),
  throwToBlob: Bd("tldrawThrowToBlob", !1),
  peopleMenu: Bd("tldrawPeopleMenu", !1)
};
if (typeof Element < "u") {
  const t = Element.prototype.removeChild;
  o1("element removal logging", () => {
    hs.elementRemovalLogging.value ? Element.prototype.removeChild = function(e) {
      return console.warn("[tldraw] removing child:", e), t.call(this, e);
    } : Element.prototype.removeChild = t;
  });
}
function Bd(t, e, n = !0) {
  if (typeof window > "u")
    return hi(`debug:${t}`, e);
  const r = n ? hZ(t) : null, a = hi(`debug:${t}`, r ?? e);
  return n && o1(`debug:${t}`, () => {
    const s = a.value;
    try {
      s === e ? window.sessionStorage.removeItem(`debug:${t}`) : window.sessionStorage.setItem(`debug:${t}`, JSON.stringify(s));
    } catch {
    }
  }), Object.defineProperty(window, t, {
    get() {
      return a.value;
    },
    set(s) {
      a.set(s);
    },
    configurable: !0
  }), a;
}
function hZ(t) {
  try {
    return JSON.parse(window.sessionStorage.getItem(`debug:${t}`) ?? "null");
  } catch {
    return null;
  }
}
function FL(t) {
  const e = t.cloneNode(!0);
  return t.setAttribute("width", +t.getAttribute("width") + ""), t.setAttribute("height", +t.getAttribute("height") + ""), new XMLSerializer().serializeToString(e).replaceAll("&#10;      ", "").replaceAll(/((\s|")[0-9]*\.[0-9]{2})([0-9]*)(\b|"|\))/g, "$1");
}
async function HL(t, e) {
  const { type: n, quality: r, scale: a } = e, s = +t.getAttribute("width"), c = +t.getAttribute("height"), f = await VL(t), p = await new Promise((y) => {
    const v = new Image();
    v.crossOrigin = "anonymous", v.onload = async () => {
      await new Promise((_) => setTimeout(_, 250));
      const S = document.createElement("canvas"), x = S.getContext("2d");
      S.width = s * a, S.height = c * a, x.imageSmoothingEnabled = !0, x.imageSmoothingQuality = "high", x.drawImage(v, 0, 0, s * a, c * a), URL.revokeObjectURL(f), y(S);
    }, v.onerror = () => {
      y(null);
    }, v.src = f;
  });
  return p ? await new Promise(
    (y) => p.toBlob(
      (v) => {
        (!v || hs.throwToBlob.value) && y(null), y(v);
      },
      "image/" + n,
      r
    )
  ) : null;
}
async function VL(t) {
  const e = t.cloneNode(!0);
  e.setAttribute("encoding", 'UTF-8"');
  const n = new FileReader(), r = Array.from(e.querySelectorAll("image"));
  for (const a of r) {
    const s = a.getAttribute("xlink:href");
    if (s && !s.startsWith("data:")) {
      const c = await (await fetch(s)).blob(), f = await new Promise((p, g) => {
        n.onload = () => p(n.result), n.onerror = () => g(n.error), n.readAsDataURL(c);
      });
      a.setAttribute("xlink:href", f);
    }
  }
  return YL(e);
}
function YL(t) {
  const e = new XMLSerializer().serializeToString(t);
  return `data:image/svg+xml;base64,${window.btoa(unescape(encodeURIComponent(e)))}`;
}
function ek(t, e) {
  const n = document.createElement("a");
  n.href = t, n.download = e, n.click();
}
function eD(t, e) {
  let n = 0;
  for (; t[e + n]; )
    n += t[e + n] + 1;
  return n + 1;
}
function gZ(t) {
  return new TextDecoder("ascii").decode(t.slice(0, 3)) === "GIF";
}
function mZ(t) {
  const e = new Uint8Array(t);
  let n, r, a = 0, s = 0;
  if (!gZ(t))
    return !1;
  for (n = e[10] & 128, r = e[10] & 7, a += 6, a += 7, a += n ? 3 * Math.pow(2, r + 1) : 0; s < 2 && a < e.length; )
    switch (e[a]) {
      case 44:
        s += 1, n = e[a + 9] & 128, r = e[a + 9] & 7, a += 10, a += n ? 3 * Math.pow(2, r + 1) : 0, a += eD(e, a + 1) + 1;
        break;
      case 33:
        a += 2, a += eD(e, a);
        break;
      case 59:
        a = e.length;
        break;
      default:
        a = e.length;
        break;
    }
  return s > 1;
}
const jI = ["image/jpeg", "image/png", "image/gif", "image/svg+xml", "image/webp"], KL = ["video/mp4", "video/quicktime", "video/webm"], vZ = jI.concat(KL).join(", "), WL = (t) => jI.includes(t);
async function yZ(t) {
  return await new Promise((e, n) => {
    const r = document.createElement("video");
    r.onloadeddata = () => e({ w: r.videoWidth, h: r.videoHeight }), r.onerror = (a) => {
      console.error(a), n(new Error("Could not get video size"));
    }, r.crossOrigin = "anonymous", r.src = t;
  });
}
async function bZ(t) {
  return await new Promise((e, n) => {
    const r = new Image();
    r.onload = () => e({ w: r.width, h: r.height }), r.onerror = (a) => {
      console.error(a), n(new Error("Could not get image size"));
    }, r.crossOrigin = "anonymous", r.src = t;
  });
}
async function SZ(t, e, n) {
  return await new Promise((r) => {
    const a = new Image();
    a.onload = () => {
      const s = document.createElement("canvas"), c = s.getContext("2d");
      if (!c)
        return;
      s.width = e * 2, s.height = n * 2, c.drawImage(a, 0, 0, s.width, s.height);
      const f = s.toDataURL();
      r(f);
    }, a.crossOrigin = "anonymous", a.src = t;
  });
}
async function wZ(t) {
  return await new Promise((e, n) => {
    const r = new FileReader();
    r.onerror = () => n(r.error), r.onload = async () => {
      let a = r.result;
      const s = WL(t.type), c = s ? bZ : yZ;
      t.type === "video/quicktime" && a.includes("video/quicktime") && (a = a.replace("video/quicktime", "video/mp4"));
      const f = await c(a), p = EZ(f, { w: sQ, h: lQ });
      p !== f && (t.type === "image/jpeg" || t.type === "image/png") && (a = await SZ(a, p.w, p.h));
      const g = cm.createCustomId(i1(a)), y = await xZ(t), v = {
        id: g,
        type: s ? "image" : "video",
        typeName: "asset",
        props: {
          name: t.name,
          src: a,
          w: p.w,
          h: p.h,
          mimeType: t.type,
          isAnimated: y.isAnimated
        }
      };
      e(v);
    }, r.readAsDataURL(t);
  });
}
async function xZ(t) {
  return t.type === "image/gif" ? await new Promise((e, n) => {
    const r = new FileReader();
    r.onerror = () => n(r.error), r.onload = () => {
      e({
        isAnimated: r.result ? mZ(r.result) : !1
      });
    }, r.readAsArrayBuffer(t);
  }) : {
    isAnimated: !WL(t.type)
  };
}
function EZ(t, e) {
  const n = t.w / e.w, r = t.h / e.h;
  return n <= 1 && r <= 1 ? t : n > r ? {
    w: t.w / n,
    h: t.h / n
  } : {
    w: t.w / r,
    h: t.h / r
  };
}
async function g1(t, e, n, r = !1) {
  const a = new O(n.x, n.y), s = /* @__PURE__ */ new Map(), c = await Promise.all(
    e.map(async (x, _) => {
      if (!x.type)
        throw new Error("No mime type");
      if (!jI.concat(KL).includes(x.type))
        return console.warn(`${x.name} not loaded - Extension not allowed.`), null;
      try {
        const T = await t.onCreateAssetFromFile(x);
        if (T.type === "bookmark")
          return;
        if (!T)
          throw Error("Could not create an asset");
        return s.set(x, T), {
          id: io(),
          type: T.type,
          x: a.x + _,
          y: a.y,
          props: {
            w: T.props.w,
            h: T.props.h,
            opacity: "1"
          }
        };
      } catch (T) {
        return console.error(T), null;
      }
    })
  ), f = Gt(c).sort((x, _) => x.x - _.x);
  if (f.length === 0)
    return;
  for (let x = 0; x < f.length; x++) {
    const _ = f[x];
    if (x === 0)
      _.x -= _.props.w / 2, _.y -= _.props.h / 2;
    else {
      const T = f[x - 1];
      _.x = T.x + T.props.w, _.y = T.y;
    }
  }
  const g = (await Promise.all(
    e.map(async (x, _) => {
      const T = f[_];
      if (!T)
        return;
      const I = s.get(x);
      if (!I)
        return;
      let D = t.getAssetById(I.id);
      return D ? (s.delete(x), T.props && (T.props.assetId = D.id), T) : (D = t.getAssetBySrc(I.props.src), D ? (T.props && (T.props.assetId = D.id), T) : (T.props && (T.props.assetId = I.id), T));
    })
  )).filter(GG);
  t.createAssets(Gt([...s.values()])), t.createShapes(g), t.setSelectedIds(g.map((x) => x.id));
  const { selectedIds: y, viewportPageBounds: v } = t, S = ot.Common(Gt(y.map((x) => t.getPageBoundsById(x))));
  S && !v.contains(S) && t.zoomToSelection();
}
function GL(t, e, n, r) {
  t.createShapes(
    [
      {
        id: io(),
        type: "embed",
        x: n.x - (r.width || 450) / 2,
        y: n.y - (r.height || 450) / 2,
        props: {
          w: r.width,
          h: r.height,
          doesResize: r.doesResize,
          url: e,
          opacity: "1"
        }
      }
    ],
    !0
  );
}
async function CZ(t, e, n) {
  const r = cm.createCustomId(i1(e)), a = t.getAssetById(r);
  if (a) {
    t.createShapes([
      {
        id: t.createShapeId(),
        type: "bookmark",
        x: n.x - 150,
        y: n.y - 160,
        props: {
          assetId: a.id,
          url: a.props.src,
          opacity: "1"
        }
      }
    ]);
    return;
  }
  t.batch(async () => {
    const s = io();
    t.createShapes(
      [
        {
          id: s,
          type: "bookmark",
          x: n.x,
          y: n.y,
          props: {
            url: e,
            opacity: "1"
          }
        }
      ],
      !0
    );
    const c = await t.onCreateBookmarkFromUrl(e);
    c && (t.createAssets([
      {
        id: r,
        typeName: "asset",
        type: "bookmark",
        props: {
          src: e,
          description: c.description,
          image: c.image,
          title: c.title
        }
      }
    ]), t.updateShapes([
      {
        id: s,
        type: "bookmark",
        props: {
          assetId: r,
          opacity: "1"
        }
      }
    ]));
  });
}
function _Z(t, e, n) {
  const r = new DOMParser().parseFromString(e, "image/svg+xml").querySelector("svg");
  if (!r)
    throw new Error("No <svg/> element present");
  const a = YL(r);
  let s = parseFloat(r.getAttribute("width") || "0"), c = parseFloat(r.getAttribute("height") || "0");
  if (!(s && c)) {
    document.body.appendChild(r);
    const p = r.getBoundingClientRect();
    document.body.removeChild(r), s = p.width, c = p.height;
  }
  const f = cm.createCustomId(i1(a));
  t.batch(() => {
    t.createAssets([
      {
        id: f,
        typeName: "asset",
        type: "image",
        props: {
          src: a,
          w: s,
          h: c,
          name: "svg",
          isAnimated: !0,
          mimeType: "image/svg+xml"
        }
      }
    ]), t.createShapes(
      [
        {
          id: io(),
          type: "image",
          x: n.x - s / 2,
          y: n.y - c / 2,
          props: {
            assetId: f,
            w: s,
            h: c,
            opacity: "1"
          }
        }
      ],
      !0
    );
  });
}
const TZ = (t) => {
  try {
    const e = new URL(t);
    return e.protocol === "http:" || e.protocol === "https:";
  } catch {
    return !1;
  }
}, kZ = (t) => {
  const e = t.split(/[\n\s]/);
  for (const n of e)
    try {
      const r = new URL(n);
      if (!(r.protocol === "http:" || r.protocol === "https:"))
        return;
    } catch {
      return;
    }
  return pZ(e);
}, PZ = (t) => /^<svg/.test(t);
function IZ(t, e, n) {
  return fetch(t).then(function(r) {
    return r.arrayBuffer();
  }).then(function(r) {
    return new File([r], e, { type: n });
  });
}
function $i() {
  return gI();
}
function RZ(t, e) {
  let n = t;
  const r = new Set(e);
  for (; r.has(n); )
    n = /^.*(\d+)$/.exec(n)?.[1] ? n.replace(/(\d+)(?=\D?)$/, (a) => (+a + 1).toString()) : `${n} 1`;
  return n;
}
function Dx(t) {
  if (t instanceof HTMLElement)
    return t;
  if (t.parentElement)
    return Dx(t.parentElement);
  throw Error("Could not find a parent element of an HTML type!");
}
function Gn(t) {
  t.preventDefault(), hs.preventDefaultLogging.value && console.warn("preventDefault called on event:", t);
}
function xb(t, e) {
  if (t.setPointerCapture(e.pointerId), hs.pointerCaptureTracking.value) {
    const n = hs.pointerCaptureTrackingObject.value;
    n.set(t, (n.get(t) ?? 0) + 1);
  }
  hs.pointerCaptureLogging.value && console.warn("setPointerCapture called on element:", t, e);
}
function Eb(t, e) {
  if (t.hasPointerCapture(e.pointerId)) {
    if (t.releasePointerCapture(e.pointerId), hs.pointerCaptureTracking.value) {
      const n = hs.pointerCaptureTrackingObject.value;
      n.get(t) === 1 ? n.delete(t) : n.has(t) ? n.set(t, n.get(t) - 1) : console.warn("Release without capture");
    }
    hs.pointerCaptureLogging.value && console.warn("releasePointerCapture called on element:", t, e);
  }
}
function zI(t, e) {
  return e.map((r) => {
    const { offsetX: a, offsetY: s, blur: c, spread: f, color: p } = r, g = new O(a, s), { x: y, y: v } = g.rot(-t);
    return `${y}px ${v}px ${c}px ${f}px ${p}`;
  }).join(", ");
}
function XL() {
  const [t, e] = k.useState(!1);
  return k.useEffect(() => {
    const n = window.matchMedia("(prefers-reduced-motion: reduce)"), r = () => {
      e(n.matches);
    };
    return r(), n.addEventListener("change", r), () => n.removeEventListener("change", r);
  }, []), t;
}
const tk = (t, e) => t.length <= e ? t : t.substring(0, e - 3) + "...";
function $Z(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function MZ(t) {
  const e = new URL(t).host.replace("www.", "");
  for (const n of Jg)
    if (qL(n.hostnames, e)) {
      const r = n.fromEmbedUrl(t);
      if (r)
        return {
          definition: n,
          url: r,
          embedUrl: t
        };
    }
}
const AZ = (t) => t.split("*").map((e) => $Z(e)).join(".+"), qL = (t, e) => !!t.find((n) => {
  const r = new RegExp(AZ(n));
  return e.match(r);
});
function OZ(t) {
  const e = new URL(t).host.replace("www.", "");
  for (const n of Jg)
    if (qL(n.hostnames, e)) {
      const r = n.toEmbedUrl(t);
      if (r)
        return {
          definition: n,
          embedUrl: r,
          url: t
        };
    }
}
function QL(t) {
  return OZ(t) ?? MZ(t);
}
function Gd(t) {
  try {
    return QL(t);
  } catch (e) {
    console.error(e);
  }
}
function tD(t, e) {
  let n = null;
  for (const [r, a] of Object.entries(e))
    SL.has(r) && (n || (n = { ...t }), n[r] = a);
  return n ?? t;
}
const us = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", DZ = "a0", ZL = "A00000000000000000000000000";
function JL(t) {
  if (t >= "a" && t <= "z")
    return t.charCodeAt(0) - "a".charCodeAt(0) + 2;
  if (t >= "A" && t <= "Z")
    return "Z".charCodeAt(0) - t.charCodeAt(0) + 2;
  throw new Error("Invalid index key head: " + t);
}
function ej(t) {
  if (t.length !== JL(t.charAt(0)))
    throw new Error("invalid integer part of index key: " + t);
}
function nD(t) {
  if (t === void 0)
    throw Error("n is undefined");
}
function rD(t) {
  ej(t);
  const [e, ...n] = t.split("");
  let r = !0;
  for (let a = n.length - 1; r && a >= 0; a--) {
    const s = us.indexOf(n[a]) + 1;
    s === us.length ? n[a] = "0" : (n[a] = us.charAt(s), r = !1);
  }
  if (r) {
    if (e === "Z")
      return "a0";
    if (e === "z")
      return;
    const a = String.fromCharCode(e.charCodeAt(0) + 1);
    return a > "a" ? n.push("0") : n.pop(), a + n.join("");
  } else
    return e + n.join("");
}
function NZ(t) {
  ej(t);
  const [e, ...n] = t.split("");
  let r = !0;
  for (let a = n.length - 1; r && a >= 0; a--) {
    const s = us.indexOf(n[a]) - 1;
    s === -1 ? n[a] = us.slice(-1) : (n[a] = us.charAt(s), r = !1);
  }
  if (r) {
    if (e === "a")
      return "Z" + us.slice(-1);
    if (e === "A")
      return;
    const a = String.fromCharCode(e.charCodeAt(0) - 1);
    return a < "Z" ? n.push(us.slice(-1)) : n.pop(), a + n.join("");
  } else
    return e + n.join("");
}
function Vg(t, e) {
  if (e !== void 0 && t >= e)
    throw new Error(t + " >= " + e);
  if (t.slice(-1) === "0" || e && e.slice(-1) === "0")
    throw new Error("trailing zero");
  if (e) {
    let a = 0;
    for (; (t.charAt(a) || "0") === e.charAt(a); )
      a++;
    if (a > 0)
      return e.slice(0, a) + Vg(t.slice(a), e.slice(a));
  }
  const n = t ? us.indexOf(t.charAt(0)) : 0, r = e !== void 0 ? us.indexOf(e.charAt(0)) : us.length;
  if (r - n > 1) {
    const a = Math.round(0.5 * (n + r));
    return us.charAt(a);
  } else
    return e && e.length > 1 ? e.slice(0, 1) : us.charAt(n) + Vg(t.slice(1), void 0);
}
function zy(t) {
  const e = JL(t.charAt(0));
  if (e > t.length)
    throw new Error("invalid index: " + t);
  return t.slice(0, e);
}
function iD(t) {
  if (t === ZL)
    throw new Error("invalid index: " + t);
  const e = zy(t);
  if (t.slice(e.length).slice(-1) === "0")
    throw new Error("invalid index: " + t);
}
function $g(t, e) {
  if (t !== void 0 && iD(t), e !== void 0 && iD(e), t !== void 0 && e !== void 0 && t >= e)
    throw new Error(t + " >= " + e);
  if (t === void 0 && e === void 0)
    return DZ;
  if (t === void 0) {
    if (e === void 0)
      throw Error("b is undefined");
    const f = zy(e), p = e.slice(f.length);
    if (f === ZL)
      return f + Vg("", p);
    if (f < e)
      return f;
    const g = NZ(f);
    return nD(g), g;
  }
  if (e === void 0) {
    const f = zy(t), p = t.slice(f.length), g = rD(f);
    return g === void 0 ? f + Vg(p, void 0) : g;
  }
  const n = zy(t), r = t.slice(n.length), a = zy(e), s = e.slice(a.length);
  if (n === a)
    return n + Vg(r, s);
  const c = rD(n);
  return nD(c), c < e ? c : n + Vg(r, void 0);
}
function tf(t, e, n) {
  if (n === 0)
    return [];
  if (n === 1)
    return [$g(t, e)];
  if (e === void 0) {
    let s = $g(t, e);
    const c = [s];
    for (let f = 0; f < n - 1; f++)
      s = $g(s, e), c.push(s);
    return c;
  }
  if (t === void 0) {
    let s = $g(t, e);
    const c = [s];
    for (let f = 0; f < n - 1; f++)
      s = $g(t, s), c.push(s);
    return c.reverse(), c;
  }
  const r = Math.floor(n / 2), a = $g(t, e);
  return [...tf(t, a, r), a, ...tf(a, e, n - r - 1)];
}
function Mg(t, e, n) {
  return tf(t, e, n);
}
function nk(t, e) {
  return tf(t, void 0, e);
}
function Hy(t, e) {
  return tf(t, e, 1)[0];
}
function Mu(t) {
  return tf(t, void 0, 1)[0];
}
function LZ(t) {
  return tf(void 0, t, 1)[0];
}
function tj(t) {
  return ["a1", ...tf("a1", void 0, t)];
}
function Ya(t, e) {
  return t.index < e.index ? -1 : t.index > e.index ? 1 : 0;
}
function jZ(t, e) {
  return t.id < e.id ? -1 : t.id > e.id ? 1 : 0;
}
function nj({ app: t }) {
  const {
    selectionRotation: e,
    selectionPageCenter: n,
    inputs: { originPagePoint: r },
    selectedShapes: a
  } = t;
  return {
    selectionPageCenter: n,
    initialCursorAngle: n.angle(r),
    initialSelectionRotation: e,
    shapeSnapshots: a.map((s) => ({
      shape: Lu(s),
      initialPagePoint: t.getPagePointById(s.id)
    }))
  };
}
function dx({
  delta: t,
  app: e,
  snapshot: n,
  stage: r
}) {
  const { selectionPageCenter: a, shapeSnapshots: s } = n;
  e.updateShapes(
    s.map(({ shape: f, initialPagePoint: p }) => {
      const g = Fs(f.parentId) ? e.getPageTransformById(f.parentId) : De.Identity(), y = O.RotWith(p, a, t), v = De.applyToPoint(
        // use the current parent transform in case it has moved/resized since the start
        // (e.g. if rotating a shape at the edge of a group)
        De.Inverse(g),
        y
      ), S = TI(f.rotation + t);
      return {
        id: f.id,
        type: f.type,
        x: v.x,
        y: v.y,
        rotation: S
      };
    })
  );
  const c = [];
  s.forEach(({ shape: f }) => {
    const p = e.getShapeById(f.id);
    if (!p)
      return;
    const g = e.getShapeUtil(f);
    if (r === "start" || r === "one-off") {
      const v = g.onRotateStart?.(f);
      v && c.push(v);
    }
    const y = g.onRotate?.(f, p);
    if (y && c.push(y), r === "end" || r === "one-off") {
      const v = g.onRotateEnd?.(f, p);
      v && c.push(v);
    }
  }), c.length > 0 && e.updateShapes(c);
}
const zZ = {
  openWindow: (t, e) => window.open(t, e, "noopener noreferrer")
};
function rj(t, e) {
  return t.match(/^\s*$/) ? e : t;
}
function UZ(t) {
  return t.replace(/\s(\s+)/g, (e, n) => {
    let r = " ";
    for (let a = 0; a < n.length; a++)
      r += " ";
    return r;
  });
}
function Yi(t, e) {
  t.isKilled = !0;
  const { top: n, left: r } = e.getBoundingClientRect();
  return {
    point: {
      x: t.clientX - r,
      y: t.clientY - n,
      z: t.pressure
    },
    shiftKey: t.shiftKey,
    altKey: t.altKey,
    ctrlKey: t.metaKey || t.ctrlKey,
    pointerId: t.pointerId,
    button: t.button,
    isPen: t.pointerType === "pen"
  };
}
function Vs(t) {
  return `${ze(t.x)},${ze(t.y)} `;
}
function Ys(t, e) {
  return `${ze((t.x + e.x) / 2)},${ze((t.y + e.y) / 2)} `;
}
function nf(t, e = !0) {
  const n = t.length;
  if (n < 2)
    return "";
  let r = t[0], a = t[1];
  if (n === 2)
    return `M${Vs(r)}L${Vs(a)}`;
  let s = "";
  for (let c = 2, f = n - 1; c < f; c++)
    r = t[c], a = t[c + 1], s += Ys(r, a);
  return e ? `M${Ys(t[0], t[1])}Q${Vs(t[1])}${Ys(
    t[1],
    t[2]
  )}T${s}${Ys(t[n - 1], t[0])}${Ys(t[0], t[1])}Z` : `M${Vs(t[0])}Q${Vs(t[1])}${Ys(t[1], t[2])}${t.length > 3 ? "T" : ""}${s}L${Vs(t[n - 1])}`;
}
function Qd(t, e = !1) {
  const n = t.length;
  if (n < 2)
    return "";
  let r = t[0].point, a = t[1].point;
  if (n === 2)
    return `M${Vs(r)}L${Vs(a)}`;
  let s = "";
  for (let c = 2, f = n - 1; c < f; c++)
    r = t[c].point, a = t[c + 1].point, s += Ys(r, a);
  return e ? `M${Ys(t[0].point, t[1].point)}Q${Vs(t[1].point)}${Ys(
    t[1].point,
    t[2].point
  )}T${s}${Ys(t[n - 1].point, t[0].point)}${Ys(
    t[0].point,
    t[1].point
  )}Z` : `M${Vs(t[0].point)}Q${Vs(t[1].point)}${Ys(
    t[1].point,
    t[2].point
  )}${t.length > 3 ? "T" : ""}${s}L${Vs(t[n - 1].point)}`;
}
function BZ(t, e = "_blank") {
  zZ.openWindow(t, e);
}
function FZ() {
  const t = Ge();
  return k.useMemo(
    function() {
      let r, a;
      function s(_) {
        _.isKilled || _.button !== 0 && _.button !== 1 && _.button !== 5 || (xb(_.currentTarget, _), t.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_down",
          ...Yi(_, t.getContainer())
        }));
      }
      function c(_) {
        _.isKilled || _.clientX === r && _.clientY === a || (r = _.clientX, a = _.clientY, t.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_move",
          ...Yi(_, t.getContainer())
        }));
      }
      function f(_) {
        _.isKilled || _.button !== 0 && _.button !== 1 && _.button !== 5 || (r = _.clientX, a = _.clientY, Eb(_.currentTarget, _), t.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_up",
          ...Yi(_, t.getContainer())
        }));
      }
      function p(_) {
        _.isKilled || t.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_enter",
          ...Yi(_, t.getContainer())
        });
      }
      function g(_) {
        _.isKilled || t.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_leave",
          ...Yi(_, t.getContainer())
        });
      }
      function y(_) {
        _.isKilled = !0, document.body.click(), Gn(_);
      }
      function v(_) {
        _.isKilled = !0, _.target.tagName !== "A" && _.target.tagName !== "TEXTAREA" && Gn(_);
      }
      function S(_) {
        Gn(_);
      }
      async function x(_) {
        if (Gn(_), !_.dataTransfer?.files?.length)
          return;
        const T = Array.from(_.dataTransfer.files).filter(
          (I) => !I.name.endsWith(".tldr")
        );
        await g1(t, T, t.screenToPage(_.clientX, _.clientY), !1);
      }
      return {
        onPointerDown: s,
        onPointerMove: c,
        onPointerUp: f,
        onPointerEnter: p,
        onPointerLeave: g,
        onDragOver: S,
        onDrop: x,
        onTouchStart: y,
        onTouchEnd: v
      };
    },
    [t]
  );
}
function HZ() {
  const t = Ge();
  k.useEffect(() => {
    const e = window.matchMedia("(pointer: coarse)"), n = () => {
      t.isCoarsePointer = e.matches;
    };
    return n(), e.addEventListener("change", n), () => e.removeEventListener("change", n);
  }, [t]);
}
const ij = k.createContext(null);
function VZ({
  container: t,
  children: e
}) {
  return /* @__PURE__ */ E.jsx(ij.Provider, { value: t, children: e });
}
function va() {
  return KG(k.useContext(ij), "useContainer used outside of <Tldraw />");
}
function Ip(t, e, n = Ws) {
  k.useEffect(() => {
    const r = new Sb(t, e);
    return r.attach(), r.execute(), () => {
      r.detach();
    };
  }, n);
}
const rk = "<path d='m19.7432 17.0869-4.072 4.068 2.829 2.828-8.473-.013-.013-8.47 2.841 2.842 4.075-4.068 1.414-1.415-2.844-2.842h8.486v8.484l-2.83-2.827z' fill='%23fff'/><path d='m18.6826 16.7334-4.427 4.424 1.828 1.828-5.056-.016-.014-5.054 1.842 1.841 4.428-4.422 2.474-2.475-1.844-1.843h5.073v5.071l-1.83-1.828z' fill='%23000'/>", ik = "<path d='m9 17.9907v.005l5.997 5.996.001-3.999h1.999 2.02v4l5.98-6.001-5.98-5.999.001 4.019-2.021.002h-2l.001-4.022zm1.411.003 3.587-3.588-.001 2.587h3.5 2.521v-2.585l3.565 3.586-3.564 3.585-.001-2.585h-2.521l-3.499-.001-.001 2.586z' fill='%23fff'/><path d='m17.4971 18.9932h2.521v2.586l3.565-3.586-3.565-3.585v2.605h-2.521-3.5v-2.607l-3.586 3.587 3.586 3.586v-2.587z' fill='%23000'/>", Ry = '<g><path d="M22.4789 9.45728L25.9935 12.9942L22.4789 16.5283V14.1032C18.126 14.1502 14.6071 17.6737 14.5675 22.0283H17.05L13.513 25.543L9.97889 22.0283H12.5674C12.6071 16.5691 17.0214 12.1503 22.4789 12.1031L22.4789 9.45728Z" fill="black"/><path fill-rule="evenodd" clip-rule="evenodd" d="M21.4789 7.03223L27.4035 12.9945L21.4789 18.9521V15.1868C18.4798 15.6549 16.1113 18.0273 15.649 21.0284H19.475L13.5128 26.953L7.55519 21.0284H11.6189C12.1243 15.8155 16.2679 11.6677 21.4789 11.1559L21.4789 7.03223ZM22.4789 12.1031C17.0214 12.1503 12.6071 16.5691 12.5674 22.0284H9.97889L13.513 25.543L17.05 22.0284H14.5675C14.5705 21.6896 14.5947 21.3558 14.6386 21.0284C15.1157 17.4741 17.9266 14.6592 21.4789 14.1761C21.8063 14.1316 22.1401 14.1069 22.4789 14.1032V16.5284L25.9935 12.9942L22.4789 9.45729L22.4789 12.1031Z" fill="white"/></g>', YZ = `<path fill="currentcolor" d='m6.94 2v-1c-1.35866267-.08246172-2.66601117.53165299-3.47 1.63-.80398883-1.09834701-2.11133733-1.71246172-3.47-1.63v1c1.30781678-.16635468 2.55544738.59885876 3 1.84v5.1h-1v1h1v4.16c-.4476345 1.2386337-1.69302129 2.002471-3 1.84v1c1.35687108.0731933 2.6600216-.5389494 3.47-1.63.8099784 1.0910506 2.11312892 1.7031933 3.47 1.63v-1c-1.28590589.133063-2.49760499-.6252793-2.94-1.84v-4.18h1v-1h-1v-5.08c.43943906-1.21710975 1.65323743-1.97676587 2.94-1.84z' transform='translate(14 9)'/>`, KZ = "<path d='m13.5732 12.0361c.48-.178 1.427-.069 1.677.473.213.462.396 1.241.406 1.075.024-.369-.024-1.167.137-1.584.117-.304.347-.59.686-.691.285-.086.62-.116.916-.055.313.064.642.287.765.499.362.623.368 1.899.385 1.831.064-.272.07-1.229.283-1.584.141-.235.497-.445.687-.479.294-.052.656-.068.964-.008.249.049.586.344.677.487.219.344.342 1.316.379 1.658.016.141.074-.393.293-.736.406-.639 1.844-.763 1.898.639.026.654.02.624.02 1.064 0 .516-.012.828-.04 1.202-.03.399-.116 1.304-.241 1.742-.086.301-.371.978-.653 1.384 0 0-1.074 1.25-1.191 1.812-.117.563-.078.567-.102.965-.023.399.121.923.121.923s-.801.104-1.234.034c-.391-.062-.875-.84-1-1.078-.172-.328-.539-.265-.682-.023-.224.383-.709 1.07-1.05 1.113-.669.084-2.055.03-3.14.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.283-.36-1.002-.929-1.243-1.985-.213-.936-.192-1.395.037-1.77.232-.381.67-.589.854-.625.208-.042.692-.039.875.062.223.123.313.159.488.391.23.307.312.456.213.121-.076-.262-.322-.595-.434-.97-.109-.361-.401-.943-.38-1.526.008-.221.103-.771.832-1.042' fill='%23fff'/><g stroke='%23000' stroke-width='.75'><path d='m13.5732 12.0361c.48-.178 1.427-.069 1.677.473.213.462.396 1.241.406 1.075.024-.369-.024-1.167.137-1.584.117-.304.347-.59.686-.691.285-.086.62-.116.916-.055.313.064.642.287.765.499.362.623.368 1.899.385 1.831.064-.272.07-1.229.283-1.584.141-.235.497-.445.687-.479.294-.052.656-.068.964-.008.249.049.586.344.677.487.219.344.342 1.316.379 1.658.016.141.074-.393.293-.736.406-.639 1.844-.763 1.898.639.026.654.02.624.02 1.064 0 .516-.012.828-.04 1.202-.03.399-.116 1.304-.241 1.742-.086.301-.371.978-.653 1.384 0 0-1.074 1.25-1.191 1.812-.117.563-.078.567-.102.965-.023.399.121.923.121.923s-.801.104-1.234.034c-.391-.062-.875-.84-1-1.078-.172-.328-.539-.265-.682-.023-.224.383-.709 1.07-1.05 1.113-.669.084-2.055.03-3.14.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.283-.36-1.002-.929-1.243-1.985-.213-.936-.192-1.395.037-1.77.232-.381.67-.589.854-.625.208-.042.692-.039.875.062.223.123.313.159.488.391.23.307.312.456.213.121-.076-.262-.322-.595-.434-.97-.109-.361-.401-.943-.38-1.526.008-.221.103-.771.832-1.042z' stroke-linejoin='round'/><path d='m20.5664 19.7344v-3.459' stroke-linecap='round'/><path d='m18.5508 19.7461-.016-3.473' stroke-linecap='round'/><path d='m16.5547 16.3047.021 3.426' stroke-linecap='round'/></g>", WZ = '<path d="m13.5557 17.5742c-.098-.375-.196-.847-.406-1.552-.167-.557-.342-.859-.47-1.233-.155-.455-.303-.721-.496-1.181-.139-.329-.364-1.048-.457-1.44-.119-.509.033-.924.244-1.206.253-.339.962-.49 1.357-.351.371.13.744.512.916.788.288.46.357.632.717 1.542.393.992.564 1.918.611 2.231l.085.452c-.001-.04-.043-1.122-.044-1.162-.035-1.029-.06-1.823-.038-2.939.002-.126.064-.587.084-.715.078-.5.305-.8.673-.979.412-.201.926-.215 1.401-.017.423.173.626.55.687 1.022.014.109.094.987.093 1.107-.013 1.025.006 1.641.015 2.174.004.231.003 1.625.017 1.469.061-.656.094-3.189.344-3.942.144-.433.405-.746.794-.929.431-.203 1.113-.07 1.404.243.285.305.446.692.482 1.153.032.405-.019.897-.02 1.245 0 .867-.021 1.324-.037 2.121-.001.038-.015.298.023.182.094-.28.188-.542.266-.745.049-.125.241-.614.359-.859.114-.234.211-.369.415-.688.2-.313.415-.448.668-.561.54-.235 1.109.112 1.301.591.086.215.009.713-.028 1.105-.061.647-.254 1.306-.352 1.648-.128.447-.274 1.235-.34 1.601-.072.394-.234 1.382-.359 1.82-.086.301-.371.978-.652 1.384 0 0-1.074 1.25-1.192 1.812-.117.563-.078.567-.101.965-.024.399.121.923.121.923s-.802.104-1.234.034c-.391-.062-.875-.841-1-1.078-.172-.328-.539-.265-.682-.023-.225.383-.709 1.07-1.051 1.113-.668.084-2.054.03-3.139.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.284-.36-.629-1.093-1.243-1.985-.348-.504-1.027-1.085-1.284-1.579-.223-.425-.331-.954-.19-1.325.225-.594.675-.897 1.362-.832.519.05.848.206 1.238.537.225.19.573.534.75.748.163.195.203.276.377.509.23.307.302.459.214.121" fill="%23fff"/><g stroke="%23000" stroke-linecap="round" stroke-width=".75"><path d="m13.5557 17.5742c-.098-.375-.196-.847-.406-1.552-.167-.557-.342-.859-.47-1.233-.155-.455-.303-.721-.496-1.181-.139-.329-.364-1.048-.457-1.44-.119-.509.033-.924.244-1.206.253-.339.962-.49 1.357-.351.371.13.744.512.916.788.288.46.357.632.717 1.542.393.992.564 1.918.611 2.231l.085.452c-.001-.04-.043-1.122-.044-1.162-.035-1.029-.06-1.823-.038-2.939.002-.126.064-.587.084-.715.078-.5.305-.8.673-.979.412-.201.926-.215 1.401-.017.423.173.626.55.687 1.022.014.109.094.987.093 1.107-.013 1.025.006 1.641.015 2.174.004.231.003 1.625.017 1.469.061-.656.094-3.189.344-3.942.144-.433.405-.746.794-.929.431-.203 1.113-.07 1.404.243.285.305.446.692.482 1.153.032.405-.019.897-.02 1.245 0 .867-.021 1.324-.037 2.121-.001.038-.015.298.023.182.094-.28.188-.542.266-.745.049-.125.241-.614.359-.859.114-.234.211-.369.415-.688.2-.313.415-.448.668-.561.54-.235 1.109.112 1.301.591.086.215.009.713-.028 1.105-.061.647-.254 1.306-.352 1.648-.128.447-.274 1.235-.34 1.601-.072.394-.234 1.382-.359 1.82-.086.301-.371.978-.652 1.384 0 0-1.074 1.25-1.192 1.812-.117.563-.078.567-.101.965-.024.399.121.923.121.923s-.802.104-1.234.034c-.391-.062-.875-.841-1-1.078-.172-.328-.539-.265-.682-.023-.225.383-.709 1.07-1.051 1.113-.668.084-2.054.03-3.139.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.284-.36-.629-1.093-1.243-1.985-.348-.504-1.027-1.085-1.284-1.579-.223-.425-.331-.954-.19-1.325.225-.594.675-.897 1.362-.832.519.05.848.206 1.238.537.225.19.573.534.75.748.163.195.203.276.377.509.23.307.302.459.214.121" stroke-linejoin="round"/><path d="m20.5664 21.7344v-3.459"/><path d="m18.5508 21.7461-.016-3.473"/><path d="m16.5547 18.3047.021 3.426"/></g>';
function Fa(t, e, n, r, a) {
  const s = (-n - e) * (Kr / 180), c = Math.sin(s), f = Math.cos(s), p = 1 * f - 1 * c, g = 1 * c + 1 * f;
  return `url("data:image/svg+xml,<svg height='32' width='32' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' style='color: ${a};'><defs><filter id='shadow' color-interpolation-filters='sRGB'><feDropShadow dx='${p}' dy='${g}' stdDeviation='1.2' flood-opacity='.5'/></filter></defs><g fill='none' transform='rotate(${e + n} 16 16)${r ? " scale(-1,-1) translate(0, -32)" : ""}' filter='url(%23shadow)'>` + t.replaceAll('"', "'") + '</g></svg>") 16 16, pointer';
}
const GZ = {
  none: () => "none",
  default: () => "default",
  pointer: () => "pointer",
  cross: () => "crosshair",
  move: () => "move",
  grab: (t, e, n) => Fa(WZ, t, 0, e, n),
  grabbing: (t, e, n) => Fa(KZ, t, 0, e, n),
  text: (t, e, n) => Fa(YZ, t, 0, e, n),
  "resize-edge": (t, e, n) => Fa(ik, t, 0, e, n),
  "resize-corner": (t, e, n) => Fa(rk, t, 0, e, n),
  "ew-resize": (t, e, n) => Fa(ik, t, 0, e, n),
  "ns-resize": (t, e, n) => Fa(ik, t, 90, e, n),
  "nesw-resize": (t, e, n) => Fa(rk, t, 0, e, n),
  "nwse-resize": (t, e, n) => Fa(rk, t, 90, e, n),
  rotate: (t, e, n) => Fa(Ry, t, 45, e, n),
  "nwse-rotate": (t, e, n) => Fa(Ry, t, 0, e, n),
  "nesw-rotate": (t, e, n) => Fa(Ry, t, 90, e, n),
  "senw-rotate": (t, e, n) => Fa(Ry, t, 180, e, n),
  "swne-rotate": (t, e, n) => Fa(Ry, t, 270, e, n)
};
function cs(t, e = 0, n = "black") {
  return GZ[t](RL(e), !1, n);
}
function XZ() {
  const t = Ge(), e = va();
  Ip(
    "useCursor",
    () => {
      const { type: n, rotation: r, color: a } = t.cursor;
      e.style.setProperty("--rs-cursor", cs(n, r, a));
    },
    [t, e]
  );
}
function qZ() {
  const t = Ge(), e = va(), n = un("isDarkMode", () => t.userDocumentSettings.isDarkMode, [t]);
  It.useEffect(() => {
    n ? (e.setAttribute("data-color-mode", "dark"), e.classList.remove("rs-theme__light"), e.classList.add("rs-theme__dark"), t.setCursor({
      color: "white"
    })) : (e.setAttribute("data-color-mode", "light"), e.classList.remove("rs-theme__dark"), e.classList.add("rs-theme__light"), t.setCursor({
      color: "black"
    }));
  }, [t, e, n]);
}
function QZ() {
  const t = Ge(), e = va();
  k.useEffect(() => {
    const n = (p) => {
      if (p.altKey && !t.root.path.value.endsWith(".idle") && !$y() && p.preventDefault(), p.isKilled)
        return;
      switch (p.isKilled = !0, p.key) {
        case "=": {
          if (p.metaKey || p.ctrlKey) {
            Gn(p);
            return;
          }
          break;
        }
        case "-": {
          if (p.metaKey || p.ctrlKey) {
            Gn(p);
            return;
          }
          break;
        }
        case "0": {
          if (p.metaKey || p.ctrlKey) {
            Gn(p);
            return;
          }
          break;
        }
        case "Tab": {
          if ($y() || t.isMenuOpen)
            return;
          break;
        }
        case ",": {
          if (!$y() && (Gn(p), !t.inputs.keys.has(","))) {
            const { x: y, y: v, z: S } = t.inputs.currentScreenPoint, {
              pageState: { hoveredId: x }
            } = t;
            t.inputs.keys.add(",");
            const _ = {
              type: "pointer",
              name: "pointer_down",
              point: { x: y, y: v, z: S },
              shiftKey: p.shiftKey,
              altKey: p.altKey,
              ctrlKey: p.metaKey || p.ctrlKey,
              pointerId: 0,
              button: 0,
              isPen: t.isPenMode,
              ...x ? {
                target: "shape",
                shape: t.getShapeById(x)
              } : {
                target: "canvas"
              }
            };
            t.dispatch(_);
            return;
          }
          break;
        }
        case "Escape": {
          t.inputs.keys.has("Escape") || (t.inputs.keys.add("Escape"), t.cancel());
          return;
        }
        default:
          if ($y() || t.isMenuOpen)
            return;
      }
      const g = {
        type: "keyboard",
        name: "key_down",
        key: p.key,
        shiftKey: p.shiftKey,
        altKey: p.altKey,
        ctrlKey: p.metaKey || p.ctrlKey
      };
      t.dispatch(g);
    }, r = (p) => {
      if (p.isKilled || (p.isKilled = !0, $y() || t.isMenuOpen))
        return;
      if (p.key === "," && (document.activeElement?.ELEMENT_NODE && Gn(p), t.inputs.keys.has(","))) {
        const { x: y, y: v, z: S } = t.inputs.currentScreenPoint, {
          pageState: { hoveredId: x }
        } = t;
        t.inputs.keys.delete(",");
        const _ = {
          type: "pointer",
          name: "pointer_up",
          point: { x: y, y: v, z: S },
          shiftKey: p.shiftKey,
          altKey: p.altKey,
          ctrlKey: p.metaKey || p.ctrlKey,
          pointerId: 0,
          button: 0,
          isPen: t.isPenMode,
          ...x ? {
            target: "shape",
            shape: t.getShapeById(x)
          } : {
            target: "canvas"
          }
        };
        t.dispatch(_);
        return;
      }
      const g = {
        type: "keyboard",
        name: "key_up",
        key: p.key,
        shiftKey: p.shiftKey,
        altKey: p.altKey,
        ctrlKey: p.metaKey || p.ctrlKey
      };
      t.dispatch(g);
    };
    function a(p) {
      if (e.contains(p.target)) {
        const g = p.touches[0].pageX, y = p.touches[0].radiusX || 0;
        (g - y < 10 || g + y > t.viewportScreenBounds.width - 10) && (p.target?.tagName === "BUTTON" && p.target?.click(), Gn(p));
      }
    }
    const s = (p) => {
      e.contains(p.target) && (p.ctrlKey || p.metaKey) && Gn(p);
    };
    function c() {
      t.blur();
    }
    function f() {
      t.updateViewportScreenBounds();
    }
    return e.addEventListener("touchstart", a, { passive: !1 }), e.addEventListener("wheel", s, { passive: !1 }), e.addEventListener("gesturestart", Gn), e.addEventListener("gesturechange", Gn), e.addEventListener("gestureend", Gn), e.addEventListener("keydown", n), e.addEventListener("keyup", r), e.addEventListener("blur", c), e.addEventListener("focus", f), () => {
      e.removeEventListener("touchstart", a), e.removeEventListener("wheel", s), e.removeEventListener("gesturestart", Gn), e.removeEventListener("gesturechange", Gn), e.removeEventListener("gestureend", Gn), e.removeEventListener("keydown", n), e.removeEventListener("keyup", r), e.removeEventListener("blur", c), e.removeEventListener("focus", c);
    };
  }, [t, e]);
}
const ZZ = ["input", "select", "button", "textarea"];
function $y() {
  const { activeElement: t } = document;
  return !!(t && (t.getAttribute("contenteditble") || ZZ.indexOf(t.tagName.toLowerCase()) > -1));
}
function JZ(t) {
  const e = k.useRef();
  return k.useLayoutEffect(() => {
    e.current = t;
  }), k.useDebugValue(t), k.useCallback((...n) => {
    const r = e.current;
    return oL(r, "fn does not exist"), r(...n);
  }, []);
}
const eJ = ["textarea", "input"];
function tJ(t) {
  const e = Ge();
  k.useEffect(() => {
    const n = t.current;
    if (!n)
      return;
    const r = (a) => {
      if (a instanceof PointerEvent && a.pointerType === "pen") {
        a.isKilled = !0;
        const { target: s } = a;
        if (eJ.includes(s.tagName?.toLocaleLowerCase()) || e.isIn("select.editing_shape"))
          return;
        Gn(a);
      }
    };
    return n.addEventListener("touchstart", r), n.addEventListener("touchend", r), () => {
      n.removeEventListener("touchstart", r), n.addEventListener("touchend", r);
    };
  }, [e, t]);
}
function nJ() {
  const [t, e] = k.useState(0);
  k.useEffect(() => e((n) => n + 1), []);
}
function rJ(t, e, n) {
  return Math.max(e, Math.min(t, n));
}
const _o = {
  toVector(t, e) {
    return t === void 0 && (t = e), Array.isArray(t) ? t : [t, t];
  },
  add(t, e) {
    return [t[0] + e[0], t[1] + e[1]];
  },
  sub(t, e) {
    return [t[0] - e[0], t[1] - e[1]];
  },
  addTo(t, e) {
    t[0] += e[0], t[1] += e[1];
  },
  subTo(t, e) {
    t[0] -= e[0], t[1] -= e[1];
  }
};
function oD(t, e, n) {
  return e === 0 || Math.abs(e) === 1 / 0 ? Math.pow(t, n * 5) : t * e * n / (e + n * t);
}
function aD(t, e, n, r = 0.15) {
  return r === 0 ? rJ(t, e, n) : t < e ? -oD(e - t, n - e, r) + e : t > n ? +oD(t - n, n - e, r) + n : t;
}
function iJ(t, [e, n], [r, a]) {
  const [[s, c], [f, p]] = t;
  return [aD(e, s, c, r), aD(n, f, p, a)];
}
function oJ(t, e) {
  if (typeof t != "object" || t === null)
    return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (typeof r != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function aJ(t) {
  var e = oJ(t, "string");
  return typeof e == "symbol" ? e : String(e);
}
function Yo(t, e, n) {
  return e = aJ(e), e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function sD(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(t, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ei(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? sD(Object(n), !0).forEach(function(r) {
      Yo(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : sD(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
const oj = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function lD(t) {
  return t ? t[0].toUpperCase() + t.slice(1) : "";
}
const sJ = ["enter", "leave"];
function lJ(t = !1, e) {
  return t && !sJ.includes(e);
}
function cJ(t, e = "", n = !1) {
  const r = oj[t], a = r && r[e] || e;
  return "on" + lD(t) + lD(a) + (lJ(n, a) ? "Capture" : "");
}
const uJ = ["gotpointercapture", "lostpointercapture"];
function dJ(t) {
  let e = t.substring(2).toLowerCase();
  const n = !!~e.indexOf("passive");
  n && (e = e.replace("passive", ""));
  const r = uJ.includes(e) ? "capturecapture" : "capture", a = !!~e.indexOf(r);
  return a && (e = e.replace("capture", "")), {
    device: e,
    capture: a,
    passive: n
  };
}
function fJ(t, e = "") {
  const n = oj[t], r = n && n[e] || e;
  return t + r;
}
function aj(t) {
  return "touches" in t;
}
function pJ(t) {
  return aj(t) ? "touch" : "pointerType" in t ? t.pointerType : "mouse";
}
function hJ(t) {
  return Array.from(t.touches).filter((e) => {
    var n, r;
    return e.target === t.currentTarget || ((n = t.currentTarget) === null || n === void 0 || (r = n.contains) === null || r === void 0 ? void 0 : r.call(n, e.target));
  });
}
function cP(t, e) {
  try {
    const n = e.clientX - t.clientX, r = e.clientY - t.clientY, a = (e.clientX + t.clientX) / 2, s = (e.clientY + t.clientY) / 2, c = Math.hypot(n, r);
    return {
      angle: -(Math.atan2(n, r) * 180) / Math.PI,
      distance: c,
      origin: [a, s]
    };
  } catch {
  }
  return null;
}
function gJ(t) {
  return hJ(t).map((e) => e.identifier);
}
function cD(t, e) {
  const [n, r] = Array.from(t.touches).filter((a) => e.includes(a.identifier));
  return cP(n, r);
}
const uD = 40, dD = 800;
function sj(t) {
  let {
    deltaX: e,
    deltaY: n,
    deltaMode: r
  } = t;
  return r === 1 ? (e *= uD, n *= uD) : r === 2 && (e *= dD, n *= dD), [e, n];
}
function mJ(t) {
  const e = {};
  if ("buttons" in t && (e.buttons = t.buttons), "shiftKey" in t) {
    const {
      shiftKey: n,
      altKey: r,
      metaKey: a,
      ctrlKey: s
    } = t;
    Object.assign(e, {
      shiftKey: n,
      altKey: r,
      metaKey: a,
      ctrlKey: s
    });
  }
  return e;
}
function Nx(t, ...e) {
  return typeof t == "function" ? t(...e) : t;
}
function vJ() {
}
function yJ(...t) {
  return t.length === 0 ? vJ : t.length === 1 ? t[0] : function() {
    let e;
    for (const n of t)
      e = n.apply(this, arguments) || e;
    return e;
  };
}
function fD(t, e) {
  return Object.assign({}, e, t || {});
}
const bJ = 32;
class lj {
  constructor(e, n, r) {
    this.ctrl = e, this.args = n, this.key = r, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset());
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(e) {
    this.ctrl.state[this.key] = e;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state: e,
      shared: n,
      ingKey: r,
      args: a
    } = this;
    n[r] = e._active = e.active = e._blocked = e._force = !1, e._step = [!1, !1], e.intentional = !1, e._movement = [0, 0], e._distance = [0, 0], e._direction = [0, 0], e._delta = [0, 0], e._bounds = [[-1 / 0, 1 / 0], [-1 / 0, 1 / 0]], e.args = a, e.axis = void 0, e.memo = void 0, e.elapsedTime = e.timeDelta = 0, e.direction = [0, 0], e.distance = [0, 0], e.overflow = [0, 0], e._movementBound = [!1, !1], e.velocity = [0, 0], e.movement = [0, 0], e.delta = [0, 0], e.timeStamp = 0;
  }
  start(e) {
    const n = this.state, r = this.config;
    n._active || (this.reset(), this.computeInitial(), n._active = !0, n.target = e.target, n.currentTarget = e.currentTarget, n.lastOffset = r.from ? Nx(r.from, n) : n.offset, n.offset = n.lastOffset, n.startTime = n.timeStamp = e.timeStamp);
  }
  computeValues(e) {
    const n = this.state;
    n._values = e, n.values = this.config.transform(e);
  }
  computeInitial() {
    const e = this.state;
    e._initial = e._values, e.initial = e.values;
  }
  compute(e) {
    const {
      state: n,
      config: r,
      shared: a
    } = this;
    n.args = this.args;
    let s = 0;
    if (e && (n.event = e, r.preventDefault && e.cancelable && n.event.preventDefault(), n.type = e.type, a.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, a.locked = !!document.pointerLockElement, Object.assign(a, mJ(e)), a.down = a.pressed = a.buttons % 2 === 1 || a.touches > 0, s = e.timeStamp - n.timeStamp, n.timeStamp = e.timeStamp, n.elapsedTime = n.timeStamp - n.startTime), n._active) {
      const F = n._delta.map(Math.abs);
      _o.addTo(n._distance, F);
    }
    this.axisIntent && this.axisIntent(e);
    const [c, f] = n._movement, [p, g] = r.threshold, {
      _step: y,
      values: v
    } = n;
    if (r.hasCustomTransform ? (y[0] === !1 && (y[0] = Math.abs(c) >= p && v[0]), y[1] === !1 && (y[1] = Math.abs(f) >= g && v[1])) : (y[0] === !1 && (y[0] = Math.abs(c) >= p && Math.sign(c) * p), y[1] === !1 && (y[1] = Math.abs(f) >= g && Math.sign(f) * g)), n.intentional = y[0] !== !1 || y[1] !== !1, !n.intentional)
      return;
    const S = [0, 0];
    if (r.hasCustomTransform) {
      const [F, K] = v;
      S[0] = y[0] !== !1 ? F - y[0] : 0, S[1] = y[1] !== !1 ? K - y[1] : 0;
    } else
      S[0] = y[0] !== !1 ? c - y[0] : 0, S[1] = y[1] !== !1 ? f - y[1] : 0;
    this.restrictToAxis && !n._blocked && this.restrictToAxis(S);
    const x = n.offset, _ = n._active && !n._blocked || n.active;
    _ && (n.first = n._active && !n.active, n.last = !n._active && n.active, n.active = a[this.ingKey] = n._active, e && (n.first && ("bounds" in r && (n._bounds = Nx(r.bounds, n)), this.setup && this.setup()), n.movement = S, this.computeOffset()));
    const [T, I] = n.offset, [[D, N], [j, L]] = n._bounds;
    n.overflow = [T < D ? -1 : T > N ? 1 : 0, I < j ? -1 : I > L ? 1 : 0], n._movementBound[0] = n.overflow[0] ? n._movementBound[0] === !1 ? n._movement[0] : n._movementBound[0] : !1, n._movementBound[1] = n.overflow[1] ? n._movementBound[1] === !1 ? n._movement[1] : n._movementBound[1] : !1;
    const z = n._active ? r.rubberband || [0, 0] : [0, 0];
    if (n.offset = iJ(n._bounds, n.offset, z), n.delta = _o.sub(n.offset, x), this.computeMovement(), _ && (!n.last || s > bJ)) {
      n.delta = _o.sub(n.offset, x);
      const F = n.delta.map(Math.abs);
      _o.addTo(n.distance, F), n.direction = n.delta.map(Math.sign), n._direction = n._delta.map(Math.sign), !n.first && s > 0 && (n.velocity = [F[0] / s, F[1] / s], n.timeDelta = s);
    }
  }
  emit() {
    const e = this.state, n = this.shared, r = this.config;
    if (e._active || this.clean(), (e._blocked || !e.intentional) && !e._force && !r.triggerAllEvents)
      return;
    const a = this.handler(ei(ei(ei({}, n), e), {}, {
      [this.aliasKey]: e.values
    }));
    a !== void 0 && (e.memo = a);
  }
  clean() {
    this.eventStore.clean(), this.timeoutStore.clean();
  }
}
function SJ([t, e], n) {
  const r = Math.abs(t), a = Math.abs(e);
  if (r > a && r > n)
    return "x";
  if (a > r && a > n)
    return "y";
}
class wJ extends lj {
  constructor(...e) {
    super(...e), Yo(this, "aliasKey", "xy");
  }
  reset() {
    super.reset(), this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0], this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = _o.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = _o.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(e) {
    const n = this.state, r = this.config;
    if (!n.axis && e) {
      const a = typeof r.axisThreshold == "object" ? r.axisThreshold[pJ(e)] : r.axisThreshold;
      n.axis = SJ(n._movement, a);
    }
    n._blocked = (r.lockDirection || !!r.axis) && !n.axis || !!r.axis && r.axis !== n.axis;
  }
  restrictToAxis(e) {
    if (this.config.axis || this.config.lockDirection)
      switch (this.state.axis) {
        case "x":
          e[1] = 0;
          break;
        case "y":
          e[0] = 0;
          break;
      }
  }
}
const pD = (t) => t, hD = 0.15, UI = {
  enabled(t = !0) {
    return t;
  },
  eventOptions(t, e, n) {
    return ei(ei({}, n.shared.eventOptions), t);
  },
  preventDefault(t = !1) {
    return t;
  },
  triggerAllEvents(t = !1) {
    return t;
  },
  rubberband(t = 0) {
    switch (t) {
      case !0:
        return [hD, hD];
      case !1:
        return [0, 0];
      default:
        return _o.toVector(t);
    }
  },
  from(t) {
    if (typeof t == "function")
      return t;
    if (t != null)
      return _o.toVector(t);
  },
  transform(t, e, n) {
    const r = t || n.shared.transform;
    if (this.hasCustomTransform = !!r, {}.NODE_ENV === "development") {
      const a = r || pD;
      return (s) => {
        const c = a(s);
        return (!isFinite(c[0]) || !isFinite(c[1])) && console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${c[0]},${[1]}]`), c;
      };
    }
    return r || pD;
  },
  threshold(t) {
    return _o.toVector(t, 0);
  }
};
({}).NODE_ENV === "development" && Object.assign(UI, {
  domTarget(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
    return NaN;
  },
  lockDirection(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `lockDirection` option has been merged with `axis`. Use it as in `{ axis: 'lock' }`");
    return NaN;
  },
  initial(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `initial` option has been renamed to `from`.");
    return NaN;
  }
});
const xJ = 0, Cb = ei(ei({}, UI), {}, {
  axis(t, e, {
    axis: n
  }) {
    if (this.lockDirection = n === "lock", !this.lockDirection)
      return n;
  },
  axisThreshold(t = xJ) {
    return t;
  },
  bounds(t = {}) {
    if (typeof t == "function")
      return (s) => Cb.bounds(t(s));
    if ("current" in t)
      return () => t.current;
    if (typeof HTMLElement == "function" && t instanceof HTMLElement)
      return t;
    const {
      left: e = -1 / 0,
      right: n = 1 / 0,
      top: r = -1 / 0,
      bottom: a = 1 / 0
    } = t;
    return [[e, n], [r, a]];
  }
}), _b = typeof window < "u" && window.document && window.document.createElement;
function EJ() {
  return _b && "ontouchstart" in window;
}
function gD() {
  return EJ() || _b && window.navigator.maxTouchPoints > 1;
}
function CJ() {
  return _b && "onpointerdown" in window;
}
function _J() {
  return _b && "exitPointerLock" in window.document;
}
function TJ() {
  try {
    return "constructor" in GestureEvent;
  } catch {
    return !1;
  }
}
const Ks = {
  isBrowser: _b,
  gesture: TJ(),
  touch: gD(),
  touchscreen: gD(),
  pointer: CJ(),
  pointerLock: _J()
}, kJ = 250, PJ = 180, IJ = 0.5, RJ = 50, $J = 250, MJ = 10, mD = {
  mouse: 0,
  touch: 0,
  pen: 8
}, AJ = ei(ei({}, Cb), {}, {
  device(t, e, {
    pointer: {
      touch: n = !1,
      lock: r = !1,
      mouse: a = !1
    } = {}
  }) {
    return this.pointerLock = r && Ks.pointerLock, Ks.touch && n ? "touch" : this.pointerLock ? "mouse" : Ks.pointer && !a ? "pointer" : Ks.touch ? "touch" : "mouse";
  },
  preventScrollAxis(t, e, {
    preventScroll: n
  }) {
    if (this.preventScrollDelay = typeof n == "number" ? n : n || n === void 0 && t ? kJ : void 0, !(!Ks.touchscreen || n === !1))
      return t || (n !== void 0 ? "y" : void 0);
  },
  pointerCapture(t, e, {
    pointer: {
      capture: n = !0,
      buttons: r = 1,
      keys: a = !0
    } = {}
  }) {
    return this.pointerButtons = r, this.keys = a, !this.pointerLock && this.device === "pointer" && n;
  },
  threshold(t, e, {
    filterTaps: n = !1,
    tapsThreshold: r = 3,
    axis: a = void 0
  }) {
    const s = _o.toVector(t, n ? r : a ? 1 : 0);
    return this.filterTaps = n, this.tapsThreshold = r, s;
  },
  swipe({
    velocity: t = IJ,
    distance: e = RJ,
    duration: n = $J
  } = {}) {
    return {
      velocity: this.transform(_o.toVector(t)),
      distance: this.transform(_o.toVector(e)),
      duration: n
    };
  },
  delay(t = 0) {
    switch (t) {
      case !0:
        return PJ;
      case !1:
        return 0;
      default:
        return t;
    }
  },
  axisThreshold(t) {
    return t ? ei(ei({}, mD), t) : mD;
  },
  keyboardDisplacement(t = MJ) {
    return t;
  }
});
({}).NODE_ENV === "development" && Object.assign(AJ, {
  useTouch(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `useTouch` option has been renamed to `pointer.touch`. Use it as in `{ pointer: { touch: true } }`.");
    return NaN;
  },
  experimental_preventWindowScrollY(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `experimental_preventWindowScrollY` option has been renamed to `preventScroll`.");
    return NaN;
  },
  swipeVelocity(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeVelocity` option has been renamed to `swipe.velocity`. Use it as in `{ swipe: { velocity: 0.5 } }`.");
    return NaN;
  },
  swipeDistance(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeDistance` option has been renamed to `swipe.distance`. Use it as in `{ swipe: { distance: 50 } }`.");
    return NaN;
  },
  swipeDuration(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeDuration` option has been renamed to `swipe.duration`. Use it as in `{ swipe: { duration: 250 } }`.");
    return NaN;
  }
});
function cj(t) {
  const [e, n] = t.overflow, [r, a] = t._delta, [s, c] = t._direction;
  (e < 0 && r > 0 && s < 0 || e > 0 && r < 0 && s > 0) && (t._movement[0] = t._movementBound[0]), (n < 0 && a > 0 && c < 0 || n > 0 && a < 0 && c > 0) && (t._movement[1] = t._movementBound[1]);
}
const OJ = 30, DJ = 100;
class NJ extends lj {
  constructor(...e) {
    super(...e), Yo(this, "ingKey", "pinching"), Yo(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0], this.state.lastOffset = [1, 0], this.state._pointerEvents = /* @__PURE__ */ new Map();
  }
  reset() {
    super.reset();
    const e = this.state;
    e._touchIds = [], e.canceled = !1, e.cancel = this.cancel.bind(this), e.turns = 0;
  }
  computeOffset() {
    const {
      type: e,
      movement: n,
      lastOffset: r
    } = this.state;
    e === "wheel" ? this.state.offset = _o.add(n, r) : this.state.offset = [(1 + n[0]) * r[0], n[1] + r[1]];
  }
  computeMovement() {
    const {
      offset: e,
      lastOffset: n
    } = this.state;
    this.state.movement = [e[0] / n[0], e[1] - n[1]];
  }
  axisIntent() {
    const e = this.state, [n, r] = e._movement;
    if (!e.axis) {
      const a = Math.abs(n) * OJ - Math.abs(r);
      a < 0 ? e.axis = "angle" : a > 0 && (e.axis = "scale");
    }
  }
  restrictToAxis(e) {
    this.config.lockDirection && (this.state.axis === "scale" ? e[1] = 0 : this.state.axis === "angle" && (e[0] = 0));
  }
  cancel() {
    const e = this.state;
    e.canceled || setTimeout(() => {
      e.canceled = !0, e._active = !1, this.compute(), this.emit();
    }, 0);
  }
  touchStart(e) {
    this.ctrl.setEventIds(e);
    const n = this.state, r = this.ctrl.touchIds;
    if (n._active && n._touchIds.every((s) => r.has(s)) || r.size < 2)
      return;
    this.start(e), n._touchIds = Array.from(r).slice(0, 2);
    const a = cD(e, n._touchIds);
    a && this.pinchStart(e, a);
  }
  pointerStart(e) {
    if (e.buttons != null && e.buttons % 2 !== 1)
      return;
    this.ctrl.setEventIds(e), e.target.setPointerCapture(e.pointerId);
    const n = this.state, r = n._pointerEvents, a = this.ctrl.pointerIds;
    if (n._active && Array.from(r.keys()).every((c) => a.has(c)) || (r.size < 2 && r.set(e.pointerId, e), n._pointerEvents.size < 2))
      return;
    this.start(e);
    const s = cP(...Array.from(r.values()));
    s && this.pinchStart(e, s);
  }
  pinchStart(e, n) {
    const r = this.state;
    r.origin = n.origin, this.computeValues([n.distance, n.angle]), this.computeInitial(), this.compute(e), this.emit();
  }
  touchMove(e) {
    if (!this.state._active)
      return;
    const n = cD(e, this.state._touchIds);
    n && this.pinchMove(e, n);
  }
  pointerMove(e) {
    const n = this.state._pointerEvents;
    if (n.has(e.pointerId) && n.set(e.pointerId, e), !this.state._active)
      return;
    const r = cP(...Array.from(n.values()));
    r && this.pinchMove(e, r);
  }
  pinchMove(e, n) {
    const r = this.state, a = r._values[1], s = n.angle - a;
    let c = 0;
    Math.abs(s) > 270 && (c += Math.sign(s)), this.computeValues([n.distance, n.angle - 360 * c]), r.origin = n.origin, r.turns = c, r._movement = [r._values[0] / r._initial[0] - 1, r._values[1] - r._initial[1]], this.compute(e), this.emit();
  }
  touchEnd(e) {
    this.ctrl.setEventIds(e), this.state._active && this.state._touchIds.some((n) => !this.ctrl.touchIds.has(n)) && (this.state._active = !1, this.compute(e), this.emit());
  }
  pointerEnd(e) {
    const n = this.state;
    this.ctrl.setEventIds(e);
    try {
      e.target.releasePointerCapture(e.pointerId);
    } catch {
    }
    n._pointerEvents.has(e.pointerId) && n._pointerEvents.delete(e.pointerId), n._active && n._pointerEvents.size < 2 && (n._active = !1, this.compute(e), this.emit());
  }
  gestureStart(e) {
    e.cancelable && e.preventDefault();
    const n = this.state;
    n._active || (this.start(e), this.computeValues([e.scale, e.rotation]), n.origin = [e.clientX, e.clientY], this.compute(e), this.emit());
  }
  gestureMove(e) {
    if (e.cancelable && e.preventDefault(), !this.state._active)
      return;
    const n = this.state;
    this.computeValues([e.scale, e.rotation]), n.origin = [e.clientX, e.clientY];
    const r = n._movement;
    n._movement = [e.scale - 1, e.rotation], n._delta = _o.sub(n._movement, r), this.compute(e), this.emit();
  }
  gestureEnd(e) {
    this.state._active && (this.state._active = !1, this.compute(e), this.emit());
  }
  wheel(e) {
    const n = this.config.modifierKey;
    n && !e[n] || (this.state._active ? this.wheelChange(e) : this.wheelStart(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this)));
  }
  wheelStart(e) {
    this.start(e), this.wheelChange(e);
  }
  wheelChange(e) {
    "uv" in e || (e.cancelable && e.preventDefault(), {}.NODE_ENV === "development" && !e.defaultPrevented && console.warn("[@use-gesture]: To properly support zoom on trackpads, try using the `target` option.\n\nThis message will only appear in development mode."));
    const r = this.state;
    r._delta = [-sj(e)[1] / DJ * r.offset[0], 0], _o.addTo(r._movement, r._delta), cj(r), this.state.origin = [e.clientX, e.clientY], this.compute(e), this.emit();
  }
  wheelEnd() {
    this.state._active && (this.state._active = !1, this.compute(), this.emit());
  }
  bind(e) {
    const n = this.config.device;
    n && (e(n, "start", this[n + "Start"].bind(this)), e(n, "change", this[n + "Move"].bind(this)), e(n, "end", this[n + "End"].bind(this)), e(n, "cancel", this[n + "End"].bind(this)), e("lostPointerCapture", "", this[n + "End"].bind(this))), this.config.pinchOnWheel && e("wheel", "", this.wheel.bind(this), {
      passive: !1
    });
  }
}
const LJ = ei(ei({}, UI), {}, {
  device(t, e, {
    shared: n,
    pointer: {
      touch: r = !1
    } = {}
  }) {
    if (n.target && !Ks.touch && Ks.gesture)
      return "gesture";
    if (Ks.touch && r)
      return "touch";
    if (Ks.touchscreen) {
      if (Ks.pointer)
        return "pointer";
      if (Ks.touch)
        return "touch";
    }
  },
  bounds(t, e, {
    scaleBounds: n = {},
    angleBounds: r = {}
  }) {
    const a = (c) => {
      const f = fD(Nx(n, c), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [f.min, f.max];
    }, s = (c) => {
      const f = fD(Nx(r, c), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [f.min, f.max];
    };
    return typeof n != "function" && typeof r != "function" ? [a(), s()] : (c) => [a(c), s(c)];
  },
  threshold(t, e, n) {
    return this.lockDirection = n.axis === "lock", _o.toVector(t, this.lockDirection ? [0.1, 3] : 0);
  },
  modifierKey(t) {
    return t === void 0 ? "ctrlKey" : t;
  },
  pinchOnWheel(t = !0) {
    return t;
  }
});
ei(ei({}, Cb), {}, {
  mouseOnly: (t = !0) => t
});
class jJ extends wJ {
  constructor(...e) {
    super(...e), Yo(this, "ingKey", "wheeling");
  }
  wheel(e) {
    this.state._active || this.start(e), this.wheelChange(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(e) {
    const n = this.state;
    n._delta = sj(e), _o.addTo(n._movement, n._delta), cj(n), this.compute(e), this.emit();
  }
  wheelEnd() {
    this.state._active && (this.state._active = !1, this.compute(), this.emit());
  }
  bind(e) {
    e("wheel", "", this.wheel.bind(this));
  }
}
const zJ = Cb;
ei(ei({}, Cb), {}, {
  mouseOnly: (t = !0) => t
});
const BI = /* @__PURE__ */ new Map(), uP = /* @__PURE__ */ new Map();
function UJ(t) {
  BI.set(t.key, t.engine), uP.set(t.key, t.resolver);
}
const BJ = {
  key: "pinch",
  engine: NJ,
  resolver: LJ
}, FJ = {
  key: "wheel",
  engine: jJ,
  resolver: zJ
};
function HJ(t, e) {
  if (t == null)
    return {};
  var n = {}, r = Object.keys(t), a, s;
  for (s = 0; s < r.length; s++)
    a = r[s], !(e.indexOf(a) >= 0) && (n[a] = t[a]);
  return n;
}
function VJ(t, e) {
  if (t == null)
    return {};
  var n = HJ(t, e), r, a;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(t);
    for (a = 0; a < s.length; a++)
      r = s[a], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]);
  }
  return n;
}
const YJ = {
  target(t) {
    if (t)
      return () => "current" in t ? t.current : t;
  },
  enabled(t = !0) {
    return t;
  },
  window(t = Ks.isBrowser ? window : void 0) {
    return t;
  },
  eventOptions({
    passive: t = !0,
    capture: e = !1
  } = {}) {
    return {
      passive: t,
      capture: e
    };
  },
  transform(t) {
    return t;
  }
}, KJ = ["target", "eventOptions", "window", "enabled", "transform"];
function fx(t = {}, e) {
  const n = {};
  for (const [r, a] of Object.entries(e))
    switch (typeof a) {
      case "function":
        if ({}.NODE_ENV === "development") {
          const s = a.call(n, t[r], r, t);
          Number.isNaN(s) || (n[r] = s);
        } else
          n[r] = a.call(n, t[r], r, t);
        break;
      case "object":
        n[r] = fx(t[r], a);
        break;
      case "boolean":
        a && (n[r] = t[r]);
        break;
    }
  return n;
}
function WJ(t, e, n = {}) {
  const r = t, {
    target: a,
    eventOptions: s,
    window: c,
    enabled: f,
    transform: p
  } = r, g = VJ(r, KJ);
  if (n.shared = fx({
    target: a,
    eventOptions: s,
    window: c,
    enabled: f,
    transform: p
  }, YJ), e) {
    const y = uP.get(e);
    n[e] = fx(ei({
      shared: n.shared
    }, g), y);
  } else
    for (const y in g) {
      const v = uP.get(y);
      if (v)
        n[y] = fx(ei({
          shared: n.shared
        }, g[y]), v);
      else if ({}.NODE_ENV === "development" && !["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(y)) {
        if (y === "domTarget")
          throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
        console.warn(`[@use-gesture]: Unknown config key \`${y}\` was used. Please read the documentation for further information.`);
      }
    }
  return n;
}
class uj {
  constructor(e, n) {
    Yo(this, "_listeners", /* @__PURE__ */ new Set()), this._ctrl = e, this._gestureKey = n;
  }
  add(e, n, r, a, s) {
    const c = this._listeners, f = fJ(n, r), p = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}, g = ei(ei({}, p), s);
    e.addEventListener(f, a, g);
    const y = () => {
      e.removeEventListener(f, a, g), c.delete(y);
    };
    return c.add(y), y;
  }
  clean() {
    this._listeners.forEach((e) => e()), this._listeners.clear();
  }
}
class GJ {
  constructor() {
    Yo(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(e, n, r = 140, ...a) {
    this.remove(e), this._timeouts.set(e, window.setTimeout(n, r, ...a));
  }
  remove(e) {
    const n = this._timeouts.get(e);
    n && window.clearTimeout(n);
  }
  clean() {
    this._timeouts.forEach((e) => void window.clearTimeout(e)), this._timeouts.clear();
  }
}
class XJ {
  constructor(e) {
    Yo(this, "gestures", /* @__PURE__ */ new Set()), Yo(this, "_targetEventStore", new uj(this)), Yo(this, "gestureEventStores", {}), Yo(this, "gestureTimeoutStores", {}), Yo(this, "handlers", {}), Yo(this, "config", {}), Yo(this, "pointerIds", /* @__PURE__ */ new Set()), Yo(this, "touchIds", /* @__PURE__ */ new Set()), Yo(this, "state", {
      shared: {
        shiftKey: !1,
        metaKey: !1,
        ctrlKey: !1,
        altKey: !1
      }
    }), qJ(this, e);
  }
  setEventIds(e) {
    if (aj(e))
      return this.touchIds = new Set(gJ(e)), this.touchIds;
    if ("pointerId" in e)
      return e.type === "pointerup" || e.type === "pointercancel" ? this.pointerIds.delete(e.pointerId) : e.type === "pointerdown" && this.pointerIds.add(e.pointerId), this.pointerIds;
  }
  applyHandlers(e, n) {
    this.handlers = e, this.nativeHandlers = n;
  }
  applyConfig(e, n) {
    this.config = WJ(e, n, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const e of this.gestures)
      this.gestureEventStores[e].clean(), this.gestureTimeoutStores[e].clean();
  }
  effect() {
    return this.config.shared.target && this.bind(), () => this._targetEventStore.clean();
  }
  bind(...e) {
    const n = this.config.shared, r = {};
    let a;
    if (!(n.target && (a = n.target(), !a))) {
      if (n.enabled) {
        for (const c of this.gestures) {
          const f = this.config[c], p = vD(r, f.eventOptions, !!a);
          if (f.enabled) {
            const g = BI.get(c);
            new g(this, e, c).bind(p);
          }
        }
        const s = vD(r, n.eventOptions, !!a);
        for (const c in this.nativeHandlers)
          s(c, "", (f) => this.nativeHandlers[c](ei(ei({}, this.state.shared), {}, {
            event: f,
            args: e
          })), void 0, !0);
      }
      for (const s in r)
        r[s] = yJ(...r[s]);
      if (!a)
        return r;
      for (const s in r) {
        const {
          device: c,
          capture: f,
          passive: p
        } = dJ(s);
        this._targetEventStore.add(a, c, "", r[s], {
          capture: f,
          passive: p
        });
      }
    }
  }
}
function Ag(t, e) {
  t.gestures.add(e), t.gestureEventStores[e] = new uj(t, e), t.gestureTimeoutStores[e] = new GJ();
}
function qJ(t, e) {
  e.drag && Ag(t, "drag"), e.wheel && Ag(t, "wheel"), e.scroll && Ag(t, "scroll"), e.move && Ag(t, "move"), e.pinch && Ag(t, "pinch"), e.hover && Ag(t, "hover");
}
const vD = (t, e, n) => (r, a, s, c = {}, f = !1) => {
  var p, g;
  const y = (p = c.capture) !== null && p !== void 0 ? p : e.capture, v = (g = c.passive) !== null && g !== void 0 ? g : e.passive;
  let S = f ? r : cJ(r, a, y);
  n && v && (S += "Passive"), t[S] = t[S] || [], t[S].push(s);
}, QJ = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function ZJ(t) {
  const e = {}, n = {}, r = /* @__PURE__ */ new Set();
  for (let a in t)
    QJ.test(a) ? (r.add(RegExp.lastMatch), n[a] = t[a]) : e[a] = t[a];
  return [n, e, r];
}
function Og(t, e, n, r, a, s) {
  if (!t.has(n))
    return;
  if (!BI.has(r)) {
    ({}).NODE_ENV === "development" && console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${r}\` gesture but isn't properly configured.

Please add \`${r}Action\` when creating your handler.`);
    return;
  }
  const c = n + "Start", f = n + "End", p = (g) => {
    let y;
    return g.first && c in e && e[c](g), n in e && (y = e[n](g)), g.last && f in e && e[f](g), y;
  };
  a[r] = p, s[r] = s[r] || {};
}
function JJ(t, e) {
  const [n, r, a] = ZJ(t), s = {};
  return Og(a, n, "onDrag", "drag", s, e), Og(a, n, "onWheel", "wheel", s, e), Og(a, n, "onScroll", "scroll", s, e), Og(a, n, "onPinch", "pinch", s, e), Og(a, n, "onMove", "move", s, e), Og(a, n, "onHover", "hover", s, e), {
    handlers: s,
    config: e,
    nativeHandlers: r
  };
}
function eee(t, e = {}, n, r) {
  const a = It.useMemo(() => new XJ(t), []);
  if (a.applyHandlers(t, r), a.applyConfig(e, n), It.useEffect(a.effect.bind(a)), It.useEffect(() => a.clean.bind(a), []), e.target === void 0)
    return a.bind.bind(a);
}
function tee(t) {
  return t.forEach(UJ), function(n, r) {
    const {
      handlers: a,
      nativeHandlers: s,
      config: c
    } = JJ(n, r || {});
    return eee(a, c, void 0, s);
  };
}
const yD = 10, nee = /Mac|iPod|iPhone|iPad/.test(
  typeof window > "u" ? "node" : window.navigator.platform
);
function dj(t) {
  let { deltaY: e, deltaX: n } = t, r = 0;
  if (t.ctrlKey || t.altKey || t.metaKey) {
    const a = Math.sign(t.deltaY), s = Math.abs(t.deltaY);
    let c = e;
    s > yD && (c = yD * a), r = c / 100;
  } else
    t.shiftKey && !nee && (n = e, e = 0);
  return { x: -n, y: -e, z: -r };
}
const ree = tee([FJ, BJ]);
let Dg;
const iee = (t) => Dg === void 0 ? (Dg = t, !1) : t - Dg > 120 && t - Dg < 160 ? (Dg = t, !0) : (Dg = t, !1);
function oee(t) {
  const e = Ge(), n = k.useMemo(() => {
    const r = ({ event: p }) => {
      if (iee(Date.now()))
        return;
      if (e.editingId) {
        const v = e.getShapeById(e.editingId);
        if (v && e.getShapeUtil(v).canScroll(v) && e.getPageBoundsById(e.editingId)?.containsPoint(e.inputs.currentPagePoint))
          return;
      }
      Gn(p);
      const g = dj(p);
      if (g.x === 0 && g.y === 0)
        return;
      const y = {
        type: "wheel",
        name: "wheel",
        delta: g,
        shiftKey: p.shiftKey,
        altKey: p.altKey,
        ctrlKey: p.metaKey || p.ctrlKey
      };
      e.dispatch(y);
    }, a = new O();
    return {
      onWheel: r,
      onPinchStart: (p) => {
        const g = t.current, { event: y, origin: v } = p;
        y instanceof WheelEvent || (y.target === g || g?.contains(y.target)) && (a.x = v[0], a.y = v[1], e.dispatch({
          type: "pinch",
          name: "pinch_start",
          point: { x: v[0], y: v[1], z: e.camera.z },
          delta: { x: 0, y: 0 },
          shiftKey: y.shiftKey,
          altKey: y.altKey,
          ctrlKey: y.metaKey || y.ctrlKey
        }));
      },
      onPinchEnd: (p) => {
        const g = t.current, { event: y, origin: v, offset: S } = p;
        if (y instanceof WheelEvent || !(y.target === g || g?.contains(y.target)))
          return;
        const x = S[0];
        requestAnimationFrame(() => {
          e.dispatch({
            type: "pinch",
            name: "pinch_end",
            point: { x: v[0], y: v[1], z: x },
            delta: { x: v[0], y: v[1] },
            shiftKey: y.shiftKey,
            altKey: y.altKey,
            ctrlKey: y.metaKey || y.ctrlKey
          });
        });
      },
      onPinch: (p) => {
        const g = t.current, { event: y, origin: v, offset: S } = p, x = S[0];
        if (y instanceof WheelEvent || !(y.target === g || g?.contains(y.target)))
          return;
        const _ = v[0] - a.x, T = v[1] - a.y;
        a.x = v[0], a.y = v[1], e.dispatch({
          type: "pinch",
          name: "pinch",
          point: { x: v[0], y: v[1], z: x },
          delta: { x: _, y: T },
          shiftKey: y.shiftKey,
          altKey: y.altKey,
          ctrlKey: y.metaKey || y.ctrlKey
        });
      }
    };
  }, [e, t]);
  ree(n, {
    target: t,
    eventOptions: { passive: !1 },
    pinch: {
      from: () => [e.camera.z, 0],
      // Return the camera z to use when pinch starts
      scaleBounds: () => ({ from: e.camera.z, max: 8, min: 0.05 })
    }
  });
}
function My(t, e, n) {
  const r = t.getShapeById(e), s = t.getShapeUtil(r).handles(r);
  return { shape: r, handle: s.find((c) => c.id === n) };
}
function aee(t, e) {
  const n = Ge();
  return k.useMemo(() => {
    const r = (y) => {
      if (y.isKilled)
        return;
      const v = Dx(y.currentTarget);
      xb(v, y);
      const { shape: S, handle: x } = My(n, t, e);
      x && n.dispatch({
        type: "pointer",
        target: "handle",
        handle: x,
        shape: S,
        name: "pointer_down",
        ...Yi(y, n.getContainer())
      });
    };
    let a, s;
    return {
      onPointerDown: r,
      onPointerMove: (y) => {
        if (y.isKilled || y.clientX === a && y.clientY === s)
          return;
        a = y.clientX, s = y.clientY;
        const { shape: v, handle: S } = My(n, t, e);
        S && n.dispatch({
          type: "pointer",
          target: "handle",
          handle: S,
          shape: v,
          name: "pointer_move",
          ...Yi(y, n.getContainer())
        });
      },
      onPointerUp: (y) => {
        if (y.isKilled)
          return;
        const v = Dx(y.currentTarget);
        Eb(v, y);
        const { shape: S, handle: x } = My(n, t, e);
        x && n.dispatch({
          type: "pointer",
          target: "handle",
          handle: x,
          shape: S,
          name: "pointer_up",
          ...Yi(y, n.getContainer())
        });
      },
      onPointerEnter: (y) => {
        if (y.isKilled)
          return;
        const { shape: v, handle: S } = My(n, t, e);
        S && n.dispatch({
          type: "pointer",
          target: "handle",
          handle: S,
          shape: v,
          name: "pointer_enter",
          ...Yi(y, n.getContainer())
        });
      },
      onPointerLeave: (y) => {
        if (y.isKilled)
          return;
        const { shape: v, handle: S } = My(n, t, e);
        S && n.dispatch({
          type: "pointer",
          target: "handle",
          handle: S,
          shape: v,
          name: "pointer_leave",
          ...Yi(y, n.getContainer())
        });
      }
    };
  }, [n, t, e]);
}
function FI(t) {
  const e = Ge();
  return un("isEditing", () => e.editingId === t, [e, t]);
}
const Uy = 8, bD = (t, e, n) => new Promise((r, a) => {
  const s = Uy * e * t, c = document.createElement("canvas");
  c.width = s, c.height = s;
  const f = c.getContext("2d");
  if (!f)
    throw new Error("No canvas");
  f.fillStyle = n ? "#212529" : "#f8f9fa", f.fillRect(0, 0, s, s), f.globalCompositeOperation = "destination-out", f.lineCap = "round", f.lineWidth = 1.25 * e * t;
  const p = 8 / 12, g = (y) => y * e * t;
  f.beginPath(), f.moveTo(g(p * 1), g(p * 3)), f.lineTo(g(p * 3), g(p * 1)), f.moveTo(g(p * 5), g(p * 7)), f.lineTo(g(p * 7), g(p * 5)), f.moveTo(g(p * 9), g(p * 11)), f.lineTo(g(p * 11), g(p * 9)), f.stroke(), c.toBlob((y) => {
    !y || hs.throwToBlob.value ? a() : r(y);
  });
}), SD = (t, e) => {
  const n = document.createElement("canvas");
  return n.width = t[0], n.height = t[1], e(n.getContext("2d")), n.toDataURL();
}, see = () => {
  const t = [];
  for (let e = 1; e <= Math.ceil(kp); e++) {
    const n = SD([1, 1], (a) => {
      a.fillStyle = "#e8e8e8", a.fillRect(0, 0, 1, 1);
    }), r = SD([1, 1], (a) => {
      a.fillStyle = "#2c3036", a.fillRect(0, 0, 1, 1);
    });
    t.push({
      zoom: e,
      url: n,
      darkMode: !1
    }), t.push({
      zoom: e,
      url: r,
      darkMode: !0
    });
  }
  return t;
}, lee = function() {
  const n = Ge().devicePixelRatio, [r, a] = k.useState(!1), s = k.useMemo(() => see(), []), [c, f] = k.useState(s);
  return k.useEffect(() => {
    const g = [];
    for (let v = 1; v <= Math.ceil(kp); v++)
      g.push(
        bD(n, v, !1).then((S) => ({
          zoom: v,
          url: URL.createObjectURL(S),
          darkMode: !1
        }))
      ), g.push(
        bD(n, v, !0).then((S) => ({
          zoom: v,
          url: URL.createObjectURL(S),
          darkMode: !0
        }))
      );
    let y = !1;
    return Promise.all(g).then((v) => {
      y || (f(v), a(!0));
    }), () => {
      y = !0, a(!1);
    };
  }, [n]), { context: /* @__PURE__ */ E.jsx("defs", { children: c.map((g) => {
    const y = g.zoom + (g.darkMode ? "_dark" : "_light");
    return /* @__PURE__ */ E.jsx(
      "pattern",
      {
        id: Mx[y],
        width: Uy,
        height: Uy,
        patternUnits: "userSpaceOnUse",
        children: /* @__PURE__ */ E.jsx("image", { href: g.url, width: Uy, height: Uy })
      },
      y
    );
  }) }), isReady: r };
}, Us = 8 / 12;
function cee() {
  const t = document.createElement("div");
  return t.innerHTML = `
		<svg>
			<defs>
				<g>
					<pattern
						id="hash_pattern"
						width="8"
						height="8"
						patternUnits="userSpaceOnUse"
						strokeLinecap="round"
						stroke="white"
					>
						<line x1="${Us * 1}" y1="${Us * 3}" x2="${Us * 3}" y2="${Us * 1}" />
						<line x1="${Us * 5}" y1="${Us * 7}" x2="${Us * 7}" y2="${Us * 5}" />
						<line x1="${Us * 9}" y1="${Us * 11}" x2="${Us * 11}" y2="${Us * 9}" />
					</pattern>
					<mask id="hash_mask">
						<rect x="-100%" y="-100%" width="200%" height="200%" fill="url(#hash_pattern)" />
					</mask>
				</g>
			</defs>
		</svg>
	`, t.querySelectorAll("defs > *");
}
var fj = "Expected a function", wD = 0 / 0, uee = "[object Symbol]", dee = /^\s+|\s+$/g, fee = /^[-+]0x[0-9a-f]+$/i, pee = /^0b[01]+$/i, hee = /^0o[0-7]+$/i, gee = parseInt, mee = typeof da == "object" && da && da.Object === Object && da, vee = typeof self == "object" && self && self.Object === Object && self, yee = mee || vee || Function("return this")(), bee = Object.prototype, See = bee.toString, wee = Math.max, xee = Math.min, ok = function() {
  return yee.Date.now();
};
function Eee(t, e, n) {
  var r, a, s, c, f, p, g = 0, y = !1, v = !1, S = !0;
  if (typeof t != "function")
    throw new TypeError(fj);
  e = xD(e) || 0, Lx(n) && (y = !!n.leading, v = "maxWait" in n, s = v ? wee(xD(n.maxWait) || 0, e) : s, S = "trailing" in n ? !!n.trailing : S);
  function x(F) {
    var K = r, X = a;
    return r = a = void 0, g = F, c = t.apply(X, K), c;
  }
  function _(F) {
    return g = F, f = setTimeout(D, e), y ? x(F) : c;
  }
  function T(F) {
    var K = F - p, X = F - g, se = e - K;
    return v ? xee(se, s - X) : se;
  }
  function I(F) {
    var K = F - p, X = F - g;
    return p === void 0 || K >= e || K < 0 || v && X >= s;
  }
  function D() {
    var F = ok();
    if (I(F))
      return N(F);
    f = setTimeout(D, T(F));
  }
  function N(F) {
    return f = void 0, S && r ? x(F) : (r = a = void 0, c);
  }
  function j() {
    f !== void 0 && clearTimeout(f), g = 0, r = p = a = f = void 0;
  }
  function L() {
    return f === void 0 ? c : N(ok());
  }
  function z() {
    var F = ok(), K = I(F);
    if (r = arguments, a = this, p = F, K) {
      if (f === void 0)
        return _(p);
      if (v)
        return f = setTimeout(D, e), x(p);
    }
    return f === void 0 && (f = setTimeout(D, e)), c;
  }
  return z.cancel = j, z.flush = L, z;
}
function Cee(t, e, n) {
  var r = !0, a = !0;
  if (typeof t != "function")
    throw new TypeError(fj);
  return Lx(n) && (r = "leading" in n ? !!n.leading : r, a = "trailing" in n ? !!n.trailing : a), Eee(t, e, {
    leading: r,
    maxWait: e,
    trailing: a
  });
}
function Lx(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function");
}
function _ee(t) {
  return !!t && typeof t == "object";
}
function Tee(t) {
  return typeof t == "symbol" || _ee(t) && See.call(t) == uee;
}
function xD(t) {
  if (typeof t == "number")
    return t;
  if (Tee(t))
    return wD;
  if (Lx(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Lx(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = t.replace(dee, "");
  var n = pee.test(t);
  return n || hee.test(t) ? gee(t.slice(2), n ? 2 : 8) : fee.test(t) ? wD : +t;
}
var kee = Cee;
const Pee = /* @__PURE__ */ jp(kee);
function Iee() {
  const t = Ge(), e = va();
  k.useLayoutEffect(() => {
    const n = Pee(
      () => {
        t.updateViewportScreenBounds();
      },
      200,
      { trailing: !0 }
    ), r = new ResizeObserver((a) => {
      a[0].contentRect && n();
    });
    return e && r.observe(e), n(), () => {
      r.disconnect();
    };
  }, [t, e]);
}
const Ay = (t, e, n) => (r) => {
  if (t.pageState.editingId === e && (r.isKilled = !0), r.isKilled)
    return;
  switch (n) {
    case "pointer_down": {
      if (r.button !== 0 && r.button !== 2)
        return;
      xb(r.currentTarget, r);
      break;
    }
    case "pointer_up": {
      Eb(r.currentTarget, r);
      break;
    }
  }
  const a = t.getShapeById(e);
  if (!a) {
    console.error("Shape not found", e);
    return;
  }
  t.dispatch({
    type: "pointer",
    target: "shape",
    shape: a,
    name: n,
    ...Yi(r, t.getContainer())
  });
};
function Ree(t) {
  const e = Ge();
  return It.useMemo(() => {
    function n(p) {
      p.isKilled = !0, Gn(p);
    }
    function r(p) {
      p.isKilled = !0, Gn(p);
    }
    const a = Ay(e, t, "pointer_move");
    let s, c;
    function f(p) {
      if (!p.isKilled && !(p.clientX === s && p.clientY === c))
        return s = p.clientX, c = p.clientY, a(p);
    }
    return {
      onPointerDown: Ay(e, t, "pointer_down"),
      onPointerUp: Ay(e, t, "pointer_up"),
      onPointerEnter: Ay(e, t, "pointer_enter"),
      onPointerLeave: Ay(e, t, "pointer_leave"),
      onPointerMove: f,
      onTouchStart: n,
      onTouchEnd: r
    };
  }, [e, t]);
}
function $ee() {
  const t = Ge(), e = va();
  k.useEffect(() => {
    const n = (s) => e.style.setProperty("--rs-zoom", s.toString()), r = fI(n, 100), a = new Sb("useZoomCss", () => {
      t.shapeIds.size < 300 ? n(t.zoomLevel) : r(t.zoomLevel);
    });
    return a.attach(), a.execute(), () => {
      a.detach();
    };
  }, [t, e]);
}
const gs = k.memo(function({ d: e, color: n, fill: r }) {
  switch (r) {
    case "none":
      return /* @__PURE__ */ E.jsx("path", { className: "rs-hitarea-stroke", fill: "none", d: e });
    case "solid":
      return /* @__PURE__ */ E.jsx("path", { className: "rs-hitarea-fill-solid", fill: `var(--palette-${n}-semi)`, d: e });
    case "semi":
      return /* @__PURE__ */ E.jsx("path", { className: "rs-hitarea-fill-solid", fill: "var(--palette-solid)", d: e });
    case "pattern":
      return /* @__PURE__ */ E.jsx(Mee, { color: n, fill: r, d: e });
  }
}), Mee = dn(function({ d: e, color: n }) {
  const r = Ge(), a = Math.ceil(r.zoomLevel), s = r.zoomLevel <= 0.18, c = r.userDocumentSettings.isDarkMode;
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx("path", { className: "rs-hitarea-fill-solid", fill: `var(--palette-${n}-pattern)`, d: e }),
    /* @__PURE__ */ E.jsx(
      "path",
      {
        fill: s ? `var(--palette-${n}-semi)` : `url(#${Mx[a + (c ? "_dark" : "_light")]})`,
        d: e
      }
    )
  ] });
});
function Ac({
  d: t,
  color: e,
  fill: n,
  colors: r
}) {
  if (n === "none")
    return;
  if (n === "pattern") {
    const s = document.createElementNS("http://www.w3.org/2000/svg", "g"), c = document.createElementNS("http://www.w3.org/2000/svg", "path");
    c.setAttribute("d", t), c.setAttribute("fill", r.background);
    const f = document.createElementNS("http://www.w3.org/2000/svg", "path");
    return f.setAttribute("d", t), f.setAttribute("mask", "url(#hash_mask)"), f.setAttribute("fill", r.pattern[e]), s.appendChild(c), s.appendChild(f), s;
  }
  const a = document.createElementNS("http://www.w3.org/2000/svg", "path");
  switch (a.setAttribute("d", t), n) {
    case "semi": {
      a.setAttribute("fill", r.solid);
      break;
    }
    case "solid": {
      a.setAttribute("fill", r.semi[e]);
      break;
    }
  }
  return a;
}
function df(t, e) {
  if (e) {
    const n = document.createElementNS("http://www.w3.org/2000/svg", "g");
    return n.appendChild(e), n.appendChild(t), n;
  } else
    return t;
}
function Gs(t, e, n = {}) {
  const {
    closed: r = !1,
    snap: a = 1,
    start: s = "outset",
    end: c = "outset",
    lengthRatio: f = 2,
    style: p = "dashed"
  } = n;
  let g = 0, y = 0, v = 1, S = 0, x = 0;
  switch (p) {
    case "dashed": {
      v = 1, g = Math.min(e * f, t / 4);
      break;
    }
    case "dotted": {
      v = 100, g = e / v;
      break;
    }
    default:
      return {
        strokeDasharray: "none",
        strokeDashoffset: "none"
      };
  }
  return r || (s === "outset" ? (t += g / 2, x += g / 2) : s === "skip" && (t -= g, x -= g), c === "outset" ? t += g / 2 : c === "skip" && (t -= g)), y = Math.floor(t / g / (2 * v)), y -= y % a, y < 3 && p === "dashed" ? t / e < 5 ? (g = t, y = 1, S = 0) : (g = t * 0.333, S = t * 0.333) : (y = Math.max(y, 3), g = t / y / (2 * v), r ? (x = g / 2, S = (t - y * g) / y) : S = (t - y * g) / Math.max(1, y - 1)), {
    strokeDasharray: [g, S].join(" "),
    strokeDashoffset: x.toString()
  };
}
const Pc = (t) => t.stopPropagation();
function m1(t, e) {
  const { padding: n = 0 } = e, r = document.createElementNS("http://www.w3.org/2000/svg", "text");
  r.setAttribute("font-size", e.fontSize + "px"), r.setAttribute("font-family", e.fontFamily), r.setAttribute("font-style", e.fontStyle), r.setAttribute("font-weight", e.fontWeight), r.setAttribute("line-height", e.lineHeight * e.fontSize + "px"), r.setAttribute("dominant-baseline", "mathematical"), r.setAttribute("alignment-baseline", "mathematical");
  const a = e.lines.map((g) => g.trim()), s = [], c = a.length * (e.lineHeight * e.fontSize), f = (Math.ceil(e.height) - c) / 2, p = n;
  for (let g = 0; g < a.length; g++) {
    const y = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    y.setAttribute("alignment-baseline", "mathematical"), y.textContent = UZ(a[g]), a.length > 1 && g < a.length - 1 && (y.textContent += `
`), y.setAttribute(
      "y",
      f + e.fontSize / 2 + e.lineHeight * e.fontSize * g + "px"
    ), r.appendChild(y), s.push(y);
  }
  switch (e.stroke && e.strokeWidth && (r.setAttribute("stroke", e.stroke), r.setAttribute("stroke-width", e.strokeWidth + "px")), e.fill && r.setAttribute("fill", e.fill), e.textAlign) {
    case "middle": {
      r.setAttribute("text-align", "center"), r.setAttribute("text-anchor", "start"), s.forEach((g, y) => {
        const v = t.textMeasure.measureText({
          ...Ki,
          text: a[y].trim(),
          fontFamily: e.fontFamily,
          fontSize: e.fontSize,
          width: "fit-content",
          padding: `${n}px`
        }).w;
        g.setAttribute("x", p + (e.width - v) / 2 + "");
      });
      break;
    }
    case "end": {
      r.setAttribute("text-align", "right"), r.setAttribute("text-anchor", "start"), s.forEach((g, y) => {
        const v = t.textMeasure.measureText({
          ...Ki,
          text: a[y].trim(),
          fontFamily: e.fontFamily,
          fontSize: e.fontSize,
          width: "fit-content",
          padding: `${n}px`
        }).w;
        g.setAttribute("x", p + e.width - v + "");
      });
      break;
    }
    default:
      r.setAttribute("text-align", "left"), r.setAttribute("text-anchor", "start"), s.forEach((g) => g.setAttribute("x", p + ""));
  }
  return r;
}
var Aee = Object.defineProperty, Oee = Object.getOwnPropertyDescriptor, HI = (t, e, n, r) => {
  for (var a = r > 1 ? void 0 : r ? Oee(e, n) : e, s = t.length - 1, c; s >= 0; s--)
    (c = t[s]) && (a = (r ? c(e, n, a) : c(a)) || a);
  return r && a && Aee(e, n, a), a;
};
const Dee = new um(), Nee = new um();
class Oc {
  constructor(e, n) {
    this.app = e, this.type = n;
  }
  is(e) {
    return e.type === this.type;
  }
  /**
   * Whether the shape can be scrolled while editing.
   *
   * @public
   */
  canScroll = () => !1;
  /**
   * Whether the shape can be bound to by an arrow.
   *
   * @public
   */
  canUnmount = () => !0;
  /**
   * Whether the shape can be bound to by an arrow.
   *
   * @param _otherShape - The other shape attempting to bind to this shape.
   * @public
   */
  canBind = (e, n) => !0;
  /**
   * Whether the shape can be double clicked to edit.
   *
   * @public
   */
  canEdit = () => !1;
  /**
   * Whether the shape can be resized.
   *
   * @public
   */
  canResize = () => !0;
  /**
   * Bounds of the shape to edit.
   *
   * Note: this could be a text area within a shape for example arrow labels.
   *
   * @public
   */
  getEditingBounds = (e) => this.bounds(e);
  /**
   * Whether the shape's outline is closed.
   *
   * @public
   */
  isClosed = () => !0;
  /**
   * Whether the shape should hide its resize handles when selected.
   *
   * @public
   */
  hideResizeHandles = () => !1;
  /**
   * Whether the shape should hide its resize handles when selected.
   *
   * @public
   */
  hideRotateHandle = () => !1;
  /**
   * Whether the shape should hide its selection bounds background when selected.
   *
   * @public
   */
  hideSelectionBoundsBg = () => !1;
  /**
   * Whether the shape should hide its selection bounds foreground when selected.
   *
   * @public
   */
  hideSelectionBoundsFg = () => !1;
  /**
   * Whether the shape's aspect ratio is locked.
   *
   * @public
   */
  isAspectRatioLocked = () => !1;
  get handlesCache() {
    return this.app.store.createComputedCache("handles:" + this.type, (e) => this.getHandles(e));
  }
  /**
   * Get the cached handles (this should not be overridden!)
   *
   * @param shape - The shape.
   * @public
   */
  handles(e) {
    return this.getHandles ? this.handlesCache.get(e.id) ?? Ws : Ws;
  }
  get boundsCache() {
    return this.app.store.createComputedCache("bounds:" + this.type, (e) => this.getBounds(e));
  }
  /**
   * Get the cached bounds for the shape.
   *
   * @param shape - The shape.
   * @public
   */
  bounds(e) {
    const n = this.boundsCache.get(e.id) ?? new ot();
    return n.width === 0 || n.height === 0 ? new ot(n.x, n.y, Math.max(n.width, 1), Math.max(n.height, 1)) : n;
  }
  /**
   * Get the cached transform. Do not override this method!
   *
   * @param shape - The shape.
   * @public
   */
  transform(e) {
    return Nee.get(
      e,
      (n) => De.Compose(De.Translate(n.x, n.y), De.Rotate(n.rotation))
    );
  }
  /**
   * Get the cached point. Do not override this method!
   *
   * @param shape - The shape.
   * @public
   */
  point(e) {
    return Dee.get(e, (n) => ({ x: n.x, y: n.y }));
  }
  get outlineCache() {
    return this.app.store.createComputedCache("outline:" + this.type, (e) => this.getOutline(e));
  }
  /**
   * Get the shape's outline. Do not override this method!
   *
   * @param shape - The shape.
   * @public
   */
  outline(e) {
    return this.outlineCache.get(e.id) ?? Ws;
  }
  /**
   * Get the shape's snap points.
   *
   * @param shape - The shape.
   * @public
   */
  snapPoints(e) {
    return this.bounds(e).snapPoints;
  }
  /**
   * Get the shape's cached center.
   *
   * @param shape - The shape.
   * @public
   */
  center(e) {
    return this.getCenter(e);
  }
  /**
   * Get whether the shape can receive children of a given type.
   *
   * @param type - The shape type.
   * @public
   */
  canReceiveNewChildrenOfType(e) {
    return !1;
  }
  /**
   * Get whether the shape can receive children of a given type.
   *
   * @param shape - The shape type.
   * @param shapes - The shapes that are being dropped.
   * @public
   */
  canDropShapes(e, n) {
    return !1;
  }
  /**
   * Get whether a point intersects the shape.
   *
   * @param shape - The shape.
   * @param point - The point to test.
   *
   * @public
   * @returns Whether the point intersects the shape.
   */
  hitTestPoint(e, n) {
    return this.bounds(e).containsPoint(n);
  }
  /**
   * Get whether a point intersects the shape.
   *
   * @param shape - The shape.
   * @param A - The line segment's first point.
   * @param B - The line segment's second point.
   *
   * @public
   * @returns Whether the line segment intersects the shape.
   */
  hitTestLineSegment(e, n, r) {
    const a = this.outline(e);
    for (let s = 0; s < a.length; s++) {
      const c = a[s], f = a[(s + 1) % a.length];
      if (ef(n, r, c, f))
        return !0;
    }
    return !1;
  }
  //  Events
  /**
   * A callback called just before a shape is created. This method
   * provides a last chance to modify the created shape.
   *
   * @example
   * ```ts
   * onBeforeUpdate = (prev, next) => {
   *   if (prev.x === next.x) {
   *   return { ...next, x: next.x + 1 }
   * }
   * ```
   *
   * @param prev - The previous shape.
   * @param next - The next shape.
   *
   * @returns The next shape or void.
   * @public
   */
  onBeforeCreate;
  /**
   * A callback called just before a shape is updated. This method
   * provides a last chance to modify the updated shape.
   *
   * @example
   * ```ts
   * onBeforeUpdate = (prev, next) => {
   *   if (prev.x === next.x) {
   *   return { ...next, x: next.x + 1 }
   * }
   * ```
   *
   * @param prev - The previous shape.
   * @param next - The next shape.
   *
   * @returns The next shape or void.
   * @public
   */
  onBeforeUpdate;
  onDragShapesOver;
  onDragShapesOut;
  onDropShapesOver;
  onResizeStart;
  onResize;
  onResizeEnd;
  onTranslateStart;
  onTranslate;
  onTranslateEnd;
  onRotateStart;
  onRotateEnd;
  onRotate;
  onHandleChange;
  onBindingChange;
  onChildrenChange;
  onDoubleClickHandle;
  onDoubleClickEdge;
  onDoubleClick;
  onClick;
  onEditEnd;
}
HI([
  pt
], Oc.prototype, "handlesCache", 1);
HI([
  pt
], Oc.prototype, "boundsCache", 1);
HI([
  pt
], Oc.prototype, "outlineCache", 1);
function Lee(t, e, n) {
  const r = e === "end" ? t.end.point : t.start.point, a = e === "end" ? t.start.point : t.end.point, s = t.isStraight ? O.Dist(a, r) : Math.abs(t.bodyArc.length), c = Math.max(Math.min(s / 5, n * 3), n);
  let f;
  if (t.isStraight)
    f = O.Nudge(r, a, c);
  else {
    const p = tQ(r, c, t.handleArc.center, t.handleArc.radius);
    f = e === "end" ? t.handleArc.sweepFlag ? p[0] : p[1] : t.handleArc.sweepFlag ? p[1] : p[0];
  }
  return {
    point: r,
    int: f
  };
}
function jee({ point: t, int: e }) {
  const n = O.RotWith(e, t, Kr / 6), r = O.RotWith(e, t, -Kr / 6);
  return `M ${n.x} ${n.y} L ${t.x} ${t.y} L ${r.x} ${r.y}`;
}
function zee({ point: t, int: e }) {
  const n = O.RotWith(e, t, Kr / 6), r = O.RotWith(e, t, -Kr / 6);
  return `M ${n.x} ${n.y} L ${t.x} ${t.y} L ${r.x} ${r.y} Z`;
}
function Uee({ point: t, int: e }) {
  const n = O.Sub(e, t).div(2), r = O.Add(t, O.Rot(n, cr)), a = O.Sub(t, O.Rot(n, cr));
  return `M ${r.x} ${r.y} L ${e.x} ${e.y} L ${a.x} ${a.y} Z`;
}
function Bee({ point: t, int: e }) {
  const n = O.Lrp(t, e, 0.45), r = O.Dist(n, t);
  return `M ${n.x - r},${n.y}
  a ${r},${r} 0 1,0 ${r * 2},0
  a ${r},${r} 0 1,0 -${r * 2},0 `;
}
function Fee({ point: t, int: e }) {
  const n = O.Lrp(t, e, 0.75), r = O.RotWith(n, t, Kr / 4), a = O.RotWith(n, t, -Kr / 4), s = O.Lrp(r, a, 0.5);
  return s.add(O.Sub(s, t)), `M ${s.x} ${s.y} L ${r.x} ${r.y} ${t.x} ${t.y} L ${a.x} ${a.y} Z`;
}
function Hee({ int: t, point: e }) {
  const n = O.Lrp(e, t, 0.85), r = O.Sub(n, e).div(2), a = O.Add(e, O.Rot(r, cr)), s = O.Sub(e, O.Rot(r, cr)), c = O.Add(n, O.Rot(r, cr)), f = O.Sub(n, O.Rot(r, cr));
  return `M ${a.x} ${a.y} L ${c.x} ${c.y} L ${f.x} ${f.y} L ${s.x} ${s.y} Z`;
}
function Vee({ int: t, point: e }) {
  const n = O.Sub(t, e).div(2), r = O.Add(e, O.Rot(n, cr)), a = O.Sub(e, O.Rot(n, cr));
  return `M ${r.x} ${r.y} L ${a.x} ${a.y}`;
}
function Ng(t, e, n) {
  const r = e === "end" ? t.end.arrowhead : t.start.arrowhead;
  if (r === "none")
    return;
  const a = Lee(t, e, n);
  if (a) {
    switch (r) {
      case "bar":
        return Vee(a);
      case "square":
        return Hee(a);
      case "diamond":
        return Fee(a);
      case "dot":
        return Bee(a);
      case "inverted":
        return Uee(a);
      case "arrow":
        return jee(a);
      case "triangle":
        return zee(a);
    }
    return "";
  }
}
function Yee(t) {
  return Math.abs(t.props.bend) < 8;
}
function jx(t, e) {
  if (e.type === "point")
    return;
  const n = t.getShapeById(e.boundShapeId), r = t.getShapeUtil(n), a = t.getPageTransform(n);
  return {
    shape: n,
    util: r,
    transform: a,
    isExact: e.isExact,
    didIntersect: !1
  };
}
function ED(t, e, n) {
  if (n.type === "point")
    return O.From(n);
  const r = t.getShapeById(n.boundShapeId);
  if (r) {
    const { point: a, size: s } = t.getBounds(r), c = O.Add(a, O.MulV(n.normalizedAnchor, s)), f = De.applyToPoint(t.getPageTransform(r), c);
    return De.applyToPoint(De.Inverse(e), f);
  } else
    return console.error("Expected a bound shape!"), new O(0, 0);
}
function Ou(t, e) {
  const n = t.getPageTransform(e), r = ED(t, n, e.props.start), a = ED(t, n, e.props.end);
  return { start: r, end: a };
}
function pj(t, e) {
  const { start: n, end: r, arrowheadStart: a, arrowheadEnd: s } = e.props, c = Ou(t, e), f = c.start.clone(), p = c.end.clone(), g = O.Med(f, p), y = O.Sub(p, f).uni(), v = jx(t, n), S = jx(t, r), x = t.getPageTransform(e);
  CD(
    p,
    // <-- will be mutated
    c.start,
    x,
    S
  ), CD(
    f,
    // <-- will be mutated
    c.end,
    x,
    v
  );
  let _ = Pp;
  const T = v && S && v.shape === S.shape;
  v && S && !T && !v.isExact && !S.isExact && (S.didIntersect && !v.didIntersect ? v.util.isClosed(v.shape) && f.setTo(O.Nudge(p, f, _)) : S.didIntersect || S.util.isClosed(S.shape) && p.setTo(O.Nudge(f, p, _)));
  const I = O.Sub(p, f).uni(), D = !O.Equals(I, y);
  if (!T) {
    if (v && a !== "none" && !v.isExact) {
      const j = Ax + t.getStrokeWidth(e.props.size) / 2 + ("size" in v.shape.props ? t.getStrokeWidth(v.shape.props.size) / 2 : 0);
      _ -= j, f.nudge(p, j * (D ? -1 : 1));
    }
    if (S && s !== "none" && !S.isExact) {
      const j = Ax + t.getStrokeWidth(e.props.size) / 2 + ("size" in S.shape.props ? t.getStrokeWidth(S.shape.props.size) / 2 : 0);
      _ -= j, p.nudge(f, j * (D ? -1 : 1));
    }
  }
  v && S && (D ? p.setTo(O.Add(f, I.mul(-_))) : O.Dist(f, p) < Pp / 2 && p.setTo(O.Add(f, I.mul(Pp / 2)))), D ? g.setTo(O.Med(c.start, c.end)) : g.setTo(O.Med(f, p));
  const N = O.Dist(f, p);
  return {
    isStraight: !0,
    start: {
      handle: c.start,
      point: f,
      arrowhead: e.props.arrowheadStart
    },
    end: {
      handle: c.end,
      point: p,
      arrowhead: e.props.arrowheadEnd
    },
    middle: g,
    isValid: N > 0,
    length: N
  };
}
function CD(t, e, n, r) {
  if (r === void 0 || r.isExact)
    return;
  const a = De.applyToPoint(n, e), s = De.applyToPoint(n, t), c = De.applyToPoint(De.Inverse(r.transform), a), f = De.applyToPoint(De.Inverse(r.transform), s), p = r.util.isClosed(r.shape), y = (p ? eQ : RI)(c, f, r.util.outline(r.shape));
  let v;
  if (y !== null && (v = y.sort((_, T) => O.Dist(_, c) - O.Dist(T, c))[0] ?? (p ? void 0 : f)), v === void 0)
    return;
  const S = De.applyToPoint(r.transform, v), x = De.applyToPoint(De.Inverse(n), S);
  t.setTo(x), r.didIntersect = !0;
}
function Kee(t) {
  return hj(t.start.handle, t.end.handle);
}
function ak(t) {
  return hj(t.start.point, t.end.point);
}
function hj(t, e) {
  return `M${t.x},${t.y}L${e.x},${e.y}`;
}
function Wee(t, e, n = 0) {
  const { arrowheadEnd: r, arrowheadStart: a } = e.props, s = e.props.bend + n;
  if (Math.abs(s) > Math.abs(e.props.bend * hQ))
    return pj(t, e);
  const c = Ou(t, e), f = O.Med(c.start, c.end), p = O.Sub(c.end, c.start).uni(), g = O.Add(f, p.per().mul(-s)), y = jx(t, e.props.start), v = jx(t, e.props.end), S = c.start.clone(), x = c.end.clone(), _ = g.clone(), T = _D(S, x, _), I = t.getPageTransform(e);
  if (y && !y.isExact) {
    const z = De.applyToPoint(I, S), F = De.applyToPoint(I, x), K = De.applyToPoint(I, T.center), X = De.Inverse(y.transform), se = De.applyToPoint(X, z), ue = De.applyToPoint(X, F), pe = De.applyToPoint(X, K), Pe = y.util.isClosed(y.shape), ve = Pe ? GO : XO;
    let Y, le = ve(
      pe,
      T.radius,
      y.util.outline(y.shape)
    );
    if (le) {
      le = le.filter(
        (de) => +O.Clockwise(se, de, ue) === T.sweepFlag
      );
      const Re = O.Angle(T.center, g), he = O.Angle(T.center, c.start), te = vp(Re, he, 0.5);
      le.sort(
        (de, W) => Math.abs(Wd(te, pe.angle(de))) - Math.abs(Wd(te, pe.angle(W)))
      ), Y = le[0] ?? (Pe ? void 0 : se);
    } else
      Y = Pe ? void 0 : se;
    if (Y && (S.setTo(
      t.getPointInShapeSpace(e, De.applyToPoint(y.transform, Y))
    ), y.didIntersect = !0, a !== "none")) {
      const Re = Ax + t.getStrokeWidth(e.props.size) / 2 + ("size" in y.shape.props ? t.getStrokeWidth(y.shape.props.size) / 2 : 0);
      S.setTo(
        Sp(
          T.center.x,
          T.center.y,
          T.radius,
          vp(
            O.Angle(T.center, S),
            O.Angle(T.center, g),
            Re / Math.abs(Ow(T.center, T.radius, S, g))
          )
        )
      );
    }
  }
  if (v && !v.isExact) {
    const z = De.applyToPoint(I, S), F = De.applyToPoint(I, x), K = De.applyToPoint(I, T.center), X = De.Inverse(v.transform), se = De.applyToPoint(X, z), ue = De.applyToPoint(X, F), pe = De.applyToPoint(X, K), Pe = v.util.isClosed(v.shape), ve = Pe ? GO : XO, Y = O.Angle(T.center, g), le = O.Angle(T.center, c.end), Re = vp(Y, le, 0.5);
    let he, te = ve(
      pe,
      T.radius,
      v.util.outline(v.shape)
    );
    if (te ? (te = te.filter(
      (de) => +O.Clockwise(se, de, ue) === T.sweepFlag
    ), te.sort(
      (de, W) => Math.abs(Wd(Re, pe.angle(de))) - Math.abs(Wd(Re, pe.angle(W)))
    ), he = te[0] ?? (Pe ? void 0 : ue)) : he = Pe ? void 0 : ue, he && (x.setTo(t.getPointInShapeSpace(e, De.applyToPoint(v.transform, he))), v.didIntersect = !0, r !== "none")) {
      let de = Ax + t.getStrokeWidth(e.props.size) / 2 + ("size" in v.shape.props ? t.getStrokeWidth(v.shape.props.size) / 2 : 0);
      O.Dist(S, x) < Pp && (de *= -2), x.setTo(
        Sp(
          T.center.x,
          T.center.y,
          T.radius,
          vp(
            O.Angle(T.center, x),
            O.Angle(T.center, g),
            de / Math.abs(Ow(T.center, T.radius, x, g))
          )
        )
      );
    }
  }
  if (Math.abs(Ow(T.center, T.radius, S, x)) < Pp / 2 && (S.setTo(c.start), x.setTo(c.end)), y && v && y.shape !== v.shape && !y.isExact && !v.isExact) {
    const z = O.Angle(T.center, S), F = O.Angle(T.center, x), K = T.sweepFlag ? Pp : -Pp, X = Ow(T.center, T.radius, x, S), {
      center: { x: se, y: ue },
      radius: pe
    } = T;
    y && !y.didIntersect && S.setTo(Sp(se, ue, pe, vp(z, F, K / X))), v && !v.didIntersect && x.setTo(Sp(se, ue, pe, vp(z, F, -K / X)));
  }
  let N = vp(O.Angle(T.center, S), O.Angle(T.center, x), 0.5), j = Sp(
    T.center.x,
    T.center.y,
    T.radius,
    N
  );
  +O.Clockwise(S, j, x) !== T.sweepFlag && (N += Kr, j = Sp(T.center.x, T.center.y, T.radius, N)), _.setTo(j);
  const L = _D(S, x, _);
  return {
    isStraight: !1,
    start: {
      point: S,
      handle: c.start,
      arrowhead: e.props.arrowheadStart
    },
    end: {
      point: x,
      handle: c.end,
      arrowhead: e.props.arrowheadEnd
    },
    middle: _,
    handleArc: T,
    bodyArc: L,
    isValid: L.length !== 0 && isFinite(L.center.x) && isFinite(L.center.y)
  };
}
function Gee(t) {
  const {
    start: e,
    end: n,
    handleArc: { radius: r, largeArcFlag: a, sweepFlag: s }
  } = t;
  return `M${e.handle.x},${e.handle.y} A${r} ${r} 0 ${a} ${s} ${n.handle.x},${n.handle.y}`;
}
function sk(t) {
  const {
    start: e,
    end: n,
    bodyArc: { radius: r, largeArcFlag: a, sweepFlag: s }
  } = t;
  return `M${e.point.x},${e.point.y} A${r} ${r} 0 ${a} ${s} ${n.point.x},${n.point.y}`;
}
function _D(t, e, n) {
  const r = -2 * (t.x * (e.y - n.y) - t.y * (e.x - n.x) + e.x * n.y - n.x * e.y), a = {
    x: ((t.x * t.x + t.y * t.y) * (n.y - e.y) + (e.x * e.x + e.y * e.y) * (t.y - n.y) + (n.x * n.x + n.y * n.y) * (e.y - t.y)) / r,
    y: ((t.x * t.x + t.y * t.y) * (e.x - n.x) + (e.x * e.x + e.y * e.y) * (n.x - t.x) + (n.x * n.x + n.y * n.y) * (t.x - e.x)) / r
  }, s = O.Dist(a, t), c = +O.Clockwise(t, n, e), f = Math.hypot(t.y - e.y, t.x - e.x), p = Math.hypot(e.y - n.y, e.x - n.x), g = Math.hypot(n.y - t.y, n.x - t.x), y = Math.acos((p * p + g * g - f * f) / (2 * p * g)) * 2, v = +(Kr > y), S = (Wr - y) * (c ? 1 : -1), x = S * s;
  return {
    center: a,
    radius: s,
    size: S,
    length: x,
    largeArcFlag: v,
    sweepFlag: c
  };
}
class Zr {
  static insertTextFirefox(e, n) {
    e.setRangeText(
      n,
      e.selectionStart || 0,
      e.selectionEnd || 0,
      "end"
      // Without this, the cursor is either at the beginning or text remains selected
    ), e.dispatchEvent(
      new InputEvent("input", {
        data: n,
        inputType: "insertText",
        isComposing: !1
        // TODO: fix @types/jsdom, this shouldn't be required
      })
    );
  }
  /**
   * Inserts text at the cursor’s position, replacing any selection, with **undo** support and by
   * firing the input event.
   */
  static insert(e, n) {
    const r = e.ownerDocument, a = r.activeElement;
    a !== e && e.focus(), r.execCommand("insertText", !1, n) || Zr.insertTextFirefox(e, n), a === r.body ? e.blur() : a instanceof HTMLElement && a !== e && a.focus();
  }
  /**
   * Replaces the entire content, equivalent to field.value = text but with **undo** support and by
   * firing the input event.
   */
  static set(e, n) {
    e.select(), Zr.insert(e, n);
  }
  /** Get the selected text in a field or an empty string if nothing is selected. */
  static getSelection(e) {
    const { selectionStart: n, selectionEnd: r } = e;
    return e.value.slice(
      n || void 0,
      r || void 0
    );
  }
  /**
   * Adds the wrappingText before and after field’s selection (or cursor). If endWrappingText is
   * provided, it will be used instead of wrappingText at on the right.
   */
  static wrapSelection(e, n, r) {
    const { selectionStart: a, selectionEnd: s } = e, c = Zr.getSelection(e);
    Zr.insert(e, n + c + (r ?? n)), e.selectionStart = (a || 0) + n.length, e.selectionEnd = (s || 0) + n.length;
  }
  /** Finds and replaces strings and regex in the field’s value. */
  static replace(e, n, r) {
    let a = 0;
    e.value.replace(n, (...s) => {
      const c = a + s[s.length - 2], f = s[0].length;
      e.selectionStart = c, e.selectionEnd = c + f;
      const p = typeof r == "string" ? r : r(...s);
      return Zr.insert(e, p), e.selectionStart = c, a += p.length - f, p;
    });
  }
  static findLineEnd(e, n) {
    const r = e.lastIndexOf(`
`, n - 1) + 1;
    return e.charAt(r) !== "	" ? n : r + 1;
  }
  static indent(e) {
    const { selectionStart: n, selectionEnd: r, value: a } = e, s = a.slice(n, r), c = /\n/g.exec(s)?.length;
    if (c && c > 0) {
      const f = a.lastIndexOf(`
`, n - 1) + 1, p = e.value.slice(f, r - 1), g = p.replace(
        /^|\n/g,
        // Match all line starts
        `$&${Zr.INDENT}`
      ), y = g.length - p.length;
      e.setSelectionRange(f, r - 1), Zr.insert(e, g), e.setSelectionRange(n + 1, r + y);
    } else
      Zr.insert(e, Zr.INDENT);
  }
  // The first line should always be unindented
  // The last line should only be unindented if the selection includes any characters after \n
  static unindent(e) {
    const { selectionStart: n, selectionEnd: r, value: a } = e, s = a.lastIndexOf(`
`, n - 1) + 1, c = Zr.findLineEnd(a, r), f = e.value.slice(s, c), p = f.replace(/(^|\n)(\t| {1,2})/g, "$1"), g = f.length - p.length;
    e.setSelectionRange(s, c), Zr.insert(e, p);
    const y = /\t| {1,2}/.exec(a.slice(s, n)), v = y ? y[0].length : 0, S = n - v;
    e.setSelectionRange(
      n - v,
      Math.max(S, r - g)
    );
  }
  static indentCE(e) {
    const n = window.getSelection(), r = e.innerText, a = jw(e) ?? 0, s = jw(e) ?? 0, c = r.slice(a, s), f = /\n/g.exec(c)?.length;
    if (f && f > 0) {
      const p = r.lastIndexOf(`
`, a - 1) + 1, g = r.slice(p, s - 1), v = g.replace(
        /^|\n/g,
        // Match all line starts
        `$&${Zr.INDENT}`
      ).length - g.length;
      n && n.setBaseAndExtent(
        e,
        a + 1,
        e,
        s + v
      );
    } else {
      const p = window.getSelection();
      e.innerText = r.slice(0, a) + Zr.INDENT + r.slice(a), p?.setBaseAndExtent(e, a + 1, e, a + 2);
    }
  }
  static unindentCE(e) {
    const n = window.getSelection(), r = e.innerText, a = jw(e) ?? 0, s = jw(e) ?? 0, c = r.lastIndexOf(`
`, a - 1) + 1, f = Zr.findLineEnd(r, s), p = r.slice(c, f), g = p.replace(/(^|\n)(\t| {1,2})/g, "$1"), y = p.length - g.length;
    if (n) {
      n.setBaseAndExtent(e, c, e, f);
      const v = /\t| {1,2}/.exec(r.slice(c, a)), S = v ? v[0].length : 0, x = a - S;
      n.setBaseAndExtent(
        e,
        a - S,
        e,
        Math.max(x, s - y)
      );
    }
  }
  static fixNewLines = /\r?\n|\r/g;
  static INDENT = "  ";
  static normalizeText(e) {
    return e.replace(Zr.fixNewLines, `
`);
  }
  static normalizeTextForDom(e) {
    return e.replace(Zr.fixNewLines, `
`).split(`
`).map((n) => n || " ").join(`
`);
  }
}
function jw(t) {
  if (typeof window.getSelection > "u")
    return;
  const e = window.getSelection();
  if (!e)
    return;
  let n = 0;
  if (e.rangeCount !== 0) {
    const r = e.getRangeAt(0), a = r.cloneRange();
    a.selectNodeContents(t), a.setEnd(r.endContainer, r.endOffset), n = a.toString().length;
  }
  return n;
}
function VI(t, e, n) {
  const r = Ge(), a = k.useRef(null), s = un("isEditing", () => r.pageState.editingId === t, [r, t]), c = k.useRef(!1), f = k.useRef(), p = un(
    "is editable hovering",
    () => {
      if (e === "text" && r.isIn("text") && r.hoveredId === t)
        return !0;
      if (r.isIn("select.editing_shape")) {
        const { editingShape: _ } = r;
        return _ ? (
          // The shape must be hovered
          // and this shape must be capable of being editing in its current form
          r.hoveredId === t && // the editing shape must be the same type as this shape
          _.type === e && r.getShapeUtil(_).canEdit(_)
        ) : !1;
      }
      return !1;
    },
    [e, t]
  ), g = k.useCallback(() => {
    p || requestAnimationFrame(() => {
      const _ = a.current;
      if (!_)
        return;
      const T = r.getShapeById(t);
      T && (_.value = T.props.text, _.value.length && !c.current && _.select(), c.current = !1);
    });
  }, [r, t, p]), y = k.useCallback(() => {
    const _ = f.current;
    requestAnimationFrame(() => {
      const T = a.current;
      if (r.isIn("select.editing_shape") && T)
        if (_)
          if (!_.length)
            T.focus();
          else {
            c.current = !0, T.focus();
            const I = window.getSelection();
            I && _.forEach((D) => I.addRange(D));
          }
        else
          T.focus();
      else
        window.getSelection()?.removeAllRanges(), r.complete();
    });
  }, [r]), v = k.useCallback(
    (_) => {
      switch ((_.ctrlKey || _.metaKey) && Pc(_), _.key) {
        case "Enter": {
          (_.ctrlKey || _.metaKey) && r.complete();
          break;
        }
        case "Tab": {
          Gn(_), _.shiftKey ? Zr.unindent(_.currentTarget) : Zr.indent(_.currentTarget);
          break;
        }
      }
    },
    [r]
  ), S = k.useCallback(
    (_) => {
      const T = Zr.normalizeText(_.currentTarget.value);
      r.updateShapes([{ id: t, type: e, props: { text: T } }]);
    },
    [r, t, e]
  ), x = n.trim().length === 0;
  return k.useEffect(() => {
    if (a.current) {
      let T = function() {
        const I = window.getSelection?.();
        if (I && I.type !== "None") {
          const D = [];
          if (I)
            for (let N = 0; N < I.rangeCount; N++)
              D.push(I.getRangeAt?.(N));
          f.current = D;
        }
      };
      return document.addEventListener("selectionchange", T), () => {
        document.removeEventListener("selectionchange", T);
      };
    }
  }), {
    rInput: a,
    isEditing: s,
    isEditableFromHover: p,
    handleFocus: g,
    handleBlur: y,
    handleKeyDown: v,
    handleChange: S,
    isEmpty: x
  };
}
const Xee = k.memo(function({
  id: e,
  text: n,
  size: r,
  font: a,
  position: s,
  width: c,
  labelColor: f
}) {
  const { rInput: p, isEditing: g, handleFocus: y, handleBlur: v, handleKeyDown: S, handleChange: x, isEmpty: _ } = VI(e, "arrow", n);
  return !g && _ ? null : /* @__PURE__ */ E.jsx(
    "div",
    {
      className: "rs-arrow-label",
      "data-font": a,
      "data-align": "center",
      "data-hastext": !_,
      "data-isediting": g,
      style: {
        textAlign: "center",
        fontSize: Vd[r],
        lineHeight: Vd[r] * Ki.lineHeight + "px",
        transform: `translate(${s.x}px, ${s.y}px)`,
        color: f
      },
      children: /* @__PURE__ */ E.jsxs("div", { className: "rs-arrow-label__inner", children: [
        /* @__PURE__ */ E.jsx("p", { style: { width: c || "9px" }, children: n ? Zr.normalizeTextForDom(n) : " " }),
        g && // Consider replacing with content-editable
        /* @__PURE__ */ E.jsx(
          "textarea",
          {
            ref: p,
            className: "rs-text rs-text-input",
            name: "text",
            tabIndex: -1,
            autoComplete: "false",
            autoCapitalize: "false",
            autoCorrect: "false",
            autoSave: "false",
            autoFocus: !0,
            placeholder: "",
            spellCheck: "true",
            wrap: "off",
            dir: "auto",
            datatype: "wysiwyg",
            defaultValue: n,
            onFocus: y,
            onChange: x,
            onKeyDown: S,
            onBlur: v,
            onContextMenu: Pc
          }
        )
      ] })
    }
  );
});
var qee = Object.defineProperty, Qee = Object.getOwnPropertyDescriptor, gj = (t, e, n, r) => {
  for (var a = r > 1 ? void 0 : r ? Qee(e, n) : e, s = t.length - 1, c; s >= 0; s--)
    (c = t[s]) && (a = (r ? c(e, n, a) : c(a)) || a);
  return r && a && qee(e, n, a), a;
};
let Zee = 0;
class YI extends Oc {
  static type = "arrow";
  canEdit = () => !0;
  canBind = () => !1;
  isClosed = () => !1;
  hideResizeHandles = () => !0;
  hideRotateHandle = () => !0;
  hideSelectionBoundsFg = () => !0;
  hideSelectionBoundsBg = () => !0;
  defaultProps() {
    return {
      opacity: "1",
      dash: "draw",
      size: "m",
      fill: "none",
      color: "black",
      labelColor: "black",
      bend: 0,
      start: { type: "point", x: 0, y: 0 },
      end: { type: "point", x: 0, y: 0 },
      arrowheadStart: "none",
      arrowheadEnd: "arrow",
      text: "",
      font: "draw"
    };
  }
  getCenter(e) {
    return this.bounds(e).center;
  }
  getBounds(e) {
    return ot.FromPoints(this.getOutlineWithoutLabel(e));
  }
  getOutlineWithoutLabel(e) {
    const n = this.getArrowInfo(e);
    if (!n)
      return [];
    if (n.isStraight)
      return n.isValid ? [n.start.point, n.end.point] : [new O(0, 0), new O(1, 1)];
    if (!n.isValid)
      return [new O(0, 0), new O(1, 1)];
    const r = Math.max(5, Math.ceil(Math.abs(n.bodyArc.length) / 16));
    if (r <= 0 && !isFinite(r))
      return [new O(0, 0), new O(1, 1)];
    const a = Array(r), s = O.Angle(n.bodyArc.center, n.start.point), c = O.Angle(n.bodyArc.center, n.end.point), f = n.bodyArc.sweepFlag ? c : s, p = n.bodyArc.sweepFlag ? s : c, g = n.bodyArc.largeArcFlag ? -Bq(f, p) : Wd(f, p), y = Math.max(1, n.bodyArc.radius);
    for (let v = 0; v < r; v++) {
      const S = v / (r - 1), x = f + g * S, _ = Sp(n.bodyArc.center.x, n.bodyArc.center.y, y, x);
      a[v] = _;
    }
    return a;
  }
  getOutline(e) {
    const n = this.getOutlineWithoutLabel(e), r = this.getLabelBounds(e);
    if (!r)
      return n;
    const a = r.sides, s = [0, 1, 2, 3];
    let c = n[0], f = !1;
    const p = [c];
    for (let g = 1; g < n.length; g++) {
      const y = n[g];
      if (!f) {
        const v = HG(
          s.filter(
            (S) => ef(a[S][0], a[S][1], c, y)
          ),
          (S) => O.DistanceToLineSegment(a[S][0], a[S][1], c)
        );
        if (v !== void 0) {
          const S = O.NearestPointOnLineSegment(
            a[v][0],
            a[v][1],
            c
          );
          p.push(S);
          for (let x = 0; x < 4; x++) {
            const _ = (v + x) % 4;
            p.push(a[_][1]);
          }
          p.push(S), f = !0;
        }
      }
      p.push(y), c = y;
    }
    return p;
  }
  snapPoints(e) {
    return Ws;
  }
  get infoCache() {
    return this.app.store.createComputedCache(
      "arrow infoCache",
      (e) => Yee(e) ? pj(this.app, e) : Wee(this.app, e)
    );
  }
  getArrowInfo(e) {
    return this.infoCache.get(e.id);
  }
  getHandles(e) {
    const n = this.infoCache.get(e.id);
    return [
      {
        id: "start",
        type: "vertex",
        index: "a0",
        x: n.start.handle.x,
        y: n.start.handle.y,
        canBind: !0
      },
      {
        id: "middle",
        type: "vertex",
        index: "a2",
        x: n.middle.x,
        y: n.middle.y,
        canBind: !1
      },
      {
        id: "end",
        type: "vertex",
        index: "a3",
        x: n.end.handle.x,
        y: n.end.handle.y,
        canBind: !0
      }
    ];
  }
  onHandleChange = (e, { handle: n, isPrecise: r }) => {
    const a = Tc(e);
    switch (n.id) {
      case "start":
      case "end": {
        const s = this.app.getPageTransformById(a.id), c = De.applyToPoint(s, n), f = this.app.inputs.ctrlKey ? void 0 : Hs(
          this.app.getShapesAtPoint(c).filter((p) => {
            if (p.id === e.id)
              return;
            const g = this.app.getShapeUtil(p);
            return g.canBind(a) && g.hitTestPoint(
              p,
              this.app.getPointInShapeSpace(p, c)
            );
          })
        );
        if (f) {
          const p = this.app.getBounds(f), g = this.app.getPointInShapeSpace(f, c), y = a.props[n.id], v = a.props.start.type === "binding" && a.props.start.boundShapeId, S = a.props.end.type === "binding" && a.props.end.boundShapeId;
          let x = (
            // If externally precise, then always precise
            // If the other shape is not closed, then precise
            r || // If the other handle is bound to the same shape, then precise
            (v || S) && v === S || !this.app.getShapeUtil(f).isClosed(a)
          );
          // If we're switching to a new bound shape, then precise only if moving slowly
          (y.type === "point" || y.type === "binding" && f.id !== y.boundShapeId) && (x = this.app.inputs.pointerVelocity.len() < 0.5), x && (x = O.Dist(g, p.center) > Math.max(4, Math.min(Math.min(p.width, p.height) * 0.15, 16)) / this.app.zoomLevel), a.props[n.id] = {
            type: "binding",
            boundShapeId: f.id,
            normalizedAnchor: x ? {
              x: (g.x - p.minX) / p.width,
              y: (g.y - p.minY) / p.height
            } : { x: 0.5, y: 0.5 },
            isExact: this.app.inputs.altKey
          };
        } else
          a.props[n.id] = {
            type: "point",
            x: n.x,
            y: n.y
          };
        break;
      }
      case "middle": {
        const { start: s, end: c } = Ou(this.app, a), f = O.Sub(c, s), p = O.Per(f), g = O.Med(c, s), y = O.Sub(g, p), v = O.Add(g, p), S = O.NearestPointOnLineSegment(y, v, n, !1);
        let x = O.Dist(S, g);
        O.Clockwise(S, c, g) && (x *= -1), a.props.bend = x;
        break;
      }
    }
    return a;
  };
  onTranslateStart = (e) => {
    let n = e.props.start.type === "binding" ? e.props.start.boundShapeId : null, r = e.props.end.type === "binding" ? e.props.end.boundShapeId : null;
    if (n && this.app.isWithinSelection(n) || r && this.app.isWithinSelection(r))
      return;
    n = null, r = null;
    const { start: a, end: s } = Ou(this.app, e);
    return {
      id: e.id,
      type: e.type,
      props: {
        ...e.props,
        start: {
          type: "point",
          x: a.x,
          y: a.y
        },
        end: {
          type: "point",
          x: s.x,
          y: s.y
        }
      }
    };
  };
  onResize = (e, n) => {
    const { scaleX: r, scaleY: a } = n, s = Ou(this.app, e);
    let { start: c, end: f } = e.props;
    if (c.type === "point") {
      const y = s.start.x * r, v = s.start.y * a;
      c = { ...c, x: y, y: v };
    }
    if (f.type === "point") {
      const y = s.end.x * r, v = s.end.y * a;
      f = { ...f, x: y, y: v };
    }
    let p = e.props.bend;
    if (p !== 0) {
      const y = Math.abs(r), v = Math.abs(a);
      r < 0 && a >= 0 || r >= 0 && a < 0 ? (p *= -1, p *= Math.max(y, v)) : (r >= 0 && a >= 0 || r < 0 && a < 0) && (p *= Math.max(y, v));
    }
    return {
      props: {
        start: c,
        end: f,
        bend: p
      }
    };
  };
  onDoubleClickHandle = (e, n) => {
    switch (n.id) {
      case "start":
        return {
          id: e.id,
          type: e.type,
          props: {
            ...e.props,
            arrowheadStart: e.props.arrowheadStart === "none" ? "arrow" : "none"
          }
        };
      case "end":
        return {
          id: e.id,
          type: e.type,
          props: {
            ...e.props,
            arrowheadEnd: e.props.arrowheadEnd === "none" ? "arrow" : "none"
          }
        };
    }
  };
  hitTestPoint(e, n) {
    const r = this.outline(e);
    for (let a = 0; a < r.length - 1; a++) {
      const s = r[a], c = r[a + 1];
      if (O.DistanceToLineSegment(s, c, n) < 4)
        return !0;
    }
    return !1;
  }
  hitTestLineSegment(e, n, r) {
    const a = this.outline(e);
    for (let s = 0; s < a.length - 1; s++) {
      const c = a[s], f = a[s + 1];
      if (ef(n, r, c, f))
        return !0;
    }
    return !1;
  }
  render(e) {
    const n = this.app.onlySelectedShape, r = this.app.isInAny(
      "select.idle",
      "select.pointing_handle",
      "select.dragging_handle",
      "arrow.dragging"
    ) && !this.app.isReadOnly, a = this.getArrowInfo(e), s = this.bounds(e), c = this.getLabelBounds(e), f = k.useMemo(() => this.app.isSafari ? Zee += 1 : 0, [e]);
    if (!a?.isValid)
      return null;
    const p = this.app.getStrokeWidth(e.props.size), g = a.start.arrowhead && Ng(a, "start", p), y = a.end.arrowhead && Ng(a, "end", p), v = a.isStraight ? ak(a) : sk(a);
    let S = null;
    if (n === e && r) {
      const { strokeDasharray: L, strokeDashoffset: z } = Gs(
        a.isStraight ? O.Dist(a.start.handle, a.end.handle) : Math.abs(a.handleArc.length),
        2,
        {
          end: "skip",
          start: "skip",
          lengthRatio: 2.5
        }
      );
      S = e.props.start.type === "binding" || e.props.end.type === "binding" ? /* @__PURE__ */ E.jsx(
        "path",
        {
          className: "rs-arrow-hint",
          d: a.isStraight ? Kee(a) : Gee(a),
          strokeDasharray: L,
          strokeDashoffset: z,
          strokeWidth: 2,
          markerStart: e.props.start.type === "binding" ? e.props.start.isExact ? "" : PD(e.props.start.normalizedAnchor) ? "url(#arrowhead-cross)" : "url(#arrowhead-dot)" : "",
          markerEnd: e.props.end.type === "binding" ? e.props.end.isExact ? "" : PD(e.props.end.normalizedAnchor) ? "url(#arrowhead-cross)" : "url(#arrowhead-dot)" : "",
          opacity: 0.16
        }
      ) : null;
    }
    const { strokeDasharray: x, strokeDashoffset: _ } = Gs(
      a.isStraight ? a.length : Math.abs(a.bodyArc.length),
      p,
      {
        style: e.props.dash
      }
    ), T = !(a.start.arrowhead === "none" || a.start.arrowhead === "arrow"), I = !(a.end.arrowhead === "none" || a.end.arrowhead === "arrow"), D = T || I || c, N = (e.id + "_clip_" + f).replace(":", "_");
    return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsxs(Mp, { id: e.id, style: { minWidth: 50, minHeight: 50 }, children: [
        D && /* @__PURE__ */ E.jsx("defs", { children: /* @__PURE__ */ E.jsxs("mask", { id: N, children: [
          /* @__PURE__ */ E.jsx(
            "rect",
            {
              x: ze(-100 + s.minX),
              y: ze(-100 + s.minY),
              width: ze(s.width + 200),
              height: ze(s.height + 200),
              fill: "white"
            }
          ),
          c && /* @__PURE__ */ E.jsx(
            "rect",
            {
              x: ze(c.x),
              y: ze(c.y),
              width: ze(c.w),
              height: ze(c.h),
              fill: "black",
              rx: 4,
              ry: 4
            }
          ),
          g && T && /* @__PURE__ */ E.jsx(
            "path",
            {
              d: g,
              fill: a.start.arrowhead === "arrow" ? "none" : "black",
              stroke: "none"
            }
          ),
          y && I && /* @__PURE__ */ E.jsx(
            "path",
            {
              d: y,
              fill: a.end.arrowhead === "arrow" ? "none" : "black",
              stroke: "none"
            }
          )
        ] }) }),
        /* @__PURE__ */ E.jsxs(
          "g",
          {
            fill: "none",
            stroke: "currentColor",
            strokeWidth: p,
            strokeLinejoin: "round",
            strokeLinecap: "round",
            pointerEvents: "none",
            children: [
              S,
              /* @__PURE__ */ E.jsxs("g", { ...D ? { mask: `url(#${N})` } : void 0, children: [
                D && /* @__PURE__ */ E.jsx(
                  "rect",
                  {
                    x: ze(s.minX - 100),
                    y: ze(s.minY - 100),
                    width: ze(s.width + 200),
                    height: ze(s.height + 200),
                    opacity: 0
                  }
                ),
                /* @__PURE__ */ E.jsx(
                  "path",
                  {
                    d: v,
                    strokeDasharray: x,
                    strokeDashoffset: _
                  }
                )
              ] }),
              g && T && e.props.fill !== "none" && /* @__PURE__ */ E.jsx(gs, { d: g, color: e.props.color, fill: e.props.fill }),
              y && I && e.props.fill !== "none" && /* @__PURE__ */ E.jsx(gs, { d: y, color: e.props.color, fill: e.props.fill }),
              g && /* @__PURE__ */ E.jsx("path", { d: g }),
              y && /* @__PURE__ */ E.jsx("path", { d: y })
            ]
          }
        ),
        /* @__PURE__ */ E.jsx("path", { d: v, className: "rs-hitarea-stroke" })
      ] }),
      /* @__PURE__ */ E.jsx(
        Xee,
        {
          id: e.id,
          text: e.props.text,
          font: e.props.font,
          size: e.props.size,
          position: a.middle,
          width: c?.w ?? 0,
          labelColor: this.app.getCssColor(e.props.labelColor)
        }
      )
    ] });
  }
  indicator(e) {
    const { start: n, end: r } = Ou(this.app, e), a = this.getArrowInfo(e), s = this.bounds(e), c = this.getLabelBounds(e);
    if (!a || O.Equals(n, r))
      return null;
    const f = this.app.getStrokeWidth(e.props.size), p = a.start.arrowhead && Ng(a, "start", f), g = a.end.arrowhead && Ng(a, "end", f), y = a.isStraight ? ak(a) : sk(a), v = p && a.start.arrowhead !== "arrow" || g && a.end.arrowhead !== "arrow" || c !== null, S = (e.id + "_clip").replace(":", "_");
    return /* @__PURE__ */ E.jsxs("g", { children: [
      v && /* @__PURE__ */ E.jsx("defs", { children: /* @__PURE__ */ E.jsxs("mask", { id: S, children: [
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            x: s.minX - 100,
            y: s.minY - 100,
            width: s.w + 200,
            height: s.h + 200,
            fill: "white"
          }
        ),
        c && /* @__PURE__ */ E.jsx(
          "rect",
          {
            x: c.x,
            y: c.y,
            width: c.w,
            height: c.h,
            fill: "black",
            rx: 4,
            ry: 4
          }
        ),
        p && /* @__PURE__ */ E.jsx(
          "path",
          {
            d: p,
            fill: a.start.arrowhead === "arrow" ? "none" : "black",
            stroke: "none"
          }
        ),
        g && /* @__PURE__ */ E.jsx(
          "path",
          {
            d: g,
            fill: a.end.arrowhead === "arrow" ? "none" : "black",
            stroke: "none"
          }
        )
      ] }) }),
      /* @__PURE__ */ E.jsxs("g", { ...v ? { mask: `url(#${S})` } : void 0, children: [
        v && /* @__PURE__ */ E.jsx(
          "rect",
          {
            x: s.minX - 100,
            y: s.minY - 100,
            width: s.width + 200,
            height: s.height + 200,
            opacity: 0
          }
        ),
        /* @__PURE__ */ E.jsx("path", { d: y })
      ] }),
      p && /* @__PURE__ */ E.jsx("path", { d: p }),
      g && /* @__PURE__ */ E.jsx("path", { d: g }),
      c && /* @__PURE__ */ E.jsx(
        "rect",
        {
          x: c.x,
          y: c.y,
          width: c.w,
          height: c.h,
          rx: 4,
          ry: 4
        }
      )
    ] });
  }
  get labelBoundsCache() {
    return this.app.store.createComputedCache("labelBoundsCache", (e) => {
      const n = this.getArrowInfo(e), r = this.bounds(e), { text: a, font: s, size: c } = e.props;
      if (!n || !a.trim())
        return null;
      const { w: f, h: p } = this.app.textMeasure.measureText({
        ...Ki,
        text: a,
        fontFamily: qd[s],
        fontSize: Vd[c],
        width: "fit-content"
      });
      let g = f, y = p;
      if (r.width > r.height) {
        g = Math.max(Math.min(f, 64), Math.min(r.width - 64, f));
        const { w: v, h: S } = this.app.textMeasure.measureText({
          ...Ki,
          text: a,
          fontFamily: qd[s],
          fontSize: Vd[c],
          width: g + "px"
        });
        g = v, y = S;
      }
      if (g > 16 * Vd[c]) {
        g = 16 * Vd[c];
        const { w: v, h: S } = this.app.textMeasure.measureText({
          ...Ki,
          text: a,
          fontFamily: qd[s],
          fontSize: Vd[c],
          width: g + "px"
        });
        g = v, y = S;
      }
      return new ot(
        n.middle.x - (g + 8) / 2,
        n.middle.y - (y + 8) / 2,
        g + 8,
        y + 8
      );
    });
  }
  getLabelBounds(e) {
    return this.labelBoundsCache.get(e.id) || null;
  }
  getEditingBounds = (e) => this.getLabelBounds(e) ?? new ot();
  onEditEnd = (e) => {
    const {
      id: n,
      type: r,
      props: { text: a }
    } = e;
    a.trim() !== e.props.text && this.app.updateShapes([
      {
        id: n,
        type: r,
        props: {
          text: a.trim()
        }
      }
    ]);
  };
  toSvg(e, n, r) {
    const a = r.fill[e.props.color], s = this.getArrowInfo(e), c = this.app.getStrokeWidth(e.props.size), f = document.createElementNS("http://www.w3.org/2000/svg", "g");
    if (!s)
      return f;
    const p = s.start.arrowhead && Ng(s, "start", c), g = s.end.arrowhead && Ng(s, "end", c), y = this.bounds(e), v = this.getLabelBounds(e), S = (e.id + "_clip").replace(":", "_");
    if (p || g) {
      const N = document.createElementNS("http://www.w3.org/2000/svg", "defs"), j = document.createElementNS("http://www.w3.org/2000/svg", "mask");
      j.id = S;
      const L = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      if (L.setAttribute("x", y.minX - 100 + ""), L.setAttribute("y", y.minY - 100 + ""), L.setAttribute("width", y.width + 200 + ""), L.setAttribute("height", y.height + 200 + ""), L.setAttribute("fill", "white"), j.appendChild(L), p && j.appendChild(TD(p, s.start.arrowhead)), g && j.appendChild(TD(g, s.end.arrowhead)), v) {
        const z = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        z.setAttribute("x", v.x + ""), z.setAttribute("y", v.y + ""), z.setAttribute("width", v.w + ""), z.setAttribute("height", v.h + ""), z.setAttribute("fill", "black"), j.appendChild(z);
      }
      N.appendChild(j), f.appendChild(N);
    }
    const x = document.createElementNS("http://www.w3.org/2000/svg", "g");
    x.setAttribute("mask", `url(#${S})`), f.appendChild(x);
    const _ = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    _.setAttribute("x", "-100"), _.setAttribute("y", "-100"), _.setAttribute("width", y.width + 200 + ""), _.setAttribute("height", y.height + 200 + ""), _.setAttribute("fill", "transparent"), _.setAttribute("stroke", "none"), x.appendChild(_);
    const T = Jee(
      s.isStraight ? ak(s) : sk(s),
      a,
      c
    ), { strokeDasharray: I, strokeDashoffset: D } = Gs(
      s.isStraight ? s.length : Math.abs(s.bodyArc.length),
      c,
      {
        style: e.props.dash
      }
    );
    if (T.setAttribute("stroke-dasharray", I), T.setAttribute("stroke-dashoffset", D), x.appendChild(T), p && f.appendChild(
      kD(
        p,
        e.props.color,
        c,
        e.props.arrowheadStart === "arrow" ? "none" : e.props.fill,
        r
      )
    ), g && f.appendChild(
      kD(
        g,
        e.props.color,
        c,
        e.props.arrowheadEnd === "arrow" ? "none" : e.props.fill,
        r
      )
    ), v) {
      const N = {
        fontSize: Vd[e.props.size],
        lineHeight: Ki.lineHeight,
        fontFamily: n,
        padding: 0,
        textAlign: "middle",
        width: v.w,
        height: v.h,
        fontStyle: "normal",
        fontWeight: "normal"
      }, j = this.app.textMeasure.getTextLines({
        text: e.props.text,
        wrap: !0,
        ...N,
        width: v.w - 8
      }), L = m1(this.app, {
        lines: j,
        ...N,
        width: v.w - 8
      });
      L.setAttribute("fill", r.fill[e.props.labelColor]), Array.from(L.children).forEach((F) => {
        const K = parseFloat(F.getAttribute("x") || "0"), X = parseFloat(F.getAttribute("y") || "0");
        F.setAttribute("x", K + 4 + v.x + "px"), F.setAttribute("y", X + v.y + "px");
      }), f.appendChild(L);
    }
    return f;
  }
}
gj([
  pt
], YI.prototype, "infoCache", 1);
gj([
  pt
], YI.prototype, "labelBoundsCache", 1);
function TD(t, e) {
  const n = document.createElementNS("http://www.w3.org/2000/svg", "path");
  return n.setAttribute("d", t), n.setAttribute("fill", e === "arrow" ? "none" : "black"), n.setAttribute("stroke", "none"), n;
}
function Jee(t, e, n) {
  const r = document.createElementNS("http://www.w3.org/2000/svg", "path");
  return r.setAttribute("d", t), r.setAttribute("fill", "none"), r.setAttribute("stroke", e), r.setAttribute("stroke-width", n + ""), r;
}
function kD(t, e, n, r, a) {
  const s = document.createElementNS("http://www.w3.org/2000/svg", "path");
  s.setAttribute("d", t), s.setAttribute("fill", "none"), s.setAttribute("stroke", a.fill[e]), s.setAttribute("stroke-width", n + "");
  const c = Ac({
    d: t,
    fill: r,
    color: e,
    colors: a
  });
  if (c) {
    const f = document.createElementNS("http://www.w3.org/2000/svg", "g");
    return f.appendChild(c), f.appendChild(s), f;
  } else
    return s;
}
function PD(t) {
  return t.x !== 0.5 || t.y !== 0.5;
}
const ro = gi({
  type: "arrow",
  getShapeUtil: () => YI,
  validator: hq,
  migrations: gq
});
function ha({ children: t, className: e = "", ...n }) {
  return /* @__PURE__ */ E.jsx("div", { ...n, className: `rs-html-container ${e}`, children: t });
}
const ID = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E";
function Tb({ url: t }) {
  const {
    camera: { z: e }
  } = Ge();
  return /* @__PURE__ */ E.jsx(
    "a",
    {
      className: `rs-hyperlink-button ${e < 0.5 ? "hidden" : ""}`,
      href: t,
      target: "_blank",
      rel: "noopener noreferrer",
      onPointerDown: Pc,
      onPointerUp: Pc,
      title: t,
      draggable: !1,
      children: /* @__PURE__ */ E.jsx(
        "div",
        {
          className: "rs-hyperlink-button__icon",
          style: {
            mask: `url("${ID}") center 100% / 100% no-repeat`,
            WebkitMask: `url("${ID}") center 100% / 100% no-repeat`
          }
        }
      )
    }
  );
}
const mj = (t, e, n = {}) => {
  const { newPoint: r, handle: a, scaleX: s, scaleY: c } = e, { minWidth: f = 1, maxWidth: p = 1 / 0, minHeight: g = 1, maxHeight: y = 1 / 0 } = n;
  let v = t.props.w * s, S = t.props.h * c;
  const x = new O(0, 0);
  if (v > 0) {
    if (v < f) {
      switch (a) {
        case "top_left":
        case "left":
        case "bottom_left": {
          x.x = v - f;
          break;
        }
        case "top":
        case "bottom": {
          x.x = (v - f) / 2;
          break;
        }
        default:
          x.x = 0;
      }
      v = f;
    }
  } else if (x.x = v, v = -v, v < f) {
    switch (a) {
      case "top_left":
      case "left":
      case "bottom_left": {
        x.x = -v;
        break;
      }
      default:
        x.x = -f;
    }
    v = f;
  }
  if (S > 0) {
    if (S < g) {
      switch (a) {
        case "top_left":
        case "top":
        case "top_right": {
          x.y = S - g;
          break;
        }
        case "right":
        case "left": {
          x.y = (S - g) / 2;
          break;
        }
        default:
          x.y = 0;
      }
      S = g;
    }
  } else if (x.y = S, S = -S, S < g) {
    switch (a) {
      case "top_left":
      case "top":
      case "top_right": {
        x.y = -S;
        break;
      }
      default:
        x.y = -g;
    }
    S = g;
  }
  const { x: _, y: T } = x.rot(t.rotation).add(r);
  return {
    x: _,
    y: T,
    props: {
      w: Math.min(p, v),
      h: Math.min(y, S)
    }
  };
};
class ya extends Oc {
  getBounds(e) {
    return new ot(0, 0, e.props.w, e.props.h);
  }
  getCenter(e) {
    return new O(e.props.w / 2, e.props.h / 2);
  }
  getOutline(e) {
    return this.bounds(e).corners;
  }
  hitTestPoint(e, n) {
    return Uu(n, this.outline(e));
  }
  hitTestLineSegment(e, n, r) {
    const a = this.outline(e);
    for (let s = 0; s < a.length; s++) {
      const c = a[s], f = a[(s + 1) % a.length];
      if (ef(n, r, c, f))
        return !0;
    }
    return !1;
  }
  onResize = (e, n) => mj(e, n);
}
class ete extends ya {
  static type = "bookmark";
  canResize = () => !1;
  hideSelectionBoundsBg = () => !0;
  hideSelectionBoundsFg = () => !0;
  defaultProps() {
    return {
      opacity: "1",
      url: "",
      w: DL,
      h: NL,
      assetId: null
    };
  }
  render(e) {
    const n = e.props.assetId ? this.app.getAssetById(e.props.assetId) : null, r = this.app.getPageRotation(e), a = this.getHumanReadableAddress(e);
    return /* @__PURE__ */ E.jsx(ha, { children: /* @__PURE__ */ E.jsxs(
      "div",
      {
        className: "rs-bookmark__container rs-hitarea-stroke",
        style: {
          boxShadow: zI(r, $I)
        },
        children: [
          /* @__PURE__ */ E.jsxs("div", { className: "rs-bookmark__image_container", children: [
            n?.props.image ? /* @__PURE__ */ E.jsx(
              "img",
              {
                className: "rs-bookmark__image",
                draggable: !1,
                src: n?.props.image,
                alt: n?.props.title || ""
              }
            ) : /* @__PURE__ */ E.jsx("div", { className: "rs-bookmark__placeholder" }),
            /* @__PURE__ */ E.jsx(Tb, { url: e.props.url })
          ] }),
          /* @__PURE__ */ E.jsxs("div", { className: "rs-bookmark__copy_container", children: [
            n?.props.title && /* @__PURE__ */ E.jsx("h2", { className: "rs-bookmark__heading", children: tk(n?.props.title || "", 54) }),
            n?.props.description && /* @__PURE__ */ E.jsx("p", { className: "rs-bookmark__description", children: tk(n?.props.description || "", 128) }),
            /* @__PURE__ */ E.jsx(
              "a",
              {
                className: "rs-bookmark__link",
                href: e.props.url || "",
                target: "_blank",
                rel: "noopener noreferrer",
                onPointerDown: Pc,
                onPointerUp: Pc,
                onClick: Pc,
                children: tk(a, 45)
              }
            )
          ] })
        ]
      }
    ) });
  }
  indicator(e) {
    return /* @__PURE__ */ E.jsx(
      "rect",
      {
        width: ze(e.props.w),
        height: ze(e.props.h),
        rx: "8",
        ry: "8"
      }
    );
  }
  onBeforeCreate = (e) => {
    this.updateBookmarkAsset(e);
  };
  onBeforeUpdate = (e, n) => {
    e.props.url !== n.props.url && this.updateBookmarkAsset(n);
  };
  getHumanReadableAddress(e) {
    try {
      const n = new URL(e.props.url), r = n.pathname.replace(/\/*$/, "");
      return `${n.hostname}${r}`;
    } catch {
      return e.props.url;
    }
  }
  updateBookmarkAsset = fI((e) => {
    const { url: n } = e.props, r = cm.createCustomId(i1(n)), a = this.app.getAssetById(r);
    a ? e.props.assetId !== a.id && this.app.updateShapes([
      {
        id: e.id,
        type: e.type,
        props: { assetId: r }
      }
    ]) : this.app.onCreateBookmarkFromUrl && this.app.onCreateBookmarkFromUrl(n).then((s) => {
      if (!s) {
        this.app.updateShapes([
          {
            id: e.id,
            type: e.type,
            props: { assetId: void 0 }
          }
        ]);
        return;
      }
      this.app.batch(() => {
        this.app.createAssets([
          {
            id: r,
            typeName: "asset",
            type: "bookmark",
            props: {
              src: n,
              description: s.description,
              image: s.image,
              title: s.title
            }
          }
        ]).updateShapes([
          {
            id: e.id,
            type: e.type,
            props: { assetId: r }
          }
        ]);
      });
    });
  }, 500);
}
const v1 = gi({
  type: "bookmark",
  getShapeUtil: () => ete,
  validator: mq,
  migrations: vq
}), tte = (t) => t * 0.65 + Uq(t * Kr / 2) * 0.35, nte = (t) => ({
  size: 1 + t,
  thinning: 0.5,
  streamline: 0.62 + (1 + t) / 8 * 0.06,
  smoothing: 0.62,
  easing: fa.easeOutSine,
  simulatePressure: !0
}), rte = (t) => ({
  size: 1 + t * 1.2,
  thinning: 0.62,
  streamline: 0.62,
  smoothing: 0.62,
  simulatePressure: !1,
  easing: tte
}), RD = (t) => ({
  size: 1 + t,
  thinning: 0,
  streamline: 0.62 + (1 + t) / 8 * 0.06,
  smoothing: 0.62,
  simulatePressure: !1,
  easing: fa.linear
});
function lk(t, e, n, r) {
  return {
    ...r ? RD(e) : t.props.dash === "draw" ? t.props.isPen ? rte(e) : nte(e) : RD(e),
    last: t.props.isComplete || n
  };
}
function zw(t) {
  const e = [];
  for (const n of t)
    if (n.type === "free" || n.points.length < 2)
      e.push(...n.points.map(O.Cast));
    else {
      const r = Math.max(
        4,
        Math.floor(O.Dist(n.points[0], n.points[1]) / 16)
      );
      e.push(...O.PointsBetween(n.points[0], n.points[1], r));
    }
  return e;
}
function $D(t, e) {
  return {
    draw: "none",
    solid: "none",
    dotted: `0.1 ${e * 2}`,
    dashed: `${e * 2} ${e * 2}`
  }[t.props.dash];
}
class ite extends Oc {
  static type = "draw";
  hideResizeHandles = (e) => this.getIsDot(e);
  hideRotateHandle = (e) => this.getIsDot(e);
  hideSelectionBoundsBg = (e) => this.getIsDot(e);
  hideSelectionBoundsFg = (e) => this.getIsDot(e);
  defaultProps() {
    return {
      segments: [],
      color: "black",
      fill: "none",
      dash: "draw",
      size: "m",
      opacity: "1",
      isComplete: !1,
      isClosed: !1,
      isPen: !1
    };
  }
  isClosed = (e) => e.props.isClosed;
  getIsDot(e) {
    return e.props.segments.length === 1 && e.props.segments[0].points.length < 2;
  }
  getBounds(e) {
    return ot.FromPoints(this.outline(e));
  }
  getOutline(e) {
    return zw(e.props.segments);
  }
  getCenter(e) {
    return this.bounds(e).center;
  }
  hitTestPoint(e, n) {
    const r = this.outline(e), a = this.app.zoomLevel, s = this.app.getStrokeWidth(e.props.size) / a;
    if (e.props.segments.length === 1 && e.props.segments[0].points.length < 4 && e.props.segments[0].points.some((c) => O.Dist(n, c) < s * 1.5))
      return !0;
    if (this.isClosed(e))
      return Uu(n, r);
    for (let c = 0; c < r.length; c++) {
      const f = r[c], p = r[(c + 1) % r.length];
      if (O.DistanceToLineSegment(f, p, n) < s)
        return !0;
    }
    return !1;
  }
  hitTestLineSegment(e, n, r) {
    const a = this.outline(e);
    if (e.props.segments.length === 1 && e.props.segments[0].points.length < 4) {
      const s = this.app.zoomLevel, c = this.app.getStrokeWidth(e.props.size) / s;
      if (e.props.segments[0].points.some(
        (f) => O.DistanceToLineSegment(n, r, f) < c * 1.5
      ))
        return !0;
    }
    if (this.isClosed(e))
      for (let s = 0; s < a.length; s++) {
        const c = a[s], f = a[(s + 1) % a.length];
        if (ef(n, r, c, f))
          return !0;
      }
    else
      for (let s = 0; s < a.length - 1; s++) {
        const c = a[s], f = a[s + 1];
        if (ef(n, r, c, f))
          return !0;
      }
    return !1;
  }
  render(e) {
    const n = un("zoom", () => this.app.zoomLevel < 0.35, []), r = this.app.getStrokeWidth(e.props.size), a = zw(e.props.segments), s = e.props.isComplete || Hs(e.props.segments)?.type === "straight";
    let c = r;
    !e.props.isPen && e.props.dash === "draw" && a.length === 1 && (c += By(e.id)() * (r / 6));
    const f = lk(e, c, s, n), p = kc(a, f), g = p.length > 1 ? Qd(p, e.props.isClosed) : ck(a[0], c);
    if (!n && e.props.dash === "draw" || p.length < 2) {
      Jy(p, f);
      const y = Zy(p, f);
      return /* @__PURE__ */ E.jsxs(Mp, { id: e.id, children: [
        /* @__PURE__ */ E.jsx(
          gs,
          {
            fill: e.props.isClosed ? e.props.fill : "none",
            color: e.props.color,
            d: g
          }
        ),
        /* @__PURE__ */ E.jsx(
          "path",
          {
            d: nf(y, !0),
            strokeLinecap: "round",
            fill: "currentColor"
          }
        )
      ] });
    }
    return /* @__PURE__ */ E.jsxs(Mp, { id: e.id, children: [
      /* @__PURE__ */ E.jsx(
        gs,
        {
          color: e.props.color,
          fill: e.props.isClosed ? e.props.fill : "none",
          d: g
        }
      ),
      /* @__PURE__ */ E.jsx(
        "path",
        {
          d: g,
          strokeLinecap: "round",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: r,
          strokeDasharray: $D(e, r),
          strokeDashoffset: "0"
        }
      )
    ] });
  }
  indicator(e) {
    const n = this.app.getStrokeWidth(e.props.size), r = zw(e.props.segments);
    let a = n;
    !e.props.isPen && e.props.dash === "draw" && r.length === 1 && (a += By(e.id)() * (n / 6));
    const s = e.props.isComplete || Hs(e.props.segments)?.type === "straight", c = lk(e, a, s, !0), f = kc(r, c), p = f.length > 1 ? Qd(f, e.props.isClosed) : ck(r[0], a);
    return /* @__PURE__ */ E.jsx("path", { d: p });
  }
  toSvg(e, n, r) {
    const { color: a } = e.props, s = this.app.getStrokeWidth(e.props.size), c = zw(e.props.segments), f = e.props.isComplete || Hs(e.props.segments)?.type === "straight";
    let p = s;
    !e.props.isPen && e.props.dash === "draw" && c.length === 1 && (p += By(e.id)() * (s / 6));
    const g = lk(e, p, f, !1), y = kc(c, g), v = y.length > 1 ? Qd(y, e.props.isClosed) : ck(c[0], p);
    let S;
    if (e.props.dash === "draw" || y.length < 2) {
      Jy(y, g);
      const _ = Zy(y, g), T = document.createElementNS("http://www.w3.org/2000/svg", "path");
      T.setAttribute("d", nf(_, !0)), T.setAttribute("fill", r.fill[a]), T.setAttribute("stroke-linecap", "round"), S = T;
    } else {
      const _ = document.createElementNS("http://www.w3.org/2000/svg", "path");
      _.setAttribute("d", v), _.setAttribute("stroke", r.fill[a]), _.setAttribute("fill", "none"), _.setAttribute("stroke-linecap", "round"), _.setAttribute("stroke-width", s.toString()), _.setAttribute("stroke-dasharray", $D(e, s)), _.setAttribute("stroke-dashoffset", "0"), S = _;
    }
    const x = Ac({
      fill: e.props.isClosed ? e.props.fill : "none",
      d: v,
      color: e.props.color,
      colors: r
    });
    if (x) {
      const _ = document.createElementNS("http://www.w3.org/2000/svg", "g");
      return _.appendChild(x), _.appendChild(S), _;
    }
    return S;
  }
  onResize = (e, n) => {
    const { scaleX: r, scaleY: a } = n, s = [];
    for (const c of e.props.segments)
      s.push({
        ...c,
        points: c.points.map(({ x: f, y: p, z: g }) => ({
          x: r * f,
          y: a * p,
          z: g
        }))
      });
    return {
      props: {
        segments: s
      }
    };
  };
}
const vj = gi({
  type: "draw",
  getShapeUtil: () => ite,
  migrations: Sq,
  validator: bq
});
function ck(t, e) {
  const n = (e + 1) * 0.5;
  return `M ${t.x} ${t.y} m -${n}, 0 a ${n},${n} 0 1,0 ${n * 2},0 a ${n},${n} 0 1,0 -${n * 2},0`;
}
function y1(t) {
  return /* @__PURE__ */ E.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", ...t, children: /* @__PURE__ */ E.jsxs("g", { strokeWidth: 2, fill: "none", fillRule: "evenodd", children: [
    /* @__PURE__ */ E.jsx("circle", { strokeOpacity: 0.25, cx: 8, cy: 8, r: 7, stroke: "black" }),
    /* @__PURE__ */ E.jsx("path", { strokeLinecap: "round", d: "M15 8c0-4.5-4.5-7-7-7", stroke: "black", children: /* @__PURE__ */ E.jsx(
      "animateTransform",
      {
        attributeName: "transform",
        type: "rotate",
        from: "0 8 8",
        to: "360 8 8",
        dur: "1s",
        repeatCount: "indefinite"
      }
    ) })
  ] }) });
}
const ote = (t) => Object.entries(t).filter(([e, n]) => n).map(([e]) => e).join(" ");
class ate extends ya {
  static type = "embed";
  canUnmount = () => !1;
  canResize = (e) => !!Gd(e.props.url)?.definition?.doesResize;
  hideSelectionBoundsBg = (e) => !this.canResize(e);
  hideSelectionBoundsFg = (e) => !this.canResize(e);
  canEdit = () => !0;
  defaultProps() {
    return {
      opacity: "1",
      w: 300,
      h: 300,
      url: "",
      doesResize: !0
    };
  }
  isAspectRatioLocked = (e) => Gd(e.props.url)?.definition.isAspectRatioLocked ?? !1;
  onResize = (e, n) => {
    const r = this.isAspectRatioLocked(e), a = Gd(e.props.url);
    let s = a?.definition.minWidth ?? 200, c = a?.definition.minHeight ?? 200;
    if (r) {
      const f = e.props.w / e.props.h;
      f > 1 ? s *= f : c /= f;
    }
    return mj(e, n, { minWidth: s, minHeight: c });
  };
  render(e) {
    const { w: n, h: r, url: a } = e.props, s = FI(e.id), c = k.useMemo(() => QL(a), [a]), f = un(
      "is hovering",
      () => {
        const { editingId: v, hoveredId: S } = this.app.pageState;
        if (v && S !== v) {
          const x = this.app.getShapeById(v);
          if (x && x.type === "embed")
            return !0;
        }
        return !1;
      },
      []
    ), p = this.app.getPageRotation(e), g = s || f;
    if (c?.definition.type === "github_gist") {
      const v = c.url.split("/").pop();
      if (v)
        return /* @__PURE__ */ E.jsx(ha, { className: "rs-embed-container", id: e.id, children: /* @__PURE__ */ E.jsx(
          ste,
          {
            id: v,
            width: ze(n),
            height: ze(r),
            isInteractive: g,
            pageRotation: p
          }
        ) });
    }
    const y = ote({
      ...TL,
      ...c?.definition.overridePermissions ?? {}
    });
    return /* @__PURE__ */ E.jsx(ha, { className: "rs-embed-container", id: e.id, children: c?.definition ? /* @__PURE__ */ E.jsx(
      "iframe",
      {
        className: `rs-embed rs-embed-${e.id}`,
        sandbox: y,
        src: c.embedUrl,
        width: ze(n),
        height: ze(r),
        draggable: !1,
        frameBorder: "0",
        referrerPolicy: "no-referrer-when-downgrade",
        style: {
          border: 0,
          pointerEvents: g ? "auto" : "none",
          // Fix for safari <https://stackoverflow.com/a/49150908>
          zIndex: g ? "" : "-1",
          boxShadow: zI(p, $I),
          borderRadius: c?.definition.overrideOutlineRadius ?? 8,
          background: c?.definition.backgroundColor
        }
      }
    ) : /* @__PURE__ */ E.jsx(y1, { x: (n - 38) / 2, y: (r - 38) / 2 }) });
  }
  indicator(e) {
    const n = k.useMemo(() => Gd(e.props.url), [e.props.url]);
    return /* @__PURE__ */ E.jsx(
      "rect",
      {
        width: ze(e.props.w),
        height: ze(e.props.h),
        rx: n?.definition.overrideOutlineRadius ?? 8,
        ry: n?.definition.overrideOutlineRadius ?? 8
      }
    );
  }
}
function ste({
  id: t,
  file: e,
  isInteractive: n,
  width: r,
  height: a,
  style: s,
  pageRotation: c
}) {
  const f = k.useRef(null), p = e ? `?file=${e}` : "", g = `https://gist.github.com/${t}.js${p}`;
  return /* @__PURE__ */ E.jsx(
    "iframe",
    {
      ref: f,
      className: "rs-embed",
      draggable: !1,
      width: ze(r),
      height: ze(a),
      frameBorder: "0",
      scrolling: "no",
      seamless: !0,
      referrerPolicy: "no-referrer-when-downgrade",
      style: {
        ...s,
        pointerEvents: n ? "all" : "none",
        // Fix for safari <https://stackoverflow.com/a/49150908>
        zIndex: n ? "" : "-1",
        boxShadow: zI(c, $I)
      },
      srcDoc: `
			<html>
				<head>
					<base target="_blank">
				</head>
				<body>
					<script src=${g}><\/script>
					<style type="text/css">
						* { margin: 0px; }
						table { height: 100%; background-color: red; }
						.gist { background-color: none; height: 100%;  }
						.gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }
					</style>
				</body>
			</html>`
    }
  );
}
const nb = gi({
  type: "embed",
  getShapeUtil: () => ate,
  validator: wq,
  migrations: xq
}), lte = k.forwardRef(({ id: t, name: e, isEditing: n }, r) => {
  const a = Ge(), s = k.useCallback(
    (p) => {
      p.key === "Enter" && (p.stopPropagation(), p.currentTarget.blur(), a.setEditingId(null));
    },
    [a]
  ), c = k.useCallback(
    (p) => {
      const g = a.getShapeById(t);
      if (!g)
        return;
      const y = g.props.name, v = p.currentTarget.value.trim();
      y !== v && a.updateShapes(
        [
          {
            id: t,
            type: "frame",
            props: { name: v }
          }
        ],
        !0
      );
    },
    [t, a]
  ), f = k.useCallback(
    (p) => {
      const g = a.getShapeById(t);
      if (!g)
        return;
      const y = g.props.name, v = p.currentTarget.value;
      y !== v && a.updateShapes(
        [
          {
            id: t,
            type: "frame",
            props: { name: v }
          }
        ],
        !0
      );
    },
    [t, a]
  );
  return /* @__PURE__ */ E.jsxs("div", { className: `rs-frame-label ${n ? "rs-frame-label__editing" : ""}`, children: [
    /* @__PURE__ */ E.jsx(
      "input",
      {
        className: "rs-frame-name-input",
        ref: r,
        style: { display: n ? void 0 : "none" },
        value: e,
        autoFocus: !0,
        onKeyDown: s,
        onBlur: c,
        onChange: f
      }
    ),
    rj(e, "Frame") + String.fromCharCode(8203)
  ] });
}), cte = dn(function({
  id: e,
  name: n,
  width: r,
  height: a
}) {
  const s = Ge(), c = TI(s.getPageRotationById(e)), f = FI(e), p = k.useRef(null);
  k.useEffect(() => {
    const x = p.current;
    x && f && (x.focus(), x.select(), requestAnimationFrame(() => {
      document.activeElement !== x && (x.focus(), x.select());
    }));
  }, [p, f]);
  const y = ((c + Math.PI / 4) * (2 / Math.PI) + 4) % 4, v = ["top", "left", "bottom", "right"][Math.floor(y)];
  let S;
  switch (v) {
    case "top":
      S = "";
      break;
    case "right":
      S = `translate(${ze(r)}px, 0px) rotate(90deg)`;
      break;
    case "bottom":
      S = `translate(${ze(r)}px, ${ze(
        a
      )}px) rotate(180deg)`;
      break;
    case "left":
      S = `translate(0px, ${ze(a)}px) rotate(270deg)`;
      break;
  }
  return /* @__PURE__ */ E.jsx(
    "div",
    {
      className: "rs-frame-heading",
      style: {
        overflow: f ? "visible" : "hidden",
        maxWidth: `calc(var(--rs-zoom) * ${Math.ceil(v === "top" || v === "bottom" ? r : a)}px + var(--space-5))`,
        bottom: Math.ceil(a),
        transform: `${S} scale(var(--rs-scale)) translateX(calc(-1 * var(--space-3))`
      },
      children: /* @__PURE__ */ E.jsx("div", { className: "rs-frame-heading-hit-area", children: /* @__PURE__ */ E.jsx(lte, { ref: p, id: e, name: n, isEditing: f }) })
    }
  );
});
class ute extends ya {
  static type = "frame";
  canBind = () => !0;
  canEdit = () => !0;
  defaultProps() {
    return { opacity: "1", w: 160 * 2, h: 90 * 2, name: "" };
  }
  render(e) {
    const n = this.bounds(e);
    return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsxs(Mp, { children: [
        /* @__PURE__ */ E.jsx("rect", { className: "rs-hitarea-stroke", width: n.width, height: n.height }),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            className: "rs-frame__body",
            width: n.width,
            height: n.height,
            fill: "none"
          }
        )
      ] }),
      /* @__PURE__ */ E.jsx(
        cte,
        {
          id: e.id,
          name: e.props.name,
          width: n.width,
          height: n.height
        }
      )
    ] });
  }
  toSvg(e, n, r) {
    const a = document.createElementNS("http://www.w3.org/2000/svg", "g"), s = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    s.setAttribute("width", e.props.w.toString()), s.setAttribute("height", e.props.h.toString()), s.setAttribute("fill", r.solid), s.setAttribute("opacity", e.props.opacity), s.setAttribute("stroke", r.fill.black), s.setAttribute("stroke-width", "1"), s.setAttribute("rx", "4"), s.setAttribute("ry", "4"), a.appendChild(s);
    const p = ((TI(this.app.getPageRotationById(e.id)) + Math.PI / 4) * (2 / Math.PI) + 4) % 4, g = ["top", "left", "bottom", "right"][Math.floor(p)];
    let y;
    switch (g) {
      case "top":
        y = "";
        break;
      case "right":
        y = `translate(${ze(e.props.w)}px, 0px) rotate(90deg)`;
        break;
      case "bottom":
        y = `translate(${ze(e.props.w)}px, ${ze(
          e.props.h
        )}px) rotate(180deg)`;
        break;
      case "left":
        y = `translate(0px, ${ze(e.props.h)}px) rotate(270deg)`;
        break;
      default:
        y = "";
    }
    const v = {
      fontSize: 12,
      fontFamily: "Inter, sans-serif",
      textAlign: "start",
      width: e.props.w + 16,
      height: 30,
      padding: 8,
      lineHeight: 1,
      fontStyle: "normal",
      fontWeight: "normal"
    };
    let S = rj(e.props.name, "Frame") + String.fromCharCode(8203);
    const x = this.app.textMeasure.getTextLines({
      text: S,
      wrap: !0,
      ...v
    });
    S = x.length > 1 ? x[0] + "…" : x[0];
    const _ = this.app.textMeasure.measureText({
      fontSize: 12,
      fontFamily: "Inter, sans-serif",
      lineHeight: 1,
      fontStyle: "normal",
      fontWeight: "normal",
      text: S,
      width: "fit-content",
      maxWidth: "unset",
      padding: "0px"
    }), T = document.createElementNS("http://www.w3.org/2000/svg", "text");
    T.setAttribute("x", "0"), T.setAttribute("y", -(8 + _.h / 2) + "px"), T.setAttribute("font-family", '"Inter", sans-serif'), T.setAttribute("font-size", "12px"), T.setAttribute("font-weight", "400"), T.style.setProperty("transform", y), T.textContent = S;
    const I = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    return I.setAttribute("x", " -4px"), I.setAttribute("y", -(16 + _.h) + "px"), I.setAttribute("width", _.w + 8 + "px"), I.setAttribute("height", _.h + 8 + "px"), I.setAttribute("rx", "4px"), I.setAttribute("ry", "4px"), I.setAttribute("fill", r.background), a.appendChild(I), a.appendChild(T), a;
  }
  indicator(e) {
    const n = this.bounds(e);
    return /* @__PURE__ */ E.jsx(
      "rect",
      {
        width: ze(n.width),
        height: ze(n.height),
        className: "rs-frame-indicator"
      }
    );
  }
  canReceiveNewChildrenOfType = (e) => !0;
  canDropShapes = (e, n) => !0;
  onDragShapesOver = (e, n) => n.every((r) => r.parentId === e.id) ? { shouldHint: !1 } : (this.app.reparentShapesById(
    n.map((r) => r.id),
    e.id
  ), { shouldHint: !0 });
  onDragShapesOut = (e, n) => {
    const r = this.app.getShapeById(e.parentId);
    r?.type === "group" ? this.app.reparentShapesById(
      n.map((s) => s.id),
      r.id
    ) : this.app.reparentShapesById(
      n.map((s) => s.id),
      this.app.currentPageId
    );
  };
  onResizeEnd = (e) => {
    const n = this.app.getPageBounds(e), r = this.app.getSortedChildIds(e.id), a = [];
    for (const s of r) {
      const c = this.app.getPageBoundsById(s);
      n.includes(c) || a.push(s);
    }
    a.length > 0 && this.app.reparentShapesById(a, this.app.currentPageId);
  };
}
const px = gi({
  type: "frame",
  getShapeUtil: () => ute,
  validator: Eq,
  migrations: Cq
}), yj = It.memo(function({
  id: e,
  type: n,
  text: r,
  size: a,
  labelColor: s,
  font: c,
  align: f,
  wrap: p
}) {
  const {
    rInput: g,
    isEmpty: y,
    isEditing: v,
    isEditableFromHover: S,
    handleFocus: x,
    handleChange: _,
    handleKeyDown: T,
    handleBlur: I
  } = VI(e, n, r), D = v || S;
  return /* @__PURE__ */ E.jsx(
    "div",
    {
      className: "rs-text-label",
      "data-font": c,
      "data-align": f,
      "data-hastext": !y,
      "data-isediting": v,
      "data-textwrap": !!p,
      children: /* @__PURE__ */ E.jsxs(
        "div",
        {
          className: "rs-text-label__inner",
          style: {
            fontSize: Xd[a],
            lineHeight: Xd[a] * Ki.lineHeight + "px",
            minHeight: y ? Xd[a] * Ki.lineHeight + 32 : 0,
            minWidth: y ? 33 : 0,
            color: s
          },
          children: [
            /* @__PURE__ */ E.jsx("div", { className: "rs-text rs-text-content", dir: "ltr", children: Zr.normalizeTextForDom(r) }),
            D ? (
              // Consider replacing with content-editable
              /* @__PURE__ */ E.jsx("textarea", {
                ref: g,
                className: "rs-text rs-text-input",
                name: "text",
                tabIndex: -1,
                autoComplete: "false",
                autoCapitalize: "false",
                autoCorrect: "false",
                autoSave: "false",
                autoFocus: v,
                placeholder: "",
                spellCheck: "true",
                wrap: "off",
                dir: "auto",
                datatype: "wysiwyg",
                defaultValue: r,
                onFocus: x,
                onChange: _,
                onKeyDown: T,
                onBlur: I,
                onContextMenu: Pc
              })
            ) : null
          ]
        }
      )
    }
  );
}), dte = k.memo(function({
  w: e,
  h: n,
  strokeWidth: r,
  dash: a,
  color: s,
  fill: c
}) {
  const f = e / 2, p = n / 2, g = Math.max(0, f - r / 2), y = Math.max(0, p - r / 2), v = Qy(g, y), { strokeDasharray: S, strokeDashoffset: x } = Gs(
    v < 64 ? v * 2 : v,
    r,
    {
      style: a,
      snap: 4,
      closed: !0
    }
  ), _ = `M${f - g},${p}a${g},${y},0,1,1,${g * 2},0a${g},${y},0,1,1,-${g * 2},0`;
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(gs, { d: _, color: s, fill: c }),
    /* @__PURE__ */ E.jsx(
      "path",
      {
        d: _,
        strokeWidth: r,
        width: ze(e),
        height: ze(n),
        fill: "none",
        stroke: "currentColor",
        strokeDasharray: S,
        strokeDashoffset: x,
        pointerEvents: "all"
      }
    )
  ] });
});
function fte({
  w: t,
  h: e,
  strokeWidth: n,
  dash: r,
  color: a,
  colors: s,
  fill: c
}) {
  const f = t / 2, p = e / 2, g = Math.max(0, f - n / 2), y = Math.max(0, p - n / 2), v = Qy(g, y), { strokeDasharray: S, strokeDashoffset: x } = Gs(
    v < 64 ? v * 2 : v,
    n,
    {
      style: r,
      snap: 4,
      closed: !0
    }
  ), _ = `M${f - g},${p}a${g},${y},0,1,1,${g * 2},0a${g},${y},0,1,1,-${g * 2},0`, T = document.createElementNS("http://www.w3.org/2000/svg", "path");
  T.setAttribute("d", _), T.setAttribute("stroke-width", n.toString()), T.setAttribute("width", t.toString()), T.setAttribute("height", e.toString()), T.setAttribute("fill", "none"), T.setAttribute("stroke", s.fill[a]), T.setAttribute("stroke-dasharray", S), T.setAttribute("stroke-dashoffset", x);
  const I = Ac({
    d: _,
    fill: c,
    color: a,
    colors: s
  });
  return df(T, I);
}
function bj(t, e) {
  if (e > t) {
    const r = t / 2;
    return `
    M0,${r}
    a${r},${r},0,1,1,${r * 2},0
    L${t},${e - r}
    a${r},${r},0,1,1,-${r * 2},0
    Z`;
  }
  const n = e / 2;
  return `
    M${n},0
    L${t - n},0
    a${n},${n},0,1,1,0,${n * 2}
    L${n},${e}
    a${n},${n},0,1,1,0,${-n * 2}
    Z`;
}
function Sj(t, e) {
  if (t > e) {
    const r = e / 2;
    return Qy(r, r) + (t - r * 2) * 2;
  }
  const n = t / 2;
  return Qy(n, n) + (e - n * 2) * 2;
}
const pte = k.memo(function({
  w: e,
  h: n,
  strokeWidth: r,
  dash: a,
  color: s,
  fill: c
}) {
  const f = bj(e, n), p = Sj(e, n), { strokeDasharray: g, strokeDashoffset: y } = Gs(
    p < 64 ? p * 2 : p,
    r,
    {
      style: a,
      snap: 4,
      start: "outset",
      end: "outset",
      closed: !0
    }
  );
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(gs, { d: f, color: s, fill: c }),
    /* @__PURE__ */ E.jsx(
      "path",
      {
        d: f,
        strokeWidth: r,
        width: ze(e),
        height: ze(n),
        fill: "none",
        stroke: "currentColor",
        strokeDasharray: g,
        strokeDashoffset: y,
        pointerEvents: "all"
      }
    )
  ] });
});
function MD({
  w: t,
  h: e,
  strokeWidth: n,
  dash: r,
  color: a,
  colors: s,
  fill: c
}) {
  const f = bj(t, e), p = Sj(t, e), { strokeDasharray: g, strokeDashoffset: y } = Gs(
    p < 64 ? p * 2 : p,
    n,
    {
      style: r,
      snap: 4,
      closed: !0
    }
  ), v = document.createElementNS("http://www.w3.org/2000/svg", "path");
  v.setAttribute("d", f), v.setAttribute("stroke-width", n.toString()), v.setAttribute("width", t.toString()), v.setAttribute("height", e.toString()), v.setAttribute("fill", "none"), v.setAttribute("stroke", s.fill[a]), v.setAttribute("stroke-dasharray", g), v.setAttribute("stroke-dashoffset", y);
  const S = Ac({
    d: f,
    fill: c,
    color: a,
    colors: s
  });
  return df(v, S);
}
const hte = k.memo(function({
  dash: e,
  fill: n,
  color: r,
  strokeWidth: a,
  outline: s,
  bgOutline: c
}) {
  const f = c ? "M" + c[0] + "L" + c.slice(1) + "Z" : "M" + s[0] + "L" + s.slice(1) + "Z";
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(gs, { d: f, fill: n, color: r }),
    /* @__PURE__ */ E.jsx("g", { strokeWidth: a, stroke: "currentColor", fill: "none", pointerEvents: "all", children: Array.from(Array(s.length)).map((p, g) => {
      const y = s[g], v = s[(g + 1) % s.length], S = O.Dist(y, v), { strokeDasharray: x, strokeDashoffset: _ } = Gs(S, a, {
        style: e,
        start: "outset",
        end: "outset"
      });
      return /* @__PURE__ */ E.jsx(
        "line",
        {
          x1: y.x,
          y1: y.y,
          x2: v.x,
          y2: v.y,
          strokeDasharray: x,
          strokeDashoffset: _
        },
        g
      );
    }) })
  ] });
});
function gte({
  dash: t,
  fill: e,
  color: n,
  colors: r,
  strokeWidth: a,
  outline: s,
  bgOutline: c
}) {
  const f = document.createElementNS("http://www.w3.org/2000/svg", "g");
  f.setAttribute("stroke-width", a.toString()), f.setAttribute("stroke", r.fill[n]), f.setAttribute("fill", "none"), Array.from(Array(s.length)).forEach((g, y) => {
    const v = s[y], S = s[(y + 1) % s.length], x = O.Dist(v, S), { strokeDasharray: _, strokeDashoffset: T } = Gs(x, a, {
      style: t
    }), I = document.createElementNS("http://www.w3.org/2000/svg", "line");
    I.setAttribute("x1", v.x.toString()), I.setAttribute("y1", v.y.toString()), I.setAttribute("x2", S.x.toString()), I.setAttribute("y2", S.y.toString()), I.setAttribute("stroke-dasharray", _.toString()), I.setAttribute("stroke-dashoffset", T.toString()), f.appendChild(I);
  });
  const p = Ac({
    d: c ? "M" + c[0] + "L" + c.slice(1) + "Z" : "M" + s[0] + "L" + s.slice(1) + "Z",
    fill: e,
    color: n,
    colors: r
  });
  return df(f, p);
}
const mte = k.memo(function({
  id: e,
  w: n,
  h: r,
  strokeWidth: a,
  fill: s,
  color: c
}) {
  const f = KI(e, n, r, a), p = Ej(e, n, r, a);
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(gs, { d: f, color: c, fill: s }),
    /* @__PURE__ */ E.jsx("path", { d: p, fill: "currentColor", strokeWidth: 0, pointerEvents: "all" })
  ] });
});
function vte({
  id: t,
  w: e,
  h: n,
  strokeWidth: r,
  fill: a,
  color: s,
  colors: c
}) {
  const f = document.createElementNS("http://www.w3.org/2000/svg", "path");
  f.setAttribute("d", Ej(t, e, n, r)), f.setAttribute("fill", c.fill[s]);
  const p = Ac({
    d: KI(t, e, n, r),
    fill: a,
    color: s,
    colors: c
  });
  return df(f, p);
}
function wj(t) {
  return {
    size: 1 + t,
    thinning: 0.25,
    end: { taper: t },
    start: { taper: t },
    streamline: 0,
    smoothing: 1,
    simulatePressure: !1
  };
}
function xj(t, e, n, r) {
  const a = By(t), s = e / 2, c = n / 2, f = Qy(s, c), p = [], g = Wr * a(), y = Wr + cr / 2 + Math.abs(a()) * cr, v = Math.max(16, f / 10);
  for (let S = 0; S < v; S++) {
    const x = S / (v - 1), _ = g + x * y, T = Math.cos(_), I = Math.sin(_);
    p.push(
      new O(
        s * T + e * 0.5 + 0.05 * a(),
        c * I + n / 2 + 0.05 * a(),
        Math.min(
          1,
          0.5 + Math.abs(0.5 - (a() > 0 ? fa.easeInOutSine(x) : fa.easeInExpo(x))) / 2
        )
      )
    );
  }
  return kc(p, wj(r));
}
function Ej(t, e, n, r) {
  const a = wj(r);
  return nf(
    Zy(
      Jy(xj(t, e, n, r), a),
      a
    )
  );
}
function KI(t, e, n, r) {
  return Qd(xj(t, e, n, r));
}
const yte = k.memo(function({
  id: e,
  bgOutline: n,
  outline: r,
  fill: a,
  color: s,
  strokeWidth: c
}) {
  const f = rb(e, r, c), p = WI(c), g = kc(f, p), y = Qd(
    n ? kc(rb(e, n, c), p) : g,
    !1
  ), v = nf(f1(f, p));
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(gs, { d: y, fill: a, color: s }),
    /* @__PURE__ */ E.jsx("path", { d: v, fill: "currentColor", pointerEvents: "all" })
  ] });
});
function bte({
  id: t,
  outline: e,
  bgOutline: n,
  fill: r,
  color: a,
  colors: s,
  strokeWidth: c
}) {
  const f = rb(t, e, c), p = WI(c), g = document.createElementNS("http://www.w3.org/2000/svg", "path");
  g.setAttribute("d", nf(f1(f, p), !0)), g.setAttribute("fill", s.fill[a]);
  const y = Ac({
    d: Qd(
      kc(
        n ? rb(t, n, c) : f,
        p
      ),
      !1
    ),
    fill: r,
    color: a,
    colors: s
  });
  return df(g, y);
}
function rb(t, e, n) {
  const r = [], a = By(t), s = Math.round(Math.abs(a()) * e.length), c = e.map(
    (p) => O.AddXY(p, a() * n / 4, a() * n / 4)
  ), f = c.length;
  for (let p = 0, g = f + 1; p < g; p++) {
    const y = c[(s + p) % f], v = c[(s + p + 1) % f], S = Math.min(O.Dist(y, v) / 2, n / 2), x = O.Nudge(y, v, S), _ = O.Med(y, v);
    if (p === 0)
      v.z = 0.7, r.push(new O(_.x, _.y, 0.7), v);
    else if (p === e.length) {
      const T = O.PointsBetween(x, _, 4);
      T.forEach((I) => I.z = 0.7), r.push(...T);
    } else
      r.push(...O.PointsBetween(x, v, 6));
  }
  return r;
}
function Ste(t, e, n) {
  const r = rb(t, e, n), a = WI(n), s = kc(r, a);
  return Qd(s, !0);
}
function WI(t) {
  return {
    size: 1 + t * 0.618,
    last: !0,
    simulatePressure: !1,
    streamline: 0.25,
    thinning: 0.9
  };
}
const AD = k.memo(function({
  w: e,
  h: n,
  strokeWidth: r,
  fill: a,
  color: s
}) {
  const c = e / 2, f = n / 2, p = Math.max(0, c), g = Math.max(0, f), y = `M${c - p},${f}a${p},${g},0,1,1,${p * 2},0a${p},${g},0,1,1,-${p * 2},0`;
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(gs, { d: y, color: s, fill: a }),
    /* @__PURE__ */ E.jsx("path", { d: y, stroke: `var(--palette-${s})`, strokeWidth: r, fill: "none" })
  ] });
});
function wte({
  w: t,
  h: e,
  strokeWidth: n,
  fill: r,
  color: a,
  colors: s
}) {
  const c = t / 2, f = e / 2, p = Math.max(0, c), g = Math.max(0, f), y = `M${c - p},${f}a${p},${g},0,1,1,${p * 2},0a${p},${g},0,1,1,-${p * 2},0`, v = document.createElementNS("http://www.w3.org/2000/svg", "path");
  v.setAttribute("d", y), v.setAttribute("stroke-width", n.toString()), v.setAttribute("width", t.toString()), v.setAttribute("height", e.toString()), v.setAttribute("fill", "none"), v.setAttribute("stroke", s.fill[a]);
  const S = Ac({
    d: y,
    fill: r,
    color: a,
    colors: s
  });
  return df(v, S);
}
const xte = k.memo(function({
  w: e,
  h: n,
  strokeWidth: r,
  fill: a,
  color: s
}) {
  const c = GI(e, n);
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(gs, { d: c, color: s, fill: a }),
    /* @__PURE__ */ E.jsx("path", { d: c, stroke: `var(--palette-${s})`, strokeWidth: r, fill: "none" })
  ] });
});
function Ete({
  w: t,
  h: e,
  strokeWidth: n,
  fill: r,
  color: a,
  colors: s
}) {
  const c = GI(t, e), f = document.createElementNS("http://www.w3.org/2000/svg", "path");
  f.setAttribute("d", c), f.setAttribute("stroke-width", n.toString()), f.setAttribute("width", t.toString()), f.setAttribute("height", e.toString()), f.setAttribute("fill", "none"), f.setAttribute("stroke", s.fill[a]);
  const p = Ac({
    d: c,
    fill: r,
    color: a,
    colors: s
  });
  return df(f, p);
}
function GI(t, e) {
  let n;
  if (e > t) {
    const r = t / 2;
    n = `
    M0,${r}
    a${r},${r},0,1,1,${r * 2},0
    L${t},${e - r}
    a${r},${r},0,1,1,-${r * 2},0
    Z`;
  } else {
    const r = e / 2;
    n = `
    M${r},0
    L${t - r},0
    a${r},${r},0,1,1,0,${r * 2}
    L${r},${e}
    a${r},${r},0,1,1,0,${-r * 2}
    Z`;
  }
  return n;
}
const OD = k.memo(function({
  outline: e,
  bgOutline: n,
  fill: r,
  color: a,
  strokeWidth: s
}) {
  const c = "M" + e[0] + "L" + e.slice(1) + "Z";
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(
      gs,
      {
        d: n ? "M" + n[0] + "L" + n.slice(1) + "Z" : c,
        fill: r,
        color: a
      }
    ),
    /* @__PURE__ */ E.jsx("path", { d: c, stroke: `var(--palette-${a}`, strokeWidth: s, fill: "none" })
  ] });
});
function Cte({
  outline: t,
  bgOutline: e,
  fill: n,
  color: r,
  strokeWidth: a,
  colors: s
}) {
  const c = "M" + t[0] + "L" + t.slice(1) + "Z", f = document.createElementNS("http://www.w3.org/2000/svg", "path");
  f.setAttribute("d", c), f.setAttribute("stroke-width", a.toString()), f.setAttribute("stroke", s.fill[r]), f.setAttribute("fill", "none");
  const p = e ? "M" + e[0] + "L" + e.slice(1) + "Z" : c, g = Ac({
    d: p,
    fill: n,
    color: r,
    colors: s
  });
  return df(f, g);
}
const uk = 16, Bs = 17 * 3;
class _te extends ya {
  static type = "geo";
  canEdit = () => !0;
  defaultProps() {
    return {
      w: 100,
      h: 100,
      geo: "rectangle",
      color: "black",
      labelColor: "black",
      fill: "none",
      dash: "draw",
      size: "m",
      opacity: "1",
      font: "draw",
      text: "",
      align: "middle",
      growY: 0,
      url: ""
    };
  }
  hitTestLineSegment(e, n, r) {
    let a = this.outline(e);
    e.props.geo === "x-box" && (a = Bw(
      Math.max(1, e.props.w),
      Math.max(1, e.props.h + e.props.growY)
    ));
    for (let s = 0; s < a.length; s++) {
      const c = a[s], f = a[(s + 1) % a.length];
      if (ef(n, r, c, f))
        return !0;
    }
    return !1;
  }
  getBounds(e) {
    return new ot(0, 0, e.props.w, e.props.h + e.props.growY);
  }
  getCenter(e) {
    return new O(e.props.w / 2, (e.props.h + e.props.growY) / 2);
  }
  getOutline(e) {
    const n = Math.max(1, e.props.w), r = Math.max(1, e.props.h + e.props.growY), a = n / 2, s = r / 2;
    switch (e.props.geo) {
      case "triangle":
        return [new O(a, 0), new O(n, r), new O(0, r)];
      case "diamond":
        return [new O(a, 0), new O(n, s), new O(a, r), new O(0, s)];
      case "pentagon":
        return qT(n, r, 5);
      case "hexagon":
        return qT(n, r, 6);
      case "octagon":
        return qT(n, r, 8);
      case "ellipse": {
        const c = Math.pow(a - s, 2) / Math.pow(a + s, 2), f = Kr * (a + s) * (1 + 3 * c / (10 + Math.sqrt(4 - 3 * c)));
        let p = Math.max(4, Math.ceil(f / 10));
        p = Math.ceil(p / 4) * 4;
        const g = Wr / p, y = Math.cos(g), v = Math.sin(g);
        let S = 0, x = 1, _ = 0, T = 1;
        const I = Array(p);
        for (let D = 0; D < p; D++)
          I[D] = new O(a + a * x, s + s * S), _ = v * x + y * S, T = y * x - v * S, S = _, x = T;
        return I;
      }
      case "oval": {
        const f = Array(20);
        if (r > n)
          for (let p = 0; p < 10; p++) {
            const g = -Kr + Kr * p / 8, y = Kr * p / (10 - 2);
            f[p] = new O(a + a * Math.cos(g), a + a * Math.sin(g)), f[p + 10] = new O(a + a * Math.cos(y), r - a + a * Math.sin(y));
          }
        else
          for (let p = 0; p < 10; p++) {
            const g = -cr + Kr * p / 8, y = cr + Kr * -p / (10 - 2);
            f[p] = new O(n - s + s * Math.cos(g), r - s + s * Math.sin(g)), f[p + 10] = new O(s - s * Math.cos(y), r - s + s * Math.sin(y));
          }
        return f;
      }
      case "star": {
        const f = Wr / 5 / 2, p = Math.floor(5 / 4) * 2, g = 5 * 2 - p, y = 0, v = Math.floor(5 / 2) * 2, S = Math.cos(-cr + p * f) * n / 2, x = Math.cos(-cr + g * f) * n / 2, _ = Math.sin(-cr + y * f) * r / 2, T = Math.sin(-cr + v * f) * r / 2, I = n - Math.abs(S - x), D = r - Math.abs(T - _), N = n / 2 + x - (n / 2 - S), j = r / 2 + _ - (r / 2 - T), L = 1, z = (n - N) / 2, F = (r - j) / 2, K = (n + I) / 2, X = (r + D) / 2, se = K * L / 2, ue = X * L / 2;
        return Array.from(Array(5 * 2)).map((pe, Pe) => {
          const ve = -cr + Pe * f;
          return new O(
            z + (Pe % 2 ? se : K) * Math.cos(ve),
            F + (Pe % 2 ? ue : X) * Math.sin(ve)
          );
        });
      }
      case "rhombus": {
        const c = Math.min(n * 0.38, r * 0.38);
        return [new O(c, 0), new O(n, 0), new O(n - c, r), new O(0, r)];
      }
      case "rhombus-2": {
        const c = Math.min(n * 0.38, r * 0.38);
        return [new O(0, 0), new O(n - c, 0), new O(n, r), new O(c, r)];
      }
      case "trapezoid": {
        const c = Math.min(n * 0.38, r * 0.38);
        return [new O(c, 0), new O(n - c, 0), new O(n, r), new O(0, r)];
      }
      case "arrow-right": {
        const c = Math.min(n, r) * 0.38, f = r * 0.16;
        return [
          new O(0, f),
          new O(n - c, f),
          new O(n - c, 0),
          new O(n, r / 2),
          new O(n - c, r),
          new O(n - c, r - f),
          new O(0, r - f)
        ];
      }
      case "arrow-left": {
        const c = Math.min(n, r) * 0.38, f = r * 0.16;
        return [
          new O(c, 0),
          new O(c, f),
          new O(n, f),
          new O(n, r - f),
          new O(c, r - f),
          new O(c, r),
          new O(0, r / 2)
        ];
      }
      case "arrow-up": {
        const c = n * 0.16, f = Math.min(n, r) * 0.38;
        return [
          new O(n / 2, 0),
          new O(n, f),
          new O(n - c, f),
          new O(n - c, r),
          new O(c, r),
          new O(c, f),
          new O(0, f)
        ];
      }
      case "arrow-down": {
        const c = n * 0.16, f = Math.min(n, r) * 0.38;
        return [
          new O(c, 0),
          new O(n - c, 0),
          new O(n - c, r - f),
          new O(n, r - f),
          new O(n / 2, r),
          new O(0, r - f),
          new O(c, r - f)
        ];
      }
      case "x-box":
      case "rectangle":
        return [new O(0, 0), new O(n, 0), new O(n, r), new O(0, r)];
    }
  }
  onEditEnd = (e) => {
    const {
      id: n,
      type: r,
      props: { text: a }
    } = e;
    a.trim() !== e.props.text && this.app.updateShapes([
      {
        id: n,
        type: r,
        props: {
          text: a.trim()
        }
      }
    ]);
  };
  render(e) {
    const { id: n, type: r, props: a } = e, s = un("zoom", () => this.app.zoomLevel < 0.35, []), c = this.app.getStrokeWidth(a.size), { w: f, color: p, labelColor: g, fill: y, dash: v, growY: S, font: x, align: _, size: T, text: I } = a, D = () => {
      const N = a.h + S;
      switch (a.geo) {
        case "ellipse":
          return v === "draw" ? s ? /* @__PURE__ */ E.jsx(AD, { strokeWidth: c, w: f, h: N, color: p, fill: y }) : /* @__PURE__ */ E.jsx(
            mte,
            {
              id: n,
              w: f,
              h: N,
              color: p,
              fill: y,
              strokeWidth: c
            }
          ) : v === "solid" ? /* @__PURE__ */ E.jsx(AD, { strokeWidth: c, w: f, h: N, color: p, fill: y }) : /* @__PURE__ */ E.jsx(
            dte,
            {
              id: n,
              strokeWidth: c,
              w: f,
              h: N,
              dash: v,
              color: p,
              fill: y
            }
          );
        case "oval":
          return v === "draw" || v === "solid" ? /* @__PURE__ */ E.jsx(xte, { strokeWidth: c, w: f, h: N, color: p, fill: y }) : /* @__PURE__ */ E.jsx(
            pte,
            {
              id: n,
              strokeWidth: c,
              w: f,
              h: N,
              dash: v,
              color: p,
              fill: y
            }
          );
        default: {
          let j = this.outline(e), L;
          return e.props.geo === "x-box" && (L = j, j = Bw(
            Math.max(1, e.props.w),
            Math.max(1, e.props.h + e.props.growY)
          )), v === "draw" ? s ? /* @__PURE__ */ E.jsx(
            OD,
            {
              fill: y,
              color: p,
              strokeWidth: c,
              outline: j,
              bgOutline: L
            }
          ) : /* @__PURE__ */ E.jsx(
            yte,
            {
              id: n,
              fill: y,
              color: p,
              strokeWidth: c,
              outline: j,
              bgOutline: L
            }
          ) : v === "solid" ? /* @__PURE__ */ E.jsx(
            OD,
            {
              fill: y,
              color: p,
              strokeWidth: c,
              outline: j,
              bgOutline: L
            }
          ) : /* @__PURE__ */ E.jsx(
            hte,
            {
              dash: v,
              fill: y,
              color: p,
              strokeWidth: c,
              outline: j,
              bgOutline: L
            }
          );
        }
      }
    };
    return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(Mp, { id: n, children: D() }),
      /* @__PURE__ */ E.jsx(
        yj,
        {
          id: n,
          type: r,
          font: x,
          fill: y,
          size: T,
          align: _,
          text: I,
          labelColor: this.app.getCssColor(g),
          wrap: !0
        }
      ),
      "url" in e.props && e.props.url && /* @__PURE__ */ E.jsx(Tb, { url: e.props.url })
    ] });
  }
  indicator(e) {
    const { id: n, props: r } = e, { w: a, h: s, growY: c, size: f } = r, p = this.app.getStrokeWidth(f);
    switch (r.geo) {
      case "ellipse":
        return r.dash === "draw" ? /* @__PURE__ */ E.jsx("path", { d: KI(n, a, s + c, p) }) : /* @__PURE__ */ E.jsx("ellipse", { cx: a / 2, cy: (s + c) / 2, rx: a / 2, ry: (s + c) / 2 });
      case "oval":
        return /* @__PURE__ */ E.jsx("path", { d: GI(a, s + c) });
      default: {
        let g = this.outline(e);
        return e.props.geo === "x-box" && (g = Bw(
          Math.max(1, e.props.w),
          Math.max(1, e.props.h + e.props.growY)
        )), r.dash === "draw" ? /* @__PURE__ */ E.jsx("path", { d: Ste(n, g, p) }) : /* @__PURE__ */ E.jsx("path", { d: `M${g[0]}L${g.slice(1)}Z` });
      }
    }
  }
  toSvg(e, n, r) {
    const { id: a, props: s } = e, c = this.app.getStrokeWidth(s.size);
    let f;
    switch (s.geo) {
      case "ellipse": {
        switch (s.dash) {
          case "draw":
            f = vte({
              id: a,
              w: s.w,
              h: s.h,
              color: s.color,
              fill: s.fill,
              strokeWidth: c,
              colors: r
            });
            break;
          case "solid":
            f = wte({
              strokeWidth: c,
              w: s.w,
              h: s.h,
              color: s.color,
              fill: s.fill,
              colors: r
            });
            break;
          default:
            f = fte({
              id: a,
              strokeWidth: c,
              w: s.w,
              h: s.h,
              dash: s.dash,
              color: s.color,
              fill: s.fill,
              colors: r
            });
            break;
        }
        break;
      }
      case "oval": {
        switch (s.dash) {
          case "draw":
            f = MD({
              id: a,
              strokeWidth: c,
              w: s.w,
              h: s.h,
              dash: s.dash,
              color: s.color,
              fill: s.fill,
              colors: r
            });
            break;
          case "solid":
            f = Ete({
              strokeWidth: c,
              w: s.w,
              h: s.h,
              color: s.color,
              fill: s.fill,
              colors: r
            });
            break;
          default:
            f = MD({
              id: a,
              strokeWidth: c,
              w: s.w,
              h: s.h,
              dash: s.dash,
              color: s.color,
              fill: s.fill,
              colors: r
            });
        }
        break;
      }
      default: {
        let p = this.outline(e), g;
        switch (s.geo === "x-box" && (g = p, p = Bw(
          Math.max(1, e.props.w),
          Math.max(1, e.props.h + e.props.growY)
        )), s.dash) {
          case "draw":
            f = bte({
              id: a,
              fill: s.fill,
              color: s.color,
              strokeWidth: c,
              outline: p,
              bgOutline: g,
              colors: r
            });
            break;
          case "solid":
            f = Cte({
              fill: s.fill,
              color: s.color,
              strokeWidth: c,
              outline: p,
              bgOutline: g,
              colors: r
            });
            break;
          default:
            f = gte({
              dash: s.dash,
              fill: s.fill,
              color: s.color,
              strokeWidth: c,
              outline: p,
              bgOutline: g,
              colors: r
            });
            break;
        }
        break;
      }
    }
    if (s.text) {
      const p = this.bounds(e), g = {
        fontSize: Xd[e.props.size],
        fontFamily: n,
        textAlign: e.props.align,
        padding: 16,
        lineHeight: Ki.lineHeight,
        fontStyle: "normal",
        fontWeight: "normal",
        width: Math.ceil(p.width),
        height: Math.ceil(p.height)
      }, y = this.app.textMeasure.getTextLines({
        text: s.text,
        wrap: !0,
        ...g
      }), v = document.createElementNS("http://www.w3.org/2000/svg", "g"), S = Uw(this.app, e), x = m1(this.app, {
        ...g,
        lines: y,
        strokeWidth: 2,
        stroke: r.background,
        fill: r.background,
        width: S.w
      });
      x.setAttribute("transform", `translate(${(p.width - S.w) / 2}, 0)`);
      const _ = x.cloneNode(!0);
      if (_.setAttribute("fill", r.fill[e.props.labelColor]), _.setAttribute("stroke", "none"), v.append(x), v.append(_), f.nodeName === "g")
        return f.appendChild(v), f;
      {
        const T = document.createElementNS("http://www.w3.org/2000/svg", "g");
        return T.appendChild(f), T.appendChild(v), T;
      }
    }
    return f;
  }
  onResize = (e, { initialBounds: n, handle: r, newPoint: a, scaleX: s, scaleY: c }) => {
    let f = n.width * s, p = n.height * c, g = 0, y = 0;
    if (e.props.text.trim()) {
      let _ = Math.max(Math.abs(f), Bs), T = Math.max(Math.abs(p), Bs);
      _ < Bs && T === Bs && (_ = Bs), _ === Bs && T < Bs && (T = Bs);
      const I = Uw(this.app, {
        ...e,
        props: {
          ...e.props,
          w: _,
          h: T
        }
      }), D = Math.max(Math.abs(f), I.w) * Math.sign(f), N = Math.max(Math.abs(p), I.h) * Math.sign(p);
      g = Math.abs(D) - Math.abs(f), y = Math.abs(N) - Math.abs(p), f = D, p = N;
    }
    const v = new O(0, 0);
    s < 0 && (v.x += f), (r === "left" || r === "top_left" || r === "bottom_left") && (v.x += s < 0 ? g : -g), c < 0 && (v.y += p), (r === "top" || r === "top_left" || r === "top_right") && (v.y += c < 0 ? y : -y);
    const { x: S, y: x } = v.rot(e.rotation).add(a);
    return {
      x: S,
      y: x,
      props: {
        w: Math.max(Math.abs(f), 1),
        h: Math.max(Math.abs(p), 1),
        growY: 0
      }
    };
  };
  onBeforeCreate = (e) => {
    if (!e.props.text)
      return e.props.growY ? {
        ...e,
        props: {
          ...e.props,
          growY: 0
        }
      } : void 0;
    const n = e.props.h, r = Uw(this.app, e).h;
    let a = null;
    if (r > n ? a = r - n : e.props.growY && (a = 0), a !== null)
      return {
        ...e,
        props: {
          ...e.props,
          growY: a
        }
      };
  };
  onBeforeUpdate = (e, n) => {
    const r = e.props.text.trim(), a = n.props.text.trim();
    if (r === a && e.props.font === n.props.font && e.props.size === n.props.size)
      return;
    if (r && !a)
      return {
        ...n,
        props: {
          ...n.props,
          growY: 0
        }
      };
    const s = e.props.w, c = e.props.h, f = Uw(this.app, n), p = f.w, g = f.h;
    if (!r && a && a.length === 1) {
      let v = Math.max(s, p), S = Math.max(c, g);
      return e.props.w < Bs && e.props.h < Bs && (v = Math.max(v, Bs), S = Math.max(S, Bs), v = Math.max(v, S), S = Math.max(v, S)), {
        ...n,
        props: {
          ...n.props,
          w: v,
          h: S,
          growY: 0
        }
      };
    }
    let y = null;
    if (g > c ? y = g - c : e.props.growY && (y = 0), y !== null)
      return {
        ...n,
        props: {
          ...n.props,
          growY: y,
          w: p
        }
      };
    if (p > e.props.w)
      return {
        ...n,
        props: {
          ...n.props,
          w: p
        }
      };
  };
}
function Uw(t, e) {
  const n = e.props.text.trim();
  if (!n)
    return { w: 0, h: 0 };
  const r = t.textMeasure.measureText({
    ...Ki,
    text: "w",
    fontFamily: qd[e.props.font],
    fontSize: Xd[e.props.size],
    width: "fit-content",
    maxWidth: "100px"
  }), a = {
    s: 2,
    m: 3.5,
    l: 5,
    xl: 10
  }, s = t.textMeasure.measureText({
    ...Ki,
    text: n,
    fontFamily: qd[e.props.font],
    fontSize: Xd[e.props.size],
    width: "fit-content",
    minWidth: r.w + "px",
    maxWidth: Math.max(
      // Guard because a DOM nodes can't be less 0
      0,
      // A 'w' width that we're setting as the min-width
      Math.ceil(r.w + a[e.props.size]),
      // The actual text size
      Math.ceil(e.props.w - uk * 2)
    ) + "px"
  });
  return {
    w: s.w + uk * 2,
    h: s.h + uk * 2
  };
}
function Bw(t, e) {
  return [
    new O(0, 0),
    new O(t, 0),
    new O(t, e),
    new O(0, e),
    new O(0, 0),
    new O(t * 0.5, e * 0.5),
    new O(t, e),
    new O(t, 0),
    new O(t * 0.5, e * 0.5),
    new O(0, e)
  ];
}
const Cj = gi({
  type: "geo",
  getShapeUtil: () => _te,
  validator: _q,
  migrations: Tq
});
class Tte extends Oc {
  static type = "group";
  hideSelectionBoundsBg = () => !1;
  hideSelectionBoundsFg = () => !0;
  canBind = () => !1;
  defaultProps() {
    return { opacity: "1" };
  }
  getBounds(e) {
    const n = this.app.getSortedChildIds(e.id);
    if (n.length === 0)
      return new ot();
    const r = n.flatMap((a) => {
      const s = this.app.getShapeById(a);
      return this.app.getOutlineById(a).map((c) => De.applyToPoint(this.app.getTransform(s), c));
    });
    return ot.FromPoints(r);
  }
  getCenter(e) {
    return this.bounds(e).center;
  }
  getOutline(e) {
    return this.bounds(e).corners;
  }
  render(e) {
    const {
      erasingIdsSet: n,
      pageState: { hintingIds: r, focusLayerId: a },
      zoomLevel: s
    } = this.app, c = n.has(e.id), f = r.length > 0 && r.some((g) => g !== e.id && this.app.getShapeById(g)?.type === "group");
    if (
      // always show the outline while we're erasing the group
      !c && // show the outline while the group is focused unless something outside of the group is being hinted
      // this happens dropping shapes from a group onto some outside group
      (e.id !== a || f)
    )
      return null;
    const p = this.bounds(e);
    return /* @__PURE__ */ E.jsx(Mp, { id: e.id, children: /* @__PURE__ */ E.jsx(DD, { className: "rs-group", bounds: p, zoomLevel: s }) });
  }
  indicator(e) {
    const {
      camera: { z: n }
    } = this.app, r = this.bounds(e);
    return /* @__PURE__ */ E.jsx(DD, { className: "", bounds: r, zoomLevel: n });
  }
  onChildrenChange = (e) => {
    const n = this.app.getSortedChildIds(e.id);
    if (n.length === 0) {
      this.app.pageState.focusLayerId === e.id && this.app.popFocusLayer(), this.app.deleteShapes([e.id]);
      return;
    } else if (n.length === 1) {
      this.app.pageState.focusLayerId === e.id && this.app.popFocusLayer(), this.app.reparentShapesById(n, e.parentId), this.app.deleteShapes([e.id]);
      return;
    }
  };
}
const _j = gi({
  type: "group",
  getShapeUtil: () => Tte,
  validator: kq,
  migrations: Pq
});
function DD({
  bounds: t,
  zoomLevel: e,
  className: n
}) {
  return /* @__PURE__ */ E.jsx("g", { className: n, pointerEvents: "none", strokeLinecap: "round", strokeLinejoin: "round", children: t.sides.map((r, a) => {
    const { strokeDasharray: s, strokeDashoffset: c } = Gs(
      r[0].dist(r[1]),
      1 / e,
      {
        style: "dashed",
        lengthRatio: 4
      }
    );
    return /* @__PURE__ */ E.jsx(
      "line",
      {
        x1: r[0].x,
        y1: r[0].y,
        x2: r[1].x,
        y2: r[1].y,
        strokeDasharray: s,
        strokeDashoffset: c
      },
      a
    );
  }) });
}
const kte = async (t) => new Promise((e, n) => {
  const r = new Image();
  r.onload = () => e(r), r.onerror = () => n(new Error("Failed to load image")), r.crossOrigin = "anonymous", r.src = t;
}), Pte = async (t) => {
  const e = await kte(t), n = document.createElement("canvas");
  n.width = e.width, n.height = e.height;
  const r = n.getContext("2d");
  if (r)
    return r.drawImage(e, 0, 0), n.toDataURL();
};
async function Ite(t) {
  const n = await (await fetch(t)).blob();
  return new Promise((r, a) => {
    const s = new FileReader();
    s.onloadend = () => r(s.result), s.onerror = a, s.readAsDataURL(n);
  });
}
class Rte extends ya {
  static type = "image";
  isAspectRatioLocked = () => !0;
  defaultProps() {
    return {
      opacity: "1",
      w: 100,
      h: 100,
      assetId: null,
      playing: !0,
      url: ""
    };
  }
  render(e) {
    const [n, r] = k.useState(""), a = XL(), s = e.props.assetId ? this.app.getAssetById(e.props.assetId) : void 0, { w: c, h: f } = e.props;
    if (k.useEffect(() => {
      if (s?.props.src && "mimeType" in s.props && s?.props.mimeType === "image/gif") {
        let g = !1;
        return (async () => {
          const v = await Pte(s.props.src);
          g || v && r(v);
        })(), () => {
          g = !0;
        };
      }
    }, [a, s?.props]), s?.type === "bookmark")
      throw Error("Bookmark assets can't be rendered as images");
    const p = a && (s?.props.mimeType?.includes("video") || s?.props.mimeType?.includes("gif"));
    return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(ha, { id: e.id, children: /* @__PURE__ */ E.jsxs("div", { className: "rs-image-container", children: [
        s?.props.src ? /* @__PURE__ */ E.jsx(
          "div",
          {
            className: `rs-image rs-image-${e.id}`,
            style: {
              backgroundImage: `url(${!e.props.playing || p ? n : s.props.src}`
            },
            draggable: !1
          }
        ) : /* @__PURE__ */ E.jsx(y1, { x: (c - 38) / 2, y: (f - 38) / 2 }),
        s?.props.isAnimated && !e.props.playing && /* @__PURE__ */ E.jsx("div", { className: "rs-image__meda-tag", children: "GIF" })
      ] }) }),
      "url" in e.props && e.props.url && /* @__PURE__ */ E.jsx(Tb, { url: e.props.url })
    ] });
  }
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: ze(e.props.w), height: ze(e.props.h) });
  }
  async toSvg(e) {
    const n = document.createElementNS("http://www.w3.org/2000/svg", "g");
    let a = (e.props.assetId ? this.app.getAssetById(e.props.assetId) : null)?.props.src || "";
    a && a.startsWith("http") && (a = await Ite(a) || "");
    const s = document.createElementNS("http://www.w3.org/2000/svg", "image");
    return s.setAttributeNS("http://www.w3.org/1999/xlink", "href", a), s.setAttribute("width", e.props.w.toString()), s.setAttribute("height", e.props.h.toString()), n.appendChild(s), n;
  }
  onDoubleClick = (e) => {
    const n = e.props.assetId ? this.app.getAssetById(e.props.assetId) : void 0;
    !n || !(n.props.src && "mimeType" in n.props && n.props.mimeType === "image/gif") || this.app.updateShapes([
      {
        type: "image",
        id: e.id,
        props: {
          playing: !e.props.playing
        }
      }
    ]);
  };
}
const $te = gi({
  type: "image",
  getShapeUtil: () => Rte,
  validator: Iq,
  migrations: Rq
});
function Tj(t) {
  const { segments: e } = t, n = [];
  for (let r = 0, a = e.length; r < a; r++) {
    const c = e[r].lut, f = c.length - 1;
    r > 0 ? n.push(O.Lrp(c[0], c[1], 0.25)) : n.push(c[0]);
    for (let p = 1; p < f; p++)
      n.push(c[p]);
    r < a - 1 ? n.push(O.Lrp(c[f - 1], c[f], 0.75)) : n.push(c[f]);
  }
  return n;
}
function kj(t) {
  return {
    size: t * 1.25,
    thinning: 0.4,
    streamline: 0,
    smoothing: 0.5,
    simulatePressure: !0,
    last: !0
  };
}
function Pj(t, e, n) {
  const r = Tj(e), a = kj(n);
  return kc(r, a);
}
function Mte(t, e, n) {
  const r = kj(n);
  return Zy(
    Jy(Pj(t, e, n), r),
    r
  );
}
function Ij(t, e, n) {
  const r = Mte(t, e, n);
  return nf(r);
}
function Ate(t, e, n) {
  if (t.props.dash === "draw") {
    const r = Pj(t, e, n);
    return Qd(r);
  }
  return e.path;
}
function Ote({
  shape: t,
  strokeWidth: e,
  spline: n,
  color: r
}) {
  const a = Ij(t, n, e), s = document.createElementNS("http://www.w3.org/2000/svg", "path");
  return s.setAttribute("stroke-width", "0"), s.setAttribute("stroke", "none"), s.setAttribute("fill", r), s.setAttribute("d", a), s;
}
function Dte({
  dash: t,
  strokeWidth: e,
  spline: n,
  color: r
}) {
  const { segments: a } = n, s = document.createElementNS("http://www.w3.org/2000/svg", "g");
  return s.setAttribute("stroke", r), s.setAttribute("stroke-width", e.toString()), a.forEach((c, f) => {
    const p = document.createElementNS("http://www.w3.org/2000/svg", "path"), { strokeDasharray: g, strokeDashoffset: y } = Gs(c.length, e, {
      style: t,
      start: f > 0 ? "outset" : "none",
      end: f < a.length - 1 ? "outset" : "none"
    });
    p.setAttribute("stroke-dasharray", g.toString()), p.setAttribute("stroke-dashoffset", y.toString()), p.setAttribute("d", c.path), p.setAttribute("fill", "none"), s.appendChild(p);
  }), s;
}
function Nte({
  strokeWidth: t,
  spline: e,
  color: n
}) {
  const { path: r } = e, a = document.createElementNS("http://www.w3.org/2000/svg", "path");
  return a.setAttribute("stroke-width", t.toString()), a.setAttribute("stroke", n), a.setAttribute("fill", "none"), a.setAttribute("d", r), a;
}
function Lte(t, e, n, r) {
  switch (t.props.dash) {
    case "draw":
      return Ote({
        shape: t,
        strokeWidth: r,
        spline: e,
        color: n
      });
    case "solid":
      return Nte({
        strokeWidth: r,
        spline: e,
        color: n
      });
    default:
      return Dte({
        strokeWidth: r,
        spline: e,
        dash: t.props.dash,
        color: n
      });
  }
}
const jte = new um(), zte = new um();
class Ute extends Oc {
  static type = "line";
  hideResizeHandles = () => !0;
  hideRotateHandle = () => !0;
  hideSelectionBoundsBg = () => !0;
  hideSelectionBoundsFg = () => !0;
  isClosed = () => !1;
  defaultProps() {
    return {
      opacity: "1",
      dash: "draw",
      size: "m",
      color: "black",
      spline: "line",
      handles: {
        start: {
          id: "start",
          type: "vertex",
          canBind: !1,
          index: "a1",
          x: 0,
          y: 0
        },
        end: {
          id: "end",
          type: "vertex",
          canBind: !1,
          index: "a2",
          x: 0,
          y: 0
        }
      }
    };
  }
  getBounds(e) {
    return xp(e).bounds;
  }
  getCenter(e) {
    return this.bounds(e).center;
  }
  getHandles(e) {
    return zte.get(e.props, () => {
      const n = e.props.handles, r = xp(e), a = Object.values(n).sort(Ya), s = a.slice();
      for (let c = 0; c < r.segments.length; c++) {
        const p = r.segments[c].getPoint(0.5), g = Hy(a[c].index, a[c + 1].index);
        s.push({
          id: `mid-${c}`,
          type: "create",
          index: g,
          x: p.x,
          y: p.y
        });
      }
      return s.sort(Ya);
    });
  }
  getOutline(e) {
    return Tj(xp(e));
  }
  //   Events
  onResize = (e, n) => {
    const { scaleX: r, scaleY: a } = n, s = Tc(e.props.handles);
    return Object.values(e.props.handles).forEach(({ id: c, x: f, y: p }) => {
      s[c].x = f * r, s[c].y = p * a;
    }), {
      props: {
        handles: s
      }
    };
  };
  onHandleChange = (e, { handle: n }) => {
    const r = Tc(e);
    switch (n.id) {
      case "start":
      case "end": {
        r.props.handles[n.id] = {
          ...r.props.handles[n.id],
          x: n.x,
          y: n.y
        };
        break;
      }
      default: {
        const a = "handle:" + n.index, s = e.props.handles[a];
        s ? r.props.handles[a] = {
          ...s,
          x: n.x,
          y: n.y
        } : r.props.handles[a] = {
          id: a,
          type: "vertex",
          canBind: !1,
          index: n.index,
          x: n.x,
          y: n.y
        };
        break;
      }
    }
    return r;
  };
  hitTestPoint(e, n) {
    return Yq(n, this.outline(e));
  }
  hitTestLineSegment(e, n, r) {
    return RI(n, r, this.outline(e)) !== null;
  }
  render(e) {
    const n = xp(e), r = un("zoom", () => this.app.zoomLevel < 0.35, []), a = this.app.getStrokeWidth(e.props.size), s = n.path, { dash: c, color: f } = e.props;
    return /* @__PURE__ */ E.jsxs(Mp, { id: e.id, children: [
      /* @__PURE__ */ E.jsx(gs, { d: s, fill: "none", color: f }),
      c === "draw" && !r ? /* @__PURE__ */ E.jsx(
        "path",
        {
          d: Ij(e, n, a),
          strokeWidth: 1,
          stroke: "currentColor",
          fill: "currentColor"
        }
      ) : c === "solid" ? /* @__PURE__ */ E.jsx("path", { strokeWidth: a, stroke: "currentColor", fill: "none", d: s }) : /* @__PURE__ */ E.jsx("g", { stroke: "currentColor", strokeWidth: a, children: n.segments.map((p, g) => {
        const { strokeDasharray: y, strokeDashoffset: v } = Gs(
          p.length,
          a,
          {
            style: c,
            start: g > 0 ? "outset" : "none",
            end: g < n.segments.length - 1 ? "outset" : "none"
          }
        );
        return /* @__PURE__ */ E.jsx(
          "path",
          {
            strokeDasharray: y,
            strokeDashoffset: v,
            d: p.path,
            fill: "none"
          },
          g
        );
      }) })
    ] });
  }
  indicator(e) {
    const n = this.app.getStrokeWidth(e.props.size), r = Ate(e, xp(e), n);
    return /* @__PURE__ */ E.jsx("path", { d: r });
  }
  toSvg(e, n, r) {
    const { color: a, size: s } = e.props, c = r.fill[a], f = xp(e);
    return Lte(e, f, c, this.app.getStrokeWidth(s));
  }
}
const Rj = gi({
  type: "line",
  getShapeUtil: () => Ute,
  validator: $q,
  migrations: Mq
});
function xp(t) {
  return jte.get(t.props, () => {
    const { spline: e, handles: n } = t.props, r = Object.values(n).sort(Ya).map(O.From);
    switch (e) {
      case "cubic":
        return new kI(r, r.length === 2 ? 2 : 1.2, 20);
      case "line":
        return new PI(r);
    }
  });
}
const Cc = 200;
class Bte extends Oc {
  static type = "note";
  canEdit = () => !0;
  hideResizeHandles = () => !0;
  hideSelectionBoundsBg = () => !0;
  hideSelectionBoundsFg = () => !0;
  defaultProps() {
    return {
      opacity: "1",
      color: "black",
      size: "m",
      text: "",
      font: "draw",
      align: "middle",
      growY: 0,
      url: ""
    };
  }
  getHeight(e) {
    return Cc + e.props.growY;
  }
  getBounds(e) {
    const n = this.getHeight(e);
    return new ot(0, 0, Cc, n);
  }
  getOutline(e) {
    return this.bounds(e).corners;
  }
  getCenter(e) {
    return new O(Cc / 2, this.getHeight(e) / 2);
  }
  render(e) {
    const {
      id: n,
      type: r,
      props: { color: a, font: s, size: c, align: f, text: p }
    } = e, g = a === "black" ? "yellow" : a;
    return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(
        "div",
        {
          style: {
            position: "absolute",
            width: Cc,
            height: this.getHeight(e)
          },
          children: /* @__PURE__ */ E.jsxs(
            "div",
            {
              className: "rs-note__container rs-hitarea-fill",
              style: {
                color: `var(--palette-${g})`,
                backgroundColor: `var(--palette-${g})`
              },
              children: [
                /* @__PURE__ */ E.jsx("div", { className: "rs-note__scrim" }),
                /* @__PURE__ */ E.jsx(
                  yj,
                  {
                    id: n,
                    type: r,
                    font: s,
                    size: c,
                    align: f,
                    text: p,
                    labelColor: "inherit",
                    wrap: !0
                  }
                )
              ]
            }
          )
        }
      ),
      "url" in e.props && e.props.url && /* @__PURE__ */ E.jsx(Tb, { url: e.props.url })
    ] });
  }
  indicator(e) {
    return /* @__PURE__ */ E.jsx(
      "rect",
      {
        rx: "7",
        width: ze(Cc),
        height: ze(this.getHeight(e))
      }
    );
  }
  toSvg(e, n, r) {
    const a = this.bounds(e), s = document.createElementNS("http://www.w3.org/2000/svg", "g"), c = e.props.color === "black" ? "yellow" : e.props.color, f = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    f.setAttribute("rx", "10"), f.setAttribute("width", Cc.toString()), f.setAttribute("height", a.height.toString()), f.setAttribute("fill", r.fill[c]), f.setAttribute("stroke", r.fill[c]), f.setAttribute("stroke-width", "1"), s.appendChild(f);
    const p = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    p.setAttribute("rx", "10"), p.setAttribute("width", Cc.toString()), p.setAttribute("height", a.height.toString()), p.setAttribute("fill", r.background), p.setAttribute("opacity", ".28"), s.appendChild(p);
    const g = 17, y = {
      fontSize: Xd[e.props.size],
      fontFamily: n,
      textAlign: e.props.align,
      width: a.width - g * 2,
      height: a.height - g * 2,
      padding: 0,
      lineHeight: Ki.lineHeight,
      fontStyle: "normal",
      fontWeight: "normal"
    }, v = this.app.textMeasure.getTextLines({
      text: e.props.text,
      wrap: !0,
      ...y
    }), S = m1(this.app, {
      lines: v,
      ...y
    });
    return S.setAttribute("fill", r.text), S.setAttribute("transform", `translate(${g} ${g})`), s.appendChild(S), s;
  }
  onBeforeCreate = (e) => ND(this.app, e, e.props.growY);
  onBeforeUpdate = (e, n) => {
    if (!(e.props.text === n.props.text && e.props.font === n.props.font && e.props.size === n.props.size))
      return ND(this.app, n, e.props.growY);
  };
  onEditEnd = (e) => {
    const {
      id: n,
      type: r,
      props: { text: a }
    } = e;
    a.trim() !== e.props.text && this.app.updateShapes([
      {
        id: n,
        type: r,
        props: {
          text: a.trim()
        }
      }
    ]);
  };
}
const dP = gi({
  getShapeUtil: () => Bte,
  type: "note",
  validator: Aq,
  migrations: Oq
});
function ND(t, e, n = 0) {
  const s = t.textMeasure.measureText({
    ...Ki,
    text: e.props.text,
    fontFamily: qd[e.props.font],
    fontSize: Xd[e.props.size],
    width: Cc - 34 + "px"
  }).h + 17 * 2;
  let c = null;
  if (s > Cc ? c = s - Cc : n && (c = 0), c !== null)
    return {
      ...e,
      props: {
        ...e.props,
        growY: c
      }
    };
}
function Fte(t, {
  initialBounds: e,
  scaleX: n,
  scaleY: r,
  newPoint: a
}) {
  const s = Math.max(0.01, Math.min(Math.abs(n), Math.abs(r))), c = new O(0, 0);
  n < 0 && (c.x = -(e.width * s)), r < 0 && (c.y = -(e.height * s));
  const { x: f, y: p } = O.Add(a, c.rot(t.rotation));
  return {
    x: f,
    y: p,
    props: {
      scale: s * t.props.scale
    }
  };
}
const Hte = new um();
class Vte extends Oc {
  static type = "text";
  canEdit = () => !0;
  isAspectRatioLocked = () => !0;
  defaultProps() {
    return {
      opacity: "1",
      color: "black",
      size: "m",
      w: 8,
      text: "",
      font: "draw",
      align: "middle",
      autoSize: !0,
      scale: 1
    };
  }
  // @computed
  // private get minDimensionsCache() {
  // 	return this.app.store.createSelectedComputedCache<
  // 		TLTextShape['props'],
  // 		{ width: number; height: number },
  // 		TLTextShape
  // 	>(
  // 		'text measure cache',
  // 		(shape) => {
  // 			return shape.props
  // 		},
  // 		(props) => getTextSize(this.app, props)
  // 	)
  // }
  getMinDimensions(e) {
    return Hte.get(e.props, (n) => LD(this.app, n));
  }
  getBounds(e) {
    const { scale: n } = e.props, { width: r, height: a } = this.getMinDimensions(e);
    return new ot(0, 0, r * n, a * n);
  }
  getOutline(e) {
    const n = this.bounds(e);
    return [
      new O(0, 0),
      new O(n.width, 0),
      new O(n.width, n.height),
      new O(0, n.height)
    ];
  }
  getCenter(e) {
    const n = this.bounds(e);
    return new O(n.width / 2, n.height / 2);
  }
  render(e) {
    const {
      id: n,
      type: r,
      props: { text: a }
    } = e, { width: s, height: c } = this.getMinDimensions(e), {
      rInput: f,
      isEmpty: p,
      isEditing: g,
      isEditableFromHover: y,
      handleFocus: v,
      handleChange: S,
      handleKeyDown: x,
      handleBlur: _
    } = VI(n, r, a);
    return /* @__PURE__ */ E.jsx(ha, { id: e.id, children: /* @__PURE__ */ E.jsxs(
      "div",
      {
        className: "rs-text-shape__wrapper rs-text-shadow",
        "data-font": e.props.font,
        "data-align": e.props.align,
        "data-hastext": !p,
        "data-isediting": g || y,
        "data-textwrap": !0,
        style: {
          fontSize: Hg[e.props.size],
          lineHeight: Hg[e.props.size] * Ki.lineHeight + "px",
          transform: `scale(${e.props.scale})`,
          transformOrigin: "top left",
          width: Math.max(1, s),
          height: Math.max(Hg[e.props.size] * Ki.lineHeight, c)
        },
        children: [
          /* @__PURE__ */ E.jsx("div", { className: "rs-text rs-text-content", dir: "ltr", children: a }),
          g || y ? /* @__PURE__ */ E.jsx(
            "textarea",
            {
              ref: f,
              className: "rs-text rs-text-input",
              name: "text",
              tabIndex: -1,
              autoComplete: "false",
              autoCapitalize: "false",
              autoCorrect: "false",
              autoSave: "false",
              autoFocus: g,
              placeholder: "",
              spellCheck: "true",
              wrap: "off",
              dir: "ltr",
              datatype: "wysiwyg",
              defaultValue: a,
              onFocus: v,
              onChange: S,
              onKeyDown: x,
              onBlur: _,
              onTouchEnd: Pc,
              onContextMenu: Pc
            }
          ) : null
        ]
      }
    ) });
  }
  indicator(e) {
    const n = this.bounds(e);
    return /* @__PURE__ */ E.jsx("rect", { width: ze(n.width), height: ze(n.height) });
  }
  toSvg(e, n, r) {
    const a = this.bounds(e), s = e.props.text, c = a.width / (e.props.scale ?? 1), f = a.height / (e.props.scale ?? 1), p = {
      fontSize: Hg[e.props.size],
      fontFamily: n,
      textAlign: e.props.align,
      width: c,
      height: f,
      padding: 0,
      // no padding?
      lineHeight: Ki.lineHeight,
      fontStyle: "normal",
      fontWeight: "normal"
    }, g = this.app.textMeasure.getTextLines({
      text: s,
      wrap: !0,
      ...p
    }), y = r.fill[e.props.color], v = document.createElementNS("http://www.w3.org/2000/svg", "g"), S = m1(this.app, {
      lines: g,
      ...p,
      stroke: r.background,
      strokeWidth: 2,
      fill: r.background,
      padding: 0
    }), x = S.cloneNode(!0);
    return x.setAttribute("fill", y), x.setAttribute("stroke", "none"), v.append(S), v.append(x), v;
  }
  onResize = (e, n) => {
    const { initialBounds: r, initialShape: a, scaleX: s, handle: c } = n;
    if (n.mode === "scale_shape" || c !== "right" && c !== "left")
      return Fte(e, n);
    {
      const f = r.width;
      let p = f * s;
      const g = new O(0, 0);
      p = Math.max(1, Math.abs(p)), c === "left" ? (g.x = f - p, s < 0 && (g.x += p)) : s < 0 && (g.x -= p);
      const { x: y, y: v } = g.rot(e.rotation).add(a);
      return {
        x: y,
        y: v,
        props: {
          w: p / a.props.scale,
          autoSize: !1
        }
      };
    }
  };
  onBeforeCreate = (e) => {
    if (!e.props.autoSize || e.props.text.trim())
      return;
    const n = this.getMinDimensions(e);
    return {
      ...e,
      x: e.x - n.width / 2,
      y: e.y - n.height / 2
    };
  };
  onEditEnd = (e) => {
    const {
      id: n,
      type: r,
      props: { text: a }
    } = e, s = e.props.text.trim();
    s.length === 0 ? this.app.deleteShapes([e.id]) : s !== e.props.text && this.app.updateShapes([
      {
        id: n,
        type: r,
        props: {
          text: a.trim()
        }
      }
    ]);
  };
  onBeforeUpdate = (e, n) => {
    if (!n.props.autoSize)
      return;
    const r = e.props.size !== n.props.size || e.props.align !== n.props.align || e.props.font !== n.props.font || e.props.scale !== 1 && n.props.scale === 1, a = e.props.text !== n.props.text;
    if (!r && !a)
      return;
    const s = this.getMinDimensions(e), c = LD(this.app, n.props), f = s.width * e.props.scale, p = s.height * e.props.scale, g = c.width * n.props.scale, y = c.height * n.props.scale;
    let v;
    switch (n.props.align) {
      case "middle": {
        v = new O((g - f) / 2, a ? 0 : (y - p) / 2);
        break;
      }
      case "end": {
        v = new O(g - f, a ? 0 : (y - p) / 2);
        break;
      }
      default: {
        if (a)
          break;
        v = new O(0, (y - p) / 2);
        break;
      }
    }
    if (v) {
      v.rot(n.rotation);
      const { x: S, y: x } = n;
      return {
        ...n,
        x: S - v.x,
        y: x - v.y,
        props: { ...n.props, w: g }
      };
    } else
      return {
        ...n,
        props: { ...n.props, w: g }
      };
  };
  onDoubleClickEdge = (e) => {
    if (!e.props.autoSize)
      return {
        id: e.id,
        type: e.type,
        props: {
          autoSize: !0
        }
      };
    if (e.props.scale !== 1)
      return {
        id: e.id,
        type: e.type,
        props: {
          scale: 1
        }
      };
  };
}
const b1 = gi({
  type: "text",
  getShapeUtil: () => Vte,
  validator: Dq,
  migrations: Nq
});
function LD(t, e) {
  const { font: n, text: r, autoSize: a, size: s, w: c } = e, f = 16, p = Hg[s], g = a ? "fit-content" : (
    // `measureText` floors the number so we need to do the same here to avoid issues.
    Math.floor(Math.max(f, c)) + "px"
  ), y = t.textMeasure.measureText({
    ...Ki,
    text: r,
    fontFamily: qd[n],
    fontSize: p,
    width: g
  });
  return a && (y.w += 1), {
    width: Math.max(f, y.w),
    height: Math.max(p, y.h)
  };
}
class Yte extends ya {
  static type = "video";
  canEdit = () => !0;
  isAspectRatioLocked = () => !0;
  defaultProps() {
    return {
      opacity: "1",
      w: 100,
      h: 100,
      assetId: null,
      time: 0,
      playing: !0,
      url: ""
    };
  }
  render(e) {
    return /* @__PURE__ */ E.jsx(Gte, { shape: e, videoUtil: this });
  }
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: ze(e.props.w), height: ze(e.props.h) });
  }
  toSvg(e) {
    const n = document.createElementNS("http://www.w3.org/2000/svg", "g"), r = document.createElementNS("http://www.w3.org/2000/svg", "image");
    return r.setAttributeNS("http://www.w3.org/1999/xlink", "href", Wte(e.id)), r.setAttribute("width", e.props.w.toString()), r.setAttribute("height", e.props.h.toString()), n.appendChild(r), n;
  }
}
const Kte = gi({
  type: "video",
  getShapeUtil: () => Yte,
  validator: Lq,
  migrations: jq
});
function Wte(t) {
  const e = t.split(":")[1], n = document.querySelector(`.rs-video-shape-${e}`);
  if (n) {
    const r = document.createElement("canvas");
    return r.width = n.videoWidth, r.height = n.videoHeight, r.getContext("2d").drawImage(n, 0, 0), r.toDataURL("image/png");
  } else
    throw new Error("Video with id " + e + " not found");
}
const Gte = dn(function(e) {
  const { shape: n, videoUtil: r } = e, a = r.app.getBounds(n).w * r.app.zoomLevel >= 110, s = n.props.assetId ? r.app.getAssetById(n.props.assetId) : null, { w: c, h: f, time: p, playing: g } = n.props, y = FI(n.id), v = XL(), S = k.useRef(null), x = k.useCallback(
    (j) => {
      const L = j.currentTarget;
      r.app.updateShapes([
        {
          type: "video",
          id: n.id,
          props: {
            playing: !0,
            time: L.currentTime
          }
        }
      ]);
    },
    [n.id, r.app]
  ), _ = k.useCallback(
    (j) => {
      const L = j.currentTarget;
      r.app.updateShapes([
        {
          type: "video",
          id: n.id,
          props: {
            playing: !1,
            time: L.currentTime
          }
        }
      ]);
    },
    [n.id, r.app]
  ), T = k.useCallback(
    (j) => {
      const L = j.currentTarget;
      y && r.app.updateShapes([
        {
          type: "video",
          id: n.id,
          props: {
            time: L.currentTime
          }
        }
      ]);
    },
    [y, n.id, r.app]
  ), [I, D] = k.useState(!1), N = k.useCallback(
    (j) => {
      const L = j.currentTarget;
      p !== L.currentTime && (L.currentTime = p), g || L.pause(), D(!0);
    },
    [g, p]
  );
  return k.useEffect(() => {
    const j = S.current;
    j && I && !y && p !== j.currentTime && (j.currentTime = p);
  }, [y, I, p]), k.useEffect(() => {
    if (v) {
      const j = S.current;
      j.pause(), j.currentTime = 0;
    }
  }, [S, v]), /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(ha, { id: n.id, children: /* @__PURE__ */ E.jsx("div", { className: "rs-counter-scaled", children: s?.props.src ? /* @__PURE__ */ E.jsx(
      "video",
      {
        ref: S,
        className: `rs-video rs-video-shape-${n.id.split(":")[1]} rs-hitarea-stroke`,
        width: "100%",
        height: "100%",
        draggable: !1,
        playsInline: !0,
        autoPlay: !0,
        muted: !0,
        loop: !0,
        disableRemotePlayback: !0,
        disablePictureInPicture: !0,
        controls: y && a,
        onPlay: x,
        onPause: _,
        onTimeUpdate: T,
        onLoadedData: N,
        hidden: !I,
        children: /* @__PURE__ */ E.jsx("source", { src: s.props.src })
      }
    ) : /* @__PURE__ */ E.jsx(
      y1,
      {
        x: (c - 38) / 2,
        y: (f - 38) / 2
      }
    ) }) }),
    "url" in n.props && n.props.url && /* @__PURE__ */ E.jsx(Tb, { url: n.props.url })
  ] });
}), Xte = () => [
  vj,
  b1,
  Rj,
  ro,
  $te,
  Kte,
  Cj,
  dP,
  _j,
  v1,
  nb,
  px
];
class kb {
  static default = new kb({});
  storeSchema;
  shapes;
  TLShape;
  tools;
  constructor({
    shapes: e = [],
    tools: n = [],
    allowUnknownShapes: r = !1
  }) {
    this.tools = n;
    const a = [...Xte(), ...e];
    this.shapes = a;
    const s = /* @__PURE__ */ new Set();
    for (const g of a) {
      if (s.has(g.type))
        throw new Error(`Shape type ${g.type} is already defined`);
      s.add(g.type);
    }
    const c = xr({
      currentVersion: BT.currentVersion,
      firstVersion: BT.firstVersion,
      migrators: BT.migrators,
      subTypeKey: "type",
      subTypeMigrations: Object.fromEntries(a.map((g) => [g.type, g.migrations]))
    });
    let f = xI("type", {
      ...Object.fromEntries(a.map((g) => [g.type, g.validator]))
    });
    r && (f = f.validateUnknownVariants((g) => g));
    const p = $c("shape", {
      migrations: c,
      validator: Mc("shape", f)
    }).withDefaultProperties(() => ({ x: 0, y: 0, rotation: 0, isLocked: !1 }));
    this.TLShape = p, this.storeSchema = yI.create(
      {
        asset: cm,
        camera: Xy,
        document: CI,
        instance: Rp,
        instance_page_state: qy,
        page: fr,
        shape: p,
        user: $p,
        user_document: aP,
        user_presence: sP
      },
      {
        snapshotMigrations: pq,
        onValidationFailure: JX,
        ensureStoreIsUsable: xc
      }
    );
  }
  createStore(e) {
    let n = e.initialData;
    return n && (n = lq(n)), new mL({
      schema: this.storeSchema,
      initialData: n,
      props: {
        userId: e?.userId ?? $p.createId(),
        instanceId: e?.instanceId ?? Rp.createId(),
        documentId: Ix
      }
    });
  }
}
const qte = (t) => {
  const e = t.query.filterHistory("shape"), n = t.query.records("shape", () => ({ type: { eq: "arrow" } }));
  function r() {
    const a = n.value, s = {};
    for (const c of a) {
      const { start: f, end: p } = c.props;
      if (f.type === "binding") {
        const g = s[f.boundShapeId];
        g ? g.push({ arrowId: c.id, handleId: "start" }) : s[f.boundShapeId] = [{ arrowId: c.id, handleId: "start" }];
      }
      if (p.type === "binding") {
        const g = s[p.boundShapeId];
        g ? g.push({ arrowId: c.id, handleId: "end" }) : s[p.boundShapeId] = [{ arrowId: c.id, handleId: "end" }];
      }
    }
    return s;
  }
  return pt("arrowBindingsIndex", (a, s) => {
    if (Wg(a))
      return r();
    const c = a, f = e.getDiffSince(s);
    if (f === fs)
      return r();
    let p;
    function g(S) {
      p || (p = { ...c }), p[S] ? p[S] === c[S] && (p[S] = [...p[S]]) : p[S] = [];
    }
    function y(S, x, _) {
      g(S), p[S] = p[S].filter(
        (T) => T.arrowId !== x || T.handleId !== _
      ), p[S].length === 0 && delete p[S];
    }
    function v(S, x, _) {
      g(S), p[S].push({ arrowId: x, handleId: _ });
    }
    for (const S of f) {
      for (const x of Object.values(S.added))
        if (ro.is(x)) {
          const { start: _, end: T } = x.props;
          _.type === "binding" && v(_.boundShapeId, x.id, "start"), T.type === "binding" && v(T.boundShapeId, x.id, "end");
        }
      for (const [x, _] of Object.values(S.updated))
        if (!(!ro.is(x) || !ro.is(_)))
          for (const T of ["start", "end"]) {
            const I = x.props[T], D = _.props[T];
            I.type === "binding" && D.type === "point" ? y(I.boundShapeId, x.id, T) : I.type === "point" && D.type === "binding" ? v(D.boundShapeId, _.id, T) : I.type === "binding" && D.type === "binding" && I.boundShapeId !== D.boundShapeId && (y(I.boundShapeId, x.id, T), v(D.boundShapeId, _.id, T));
          }
      for (const x of Object.values(S.removed))
        if (ro.is(x)) {
          const { start: _, end: T } = x.props;
          _.type === "binding" && y(_.boundShapeId, x.id, "start"), T.type === "binding" && y(T.boundShapeId, x.id, "end");
        }
    }
    return p ?? c;
  });
}, Qte = (t) => {
  const e = t.query.ids("shape");
  function n() {
    const r = {};
    return e.value.forEach((a) => {
      const s = t.get(a);
      r[s.parentId] || (r[s.parentId] = []), r[s.parentId].push([a, s.index]);
    }), Object.values(r).forEach((a) => a.sort((s, c) => s[1] < c[1] ? -1 : 1)), r;
  }
  return pt(
    "parentsToChildrenWithIndexes",
    (r, a) => {
      if (Wg(r))
        return n();
      const s = t.history.getDiffSince(a);
      if (s === fs)
        return n();
      if (s.length === 0)
        return r;
      let c = null;
      const f = (y) => {
        c || (c = { ...r }), c[y] ? c[y] === r[y] && (c[y] = [...c[y]]) : c[y] = [];
      }, p = /* @__PURE__ */ new Set();
      let g;
      for (let y = 0, v = s.length; y < v; y++) {
        g = s[y];
        for (const S of Object.values(g.added))
          Tp(S) && (f(S.parentId), c[S.parentId].push([S.id, S.index]), p.add(c[S.parentId]));
        for (const [S, x] of Object.values(g.updated))
          if (Tp(x) && Tp(S)) {
            if (S.parentId !== x.parentId)
              f(S.parentId), f(x.parentId), c[S.parentId].splice(
                c[S.parentId].findIndex((_) => _[0] === x.id),
                1
              ), c[x.parentId].push([x.id, x.index]), p.add(c[x.parentId]);
            else if (S.index !== x.index) {
              f(x.parentId);
              const _ = c[x.parentId].findIndex((T) => T[0] === x.id);
              c[x.parentId][_] = [x.id, x.index], p.add(c[x.parentId]);
            }
          }
        for (const S of Object.values(g.removed))
          Tp(S) && (f(S.parentId), c[S.parentId].splice(
            c[S.parentId].findIndex((x) => x[0] === S.id),
            1
          ));
      }
      for (const y of p)
        y.sort((v, S) => v[1] < S[1] ? -1 : 1);
      return c ?? r;
    }
  );
}, dk = (t, e, n) => {
  for (; !fr.isId(n.parentId); ) {
    const r = t.get(n.parentId);
    if (!r)
      return !1;
    n = r;
  }
  return n.parentId === e;
}, Zte = (t, e) => {
  const n = t.query.ids("shape");
  let r = null;
  function a() {
    const s = e();
    return r = s, new Set(
      [...n.value].filter((c) => dk(t, s, t.get(c)))
    );
  }
  return pt("_shapeIdsInCurrentPage", (s, c) => {
    if (Wg(s))
      return a();
    const f = e();
    if (f !== r)
      return a();
    const p = t.history.getDiffSince(c);
    if (p === fs)
      return a();
    const g = new cx(
      s
    );
    for (const v of p) {
      for (const S of Object.values(v.added))
        Tp(S) && dk(t, f, S) && g.add(S.id);
      for (const [S, x] of Object.values(v.updated))
        Tp(x) && (dk(t, f, x) ? g.add(x.id) : g.remove(x.id));
      for (const S of Object.keys(v.removed))
        Fs(S) && g.remove(S);
    }
    const y = g.get();
    return y ? Ly(y.value, y.diff) : s;
  });
}, $j = {
  top: 10,
  left: 10,
  bottom: 10,
  right: 10
};
function Mj(t) {
  const e = t.getContainer(), n = e.querySelector('*[data-tldraw-area="active-drawing"]'), r = {
    ...$j,
    width: 0,
    height: 0
  };
  if (n && e) {
    const a = e.getBoundingClientRect(), s = n.getBoundingClientRect();
    r.top = s.top, r.left = s.left, r.bottom = a.height - s.bottom, r.right = a.width - s.right;
  }
  return r.width = t.viewportScreenBounds.width - r.left - r.right, r.height = t.viewportScreenBounds.height - r.top - r.bottom, r;
}
function Jte(t) {
  const e = Mj(t), n = t.camera.z;
  return e.left /= n, e.right /= n, e.top /= n, e.bottom /= n, e.width /= n, e.height /= n, e;
}
class ene {
  constructor(e) {
    this.app = e, window.addEventListener("resize", this.updateOffsets), this.app.disposables.add(this.dispose);
  }
  offsets = hi("activeAreaOffsets", $j);
  updateOffsets = () => {
    const e = Jte(this.app);
    this.offsets.set(e);
  };
  // Clear the listener
  dispose = () => {
    window.addEventListener("resize", this.updateOffsets);
  };
}
const tne = 12;
class nne {
  constructor(e) {
    this.app = e;
  }
  state = hi("camera state", "idle");
  timeoutRemaining = 0;
  decay = (e) => {
    this.timeoutRemaining -= e, this.timeoutRemaining <= 0 && (this.state.set("idle"), this.app.off("tick", this.decay), this.app.updateCullingBounds());
  };
  tick = () => {
    this.timeoutRemaining = tne, this.state.__unsafe__getWithoutCapture() === "idle" && (this.state.set("moving"), this.app.on("tick", this.decay));
  };
}
const rne = 40;
class ine {
  constructor(e) {
    this.app = e;
  }
  _clickId = "";
  _clickTimeout;
  _clickScreenPoint;
  _previousScreenPoint;
  _getClickTimeout = (e, n = $i()) => {
    this._clickId = n, clearTimeout(this._clickTimeout), this._clickTimeout = setTimeout(
      () => {
        if (this._clickState === e && this._clickId === n) {
          switch (this._clickState) {
            case "pendingTriple": {
              this.app.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "double_click",
                phase: "settle"
              });
              break;
            }
            case "pendingQuadruple": {
              this.app.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "triple_click",
                phase: "settle"
              });
              break;
            }
            case "pendingOverflow": {
              this.app.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "quadruple_click",
                phase: "settle"
              });
              break;
            }
          }
          this._clickState = "idle";
        }
      },
      e === "idle" || e === "pendingDouble" ? dQ : fQ
    );
  };
  /**
   * The current click state.
   *
   * @internal
   */
  _clickState = "idle";
  /**
   * The current click state.
   *
   * @public
   */
  get clickState() {
    return this._clickState;
  }
  lastPointerInfo = {};
  /**
   * Start the double click timeout.
   *
   * @param info - The event info.
   */
  transformPointerDownEvent = (e) => {
    if (!this._clickState)
      return e;
    switch (this._clickScreenPoint = O.From(e.point), this._previousScreenPoint && this._previousScreenPoint.dist(this._clickScreenPoint) > rne && (this._clickState = "idle"), this._previousScreenPoint = this._clickScreenPoint, this.lastPointerInfo = e, this._clickState) {
      case "idle":
        return this._clickState = "pendingDouble", this._clickTimeout = this._getClickTimeout(this._clickState), e;
      case "pendingDouble":
        return this._clickState = "pendingTriple", this._clickTimeout = this._getClickTimeout(this._clickState), {
          ...e,
          type: "click",
          name: "double_click",
          phase: "down"
        };
      case "pendingTriple":
        return this._clickState = "pendingQuadruple", this._clickTimeout = this._getClickTimeout(this._clickState), {
          ...e,
          type: "click",
          name: "triple_click",
          phase: "down"
        };
      case "pendingQuadruple":
        return this._clickState = "pendingOverflow", this._clickTimeout = this._getClickTimeout(this._clickState), {
          ...e,
          type: "click",
          name: "quadruple_click",
          phase: "down"
        };
      case "pendingOverflow":
        return this._clickState = "overflow", this._clickTimeout = this._getClickTimeout(this._clickState), e;
      default:
        return this._clickTimeout = this._getClickTimeout(this._clickState), e;
    }
  };
  /**
   * Emit click_up events on pointer up.
   *
   * @param info - The event info.
   */
  transformPointerUpEvent = (e) => {
    if (!this._clickState)
      return e;
    switch (this._clickScreenPoint = O.From(e.point), this._clickState) {
      case "pendingTriple":
        return {
          ...this.lastPointerInfo,
          type: "click",
          name: "double_click",
          phase: "up"
        };
      case "pendingQuadruple":
        return {
          ...this.lastPointerInfo,
          type: "click",
          name: "triple_click",
          phase: "up"
        };
      case "pendingOverflow":
        return {
          ...this.lastPointerInfo,
          type: "click",
          name: "quadruple_click",
          phase: "up"
        };
      default:
        return e;
    }
  };
  /**
   * Cancel the double click timeout.
   *
   * @internal
   */
  cancelDoubleClickTimeout = () => {
    this._clickTimeout = clearTimeout(this._clickTimeout), this._clickState = "idle";
  };
  /**
   * Handle a move event, possibly cancelling the click timeout.
   *
   * @internal
   */
  handleMove = () => {
    this._clickState !== "idle" && this._clickScreenPoint && this._clickScreenPoint.dist(this.app.inputs.currentScreenPoint) > eb && this.cancelDoubleClickTimeout();
  };
}
class one {
  constructor(e) {
    this.app = e, this.rebind(), this.app.disposables.add(this.dispose);
  }
  _currentMM;
  // Set a listener to update the dpr when the device pixel ratio changes
  rebind() {
    this.dispose(), this._currentMM = this.getMedia(), this._currentMM?.addEventListener("change", this.updateDevicePixelRatio);
  }
  dpr = hi(
    "devicePixelRatio",
    typeof window > "u" ? 1 : window.devicePixelRatio
  );
  // Get the media query list for the device pixel ratio
  getMedia() {
    if (window.matchMedia)
      return matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
  }
  // Update the device pixel ratio atom
  updateDevicePixelRatio = () => {
    this.dpr.set(window.devicePixelRatio), this.rebind();
  };
  // Clear the listener
  dispose = () => {
    this._currentMM?.removeEventListener("change", this.updateDevicePixelRatio);
  };
}
const jD = 100;
class ane {
  constructor(e) {
    this.app = e, e.disposables.add(this.dispose);
  }
  prevDroppingShapeId = null;
  currDroppingShapeId = null;
  droppingNodeTimer = null;
  updateDroppingNode(e, n) {
    if (this.droppingNodeTimer === null) {
      const { currentPagePoint: r } = this.app.inputs;
      this.currDroppingShapeId = this.app.getDroppingShape(r, e)?.id ?? null, this.setDragTimer(e, jD * 10, n);
    } else
      this.app.inputs.pointerVelocity.len() > 0.5 && (clearInterval(this.droppingNodeTimer), this.setDragTimer(e, jD, n));
  }
  setDragTimer(e, n, r) {
    this.droppingNodeTimer = setTimeout(() => {
      this.app.batch(() => {
        this.handleDrag(e, r);
      }), this.droppingNodeTimer = null;
    }, n);
  }
  handleDrag(e, n) {
    const { currentPagePoint: r } = this.app.inputs;
    e = Gt(e.map((p) => this.app.getShapeById(p.id)));
    const a = this.app.getDroppingShape(r, e)?.id ?? null;
    a !== this.currDroppingShapeId && (this.prevDroppingShapeId = this.currDroppingShapeId, this.currDroppingShapeId = a);
    const { prevDroppingShapeId: s } = this;
    if (a === s)
      return;
    const c = s && this.app.getShapeById(s), f = a && this.app.getShapeById(a);
    if (this.prevDroppingShapeId = this.currDroppingShapeId, c && this.app.getShapeUtil(c).onDragShapesOut?.(c, e), f) {
      const p = this.app.getShapeUtil(f).onDragShapesOver?.(f, e);
      p && p.shouldHint && this.app.setHintingIds([f.id]);
    } else
      this.app.setHintingIds([]);
    n?.();
  }
  dropShapes(e) {
    const { currDroppingShapeId: n } = this;
    if (this.handleDrag(e), n) {
      const r = this.app.getShapeById(n);
      if (!r)
        return;
      this.app.getShapeUtil(r).onDropShapesOver?.(r, e);
    }
  }
  clear() {
    this.prevDroppingShapeId = null, this.currDroppingShapeId = null, this.droppingNodeTimer !== null && clearInterval(this.droppingNodeTimer), this.droppingNodeTimer = null, this.app.setHintingIds([]);
  }
  dispose = () => {
    this.clear();
  };
}
function yp(t) {
  if (t) {
    let e = zD;
    for (; t.length; )
      e = e.push(t.pop());
    return e;
  }
  return zD;
}
class sne {
  length = 0;
  head = null;
  tail = this;
  push(e) {
    return new XI(e, this);
  }
  toArray() {
    return Ws;
  }
  [Symbol.iterator]() {
    return {
      next() {
        return { value: void 0, done: !0 };
      }
    };
  }
}
const zD = new sne();
class XI {
  constructor(e, n) {
    this.head = e, this.tail = n, this.length = n.length + 1;
  }
  length;
  push(e) {
    return new XI(e, this);
  }
  toArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e = this;
    return {
      next() {
        if (e.length) {
          const n = e.head;
          return e = e.tail, { value: n, done: !1 };
        } else
          return { value: void 0, done: !0 };
      }
    };
  }
}
class lne {
  // A flag for whether the user is in a batch operation
  constructor(e, n, r) {
    this.ctx = e, this.onBatchComplete = n, this.annotateError = r;
  }
  _undos = hi("HistoryManager.undos", yp());
  // Updated by each action that includes and undo
  _redos = hi("HistoryManager.redos", yp());
  // Updated when a user undoes
  _batchDepth = 0;
  _commands = {};
  get numUndos() {
    return this._undos.value.length;
  }
  get numRedos() {
    return this._redos.value.length;
  }
  createCommand = (e, n, r) => {
    if (this._commands[e])
      throw new Error(`Duplicate command: ${e}`);
    this._commands[e] = r;
    const a = (...s) => {
      if (!this._batchDepth)
        return this.batch(() => a(...s)), this.ctx;
      const c = n(...s);
      if (!c)
        return this.ctx;
      const { data: f, ephemeral: p, squashing: g, preservesRedoStack: y } = c;
      if (this.ignoringUpdates((v, S) => (r.do(f), { undos: v, redos: S })), !p) {
        const v = this._undos.value.head;
        g && v && v.type === "command" && v.name === e && v.preservesRedoStack === y ? this._undos.update(
          (S) => S.tail.push({
            ...v,
            id: $i(),
            data: _x(r.squash(v.data, f))
          })
        ) : this._undos.update(
          (S) => S.push({
            type: "command",
            name: e,
            data: _x(f),
            id: $i(),
            preservesRedoStack: y
          })
        ), c.preservesRedoStack || this._redos.set(yp()), this.ctx.emit("change-history");
      }
      return this.ctx;
    };
    return a;
  };
  batch = (e) => {
    try {
      this._batchDepth++, this._batchDepth === 1 ? Ru(() => {
        const n = this._undos.value.head?.id;
        e(), n !== this._undos.value.head?.id && this.onBatchComplete();
      }) : e();
    } catch (n) {
      throw this.annotateError(n), n;
    } finally {
      this._batchDepth--;
    }
    return this;
  };
  ignoringUpdates = (e) => {
    let n = this._undos.value, r = this._redos.value;
    this._undos.set(yp()), this._redos.set(yp());
    try {
      ({ undos: n, redos: r } = Ru(() => e(n, r)));
    } finally {
      this._undos.set(n), this._redos.set(r);
    }
  };
  // History
  _undo = ({
    pushToRedoStack: e,
    toMark: n = void 0
  }) => (this.ignoringUpdates((r, a) => {
    if (r.length === 0)
      return this.ctx.emit("change-history"), { undos: r, redos: a };
    for (; r.head?.type === "STOP"; ) {
      const s = r.head;
      if (r = r.tail, e && (a = a.push(s)), s.id === n)
        return this.ctx.emit("change-history"), { undos: r, redos: a };
    }
    if (r.length === 0)
      return this.ctx.emit("change-history"), { undos: r, redos: a };
    for (; r.head; ) {
      const s = r.head;
      if (r = r.tail, e && (a = a.push(s)), s.type === "STOP") {
        if (s.onUndo && (!n || s.id === n))
          return this.ctx.emit("change-history"), { undos: r, redos: a };
      } else
        this._commands[s.name].undo(s.data);
    }
    return this.ctx.emit("change-history"), { undos: r, redos: a };
  }), this);
  undo = () => (this._undo({ pushToRedoStack: !0 }), this);
  redo = () => (this.ignoringUpdates((e, n) => {
    if (n.length === 0)
      return this.ctx.emit("change-history"), { undos: e, redos: n };
    for (; n.head?.type === "STOP"; )
      e = e.push(n.head), n = n.tail;
    if (n.length === 0)
      return this.ctx.emit("change-history"), { undos: e, redos: n };
    for (; n.head; ) {
      const r = n.head;
      if (e = e.push(n.head), n = n.tail, r.type === "STOP") {
        if (r.onRedo)
          break;
      } else {
        const a = this._commands[r.name];
        a.redo ? a.redo(r.data) : a.do(r.data);
      }
    }
    return this.ctx.emit("change-history"), { undos: e, redos: n };
  }), this);
  bail = () => (this._undo({ pushToRedoStack: !1 }), this);
  bailToMark = (e) => (this._undo({ pushToRedoStack: !1, toMark: e }), this);
  mark = (e = $i(), n = !0, r = !0) => {
    const a = this._undos.value.head;
    return a && a.type === "STOP" && a.id === e && a.onUndo === n && a.onRedo === r ? a.id : (this._undos.update((s) => s.push({ type: "STOP", id: e, onUndo: n, onRedo: r })), e);
  };
  clear() {
    this._undos.set(yp()), this._redos.set(yp());
  }
}
class Aj {
  // Scribble properties
  state;
  points;
  size;
  color;
  opacity;
  // Callbacks
  onUpdate;
  onComplete;
  // Internal state
  prev = null;
  next = null;
  constructor(e) {
    const { size: n = 20, color: r = "accent", opacity: a = 0.8, onComplete: s, onUpdate: c } = e;
    this.onUpdate = c, this.onComplete = s, this.size = n, this.color = r, this.opacity = a, this.points = [], this.state = "starting", this.prev = null, this.next = null, this.resume();
  }
  resume = () => {
    this.state = "active";
  };
  pause = () => {
    this.state = "starting";
  };
  /**
   * Start stopping the scribble. The scribble won't be removed
   * until its last point is cleared.
   *
   * @public
   */
  stop = () => {
    this.state = "stopping";
  };
  /**
   * Set the scribble's next point.
   *
   * @param point - The point to add.
   * @public
   */
  addPoint = (e, n) => {
    const { prev: r } = this, a = { x: e, y: n, z: 0.5 };
    r && O.Dist(r, a) < 1 || (this.next = a);
  };
  /**
   * Get the current TLScribble object from the scribble manager.
   *
   * @public
   */
  getScribble() {
    return {
      state: this.state,
      size: this.size,
      color: this.color,
      opacity: this.opacity,
      points: [...this.points]
    };
  }
  updateScribble() {
    this.onUpdate(this.getScribble());
  }
  timeoutMs = 0;
  tick = (e) => {
    this.timeoutMs += e, this.timeoutMs >= 16 && (this.timeoutMs = 0);
    const { timeoutMs: n, state: r, prev: a, next: s, points: c } = this;
    switch (r) {
      case "active": {
        s && s !== a ? (this.prev = s, c.push(s), c.length > 8 && c.shift(), this.updateScribble()) : n === 0 && c.length > 1 && (c.shift(), this.updateScribble());
        break;
      }
      case "stopping": {
        if (n === 0) {
          if (c.length === 1) {
            this.state = "paused", this.onComplete();
            return;
          }
          this.size *= 0.9, c.shift(), this.updateScribble();
        }
        break;
      }
    }
  };
}
var cne = Object.defineProperty, une = Object.getOwnPropertyDescriptor, S1 = (t, e, n, r) => {
  for (var a = r > 1 ? void 0 : r ? une(e, n) : e, s = t.length - 1, c; s >= 0; s--)
    (c = t[s]) && (a = (r ? c(e, n, a) : c(a)) || a);
  return r && a && cne(e, n, a), a;
};
const zt = (t) => Math.round(t * 10 ** 8) / 10 ** 8;
function Iu(t, e, n, r, a) {
  const s = t.filter(
    (f) => (r === "forward" ? f.startNode.id === e : f.endNode.id === e) && zt(f.length) === zt(n) && Il(
      f.breadthIntersection[0],
      f.breadthIntersection[1],
      a[0],
      a[1]
    )
  );
  if (s.length === 0)
    return [];
  const c = /* @__PURE__ */ new Set();
  for (const f of s) {
    const p = r === "forward" ? f.endNode.id : f.startNode.id;
    c.has(p) || (c.add(p), s.push(
      ...Iu(
        t,
        p,
        n,
        r,
        Il(
          f.breadthIntersection[0],
          f.breadthIntersection[1],
          a[0],
          a[1]
        )
      )
    ));
  }
  return s;
}
function dne(t) {
  t.sort((e, n) => n.gaps.length - e.gaps.length);
  for (let e = t.length - 1; e > 0; e--) {
    const n = t[e];
    for (let r = e - 1; r >= 0; r--) {
      const a = t[r];
      if (a.direction === n.direction && n.gaps.every(
        (s) => a.gaps.some(
          (c) => zt(s.startEdge[0].x) === zt(c.startEdge[0].x) && zt(s.startEdge[0].y) === zt(c.startEdge[0].y) && zt(s.startEdge[1].x) === zt(c.startEdge[1].x) && zt(s.startEdge[1].y) === zt(c.startEdge[1].y)
        ) && a.gaps.some(
          (c) => zt(s.endEdge[0].x) === zt(c.endEdge[0].x) && zt(s.endEdge[0].y) === zt(c.endEdge[0].y) && zt(s.endEdge[1].x) === zt(c.endEdge[1].x) && zt(s.endEdge[1].y) === zt(c.endEdge[1].y)
        )
      )) {
        t.splice(e, 1);
        break;
      }
    }
  }
}
class Pb {
  constructor(e) {
    this.app = e;
  }
  _snapLines = hi("snapLines", void 0);
  get lines() {
    return this._snapLines.value ?? Ws;
  }
  clear() {
    this.lines.length && this._snapLines.set(void 0);
  }
  setLines(e) {
    this._snapLines.set(e);
  }
  get snapPointsCache() {
    return this.app.store.createComputedCache("snapPoints", (e) => {
      const n = this.app.getPageTransformById(e.id);
      return n ? this.app.getShapeUtil(e).snapPoints(e).map((s, c) => {
        const { x: f, y: p } = De.applyToPoint(n, s);
        return { x: f, y: p, id: `${e.id}:${c}` };
      }) : void 0;
    });
  }
  get snapThreshold() {
    return 8 / this.app.camera.z;
  }
  get visibleShapesNotInSelection() {
    const e = this.app.selectedIds, n = /* @__PURE__ */ new Set(), r = (s) => {
      const c = this.app.getSortedChildIds(s);
      for (const f of c) {
        const p = this.app.getShapeById(f);
        if (p && p.type !== "arrow" && !e.includes(f) && this.app.isShapeInViewport(p.id)) {
          if (p.type === "group") {
            r(f);
            continue;
          }
          n.add({ id: p.id, pageBounds: this.app.getPageBoundsById(p.id) }), p.type !== "frame" && r(f);
        }
      }
    }, a = this.app.findCommonAncestor(
      Gt(e.map((s) => this.app.getShapeById(s))),
      (s) => s.type === "frame"
    );
    return r(a ?? this.app.currentPageId), n;
  }
  get visibleSnapPointsNotInSelection() {
    const e = [];
    for (const n of this.visibleShapesNotInSelection) {
      const r = this.snapPointsCache.get(n.id);
      r && e.push(...r);
    }
    return e;
  }
  get visibleGaps() {
    const e = [], n = [], r = [...this.visibleShapesNotInSelection].sort((s, c) => s.pageBounds.minX - c.pageBounds.minX);
    for (let s = 0; s < r.length; s++) {
      const c = r[s];
      for (let f = s + 1; f < r.length; f++) {
        const p = r[f];
        // is there space between the boxes
        c.pageBounds.maxX < p.pageBounds.minX && // and they overlap in the y axis
        Iy(
          c.pageBounds.minY,
          c.pageBounds.maxY,
          p.pageBounds.minY,
          p.pageBounds.maxY
        ) && e.push({
          startNode: c,
          endNode: p,
          startEdge: [
            new O(c.pageBounds.maxX, c.pageBounds.minY),
            new O(c.pageBounds.maxX, c.pageBounds.maxY)
          ],
          endEdge: [
            new O(p.pageBounds.minX, p.pageBounds.minY),
            new O(p.pageBounds.minX, p.pageBounds.maxY)
          ],
          length: p.pageBounds.minX - c.pageBounds.maxX,
          breadthIntersection: Il(
            c.pageBounds.minY,
            c.pageBounds.maxY,
            p.pageBounds.minY,
            p.pageBounds.maxY
          )
        });
      }
    }
    const a = r.slice(0).sort((s, c) => s.pageBounds.minY - c.pageBounds.minY);
    for (let s = 0; s < a.length; s++) {
      const c = a[s];
      for (let f = s + 1; f < a.length; f++) {
        const p = a[f];
        // is there space between the boxes
        c.pageBounds.maxY < p.pageBounds.minY && // do they overlap in the x axis
        Iy(
          c.pageBounds.minX,
          c.pageBounds.maxX,
          p.pageBounds.minX,
          p.pageBounds.maxX
        ) && n.push({
          startNode: c,
          endNode: p,
          startEdge: [
            new O(c.pageBounds.minX, c.pageBounds.maxY),
            new O(c.pageBounds.maxX, c.pageBounds.maxY)
          ],
          endEdge: [
            new O(p.pageBounds.minX, p.pageBounds.minY),
            new O(p.pageBounds.maxX, p.pageBounds.minY)
          ],
          length: p.pageBounds.minY - c.pageBounds.maxY,
          breadthIntersection: Il(
            c.pageBounds.minX,
            c.pageBounds.maxX,
            p.pageBounds.minX,
            p.pageBounds.maxX
          )
        });
      }
    }
    return { horizontal: e, vertical: n };
  }
  snapTranslate({
    lockedAxis: e,
    initialSelectionPageBounds: n,
    initialSelectionSnapPoints: r,
    dragDelta: a
  }) {
    const s = e === "x", c = e === "y", f = n.clone().translate(a), p = r.map(({ x: I, y: D }, N) => ({
      id: "selection:" + N,
      x: I + a.x,
      y: D + a.y
    })), g = this.visibleSnapPointsNotInSelection, y = [], v = [], S = new O(this.snapThreshold, this.snapThreshold);
    this.findPointSnaps({
      minOffset: S,
      nearestSnapsX: y,
      nearestSnapsY: v,
      otherNodeSnapPoints: g,
      selectionSnapPoints: p
    }), this.findGapSnaps({ selectionPageBounds: f, nearestSnapsX: y, nearestSnapsY: v, minOffset: S });
    const x = new O(
      s ? 0 : y[0]?.nudge ?? 0,
      c ? 0 : v[0]?.nudge ?? 0
    );
    S.x = 0, S.y = 0, y.length = 0, v.length = 0, p.forEach((I) => {
      I.x += x.x, I.y += x.y;
    }), f.translate(x), this.findPointSnaps({
      minOffset: S,
      nearestSnapsX: y,
      nearestSnapsY: v,
      otherNodeSnapPoints: g,
      selectionSnapPoints: p
    }), this.findGapSnaps({
      selectionPageBounds: f,
      nearestSnapsX: y,
      nearestSnapsY: v,
      minOffset: S
    });
    const _ = this.getPointSnapLines({
      nearestSnapsX: y,
      nearestSnapsY: v
    }), T = this.getGapSnapLines({
      selectionPageBounds: f,
      nearestSnapsX: y,
      nearestSnapsY: v
    });
    return this._snapLines.set([...T, ..._]), { nudge: x };
  }
  // for a handle of a line:
  // - find the nearest snap point
  // - return the nudge vector to snap to that point
  // note: this happens within page space
  snapLineHandleTranslate({
    lineId: e,
    handleId: n,
    handlePoint: r
  }) {
    const a = this.app.getShapeById(e);
    if (!a)
      return { nudge: new O(0, 0) };
    const c = this.app.getShapeUtilByDef(Rj).handles(a).sort(Ya);
    if (c.length < 3)
      return { nudge: new O(0, 0) };
    const f = c.findIndex((T) => T.id === n), g = c[f].type === "vertex" ? f / 2 : (f + 1) / 2, y = xp(a), v = 1, S = this.app.getPageTransform(a), x = y.segments.slice(0, Math.max(0, g - v)).map((T) => De.applyToPoints(S, T.lut)), _ = y.segments.slice(g + v).map((T) => De.applyToPoints(S, T.lut));
    return this.snapHandleTranslate({
      handlePoint: r,
      additionalOutlines: [...x, ..._]
    });
  }
  // for a handle:
  // - find the nearest snap point from all non-selected shapes
  // - return the nudge vector to snap to that point
  // note: this happens within page space
  snapHandleTranslate({
    handlePoint: e,
    additionalOutlines: n = []
  }) {
    const r = this.visibleShapesNotInSelection, a = [];
    for (const f of r) {
      const p = this.app.getShapeById(f.id);
      if (p.type === "text" || p.type === "icon")
        continue;
      const g = Tc(this.app.getOutlineById(f.id));
      this.app.getShapeUtil(p).isClosed?.(p) && g.push(g[0]), a.push(De.applyToPoints(this.app.getPageTransformById(p.id), g));
    }
    let s = this.snapThreshold, c = null;
    for (const f of [...a, ...n])
      for (let p = 0; p < f.length - 1; p++) {
        const g = f[p], y = f[p + 1], v = O.DistanceToLineSegment(g, y, e);
        isNaN(v) || v < s && (s = v, c = O.NearestPointOnLineSegment(g, y, e));
      }
    if (c) {
      const f = [];
      return f.push({
        id: $i(),
        type: "points",
        points: [c]
      }), this._snapLines.set(f), {
        nudge: O.Sub(c, e)
      };
    }
    return { nudge: new O(0, 0) };
  }
  snapResize({
    initialSelectionPageBounds: e,
    dragDelta: n,
    handle: r,
    isAspectRatioLocked: a,
    isResizingFromCenter: s
  }) {
    const {
      box: c,
      scaleX: f,
      scaleY: p
    } = ot.Resize(
      e,
      r,
      s ? n.x * 2 : n.x,
      s ? n.y * 2 : n.y,
      a
    );
    let g = r;
    f < 0 && (g = Wq(g)), p < 0 && (g = Kq(g)), s && (c.center = e.center);
    const y = g === "top" || g === "bottom", v = g === "left" || g === "right", S = UD(g, c), x = this.visibleSnapPointsNotInSelection, _ = [], T = [], I = new O(this.snapThreshold, this.snapThreshold);
    this.findPointSnaps({
      minOffset: I,
      nearestSnapsX: _,
      nearestSnapsY: T,
      otherNodeSnapPoints: x,
      selectionSnapPoints: S
    });
    const D = new O(
      y ? 0 : _[0]?.nudge ?? 0,
      v ? 0 : T[0]?.nudge ?? 0
    );
    if (a && Gq(g) && D.len() !== 0) {
      const F = _.length && T.length ? Math.abs(D.x) < Math.abs(D.y) ? "x" : "y" : _.length ? "x" : "y", K = e.aspectRatio;
      F === "x" ? (T.length = 0, D.y = D.x / K, (g === "bottom_left" || g === "top_right") && (D.y = -D.y)) : (_.length = 0, D.x = D.y * K, (g === "bottom_left" || g === "top_right") && (D.x = -D.x));
    }
    const N = O.Add(n, D), { box: j } = ot.Resize(
      e,
      r,
      s ? N.x * 2 : N.x,
      s ? N.y * 2 : N.y,
      a
    );
    s && (j.center = e.center);
    const L = UD("any", j);
    _.length = 0, T.length = 0, I.x = 0, I.y = 0, this.findPointSnaps({
      minOffset: I,
      nearestSnapsX: _,
      nearestSnapsY: T,
      otherNodeSnapPoints: x,
      selectionSnapPoints: L
    });
    const z = this.getPointSnapLines({
      nearestSnapsX: _,
      nearestSnapsY: T
    });
    return this._snapLines.set([...z]), { nudge: D };
  }
  findPointSnaps({
    selectionSnapPoints: e,
    otherNodeSnapPoints: n,
    minOffset: r,
    nearestSnapsX: a,
    nearestSnapsY: s
  }) {
    for (const c of e)
      for (const f of n) {
        const p = O.Sub(c, f), g = Math.abs(p.x), y = Math.abs(p.y);
        zt(g) <= zt(r.x) && (zt(g) < zt(r.x) && (a.length = 0), a.push({
          type: "points",
          points: { thisPoint: c, otherPoint: f },
          nudge: f.x - c.x
        }), r.x = g), zt(y) <= zt(r.y) && (zt(y) < zt(r.y) && (s.length = 0), s.push({
          type: "points",
          points: { thisPoint: c, otherPoint: f },
          nudge: f.y - c.y
        }), r.y = y);
      }
  }
  findGapSnaps({
    selectionPageBounds: e,
    minOffset: n,
    nearestSnapsX: r,
    nearestSnapsY: a
  }) {
    for (const s of this.visibleGaps.horizontal) {
      if (!Iy(
        s.breadthIntersection[0],
        s.breadthIntersection[1],
        e.minY,
        e.maxY
      ))
        continue;
      const f = s.startEdge[0].x + s.length / 2 - e.center.x;
      if (s.length > e.width && zt(Math.abs(f)) <= zt(n.x)) {
        zt(Math.abs(f)) < zt(n.x) && (r.length = 0), n.x = Math.abs(f);
        const T = {
          type: "gap_center",
          gap: s,
          nudge: f
        }, I = r.find(({ type: N }) => N === "gap_center"), D = I && Il(
          s.breadthIntersection[0],
          s.breadthIntersection[1],
          I.gap.breadthIntersection[0],
          I.gap.breadthIntersection[1]
        );
        I && I.gap.length > s.length && D ? r[r.indexOf(I)] = T : (!I || !D) && r.push(T);
      }
      const g = s.startNode.pageBounds.minX - s.length, y = e.maxX, v = g - y;
      zt(Math.abs(v)) <= zt(n.x) && (zt(Math.abs(v)) < zt(n.x) && (r.length = 0), n.x = Math.abs(v), r.push({
        type: "gap_duplicate",
        gap: s,
        protrusionDirection: "left",
        nudge: v
      }));
      const S = s.endNode.pageBounds.maxX + s.length, x = e.minX, _ = S - x;
      zt(Math.abs(_)) <= zt(n.x) && (zt(Math.abs(_)) < zt(n.x) && (r.length = 0), n.x = Math.abs(_), r.push({
        type: "gap_duplicate",
        gap: s,
        protrusionDirection: "right",
        nudge: _
      }));
    }
    for (const s of this.visibleGaps.vertical) {
      if (!Iy(
        s.breadthIntersection[0],
        s.breadthIntersection[1],
        e.minX,
        e.maxX
      ))
        continue;
      const f = s.startEdge[0].y + s.length / 2 - e.center.y;
      if (s.length > e.height && zt(Math.abs(f)) <= zt(n.y)) {
        zt(Math.abs(f)) < zt(n.y) && (a.length = 0), n.y = Math.abs(f);
        const T = {
          type: "gap_center",
          gap: s,
          nudge: f
        }, I = a.find(({ type: N }) => N === "gap_center"), D = I && Iy(
          I.gap.breadthIntersection[0],
          I.gap.breadthIntersection[1],
          s.breadthIntersection[0],
          s.breadthIntersection[1]
        );
        I && I.gap.length > s.length && D ? a[a.indexOf(I)] = T : (!I || !D) && a.push(T);
        continue;
      }
      const g = s.startNode.pageBounds.minY - s.length, y = e.maxY, v = g - y;
      zt(Math.abs(v)) <= zt(n.y) && (zt(Math.abs(v)) < zt(n.y) && (a.length = 0), n.y = Math.abs(v), a.push({
        type: "gap_duplicate",
        gap: s,
        protrusionDirection: "top",
        nudge: v
      }));
      const S = s.endNode.pageBounds.maxY + s.length, x = e.minY, _ = S - x;
      zt(Math.abs(_)) <= zt(n.y) && (zt(Math.abs(_)) < zt(n.y) && (a.length = 0), n.y = Math.abs(_), a.push({
        type: "gap_duplicate",
        gap: s,
        protrusionDirection: "bottom",
        nudge: _
      }));
    }
  }
  getPointSnapLines({
    nearestSnapsX: e,
    nearestSnapsY: n
  }) {
    const r = {}, a = {}, s = [];
    if (e.length > 0) {
      for (const c of e)
        if (c.type === "points") {
          const f = zt(c.points.otherPoint.x);
          r[f] || (r[f] = []), r[f].push(c.points);
        }
    }
    if (n.length > 0) {
      for (const c of n)
        if (c.type === "points") {
          const f = zt(c.points.otherPoint.y);
          a[f] || (a[f] = []), a[f].push(c.points);
        }
    }
    for (const [c, f] of Object.entries(r).concat(Object.entries(a)))
      s.push({
        id: $i(),
        type: "points",
        points: xx(
          f.map((p) => O.From(p.otherPoint)).concat(f.map((p) => O.From(p.thisPoint))),
          (p, g) => p.equals(g)
        )
      });
    return s;
  }
  getGapSnapLines({
    selectionPageBounds: e,
    nearestSnapsX: n,
    nearestSnapsY: r
  }) {
    const a = {
      top: e.sides[0],
      right: e.sides[1],
      // need bottom and left to be sorted asc, which .sides is not.
      bottom: [e.corners[3], e.corners[2]],
      left: [e.corners[0], e.corners[3]]
    }, s = [];
    if (n.length > 0)
      for (const c of n) {
        if (c.type === "gap_center") {
          const f = (c.gap.length - e.width) / 2, p = Il(
            c.gap.breadthIntersection[0],
            c.gap.breadthIntersection[1],
            e.minY,
            e.maxY
          );
          s.push({
            type: "gaps",
            direction: "horizontal",
            id: $i(),
            gaps: [
              ...Iu(
                this.visibleGaps.horizontal,
                c.gap.startNode.id,
                f,
                "backward",
                p
              ),
              {
                startEdge: c.gap.startEdge,
                endEdge: a.left
              },
              {
                startEdge: a.right,
                endEdge: c.gap.endEdge
              },
              ...Iu(
                this.visibleGaps.horizontal,
                c.gap.endNode.id,
                f,
                "forward",
                p
              )
            ]
          });
        }
        if (c.type === "gap_duplicate") {
          const f = Il(
            c.gap.breadthIntersection[0],
            c.gap.breadthIntersection[1],
            e.minY,
            e.maxY
          );
          s.push({
            type: "gaps",
            direction: "horizontal",
            id: $i(),
            gaps: c.protrusionDirection === "left" ? [
              {
                startEdge: a.right,
                endEdge: [
                  O.Add(c.gap.startEdge[0], {
                    x: -c.gap.startNode.pageBounds.width,
                    y: 0
                  }),
                  O.Add(c.gap.startEdge[1], {
                    x: -c.gap.startNode.pageBounds.width,
                    y: 0
                  })
                ]
              },
              {
                startEdge: c.gap.startEdge,
                endEdge: c.gap.endEdge
              },
              ...Iu(
                this.visibleGaps.horizontal,
                c.gap.endNode.id,
                c.gap.length,
                "forward",
                f
              )
            ] : [
              ...Iu(
                this.visibleGaps.horizontal,
                c.gap.startNode.id,
                c.gap.length,
                "backward",
                f
              ),
              {
                startEdge: c.gap.startEdge,
                endEdge: c.gap.endEdge
              },
              {
                startEdge: [
                  O.Add(c.gap.endEdge[0], {
                    x: c.gap.endNode.pageBounds.width,
                    y: 0
                  }),
                  O.Add(c.gap.endEdge[1], {
                    x: c.gap.endNode.pageBounds.width,
                    y: 0
                  })
                ],
                endEdge: a.left
              }
            ]
          });
        }
      }
    if (r.length > 0)
      for (const c of r) {
        if (c.type === "gap_center") {
          const f = (c.gap.length - e.height) / 2, p = Il(
            c.gap.breadthIntersection[0],
            c.gap.breadthIntersection[1],
            e.minX,
            e.maxX
          );
          s.push({
            type: "gaps",
            direction: "vertical",
            id: $i(),
            gaps: [
              ...Iu(
                this.visibleGaps.vertical,
                c.gap.startNode.id,
                f,
                "backward",
                p
              ),
              {
                startEdge: c.gap.startEdge,
                endEdge: a.top
              },
              {
                startEdge: a.bottom,
                endEdge: c.gap.endEdge
              },
              ...Iu(
                this.visibleGaps.vertical,
                c.gap.endNode.id,
                f,
                "forward",
                p
              )
            ]
          });
        }
        if (c.type === "gap_duplicate") {
          const f = Il(
            c.gap.breadthIntersection[0],
            c.gap.breadthIntersection[1],
            e.minX,
            e.maxX
          );
          s.push({
            type: "gaps",
            direction: "vertical",
            id: $i(),
            gaps: c.protrusionDirection === "top" ? [
              {
                startEdge: a.bottom,
                endEdge: [
                  O.Add(c.gap.startEdge[0], {
                    x: 0,
                    y: -c.gap.startNode.pageBounds.height
                  }),
                  O.Add(c.gap.startEdge[1], {
                    x: 0,
                    y: -c.gap.startNode.pageBounds.height
                  })
                ]
              },
              {
                startEdge: c.gap.startEdge,
                endEdge: c.gap.endEdge
              },
              ...Iu(
                this.visibleGaps.vertical,
                c.gap.endNode.id,
                c.gap.length,
                "forward",
                f
              )
            ] : [
              ...Iu(
                this.visibleGaps.vertical,
                c.gap.startNode.id,
                c.gap.length,
                "backward",
                f
              ),
              {
                startEdge: c.gap.startEdge,
                endEdge: c.gap.endEdge
              },
              {
                startEdge: [
                  O.Add(c.gap.endEdge[0], {
                    x: 0,
                    y: c.gap.endNode.pageBounds.height
                  }),
                  O.Add(c.gap.endEdge[1], {
                    x: 0,
                    y: c.gap.endNode.pageBounds.height
                  })
                ],
                endEdge: a.top
              }
            ]
          });
        }
      }
    return dne(s), s;
  }
}
S1([
  pt
], Pb.prototype, "snapPointsCache", 1);
S1([
  pt
], Pb.prototype, "visibleShapesNotInSelection", 1);
S1([
  pt
], Pb.prototype, "visibleSnapPointsNotInSelection", 1);
S1([
  pt
], Pb.prototype, "visibleGaps", 1);
function UD(t, e) {
  const { minX: n, maxX: r, minY: a, maxY: s } = e, c = [];
  switch (t) {
    case "top":
    case "left":
    case "top_left":
    case "any":
      c.push({
        id: "top_left",
        handle: "top_left",
        x: n,
        y: a
      });
  }
  switch (t) {
    case "top":
    case "right":
    case "top_right":
    case "any":
      c.push({
        id: "top_right",
        handle: "top_right",
        x: r,
        y: a
      });
  }
  switch (t) {
    case "bottom":
    case "right":
    case "bottom_right":
    case "any":
      c.push({
        id: "bottom_right",
        handle: "bottom_right",
        x: r,
        y: s
      });
  }
  switch (t) {
    case "bottom":
    case "left":
    case "bottom_left":
    case "any":
      c.push({
        id: "bottom_left",
        handle: "bottom_left",
        x: n,
        y: s
      });
  }
  return c;
}
const BD = new RegExp(
  `${[32, 160, 4961, 65792, 65793, 4153, 4241].map((t) => String.fromCodePoint(t)).join("|")}`
), fne = {
  start: "left",
  middle: "center",
  end: "right",
  justify: "justify"
};
class pne {
  constructor(e) {
    this.app = e;
  }
  getTextElement() {
    const e = document.createElement("div");
    return this.app.getContainer().appendChild(e), e.id = `__textMeasure_${$i()}`, e.classList.add("rs-text"), e.classList.add("rs-text-measure"), e.tabIndex = -1, e;
  }
  measureText = (e) => {
    const n = this.getTextElement();
    n.setAttribute("dir", "ltr"), n.style.setProperty("font-family", e.fontFamily), n.style.setProperty("font-style", e.fontStyle), n.style.setProperty("font-weight", e.fontWeight), n.style.setProperty("font-size", e.fontSize + "px"), n.style.setProperty("line-height", e.lineHeight * e.fontSize + "px"), n.style.setProperty("width", e.width), n.style.setProperty("min-width", e.minWidth ?? null), n.style.setProperty("max-width", e.maxWidth), n.style.setProperty("padding", e.padding), n.textContent = Zr.normalizeTextForDom(e.text);
    const r = n.getBoundingClientRect();
    return n.remove(), {
      x: 0,
      y: 0,
      w: r.width,
      h: r.height
    };
  };
  getTextLines(e) {
    const n = this.getTextElement();
    n.style.setProperty("width", e.width - e.padding * 2 + "px"), n.style.setProperty("height", "min-content"), n.style.setProperty("dir", "ltr"), n.style.setProperty("font-size", e.fontSize + "px"), n.style.setProperty("font-family", e.fontFamily), n.style.setProperty("font-weight", e.fontWeight), n.style.setProperty("line-height", e.lineHeight * e.fontSize + "px"), n.style.setProperty("text-align", fne[e.textAlign]);
    const r = [];
    e.text.split(BD).flatMap(
      (v) => v.split(`
`).map((S) => S.trim()).join(`
`)
    );
    for (const v of e.text.split(BD))
      if (v.includes(`
`)) {
        const S = v.split(`
`);
        for (let x = 0; x < S.length; x++)
          S[x] = S[x].trim(), S[x] && r.push(S[x]), x < S.length - 1 && r.push(`
`);
      } else
        r.push(v);
    const a = [];
    for (let v = 0; v < r.length; v++) {
      const S = r[v];
      a.push(S), S === `
` && r[v + 1] === "" && v++;
    }
    let s = a.length - 1;
    for (; a[s] === "" && (a.pop(), s !== 0); )
      s--;
    let c = [];
    const f = [];
    n.textContent = "";
    let p = n.offsetHeight, g = n.textContent;
    for (let v = 0; v < a.length; v++) {
      const S = a[v], x = S === `
` ? S : `${S} `;
      if (n.textContent += x, n.offsetHeight <= p)
        c.push(c.length ? " " + S.trim() : S.trim());
      else if (!e.wrap || S === `
`)
        c = [], f.push(c);
      else {
        const T = n.textContent;
        n.textContent = g, n.textContent += `
`;
        const I = [...S];
        n.textContent += I[0], p = n.offsetHeight;
        let D = [I[0]];
        const N = [D];
        for (let L = 1; L < I.length; L++) {
          const z = I[L];
          n.textContent += z;
          const F = n.offsetHeight;
          F > p ? (D = [z], N.push(D), p = F) : D.push(z);
        }
        const j = N.map((L) => [L.join("")]);
        f.push(...j), c = f[f.length - 1], n.textContent = T, p = n.offsetHeight;
      }
      g = n.textContent;
    }
    const y = f.map((v) => v.join("").trim());
    return n.remove(), y;
  }
}
class hne {
  constructor(e) {
    this.app = e, this.app.disposables.add(this.dispose), this.start();
  }
  raf;
  isPaused = !0;
  last = 0;
  t = 0;
  start = () => {
    this.isPaused = !1, cancelAnimationFrame(this.raf), this.raf = requestAnimationFrame(this.tick), this.last = Date.now();
  };
  tick = () => {
    if (this.isPaused)
      return;
    const e = Date.now(), n = e - this.last;
    if (this.last = e, this.t += n, this.t < 16) {
      this.raf = requestAnimationFrame(this.tick);
      return;
    }
    this.t -= 16, this.updatePointerVelocity(n), this.app.emit("tick", n), this.raf = requestAnimationFrame(this.tick);
  };
  // Clear the listener
  dispose = () => {
    this.isPaused = !0, cancelAnimationFrame(this.raf);
  };
  prevPoint = new O();
  updatePointerVelocity = (e) => {
    const {
      prevPoint: n,
      app: {
        inputs: { currentScreenPoint: r, pointerVelocity: a }
      }
    } = this;
    if (e === 0)
      return;
    const s = O.Sub(r, n);
    this.prevPoint = r.clone();
    const c = s.len(), f = c ? s.div(c) : new O(0, 0), p = a.clone().lrp(f.mul(c / e), 0.5);
    Math.abs(p.x) < 0.01 && (p.x = 0), Math.abs(p.y) < 0.01 && (p.y = 0), a.equals(p) || (this.app.inputs.pointerVelocity = p);
  };
}
const gne = {
  wheel: "onWheel",
  pointer_enter: "onPointerEnter",
  pointer_leave: "onPointerLeave",
  pointer_down: "onPointerDown",
  pointer_move: "onPointerMove",
  pointer_up: "onPointerUp",
  right_click: "onRightClick",
  middle_click: "onMiddleClick",
  blur: "onBlur",
  key_down: "onKeyDown",
  key_up: "onKeyUp",
  cancel: "onCancel",
  complete: "onComplete",
  interrupt: "onInterrupt",
  double_click: "onDoubleClick",
  triple_click: "onTripleClick",
  quadruple_click: "onQuadrupleClick"
};
class sn {
  constructor(e, n) {
    this.app = e;
    const { id: r, children: a, initial: s } = this.constructor;
    this.id = r, this.current = hi("toolState" + this.id, void 0), this.path = pt("toolPath" + this.id, () => {
      const c = this.current.value;
      return this.id + (c ? `.${c.path.value}` : "");
    }), this.parent = n ?? {}, this.parent ? a && s ? (this.type = "branch", this.initial = s, this.children = Object.fromEntries(
      a().map((c) => [c.id, new c(this.app, this)])
    ), this.current.set(this.children[this.initial])) : this.type = "leaf" : (this.type = "root", a && s && (this.initial = s, this.children = Object.fromEntries(
      a().map((c) => [c.id, new c(this.app, this)])
    ), this.current.set(this.children[this.initial])));
  }
  path;
  static id;
  static initial;
  static children;
  id;
  current;
  type;
  styles = [];
  initial;
  children;
  parent;
  isActive = !1;
  transition(e, n) {
    const r = e.split(".");
    let a = this;
    for (let s = 0; s < r.length; s++) {
      const c = r[s], f = a.current.value, p = a.children?.[c];
      if (!p)
        throw Error(`${a.id} - no child state exists with the id ${c}.`);
      if (f?.id !== p.id && (f?.exit(n, c), a.current.set(p), p.enter(n, f?.id || "initial"), !p.isActive))
        break;
      a = p;
    }
    return this;
  }
  handleEvent(e) {
    const n = gne[e.name], r = this.current.value;
    this[n]?.(e), this.current.value === r && this.isActive && r?.handleEvent(e);
  }
  enter(e, n) {
    if (this.isActive = !0, this.onEnter?.(e, n), this.children && this.initial && this.isActive) {
      const r = this.children[this.initial];
      this.current.set(r), r.enter(e, n);
    }
  }
  exit(e, n) {
    this.isActive = !1, this.onExit?.(e, n), this.isActive || this.current.value?.exit(e, n);
  }
  onWheel;
  onPointerEnter;
  onPointerLeave;
  onPointerDown;
  onPointerMove;
  onPointerUp;
  onDoubleClick;
  onTripleClick;
  onQuadrupleClick;
  onRightClick;
  onMiddleClick;
  onKeyDown;
  onKeyUp;
  onCancel;
  onComplete;
  onInterrupt;
  onBlur;
  onEnter;
  onExit;
}
let mne = class extends sn {
  static id = "idle";
  onPointerDown = (e) => {
    this.parent.transition("pointing", e);
  };
  onEnter = () => {
    this.app.setCursor({ type: "cross" });
  };
  onCancel = () => {
    this.app.setSelectedTool("select");
  };
}, vne = class extends sn {
  static id = "pointing";
  shapeType = "";
  shape;
  preciseTimeout = -1;
  didTimeout = !1;
  startPreciseTimeout() {
    this.preciseTimeout = window.setTimeout(() => {
      this.isActive && this.shape && (this.didTimeout = !0);
    }, 300);
  }
  clearPreciseTimeout() {
    clearTimeout(this.preciseTimeout);
  }
  onEnter = () => {
    const {
      inputs: { currentPagePoint: e }
    } = this.app;
    this.didTimeout = !1, this.shapeType = this.parent.shapeType, this.app.mark("creating");
    const n = io();
    this.app.createShapes([
      {
        id: n,
        type: this.shapeType,
        x: e.x,
        y: e.y
      }
    ]);
    const r = this.app.getShapeUtilByDef(ro), a = this.app.getShapeById(n);
    if (!a)
      return;
    const s = r.handles?.(a);
    if (s) {
      const c = this.app.getPointInShapeSpace(a, e), f = r.onHandleChange?.(a, {
        handle: { ...s[0], x: c.x, y: c.y },
        isPrecise: !0
      });
      if (f) {
        const p = f.props?.start;
        p?.type === "binding" && this.app.setHintingIds([p.boundShapeId]), this.app.updateShapes([f], !0);
      }
    }
    this.app.select(n), this.shape = this.app.getShapeById(n), this.startPreciseTimeout();
  };
  onExit = () => {
    this.clearPreciseTimeout();
  };
  onPointerMove = () => {
    if (this.shape && this.app.inputs.isDragging) {
      const n = this.app.getShapeUtil(this.shape).handles?.(this.shape);
      if (!n)
        throw this.app.bailToMark("creating"), Error("No handles found");
      if (!this.didTimeout) {
        const r = this.app.getShapeUtilByDef(ro), a = this.app.getShapeById(this.shape.id);
        if (!a)
          return;
        const s = r.handles(a);
        if (s) {
          const { x: c, y: f } = this.app.getPointInShapeSpace(a, this.app.inputs.originPagePoint), p = r.onHandleChange?.(a, {
            handle: {
              ...s[0],
              x: c,
              y: f
            },
            isPrecise: !1
          });
          p && this.app.updateShapes([p], !0);
        }
      }
      this.app.setSelectedTool("select.dragging_handle", {
        shape: this.shape,
        handle: n.find((r) => r.id === "end"),
        isCreating: !0,
        onInteractionEnd: "arrow"
      });
    }
  };
  onPointerUp = () => {
    this.cancel();
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.cancel();
  };
  onInterrupt = () => {
    this.cancel();
  };
  cancel() {
    this.app.bailToMark("creating"), this.app.setHintingIds([]), this.parent.transition("idle", {});
  }
};
class yne extends sn {
  static id = "arrow";
  static initial = "idle";
  static children = () => [mne, vne];
  shapeType = "arrow";
  styles = [
    "color",
    "opacity",
    "dash",
    "size",
    "arrowheadStart",
    "arrowheadEnd",
    "font",
    "fill"
  ];
}
class bne extends sn {
  static id = "drawing";
  info = {};
  initialShape;
  util = this.app.getShapeUtilByDef(vj);
  isPen = !1;
  segmentMode = "free";
  didJustShiftClickToExtendPreviousShapeLine = !1;
  pagePointWhereCurrentSegmentChanged = {};
  pagePointWhereNextSegmentChanged = null;
  lastRecordedPoint = {};
  mergeNextPoint = !1;
  canDraw = !1;
  onEnter = (e) => {
    this.info = e, this.canDraw = !this.app.isMenuOpen, this.lastRecordedPoint = this.app.inputs.currentPagePoint.clone(), this.canDraw && this.startShape();
  };
  onPointerMove = () => {
    const {
      app: { inputs: e }
    } = this;
    this.isPen !== e.isPen && this.cancel(), !this.canDraw && e.isDragging && (this.startShape(), this.canDraw = !0), this.canDraw && (e.isPen ? O.Dist(e.currentPagePoint, this.lastRecordedPoint) >= 1 / this.app.camera.z ? (this.lastRecordedPoint = e.currentPagePoint.clone(), this.mergeNextPoint = !1) : this.mergeNextPoint = !0 : this.mergeNextPoint = !1, this.updateShapes());
  };
  onKeyDown = (e) => {
    if (e.key === "Shift")
      switch (this.segmentMode) {
        case "free": {
          this.segmentMode = "starting_straight", this.pagePointWhereNextSegmentChanged = this.app.inputs.currentPagePoint.clone();
          break;
        }
        case "starting_free":
          this.segmentMode = "starting_straight";
      }
    this.updateShapes();
  };
  onKeyUp = (e) => {
    if (e.key === "Shift")
      switch (this.app.snaps.clear(), this.segmentMode) {
        case "straight": {
          this.segmentMode = "starting_free", this.pagePointWhereNextSegmentChanged = this.app.inputs.currentPagePoint.clone();
          break;
        }
        case "starting_straight": {
          this.pagePointWhereNextSegmentChanged = null, this.segmentMode = "free";
          break;
        }
      }
    this.updateShapes();
  };
  onExit = () => {
    this.app.snaps.clear(), this.pagePointWhereCurrentSegmentChanged = this.app.inputs.currentPagePoint.clone();
  };
  getIsClosed(e, n) {
    const r = e[0].points[0], a = e[e.length - 1], s = a.points[a.points.length - 1];
    return (
      /*points.length > 3 &&*/
      O.Dist(r, s) < this.app.getStrokeWidth(n) * 2
    );
  }
  startShape() {
    const {
      inputs: { originPagePoint: e, isPen: n }
    } = this.app;
    this.app.mark("draw create start"), this.isPen = n;
    const r = this.isPen ? this.info.point.z * 1.25 : 0.5;
    if (this.segmentMode = this.app.inputs.shiftKey ? "straight" : "free", this.didJustShiftClickToExtendPreviousShapeLine = !1, this.lastRecordedPoint = e.clone(), this.initialShape) {
      const s = this.app.getShapeById(this.initialShape.id);
      if (s && this.segmentMode === "straight") {
        this.didJustShiftClickToExtendPreviousShapeLine = !0;
        const c = Hs(s.props.segments);
        if (!c)
          throw Error("Expected a previous segment!");
        const f = Hs(c.points);
        if (!f)
          throw Error("Expected a previous point!");
        const { x: p, y: g } = this.app.getPointInShapeSpace(s, e).toFixed(), y = this.isPen ? this.info.point.z * 1.25 : 0.5, v = {
          type: this.segmentMode,
          points: [
            {
              x: f.x,
              y: f.y,
              z: +y.toFixed(2)
            },
            {
              x: p,
              y: g,
              z: +y.toFixed(2)
            }
          ]
        }, S = De.applyToPoint(
          this.app.getPageTransformById(s.id),
          f
        );
        this.pagePointWhereCurrentSegmentChanged = S, this.pagePointWhereNextSegmentChanged = null;
        const x = [...s.props.segments, v];
        this.app.updateShapes([
          {
            id: s.id,
            type: "draw",
            props: {
              segments: x,
              isClosed: this.getIsClosed(x, s.props.size)
            }
          }
        ]);
        return;
      }
    }
    this.pagePointWhereCurrentSegmentChanged = e.clone();
    const a = io();
    this.app.createShapes([
      {
        id: a,
        type: "draw",
        x: e.x,
        y: e.y,
        props: {
          isPen: this.isPen,
          segments: [
            {
              type: this.segmentMode,
              points: [
                {
                  x: 0,
                  y: 0,
                  z: +r.toFixed(2)
                }
              ]
            }
          ]
        }
      }
    ]), this.initialShape = this.app.getShapeById(a);
  }
  updateShapes() {
    const { inputs: e } = this.app, { initialShape: n } = this;
    if (!n)
      return;
    const {
      id: r,
      props: { size: a }
    } = n, s = this.app.getShapeById(r);
    if (!s)
      return;
    const { segments: c } = s.props, { x: f, y: p, z: g } = this.app.getPointInShapeSpace(s, e.currentPagePoint).toFixed(), y = { x: f, y: p, z: this.isPen ? +(g * 1.25).toFixed(2) : 0.5 };
    switch (this.segmentMode) {
      case "starting_straight": {
        const { pagePointWhereNextSegmentChanged: v } = this;
        if (v === null)
          throw Error("We should have a point where the segment changed");
        if (O.Dist(v, e.currentPagePoint) > eb) {
          this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone(), this.pagePointWhereNextSegmentChanged = null, this.segmentMode = "straight";
          const x = Hs(c);
          if (!x)
            throw Error("Expected a previous segment!");
          const _ = Hs(x.points);
          if (!_)
            throw Error("Expected a previous last point!");
          let T;
          if (x.type === "straight") {
            T = {
              type: "straight",
              points: [
                { ..._ },
                this.app.getPointInShapeSpace(s, this.pagePointWhereCurrentSegmentChanged).toFixed().toJson()
              ]
            };
            const I = this.app.getPageTransform(s);
            this.pagePointWhereCurrentSegmentChanged = De.applyToPoint(
              I,
              _
            );
          } else
            T = {
              type: "straight",
              points: [
                this.app.getPointInShapeSpace(s, this.pagePointWhereCurrentSegmentChanged).toFixed().toJson(),
                y
              ]
            };
          this.app.updateShapes(
            [
              {
                id: r,
                type: "draw",
                props: {
                  segments: [...c, T],
                  isClosed: this.getIsClosed(c, a)
                }
              }
            ],
            !0
          );
        }
        break;
      }
      case "starting_free": {
        const { pagePointWhereNextSegmentChanged: v } = this;
        if (v === null)
          throw Error("We should have a point where the segment changed");
        if (O.Dist(v, e.currentPagePoint) > eb) {
          this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone(), this.pagePointWhereNextSegmentChanged = null, this.segmentMode = "free";
          const x = c.slice(), _ = x[x.length - 1], T = Hs(_.points);
          if (!T)
            throw Error("No previous point!");
          const I = {
            type: "free",
            points: [
              ...O.PointsBetween(T, y, 6).map((D) => D.toFixed().toJson())
            ]
          };
          this.app.updateShapes(
            [
              {
                id: r,
                type: "draw",
                props: {
                  segments: [...x, I],
                  isClosed: this.getIsClosed(c, a)
                }
              }
            ],
            !0
          );
        }
        break;
      }
      case "straight": {
        const v = c.slice(), S = v[v.length - 1], { pagePointWhereCurrentSegmentChanged: x } = this, { currentPagePoint: _, ctrlKey: T } = this.app.inputs;
        if (!x)
          throw Error("We should have a point where the segment changed");
        let I, D = !1;
        this.didJustShiftClickToExtendPreviousShapeLine ? this.app.inputs.isDragging && (D = !T, this.didJustShiftClickToExtendPreviousShapeLine = !1) : D = !T;
        let N = this.app.getPointInShapeSpace(s, _).toFixed().toJson(), j = !1, L;
        if ((this.app.userDocumentSettings.isSnapMode ? !T : T) && v.length > 2) {
          let F, K = 8 / this.app.camera.z;
          for (let X = 0, se = c.length - 2; X < se; X++) {
            const ue = c[X];
            if (!ue)
              break;
            if (ue.type === "free")
              continue;
            const pe = ue.points[0], Pe = Hs(ue.points);
            if (!(pe && Pe))
              continue;
            const ve = O.NearestPointOnLineSegment(
              pe,
              Pe,
              N
            ), Y = O.Dist(ve, N);
            if (Y < K) {
              F = ve.toFixed().toJson(), K = Y, L = ue;
              break;
            }
          }
          F && (j = !0, N = F);
        }
        if (j && L) {
          const F = this.app.getPageTransform(s), K = L.points[0], X = Hs(L.points);
          if (!X)
            throw Error("Expected a last point!");
          const se = De.applyToPoint(F, K), ue = De.applyToPoint(F, X), pe = De.applyToPoint(F, N);
          this.app.snaps.setLines([
            {
              id: $i(),
              type: "points",
              points: [se, pe, ue]
            }
          ]);
        } else {
          if (this.app.snaps.clear(), D) {
            const F = O.Angle(x, _), X = Rx(F, 24) - F;
            I = O.RotWith(
              _,
              x,
              X
            );
          } else
            I = _;
          N = this.app.getPointInShapeSpace(s, I).toFixed().toJson();
        }
        v[v.length - 1] = {
          ...S,
          type: "straight",
          points: [S.points[0], N]
        }, this.app.updateShapes(
          [
            {
              id: r,
              type: "draw",
              props: {
                segments: v,
                isClosed: this.getIsClosed(c, a)
              }
            }
          ],
          !0
        );
        break;
      }
      case "free": {
        const v = c.slice(), S = v[v.length - 1], x = [...S.points];
        if (x.length && this.mergeNextPoint) {
          const { z: _ } = x[x.length - 1];
          x[x.length - 1] = {
            x: y.x,
            y: y.y,
            z: _ ? Math.max(_, y.z) : y.z
          };
        } else
          x.push(y);
        if (v[v.length - 1] = {
          ...S,
          points: x
        }, this.app.updateShapes(
          [
            {
              id: r,
              type: "draw",
              props: {
                segments: v,
                isClosed: this.getIsClosed(c, a)
              }
            }
          ],
          !0
        ), x.length > 500) {
          this.app.updateShapes([{ id: r, type: "draw", props: { isComplete: !0 } }]);
          const { currentPagePoint: _ } = this.app.inputs, T = this.app.createShapeId();
          this.app.createShapes([
            {
              id: T,
              type: "draw",
              x: _.x,
              y: _.y,
              props: {
                isPen: this.isPen,
                segments: [
                  {
                    type: "free",
                    points: [{ x: 0, y: 0, z: this.isPen ? +(g * 1.25).toFixed() : 0.5 }]
                  }
                ]
              }
            }
          ]), this.initialShape = Lu(this.app.getShapeById(T)), this.mergeNextPoint = !1, this.lastRecordedPoint = this.app.inputs.currentPagePoint.clone();
        }
        break;
      }
    }
  }
  onPointerUp = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.complete();
  };
  onInterrupt = () => {
    this.app.inputs.isDragging || (this.app.bail(), this.cancel());
  };
  complete() {
    if (!this.canDraw) {
      this.cancel();
      return;
    }
    const { initialShape: e } = this;
    e && (this.app.updateShapes([
      { id: e.id, type: e.type, props: { isComplete: !0 } }
    ]), this.parent.transition("idle", {}));
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
}
let Sne = class extends sn {
  static id = "idle";
  onPointerDown = (e) => {
    this.parent.transition("drawing", e);
  };
  onEnter = () => {
    this.app.setCursor({ type: "cross" });
  };
  onCancel = () => {
    this.app.setSelectedTool("select");
  };
};
class wne extends sn {
  static id = "draw";
  static initial = "idle";
  static children = () => [Sne, bne];
  styles = ["color", "opacity", "dash", "fill", "size"];
  onExit = () => {
    const e = this.children.drawing;
    e.initialShape = void 0;
  };
}
class xne extends sn {
  static id = "erasing";
  info = {};
  scribble = {};
  markId = "";
  excludedShapeIds = /* @__PURE__ */ new Set();
  onEnter = (e) => {
    this.markId = this.app.mark("erase scribble begin"), this.info = e;
    const { originPagePoint: n } = this.app.inputs;
    this.excludedShapeIds = new Set(
      this.app.shapesArray.filter(
        (r) => (r.type === "frame" || r.type === "group") && this.app.isPointInShape(n, r)
      ).map((r) => r.id)
    ), this.startScribble(), this.update();
  };
  startScribble = () => {
    this.scribble = new Aj({
      onUpdate: this.onScribbleUpdate,
      onComplete: this.onScribbleComplete,
      color: "muted-1",
      size: 12
    }), this.app.on("tick", this.scribble.tick);
  };
  pushPointToScribble = () => {
    const { x: e, y: n } = this.app.inputs.currentPagePoint;
    this.scribble.addPoint(e, n);
  };
  onScribbleUpdate = (e) => {
    this.app.setScribble(e);
  };
  onScribbleComplete = () => {
    this.app.off("tick", this.scribble.tick), this.app.setScribble(null);
  };
  onExit = () => {
    this.scribble.stop();
  };
  onPointerMove = () => {
    this.update();
  };
  onPointerUp = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.complete();
  };
  update() {
    const {
      shapesArray: e,
      erasingIdsSet: n,
      inputs: { currentPagePoint: r, previousPagePoint: a }
    } = this.app, { excludedShapeIds: s } = this;
    this.pushPointToScribble();
    const c = new Set(n);
    for (const f of e) {
      if (f.type === "group")
        continue;
      const p = this.app.getPageMaskById(f.id);
      if (p && !Uu(r, p))
        continue;
      const g = this.app.getShapeUtil(f), y = this.app.getPointInShapeSpace(f, a), v = this.app.getPointInShapeSpace(f, r);
      g.hitTestLineSegment(f, y, v) && c.add(this.app.getOutermostSelectableShape(f).id);
    }
    this.app.setErasingIds([...c].filter((f) => !s.has(f)));
  }
  complete() {
    this.app.deleteShapes(this.app.pageState.erasingIds), this.app.setErasingIds([]), this.parent.transition("idle", {});
  }
  cancel() {
    this.app.setErasingIds([]), this.app.bailToMark(this.markId), this.parent.transition("idle", this.info);
  }
}
let Ene = class extends sn {
  static id = "idle";
  onPointerDown = (e) => {
    this.parent.transition("pointing", e);
  };
}, Cne = class extends sn {
  static id = "pointing";
  onEnter = () => {
    const { inputs: e } = this.app, n = /* @__PURE__ */ new Set(), r = n.size;
    for (const a of [...this.app.sortedShapesArray].reverse())
      if (this.app.isPointInShape(e.currentPagePoint, a)) {
        if (a.type === "group")
          continue;
        const s = this.app.getOutermostSelectableShape(a);
        if (s.type === "frame" && n.size > r)
          break;
        n.add(s.id);
      }
    this.app.setErasingIds([...n]);
  };
  onPointerMove = (e) => {
    this.app.inputs.isDragging && this.parent.transition("erasing", e);
  };
  onPointerUp = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.complete();
  };
  onInterrupt = () => {
    this.cancel();
  };
  complete() {
    const { erasingIds: e } = this.app;
    e.length && (this.app.mark("erase end"), this.app.deleteShapes(e)), this.app.setErasingIds([]), this.parent.transition("idle", {});
  }
  cancel() {
    this.app.setErasingIds([]), this.parent.transition("idle", {});
  }
};
class _ne extends sn {
  static id = "eraser";
  static initial = "idle";
  static children = () => [Ene, Cne, xne];
  onEnter = () => {
    this.app.setCursor({ type: "cross" });
  };
}
let Tne = class extends sn {
  static id = "idle";
  onPointerDown = (e) => {
    this.parent.transition("pointing", e);
  };
  onEnter = () => {
    this.app.setCursor({ type: "cross" });
  };
  onCancel = () => {
    this.app.setSelectedTool("select");
  };
}, kne = class extends sn {
  static id = "pointing";
  markId = "creating";
  wasFocusedOnEnter = !1;
  onEnter = () => {
    const { isMenuOpen: e } = this.app;
    this.wasFocusedOnEnter = !e;
  };
  onPointerMove = (e) => {
    if (this.app.inputs.isDragging) {
      const { originPagePoint: n } = this.app.inputs, r = this.parent.shapeType, a = io();
      this.app.mark(this.markId), this.app.createShapes([
        {
          id: a,
          type: r,
          x: n.x,
          y: n.y,
          props: {
            w: 1,
            h: 1
          }
        }
      ]), this.app.setSelectedIds([a]), this.app.setSelectedTool("select.resizing", {
        ...e,
        target: "selection",
        handle: "bottom_right",
        isCreating: !0,
        creationCursorOffset: { x: 1, y: 1 },
        onInteractionEnd: this.parent.id
      });
    }
  };
  onPointerUp = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.complete();
  };
  onInterrupt = () => {
    this.cancel();
  };
  complete() {
    const { originPagePoint: e } = this.app.inputs;
    if (!this.wasFocusedOnEnter)
      return;
    this.app.mark(this.markId);
    const n = this.parent.shapeType, r = io();
    this.app.mark(this.markId), this.app.createShapes([
      {
        id: r,
        type: n,
        x: e.x,
        y: e.y
      }
    ]);
    const a = this.app.getShapeById(r), { w: s, h: c } = this.app.getShapeUtil(a).defaultProps(), f = this.app.getDeltaInParentSpace(a, new O(s / 2, c / 2));
    this.app.updateShapes([
      {
        id: r,
        type: n,
        x: a.x - f.x,
        y: a.y - f.y
      }
    ]), this.app.setSelectedIds([r]), this.app.instanceState.isToolLocked ? this.parent.transition("idle", {}) : this.app.setSelectedTool("select.idle");
  }
  cancel() {
    this.parent.transition("idle", {});
  }
};
class Dc extends sn {
  static id = "box";
  static initial = "idle";
  static children = () => [Tne, kne];
  styles = ["opacity"];
}
class Pne extends Dc {
  static id = "frame";
  static initial = "idle";
  shapeType = "frame";
  styles = ["opacity"];
}
let Ine = class extends sn {
  static id = "idle";
  onPointerDown = (e) => {
    this.parent.transition("pointing", e);
  };
  onEnter = () => {
    this.app.setCursor({ type: "cross" });
  };
  onKeyUp = (e) => {
    if (e.key === "Enter") {
      const n = this.app.onlySelectedShape;
      n && n.type === "geo" && (this.app.mark("editing shape"), this.app.setEditingId(n.id), this.app.setSelectedTool("select.editing_shape", {
        ...e,
        target: "shape",
        shape: n
      }));
    }
  };
  onCancel = () => {
    this.app.setSelectedTool("select");
  };
}, Rne = class extends sn {
  static id = "pointing";
  onPointerMove = (e) => {
    if (this.app.inputs.isDragging) {
      const { originPagePoint: n } = this.app.inputs, r = io();
      this.app.mark("creating"), this.app.createShapes([
        {
          id: r,
          type: "geo",
          x: n.x,
          y: n.y,
          props: {
            w: 1,
            h: 1,
            geo: this.app.instanceState.propsForNextShape.geo
          }
        }
      ]), this.app.select(r), this.app.setSelectedTool("select.resizing", {
        ...e,
        target: "selection",
        handle: "bottom_right",
        isCreating: !0,
        creationCursorOffset: { x: 1, y: 1 },
        onInteractionEnd: "geo"
      });
    }
  };
  onPointerUp = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.complete();
  };
  onInterrupt = () => {
    this.cancel();
  };
  complete() {
    const { originPagePoint: e } = this.app.inputs, n = io();
    this.app.mark("creating"), this.app.createShapes([
      {
        id: n,
        type: "geo",
        x: e.x,
        y: e.y,
        props: {
          geo: this.app.instanceState.propsForNextShape.geo,
          w: 1,
          h: 1
        }
      }
    ]);
    const r = this.app.getShapeById(n);
    if (!r)
      return;
    const a = r.props.geo === "star" ? Vq(5, 200, 200) : new ot(0, 0, 200, 200), s = this.app.getDeltaInParentSpace(r, a.center);
    this.app.select(n), this.app.updateShapes([
      {
        id: r.id,
        type: "geo",
        x: r.x - s.x,
        y: r.y - s.y,
        props: {
          geo: this.app.instanceState.propsForNextShape.geo,
          w: a.width,
          h: a.height
        }
      }
    ]), this.app.instanceState.isToolLocked ? this.parent.transition("idle", {}) : this.app.setSelectedTool("select", {});
  }
  cancel() {
    this.parent.transition("idle", {});
  }
};
class $ne extends sn {
  static id = "geo";
  static initial = "idle";
  static children = () => [Ine, Rne];
  styles = ["color", "opacity", "dash", "fill", "size", "geo", "font", "align"];
}
class Mne extends sn {
  static id = "dragging";
  onEnter = () => {
    this.update();
  };
  onPointerMove = () => {
    this.update();
  };
  onPointerUp = () => {
    this.complete();
  };
  onCancel = () => {
    this.complete();
  };
  onComplete = () => {
    this.complete();
  };
  update() {
    const { currentScreenPoint: e, previousScreenPoint: n } = this.app.inputs, r = O.Sub(e, n);
    (Math.abs(r.x) > 0 || Math.abs(r.y) > 0) && this.app.pan(r.x, r.y);
  }
  complete() {
    this.app.slideCamera({
      speed: Math.min(2, this.app.inputs.pointerVelocity.len()),
      direction: this.app.inputs.pointerVelocity,
      friction: ux
    }), this.parent.transition("idle", {});
  }
}
let Ane = class extends sn {
  static id = "idle";
  onEnter = () => {
    this.app.setCursor({ type: "grab" });
  };
  onPointerDown = (e) => {
    this.parent.transition("pointing", e);
  };
  onCancel = () => {
    this.app.setSelectedTool("select");
  };
}, One = class extends sn {
  static id = "pointing";
  onEnter = () => {
    this.app.stopCameraAnimation(), this.app.setCursor({ type: "grabbing" });
  };
  onPointerMove = (e) => {
    this.app.inputs.isDragging && this.parent.transition("dragging", e);
  };
  onPointerUp = () => {
    this.complete();
  };
  onCancel = () => {
    this.complete();
  };
  onComplete = () => {
    this.complete();
  };
  onInterrupt = () => {
    this.complete();
  };
  complete() {
    this.parent.transition("idle", {});
  }
};
class Dne extends sn {
  static id = "hand";
  static initial = "idle";
  static children = () => [Ane, One, Mne];
  styles = [];
  onDoubleClick = (e) => {
    if (e.phase === "settle") {
      const { currentScreenPoint: n } = this.app.inputs;
      this.app.zoomIn(n, { duration: 220, easing: fa.easeOutQuint });
    }
  };
  onTripleClick = (e) => {
    if (e.phase === "settle") {
      const { currentScreenPoint: n } = this.app.inputs;
      this.app.zoomOut(n, { duration: 320, easing: fa.easeOutQuint });
    }
  };
  onQuadrupleClick = (e) => {
    if (e.phase === "settle") {
      const {
        zoomLevel: n,
        inputs: { currentScreenPoint: r }
      } = this.app;
      n === 1 ? this.app.zoomToFit({ duration: 400, easing: fa.easeOutQuint }) : this.app.resetZoom(r, { duration: 320, easing: fa.easeOutQuint });
    }
  };
}
let Nne = class extends sn {
  static id = "idle";
  shapeId = "";
  onEnter = (e) => {
    this.shapeId = e.shapeId, this.app.setCursor({ type: "cross" });
  };
  onPointerDown = () => {
    this.parent.transition("pointing", { shapeId: this.shapeId });
  };
  onCancel = () => {
    this.app.setSelectedTool("select");
  };
}, Lne = class extends sn {
  static id = "pointing";
  shapeType = "";
  shape = {};
  markPointId = "";
  onEnter = (e) => {
    const { inputs: n } = this.app, { currentPagePoint: r } = n;
    this.shapeType = this.parent.shapeType, this.markPointId = this.app.mark("creating");
    let a = !1;
    if (e.shapeId) {
      const s = this.app.getShapeById(e.shapeId);
      s && (a = !0, this.shape = s);
    }
    if (n.shiftKey && a) {
      const c = this.app.getShapeUtil(this.shape).handles(this.shape).filter((x) => x.type === "vertex").sort(Ya), f = c[c.length - 1], p = De.applyToPoint(
        this.app.getParentTransform(this.shape),
        new O(this.shape.x, this.shape.y)
      );
      let g, y, v;
      c.length === 2 && c[1].x === 1 && c[1].y === 1 ? (g = c[1].index, y = c[1].id, v = {
        ...c[1],
        x: r.x - p.x,
        y: r.y - p.y
      }) : (g = Mu(f.index), y = "handle:" + g, v = {
        x: r.x - p.x,
        y: r.y - p.y,
        index: g,
        canBind: !1,
        type: "vertex",
        id: y
      });
      const S = Lu(this.shape.props.handles);
      S[v.id] = v, this.app.updateShapes([
        {
          id: this.shape.id,
          type: this.shape.type,
          props: {
            handles: S
          }
        }
      ]);
    } else {
      const s = io();
      this.app.createShapes([
        {
          id: s,
          type: this.shapeType,
          x: r.x,
          y: r.y
        }
      ]), this.app.select(s), this.shape = this.app.getShapeById(s);
    }
  };
  onPointerMove = () => {
    if (this.shape && this.app.inputs.isDragging) {
      const n = this.app.getShapeUtil(this.shape).handles?.(this.shape);
      if (!n)
        throw this.app.bailToMark("creating"), Error("No handles found");
      this.app.setSelectedTool("select.dragging_handle", {
        shape: this.shape,
        isCreating: !0,
        handle: Hs(n),
        onInteractionEnd: "line"
      });
    }
  };
  onPointerUp = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.complete();
  };
  onInterrupt = () => {
    this.parent.transition("idle", {}), this.app.bailToMark("creating"), this.app.snaps.clear();
  };
  complete() {
    this.parent.transition("idle", { shapeId: this.shape.id }), this.app.snaps.clear();
  }
  cancel() {
    this.app.bailToMark(this.markPointId), this.parent.transition("idle", { shapeId: this.shape.id }), this.app.snaps.clear();
  }
};
class jne extends sn {
  static id = "line";
  static initial = "idle";
  static children = () => [Nne, Lne];
  shapeType = "line";
  styles = ["color", "opacity", "dash", "size", "spline"];
}
let zne = class extends sn {
  static id = "idle";
  onPointerDown = (e) => {
    this.parent.transition("pointing", e);
  };
  onEnter = () => {
    this.app.setCursor({ type: "cross" });
  };
  onCancel = () => {
    this.app.setSelectedTool("select");
  };
}, Une = class extends sn {
  static id = "pointing";
  dragged = !1;
  info = {};
  wasFocusedOnEnter = !1;
  markPointId = "creating";
  onEnter = () => {
    this.wasFocusedOnEnter = !this.app.isMenuOpen;
  };
  onPointerMove = (e) => {
    if (this.app.inputs.isDragging) {
      this.app.mark(this.markPointId);
      const n = this.createShape();
      if (!n)
        return;
      this.app.setSelectedTool("select.translating", {
        ...e,
        target: "shape",
        shape: n,
        isCreating: !0,
        editAfterComplete: !0,
        onInteractionEnd: "note"
      });
    }
  };
  onPointerUp = () => {
    this.complete();
  };
  onInterrupt = () => {
    this.cancel();
  };
  onComplete = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  complete() {
    if (!this.wasFocusedOnEnter)
      return;
    this.app.mark(this.markPointId);
    const e = this.createShape();
    if (this.app.instanceState.isToolLocked)
      this.parent.transition("idle", {});
    else {
      if (!e)
        return;
      this.app.setEditingId(e.id), this.app.setSelectedTool("select.editing_shape", {
        ...this.info,
        target: "shape",
        shape: e
      });
    }
  }
  cancel() {
    this.app.bailToMark(this.markPointId), this.parent.transition("idle", this.info);
  }
  createShape() {
    const {
      inputs: { originPagePoint: e }
    } = this.app, n = this.app.createShapeId();
    this.app.createShapes(
      [
        {
          id: n,
          type: "note",
          x: e.x,
          y: e.y
        }
      ],
      !0
    );
    const r = this.app.getShapeUtilByDef(dP), a = this.app.getShapeById(n);
    oL(dP.is(a));
    const s = r.bounds(a);
    return this.app.updateShapes([
      {
        id: n,
        type: "note",
        x: a.x - s.width / 2,
        y: a.y - s.height / 2
      }
    ]), this.app.getShapeById(n);
  }
};
class Bne extends sn {
  static id = "note";
  static initial = "idle";
  static children = () => [zne, Une];
  styles = ["color", "opacity", "size", "align", "font"];
}
class Fne extends sn {
  static id = "translating";
  info = {};
  selectionSnapshot = {};
  snapshot = {};
  markId = "";
  isCloning = !1;
  isCreating = !1;
  editAfterComplete = !1;
  dragAndDropManager = new ane(this.app);
  onEnter = (e) => {
    const { isCreating: n = !1, editAfterComplete: r = !1 } = e;
    this.info = e, this.isCreating = n, this.editAfterComplete = r, this.markId = n ? "creating" : this.app.mark("translating"), this.handleEnter(e), this.app.on("tick", this.updateParent);
  };
  updateParent = () => {
    const { snapshot: e } = this;
    this.dragAndDropManager.updateDroppingNode(e.movingShapes, this.updateParentTransforms);
  };
  onExit = () => {
    this.app.off("tick", this.updateParent), this.selectionSnapshot = {}, this.snapshot = {}, this.app.snaps.clear(), this.app.setCursor({ type: "default" }), this.dragAndDropManager.clear();
  };
  onPointerMove = () => {
    this.updateShapes();
  };
  onKeyDown = () => {
    if (this.app.inputs.altKey && !this.isCloning) {
      this.startCloning();
      return;
    }
    this.updateShapes();
  };
  onKeyUp = () => {
    if (!this.app.inputs.altKey && this.isCloning) {
      this.stopCloning();
      return;
    }
    this.updateShapes();
  };
  onPointerUp = () => {
    this.complete();
  };
  onComplete = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  reset() {
    this.app.bailToMark(this.markId);
  }
  startCloning() {
    this.isCreating || (this.isCloning = !0, this.reset(), this.markId = this.app.mark("translating"), this.app.duplicateShapes(), this.snapshot = FD(this.app), this.handleStart(), this.updateShapes());
  }
  stopCloning() {
    this.isCloning = !1, this.snapshot = this.selectionSnapshot, this.reset(), this.markId = this.app.mark("translating"), this.updateShapes();
  }
  complete() {
    if (this.updateShapes(), this.dragAndDropManager.dropShapes(this.snapshot.movingShapes), this.handleEnd(), this.app.instanceState.isToolLocked && this.info.onInteractionEnd)
      this.app.setSelectedTool(this.info.onInteractionEnd);
    else if (this.editAfterComplete) {
      const e = this.app.onlySelectedShape;
      e && (this.app.setEditingId(e.id), this.app.setSelectedTool("select"), this.app.root.current.value.transition("editing_shape", {}));
    } else
      this.parent.transition("idle", {});
  }
  cancel() {
    this.reset(), this.info.onInteractionEnd ? this.app.setSelectedTool(this.info.onInteractionEnd) : this.parent.transition("idle", this.info);
  }
  handleEnter(e) {
    if (this.isCloning = !1, this.info = e, this.app.setCursor({ type: "move" }), this.selectionSnapshot = FD(this.app), !this.isCreating && this.app.inputs.altKey) {
      this.startCloning();
      return;
    }
    this.snapshot = this.selectionSnapshot, this.handleStart(), this.updateShapes();
  }
  handleStart() {
    const { movingShapes: e } = this.snapshot, n = [];
    e.forEach((r) => {
      const s = this.app.getShapeUtil(r).onTranslateStart?.(r);
      s && n.push(s);
    }), n.length > 0 && this.app.updateShapes(n);
  }
  handleEnd() {
    const { movingShapes: e } = this.snapshot, n = [];
    e.forEach((r) => {
      const a = this.app.getShapeById(r.id), c = this.app.getShapeUtil(r).onTranslateEnd?.(r, a);
      c && n.push(c);
    }), n.length > 0 && this.app.updateShapes(n);
  }
  handleChange() {
    const { movingShapes: e } = this.snapshot, n = [];
    e.forEach((r) => {
      const a = this.app.getShapeById(r.id), c = this.app.getShapeUtil(r).onTranslate?.(r, a);
      c && n.push(c);
    }), n.length > 0 && this.app.updateShapes(n);
  }
  updateShapes() {
    const { snapshot: e } = this;
    this.dragAndDropManager.updateDroppingNode(e.movingShapes, this.updateParentTransforms), Hne({
      app: this.app,
      shapeSnapshots: e.shapeSnapshots,
      averagePagePoint: e.averagePagePoint,
      initialSelectionPageBounds: e.initialPageBounds,
      initialSelectionSnapPoints: e.initialSnapPoints
    }), this.handleChange();
  }
  updateParentTransforms = () => {
    const {
      app: e,
      snapshot: { shapeSnapshots: n }
    } = this;
    n.forEach((r) => {
      const a = e.getShapeById(r.shape.id);
      if (!a)
        return null;
      const s = fr.isId(a.parentId) ? null : De.Inverse(e.getPageTransformById(a.parentId));
      r.parentTransform = s;
    });
  };
}
function FD(t) {
  const e = [], n = [], r = Gt(
    t.selectedIds.map((a) => {
      const s = t.getShapeById(a);
      if (!s)
        return null;
      e.push(s);
      const c = t.getPagePointById(a);
      if (!c)
        return null;
      n.push(c);
      const f = fr.isId(s.parentId) ? null : De.Inverse(t.getPageTransformById(s.parentId));
      return {
        shape: s,
        pagePoint: c,
        parentTransform: f
      };
    })
  );
  return {
    averagePagePoint: O.Average(n),
    movingShapes: e,
    shapeSnapshots: r,
    initialPageBounds: t.selectedPageBounds,
    initialSnapPoints: t.selectedIds.length === 1 ? t.snaps.snapPointsCache.get(t.selectedIds[0]) : t.selectedPageBounds ? t.selectedPageBounds.snapPoints.map((a, s) => ({
      id: "selection:" + s,
      x: a.x,
      y: a.y
    })) : []
  };
}
function Hne({
  app: t,
  shapeSnapshots: e,
  averagePagePoint: n,
  initialSelectionPageBounds: r,
  initialSelectionSnapPoints: a
}) {
  const { inputs: s, isGridMode: c, gridSize: f } = t, p = O.Sub(s.currentPagePoint, s.originPagePoint), g = t.inputs.shiftKey ? Math.abs(p.x) < Math.abs(p.y) ? "x" : "y" : null;
  if (g === "x" ? p.x = 0 : g === "y" && (p.y = 0), t.snaps.clear(), (t.userDocumentSettings.isSnapMode ? !s.ctrlKey : s.ctrlKey) && t.inputs.pointerVelocity.len() < 0.5) {
    const { nudge: x } = t.snaps.snapTranslate({
      dragDelta: p,
      initialSelectionPageBounds: r,
      lockedAxis: g,
      initialSelectionSnapPoints: a
    });
    p.add(x);
  }
  const v = O.Add(n, p);
  c && !s.ctrlKey && v.snapToGrid(f);
  const S = O.Sub(v, n);
  t.updateShapes(
    Gt(
      e.map(({ shape: x, pagePoint: _, parentTransform: T }) => {
        const I = O.Add(_, S), D = T ? De.applyToPoint(T, I) : I;
        return {
          id: x.id,
          type: x.type,
          x: D.x,
          y: D.y
        };
      })
    ),
    !0
  );
}
class Vne extends sn {
  static id = "brushing";
  info = {};
  brush = new ot();
  initialSelectedIds = [];
  // The shape that the brush started on
  initialStartShape = null;
  onEnter = (e) => {
    const { altKey: n, currentPagePoint: r } = this.app.inputs;
    if (n) {
      this.parent.transition("scribble_brushing", e);
      return;
    }
    this.info = e, this.initialSelectedIds = this.app.selectedIds.slice(), this.initialStartShape = this.app.getShapesAtPoint(r)[0], this.onPointerMove();
  };
  onExit = () => {
    this.initialSelectedIds = [], this.app.setBrush(null);
  };
  onPointerMove = () => {
    this.hitTestShapes();
  };
  onPointerUp = () => {
    this.complete();
  };
  onComplete = () => {
    this.complete();
  };
  onCancel = (e) => {
    this.app.setSelectedIds(this.initialSelectedIds, !0), this.parent.transition("idle", e);
  };
  onKeyDown = (e) => {
    this.app.inputs.altKey ? this.parent.transition("scribble_brushing", e) : this.hitTestShapes();
  };
  onKeyUp = () => {
    this.hitTestShapes();
  };
  complete() {
    this.parent.transition("idle", {});
  }
  hitTestShapes() {
    const {
      currentPageId: e,
      shapesArray: n,
      inputs: { originPagePoint: r, currentPagePoint: a, shiftKey: s, ctrlKey: c }
    } = this.app;
    this.brush.setTo(ot.FromPoints([r, a]));
    const f = new Set(s ? this.initialSelectedIds : []);
    let p, g, y, v, S, x, _;
    const { corners: T } = this.brush;
    e:
      for (let I = 0, D = n.length; I < D; I++) {
        if (y = n[I], y.type === "group" || f.has(y.id) || (S = this.app.getPageBounds(y), !S))
          continue e;
        if (this.brush.contains(S)) {
          this.handleHit(y, a, e, f, T);
          continue e;
        }
        if (c || y.type === "frame")
          continue e;
        if (this.brush.collides(S)) {
          if (v = this.app.getShapeUtil(y), x = this.app.getPageTransform(y), !x)
            continue e;
          _ = De.applyToPoints(De.Inverse(x), T);
          t:
            for (let N = 0; N < _.length; N++)
              if (p = _[N], g = _[(N + 1) % _.length], v.hitTestLineSegment(y, p, g)) {
                this.handleHit(y, a, e, f, T);
                break t;
              }
        }
      }
    this.app.setBrush({ ...this.brush.toJson() }), this.app.setSelectedIds(Array.from(f), !0);
  }
  onInterrupt = () => {
    this.app.setBrush(null);
  };
  handleHit(e, n, r, a, s) {
    if (e.parentId === r) {
      a.add(e.id);
      return;
    }
    const c = this.app.getOutermostSelectableShape(e), f = this.app.getPageMaskById(c.id);
    f && rQ(f, s) !== null && !Uu(n, f) || a.add(c.id);
  }
}
class Yne extends sn {
  static id = "dragging_handle";
  shapeId = "";
  initialHandle = {};
  initialAdjacentHandle = null;
  markId = "";
  initialPageTransform;
  initialPageRotation;
  info = {};
  isPrecise = !1;
  isPreciseId = null;
  pointingId = null;
  onEnter = (e) => {
    const { shape: n, isCreating: r, handle: a } = e;
    this.info = e, this.shapeId = n.id, this.markId = r ? "creating" : this.app.mark("dragging handle"), this.initialHandle = Tc(a), this.initialPageTransform = this.app.getPageTransform(n), this.initialPageRotation = this.app.getPageRotation(n), this.app.setCursor({ type: r ? "cross" : "grabbing", rotation: 0 });
    const s = this.app.getShapeUtil(n).handles(n).sort(Ya), c = s.findIndex((p) => p.id === e.handle.id);
    this.initialAdjacentHandle = null;
    for (let p = c + 1; p < s.length; p++) {
      const g = s[p];
      if (g.type === "vertex" && g.id !== "middle" && g.id !== e.handle.id) {
        this.initialAdjacentHandle = g;
        break;
      }
    }
    if (!this.initialAdjacentHandle)
      for (let p = s.length - 1; p >= 0; p--) {
        const g = s[p];
        if (g.type === "vertex" && g.id !== "middle" && g.id !== e.handle.id) {
          this.initialAdjacentHandle = g;
          break;
        }
      }
    const f = n.props[e.handle.id];
    this.isPrecise = !1, f?.type === "binding" && (this.app.setHintingIds([f.boundShapeId]), this.isPrecise = !O.Equals(f.normalizedAnchor, { x: 0.5, y: 0.5 }), this.isPrecise ? this.isPreciseId = f.boundShapeId : this.resetExactTimeout()), this.update();
  };
  exactTimeout = -1;
  resetExactTimeout() {
    this.exactTimeout !== -1 && this.clearExactTimeout(), this.exactTimeout = setTimeout(() => {
      this.isActive && !this.isPrecise && (this.isPrecise = !0, this.isPreciseId = this.pointingId, this.update()), this.exactTimeout = -1;
    }, 750);
  }
  clearExactTimeout() {
    this.exactTimeout !== -1 && (clearTimeout(this.exactTimeout), this.exactTimeout = -1);
  }
  onPointerMove = () => {
    this.update();
  };
  onKeyDown = () => {
    this.update();
  };
  onKeyUp = () => {
    this.update();
  };
  onPointerUp = () => {
    this.complete();
  };
  onComplete = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  onExit = () => {
    this.app.setHintingIds([]), this.app.snaps.clear(), this.app.setCursor({ type: "default" });
  };
  complete() {
    this.app.snaps.clear();
    const { onInteractionEnd: e } = this.info;
    if (this.app.instanceState.isToolLocked && e) {
      this.app.setSelectedTool(e, { shapeId: this.shapeId });
      return;
    }
    this.parent.transition("idle", {});
  }
  cancel() {
    this.app.bailToMark(this.markId), this.app.snaps.clear();
    const { onInteractionEnd: e } = this.info;
    if (e) {
      this.app.setSelectedTool(e, { shapeId: this.shapeId });
      return;
    }
    this.parent.transition("idle", {});
  }
  update() {
    const { currentPagePoint: e, originPagePoint: n, shiftKey: r } = this.app.inputs, a = this.app.getShapeById(this.shapeId);
    if (!a)
      return;
    let s = O.Add(
      O.Rot(O.Sub(e, n), -this.initialPageRotation),
      this.initialHandle
    );
    if (r && this.initialHandle.id !== "middle") {
      const { initialAdjacentHandle: v } = this;
      if (v) {
        const S = O.Angle(v, s), _ = Rx(S, 24) - S;
        s = O.RotWith(s, v, _);
      }
    }
    this.app.snaps.clear();
    const { ctrlKey: c } = this.app.inputs;
    if ((this.app.userDocumentSettings.isSnapMode ? !c : c) && a.type === "line") {
      const v = De.applyToPoint(this.app.getPageTransformById(a.id), s), S = this.app.snaps.snapLineHandleTranslate({
        lineId: a.id,
        handleId: this.initialHandle.id,
        handlePoint: v
      }), { nudge: x } = S;
      if (x.x || x.y) {
        const _ = this.app.getDeltaInShapeSpace(a, x);
        s = O.Add(s, _);
      }
    }
    const g = this.app.getShapeUtil(a).onHandleChange?.(a, {
      handle: {
        ...this.initialHandle,
        x: s.x,
        y: s.y
      },
      isPrecise: this.isPrecise || this.app.inputs.altKey
    }), y = { ...a, ...g };
    if (this.initialHandle.canBind) {
      const v = y.props[this.initialHandle.id];
      v?.type === "binding" ? this.app.hintingIds[0] !== v.boundShapeId && (this.app.setHintingIds([v.boundShapeId]), this.pointingId = v.boundShapeId, this.isPrecise = this.app.inputs.pointerVelocity.len() < 0.5 || this.app.inputs.altKey, this.isPreciseId = this.isPrecise ? v.boundShapeId : null, this.resetExactTimeout()) : this.app.hintingIds.length > 0 && (this.app.setHintingIds([]), this.pointingId = null, this.isPrecise = !1, this.isPreciseId = null, this.resetExactTimeout());
    }
    g && this.app.updateShapes([y], !0);
  }
}
class Kne extends sn {
  static id = "editing_shape";
  onPointerEnter = (e) => {
    switch (e.target) {
      case "shape": {
        const { selectedIds: n, focusLayerId: r } = this.app, a = this.app.getOutermostSelectableShape(
          e.shape,
          (s) => !n.includes(s.id)
        );
        a.id !== r && this.app.setHoveredId(a.id);
        break;
      }
    }
  };
  onPointerLeave = (e) => {
    switch (e.target) {
      case "shape": {
        this.app.setHoveredId(null);
        break;
      }
    }
  };
  onExit = () => {
    if (!this.app.pageState.editingId)
      return;
    const { editingId: e } = this.app.pageState;
    if (!e)
      return;
    this.app.setEditingId(null);
    const n = this.app.getShapeById(e);
    this.app.getShapeUtil(n).onEditEnd?.(n);
  };
  onPointerDown = (e) => {
    switch (e.target) {
      case "shape": {
        const { shape: n } = e, { editingId: r } = this.app.pageState;
        if (r) {
          if (n.id === r)
            return;
          const a = this.app.getShapeById(r);
          if (a) {
            const s = this.app.getShapeUtil(n);
            if (n.type === a.type && s.canEdit?.(n)) {
              this.app.setEditingId(n.id), this.app.setHoveredId(n.id), this.app.setSelectedIds([n.id]);
              return;
            }
          }
        }
      }
    }
    this.parent.transition("idle", e), this.parent.current.value?.onPointerDown?.(e);
  };
  onComplete = (e) => {
    this.parent.transition("idle", e);
  };
  onCancel = (e) => {
    this.parent.transition("idle", e);
  };
  onBlur = (e) => {
    this.parent.transition("idle", e);
  };
}
let Wne = class extends sn {
  static id = "idle";
  onPointerEnter = (e) => {
    switch (e.target) {
      case "canvas":
        break;
      case "shape": {
        const { selectedIds: n, focusLayerId: r } = this.app, a = this.app.getOutermostSelectableShape(
          e.shape,
          (s) => !n.includes(s.id)
        );
        a.id !== r && this.app.setHoveredId(a.id);
        break;
      }
    }
  };
  onPointerLeave = (e) => {
    switch (e.target) {
      case "shape": {
        this.app.setHoveredId(null);
        break;
      }
    }
  };
  onPointerDown = (e) => {
    if (!this.app.isMenuOpen) {
      if (e.ctrlKey) {
        this.parent.transition("brushing", e);
        return;
      }
      switch (e.target) {
        case "canvas": {
          this.parent.transition("pointing_canvas", e);
          break;
        }
        case "shape": {
          this.parent.transition("pointing_shape", e);
          break;
        }
        case "handle": {
          if (this.app.isReadOnly)
            break;
          this.parent.transition("pointing_handle", e);
          break;
        }
        case "selection": {
          switch (e.handle) {
            case "mobile_rotate":
            case "top_left_rotate":
            case "top_right_rotate":
            case "bottom_left_rotate":
            case "bottom_right_rotate": {
              this.parent.transition("pointing_rotate_handle", e);
              break;
            }
            case "top":
            case "right":
            case "bottom":
            case "left": {
              this.parent.transition("pointing_resize_handle", e);
              break;
            }
            case "top_left":
            case "top_right":
            case "bottom_left":
            case "bottom_right": {
              this.parent.transition("pointing_resize_handle", e);
              break;
            }
            default:
              this.parent.transition("pointing_selection", e);
          }
          break;
        }
      }
    }
  };
  onDoubleClick = (e) => {
    switch (e.target) {
      case "canvas": {
        this.createTextShapeAtPoint(e);
        break;
      }
      case "selection": {
        if (this.app.isReadOnly)
          break;
        const { onlySelectedShape: n } = this.app;
        if (n) {
          const r = this.app.getShapeUtil(n);
          if (e.handle === "right" || e.handle === "left" || e.handle === "top" || e.handle === "bottom") {
            const a = r.onDoubleClickEdge?.(n);
            if (a) {
              this.app.mark("double click edge"), this.app.updateShapes([a]);
              return;
            }
          }
          r.canEdit(n) && this.startEditingShape(n, e);
        }
        break;
      }
      case "shape": {
        const { shape: n } = e, r = this.app.getShapeUtil(n);
        if (n.type !== "video" && this.app.isReadOnly)
          break;
        if (r.onDoubleClick) {
          const a = r.onDoubleClick?.(n);
          a && this.app.updateShapes([a]);
        } else
          r.canEdit(n) ? this.startEditingShape(n, e) : this.createTextShapeAtPoint(e);
        break;
      }
      case "handle": {
        if (this.app.isReadOnly)
          break;
        const { shape: n, handle: r } = e, a = this.app.getShapeUtil(n), s = a.onDoubleClickHandle?.(n, r);
        s ? this.app.updateShapes([s]) : a.canEdit(n) && this.startEditingShape(n, e);
      }
    }
  };
  onRightClick = (e) => {
    switch (e.target) {
      case "canvas": {
        this.app.selectNone();
        break;
      }
      case "shape": {
        const { selectedIds: n } = this.app.pageState, { shape: r } = e, a = this.app.getOutermostSelectableShape(
          r,
          (s) => !this.app.isSelected(s.id)
        );
        n.includes(a.id) || (this.app.mark("selecting shape"), this.app.setSelectedIds([a.id]));
        break;
      }
    }
  };
  onEnter = () => {
    this.app.setHoveredId(null), this.app.setCursor({ type: "default" });
  };
  onCancel = () => {
    // if there are no selected shapes
    this.app.selectedIds.length === 0 || // or if the only selected shape is a group and the focus layer is not the page
    this.app.selectedIds.length === 1 && this.app.getShapeById(this.app.selectedIds[0])?.type === "group" && this.app.focusLayerId !== this.app.currentPageId ? this.app.popFocusLayer() : (this.app.mark("clearing selection"), this.app.selectNone());
  };
  onKeyUp = (e) => {
    if (!this.app.isReadOnly)
      switch (e.key) {
        case "Enter": {
          const { selectedShapes: n } = this.app;
          if (n.every((a) => a.type === "group")) {
            this.app.setSelectedIds(
              n.flatMap((a) => this.app.getSortedChildIds(a.id))
            );
            return;
          }
          const { onlySelectedShape: r } = this.app;
          if (r && this.app.getShapeUtil(r).canEdit(r)) {
            this.startEditingShape(r, {
              ...e,
              target: "shape",
              shape: r
            });
            return;
          }
          break;
        }
      }
  };
  startEditingShape(e, n) {
    this.app.mark("editing shape"), this.app.setEditingId(e.id), this.parent.transition("editing_shape", n);
  }
  createTextShapeAtPoint(e) {
    this.app.mark("creating text shape");
    const n = io(), { x: r, y: a } = this.app.inputs.currentPagePoint;
    this.app.createShapes([
      {
        id: n,
        type: "text",
        x: r,
        y: a,
        props: {
          text: "",
          autoSize: !0
        }
      }
    ]);
    const s = this.app.getShapeById(n);
    if (!s)
      return;
    const c = this.app.getBounds(s);
    this.app.updateShapes([
      {
        id: n,
        type: "text",
        x: s.x - c.width / 2,
        y: s.y - c.height / 2
      }
    ]), this.app.setEditingId(n), this.app.select(n), this.parent.transition("editing_shape", e);
  }
};
class Gne extends sn {
  static id = "pointing_canvas";
  onEnter = () => {
    const { inputs: e } = this.app;
    e.shiftKey || this.app.selectedIds.length > 0 && (this.app.mark("selecting none"), this.app.selectNone());
  };
  _clickWasInsideFocusedGroup() {
    const { focusLayerId: e, inputs: n } = this.app;
    if (!Fs(e))
      return !1;
    const r = this.app.getShapeById(e);
    if (!r)
      return !1;
    const a = this.app.getPointInShapeSpace(r, n.currentPagePoint);
    return this.app.getShapeUtil(r).hitTestPoint(r, a);
  }
  onPointerMove = (e) => {
    this.app.inputs.isDragging && this.parent.transition("brushing", e);
  };
  onPointerUp = () => {
    this.complete();
  };
  onComplete = () => {
    this.complete();
  };
  onInterrupt = () => {
    this.parent.transition("idle", {});
  };
  complete() {
    const { shiftKey: e } = this.app.inputs;
    e || (this.app.selectNone(), this._clickWasInsideFocusedGroup() || this.app.setFocusLayer(null)), this.parent.transition("idle", {});
  }
}
class Xne extends sn {
  static id = "pointing_handle";
  info = {};
  onEnter = (e) => {
    this.info = e;
    const n = e.shape.props[e.handle.id];
    n?.type === "binding" && this.app.setHintingIds([n.boundShapeId]), this.app.setCursor({ type: "grabbing" });
  };
  onExit = () => {
    this.app.setHintingIds([]), this.app.setCursor({ type: "default" });
  };
  onPointerUp = () => {
    this.parent.transition("idle", this.info);
  };
  onPointerMove = () => {
    this.app.inputs.isDragging && this.parent.transition("dragging_handle", this.info);
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.cancel();
  };
  onInterrupt = () => {
    this.cancel();
  };
  cancel() {
    this.parent.transition("idle", {});
  }
}
const zx = {
  bottom: "ns-resize",
  top: "ns-resize",
  left: "ew-resize",
  right: "ew-resize",
  bottom_left: "nesw-resize",
  bottom_right: "nwse-resize",
  top_left: "nwse-resize",
  top_right: "nesw-resize",
  bottom_left_rotate: "swne-rotate",
  bottom_right_rotate: "senw-rotate",
  top_left_rotate: "nwse-rotate",
  top_right_rotate: "nesw-rotate",
  mobile_rotate: "grabbing"
};
class qne extends sn {
  static id = "pointing_resize_handle";
  info = {};
  updateCursor() {
    const e = this.app.selectedShapes, n = zx[this.info.handle];
    this.app.setCursor({
      type: n,
      rotation: e.length === 1 ? e[0].rotation : 0
    });
  }
  onEnter = (e) => {
    this.info = e, this.updateCursor();
  };
  onPointerMove = () => {
    this.app.inputs.isDragging && this.parent.transition("resizing", this.info);
  };
  onPointerUp = () => {
    this.parent.transition("idle", {});
  };
  // override onPinchStart: TLEventHandlers['onPinchStart'] = (info) => {
  // 	this.parent.transition('pinching', info)
  // }
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.cancel();
  };
  onInterrupt = () => {
    this.cancel();
  };
  cancel() {
    this.parent.transition("idle", {});
  }
}
class Qne extends sn {
  static id = "pointing_rotate_handle";
  info = {};
  updateCursor() {
    const { selectionRotation: e } = this.app;
    this.app.setCursor({
      type: zx[this.info.handle],
      rotation: e
    });
  }
  onEnter = (e) => {
    this.info = e, this.updateCursor();
  };
  onPointerMove = () => {
    const { isDragging: e } = this.app.inputs;
    e && this.parent.transition("rotating", this.info);
  };
  onPointerUp = () => {
    this.parent.transition("idle", this.info);
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.cancel();
  };
  onInterrupt = () => {
    this.cancel();
  };
  cancel() {
    this.parent.transition("idle", {});
  }
}
class Zne extends sn {
  static id = "pointing_selection";
  info = {};
  onEnter = (e) => {
    this.info = e;
  };
  onPointerUp = (e) => {
    this.app.selectNone(), this.parent.transition("idle", e);
  };
  onPointerMove = (e) => {
    if (this.app.inputs.isDragging) {
      if (this.app.isReadOnly)
        return;
      this.parent.transition("translating", e);
    }
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.cancel();
  };
  onInterrupt = () => {
    this.cancel();
  };
  cancel() {
    this.parent.transition("idle", {});
  }
}
class Jne extends sn {
  static id = "pointing_shape";
  eventTargetShape = {};
  selectingShape = {};
  didSelectOnEnter = !1;
  onEnter = (e) => {
    const { shape: n } = e;
    if (n && this.app.getShapeUtil(n).onClick !== void 0)
      return;
    if (this.eventTargetShape = e.shape, this.selectingShape = this.app.getOutermostSelectableShape(e.shape), this.selectingShape.id === this.app.focusLayerId) {
      this.didSelectOnEnter = !1;
      return;
    }
    const r = this.app.isWithinSelection(this.selectingShape.id), a = this.app.selectedIds.length > 1 && // only on 2+ selected shapes!
    this.app.selectionBounds?.containsPoint(this.app.inputs.currentPagePoint);
    if (this.didSelectOnEnter = !r && this.selectingShape.id !== this.app.focusLayerId && !a, this.didSelectOnEnter) {
      const { inputs: s, selectedIds: c } = this.app, f = this.app.getParentShape(e.shape);
      f && f.type === "group" && this.app.cancelDoubleClick(), s.shiftKey && !s.altKey ? c.includes(this.selectingShape.id) || (this.app.mark("shift selecting shape"), this.app.setSelectedIds([...c, this.selectingShape.id])) : (this.app.mark("selecting shape"), this.app.setSelectedIds([this.selectingShape.id]));
    }
  };
  onPointerUp = (e) => {
    const { shape: n } = e;
    if (n) {
      const r = this.app.getShapeUtil(n);
      if (r.onClick) {
        const a = r.onClick?.(n);
        a && this.app.updateShapes([a]);
        return;
      }
    }
    if (!this.didSelectOnEnter && this.selectingShape.id !== this.app.focusLayerId) {
      this.app.mark("selecting shape (pointer up)");
      const r = this.app.getOutermostSelectableShape(
        this.eventTargetShape,
        // if a group is selected, we want to stop before reaching that group
        // so we can drill down into the group
        (a) => !this.app.isSelected(a.id)
      );
      if (this.app.selectedIds.includes(r.id))
        this.app.setSelectedIds(
          this.app.inputs.shiftKey ? this.app.selectedIds.filter((a) => a !== this.selectingShape.id) : [this.selectingShape.id]
        );
      else if (this.app.inputs.shiftKey) {
        const a = this.app.getAncestors(r);
        this.app.setSelectedIds([
          ...this.app.selectedIds.filter((s) => !a.find((c) => c.id === s)),
          r.id
        ]);
      } else
        this.app.setSelectedIds([r.id]);
    } else
      this.selectingShape.id === this.app.focusLayerId && (this.app.selectedIds.length > 0 ? this.app.setSelectedIds([]) : this.app.popFocusLayer());
    this.parent.transition("idle", e);
  };
  onPointerMove = (e) => {
    if (this.app.inputs.isDragging) {
      if (this.app.isReadOnly)
        return;
      this.parent.transition("translating", e);
    }
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.cancel();
  };
  onInterrupt = () => {
    this.cancel();
  };
  cancel() {
    this.parent.transition("idle", {});
  }
}
class ere extends sn {
  static id = "resizing";
  info = {};
  markId = "";
  // we transition into the resizing state from the geo pointing state, which starts with a shape of size w: 1, h: 1,
  // so if the user drags x: +50, y: +50 after mouseDown, the shape will be w: 51, h: 51, which is too many pixels, alas
  // so we allow passing a further offset into this state to negate such issues
  creationCursorOffset = { x: 0, y: 0 };
  editAfterComplete = !1;
  snapshot = {};
  onEnter = (e) => {
    const {
      isCreating: n = !1,
      editAfterComplete: r = !1,
      creationCursorOffset: a = { x: 0, y: 0 }
    } = e;
    this.info = e, this.editAfterComplete = r, this.creationCursorOffset = a, e.isCreating && this.app.setCursor({ type: "cross", rotation: 0 }), this.snapshot = this._createSnapshot(), this.markId = n ? "creating" : this.app.mark("starting resizing"), this.handleResizeStart(), this.updateShapes();
  };
  onPointerMove = () => {
    this.updateShapes();
  };
  onKeyDown = () => {
    this.updateShapes();
  };
  onKeyUp = () => {
    this.updateShapes();
  };
  onPointerUp = () => {
    this.complete();
  };
  onComplete = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  cancel() {
    this.app.bailToMark(this.markId), this.info.onInteractionEnd ? this.app.setSelectedTool(this.info.onInteractionEnd) : this.parent.transition("idle", {});
  }
  complete() {
    if (this.handleResizeEnd(), this.editAfterComplete && this.app.onlySelectedShape) {
      this.app.setEditingId(this.app.onlySelectedShape.id), this.app.setSelectedTool("select"), this.app.root.current.value.transition("editing_shape", {});
      return;
    }
    if (this.app.instanceState.isToolLocked && this.info.onInteractionEnd) {
      this.app.setSelectedTool(this.info.onInteractionEnd);
      return;
    }
    this.parent.transition("idle", {});
  }
  handleResizeStart() {
    const { shapeSnapshots: e } = this.snapshot, n = [];
    e.forEach(({ shape: r }) => {
      const s = this.app.getShapeUtil(r).onResizeStart?.(r);
      s && n.push(s);
    }), n.length > 0 && this.app.updateShapes(n);
  }
  handleResizeEnd() {
    const { shapeSnapshots: e } = this.snapshot, n = [];
    e.forEach(({ shape: r }) => {
      const a = this.app.getShapeById(r.id), c = this.app.getShapeUtil(r).onResizeEnd?.(r, a);
      c && n.push(c);
    }), n.length > 0 && this.app.updateShapes(n);
  }
  updateShapes() {
    const { altKey: e, shiftKey: n } = this.app.inputs, {
      shapeSnapshots: r,
      selectionBounds: a,
      cursorHandleOffset: s,
      selectedIds: c,
      selectionRotation: f,
      canShapesDeform: p
    } = this.snapshot, g = n || !p, { ctrlKey: y } = this.app.inputs, v = this.app.inputs.currentPagePoint.clone().sub(s).sub(this.creationCursorOffset), S = this.app.inputs.originPagePoint.clone().sub(s);
    this.app.isGridMode && !y && v.snapToGrid(this.app.gridSize);
    const x = this.info.handle, _ = HD(x, Math.PI);
    if (this.app.snaps.clear(), (this.app.userDocumentSettings.isSnapMode ? !y : y) && f % cr === 0) {
      const { nudge: F } = this.app.snaps.snapResize({
        dragDelta: O.Sub(v, S),
        initialSelectionPageBounds: this.snapshot.initialSelectionPageBounds,
        handle: HD(x, f),
        isAspectRatioLocked: g,
        isResizingFromCenter: e
      });
      v.add(F);
    }
    const I = O.RotWith(
      e ? a.center : a.getHandlePoint(_),
      a.point,
      f
    ), D = O.Sub(v, I).rot(
      -f
    ), N = O.Sub(S, I).rot(
      -f
    ), j = O.DivV(D, N);
    Number.isFinite(j.x) || (j.x = 1), Number.isFinite(j.y) || (j.y = 1);
    const L = x === "top" || x === "bottom", z = x === "left" || x === "right";
    g ? z ? j.y = Math.abs(j.x) : L ? j.x = Math.abs(j.y) : Math.abs(j.x) > Math.abs(j.y) ? j.y = Math.abs(j.x) * (j.y < 0 ? -1 : 1) : j.x = Math.abs(j.y) * (j.x < 0 ? -1 : 1) : (L && (j.x = 1), z && (j.y = 1)), this.info.isCreating || this.updateCursor({
      dragHandle: x,
      isFlippedX: j.x < 0,
      isFlippedY: j.y < 0,
      rotation: f
    });
    for (const F of r.keys()) {
      const K = r.get(F);
      this.app.resizeShape(F, j, {
        initialBounds: K.bounds,
        dragHandle: x,
        initialPageTransform: K.pageTransform,
        initialShape: K.shape,
        mode: c.length === 1 && F === c[0] ? "resize_bounds" : "scale_shape",
        scaleOrigin: I,
        scaleAxisRotation: f
      });
    }
  }
  // ---
  updateCursor({
    dragHandle: e,
    isFlippedX: n,
    isFlippedY: r,
    rotation: a
  }) {
    const s = { ...this.app.cursor };
    switch (e) {
      case "top_left":
      case "bottom_right": {
        s.type = "nwse-resize", n !== r && (s.type = "nesw-resize");
        break;
      }
      case "top_right":
      case "bottom_left": {
        s.type = "nesw-resize", n !== r && (s.type = "nwse-resize");
        break;
      }
    }
    s.rotation = a, this.app.setCursor(s);
  }
  onExit = () => {
    this.app.snaps.clear();
  };
  _createSnapshot = () => {
    const {
      selectedIds: e,
      selectionRotation: n,
      inputs: { originPagePoint: r }
    } = this.app, a = this.app.selectionBounds, s = O.RotWith(
      a.getHandlePoint(this.info.handle),
      a.point,
      n
    ), c = O.Sub(r, s), f = /* @__PURE__ */ new Map();
    e.forEach((g) => {
      const y = this.app.getShapeById(g);
      if (y) {
        if (f.set(y.id, this._createShapeSnapshot(y)), y.type === "frame" && e.length === 1)
          return;
        this.app.visitDescendants(y.id, (v) => {
          const S = this.app.getShapeById(v);
          if (S && (f.set(S.id, this._createShapeSnapshot(S)), S.type === "frame"))
            return !1;
        });
      }
    });
    const p = ![...f.values()].some(
      (g) => !IL(g.pageRotation, n) || g.isAspectRatioLocked
    );
    return {
      shapeSnapshots: f,
      selectionBounds: a,
      cursorHandleOffset: c,
      selectionRotation: n,
      selectedIds: e,
      canShapesDeform: p,
      initialSelectionPageBounds: this.app.selectedPageBounds
    };
  };
  _createShapeSnapshot = (e) => {
    const n = this.app.getPageTransform(e), r = this.app.getShapeUtil(e);
    return {
      shape: e,
      bounds: r.bounds(e),
      pageTransform: n,
      pageRotation: De.Decompose(n).rotation,
      isAspectRatioLocked: r.isAspectRatioLocked(e)
    };
  };
}
const fk = [
  "top",
  "top_right",
  "right",
  "bottom_right",
  "bottom",
  "bottom_left",
  "left",
  "top_left"
];
function HD(t, e) {
  e = e % Wr;
  const n = Math.round(e / (Kr / 4)), r = fk.indexOf(t);
  return fk[(r + n) % fk.length];
}
class tre extends sn {
  static id = "rotating";
  snapshot = {};
  info = {};
  markId = "";
  onEnter = (e) => {
    this.info = e, this.markId = this.app.mark("rotate start"), this.snapshot = nj({ app: this.app }), this.handleStart();
  };
  onExit = () => {
    this.app.setCursor({ type: "none" }), this.snapshot = {};
  };
  onPointerMove = () => {
    this.update();
  };
  onKeyDown = () => {
    this.update();
  };
  onKeyUp = () => {
    this.update();
  };
  onPointerUp = () => {
    this.complete();
  };
  onComplete = () => {
    this.complete();
  };
  onCancel = () => {
    this.app.bailToMark(this.markId), this.parent.transition("idle", this.info);
  };
  // ---
  update = () => {
    const e = this._getRotationFromPointerPosition({
      snapToNearestDegree: !1
    });
    dx({
      app: this.app,
      delta: e,
      snapshot: this.snapshot,
      stage: "update"
    }), this.app.setCursor({
      type: zx[this.info.handle],
      rotation: e + this.snapshot.initialSelectionRotation
    });
  };
  complete = () => {
    dx({
      app: this.app,
      delta: this._getRotationFromPointerPosition({ snapToNearestDegree: !0 }),
      snapshot: this.snapshot,
      stage: "end"
    }), this.parent.transition("idle", this.info);
  };
  handleStart() {
    const e = this._getRotationFromPointerPosition({
      snapToNearestDegree: !1
    });
    dx({
      app: this.app,
      delta: this._getRotationFromPointerPosition({ snapToNearestDegree: !1 }),
      snapshot: this.snapshot,
      stage: "start"
    }), this.app.setCursor({
      type: zx[this.info.handle],
      rotation: e + this.snapshot.initialSelectionRotation
    });
  }
  _getRotationFromPointerPosition({ snapToNearestDegree: e }) {
    const {
      selectionPageCenter: n,
      inputs: { shiftKey: r, currentPagePoint: a }
    } = this.app, { initialCursorAngle: s, initialSelectionRotation: c } = this.snapshot, f = n.angle(a) - s;
    let p = c + f;
    if (r)
      p = Rx(p, 24);
    else if (e && (p = Math.round(p / KO) * KO, this.app.isCoarsePointer)) {
      const g = Rx(p, 4), y = kL(p, g);
      Math.abs(y) < Hq(5) && (p = g);
    }
    return p - c;
  }
}
class nre extends sn {
  static id = "scribble_brushing";
  static canActivateInReadOnly = !0;
  hits = /* @__PURE__ */ new Set();
  size = 0;
  scribble = {};
  initialSelectedIds = /* @__PURE__ */ new Set();
  newlySelectedIds = /* @__PURE__ */ new Set();
  onEnter = () => {
    this.initialSelectedIds = new Set(
      this.app.inputs.shiftKey ? this.app.selectedIds : []
    ), this.newlySelectedIds = /* @__PURE__ */ new Set(), this.size = 0, this.hits.clear(), this.startScribble(), this.updateBrushSelection(), requestAnimationFrame(() => {
      this.app.setBrush(null);
    });
  };
  onExit = () => {
    this.app.setErasingIds([]), this.scribble.stop();
  };
  onPointerMove = () => {
    this.updateBrushSelection();
  };
  onPointerUp = () => {
    this.complete();
  };
  onKeyDown = () => {
    this.updateBrushSelection();
  };
  onKeyUp = () => {
    this.app.inputs.altKey ? this.updateBrushSelection() : this.parent.transition("brushing", {});
  };
  startScribble = () => {
    this.scribble = new Aj({
      onUpdate: this.onScribbleUpdate,
      onComplete: this.onScribbleComplete,
      color: "selection-stroke",
      opacity: 0.32,
      size: 12
    }), this.app.on("tick", this.scribble.tick);
  };
  pushPointToScribble = () => {
    const { x: e, y: n } = this.app.inputs.currentPagePoint;
    this.scribble.addPoint(e, n);
  };
  onScribbleUpdate = (e) => {
    this.app.setScribble(e);
  };
  onScribbleComplete = () => {
    this.app.off("tick", this.scribble.tick), this.app.setScribble(null);
  };
  updateBrushSelection() {
    const {
      shapesArray: e,
      inputs: { originPagePoint: n, previousPagePoint: r, currentPagePoint: a }
    } = this.app;
    this.pushPointToScribble();
    const s = e;
    let c, f;
    for (let p = 0, g = s.length; p < g; p++)
      if (c = s[p], f = this.app.getShapeUtil(c), !(c.type === "group" || this.newlySelectedIds.has(c.id) || c.type === "frame" && f.hitTestPoint(c, this.app.getPointInShapeSpace(c, n))) && f.hitTestLineSegment(
        c,
        this.app.getPointInShapeSpace(c, r),
        this.app.getPointInShapeSpace(c, a)
      )) {
        const y = this.app.getOutermostSelectableShape(c), v = this.app.getPageMaskById(y.id);
        if (v && RI(
          r,
          a,
          v
        ) !== null && !Uu(a, v))
          continue;
        this.newlySelectedIds.add(y.id);
      }
    this.app.setSelectedIds(
      [.../* @__PURE__ */ new Set([...this.newlySelectedIds, ...this.initialSelectedIds])],
      !0
    );
  }
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.complete();
  };
  complete() {
    this.parent.transition("idle", {});
  }
  cancel() {
    this.app.setSelectedIds([...this.initialSelectedIds], !0), this.parent.transition("idle", {});
  }
}
class rre extends sn {
  static id = "select";
  static initial = "idle";
  static children = () => [
    Wne,
    Gne,
    Jne,
    Fne,
    Vne,
    nre,
    Zne,
    qne,
    Kne,
    ere,
    tre,
    Qne,
    Xne,
    Yne
  ];
  styles = ["color", "opacity", "dash", "fill", "size"];
  onExit = () => {
    this.app.pageState.editingId && this.app.setEditingId(null);
  };
}
class ire extends sn {
  static id = "idle";
  onPointerEnter = (e) => {
    switch (e.target) {
      case "canvas":
        break;
      case "shape": {
        const { selectedIds: n, focusLayerId: r } = this.app, a = this.app.getOutermostSelectableShape(
          e.shape,
          (s) => !n.includes(s.id)
        );
        a.id !== r && a.type === "text" && this.app.setHoveredId(a.id);
        break;
      }
    }
  };
  onPointerLeave = (e) => {
    switch (e.target) {
      case "shape": {
        this.app.setHoveredId(null);
        break;
      }
    }
  };
  onPointerDown = (e) => {
    const { hoveredId: n } = this.app;
    if (n) {
      const r = this.app.getShapeById(n);
      if (r.type === "text") {
        requestAnimationFrame(() => {
          this.app.setSelectedIds([r.id]), this.app.setEditingId(r.id), this.app.setSelectedTool("select.editing_shape", {
            ...e,
            target: "shape",
            shape: r
          });
        });
        return;
      }
    }
    this.parent.transition("pointing", e);
  };
  onEnter = () => {
    this.app.setCursor({ type: "cross" });
  };
  onKeyDown = (e) => {
    if (e.key === "Enter") {
      const n = this.app.selectedShapes[0];
      n && n.type === "geo" && (this.app.setSelectedTool("select"), this.app.setEditingId(n.id), this.app.root.current.value.transition("editing_shape", {
        ...e,
        target: "shape",
        shape: n
      }));
    }
  };
  onCancel = () => {
    this.app.setSelectedTool("select");
  };
}
class ore extends sn {
  static id = "pointing";
  shape;
  onExit = () => {
    this.app.setHintingIds([]);
  };
  onPointerMove = (e) => {
    if (this.app.inputs.isDragging) {
      const {
        inputs: { originPagePoint: n }
      } = this.app, r = io();
      if (this.app.mark("creating"), this.app.createShapes([
        {
          id: r,
          type: "text",
          x: n.x,
          y: n.y,
          props: {
            text: "",
            autoSize: !1,
            w: 20
          }
        }
      ]), this.app.select(r), this.shape = this.app.getShapeById(r), !this.shape)
        return;
      this.app.setSelectedTool("select.resizing", {
        ...e,
        target: "selection",
        handle: "right",
        isCreating: !0,
        creationCursorOffset: { x: 1, y: 1 },
        editAfterComplete: !0,
        onInteractionEnd: "text"
      });
    }
  };
  onPointerUp = () => {
    this.complete();
  };
  onComplete = () => {
    this.cancel();
  };
  onCancel = () => {
    this.cancel();
  };
  onInterrupt = () => {
    this.cancel();
  };
  complete() {
    this.app.mark("creating text shape");
    const e = io(), { x: n, y: r } = this.app.inputs.currentPagePoint;
    this.app.createShapes(
      [
        {
          id: e,
          type: "text",
          x: n,
          y: r,
          props: {
            text: "",
            autoSize: !0
          }
        }
      ],
      !0
    ), this.app.setEditingId(e), this.app.setSelectedTool("select"), this.app.root.current.value?.transition("editing_shape", {});
  }
  cancel() {
    this.parent.transition("idle", {}), this.app.bailToMark("creating");
  }
}
class are extends sn {
  static id = "text";
  static initial = "idle";
  static children = () => [ire, ore];
  styles = ["color", "opacity", "font", "align", "size"];
}
class sre extends sn {
  static id = "root";
  static initial = "select";
  static children = () => [
    rre,
    Dne,
    _ne,
    wne,
    are,
    jne,
    yne,
    $ne,
    Bne,
    Pne
  ];
}
var lre = Object.defineProperty, cre = Object.getOwnPropertyDescriptor, ln = (t, e, n, r) => {
  for (var a = r > 1 ? void 0 : r ? cre(e, n) : e, s = t.length - 1, c; s >= 0; s--)
    (c = t[s]) && (a = (r ? c(e, n, a) : c(a)) || a);
  return r && a && lre(e, n, a), a;
};
function ure(t) {
  return t.type === "arrow" || t.type === "line" || t.type === "draw";
}
const Oj = class extends iQ.EventEmitter {
  constructor({ config: t = kb.default, store: e, getContainer: n }) {
    if (super(), e.schema !== t.storeSchema)
      throw new Error("Store schema does not match schema given to App");
    this.config = t, this.store = e, this.getContainer = n ?? (() => document.body), this.textMeasure = new pne(this), this.shapeUtils = Object.fromEntries(
      t.shapes.map((r) => [
        r.type,
        r.createShapeUtils(this)
      ])
    ), typeof window < "u" && "navigator" in window ? (this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), this.isIos = !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPhone/i)) : (this.isSafari = !1, this.isIos = !1), this.colors = new Map(Oj.styles.color.map((r) => [r.id, `var(--palette-${r.id})`])), this.root = new sre(this), this.root.children && t.tools.forEach((r) => {
      this.root.children[r.id] = new r(this);
    }), this.store.onBeforeDelete = (r) => {
      r.typeName === "shape" ? this._shapeWillBeDeleted(r) : r.typeName === "page" && this._pageWillBeDeleted(r);
    }, this.store.onAfterChange = (r, a) => {
      this._updateDepth++, this._updateDepth > 1e3 && console.error("[onAfterChange] Maximum update depth exceeded, bailing out."), r.typeName === "shape" && a.typeName === "shape" ? this._shapeDidChange(r, a) : r.typeName === "instance_page_state" && a.typeName === "instance_page_state" && this._tabStateDidChange(r, a), this._updateDepth--;
    }, this.store.onAfterCreate = (r) => {
      r.typeName === "shape" && ro.is(r) && this._arrowDidUpdate(r);
    }, this._shapeIds = Zte(this.store, () => this.currentPageId), this._parentIdsToChildIds = Qte(this.store), this.disposables.add(
      this.store.listen((r) => {
        this.emit("change", r);
      })
    ), this.store.ensureStoreIsUsable(), this.root.enter(void 0, "initial"), this.updateCullingBounds(), requestAnimationFrame(() => {
      this._tickManager.start();
    });
  }
  /**
   * The editor's store
   *
   * @public
   */
  store;
  /**
   * The editor's config
   *
   * @public
   */
  config;
  /**
   * The root state of the statechart.
   *
   * @public
   */
  root;
  /**
   * A cache of shape ids in the current page.
   *
   * @internal
   */
  _shapeIds;
  /**
   * A set of functions to call when the app is disposed.
   *
   * @public
   */
  disposables = /* @__PURE__ */ new Set();
  /** @internal */
  _dprManager = new one(this);
  /** @internal */
  _cameraManager = new nne(this);
  /** @internal */
  _activeAreaManager = new ene(this);
  /** @internal */
  _tickManager = new hne(this);
  /** @internal */
  _updateDepth = 0;
  /**
   * A manager for the app's snapping feature.
   *
   * @public
   */
  snaps = new Pb(this);
  /**
   * Whether the editor is running in Safari.
   *
   * @public
   */
  isSafari;
  /**
   * Whether the editor is running on iOS.
   *
   * @public
   */
  isIos;
  // Flags
  _canMoveCamera = hi("can move camera", !0);
  get canMoveCamera() {
    return this._canMoveCamera.value;
  }
  set canMoveCamera(t) {
    this._canMoveCamera.set(t);
  }
  /**
   * The current HTML element containing the editor.
   *
   * @example
   * ```ts
   * const container = app.getContainer()
   * ```
   *
   * @public
   */
  getContainer;
  /**
   * The editor's userId (defined in its store.props).
   *
   * @example
   * ```ts
   * const userId = app.userId
   * ```
   *
   * @public
   */
  get userId() {
    return this.store.props.userId;
  }
  /**
   * The editor's instanceId (defined in its store.props).
   *
   * @example
   * ```ts
   * const instanceId = app.instanceId
   * ```
   *
   * @public
   */
  get instanceId() {
    return this.store.props.instanceId;
  }
  /** @internal */
  annotateError(t, {
    origin: e,
    willCrashApp: n,
    tags: r,
    extras: a
  }) {
    const s = this.createErrorAnnotations(e, n);
    pI(t, {
      tags: { ...s.tags, ...r },
      extras: { ...s.extras, ...a }
    }), n && this.store.markAsPossiblyCorrupted();
  }
  /** @internal */
  createErrorAnnotations(t, e) {
    try {
      return {
        tags: {
          origin: t,
          willCrashApp: e
        },
        extras: {
          activeStateNode: this.root.path.value,
          selectedShapes: this.selectedShapes,
          editingShape: this.editingId ? this.getShapeById(this.editingId) : void 0,
          inputs: this.inputs
        }
      };
    } catch {
      return {
        tags: {
          origin: t,
          willCrashApp: e
        },
        extras: {}
      };
    }
  }
  /** @internal */
  _crashingError = null;
  /**
   * we can't use an `atom` here because there's a chance that when
   * `crashAndReportError` is called, we're in a transaction that's about to
   * be rolled back due to the same error we're currently reporting.
   *
   * instead, to listen to changes to this value, you need to listen to app's
   * `crash` event.
   *
   * @internal
   */
  get crashingError() {
    return this._crashingError;
  }
  /** @internal */
  crash(t) {
    this._crashingError = t, this.store.markAsPossiblyCorrupted(), this.emit("crash");
  }
  get devicePixelRatio() {
    return this._dprManager.dpr.value;
  }
  /**
   * A set of strings representing any open menus or modals.
   *
   * @public
   */
  openMenus = /* @__PURE__ */ new Set();
  /**
   * Get whether any menus are open.
   *
   * @public
   */
  get isMenuOpen() {
    return this.openMenus.size > 0;
  }
  /** @internal */
  _isCoarsePointer = hi("isCoarsePointer", !1);
  /**
   * Whether the user is using a "coarse" pointer, such as on a touch screen.
   *
   * @public
   */
  get isCoarsePointer() {
    return this._isCoarsePointer.value;
  }
  set isCoarsePointer(t) {
    this._isCoarsePointer.set(t);
  }
  /** @internal */
  _isChangingStyle = hi("isChangingStyle", !1);
  /** @internal */
  _isChangingStyleTimeout = -1;
  /**
   * Whether the user is currently changing the style of a shape. This may cause the UI to change.
   *
   * @example
   * ```ts
   * app.isChangingStyle = true
   * ```
   *
   * @public
   */
  get isChangingStyle() {
    return this._isChangingStyle.value;
  }
  set isChangingStyle(t) {
    this._isChangingStyle.set(t), clearTimeout(this._isChangingStyleTimeout), t && (this._isChangingStyleTimeout = setTimeout(() => this.isChangingStyle = !1, 2e3));
  }
  get _pageTransformCache() {
    return this.store.createComputedCache("pageTransformCache", (t) => {
      if (fr.isId(t.parentId))
        return this.getTransform(t);
      const e = this._pageTransformCache.get(t.parentId);
      return De.Compose(e, this.getTransform(t));
    });
  }
  get _pageBoundsCache() {
    return this.store.createComputedCache("pageBoundsCache", (t) => {
      const e = this._pageTransformCache.get(t.id);
      return e ? ot.FromPoints(
        De.applyToPoints(e, this.getShapeUtil(t).outline(t))
      ) : new ot();
    });
  }
  get _pageMaskCache() {
    return this.store.createComputedCache("pageMaskCache", (t) => {
      if (fr.isId(t.parentId))
        return;
      const e = this.getAncestorsById(t.id).filter((r) => r.type === "frame");
      return e.length === 0 ? void 0 : e.map(
        (r) => (
          // Apply the frame transform to the frame outline to get the frame outline in page space
          De.applyToPoints(this._pageTransformCache.get(r.id), this.getOutline(r))
        )
      ).reduce((r, a) => a && r ? lP(r, a) ?? void 0 : void 0);
    });
  }
  /**
   * Get the page mask for a shape.
   *
   * @example
   * ```ts
   * const pageMask = app.getPageMaskById(shape.id)
   * ```
   *
   * @public
   *
   * @param id - The id of the shape to get the page mask for.
   *
   * @returns The page mask for the shape.
   */
  getPageMaskById(t) {
    return this._pageMaskCache.get(t);
  }
  get _clipPathCache() {
    return this.store.createComputedCache("clipPathCache", (t) => {
      const e = this._pageMaskCache.get(t.id);
      if (!e)
        return;
      const n = this._pageTransformCache.get(t.id);
      return n ? e.length === 0 ? "polygon(0px 0px, 0px 0px, 0px 0px)" : `polygon(${De.applyToPoints(De.Inverse(n), e).map((a) => `${a.x}px ${a.y}px`).join(",")})` : void 0;
    });
  }
  /**
   * Get the clip path for a shape.
   *
   * @example
   * ```ts
   * const clipPath = app.getClipPathById(shape.id)
   * ```
   *
   * @param id - The shape id.
   *
   * @returns The clip path or undefined.
   *
   * @public
   */
  getClipPathById(t) {
    return this._clipPathCache.get(t);
  }
  /**
   * A cache of parents to children.
   *
   * @internal
   */
  _parentIdsToChildIds;
  /**
   * Dispose the app.
   *
   * @public
   */
  dispose() {
    this.disposables.forEach((t) => t()), this.disposables.clear();
  }
  /**
   * A manager for the app's history.
   *
   * @readonly
   */
  history = new lne(
    this,
    () => this._complete(),
    (t) => {
      this.annotateError(t, { origin: "history.batch", willCrashApp: !0 }), this.crash(t);
    }
  );
  /**
   * Undo to the last mark.
   *
   * @example
   * ```ts
   * 	app.undo()
   * ```
   *
   * @public
   */
  undo() {
    return this.history.undo();
  }
  get canUndo() {
    return this.history.numUndos > 0;
  }
  /**
   * Redo to the next mark.
   *
   * @example
   * ```ts
   * 	app.redo()
   * ```
   *
   * @public
   */
  redo() {
    return this.history.redo(), this;
  }
  get canRedo() {
    return this.history.numRedos > 0;
  }
  /**
   * Create a new "mark", or stopping point, in the undo redo history. Creating a mark will clear
   * any redos.
   *
   * @example
   * ```ts
   * app.mark()
   * app.mark('flip shapes')
   * ```
   *
   * @param reason - The reason for the mark.
   * @param onUndo - Whether to stop at the mark when undoing.
   * @param onRedo - Whether to stop at the mark when redoing.
   * @public
   */
  mark(t, e, n) {
    return this.history.mark(t, e, n);
  }
  /**
   * Clear all marks in the undo stack back to the next mark.
   *
   * @example
   * ```ts
   * app.bail()
   * ```
   *
   * @public
   */
  bail() {
    return this.history.bail(), this;
  }
  /**
   * Clear all marks in the undo stack back to the mark with the provided mark id.
   *
   * @example
   * ```ts
   * app.bailToMark("creating")
   * ```
   *
   * @public
   */
  bailToMark(t) {
    return this.history.bailToMark(t), this;
  }
  /**
   * Run a function in a batch, which will be undone/redone as a single action.
   *
   * @example
   * ```ts
   * app.batch(() => {
   *   app.selectAll()
   *   app.deleteShapes()
   *   app.createShapes(myShapes)
   *   app.selectNone()
   * })
   *
   * app.undo() // will undo all of the above
   * ```
   *
   * @public
   */
  batch(t) {
    return this.history.batch(t), this;
  }
  /**
   * A map of shape utility classes (TLShapeUtils) by shape type.
   *
   * @public
   */
  shapeUtils;
  /**
   * Get a shape util for a given shape or shape type.
   *
   * @example
   * ```ts
   * 	app.getShapeUtil('geo')
   * ```
   * 	app.getShapeUtil(myBoxShape)
   *
   * @param type - The shape type.
   *
   * @public
   */
  getShapeUtil(t) {
    return this.shapeUtils[t.type];
  }
  /**
   * Get a shape util by its definition.
   *
   * @example
   * ```ts
   * app.getShapeUtilByDef(TLDrawShapeDef)
   * ```
   *
   * @param def - The shape definition.
   *
   * @public
   */
  getShapeUtilByDef(t) {
    return this.shapeUtils[t.type];
  }
  /**
   * A cache of children for each parent.
   *
   * @internal
   */
  _childIdsCache = new um();
  /**
   * Get an array of all the children of a shape.
   *
   * @example
   * ```ts
   * 	app.getSortedChildIds('frame1')
   * ```
   *
   * @param parentId - The id of the parent shape.
   * @public
   */
  getSortedChildIds(t) {
    const e = this._parentIdsToChildIds.value[t];
    return e ? this._childIdsCache.get(e, () => e.map(([n]) => n)) : Ws;
  }
  /**
   * Run a visitor function for all descendants of a shape.
   *
   * @example
   * ```ts
   * 	app.visitDescendants('frame1', myCallback)
   * ```
   *
   * @param parentId - The id of the parent shape.
   * @param visitor - The visitor function.
   * @public
   */
  visitDescendants(t, e) {
    const n = this.getSortedChildIds(t);
    for (const r of n)
      e(r) !== !1 && this.visitDescendants(r, e);
  }
  get erasingIds() {
    return this.pageState.erasingIds;
  }
  get hintingIds() {
    return this.pageState.hintingIds;
  }
  get erasingIdsSet() {
    return new Set(this.erasingIds);
  }
  /**
   * Get all the current props among the users selected shapes
   *
   * @internal
   */
  _extractSharedProps(t, e) {
    if (t.type === "group") {
      const n = this._parentIdsToChildIds.value[t.id];
      if (!n)
        return;
      for (let r = 0, a = n.length; r < a; r++)
        this._extractSharedProps(this.getShapeById(n[r][0]), e);
    } else {
      const n = Object.entries(t.props);
      let r;
      for (let a = 0, s = n.length; a < s; a++)
        switch (r = n[a], e[r[0]]) {
          case void 0: {
            e[r[0]] = r[1];
            break;
          }
          case null:
          case r[1]:
            continue;
          default:
            e[r[0]] = null;
        }
    }
  }
  /**
   * A derived object containing all current props among the user's selected shapes.
   *
   * @internal
   */
  _selectionSharedProps = pt("_selectionSharedProps", () => {
    const { selectedShapes: t } = this, e = {};
    for (let n = 0, r = t.length; n < r; n++)
      this._extractSharedProps(t[n], e);
    return e;
  });
  get allowUiPaste() {
    return !!navigator.clipboard && !!navigator.clipboard.read;
  }
  /** @internal */
  _prevProps = {};
  get props() {
    let t;
    if (this.isIn("select") && this.selectedIds.length > 0)
      t = this._selectionSharedProps.value;
    else {
      const e = this.root.current.value;
      if (e.styles.length === 0)
        t = null;
      else {
        const { propsForNextShape: n } = this.instanceState;
        t = Object.fromEntries(
          e.styles.map((r) => [r, n[r]])
        );
      }
    }
    return JSON.stringify(this._prevProps) === JSON.stringify(t) ? this._prevProps : (this._prevProps = t, t);
  }
  /**
   * An array of all of the shapes on the current page.
   *
   * @public
   */
  get shapeIds() {
    return this._shapeIds.value;
  }
  /**
   * _invalidParents is used to trigger the 'onChildrenChange' callback that shapes
   * can have.
   *
   * @internal
   */
  _invalidParents = /* @__PURE__ */ new Set();
  /** @internal */
  _complete() {
    const { lastUpdatedPageId: t, lastUsedTabId: e } = this.userDocumentSettings;
    (e !== this.instanceId || t !== this.currentPageId) && this.store.put([
      {
        ...this.userDocumentSettings,
        lastUsedTabId: this.instanceId,
        lastUpdatedPageId: this.currentPageId
      }
    ]);
    for (const n of this._invalidParents) {
      this._invalidParents.delete(n);
      const r = this.getShapeById(n);
      if (!r)
        continue;
      const s = this.getShapeUtil(r).onChildrenChange?.(r);
      s?.length && this.updateShapes(s, !0);
    }
    this.updateUserPresence(), this.emit("update");
  }
  get _arrowBindingsIndex() {
    return qte(this.store);
  }
  /**
   * getArrowsBoundTo
   */
  getArrowsBoundTo(t) {
    return this._arrowBindingsIndex.value[t] || Ws;
  }
  /** @internal */
  _reparentArrow(t) {
    const e = this.getShapeById(t);
    if (!e)
      return;
    const { start: n, end: r } = e.props, a = n.type === "binding" ? this.getShapeById(n.boundShapeId) : void 0, s = r.type === "binding" ? this.getShapeById(r.boundShapeId) : void 0, c = this.getParentPageId(e);
    if (!c)
      return;
    let f;
    if (a && s)
      f = this.findCommonAncestor([a, s]) ?? c;
    else if (a || s)
      f = c;
    else
      return;
    f && f !== e.parentId && this.reparentShapesById([t], f);
    const p = this.getShapeById(t), g = this.getNearestSiblingShape(p, a), y = this.getNearestSiblingShape(p, s);
    let v;
    if (g && y)
      v = g.index > y.index ? g : y;
    else if (g && !y)
      v = g;
    else if (y && !g)
      v = y;
    else
      return;
    let S;
    const x = this.getSortedChildIds(v.parentId).map((_) => this.getShapeById(_)).filter((_) => _.index > v.index);
    if (x.length) {
      const _ = x.find((T) => T.type !== "arrow");
      if (
        // ...then, if we're above the last shape we want to be above...
        p.index > v.index && // ...but below the next non-arrow sibling...
        (!_ || p.index < _.index)
      )
        return;
      S = Hy(v.index, x[0].index);
    } else
      S = Mu(v.index);
    S !== p.index && this.updateShapes([{ id: t, type: "arrow", index: S }]);
  }
  /** @internal */
  _unbindArrowTerminal(t, e) {
    const { x: n, y: r } = Ou(this, t)[e];
    this.store.put([{ ...t, props: { ...t.props, [e]: { type: "point", x: n, y: r } } }]);
  }
  // private _shapeWillUpdate = (prev: TLShape, next: TLShape) => {
  // 	const update = this.getShapeUtil(next).onUpdate?.(prev, next)
  // 	return update ?? next
  // }
  /** @internal */
  _shapeWillBeDeleted(t) {
    t.parentId && Fs(t.parentId) && this._invalidParents.add(t.parentId);
    const e = this._arrowBindingsIndex.value[t.id];
    if (e?.length)
      for (const { arrowId: s, handleId: c } of e) {
        const f = this.getShapeById(s);
        f && this._unbindArrowTerminal(f, c);
      }
    const n = this.store.query.records("instance_page_state").value, r = /* @__PURE__ */ new Set([t.id]), a = Gt(
      n.map((s) => this._cleanupInstancePageState(s, r))
    );
    a.length && this.store.put(a);
  }
  /** @internal */
  _arrowDidUpdate(t) {
    for (const e of ["start", "end"]) {
      const n = t.props[e];
      if (n.type !== "binding")
        continue;
      const r = this.getShapeById(n.boundShapeId), a = this.getParentPageId(t) === this.getParentPageId(r);
      (!r || !a) && this._unbindArrowTerminal(t, e);
    }
    this._reparentArrow(t.id);
  }
  /** @internal */
  _cleanupInstancePageState(t, e) {
    let n = null;
    const r = t.selectedIds.filter((c) => !e.has(c));
    r.length !== t.selectedIds.length && (n || (n = { ...t }), n.selectedIds = r);
    const a = t.erasingIds.filter((c) => !e.has(c));
    a.length !== t.erasingIds.length && (n || (n = { ...t }), n.erasingIds = a), t.hoveredId && e.has(t.hoveredId) && (n || (n = { ...t }), n.hoveredId = null), t.editingId && e.has(t.editingId) && (n || (n = { ...t }), n.editingId = null);
    const s = t.hintingIds.filter((c) => !e.has(c));
    return s.length !== t.hintingIds.length && (n || (n = { ...t }), n.hintingIds = s), t.focusLayerId && e.has(t.focusLayerId) && (n || (n = { ...t }), n.focusLayerId = null), n;
  }
  /** @internal */
  _shapeDidChange(t, e) {
    if (ro.is(e) && this._arrowDidUpdate(e), t.parentId !== e.parentId) {
      const n = (r) => {
        const a = this._arrowBindingsIndex.value[r];
        if (a?.length)
          for (const s of a)
            this._reparentArrow(s.arrowId);
      };
      n(e.id), this.visitDescendants(e.id, n);
    }
    if (t.parentId !== e.parentId && fr.isId(e.parentId)) {
      const n = /* @__PURE__ */ new Set([t.id]);
      this.visitDescendants(t.id, (r) => {
        n.add(r);
      });
      for (const r of this.store.query.records("instance_page_state").value) {
        if (r.pageId === e.parentId)
          continue;
        const a = this._cleanupInstancePageState(r, n);
        a && this.store.put([a]);
      }
    }
    t.parentId && Fs(t.parentId) && this._invalidParents.add(t.parentId), e.parentId !== t.parentId && Fs(e.parentId) && this._invalidParents.add(e.parentId);
  }
  /** @internal */
  _tabStateDidChange(t, e) {
    if (t?.selectedIds !== e?.selectedIds) {
      const n = e.selectedIds.filter((a) => {
        let s = this.getShapeById(a)?.parentId;
        for (; Fs(s); ) {
          if (e.selectedIds.includes(s))
            return !1;
          s = this.getShapeById(s)?.parentId;
        }
        return !0;
      }), r = n.length === 0 ? e?.focusLayerId : this.findCommonAncestor(
        Gt(n.map((a) => this.getShapeById(a))),
        (a) => a.type === "group"
      );
      (n.length !== e.selectedIds.length || r != e.focusLayerId) && this.store.put([{ ...e, selectedIds: n, focusLayerId: r ?? null }]);
    }
  }
  /** @internal */
  _pageWillBeDeleted(t) {
    const e = this.store.query.exec("instance", { currentPageId: { eq: t.id } });
    if (!e.length)
      return;
    const n = this.pages.find((r) => r.id !== t.id)?.id;
    n && this.store.put(e.map((r) => ({ ...r, currentPageId: n })));
  }
  get documentSettings() {
    return this.store.get(Ix);
  }
  get gridSize() {
    return this.documentSettings.gridSize;
  }
  /**
   * The user's global settings.
   *
   * @public
   * @readonly
   */
  get userSettings() {
    return this.store.get(this.userId);
  }
  get _userDocumentSettings() {
    return this.store.query.record("user_document", () => ({ userId: { eq: this.userId } }));
  }
  get userDocumentSettings() {
    return this._userDocumentSettings.value;
  }
  get isReadOnly() {
    return this.userDocumentSettings.isReadOnly;
  }
  get isGridMode() {
    return this.userDocumentSettings.isGridMode;
  }
  setGridMode(t) {
    this.updateUserDocumentSettings({ isGridMode: t }, !0);
  }
  setDarkMode(t) {
    this.updateUserDocumentSettings({ isDarkMode: t }, !0);
  }
  //** @public */
  enableReadOnlyMode() {
    this.updateUserDocumentSettings({ isReadOnly: !0 }), this.setSelectedTool("hand");
  }
  /** @internal */
  _isPenMode = hi("isPenMode", !1);
  /** @internal */
  _touchEventsRemainingBeforeExitingPenMode = 0;
  get isPenMode() {
    return this._isPenMode.value;
  }
  setPenMode(t) {
    t && (this._touchEventsRemainingBeforeExitingPenMode = 3), this._isPenMode.set(t);
  }
  // User / User App State
  /**
   * The current user state.
   *
   * @public
   */
  get user() {
    return this.store.get(this.userId);
  }
  /** The current tab state */
  get instanceState() {
    return this.store.get(this.instanceId);
  }
  get cursor() {
    return this.instanceState.cursor;
  }
  get brush() {
    return this.instanceState.brush;
  }
  get scribble() {
    return this.instanceState.scribble;
  }
  get _pageState() {
    return this.store.query.record(
      "instance_page_state",
      () => ({
        pageId: { eq: this.currentPageId },
        instanceId: { eq: this.instanceId }
      }),
      "app._pageState"
    );
  }
  /**
   * The current page state.
   *
   * @public
   */
  get pageState() {
    return this._pageState.value;
  }
  get camera() {
    return this.store.get(this.pageState.cameraId);
  }
  get zoomLevel() {
    return this.camera.z;
  }
  get selectedIds() {
    return this.pageState.selectedIds;
  }
  get selectedIdsSet() {
    return new Set(this.selectedIds);
  }
  get _pages() {
    return this.store.query.records("page");
  }
  get pages() {
    return this._pages.value.sort(Ya);
  }
  /**
   * The current page.
   *
   * @public
   */
  get currentPage() {
    return this.getPageById(this.currentPageId);
  }
  /**
   * The current page id.
   *
   * @public
   */
  get currentPageId() {
    return this.instanceState.currentPageId;
  }
  /**
   * Get a page by its ID.
   *
   * @example
   * ```ts
   * 	app.getPageById(myPage.id)
   * ```
   *
   * @public
   */
  getPageById(t) {
    return this.store.get(t);
  }
  get _pageStates() {
    return this.store.query.records("instance_page_state", () => ({
      instanceId: { eq: this.instanceId }
    }));
  }
  /**
   * Get a page state by its id.
   *
   * @example
   * ```ts
   * 	app.getPageStateByPageId('page1')
   * ```
   *
   * @public
   */
  getPageStateByPageId(t) {
    return this._pageStates.value.find((e) => e.pageId === t);
  }
  /**
   * Get a page by its ID.
   *
   * @example
   * ```ts
   * 	app.getPageById(myPage.id)
   * ```
   *
   * @public
   */
  getPageInfoById(t) {
    return this.store.get(t);
  }
  /**
   * Get shapes on a page.
   */
  getShapesInPage(t) {
    const e = this.store.query.exec("shape", { parentId: { eq: t } });
    return this.getShapesAndDescendantsInOrder(e.map((n) => n.id));
  }
  /* --------------------- Shapes --------------------- */
  /**
   * Get the local transform for a shape as a matrix model. This transform reflects both its
   * translation (x, y) from from either its parent's top left corner, if the shape's parent is
   * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the
   * shape's rotation.
   *
   * @example
   * ```ts
   * 	app.getTransform(myShape)
   * ```
   *
   * @param shape - The shape to get the local transform for.
   * @public
   */
  getTransform(t) {
    return this.getShapeUtil(t).transform(t);
  }
  /**
   * Get the local transform of a shape's parent as a matrix model.
   *
   * @example
   * ```ts
   * 	app.getParentTransform(myShape)
   * ```
   *
   * @param shape - The shape to get the parent transform for.
   * @public
   */
  getParentTransform(t) {
    return fr.isId(t.parentId) ? De.Identity() : this._pageTransformCache.get(t.parentId) ?? De.Identity();
  }
  /**
   * Get the page transform (or absolute transform) of a shape.
   *
   * @example
   * ```ts
   * 	app.getPageTransform(myShape)
   * ```
   *
   * @param shape - The shape to get the page transform for.
   * @public
   */
  getPageTransform(t) {
    return this.getPageTransformById(t.id);
  }
  /**
   * Get the page transform (or absolute transform) of a shape by its id.
   *
   * @example
   * ```ts
   * 	app.getPageTransformById(myShape)
   * ```
   *
   * @param id - The if of the shape to get the page transform for.
   * @public
   */
  getPageTransformById(t) {
    return this._pageTransformCache.get(t);
  }
  /**
   * Get the page point (or absolute point) of a shape.
   *
   * @example
   * ```ts
   * 	app.getPagePoint(myShape)
   * ```
   *
   * @param shape - The shape to get the page point for.
   * @public
   */
  getPagePointById(t) {
    const e = this.getPageTransformById(t);
    if (e)
      return De.applyToPoint(e, new O());
  }
  /**
   * Get the page point (or absolute point) of a shape.
   *
   * @example
   * ```ts
   * 	app.getPagePoint(myShape)
   * ```
   *
   * @param shape - The shape to get the page point for.
   * @public
   */
  getPageCenter(t) {
    const e = this.getPageTransformById(t.id);
    if (!e)
      return null;
    const r = this.getShapeUtil(t).center(t);
    return De.applyToPoint(e, r);
  }
  /**
   * Get the page point (or absolute point) of a shape by its id.
   *
   * @example
   * ```ts
   * 	app.getPagePoint(myShape)
   * ```
   *
   * @param id - The shape id to get the page point for.
   * @public
   */
  getPageCenterById(t) {
    const e = this.getShapeById(t);
    return this.getPageCenter(e);
  }
  /**
   * Get the page rotation (or absolute rotation) of a shape.
   *
   * @example
   * ```ts
   * 	app.getPageRotation(myShape)
   * ```
   *
   * @param shape - The shape to get the page rotation for.
   * @public
   */
  getPageRotation(t) {
    return this.getPageRotationById(t.id);
  }
  /**
   * Get the page rotation (or absolute rotation) of a shape by its id.
   *
   * @param id - The id of the shape to get the page rotation for.
   */
  getPageRotationById(t) {
    const e = this.getPageTransformById(t);
    return e ? De.Decompose(e).rotation : 0;
  }
  /**
   * Get the local bounds of a shape.
   *
   * @example
   * ```ts
   * 	app.getBounds(myShape)
   * ```
   *
   * @param shape - The shape to get the bounds for.
   * @public
   */
  getBounds(t) {
    return this.getShapeUtil(t).bounds(t);
  }
  /**
   * Get the local bounds of a shape by its id.
   *
   * @example
   * ```ts
   * 	app.getBoundsById(myShape)
   * ```
   *
   * @param id - The id of the shape to get the bounds for.
   * @public
   */
  getBoundsById(t) {
    const e = this.getShapeById(t);
    if (e)
      return this.getBounds(e);
  }
  /**
   * Get the page (or absolute) bounds of a shape.
   *
   * @example
   * ```ts
   * 	app.getPageBounds(myShape)
   * ```
   *
   * @param shape - The shape to get the bounds for.
   * @public
   */
  getPageBounds(t) {
    return this.getPageBoundsById(t.id);
  }
  /**
   * Get the page (or absolute) bounds of a shape by its id.
   *
   * @example
   * ```ts
   * 	app.getPageBoundsById(myShape)
   * ```
   *
   * @param id - The id of the shape to get the page bounds for.
   * @public
   */
  getPageBoundsById(t) {
    return this._pageBoundsCache.get(t);
  }
  /**
   * Get the page (or absolute) bounds of a shape, incorporating any masks.
   * For example, if the shape were the child of a frame and was half way out of the frame,
   * the bounds would be the half of the shape that was in the frame.
   *
   * @example
   * ```ts
   * 	app.getMaskedPageBounds(myShape)
   * ```
   *
   * @param shape - The shape to get the masked bounds for.
   * @public
   */
  getMaskedPageBounds(t) {
    return this.getMaskedPageBoundsById(t.id);
  }
  /**
   * Get the page (or absolute) bounds of a shape by its id, incorporating any masks.
   * For example, if the shape were the child of a frame and was half way out of the frame,
   * the bounds would be the half of the shape that was in the frame.
   *
   * @example
   * ```ts
   * 	app.getMaskedPageBoundsById(myShape)
   * ```
   *
   * @param id - The id of the shape to get the masked page bounds for.
   * @public
   */
  getMaskedPageBoundsById(t) {
    const e = this._pageBoundsCache.get(t);
    if (!e)
      return;
    const n = this._pageMaskCache.get(t);
    if (n) {
      const r = lP(n, e.corners);
      return r ? ot.FromPoints(r) : void 0;
    }
    return e;
  }
  /**
   * Get the local outline of a shape.
   *
   * @example
   * ```ts
   * 	app.getOutline(myShape)
   * ```
   *
   * @param shape - The shape to get the outline for.
   * @public
   */
  getOutline(t) {
    return this.getShapeUtil(t).outline(t);
  }
  /**
   * Get the local outline of a shape.
   *
   * @example
   * ```ts
   * 	app.getOutlineById(myShape)
   * ```
   *
   * @param id - The shape id to get the outline for.
   * @public
   */
  getOutlineById(t) {
    return this.getOutline(this.getShapeById(t));
  }
  /**
   * Get the ancestors of a shape.
   *
   * @example
   * ```ts
   * 	const ancestors = app.getAncestors(myShape)
   * ```
   *
   * @param shape - The shape to get the ancestors for.
   * @public
   */
  getAncestors(t, e = []) {
    const n = t.parentId;
    if (fr.isId(n))
      return e.reverse(), e;
    const r = this.store.get(n);
    return e.push(r), this.getAncestors(r, e);
  }
  /**
   * Get the ancestors of a shape by its id.
   *
   * @example
   * ```ts
   * 	const ancestors = app.getAncestorsById(myShape)
   * ```
   *
   * @param id - The id of the shape to get the ancestors for.
   * @public
   */
  getAncestorsById(t, e = []) {
    const n = this.getShapeById(t);
    return this.getAncestors(n, e);
  }
  /**
   * Find the first ancestor matching the given predicate
   *
   * @example
   * ```ts
   * 	const ancestor = app.findAncestor(myShape)
   * ```
   *
   * @param shape - The shape to check the ancestors for.
   * @public
   */
  findAncestor(t, e) {
    const n = t.parentId;
    if (fr.isId(n))
      return;
    const r = this.getShapeById(n);
    if (r)
      return e(r) ? r : this.findAncestor(r, e);
  }
  /**
   * Returns true if the the given shape has the given ancestor
   *
   */
  hasAncestor(t, e) {
    return t ? t.parentId === e ? !0 : this.hasAncestor(this.getParentShape(t), e) : !1;
  }
  /**
   * Get the common ancestor of two or more shapes that matches a predicate.
   *
   * @param shapes - The shapes to check.
   * @param predicate - The predicate to match.
   */
  findCommonAncestor(t, e) {
    if (t.length === 0)
      return;
    if (t.length === 1) {
      const s = t[0].parentId;
      return fr.isId(s) ? void 0 : e ? this.findAncestor(t[0], e)?.id : s;
    }
    const [n, ...r] = t;
    let a = this.getParentShape(n);
    for (; a; ) {
      if (e && !e(a)) {
        a = this.getParentShape(a);
        continue;
      }
      if (r.every((s) => this.hasAncestor(s, a.id)))
        return a.id;
      a = this.getParentShape(a);
    }
  }
  /**
   * Check whether a shape is within the bounds of the current viewport.
   *
   * @param id - The id of the shape to check.
   *
   * @public
   */
  isShapeInViewport(t) {
    const e = this.getPageBoundsById(t);
    return e ? this.viewportPageBounds.includes(e) : !1;
  }
  get renderingShapes() {
    const { currentPageId: t, cullingBounds: e, cullingBoundsExpanded: n, erasingIdsSet: r, editingId: a } = this, s = [], c = (f, p, g) => {
      const y = this.getShapeById(f);
      if (!y)
        return;
      let v = +y.props.opacity * p, S = !1;
      !g && r.has(f) && (S = !0, v *= 0.32);
      const x = this.getMaskedPageBoundsById(f), _ = x ? e.includes(x) : !1, T = x ? a !== f && !n.includes(x) : !0;
      s.push({ id: f, index: s.length, opacity: v, isCulled: T, isInViewport: _ }), this.getSortedChildIds(f).forEach((I) => {
        c(I, v, g || S);
      });
    };
    return this.getSortedChildIds(t).forEach((f) => c(f, 1, !1)), s.sort(jZ);
  }
  get allShapesCommonBounds() {
    let t = null;
    return this.shapeIds.forEach((e) => {
      const n = this.getMaskedPageBoundsById(e);
      n && (t ? t.expand(n) : t = n.clone());
    }), t;
  }
  /**
   * Get the corners of a shape in page space.
   *
   * @example
   * ```ts
   * 	const corners = app.getPageCorners(myShape)
   * ```
   *
   * @param shape - The shape to get the corners for.
   * @public
   */
  getPageCorners(t) {
    const e = this.getAncestors(t), n = this.getBounds(t).corners, r = De.Compose(
      ...e.flatMap((a) => [De.Translate(a.x, a.y), De.Rotate(a.rotation)]),
      De.Translate(t.x, t.y),
      De.Rotate(t.rotation, 0, 0)
    );
    return De.applyToPoints(r, n);
  }
  /**
   * Test whether a point (in page space) will will a shape. This method takes into
   * account masks, such as when a shape is the child of a frame and is partially
   * clipped by the frame.
   *
   * @example
   * ```ts
   * 	app.isPointInShape({ x: 100, y: 100 }, myShape)
   * ```
   *
   * @param point - The page point to test.
   * @param shape - The shape to test against.
   * @public
   */
  isPointInShape(t, e) {
    const n = this.getShapeUtil(e), r = this._pageMaskCache.get(e.id);
    return r && !Uu(t, r) ? !1 : n.hitTestPoint(e, this.getPointInShapeSpace(e, t));
  }
  /**
   * Get the shapes, if any, at a given page point.
   *
   * @example
   * ```ts
   * 	app.getShapesAtPoint({ x: 100, y: 100 })
   * ```
   *
   * @param point - The page point to test.
   * @public
   */
  getShapesAtPoint(t) {
    return this.sortedShapesArray.filter((e) => {
      const n = this._pageMaskCache.get(e.id);
      return n && !Uu(t, n) ? !1 : this.getShapeUtil(e).hitTestPoint(e, this.getPointInShapeSpace(e, t));
    });
  }
  /**
   * Convert a point in page space to a point in the local space of a shape. For example, if a
   * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
   * `{ x: 10, y: 10 }` in the shape's local space.
   *
   * @example
   * ```ts
   * 	app.getPointInShapeSpace(myShape, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   * @public
   */
  getPointInShapeSpace(t, e) {
    return De.applyToPoint(De.Inverse(this.getPageTransform(t)), e);
  }
  /**
   * Convert a delta in page space to a point in the local space of a shape. For example, if a
   * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
   * `{ x: 10, y: 10 }` in the shape's local space.
   *
   * @example
   * ```ts
   * 	app.getPointInShapeSpace(myShape.id, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   * @public
   */
  getPointInParentSpace(t, e) {
    const n = this.getShapeById(t);
    if (!n)
      return new O(0, 0);
    if (fr.isId(n.parentId))
      return O.From(e);
    const r = this.getPageTransformById(n.parentId);
    return r ? De.applyToPoint(De.Inverse(r), e) : O.From(e);
  }
  /**
   * Convert a delta in page space to a delta in the local space of a shape.
   *
   * @example
   * ```ts
   * 	app.getDeltaInShapeSpace(myShape, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the delta in the local space of.
   * @param delta - The page delta to convert.
   * @public
   */
  getDeltaInShapeSpace(t, e) {
    const n = this.getPageTransform(t);
    return n ? O.Rot(e, -De.Decompose(n).rotation) : O.From(e);
  }
  /**
   * Convert a delta in page space to a delta in the parent space of a shape.
   *
   * @example
   * ```ts
   * 	app.getDeltaInParentSpace(myShape, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the delta in the parent space of.
   * @param delta - The page delta to convert.
   * @public
   */
  getDeltaInParentSpace(t, e) {
    if (fr.isId(t.parentId))
      return O.From(e);
    const n = this.getShapeById(t.parentId);
    return n ? this.getDeltaInShapeSpace(n, e) : O.From(e);
  }
  /**
   * For a given set of ids, get a map containing the ids of their parents and the children of those
   * parents.
   *
   * @example
   * ```ts
   * 	app.getParentsMappedToChildren(['id1', 'id2', 'id3'])
   * ```
   *
   * @param ids - The ids to get the parents and children of.
   * @public
   */
  getParentsMappedToChildren(t) {
    const e = t.map((r) => this.store.get(r)), n = /* @__PURE__ */ new Map();
    return e.forEach((r) => {
      n.has(r.parentId) || n.set(r.parentId, /* @__PURE__ */ new Set()), n.get(r.parentId)?.add(r);
    }), n;
  }
  /* -------------------- Viewport -------------------- */
  /**
   * Update the viewport. The viewport will measure the size and
   * screen position of its container element. This should be done whenever
   * the container's position on the screen changes.
   *
   * @example
   * ```ts
   * 	app.updateViewportScreenBounds()
   * ```
   *
   * @param center - Whether to preserve the viewport page center as the viewport changes. (optional)
   *
   * @public
   */
  updateViewportScreenBounds(t = !1) {
    const e = this.getContainer();
    if (!e)
      return this;
    const n = e.getBoundingClientRect(), r = new ot(0, 0, Math.max(n.width, 1), Math.max(n.height, 1)), a = r.equals(this.viewportScreenBounds), { _willSetInitialBounds: s } = this;
    if (a)
      this._willSetInitialBounds = !1;
    else if (s)
      this._willSetInitialBounds = !1, this.updateInstanceState({ screenBounds: r.toJson() }, !0, !0);
    else {
      const { zoomLevel: f } = this;
      if (t) {
        const p = this.viewportPageCenter;
        this.updateInstanceState({ screenBounds: r.toJson() }, !0, !0);
        const g = this.viewportPageCenter;
        this.pan((g.x - p.x) * f, (g.y - p.y) * f);
      } else {
        const p = this.screenToPage(0, 0);
        this.updateInstanceState({ screenBounds: r.toJson() }, !0, !0);
        const g = this.screenToPage(0, 0);
        this.pan((g.x - p.x) * f, (g.y - p.y) * f);
      }
    }
    this._cameraManager.tick(), this.updateCullingBounds();
    const { editingId: c } = this;
    return c && this.panZoomIntoView([c]), this;
  }
  get viewportScreenBounds() {
    const { x: t, y: e, w: n, h: r } = this.instanceState.screenBounds;
    return new ot(t, e, n, r);
  }
  get viewportScreenCenter() {
    return this.viewportScreenBounds.center;
  }
  get viewportPageBounds() {
    const { x: t, y: e, w: n, h: r } = this.viewportScreenBounds, a = this.screenToPage(t, e), s = this.screenToPage(t + n, e + r);
    return new ot(a.x, a.y, s.x - a.x, s.y - a.y);
  }
  get cullingBounds() {
    return this._cullingBounds.value;
  }
  /** @internal */
  _cullingBounds = hi("culling viewport", new ot());
  get cullingBoundsExpanded() {
    return this._cullingBoundsExpanded.value;
  }
  /** @internal */
  _cullingBoundsExpanded = hi("culling viewport expanded", new ot());
  /**
   * Update the culling bounds. This should be called when the viewport has stopped changing, such as at the end of a pan, zoom, or animation.
   *
   * @example
   * ```ts
   * 	app.updateCullingBounds()
   * ```
   *
   * @internal
   */
  updateCullingBounds() {
    const { viewportPageBounds: t } = this;
    return t.equals(this._cullingBounds.__unsafe__getWithoutCapture()) ? this : (this._cullingBounds.set(t.clone()), this._cullingBoundsExpanded.set(t.clone().expandBy(100 / this.zoomLevel)), this);
  }
  get viewportPageCenter() {
    return this.viewportPageBounds.center;
  }
  /**
   * Convert a point in screen space to a point in page space.
   *
   * @example
   * ```ts
   * 	app.screenToPage(100, 100)
   * ```
   *
   * @param x - The x coordinate of the point in screen space.
   * @param y - The y coordinate of the point in screen space.
   * @param camera - The camera to use. Defaults to the current camera.
   * @public
   */
  screenToPage(t, e, n = 0.5, r = this.camera) {
    const { screenBounds: a } = this.store.unsafeGetWithoutCapture(this.instanceId), { x: s, y: c, z: f = 1 } = r;
    return {
      x: (t - a.x) / f - s,
      y: (e - a.y) / f - c,
      z: n
    };
  }
  /**
   * Convert a point in page space to a point in screen space.
   *
   * @example
   * ```ts
   * 	app.pageToScreen(100, 100)
   * ```
   *
   * @param x - The x coordinate of the point in screen space.
   * @param y - The y coordinate of the point in screen space.
   * @param camera - The camera to use. Defaults to the current camera.
   * @public
   */
  pageToScreen(t, e, n = 0.5, r = this.camera) {
    const { x: a, y: s, z: c = 1 } = r;
    return {
      x: t + a * c,
      y: e + s * c,
      z: n
    };
  }
  /* Focus Layers */
  get focusLayerId() {
    return this.pageState.focusLayerId ?? this.currentPageId;
  }
  get focusLayerShape() {
    const t = this.pageState.focusLayerId;
    if (t)
      return this.getShapeById(t);
  }
  popFocusLayer() {
    const t = this.pageState.focusLayerId, e = t && this.getShapeById(t);
    if (e) {
      const n = this.findAncestor(e, (r) => r.type === "group");
      this.setFocusLayer(n?.id ?? null), this.select(e.id);
    } else
      this.setFocusLayer(null), this.selectNone();
    return this;
  }
  /**
   * Set the focus layer to the given shape id.
   *
   * @param next - The next focus layer id or null to reset the focus layer to the page
   *
   * @public
   */
  setFocusLayer(t) {
    return this._setFocusLayer(t), this;
  }
  /** @internal */
  _setFocusLayer = this.history.createCommand(
    "setFocusLayer",
    (t) => t === null && !this.canUndo ? void 0 : { data: { prev: this.pageState.focusLayerId, next: t }, preservesRedoStack: !0, squashing: !0 },
    {
      do: ({ next: t }) => {
        this.store.update(this.pageState.id, (e) => ({ ...e, focusLayerId: t }));
      },
      undo: ({ prev: t }) => {
        this.store.update(this.pageState.id, (e) => ({ ...e, focusLayerId: t }));
      },
      squash({ prev: t }, { next: e }) {
        return { prev: t, next: e };
      }
    }
  );
  /**
   * Set the hinted shape ids.
   *
   * @param ids - The ids to set as hinted.
   *
   * @public
   */
  setHintingIds(t) {
    return this.store.update(this.pageState.id, (e) => ({ ...e, hintingIds: xx(t) })), this;
  }
  /**
   * The current editing shape's id.
   *
   * @public
   */
  get editingId() {
    return this.pageState.editingId;
  }
  get editingShape() {
    return this.editingId ? this.getShapeById(this.editingId) ?? null : null;
  }
  /**
   * Set the current editing id.
   *
   * @param id - The id of the shape to edit or null to clear the editing id.
   *
   * @public
   */
  setEditingId(t) {
    if (!t)
      this.setInstancePageState({ editingId: null });
    else if (t !== this.editingId) {
      const e = this.getShapeById(t), n = this.getShapeUtil(e);
      if (e && n.canEdit(e)) {
        this.setInstancePageState({ editingId: t, hoveredId: null }, !1);
        const { viewportPageBounds: r } = this, a = n.getEditingBounds(e), s = this.getPageTransformById(t), c = ot.FromPoints(
          De.applyToPoints(s, a.corners)
        );
        r.contains(c) || (c.width > r.width || c.height > r.height ? this.zoomToBounds(
          c.minX,
          c.minY,
          c.width,
          c.height
        ) : this.centerOnPoint(c.midX, c.midY));
      }
    }
    return this;
  }
  getParentIdForNewShapeAtPoint(t, e) {
    const n = this.sortedShapesArray;
    for (let r = n.length - 1; r >= 0; r--) {
      const a = n[r], s = this.getShapeUtil(a);
      if (!s.canReceiveNewChildrenOfType(e))
        continue;
      const c = this.getMaskedPageBoundsById(a.id);
      if (c && c.containsPoint(t) && s.hitTestPoint(a, this.getPointInShapeSpace(a, t)))
        return a.id;
    }
    return this.focusLayerId;
  }
  getDroppingShape(t, e = []) {
    const n = this.sortedShapesArray;
    for (let r = n.length - 1; r >= 0; r--) {
      const a = n[r];
      if (e.find((f) => f.id === a.id || this.hasAncestor(a, f.id)))
        continue;
      const s = this.getShapeUtil(a);
      if (!s.canDropShapes(a, e))
        continue;
      const c = this.getMaskedPageBoundsById(a.id);
      if (c && c.containsPoint(t) && s.hitTestPoint(a, this.getPointInShapeSpace(a, t)))
        return a;
    }
  }
  // This returns the node that should be selected when you click on this one, assuming there is nothing
  // already selected. It will not return anything higher than or including the current focus layer.
  getOutermostSelectableShape(t, e) {
    let n = t, r = t;
    for (; r; ) {
      if (r.type === "group" && this.focusLayerId !== r.id && !this.hasAncestor(this.focusLayerShape, r.id) && (e?.(r) ?? !0))
        n = r;
      else if (this.focusLayerId === r.id)
        break;
      r = this.getParentShape(r);
    }
    return n;
  }
  /* --------------------- Shapes --------------------- */
  /**
   * The app's set of styles.
   *
   * @public
   */
  static styles = Lw;
  get selectedPageBounds() {
    const {
      pageState: { selectedIds: t }
    } = this;
    return t.length === 0 ? null : ot.Common(Gt(t.map((e) => this.getPageBoundsById(e))));
  }
  get selectionRotation() {
    const { selectedIds: t } = this;
    if (t.length === 0)
      return 0;
    if (t.length === 1)
      return this.getPageRotationById(this.selectedIds[0]);
    const e = t.map((n) => this.getPageRotationById(n) % (Math.PI / 2));
    return e.every((n) => Math.abs(n - e[0]) < Math.PI / 180) ? this.getPageRotationById(t[0]) : 0;
  }
  get selectionBounds() {
    const { selectedIds: t } = this;
    if (t.length === 0)
      return;
    const { selectionRotation: e } = this;
    if (e === 0)
      return this.selectedPageBounds;
    if (t.length === 1) {
      const a = this.getBounds(this.getShapeById(t[0])).clone();
      return a.point = De.applyToPoint(this.getPageTransformById(t[0]), a.point), a;
    }
    const n = this.selectedIds.flatMap((a) => {
      const s = this.getPageTransformById(a);
      return s ? this.getOutlineById(a).map((c) => De.applyToPoint(s, c)) : [];
    }).map((a) => O.Rot(a, -e)), r = ot.FromPoints(n);
    return r.point = r.point.rot(e), r;
  }
  get selectionPageCenter() {
    const { selectionBounds: t, selectionRotation: e } = this;
    return t ? O.RotWith(t.center, t.point, e) : null;
  }
  get shapesArray() {
    return Array.from(this.shapeIds).map((t) => this.store.get(t));
  }
  get sortedShapesArray() {
    const t = new Set(this.shapesArray.sort(Ya)), e = [];
    function n(r) {
      e.push(r), t.delete(r), t.forEach((a) => {
        a.parentId === r.id && n(a);
      });
    }
    return t.forEach((r) => {
      const a = this.getShapeById(r.parentId);
      Tp(a) || n(r);
    }), e;
  }
  get selectedShapes() {
    const { selectedIds: t } = this.pageState;
    return Gt(t.map((e) => this.store.get(e)));
  }
  get onlySelectedShape() {
    const { selectedShapes: t } = this;
    return t.length === 1 ? t[0] : null;
  }
  /**
   * Get a shape by its id.
   *
   * @example
   * ```ts
   * 	app.getShapeById('box1')
   * ```
   *
   * @param id - The id of the shape to get.
   * @public
   */
  getShapeById(t) {
    if (Fs(t))
      return this.store.get(t);
  }
  /**
   * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of
   * the page.
   *
   * @example
   * ```ts
   * 	app.getParentShape(myShape)
   * ```
   *
   * @public
   */
  getParentShape(t) {
    if (!(t === void 0 || !Fs(t.parentId)))
      return this.store.get(t.parentId);
  }
  /**
   * If siblingShape and targetShape are siblings, this returns targetShape
   * If targetShape has an ancestor who is a sibling of siblingShape, this returns that ancestor
   * Otherwise, this returns undefined
   */
  getNearestSiblingShape(t, e) {
    return e ? e.parentId === t.parentId ? e : this.findAncestor(
      e,
      (r) => r.parentId === t.parentId
    ) : void 0;
  }
  /**
   * Get the id of the containing page for a given shape.
   */
  getParentPageId(t) {
    if (t !== void 0)
      return fr.isId(t.parentId) ? t.parentId : this.getParentPageId(this.getShapeById(t.parentId));
  }
  /**
   * Get whether the given shape is the descendant of the given page.
   *
   * @example
   * ```ts
   * 	app.isShapeInPage(myShape)
   * 	app.isShapeInPage(myShape, 'page1')
  
   * ```
   * @param shape - The shape to check.
   * @param pageId - The id of the page to check against. Defaults to the current page.
   * @public
   */
  isShapeInPage(t, e = this.currentPageId) {
    let n = !1;
    if (t.parentId === e)
      n = !0;
    else {
      let r = this.getShapeById(t.parentId);
      e:
        for (; r; ) {
          if (r.parentId === e) {
            n = !0;
            break e;
          }
          r = this.getShapeById(r.parentId);
        }
    }
    return n;
  }
  /* --------------------- Styles --------------------- */
  /**
   * A mapping of color ids to CSS color values.
   *
   * @internal
   */
  colors;
  /**
   * A mapping of size ids to size values.
   *
   * @internal
   */
  sizes = {
    s: 2,
    m: 3.5,
    l: 5,
    xl: 10
  };
  /**
   * Get the CSS color value for a given color id.
   *
   * @example
   * ```ts
   * 	app.getCssColor('red')
   * ```
   *
   * @param id - The id of the color to get.
   * @public
   */
  getCssColor(t) {
    return this.colors.get(t);
  }
  /**
   * Get the stroke width value for a given size id.
   *
   * @example
   * ```ts
   * 	app.getStrokeWidth('m')
   * ```
   *
   * @param id - The id of the size to get.
   * @public
   */
  getStrokeWidth(t) {
    return this.sizes[t];
  }
  /* ------------------- Statechart ------------------- */
  /**
   * The id of the current selected tool.
   *
   * @public
   */
  get currentToolId() {
    const t = this.root.current.value;
    let e = t?.id;
    return e === "select" && (e = t?.current.value?.info?.onInteractionEnd ?? "select"), e ?? "select";
  }
  /**
   * Set the selected tool.
   *
   * @example
   * ```ts
   * 	app.setSelectedTool('hand')
   * 	app.setSelectedTool('hand', { date: Date.now() })
   * ```
   *
   * @param id - The id of the tool to select.
   * @param info - Arbitrary data to pass along into the transition.
   * @public
   */
  setSelectedTool(t, e = {}) {
    return this.root.transition(t, e), this;
  }
  /**
   * Get a descendant by its path.
   *
   * @example
   * ```ts
   * 	state.getStateDescendant('select')
   * 	state.getStateDescendant('select.brushing')
   * ```
   *
   * @param path - The descendant's path of state ids, separated by periods.
   * @public
   */
  getStateDescendant(t) {
    const e = t.split(".").reverse();
    let n = this.root;
    for (; e.length > 0; ) {
      const r = e.pop();
      if (!r)
        return n;
      const a = n.children?.[r];
      if (!a)
        return;
      n = a;
    }
    return n;
  }
  /**
   * Get whether a certain tool (or other state node) is currently active.
   *
   * @example
   * ```ts
   * 	app.isIn('select')
   * 	app.isIn('select.brushing')
   * ```
   *
   * @param path - The path of active states, separated by periods.
   * @public
   */
  isIn(t) {
    const e = t.split(".").reverse();
    let n = this.root;
    for (; e.length > 0; ) {
      const r = e.pop();
      if (!r)
        return !0;
      const a = n.current.value;
      if (a?.id === r) {
        if (e.length === 0)
          return !0;
        n = a;
        continue;
      } else
        return !1;
    }
    return !1;
  }
  /**
   * Get whether the state node is in any of the given active paths.
   *
   * @example
   * ```ts
   * 	state.isInAny('select', 'erase')
   * 	state.isInAny('select.brushing', 'erase.idle')
   * ```
   *
   * @public
   */
  isInAny(...t) {
    return t.some((e) => this.isIn(e));
  }
  /* --------------------- Inputs --------------------- */
  /**
   * The app's current input state.
   *
   * @public
   */
  inputs = {
    /** The most recent pointer down's position in page space. */
    originPagePoint: new O(),
    /** The most recent pointer down's position in screen space. */
    originScreenPoint: new O(),
    /** The previous pointer position in page space. */
    previousPagePoint: new O(),
    /** The previous pointer position in screen space. */
    previousScreenPoint: new O(),
    /** The most recent pointer position in page space. */
    currentPagePoint: new O(),
    /** The most recent pointer position in screen space. */
    currentScreenPoint: new O(),
    /** A set containing the currently pressed keys. */
    keys: /* @__PURE__ */ new Set(),
    /** A set containing the currently pressed buttons. */
    buttons: /* @__PURE__ */ new Set(),
    /** Whether the input is from a pe. */
    isPen: !1,
    /** Whether the shift key is currently pressed. */
    shiftKey: !1,
    /** Whether the control or command key is currently pressed. */
    ctrlKey: !1,
    /** Whether the alt or option key is currently pressed. */
    altKey: !1,
    /** Whether the user is dragging. */
    isDragging: !1,
    /** Whether the user is pointing. */
    isPointing: !1,
    /** Whether the user is pinching. */
    isPinching: !1,
    /** Whether the user is editing. */
    isEditing: !1,
    /** Whether the user is panning. */
    isPanning: !1,
    /** Veclocity of mouse pointer, in pixels per millisecond */
    pointerVelocity: new O()
  };
  /**
   * Update the input points from a pointer or pinch event.
   *
   * @internal
   * @param info - The event info.
   */
  _updateInputsFromEvent(t) {
    const { previousScreenPoint: e, previousPagePoint: n, currentScreenPoint: r, currentPagePoint: a } = this.inputs, { screenBounds: s } = this.store.unsafeGetWithoutCapture(this.instanceId), { x: c, y: f, z: p } = t.point, { x: g, y, z: v } = this.camera;
    e.setTo(r), n.setTo(a);
    const S = (c - s.x) / v - g, x = (f - s.y) / v - y;
    r.set(c, f), a.set(S, x, p ?? 0.5), this.inputs.isPen = t.type === "pointer" && t.isPen, t.name === "pointer_down" && (this.inputs.pointerVelocity = new O()), this.updateUserPresence({ cursor: a.toJson() });
  }
  /* --------------------- Events --------------------- */
  /**
   * A manager for recording multiple click events.
   *
   * @internal
   */
  _clickManager = new ine(this);
  /**
   * Prevent a double click event from firing the next time the user clicks
   *
   * @public
   */
  cancelDoubleClick() {
    this._clickManager.cancelDoubleClickTimeout();
  }
  /**
   * The previous cursor. Used for restoring the cursor after pan events.
   *
   * @internal
   */
  _prevCursor = "default";
  /** @internal */
  _shiftKeyTimeout = -1;
  /** @internal */
  _setShiftKeyTimeout = () => {
    this.inputs.shiftKey = !1, this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Shift",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey
    });
  };
  /** @internal */
  _altKeyTimeout = -1;
  /** @internal */
  _setAltKeyTimeout = () => {
    this.inputs.altKey = !1, this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Alt",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey
    });
  };
  /** @internal */
  _ctrlKeyTimeout = -1;
  /** @internal */
  _setCtrlKeyTimeout = () => {
    this.inputs.ctrlKey = !1, this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Ctrl",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey
    });
  };
  /** @internal */
  _restoreToolId = "select";
  /** @internal */
  _pinchStart = 1;
  /** @internal */
  _didPinch = !1;
  /** @internal */
  _selectedIdsAtPointerDown = [];
  /**
   * Dispatch an event to the app.
   *
   * @example
   * ```ts
   * 	app.dispatch(myPointerEvent)
   * ```
   *
   * @param info - The event info.
   * @public
   */
  dispatch = (t) => {
    if (this.crashingError)
      return this;
    const { inputs: e } = this, { type: n } = t;
    return this.batch(() => {
      if (t.type === "misc") {
        t.name === "blur" && this.inputs.isPanning && (this.inputs.isPanning = !1, this.setCursor({
          type: this._prevCursor
        })), this.root.handleEvent(t);
        return;
      }
      t.shiftKey ? (clearInterval(this._shiftKeyTimeout), this._shiftKeyTimeout = -1, e.shiftKey = !0) : !t.shiftKey && e.shiftKey && this._shiftKeyTimeout === -1 && (this._shiftKeyTimeout = setTimeout(this._setShiftKeyTimeout, 150)), t.altKey ? (clearInterval(this._altKeyTimeout), this._altKeyTimeout = -1, e.altKey = !0) : !t.altKey && e.altKey && this._altKeyTimeout === -1 && (this._altKeyTimeout = setTimeout(this._setAltKeyTimeout, 150)), t.ctrlKey ? (clearInterval(this._ctrlKeyTimeout), this._ctrlKeyTimeout = -1, e.ctrlKey = !0) : !t.ctrlKey && e.ctrlKey && this._ctrlKeyTimeout === -1 && (this._ctrlKeyTimeout = setTimeout(this._setCtrlKeyTimeout, 150));
      const { originPagePoint: r, originScreenPoint: a, currentPagePoint: s, currentScreenPoint: c } = e;
      switch (e.isPointing || (e.isDragging = !1), n) {
        case "pinch": {
          if (!this.canMoveCamera)
            return;
          switch (this._updateInputsFromEvent(t), t.name) {
            case "pinch_start": {
              if (e.isPinching)
                return;
              e.isEditing || (this._pinchStart = this.camera.z, this._selectedIdsAtPointerDown.length || (this._selectedIdsAtPointerDown = this.selectedIds.slice()), this._didPinch = !0, e.isPinching = !0, this.interrupt());
              return;
            }
            case "pinch": {
              if (!e.isPinching)
                return;
              const {
                point: { x: f, y: p, z: g = 1 },
                delta: { x: y, y: v }
              } = t, {
                camera: { x: S, y: x, z: _ }
              } = this, T = Math.min(kp, Math.max(Nw, g));
              this.setCamera(
                S + y / _ - f / _ + f / T,
                x + v / _ - p / _ + p / T,
                T
              );
              return;
            }
            case "pinch_end": {
              if (!e.isPinching)
                return this;
              e.isPinching = !1;
              const { _selectedIdsAtPointerDown: f } = this;
              this.setSelectedIds(this._selectedIdsAtPointerDown, !0), this._selectedIdsAtPointerDown = [];
              const {
                camera: { x: p, y: g, z: y }
              } = this;
              let v;
              if (y > 0.9 && y < 1.05 ? v = 1 : y > 0.49 && y < 0.505 && (v = 0.5), y > this._pinchStart - 0.1 && y < this._pinchStart + 0.05 && (v = this._pinchStart), v !== void 0) {
                const { x: S, y: x } = this.viewportScreenCenter;
                this.animateCamera(
                  p + (S / v - S) - (S / y - S),
                  g + (x / v - x) - (x / y - x),
                  v,
                  { duration: 100 }
                );
              }
              this._didPinch && (this._didPinch = !1, requestAnimationFrame(() => {
                this._didPinch || this.setSelectedIds(f, !0);
              }));
              return;
            }
          }
        }
        case "wheel": {
          if (!this.canMoveCamera)
            return;
          if (!(this._viewportAnimation || this.isMenuOpen)) {
            if (e.ctrlKey) {
              const { x: f, y: p } = this.inputs.currentScreenPoint, { x: g, y, z: v } = this.camera, S = Math.min(kp, Math.max(Nw, v + (t.delta.z ?? 0) * v));
              this.setCamera(
                g + (f / S - f) - (f / v - f),
                y + (p / S - p) - (p / v - p),
                S
              );
              return;
            }
            this.pan(t.delta.x, t.delta.y), e.isPointing && !e.isDragging && O.Dist(
              a,
              this.pageToScreen(c.x, c.y)
            ) > eb && (e.isDragging = !0), this.dispatch({
              type: "pointer",
              target: "canvas",
              name: "pointer_move",
              point: c,
              pointerId: 0,
              ctrlKey: t.ctrlKey,
              altKey: t.altKey,
              shiftKey: t.shiftKey,
              button: 0,
              isPen: this.isPenMode ?? !1
            });
          }
          break;
        }
        case "pointer": {
          if (e.isPinching)
            return;
          this._updateInputsFromEvent(t);
          const { isPen: f } = t;
          switch (t.name) {
            case "pointer_down": {
              if (this._selectedIdsAtPointerDown = this.selectedIds.slice(), e.buttons.add(t.button), e.isPointing = !0, e.isDragging = !1, this.isPenMode)
                if (f)
                  this._touchEventsRemainingBeforeExitingPenMode = 3;
                else if (this._touchEventsRemainingBeforeExitingPenMode--, this._touchEventsRemainingBeforeExitingPenMode === 0)
                  this.setPenMode(!1);
                else
                  return;
              else
                f && this.setPenMode(!0);
              if (t.button === 5 ? (this._restoreToolId = this.currentToolId, this.complete(), this.setSelectedTool("eraser")) : t.button === 1 && (this.inputs.isPanning || (this._prevCursor = this.instanceState.cursor.type), this.inputs.isPanning = !0), this.inputs.isPanning)
                return this.stopCameraAnimation(), this.setCursor({
                  type: "grabbing"
                }), this;
              a.setTo(c), r.setTo(s);
              break;
            }
            case "pointer_move": {
              if (!f && this.isPenMode)
                return;
              if (this.inputs.isPanning && this.inputs.isPointing) {
                const { currentScreenPoint: p, previousScreenPoint: g } = this.inputs, y = O.Sub(p, g);
                this.pan(y.x, y.y);
                return;
              }
              e.isPointing && !e.isDragging && O.Dist(a, c) > eb && (e.isDragging = !0);
              break;
            }
            case "pointer_up": {
              if (e.buttons.delete(t.button), e.isPointing = !1, e.isDragging = !1, this.isMenuOpen || !f && this.isPenMode)
                return;
              e.isPanning ? t.button === 1 ? this.inputs.keys.has(" ") ? (this.slideCamera({
                speed: Math.min(2, this.inputs.pointerVelocity.len()),
                direction: this.inputs.pointerVelocity,
                friction: ux
              }), this.setCursor({
                type: "grab"
              })) : (e.isPanning = !1, this.slideCamera({
                speed: Math.min(2, this.inputs.pointerVelocity.len()),
                direction: this.inputs.pointerVelocity,
                friction: ux
              }), this.setCursor({
                type: this._prevCursor
              })) : t.button === 0 && (this.slideCamera({
                speed: Math.min(2, this.inputs.pointerVelocity.len()),
                direction: this.inputs.pointerVelocity,
                friction: ux
              }), this.setCursor({
                type: "grab"
              })) : t.button === 5 && (this.complete(), this.setSelectedTool(this._restoreToolId));
              break;
            }
          }
          break;
        }
        case "keyboard": {
          switch (t.name) {
            case "key_down": {
              if (e.keys.has(t.key))
                return;
              e.keys.add(t.key), !t.ctrlKey && t.key === " " && (this.inputs.isPanning || (this._prevCursor = this.instanceState.cursor.type), this.inputs.isPanning = !0, this.setCursor({
                type: this.inputs.isPointing ? "grabbing" : "grab"
              }));
              break;
            }
            case "key_up": {
              e.keys.delete(t.key), t.key === " " && !this.inputs.buttons.has(1) && (this.inputs.isPanning = !1, this.setCursor({
                type: this._prevCursor
              }));
              break;
            }
          }
          break;
        }
      }
      if (t.type === "pointer" && (t.button === 1 ? t.name = "middle_click" : t.button === 2 && (t.name = "right_click")), t.type === "pointer" && t.isPen === this.isPenMode)
        switch (t.name) {
          case "pointer_down": {
            const f = this._clickManager.transformPointerDownEvent(t);
            if (t.name !== f.name) {
              this.root.handleEvent(t), this.emit("event", t), this.root.handleEvent(f), this.emit("event", f);
              return;
            }
            break;
          }
          case "pointer_up": {
            const f = this._clickManager.transformPointerUpEvent(t);
            if (t.name !== f.name) {
              this.root.handleEvent(t), this.emit("event", t), this.root.handleEvent(f), this.emit("event", f);
              return;
            }
            break;
          }
          case "pointer_move": {
            this._clickManager.handleMove();
            break;
          }
        }
      this.root.handleEvent(t), this.emit("event", t);
    }), this;
  };
  replaceStoreContentsWithRecordsForOtherDocument(t) {
    Ru(() => {
      this.store.clear();
      const [e, n] = VG(t, (a) => a.typeName === "shape");
      this.store.put(n, "initialize"), this.store.ensureStoreIsUsable(), this.store.put(e, "initialize"), this.history.clear(), this.updateViewportScreenBounds(), this.updateCullingBounds();
      const r = this.allShapesCommonBounds;
      r && this.zoomToBounds(r.minX, r.minY, r.width, r.height, 1);
    });
  }
  getContent(t = this.selectedIds) {
    if (!t || t.length === 0)
      return;
    const e = {};
    let n = xx(
      t.map((s) => this.getShapeById(s)).sort(Ya).flatMap((s) => {
        const c = [s];
        return this.visitDescendants(s.id, (f) => {
          c.push(this.getShapeById(f));
        }), c;
      })
    );
    n = n.map((s) => {
      if (s = Lu(s), e[s.id] = this.getPageTransformById(s.id), !ro.is(s))
        return s;
      if (s.props.start.type === "binding") {
        const c = s.props.start.boundShapeId;
        if (!n.find((f) => f.id === c)) {
          const { start: f } = Ou(this, s);
          s.props.start = {
            type: "point",
            x: f.x,
            y: f.y
          };
        }
      }
      if (s.props.end.type === "binding") {
        const c = s.props.end.boundShapeId;
        if (!n.find((f) => f.id === c)) {
          const { end: f } = Ou(this, s);
          s.props.end = {
            type: "point",
            x: f.x,
            y: f.y
          };
        }
      }
      return s;
    });
    const r = [];
    n.forEach((s) => {
      if (n.find((c) => c.id === s.parentId) === void 0) {
        const c = this.getPagePointById(s.id), f = this.getPageRotationById(s.id);
        s.x = c.x, s.y = c.y, s.rotation = f, s.parentId = this.currentPageId, r.push(s.id);
      }
    });
    const a = /* @__PURE__ */ new Set();
    return n.forEach((s) => {
      "assetId" in s.props && s.props.assetId !== null && a.add(s.props.assetId);
    }), {
      shapes: n,
      rootShapeIds: r,
      schema: this.store.schema.serialize(),
      assets: Gt(Array.from(a).map((s) => this.getAssetById(s)))
    };
  }
  /* --------------------- Commands --------------------- */
  putContent(t, e = {}) {
    if (this.isReadOnly)
      return this;
    if (!t.schema)
      throw Error("Could not put content: content is missing a schema.");
    const { select: n = !1, preserveIds: r = !1, preservePosition: a = !1 } = e;
    let { point: s = void 0 } = e;
    const { currentPageId: c } = this, { assets: f, shapes: p, rootShapeIds: g } = t, y = new Map(p.map((j) => [j.id, io()]));
    let v = this.currentPageId, S = 1 / 0, x = [];
    for (const j of this.selectedShapes) {
      if (S === 0)
        break;
      const L = this.getAncestors(j);
      j.type === "frame" && L.push(j);
      const z = j.type === "frame" ? L.length + 1 : L.length;
      if (z < S)
        S = z, x = L, v = j.type === "frame" ? j.id : j.parentId;
      else if (z === S) {
        if (x.length !== L.length)
          throw Error(`Ancestors: ${x.length} !== ${L.length}`);
        if (x.length === 0) {
          v = c;
          break;
        } else {
          v = c;
          for (let F = 0; F < x.length && L[F] === x[F]; F++)
            v = L[F].id;
        }
      }
    }
    let _ = !1;
    if (!fr.isId(v)) {
      const j = this.getShapeById(v);
      if (j) {
        if (!this.viewportPageBounds.includes(this.getPageBounds(j)))
          v = c;
        else if (g.length === 1) {
          const L = p.find((z) => z.id === g[0]);
          px.is(j) && px.is(L) && L.props.w === j?.props.w && L.props.h === j?.props.h && (_ = !0);
        }
      } else
        v = c;
    }
    _ || (_ = y.has(v)), _ && (v = this.getShapeById(v).parentId);
    let T = this.getHighestIndexForParent(v);
    const I = [], D = p.map((j) => {
      let L;
      if (r)
        L = Tc(j), y.set(j.id, j.id);
      else {
        const z = y.get(j.id);
        L = Tc({ ...j, id: z });
      }
      if (g.includes(j.id) && (L.parentId = c, I.push(L)), y.has(L.parentId) ? L.parentId = y.get(j.parentId) : (g.push(L.id), L.index = T, T = Mu(T)), ro.is(L)) {
        if (L.props.start.type === "binding") {
          const z = y.get(L.props.start.boundShapeId);
          L.props.start = z ? { ...L.props.start, boundShapeId: z } : (
            // this shouldn't happen, if you copy an arrow but not it's bound shape it should
            // convert the binding to a point at the time of copying
            {
              type: "point",
              x: 0,
              y: 0
            }
          );
        }
        if (L.props.end.type === "binding") {
          const z = y.get(L.props.end.boundShapeId);
          L.props.end = z ? { ...L.props.end, boundShapeId: z } : (
            // this shouldn't happen, if you copy an arrow but not it's bound shape it should
            // convert the binding to a point at the time of copying
            {
              type: "point",
              x: 0,
              y: 0
            }
          );
        }
      }
      return L;
    });
    if (D.length + this.shapeIds.size > wp)
      return Fw(this), this;
    let N = [];
    if (f) {
      for (let L = 0; L < f.length; L++) {
        const z = f[L], F = this.store.schema.migratePersistedRecord(z, t.schema);
        if (F.type === "success")
          f[L] = F.value;
        else
          throw Error(
            `Could not put content: could not migrate content for asset:
${JSON.stringify(
              z,
              null,
              2
            )}`
          );
      }
      const j = [];
      N = f.filter((L) => !this.store.has(L.id)).map((L) => ((L.type === "image" || L.type === "video") && (L.props.src && L.props.src?.startsWith("data:image") ? (j.push(Lu(L)), L.props.src = null) : j.push(Lu(L))), L)), Promise.allSettled(
        j.map(async (L) => {
          const z = await IZ(
            L.props.src,
            L.props.name,
            L.props.mimeType ?? "image/png"
          ), F = await this.onCreateAssetFromFile(z);
          return [L, F];
        })
      ).then((L) => {
        this.updateAssets(
          Gt(
            L.map(
              (z) => z.status === "fulfilled" ? { ...z.value[1], id: z.value[0].id } : void 0
            )
          )
        );
      });
    }
    for (let j = 0; j < D.length; j++) {
      const L = D[j], z = this.store.schema.migratePersistedRecord(L, t.schema);
      if (z.type === "success")
        D[j] = z.value;
      else
        throw Error(
          `Could not put content: could not migrate content for shape:
${JSON.stringify(
            L,
            null,
            2
          )}`
        );
    }
    return this.batch(() => {
      N.length > 0 && this.createAssets(N), this.createShapes(D, n), v !== c && this.reparentShapesById(
        I.map((z) => z.id),
        v
      );
      const j = D.map((z) => this.getShapeById(z.id)), L = ot.Common(j.map((z) => this.getPageBounds(z)));
      if (s === void 0)
        if (fr.isId(v)) {
          const { viewportPageBounds: z } = this;
          a || z.includes(ot.From(L)) ? s = L.center : s = z.center;
        } else {
          const z = this.getShapeById(v);
          s = this.getShapeUtil(z).center(z);
        }
      if (I.length === 1) {
        const z = I[0];
        if (z.type === "frame")
          for (; this.getShapesAtPoint(s).some(
            (F) => px.is(F) && F.props.w === z.props.w && F.props.h === z.props.h
          ); )
            s.x += L.w + 16;
      }
      this.updateShapes(
        I.map((z) => {
          const F = {
            x: (z.x ?? 0) - (L.x + L.w / 2),
            y: (z.y ?? 0) - (L.y + L.h / 2)
          };
          return { id: z.id, type: z.type, x: s.x + F.x, y: s.y + F.y };
        })
      );
    }), this;
  }
  /* --------------------- Shapes --------------------- */
  /**
   * Get a unique id for a shape.
   *
   * @example
   * ```ts
   * 	app.createShapeId()
   * 	app.createShapeId('box1')
   * ```
   *
   * @param id - The id to use.
   * @public
   */
  createShapeId(t) {
    return t ? fq(t) : io();
  }
  getHighestIndexForParent(t) {
    const e = this._parentIdsToChildIds.value[t];
    return !e || e.length === 0 ? "a1" : Mu(e[e.length - 1][1]);
  }
  /**
   * Create shapes.
   *
   * @example
   * ```ts
   * 	app.createShapes([{ id: "box1", type: "box" }]
   * ```
   *
   * @param partials - The shape partials to create.
   * @param select - Whether to select the created shapes. Defaults to false.
   * @public
   */
  createShapes(t, e = !1) {
    return this._createShapes(t, e), this;
  }
  /** @internal */
  _createShapes = this.history.createCommand(
    "createShapes",
    (t, e = !1) => {
      if (this.isReadOnly || t.length <= 0)
        return null;
      const { shapeIds: n, selectedIds: r } = this, a = e ? r : void 0, s = t.length + n.size > wp;
      s && Fw(this);
      const c = s ? t.slice(0, wp - n.size) : t;
      return c.length === 0 ? null : {
        data: {
          prevSelectedIds: a,
          partials: c,
          select: e
        }
      };
    },
    {
      do: ({ partials: t, select: e }) => {
        const { focusLayerId: n } = this;
        t = t.map((s) => {
          if (
            // No parentId provided
            !s.parentId || // A parentId is proved but the parent is neither a) in the store
            // or b) among the other creating shape partials
            !this.store.get(s.parentId) && !t.find((c) => c.id === s.parentId)
          ) {
            s = { ...s };
            const c = this.getParentIdForNewShapeAtPoint(
              { x: s.x ?? 0, y: s.y ?? 0 },
              s.type
            );
            if (s.parentId = c, Fs(c)) {
              const f = this.getPointInShapeSpace(this.getShapeById(c), {
                x: s.x ?? 0,
                y: s.y ?? 0
              });
              s.x = f.x, s.y = f.y, s.rotation = -this.getPageRotationById(c) + (s.rotation ?? 0);
            }
            return s;
          }
          return s;
        });
        const r = /* @__PURE__ */ new Map(), a = [];
        for (const s of t) {
          const c = this.getShapeUtil(s);
          let f = s.index;
          if (!f) {
            const S = s.parentId ?? n;
            r.has(S) || r.set(S, this.getHighestIndexForParent(S)), f = r.get(S), r.set(S, Mu(f));
          }
          const p = c.defaultProps(), { propsForNextShape: g } = this.instanceState;
          for (const S in p)
            if (S in g) {
              if (S === "url")
                continue;
              p[S] = g[S];
            }
          let y = this.config.TLShape.create({
            ...s,
            index: f,
            parentId: s.parentId ?? n,
            props: "props" in s ? { ...p, ...s.props } : p
          });
          if (y.index === void 0)
            throw Error("no index!");
          const v = this.getShapeUtil(y).onBeforeCreate?.(y);
          v && (y = v), a.push(y);
        }
        if (this.store.put(a), e) {
          const s = t.map((c) => c.id);
          this.store.update(this.pageState.id, (c) => ({ ...c, selectedIds: s }));
        }
      },
      undo: ({ partials: t, prevSelectedIds: e }) => {
        this.store.remove(t.map((n) => n.id)), e && this.store.update(this.pageState.id, (n) => ({
          ...n,
          selectedIds: e
        }));
      }
    }
  );
  animatingShapes = /* @__PURE__ */ new Map();
  /**
   * Animate shapes.
   *
   * @example
   * ```ts
   * 	app.animateShapes([{ id: "box1", type: "box", x: 100, y: 100}])
   * ```
   *
   * @param partials - The shape partials to update.
   * @public
   */
  animateShapes(t, e = {}) {
    const { duration: n = 500, ease: r = fa.linear } = e, a = $i();
    let s = n, c;
    const f = [];
    t.forEach((y) => {
      if (!y)
        return;
      const v = {
        partial: y,
        values: []
      }, S = this.getShapeById(y.id);
      if (S) {
        for (const x of ["x", "y", "rotation"])
          y[x] !== void 0 && S[x] !== y[x] && v.values.push({ prop: x, from: S[x], to: y[x] });
        f.push(v), this.animatingShapes.set(S.id, a);
      }
    });
    let p;
    const g = (y) => {
      if (s -= y, s < 0) {
        const { animatingShapes: S } = this, x = t.filter(
          (_) => _ && S.get(_.id) === a
        );
        x.length && this.updateShapes(x, !1), this.removeListener("tick", g);
        return;
      }
      c = r(1 - s / n);
      const { animatingShapes: v } = this;
      try {
        const S = [];
        for (let x = 0; x < f.length; x++)
          p = f[x], v.get(p.partial.id) === a && S.push({
            id: p.partial.id,
            type: p.partial.type,
            ...p.values.reduce((_, { prop: T, from: I, to: D }) => (_[T] = I + (D - I) * c, _), {})
          });
        this._updateShapes(S, !0);
      } catch {
      }
    };
    return this.addListener("tick", g), this;
  }
  /**
   * Update shapes.
   *
   * @example
   * ```ts
   * 	app.updateShapes([{ id: "box1", type: "box", x: 100, y: 100}])
   * ```
   *
   * @param partials - The shape partials to update.
   * @param squashing - Whether the change is ephemeral.
   * @public
   */
  updateShapes(t, e = !1) {
    if (this.animatingShapes.size > 0) {
      let n;
      for (let r = 0; r < t.length; r++)
        n = t[r], n && this.animatingShapes.delete(n.id);
    }
    return this._updateShapes(t, e), this;
  }
  /** @internal */
  _updateShapes = this.history.createCommand(
    "updateShapes",
    (t, e = !1) => {
      if (this.isReadOnly)
        return null;
      const n = Gt(t), r = Object.fromEntries(
        Gt(n.map(({ id: c }) => this.getShapeById(c))).map((c) => [c.id, c])
      );
      if (n.length <= 0)
        return null;
      const a = Gt(
        n.map((c) => {
          const f = r[c.id];
          if (!f)
            return null;
          let p = null;
          for (const [g, y] of Object.entries(c))
            switch (g) {
              case "id":
              case "type":
              case "typeName":
                continue;
              default:
                y !== f[g] && (p || (p = { ...f }), g === "props" ? p.props = { ...f.props, ...y } : p[g] = y);
            }
          return p ?? f;
        })
      ), s = Object.fromEntries(a.map((c) => [c.id, c]));
      return { data: { snapshots: r, updates: s }, squashing: e };
    },
    {
      do: ({ updates: t }) => {
        const e = Object.values(t);
        let n, r;
        for (let a = 0, s = e.length; a < s; a++)
          n = e[a], r = this.getShapeUtil(n).onBeforeUpdate?.(this.store.get(n.id), n), r && (e[a] = r);
        this.store.put(e);
      },
      undo: ({ snapshots: t }) => {
        this.store.put(Object.values(t));
      },
      squash(t, e) {
        return {
          // keep the oldest snapshots
          snapshots: { ...e.snapshots, ...t.snapshots },
          // keep the newest updates
          updates: { ...t.updates, ...e.updates }
        };
      }
    }
  );
  /**
   * Delete shapes.
   *
   * @example
   * ```ts
   * 	app.deleteShapes()
   * 	app.deleteShapes(['box1', 'box2'])
   * ```
   *
   * @param ids - The ids of the shapes to delete. Defaults to the selected shapes.
   * @public
   */
  deleteShapes(t = this.selectedIds) {
    return this._deleteShapes(t), this;
  }
  /** @internal */
  _deleteShapes = this.history.createCommand(
    "delete_shapes",
    (t) => {
      if (this.isReadOnly || t.length === 0)
        return null;
      const e = [...this.pageState.selectedIds], n = new Set(t);
      for (const f of t)
        this.visitDescendants(f, (p) => {
          n.add(p);
        });
      const r = [...n], a = this._arrowBindingsIndex.value, s = Gt(
        r.flatMap((f) => {
          const p = this.getShapeById(f), g = a[f];
          return g && g.length > 0 ? g.map(({ arrowId: y }) => this.getShapeById(y)).concat(p) : p;
        })
      ), c = e.filter((f) => !n.has(f));
      return { data: { deletedIds: r, snapshots: s, prevSelectedIds: e, postSelectedIds: c } };
    },
    {
      do: ({ deletedIds: t, postSelectedIds: e }) => {
        this.store.remove(t), this.store.update(this.pageState.id, (n) => ({
          ...n,
          selectedIds: e
        }));
      },
      undo: ({ snapshots: t, prevSelectedIds: e }) => {
        this.store.put(t), this.store.update(this.pageState.id, (n) => ({
          ...n,
          selectedIds: e
        }));
      }
    }
  );
  /**
   * Update user document settings
   *
   * @example
   * ```ts
   * 	app.updateUserDocumentSettings({ isGridMode: true })
   * ```
   *
   * @public
   */
  updateUserDocumentSettings(t, e = !1) {
    return this._updateUserDocumentSettings(t, e), this;
  }
  /** @internal */
  _updateUserDocumentSettings = this.history.createCommand(
    "updateUserDocumentSettings",
    (t, e = !1) => {
      const { isReadOnly: n } = t;
      if (n === !1)
        return;
      const r = this.userDocumentSettings, a = { ...r, ...t };
      return { data: { prev: r, next: a }, ephemeral: e };
    },
    {
      do: ({ next: t }) => {
        this.store.put([t]);
      },
      undo: ({ prev: t }) => {
        this.store.put([t]);
      }
    }
  );
  /**
   * Update a page.
   *
   * @example
   * ```ts
   * 	app.updatePage({ id: 'page2', name: 'Page 2' })
   * ```
   *
   * @param partial - The partial of the shape to update.
   * @public
   */
  updatePage(t, e = !1) {
    return this._updatePage(t, e), this;
  }
  /** @internal */
  _updatePage = this.history.createCommand(
    "updatePage",
    (t, e = !1) => {
      if (this.isReadOnly)
        return null;
      const n = this.getPageById(t.id);
      return n ? { data: { prev: n, partial: t }, squashing: e } : null;
    },
    {
      do: ({ partial: t }) => {
        this.store.update(t.id, (e) => ({ ...e, ...t }));
      },
      undo: ({ prev: t, partial: e }) => {
        this.store.update(e.id, () => t);
      },
      squash(t, e) {
        return {
          prev: { ...t.prev, ...e.prev },
          partial: e.partial
        };
      }
    }
  );
  /**
   * Create a page.
   *
   * @example
   * ```ts
   * 	app.createPage('New Page')
   * 	app.createPage('New Page', 'page1')
   * ```
   *
   * @param id - The new page's id.
   * @param title - The new page's title.
   * @public
   */
  createPage(t, e = fr.createId(), n) {
    return this._createPage(t, e, n), this;
  }
  /** @internal */
  _createPage = this.history.createCommand(
    "createPage",
    (t, e = fr.createId(), n) => {
      if (this.isReadOnly || this.pages.length >= $x)
        return null;
      const r = this.pages, a = n ?? r[r.length - 1]?.index ?? "a1", s = r[r.findIndex((v) => v.index === a) + 1]?.index, c = { ...this.pageState }, f = { ...this.instanceState };
      t = RZ(
        t,
        r.map((v) => v.name)
      );
      const p = fr.create({
        id: e,
        name: t,
        index: s ? Hy(a, s) : Mu(a)
      }), g = Xy.create({}), y = qy.create({
        pageId: p.id,
        instanceId: this.instanceId,
        cameraId: g.id
      });
      return {
        data: {
          prevPageState: c,
          prevTabState: f,
          newPage: p,
          newTabPageState: y,
          newCamera: g
        }
      };
    },
    {
      do: ({ newPage: t, newTabPageState: e, newCamera: n }) => {
        this.store.put([
          t,
          n,
          e,
          { ...this.instanceState, currentPageId: t.id }
        ]), this.updateCullingBounds();
      },
      undo: ({ newPage: t, prevPageState: e, prevTabState: n, newTabPageState: r }) => {
        this.store.put([e, n]), this.store.remove([r.id, t.id, r.cameraId]), this.updateCullingBounds();
      }
    }
  );
  duplicatePage(t = this.currentPageId, e = fr.createId()) {
    if (this.pages.length >= $x)
      return;
    const n = this.getPageById(t);
    if (!n)
      return;
    const r = { ...this.camera }, a = this.getContent(this.getSortedChildIds(n.id));
    this.batch(() => {
      if (this.createPage(n.name + " Copy", e, n.index), this.setCurrentPageId(e), this.setCamera(r.x, r.y, r.z), a)
        return this.putContent(a);
    });
  }
  /**
   * Delete a page.
   *
   * @example
   * ```ts
   * 	app.deletePage('page1')
   * ```
   *
   * @param id - The id of the page to delete.
   * @public
   */
  deletePage(t) {
    this._deletePage(t);
  }
  /** @internal */
  _deletePage = this.history.createCommand(
    "delete_page",
    (t) => {
      if (this.isReadOnly)
        return null;
      const { pages: e } = this;
      if (e.length === 1)
        return null;
      const n = this.getPageById(t), r = this._pageStates.value.filter((a) => a.pageId === t);
      if (!n)
        return null;
      if (t === this.currentPageId) {
        const a = e.findIndex((c) => c.id === t), s = e[a - 1] ?? e[a + 1];
        this.setCurrentPageId(s.id);
      }
      return { data: { id: t, deletedPage: n, deletedPageStates: r } };
    },
    {
      do: ({ deletedPage: t, deletedPageStates: e }) => {
        this.store.remove(e.map((n) => n.id)), this.store.remove([t.id]), this.updateCullingBounds();
      },
      undo: ({ deletedPage: t, deletedPageStates: e }) => {
        this.store.put([t]), this.store.put(e), this.updateCullingBounds();
      }
    }
  );
  /**
   * Update a page state.
   *
   * @example
   * ```ts
   * 	app.setInstancePageState({ id: 'page1', editingId: "shape:123" })
   * 	app.setInstancePageState({ id: 'page1', editingId: "shape:123" }, true)
   * ```
   *
   * @param partial - The partial of the page state object containing the changes.
   * @param ephemeral - Whether the command is ephemeral.
   * @public
   */
  setInstancePageState(t, e = !1) {
    this._setInstancePageState(t, e);
  }
  /** @internal */
  _setInstancePageState = this.history.createCommand(
    "setInstancePageState",
    (t, e = !1) => ({ data: { prev: this.store.get(t.id ?? this.pageState.id), partial: t }, ephemeral: e }),
    {
      do: ({ prev: t, partial: e }) => {
        this.store.update(t.id, (n) => ({ ...n, ...e }));
      },
      undo: ({ prev: t }) => {
        this.store.update(t.id, () => t);
      }
    }
  );
  /**
   * Set user state. Always ephemeral for now.
   *
   * @example
   * ```ts
   * 	app.updateUser({ color: '#923433' })
   * ```
   *
   * @param partial - The partial of the user state object containing the changes.
   * @public
   */
  updateUser(t) {
    const e = { ...this.user, ...t };
    this.store.put([e]);
  }
  get _currentUserPresence() {
    return this.store.query.record("user_presence", () => ({ userId: { eq: this.userId } }));
  }
  get userPresence() {
    return this._currentUserPresence.value;
  }
  // when a user performs any action in the app, we update their presence record
  updateUserPresence = ({ cursor: t, color: e } = {}) => {
    const n = this._currentUserPresence.value;
    if (!n) {
      console.error("No presence found for current user");
      return;
    }
    this.store.put([
      {
        ...n,
        cursor: t ?? n.cursor,
        color: e ?? n.color,
        lastUsedInstanceId: this.instanceId,
        lastActivityTimestamp: Date.now()
      }
    ]);
  };
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * 	app.setSelectedIds(['id1'])
   * 	app.setSelectedIds(['id1', 'id2'])
   * ```
   *
   * @param ids - The ids to select.
   * @param squashing - Whether the change should create a new history entry or combine with the
   *   previous (if the previous is the same type).
   * @public
   */
  setSelectedIds(t, e = !1) {
    return this._setSelectedIds(t, e), this;
  }
  /** @internal */
  _setSelectedIds = this.history.createCommand(
    "setSelectedIds",
    (t, e = !1) => {
      const n = this.pageState.selectedIds, r = new Set(this.pageState.selectedIds);
      return t.length === r.size && t.every((a) => r.has(a)) ? null : { data: { ids: t, prevSelectedIds: n }, squashing: e, preservesRedoStack: !0 };
    },
    {
      do: ({ ids: t }) => {
        this.store.update(this.pageState.id, (e) => ({ ...e, selectedIds: t }));
      },
      undo: ({ prevSelectedIds: t }) => {
        this.store.update(this.pageState.id, () => ({
          ...this.pageState,
          selectedIds: t
        }));
      },
      squash(t, e) {
        return { ids: e.ids, prevSelectedIds: t.prevSelectedIds };
      }
    }
  );
  /**
   * Determine whether or not a shape is selected
   *
   * @example
   * ```ts
   * 	app.isSelected('id1')
   * ```
   *
   * @param id - The id of the shape to check.
   * @public
   */
  isSelected(t) {
    return this.selectedIdsSet.has(t);
  }
  /**
   * Determine whether a not a shape is within the current selection. A shape
   * is within the selection if it or any of its parents is selected.
   *
   * @param id - The id of the shape to check.
   * @public
   */
  isWithinSelection(t) {
    const e = this.getShapeById(t);
    return e ? this.isSelected(t) ? !0 : !!this.findAncestor(e, (n) => this.isSelected(n.id)) : !1;
  }
  get _assets() {
    return this.store.query.records("asset");
  }
  /**
   * Get all assets in the app.
   */
  get assets() {
    return this._assets.value;
  }
  /**
   * Create one or more assets.
   *
   * @example
   * ```ts
   * 	app.createAssets([...myAssets])
   * ```
   *
   * @param assets - The assets to create.
   * @public
   */
  createAssets(t) {
    return this._createAssets(t), this;
  }
  /** @internal */
  _createAssets = this.history.createCommand(
    "createAssets",
    (t) => this.isReadOnly || t.length <= 0 ? null : { data: { assets: t } },
    {
      do: ({ assets: t }) => {
        this.store.put(t);
      },
      undo: ({ assets: t }) => {
        this.store.remove(t.map((e) => e.id));
      }
    }
  );
  /**
   * Delete one or more assets.
   *
   * @example
   * ```ts
   * 	app.deleteAssets(['asset1', 'asset2'])
   * ```
   *
   * @param ids - The assets to delete.
   * @public
   */
  deleteAssets(t) {
    return this._deleteAssets(t), this;
  }
  /** @internal */
  _deleteAssets = this.history.createCommand(
    "deleteAssets",
    (t) => {
      if (this.isReadOnly || t.length <= 0)
        return;
      const e = Gt(t.map((n) => this.store.get(n)));
      return { data: { ids: t, prev: e } };
    },
    {
      do: ({ ids: t }) => {
        this.store.remove(t);
      },
      undo: ({ prev: t }) => {
        this.store.put(t);
      }
    }
  );
  /**
   * Update one or more assets.
   *
   * @example
   * ```ts
   * 	app.updateAssets([{ id: 'asset1', name: 'New name' }])
   * ```
   *
   * @param assets - The assets to update.
   * @public
   */
  updateAssets(t) {
    return this._updateAssets(t), this;
  }
  /** @internal */
  _updateAssets = this.history.createCommand(
    "updateAssets",
    (t) => this.isReadOnly || t.length <= 0 ? void 0 : { data: { snapshots: {}, assets: t } },
    {
      do: ({ assets: t, snapshots: e }) => {
        this.store.put(
          t.map((n) => {
            const r = this.store.get(n.id);
            return e[n.id] = r, {
              ...r,
              ...n
            };
          })
        );
      },
      undo: ({ snapshots: t }) => {
        this.store.put(Object.values(t));
      }
    }
  );
  /**
   * Get an asset by its src property.
   *
   * @example
   * ```ts
   * 	app.getAssetBySource('https://example.com/image.png')
   * ```
   *
   * @param src - The source value of the asset.
   * @public
   */
  getAssetBySrc(t) {
    return this.assets.find((e) => e.props.src === t);
  }
  /**
   * Get an asset by its id.
   *
   * @example
   * ```ts
   * 	app.getAssetById('asset1')
   * ```
   *
   * @param id - The id of the asset.
   * @public
   */
  getAssetById(t) {
    return this.store.get(t);
  }
  /* ------------------- SubCommands ------------------ */
  async getSvg(t = this.selectedIds.length ? this.selectedIds : Object.keys(this.shapeIds), e = {}) {
    if (t.length === 0)
      return;
    if (!window.document)
      throw Error("No document");
    const {
      scale: n = 1,
      background: r = !1,
      padding: a = pQ,
      darkMode: s = this.userDocumentSettings.isDarkMode,
      preserveAspectRatio: c = !1
    } = e, f = this.getContainer(), p = getComputedStyle(f), g = document.createElement("div");
    g.className = `rs-container rs-theme__${s ? "dark" : "light"}`, document.body.appendChild(g);
    const y = getComputedStyle(g), v = /* @__PURE__ */ new Map(), S = {
      fill: Object.fromEntries(
        Lw.color.map((F) => [
          F.id,
          y.getPropertyValue(`--palette-${F.id}`)
        ])
      ),
      pattern: Object.fromEntries(
        Lw.color.map((F) => [
          F.id,
          y.getPropertyValue(`--palette-${F.id}-pattern`)
        ])
      ),
      semi: Object.fromEntries(
        Lw.color.map((F) => [
          F.id,
          y.getPropertyValue(`--palette-${F.id}-semi`)
        ])
      ),
      text: y.getPropertyValue("--color-text"),
      background: y.getPropertyValue("--color-background"),
      solid: y.getPropertyValue("--palette-solid")
    };
    document.body.removeChild(g);
    const x = this.getShapesAndDescendantsInOrder(t), _ = ot.FromPoints(
      x.map((F) => {
        const K = this.getPageTransform(F);
        return De.applyToPoints(K, this.getOutline(F));
      }).flat()
    );
    _.expandBy(a);
    const T = window.document.createElementNS("http://www.w3.org/2000/svg", "svg");
    c && T.setAttribute("preserveAspectRatio", c);
    const I = _.width * n, D = _.height * n;
    T.setAttribute("direction", "ltr"), T.setAttribute("width", I + ""), T.setAttribute("height", D + ""), T.setAttribute("viewBox", `${_.minX} ${_.minY} ${_.width} ${_.height}`), T.setAttribute("stroke-linecap", "round"), T.setAttribute("stroke-linejoin", "round"), T.style.setProperty("background-color", r ? S.background : "transparent");
    const N = window.document.createElementNS("http://www.w3.org/2000/svg", "defs");
    for (const F of Array.from(cee()))
      N.appendChild(F);
    try {
      document.body.focus?.();
    } catch {
    }
    T.append(N);
    for (const F of x) {
      let K;
      "font" in F.props && F.props.font && (v.has(F.props.font) ? K = v.get(F.props.font) : (K = p.getPropertyValue(`--rs-font-${F.props.font}`), v.set(F.props.font, K)));
      let se = await this.getShapeUtil(F).toSvg?.(F, K, S);
      if (!se) {
        const ve = this.getPageBounds(F), Y = window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
        Y.setAttribute("width", ve.width + ""), Y.setAttribute("height", ve.height + ""), Y.setAttribute("fill", S.solid), Y.setAttribute("stroke", S.pattern.grey), Y.setAttribute("stroke-width", "1"), se = Y;
      }
      const ue = se;
      let pe = this.getPageTransform(F).toCssString();
      "scale" in F.props && F.props.scale !== 1 && (pe = `${pe} scale(${F.props.scale}, ${F.props.scale})`), ue.setAttribute("transform", pe), "opacity" in F.props && ue.setAttribute("opacity", F.props.opacity + ""), T.appendChild(ue);
      const Pe = this._clipPathCache.get(F.id);
      if (ue && Pe) {
        const ve = document.createElementNS("http://www.w3.org/2000/svg", "g");
        ve.style.clipPath = Pe, Array.from(ue.childNodes).forEach((le) => ve.appendChild(le)), ue.appendChild(ve);
      }
    }
    let j = "";
    const L = window.document.createElementNS("http://www.w3.org/2000/svg", "style"), z = [];
    "fonts" in document && document.fonts.forEach((F) => z.push(F));
    for (const F of z) {
      const K = new FileReader();
      let X = !1;
      if (v.forEach((pe) => {
        pe.includes(F.family) && (X = !0);
      }), !X)
        continue;
      const se = F.$$_url, ue = F.$$_fontface;
      if (se) {
        const pe = await (await fetch(se)).blob(), Pe = await new Promise((Y, le) => {
          K.onload = () => Y(K.result), K.onerror = () => le(K.error), K.readAsDataURL(pe);
        }), ve = `
` + ue.replaceAll(se, Pe);
        j += ve;
      }
    }
    return L.textContent = j, N.append(L), T;
  }
  /**
   * Rename a page.
   *
   * @example
   * ```ts
   * 	app.renamePage('page1', 'My Page')
   * ```
   *
   * @param id - The id of the page to rename.
   * @param name - The new name.
   * @public
   */
  renamePage(t, e, n = !1) {
    return this.isReadOnly ? this : (this.updatePage({ id: t, name: e }, n), this);
  }
  /**
   * Move shapes to page.
   *
   * @example
   * ```ts
   * 	app.moveShapesToPage(['box1', 'box2'], 'page1')
   * ```
   *
   * @param ids - The ids of the shapes to move.
   * @param pageId - The id of the page where the shapes will be moved.
   * @public
   */
  moveShapesToPage(t, e) {
    if (t.length === 0)
      return this;
    if (this.isReadOnly)
      return this;
    const { currentPageId: n } = this;
    if (e === n)
      return this;
    if (!this.store.has(e))
      return this;
    const r = this.getContent(t);
    if (!r)
      return this;
    if (this.getShapesInPage(e).length + r.shapes.length > wp)
      return Fw(this, e), this;
    const a = this.camera.z;
    return this.history.batch(() => {
      this.deleteShapes(t), this.setCurrentPageId(e), this.setFocusLayer(null), this.selectNone(), this.putContent(r, { select: !0, preserveIds: !0, preservePosition: !0 });
      const {
        center: { x: s, y: c }
      } = this.selectionBounds;
      this.setCamera(this.camera.x, this.camera.y, a), this.centerOnPoint(s, c);
    }), this.emit("moved-to-page", { name: this.currentPage.name, toId: e, fromId: n }), this;
  }
  lockShapes(t = this.pageState.selectedIds) {
    return this.isReadOnly ? this : this;
  }
  /**
   * Reorder shapes.
   *
   * @param operation - The operation to perform.
   * @param ids - The ids to reorder.
   * @public
   */
  reorderShapes(t, e) {
    if (this.isReadOnly)
      return this;
    if (e.length === 0)
      return this;
    const n = this.getParentsMappedToChildren(e), r = [];
    switch (t) {
      case "toBack": {
        n.forEach((a, s) => {
          const c = Gt(
            this.getSortedChildIds(s).map((y) => this.getShapeById(y))
          );
          if (a.size === c.length)
            return;
          let f, p;
          for (const y of c) {
            if (!a.has(y)) {
              p = y.index;
              break;
            }
            a.delete(y), f = y.index;
          }
          if (a.size === 0)
            return;
          const g = Mg(f, p, a.size);
          Array.from(a.values()).sort(Ya).forEach(
            (y, v) => r.push({ id: y.id, type: y.type, index: g[v] })
          );
        });
        break;
      }
      case "toFront": {
        n.forEach((a, s) => {
          const c = Gt(
            this.getSortedChildIds(s).map((v) => this.getShapeById(v))
          ), f = c.length;
          if (a.size === f)
            return;
          let p, g;
          for (let v = f - 1; v > -1; v--) {
            const S = c[v];
            if (!a.has(S)) {
              p = S.index;
              break;
            }
            a.delete(S), g = S.index;
          }
          if (a.size === 0)
            return;
          const y = Mg(p, g, a.size);
          Array.from(a.values()).sort(Ya).forEach(
            (v, S) => r.push({ id: v.id, type: v.type, index: y[S] })
          );
        });
        break;
      }
      case "forward": {
        n.forEach((a, s) => {
          const c = Gt(
            this.getSortedChildIds(s).map((_) => this.getShapeById(_))
          ), f = c.length;
          if (a.size === f)
            return;
          const p = new Set(Array.from(a).map((_) => c.indexOf(_)));
          let g = -1, y = !1, v, S, x;
          for (let _ = 0; _ < f; _++) {
            const T = p.has(_);
            if (!y && T)
              y = !0, g = _, S = void 0;
            else if (y && !T) {
              y = !1, x = _ - g, v = c[_].index, S = c[_ + 1]?.index;
              const I = Mg(v, S, x);
              for (let D = 0; D < x; D++) {
                const N = c[g + D];
                r.push({ id: N.id, type: N.type, index: I[D] });
              }
            }
          }
        });
        break;
      }
      case "backward": {
        n.forEach((a, s) => {
          const c = Gt(
            this.getSortedChildIds(s).map((S) => this.getShapeById(S))
          ), f = c.length;
          if (a.size === f)
            return;
          const p = new Set(Array.from(a).map((S) => c.indexOf(S)));
          let g = -1, y = !1, v;
          for (let S = f - 1; S > -1; S--) {
            const x = p.has(S);
            if (!y && x)
              y = !0, g = S;
            else if (y && !x) {
              y = !1, v = g - S;
              const _ = Mg(c[S - 1]?.index, c[S].index, v);
              for (let T = 0; T < v; T++) {
                const I = c[S + T + 1];
                r.push({ id: I.id, type: I.type, index: _[T] });
              }
            }
          }
        });
        break;
      }
    }
    return this.updateShapes(r), this;
  }
  /**
   * Send shapes to the back of the page's object list.
   *
   * @example
   * ```ts
   * 	app.sendToBack()
   * 	app.sendToBack(['id1', 'id2'])
   * ```
   *
   * @param ids - The ids of the shapes to move. Defaults to the ids of the selected
   *   shapes.
   * @public
   */
  sendToBack(t = this.pageState.selectedIds) {
    return this.reorderShapes("toBack", t), this;
  }
  /**
   * Send shapes backward in the page's object list.
   *
   * @example
   * ```ts
   * 	app.sendBackward()
   * 	app.sendBackward(['id1', 'id2'])
   * ```
   *
   * @param ids - The ids of the shapes to move. Defaults to the ids of the selected
   *   shapes.
   * @public
   */
  sendBackward(t = this.pageState.selectedIds) {
    return this.reorderShapes("backward", t), this;
  }
  /**
   * Bring shapes forward in the page's object list.
   *
   * @example
   * ```ts
   * 	app.bringForward()
   * 	app.bringForward(['id1', 'id2'])
   * ```
   *
   * @param ids - The ids of the shapes to move. Defaults to the ids of the selected
   *   shapes.
   * @public
   */
  bringForward(t = this.pageState.selectedIds) {
    return this.reorderShapes("forward", t), this;
  }
  /**
   * Bring shapes to the front of the page's object list.
   *
   * @example
   * ```ts
   * 	app.bringToFront()
   * 	app.bringToFront(['id1', 'id2'])
   * ```
   *
   * @param ids - The ids of the shapes to move. Defaults to the ids of the selected
   *   shapes.
   * @public
   */
  bringToFront(t = this.pageState.selectedIds) {
    return this.reorderShapes("toFront", t), this;
  }
  /**
   * Flip shape positions.
   *
   * @example
   * ```ts
   * 	app.flipShapes('horizontal')
   * 	app.flipShapes('horizontal', ['box1', 'box2'])
   * ```
   *
   * @param operation - Whether to flip horizontally or vertically.
   * @param ids - The ids of the shapes to flip. Defaults to selected shapes.
   * @public
   */
  flipShapes(t, e = this.selectedIds) {
    if (this.isReadOnly)
      return this;
    let n = Gt(e.map((a) => this.getShapeById(a)));
    if (!n.length)
      return this;
    n = n.map((a) => a.type === "group" ? this.getSortedChildIds(a.id).map((s) => this.getShapeById(s)) : a).flat();
    const r = ot.Common(Gt(n.map((a) => this.getPageBounds(a)))).center;
    for (const a of n) {
      const c = this.getShapeUtil(a).bounds(a), f = this.getPageTransformById(a.id);
      f && this.resizeShape(
        a.id,
        { x: t === "horizontal" ? -1 : 1, y: t === "vertical" ? -1 : 1 },
        {
          initialBounds: c,
          initialPageTransform: f,
          initialShape: a,
          mode: "scale_shape",
          scaleOrigin: r,
          scaleAxisRotation: 0
        }
      );
    }
    return this;
  }
  /**
   * Stack shape.
   *
   * @example
   * ```ts
   * 	app.stackShapes('horizontal')
   * 	app.stackShapes('horizontal', ['box1', 'box2'])
   * 	app.stackShapes('horizontal', ['box1', 'box2'], 20)
   * ```
   *
   * @param operation - Whether to stack horizontally or vertically.
   * @param ids - The ids of the shapes to stack. Defaults to selected shapes.
   * @param gap - A specific gap to use when stacking.
   * @public
   */
  stackShapes(t, e = this.pageState.selectedIds, n) {
    if (this.isReadOnly)
      return this;
    const r = Gt(e.map((x) => this.getShapeById(x))).filter((x) => !(!x || ro.is(x) && (x.props.start.type === "binding" || x.props.end.type === "binding"))), a = r.length;
    if (n === void 0 && a < 3 || a < 2)
      return this;
    const s = Object.fromEntries(
      r.map((x) => [x.id, this.getPageBounds(x)])
    );
    let c, f, p, g;
    t === "horizontal" ? (c = "x", f = "minX", p = "maxX", g = "width") : (c = "y", f = "minY", p = "maxY", g = "height");
    let y;
    if (n === void 0) {
      const x = [];
      r.sort((T, I) => s[T.id][f] - s[I.id][f]);
      for (let T = 0; T < a - 1; T++) {
        const I = r[T], D = r[T + 1], N = s[I.id], L = s[D.id][f] - N[p], z = x.find((F) => F.gap === L);
        z ? z.count++ : x.push({ gap: L, count: 1 });
      }
      let _ = 0;
      x.forEach((T) => {
        T.count > _ && (_ = T.count, y = T.gap);
      }), _ === 1 && (y = Math.max(0, x.reduce((T, I) => T + I.gap * I.count, 0) / (a - 1)));
    } else
      y = n;
    const v = [];
    let S = s[r[0].id][p];
    return r.forEach((x, _) => {
      if (_ === 0)
        return;
      const T = { x: 0, y: 0 };
      T[c] = S + y - s[x.id][c];
      const I = this.getParentShape(x), D = I ? O.Rot(T, -this.getPageRotation(I)) : T, N = this.getShapeUtil(x).onTranslateStart?.(x);
      v.push(
        N ? {
          ...N,
          [c]: x[c] + D[c]
        } : {
          id: x.id,
          type: x.type,
          [c]: x[c] + D[c]
        }
      ), S += s[x.id][g] + y;
    }), this.updateShapes(v), this;
  }
  /**
   * Pack shapes into a grid centered on their current position.
   * Based on potpack (https://github.com/mapbox/potpack)
   *
   * @param ids - The ids of the shapes to pack. Defaults to selected shapes.
   * @param padding - The padding to apply to the packed shapes.
   */
  packShapes(t = this.pageState.selectedIds, e = 16) {
    if (this.isReadOnly)
      return this;
    if (t.length < 2)
      return this;
    const n = Gt(
      t.map((L) => this.getShapeById(L)).filter((L) => !(!L || ro.is(L) && (L.props.start.type === "binding" || L.props.end.type === "binding")))
    ), r = {}, a = {};
    let s, c, f = 0;
    for (let L = 0; L < n.length; L++)
      s = n[L], c = this.getPageBounds(s), r[s.id] = c, a[s.id] = c.clone(), f += c.width * c.height;
    const p = ot.Common(Gt(Object.values(r))), g = p.width;
    n.sort((L, z) => r[z.id].height - r[L.id].height);
    const y = Math.max(Math.ceil(Math.sqrt(f / 0.95)), g), v = [new ot(p.x, p.y, y, 1 / 0)];
    let S = 0, x = 0, _, T;
    for (let L = 0; L < n.length; L++) {
      s = n[L], c = a[s.id];
      for (let z = v.length - 1; z >= 0; z--)
        if (_ = v[z], !(c.width > _.width || c.height > _.height)) {
          c.x = _.x, c.y = _.y, x = Math.max(x, c.maxY), S = Math.max(S, c.maxX), c.width === _.width && c.height === _.height ? (T = v.pop(), z < v.length && (v[z] = T)) : c.height === _.height ? (_.x += c.width + e, _.width -= c.width + e) : c.width === _.width ? (_.y += c.height + e, _.height -= c.height + e) : (v.push(
            new ot(
              _.x + (c.width + e),
              _.y,
              _.width - (c.width + e),
              c.height
            )
          ), _.y += c.height + e, _.height -= c.height + e);
          break;
        }
    }
    const I = ot.Common(Object.values(a)), D = O.Sub(p.center, I.center);
    let N;
    const j = [];
    for (let L = 0; L < n.length; L++) {
      s = n[L], c = r[s.id], N = a[s.id];
      const z = this.getDeltaInParentSpace(
        s,
        O.Sub(N.point, c.point).add(D)
      ), F = {
        id: s.id,
        type: s.type,
        x: s.x + z.x,
        y: s.y + z.y
      }, K = this.getShapeUtil(s).onTranslateStart?.({
        ...s,
        ...F
      });
      K ? j.push({ ...F, ...K }) : j.push(F);
    }
    return j.length && this.updateShapes(j), this;
  }
  /**
   * Align shape positions.
   *
   * @example
   * ```ts
   * 	app.alignShapes('left')
   * 	app.alignShapes('left', ['box1', 'box2'])
   * ```
   *
   * @param operation - The align operation to apply.
   * @param ids - The ids of the shapes to align. Defaults to selected shapes.
   * @public
   */
  alignShapes(t, e = this.pageState.selectedIds) {
    if (this.isReadOnly)
      return this;
    if (e.length < 2)
      return this;
    const n = Gt(e.map((c) => this.getShapeById(c))), r = Object.fromEntries(
      n.map((c) => [c.id, this.getPageBounds(c)])
    ), a = ot.Common(Gt(Object.values(r))), s = [];
    return n.forEach((c) => {
      const f = r[c.id];
      if (!f)
        return;
      const p = { x: 0, y: 0 };
      switch (t) {
        case "top": {
          p.y = a.minY - f.minY;
          break;
        }
        case "center-vertical": {
          p.y = a.midY - f.minY - f.height / 2;
          break;
        }
        case "bottom": {
          p.y = a.maxY - f.minY - f.height;
          break;
        }
        case "left": {
          p.x = a.minX - f.minX;
          break;
        }
        case "center-horizontal": {
          p.x = a.midX - f.minX - f.width / 2;
          break;
        }
        case "right": {
          p.x = a.maxX - f.minX - f.width;
          break;
        }
      }
      const g = this.getParentShape(c), y = g ? O.Rot(p, -this.getPageRotation(g)) : p, v = this.getShapeUtil(c).onTranslateStart?.(c);
      s.push(
        v ? {
          ...v,
          x: c.x + y.x,
          y: c.y + y.y
        } : {
          id: c.id,
          type: c.type,
          x: c.x + y.x,
          y: c.y + y.y
        }
      );
    }), this.updateShapes(s), this;
  }
  /**
   * Distribute shape positions.
   *
   * @example
   * ```ts
   * 	app.distributeShapes('left')
   * 	app.distributeShapes('left', ['box1', 'box2'])
   * ```
   *
   * @param operation - Whether to distribute shapes horizontally or vertically.
   * @param ids - The ids of the shapes to distribute. Defaults to selected shapes.
   * @public
   */
  distributeShapes(t, e = this.pageState.selectedIds) {
    if (this.isReadOnly)
      return this;
    if (e.length < 3)
      return this;
    const n = e.length, r = Gt(e.map((I) => this.getShapeById(I))), a = Object.fromEntries(
      r.map((I) => [I.id, this.getPageBounds(I)])
    );
    let s, c, f, p, g;
    t === "horizontal" ? (s = "x", c = "minX", f = "maxX", p = "midX", g = "width") : (s = "y", c = "minY", f = "maxY", p = "midY", g = "height");
    const y = [], v = r.sort((I, D) => a[I.id][c] - a[D.id][c])[0], S = r.sort((I, D) => a[D.id][f] - a[I.id][f])[0], x = a[v.id][p], _ = (a[S.id][p] - x) / (n - 1), T = x + _;
    return r.filter((I) => I !== v && I !== S).sort((I, D) => a[I.id][p] - a[D.id][p]).forEach((I, D) => {
      const N = { x: 0, y: 0 };
      N[s] = T + _ * D - a[I.id][g] / 2 - a[I.id][s];
      const j = this.getParentShape(I), L = j ? O.Rot(N, -this.getPageRotation(j)) : N, z = this.getShapeUtil(I).onTranslateStart?.(I);
      y.push(
        z ? {
          ...z,
          [s]: I[s] + L[s]
        } : {
          id: I.id,
          type: I.type,
          [s]: I[s] + L[s]
        }
      );
    }), this.updateShapes(y), this;
  }
  /** @internal */
  _resizeUnalignedShape(t, e, n) {
    const { type: r } = n.initialShape, a = new O(e.x, e.y);
    if (Math.abs(e.x) > Math.abs(e.y) ? a.x = Math.sign(e.x) * Math.abs(e.y) : a.y = Math.sign(e.y) * Math.abs(e.x), this.resizeShape(t, a, {
      initialShape: n.initialShape,
      initialBounds: n.initialBounds
    }), Math.sign(e.x) * Math.sign(e.y) < 0) {
      let { rotation: x } = De.Decompose(n.initialPageTransform);
      x -= 2 * x, this.updateShapes([{ id: t, type: r, rotation: x }], !0);
    }
    const s = De.applyToPoint(
      n.initialPageTransform,
      n.initialBounds.center
    ), c = this._scalePagePoint(
      s,
      n.scaleOrigin,
      e,
      n.scaleAxisRotation
    ), f = this.getPageCenterById(t), p = this.getPagePointById(t);
    if (!f || !p)
      return this;
    const g = O.Sub(c, f), y = O.Add(p, g), { x: v, y: S } = this.getPointInParentSpace(t, y);
    return this.updateShapes([{ id: t, type: r, x: v, y: S }], !0), this;
  }
  /** @internal */
  _scalePagePoint(t, e, n, r) {
    const a = O.RotWith(t, e, -r).sub(e), s = O.MulV(a, n);
    return O.Add(s, e).rotWith(
      e,
      r
    );
  }
  resizeShape(t, e, n) {
    if (this.isReadOnly)
      return this;
    Number.isFinite(e.x) || (e = new O(1, e.y)), Number.isFinite(e.y) || (e = new O(e.x, 1));
    const r = n?.initialShape ?? this.getShapeById(t);
    if (!r)
      return this;
    const a = n?.scaleOrigin ?? this.getPageBoundsById(t)?.center;
    if (!a)
      return this;
    const s = this.getPageRotationById(t);
    if (s == null)
      return this;
    const c = n?.scaleAxisRotation ?? s, f = n?.initialPageTransform ?? this.getPageTransformById(t);
    if (!f)
      return this;
    const p = n?.initialBounds ?? this.getBoundsById(t);
    if (!p)
      return this;
    if (!IL(s, c))
      return this._resizeUnalignedShape(t, e, {
        ...n,
        initialBounds: p,
        scaleOrigin: a,
        scaleAxisRotation: c,
        initialPageTransform: f,
        initialShape: r
      });
    const g = this.getShapeUtil(r);
    if (g.isAspectRatioLocked(r) && (Math.abs(e.x) > Math.abs(e.y) ? e = new O(e.x, Math.sign(e.y) * Math.abs(e.x)) : e = new O(Math.sign(e.x) * Math.abs(e.y), e.y)), g.onResize && g.canResize(r)) {
      const y = this._scalePagePoint(
        De.applyToPoint(f, new O(0, 0)),
        a,
        e,
        c
      ), v = this.getPointInParentSpace(r.id, y), S = new O(e.x, e.y), x = Fy(
        (s - c) % Math.PI,
        0
      );
      S.x = x ? e.x : e.y, S.y = x ? e.y : e.x;
      const _ = De.applyToPoint(f, new O()), { x: T, y: I } = this.getPointInParentSpace(r.id, _);
      this.updateShapes(
        [
          {
            id: t,
            type: r.type,
            x: v.x,
            y: v.y,
            ...g.onResize(
              { ...r, x: T, y: I },
              {
                newPoint: v,
                handle: n?.dragHandle ?? "bottom_right",
                // don't set isSingle to true for children
                mode: n?.mode ?? "scale_shape",
                scaleX: S.x,
                scaleY: S.y,
                initialBounds: p,
                initialShape: r
              }
            )
          }
        ],
        !0
      );
    } else {
      const y = De.applyToPoint(f, p.center), v = this._scalePagePoint(
        y,
        a,
        e,
        c
      ), S = this.getPointInParentSpace(
        r.id,
        y
      ), x = this.getPointInParentSpace(r.id, v), _ = O.Sub(x, S);
      this.updateShapes(
        [
          {
            id: t,
            type: r.type,
            x: r.x + _.x,
            y: r.y + _.y
          }
        ],
        !0
      );
    }
    return this;
  }
  /**
   * Stretch shape sizes and positions to fill their common bounding box.
   *
   * @example
   * ```ts
   * 	app.stretchShapes('horizontal')
   * 	app.stretchShapes('horizontal', ['box1', 'box2'])
   * ```
   *
   * @param operation - Whether to stretch shapes horizontally or vertically.
   * @param ids - The ids of the shapes to stretch. Defaults to selected shapes.
   * @public
   */
  stretchShapes(t, e = this.pageState.selectedIds) {
    if (this.isReadOnly)
      return this;
    if (e.length < 2)
      return this;
    const n = Gt(e.map((f) => this.getShapeById(f))), r = Object.fromEntries(n.map((f) => [f.id, this.getBounds(f)])), a = Object.fromEntries(
      n.map((f) => [f.id, this.getPageBounds(f)])
    ), s = ot.Common(Gt(Object.values(a))), c = [];
    switch (t) {
      case "vertical": {
        this.batch(() => {
          for (const f of n) {
            if (this.getPageRotation(f) % Wr)
              continue;
            const g = r[f.id], y = a[f.id], v = this.getDeltaInParentSpace(
              f,
              new O(0, s.minY - y.minY)
            ), { x: S, y: x } = O.Add(v, f);
            this.updateShapes([{ id: f.id, type: f.type, x: S, y: x }], !0);
            const _ = new O(1, s.height / y.height);
            this.resizeShape(f.id, _, {
              initialBounds: g,
              scaleOrigin: new O(y.center.x, s.minY),
              scaleAxisRotation: 0
            });
          }
        });
        break;
      }
      case "horizontal": {
        this.batch(() => {
          for (const f of n) {
            const p = r[f.id], g = a[f.id];
            if (this.getPageRotation(f) % Wr)
              continue;
            const v = this.getDeltaInParentSpace(
              f,
              new O(s.minX - g.minX, 0)
            ), { x: S, y: x } = O.Add(v, f);
            this.updateShapes([{ id: f.id, type: f.type, x: S, y: x }], !0);
            const _ = new O(s.width / g.width, 1);
            this.resizeShape(f.id, _, {
              initialBounds: p,
              scaleOrigin: new O(s.minX, g.center.y),
              scaleAxisRotation: 0
            });
          }
        });
        break;
      }
    }
    return this.updateShapes(c), this;
  }
  /**
   * Reparent shapes to a new parent. This operation preserves the shape's current page positions /
   * rotations.
   *
   * @example
   * ```ts
   * 	app.reparentShapesById(['box1', 'box2'], 'frame1')
   * ```
   *
   * @param ids - The ids of the shapes to reparent.
   * @param parentId - The id of the new parent shape.
   * @param insertIndex - The index to insert the children.
   * @public
   */
  reparentShapesById(t, e, n) {
    const r = [], a = fr.isId(e) ? De.Identity() : this.getPageTransformById(e), s = a.decompose().rotation;
    let c = [];
    const f = Gt(this.getSortedChildIds(e).map((g) => this.getShapeById(g)));
    if (n) {
      const g = f.find((y) => y.index === n);
      if (g) {
        const y = f[f.indexOf(g) + 1];
        y ? c = Mg(n, y.index, t.length) : c = nk(n, t.length);
      } else {
        const y = f.sort(Ya).find((v) => v.index > n);
        y ? c = Mg(n, y.index, t.length) : c = nk(n, t.length);
      }
    } else {
      const g = f.length && f[f.length - 1];
      c = g ? nk(g.index, t.length) : tj(t.length);
    }
    let p;
    for (let g = 0; g < t.length; g++) {
      p = t[g];
      const y = this.getShapeById(p), v = this.getPagePointById(p);
      if (!y || !v)
        continue;
      const S = De.applyToPoint(De.Inverse(a), v), x = this.getPageRotation(y) - s;
      r.push({
        id: y.id,
        type: y.type,
        parentId: e,
        x: S.x,
        y: S.y,
        rotation: x,
        index: c[g]
      });
    }
    return this.updateShapes(r), this;
  }
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * 	app.select('id1')
   * 	app.select('id1', 'id2')
   * ```
   *
   * @param ids - The ids to select.
   * @public
   */
  select(...t) {
    return this.setSelectedIds(t), this;
  }
  /**
   * Remove a shpae from the existing set of selected shapes.
   *
   * @example
   * ```ts
   * 	app.deselect(shape.id)
   * ```
   *
   * @public
   */
  deselect(...t) {
    const { selectedIds: e } = this;
    return e.length > 0 && t.length > 0 && this.setSelectedIds(e.filter((n) => !t.includes(n))), this;
  }
  /**
   * Select all direct children of the current page.
   *
   * @example
   * ```ts
   * 	app.selectAll()
   * ```
   *
   * @public
   */
  selectAll() {
    const t = this.getSortedChildIds(this.currentPageId);
    return t.length <= 0 ? this : (this.setSelectedIds(t), this);
  }
  getShapesAndDescendantsInOrder(t) {
    const e = [], n = /* @__PURE__ */ new Set(), r = [...t];
    for (; r.length > 0; ) {
      const c = r.pop();
      if (!c)
        break;
      n.has(c) || (e.push(c), this.getSortedChildIds(c).forEach((f) => {
        r.push(f);
      }));
    }
    const a = e.map((c) => this.getShapeById(c)).filter((c) => c.type !== "group"), { sortedShapesArray: s } = this;
    return a.sort((c, f) => s.indexOf(c) - s.indexOf(f)), a;
  }
  /**
   * Clear the selection.
   *
   * @example
   * ```ts
   * 	app.selectNone()
   * ```
   *
   * @public
   */
  selectNone() {
    return this.selectedIds.length > 0 && this.setSelectedIds([]), this;
  }
  /**
   * Set the current page.
   *
   * @example
   * ```ts
   * 	app.setCurrentPageId('page1')
   * ```
   *
   * @param pageId - The id of the page to set as the current page.
   * @public
   */
  setCurrentPageId(t) {
    return this._setCurrentPageId(t), this;
  }
  /** @internal */
  _setCurrentPageId = this.history.createCommand(
    "setCurrentPage",
    (t) => {
      if (!this.store.has(t)) {
        console.error("Tried to set the current page id to a page that doesn't exist.");
        return;
      }
      return {
        data: { pageId: t, prev: this.currentPageId },
        squashing: !0,
        preservesRedoStack: !0
      };
    },
    {
      do: ({ pageId: t }) => {
        if (!this.getPageStateByPageId(t)) {
          const e = Xy.create({});
          this.store.put([
            e,
            qy.create({
              pageId: t,
              instanceId: this.instanceId,
              cameraId: e.id
            })
          ]);
        }
        this.store.put([{ ...this.instanceState, currentPageId: t }]), this.updateCullingBounds();
      },
      undo: ({ prev: t }) => {
        this.store.put([{ ...this.instanceState, currentPageId: t }]), this.updateCullingBounds();
      },
      squash: ({ prev: t }, { pageId: e }) => ({ pageId: e, prev: t })
    }
  );
  /** Set the current user tab state */
  updateInstanceState(t, e = !1, n = !1) {
    return this._updateInstanceState(t, e, n), this;
  }
  /** @internal */
  _updateInstanceState = this.history.createCommand(
    "updateTabState",
    (t, e = !1, n = !1) => {
      const r = this.instanceState, a = { ...r, ...t };
      return {
        data: { prev: r, next: a },
        squashing: n,
        ephemeral: e
      };
    },
    {
      do: ({ next: t }) => {
        this.store.put([t]);
      },
      undo: ({ prev: t }) => {
        this.store.put([t]);
      },
      squash({ prev: t }, { next: e }) {
        return { prev: t, next: e };
      }
    }
  );
  get hoveredId() {
    return this.pageState.hoveredId;
  }
  get hoveredShape() {
    return this.hoveredId ? this.getShapeById(this.hoveredId) ?? null : null;
  }
  /**
   * Set the current hovered shape.
   *
   * @example
   * ```ts
   * 	app.setHoveredId('box1')
   * 	app.setHoveredId() // Clears the hovered shape.
   * ```
   *
   * @param id - The id of the page to set as the current page
   * @public
   */
  setHoveredId(t = null) {
    return t === this.pageState.hoveredId ? this : (this.setInstancePageState({ hoveredId: t }, !0), this);
  }
  /**
   * Set the current erasing shapes.
   *
   * @example
   * ```ts
   * 	app.setErasingIds(['box1', 'box2'])
   * 	app.setErasingIds() // Clears the erasing set
   * ```
   *
   * @param ids - The ids of shapes to set as erasing.
   * @public
   */
  setErasingIds(t = []) {
    const e = this.erasingIdsSet;
    return t.length === e.size && t.every((n) => e.has(n)) ? this : (this.setInstancePageState({ erasingIds: t }, !0), this);
  }
  /**
   * Set the current cursor.
   *
   * @example
   * ```ts
   * 	app.setCursor({ type: 'default' })
   * 	app.setCursor({ type: 'default', rotation: Math.PI / 2, color: 'red' })
   * ```
   *
   * @param cursor - A partial of the cursor object.
   * @public
   */
  setCursor(t) {
    const e = this.cursor, n = {
      ...e,
      rotation: 0,
      ...t
    };
    return e.type === n.type && e.rotation === n.rotation && e.color === n.color || this.updateInstanceState({ cursor: n }, !0), this;
  }
  /**
   * Set the current scribble.
   *
   * @example
   * ```ts
   * 	app.setScribble(nextScribble)
   * 	app.setScribble() // clears the scribble
   * ```
   *
   * @param scribble - The new scribble object.
   * @public
   */
  setScribble(t = null) {
    return this.updateInstanceState({ scribble: t }, !0), this;
  }
  /**
   * Set the current brush.
   *
   * @example
   * ```ts
   * 	app.setBrush({ x: 0, y: 0, w: 100, h: 100 })
   * 	app.setBrush() // Clears the brush
   * ```
   *
   * @param brush - The brush box model to set, or null for no brush model.
   * @public
   */
  setBrush(t = null) {
    return !t && this.brush, this.batch(() => {
      this.updateInstanceState({ brush: t }, !0);
    }), this;
  }
  /**
   * Rotate shapes by a delta in radians.
   *
   * @example
   * ```ts
   * 	app.rotateShapesBy(['box1', 'box2'], Math.PI)
   * 	app.rotateShapesBy(['box1', 'box2'], 'Math.PI / 2)
   * ```
   *
   * @param ids - The ids of the shapes to move.
   * @param delta - The delta in radians to apply to the selection rotation.
   */
  rotateShapesBy(t, e) {
    if (t.length <= 0)
      return this;
    const n = nj({ app: this });
    return dx({ delta: e, snapshot: n, app: this, stage: "one-off" }), this;
  }
  /**
   * Move shapes by a delta.
   *
   * @example
   * ```ts
   * 	app.nudgeShapes(['box1', 'box2'], 'left')
   * 	app.nudgeShapes(['box1', 'box2'], 'left', true)
   * ```
   *
   * @param ids - The ids of the shapes to move.
   * @param direction - The direction in which to move the shapes.
   * @param major - Whether this is a major nudge, e.g. a shift + arrow nudge.
   */
  nudgeShapes(t, e, n = !1) {
    if (t.length <= 0)
      return this;
    const r = this.isGridMode ? n ? this.gridSize * cQ : this.gridSize : n ? oQ : aQ, a = O.Mul(uQ[e], r), s = [];
    for (const c of t) {
      const f = this.getShapeById(c);
      if (!f)
        throw Error(`Could not find a shape with the id ${c}.`);
      const p = this.getDeltaInParentSpace(f, a), g = this.getShapeUtil(f).onTranslateStart?.(f);
      s.push(
        g ? {
          ...g,
          x: f.x + p.x,
          y: f.y + p.y
        } : {
          id: c,
          x: f.x + p.x,
          y: f.y + p.y,
          type: f.type
        }
      );
    }
    return this.updateShapes(s), this;
  }
  /**
   * Duplicate shapes.
   *
   * @example
   * ```ts
   * 	app.duplicateShapes()
   * 	app.duplicateShapes(['id1', 'id2'])
   * 	app.duplicateShapes(['id1', 'id2'], { x: 8, y: 8 })
   * ```
   *
   * @param ids - The ids of the shapes to duplicate. Defaults to the ids of the selected
   *   shapes.
   * @param offset - The offset (in pixels) to apply to the duplicated shapes.
   * @public
   */
  duplicateShapes(t = this.selectedIds, e) {
    if (t.length <= 0)
      return this;
    const n = new Set(t), r = [], a = [...t];
    for (; a.length > 0; ) {
      const f = a.pop();
      if (!f)
        break;
      r.push(f), this.getSortedChildIds(f).forEach((p) => a.push(p));
    }
    r.reverse();
    const s = new Map(r.map((f) => [f, this.createShapeId()])), c = Gt(
      r.map((f) => {
        const p = this.getShapeById(f);
        if (!p)
          return null;
        const g = s.get(f);
        let y = 0, v = 0;
        if (e && n.has(f)) {
          const j = this.getParentTransform(p), L = new O(e.x, e.y).rot(
            -De.Decompose(j).rotation
          );
          y = L.x, v = L.y;
        }
        const S = p.parentId ?? this.currentPageId, x = this.getSortedChildIds(S), _ = x.indexOf(p.id), T = x[_ + 1], I = T ? this.getShapeById(T) : null, D = I ? Hy(p.index, I.index) : Mu(p.index), N = {
          ...Tc(p),
          id: g,
          x: p.x + y,
          y: p.y + v,
          index: D
        };
        if (ro.is(p) && ro.is(N)) {
          if (p.props.start.type === "binding") {
            const j = s.get(p.props.start.boundShapeId);
            if (j)
              N.props.start.boundShapeId = j;
            else {
              const L = this.getPageBoundsById(p.props.start.boundShapeId), z = new O(
                p.props.start.normalizedAnchor.x * L.width + L.minX,
                p.props.start.normalizedAnchor.y * L.height + L.minY
              ), F = De.applyToPoint(
                De.Inverse(this.getTransform(N)),
                z
              );
              N.props.start = {
                type: "point",
                x: F.x + y,
                y: F.y + v
              };
            }
          }
          if (p.props.end.type === "binding") {
            const j = s.get(p.props.end.boundShapeId);
            if (j)
              N.props.end.boundShapeId = j;
            else {
              const L = this.getPageBoundsById(p.props.end.boundShapeId), z = new O(
                p.props.end.normalizedAnchor.x * L.width + L.minX,
                p.props.end.normalizedAnchor.y * L.height + L.minY
              ), F = De.applyToPoint(
                De.Inverse(this.getTransform(N)),
                z
              );
              N.props.end = {
                type: "point",
                x: F.x + y,
                y: F.y + v
              };
            }
          }
        }
        return N;
      })
    );
    return c.forEach((f) => {
      Fs(f.parentId) && s.has(f.parentId) && (f.parentId = s.get(f.parentId));
    }), this.history.batch(() => {
      const f = c.length + this.shapeIds.size > wp;
      f && Fw(this);
      const p = f ? c.slice(0, wp - this.shapeIds.size) : c, g = p.map((y) => y.id);
      if (this.createShapes(p), this.setSelectedIds(g), e !== void 0) {
        const { viewportPageBounds: y, selectedPageBounds: v } = this;
        v && !y.contains(v) && this.centerOnPoint(v.center.x, v.center.y, {
          duration: Au
        });
      }
    }), this;
  }
  /**
   * Set the current props (generally styles).
   *
   * @example
   * ```ts
   * 	app.setProp('color', 'red')
   * 	app.setProp('color', 'red', true)
   * ```
   *
   * @param key - The key to set.
   * @param value - The value to set.
   * @param ephemeral - Whether the style is ephemeral. Defaults to false.
   * @public
   */
  setProp(t, e, n = !1, r = !1) {
    const a = [], s = (c) => {
      const f = this.getSortedChildIds(c);
      for (const p of f) {
        const g = this.getShapeById(p);
        g?.type === "group" && s(g.id), a.push(g);
      }
    };
    return this.history.batch(() => {
      if (this.updateInstanceState(
        {
          propsForNextShape: tD(this.instanceState.propsForNextShape, {
            [t]: e
          })
        },
        n,
        r
      ), this.isIn("select")) {
        const {
          pageState: { selectedIds: c }
        } = this;
        if (c.length > 0) {
          const f = Gt(
            c.map((p) => {
              const g = this.getShapeById(p);
              if (g?.type === "group") {
                const y = this.getSortedChildIds(g.id);
                for (const v of y) {
                  const S = this.getShapeById(v);
                  S?.type === "group" && s(S.id), a.push(S);
                }
                return a;
              } else
                return g;
            })
          ).flat().filter(
            (p) => p.props[t] !== void 0 && p?.type !== "group"
          );
          if (this.updateShapes(
            f.map((p) => {
              const g = { ...p.props, [t]: e };
              return t === "color" && "labelColor" in g && (g.labelColor = "black"), {
                id: p.id,
                type: p.type,
                props: g
              };
            }),
            n
          ), t !== "color" && t !== "opacity") {
            const p = [];
            for (const g of f) {
              const y = this.getShapeById(g.id);
              if (!y)
                continue;
              const v = this.getShapeUtil(y), S = v.bounds(g), x = v.bounds(y), _ = { id: g.id, type: g.type };
              let T = !1;
              if (S.width !== x.width)
                if (T = !0, b1.is(g))
                  switch (g.props.align) {
                    case "middle": {
                      _.x = y.x + (S.width - x.width) / 2;
                      break;
                    }
                    case "end": {
                      _.x = y.x + S.width - x.width;
                      break;
                    }
                  }
                else
                  _.x = y.x + (S.width - x.width) / 2;
              S.height !== x.height && (T = !0, _.y = y.y + (S.height - x.height) / 2), T && p.push(_);
            }
            p.length && this.updateShapes(p, n);
          }
        }
      }
      this.updateInstanceState(
        {
          propsForNextShape: tD(this.instanceState.propsForNextShape, {
            [t]: e
          })
        },
        n,
        r
      );
    }), this;
  }
  /** @internal */
  _willSetInitialBounds = !0;
  /** @internal */
  _setCamera(t, e, n = this.camera.z) {
    const r = this.camera;
    return r.x === t && r.y === e && r.z === n ? this : (this.store.put([{ ...r, x: t, y: e, z: n }]), this._cameraManager.tick(), this.emit("change-camera", this.camera), this);
  }
  /**
   * Set the current camera.
   *
   * @example
   * ```ts
   * 	app.setCamera(0, 0)
   * 	app.setCamera(0, 0, 1)
   * ```
   *
   * @param x - The camera's x position.
   * @param y - The camera's y position.
   * @param z - The camera's z position. Defaults to the current zoom.
   *
   * @public
   */
  setCamera(t, e, n = this.camera.z) {
    return this.stopCameraAnimation(), t = Number.isNaN(t) ? 0 : t, e = Number.isNaN(e) ? 0 : e, n = Number.isNaN(n) ? 1 : n, this._setCamera(t, e, n), this;
  }
  /**
   * Animate the camera.
   *
   * @example
   * ```ts
   * 	app.animateCamera(0, 0)
   * 	app.animateCamera(0, 0, 1)
   * 	app.animateCamera(0, 0, 1, { duration: 1000, easing: (t) => t * t })
   * ```
   *
   * @param x - The camera's x position.
   * @param y - The camera's y position.
   * @param z - The camera's z position. Defaults to the current zoom.
   * @param opts - Options for the animation.
   *
   * @public
   */
  animateCamera(t, e, n = this.camera.z, r = qO) {
    t = Number.isNaN(t) ? 0 : t, e = Number.isNaN(e) ? 0 : e, n = Number.isNaN(n) ? 1 : n;
    const { width: a, height: s } = this.viewportScreenBounds, c = a / n, f = s / n, p = new ot(-t, -e, c, f);
    return this._animateToViewport(p, r);
  }
  /**
   * Center the camera on a point (in page space).
   *
   * @example
   * ```ts
   * 	app.centerOnPoint(100, 100)
   * ```
   *
   * @param x - The x position of the point.
   * @param y - The y position of the point.
   * @param opts - The options for an animation.
   *
   * @public
   */
  centerOnPoint(t, e, n) {
    if (!this.canMoveCamera)
      return this;
    const {
      viewportPageBounds: { width: r, height: a },
      camera: s
    } = this;
    return n?.duration ? this.animateCamera(-(t - r / 2), -(e - a / 2), s.z, n) : this.setCamera(-(t - r / 2), -(e - a / 2), s.z), this;
  }
  /**
   * Zoom the camera to fit the current page's content in the viewport.
   *
   * @example
   * ```ts
   * 	app.zoomToFit()
   * ```
   *
   * @public
   */
  zoomToFit(t) {
    if (!this.canMoveCamera)
      return this;
    const e = [...this.shapeIds];
    if (e.length <= 0)
      return this;
    const n = ot.Common(Gt(e.map((r) => this.getPageBoundsById(r))));
    return this.zoomToBounds(
      n.minX,
      n.minY,
      n.width,
      n.height,
      void 0,
      t
    ), this;
  }
  /**
   * Set the zoom back to 100%.
   *
   * @example
   * ```ts
   * 	app.resetZoom()
   * ```
   *
   * @param opts - The options for an animation.
   * @public
   */
  resetZoom(t = this.viewportScreenCenter, e) {
    if (!this.canMoveCamera)
      return this;
    const { x: n, y: r, z: a } = this.camera, { x: s, y: c } = t;
    return e?.duration ? this.animateCamera(n + (s / 1 - s) - (s / a - s), r + (c / 1 - c) - (c / a - c), 1, e) : this.setCamera(n + (s / 1 - s) - (s / a - s), r + (c / 1 - c) - (c / a - c), 1), this;
  }
  /**
   * Zoom the camera in.
   *
   * @example
   * ```ts
   * 	app.zoomIn()
   * 	app.zoomIn(app.viewportScreenCenter, { duration: 120 })
   * 	app.zoomIn(app.inputs.currentScreenPoint, { duration: 120 })
   * ```
   *
   * @param opts - The options for an animation.
   * @public
   */
  zoomIn(t = this.viewportScreenCenter, e) {
    if (!this.canMoveCamera)
      return this;
    const { x: n, y: r, z: a } = this.camera;
    let s = kp;
    for (let p = 1; p < Rg.length; p++) {
      const g = Rg[p - 1], y = Rg[p];
      if (!(y - a <= (y - g) / 2)) {
        s = y;
        break;
      }
    }
    const { x: c, y: f } = t;
    return e?.duration ? this.animateCamera(
      n + (c / s - c) - (c / a - c),
      r + (f / s - f) - (f / a - f),
      s,
      e
    ) : this.setCamera(n + (c / s - c) - (c / a - c), r + (f / s - f) - (f / a - f), s), this;
  }
  /**
   * Zoom the camera out.
   *
   * @example
   * ```ts
   * 	app.zoomOut()
   * 	app.zoomOut(app.viewportScreenCenter, { duration: 120 })
   * 	app.zoomOut(app.inputs.currentScreenPoint, { duration: 120 })
   * ```
   *
   * @param opts - The options for an animation.
   * @public
   */
  zoomOut(t = this.viewportScreenCenter, e) {
    if (!this.canMoveCamera)
      return this;
    const { x: n, y: r, z: a } = this.camera;
    let s = Nw;
    for (let p = Rg.length - 1; p > 0; p--) {
      const g = Rg[p - 1], y = Rg[p];
      if (!(y - a >= (y - g) / 2)) {
        s = g;
        break;
      }
    }
    const { x: c, y: f } = t;
    return e?.duration ? this.animateCamera(
      n + (c / s - c) - (c / a - c),
      r + (f / s - f) - (f / a - f),
      s,
      e
    ) : this.setCamera(n + (c / s - c) - (c / a - c), r + (f / s - f) - (f / a - f), s), this;
  }
  /**
   * Zoom the camera to fit the current selection in the viewport.
   *
   * @example
   * ```ts
   * 	app.zoomToSelection()
   * ```
   *
   * @param opts - The options for an animation.
   * @public
   */
  zoomToSelection(t) {
    if (!this.canMoveCamera)
      return this;
    const e = this.selectedIds;
    if (e.length <= 0)
      return this;
    const n = ot.Common(Gt(e.map((r) => this.getPageBoundsById(r))));
    return this.zoomToBounds(
      n.minX,
      n.minY,
      n.width,
      n.height,
      Math.max(1, this.camera.z),
      t
    ), this;
  }
  /**
   * Pan or pan/zoom the selected ids into view. This method tries to not
   * change the zoom if possible.
   *
   * @param ids - The ids of the shapes to pan and zoom into view.
   * @param opts - The options for an animation.
   * @public
   */
  panZoomIntoView(t, e) {
    if (!this.canMoveCamera)
      return this;
    if (t.length <= 0)
      return this;
    const n = ot.Common(Gt(t.map((a) => this.getPageBoundsById(a)))), { viewportPageBounds: r } = this;
    if (r.h < n.h || r.w < n.w)
      return this.zoomToBounds(
        n.minX,
        n.minY,
        n.width,
        n.height,
        this.camera.z,
        e
      ), this;
    {
      const a = this._activeAreaManager.offsets.value, s = r.y + a.top, c = r.maxY - a.right, f = r.maxY - a.bottom, p = r.x + a.left, g = n.y, y = n.maxX, v = n.maxY, S = n.x;
      let x = 0, _ = 0;
      f < v ? _ = f - v : s > g && (_ = s - g), c < y ? x = c - y : p > S && (x = p - S);
      const { camera: T } = this;
      e?.duration ? this.animateCamera(T.x + x, T.y + _, T.z, e) : this.setCamera(T.x + x, T.y + _, T.z);
    }
    return this;
  }
  /**
   * Zoom the camera to fit a bounding box (in page space).
   *
   * @example
   * ```ts
   * 	app.zoomToBounds(0, 0, 100, 100)
   * ```
   *
   * @param x - The bounding box's x position.
   * @param y - The bounding box's y position.
   * @param width - The bounding box's width.
   * @param height - The bounding box's height.
   * @param targetZoom - The desired zoom level. Defaults to 0.1.
   * @public
   */
  zoomToBounds(t, e, n, r, a, s) {
    if (!this.canMoveCamera)
      return this;
    const { viewportScreenBounds: c } = this, f = Math.min(256, c.width * 0.28);
    let p = $u(
      Math.min(
        (c.width - f) / n,
        (c.height - f) / r
      ),
      Nw,
      kp
    );
    return a !== void 0 && (p = Math.min(a, p)), s?.duration ? this.animateCamera(
      -t + (c.width - n * p) / 2 / p,
      -e + (c.height - r * p) / 2 / p,
      p,
      s
    ) : this.setCamera(
      -t + (c.width - n * p) / 2 / p,
      -e + (c.height - r * p) / 2 / p,
      p
    ), this;
  }
  /**
   * Pan the camera.
   *
   * @example
   * ```ts
   * 	app.pan(100, 100)
   * 	app.pan(100, 100, {duration: 1000})
   * ```
   *
   * @param dx - The amount to pan on the x axis.
   * @param dy - The amount to pan on the y axis.
   * @param opts - the animation options
   */
  pan(t, e, n) {
    if (!this.canMoveCamera)
      return this;
    const { camera: r } = this, { x: a, y: s, z: c } = r, f = new O(t, e).div(c);
    return n?.duration ?? 0 > 0 ? this.animateCamera(a + f.x, s + f.y, c, n) : (this.setCamera(a + f.x, s + f.y, c), this);
  }
  /**
   * Stop the current camera animation, if any.
   *
   * @public
   */
  stopCameraAnimation() {
    return this.emit("stop-camera-animation"), this;
  }
  /** @internal */
  _viewportAnimation = null;
  /** @internal */
  _animateViewport(t) {
    if (!this._viewportAnimation)
      return;
    const e = () => {
      this.removeListener("tick", this._animateViewport), this.removeListener("stop-camera-animation", e);
    };
    this.once("stop-camera-animation", e), this._viewportAnimation.elapsed += t;
    const { elapsed: n, easing: r, duration: a, start: s, end: c } = this._viewportAnimation;
    if (n > a) {
      const D = this.viewportScreenBounds.width / c.width, N = -c.x, j = -c.y;
      this._setCamera(N, j, D), this.removeListener("tick", this._animateViewport), this._viewportAnimation = null;
      return;
    }
    const f = a - n, p = r(1 - f / a), g = s.minX + (c.minX - s.minX) * p, y = s.minY + (c.minY - s.minY) * p, v = s.maxX + (c.maxX - s.maxX) * p, S = s.maxY + (c.maxY - s.maxY) * p, x = new ot(g, y, v - g, S - y), _ = this.viewportScreenBounds.width / x.width, T = -x.x, I = -x.y;
    this._setCamera(T, I, _);
  }
  /** @internal */
  _animateToViewport(t, e = {}) {
    const { duration: n = 0, easing: r = fa.easeInOutCubic } = e, a = this.viewportPageBounds.clone();
    return this.stopCameraAnimation(), this._viewportAnimation = {
      elapsed: 0,
      duration: n,
      easing: r,
      start: a,
      end: t
    }, this.addListener("tick", this._animateViewport), this;
  }
  slideCamera(t = {}) {
    if (!this.canMoveCamera)
      return this;
    const { speed: e, direction: n, friction: r, speedThreshold: a = 0.01 } = t;
    let s = e;
    this.stopCameraAnimation();
    const c = () => {
      this.removeListener("tick", f), this.removeListener("stop-camera-animation", c);
    };
    this.once("stop-camera-animation", c);
    const f = (p) => {
      const { x: g, y, z: v } = this.camera, S = n.clone().mul(s * p / v);
      s *= 1 - r, s < a ? c() : this._setCamera(g + S.x, y + S.y, v);
    };
    return this.addListener("tick", f), this;
  }
  animateToShape(t, e = qO) {
    if (!this.canMoveCamera)
      return this;
    const n = Mj(this), r = n.width / n.height, a = this.getPageBoundsById(t);
    if (!a)
      return this;
    const s = a.width / a.height, c = a.clone(), f = a.width / n.width;
    return c.width += (n.left + n.right) * f, c.height += (n.top + n.bottom) * f, c.x -= n.left * f, c.y -= n.top * f, s > r ? (c.height = a.width / r, c.y -= (c.height - a.height) / 2) : (c.width = a.height * r, c.x -= (c.width - a.width) / 2), this._animateToViewport(c, e);
  }
  /**
   * Blur the app, cancelling any interaction state.
   *
   * @example
   * ```ts
   * 	app.blur()
   * ```
   *
   * @public
   */
  blur() {
    return this.dispatch({ type: "misc", name: "blur" }), this;
  }
  /**
   * Dispatch a cancel event.
   *
   * @example
   * ```ts
   * 	app.cancel()
   * ```
   *
   * @public
   */
  cancel() {
    return this.dispatch({ type: "misc", name: "cancel" }), this;
  }
  /**
   * Dispatch an interrupt event.
   *
   * @example
   * ```ts
   * 	app.interrupt()
   * ```
   *
   * @public
   */
  interrupt() {
    return this.dispatch({ type: "misc", name: "interrupt" }), this;
  }
  /**
   * Dispatch a complete event.
   *
   * @example
   * ```ts
   * 	app.complete()
   * ```
   *
   * @public
   */
  complete() {
    return this.dispatch({ type: "misc", name: "complete" }), this;
  }
  /* -------------------- Callbacks ------------------- */
  /**
   * A callback fired when a file is converted to an asset. This callback should return the asset partial.
   *
   * @example
   * ```ts
   * 	app.onCreateAssetFromFile(myFile)
   * ```
   *
   * @param file - The file to upload.
   * @public
   */
  async onCreateAssetFromFile(t) {
    return await wZ(t);
  }
  /**
   * A callback fired when a URL is converted to a bookmark. This callback should return the
   * metadata for the bookmark.
   *
   * @example
   * ```ts
   * 	app.onCreateBookmarkFromUrl(url, id)
   * ```
   *
   * @param url - The url that was created.
   * @public
   */
  async onCreateBookmarkFromUrl(t) {
    try {
      const n = await (await fetch(t, { method: "GET", mode: "no-cors" })).text(), r = new DOMParser().parseFromString(n, "text/html");
      return {
        image: r.head.querySelector('meta[property="og:image"]')?.getAttribute("content") ?? "",
        title: r.head.querySelector('meta[property="og:title"]')?.getAttribute("content") ?? "",
        description: r.head.querySelector('meta[property="og:description"]')?.getAttribute("content") ?? ""
      };
    } catch (e) {
      return console.error(e), { image: "", title: "", description: "" };
    }
  }
  /* ---------------- Text Measurement ---------------- */
  /**
   * A helper for measuring text.
   *
   * @public
   */
  textMeasure;
  /* --------------------- Groups --------------------- */
  groupShapes(t = this.selectedIds, e = io()) {
    if (this.isReadOnly)
      return this;
    if (t.length <= 1)
      return this;
    const n = Gt(t.map((y) => this.getShapeById(y))), r = n.sort(Ya).map((y) => y.id), a = ot.Common(Gt(n.map((y) => this.getPageBounds(y)))), { x: s, y: c } = a.point, f = this.findCommonAncestor(n) ?? this.currentPageId;
    if (this.currentToolId !== "select")
      return this;
    this.isIn("select.idle") || this.cancel();
    const p = n.filter((y) => y.parentId === f).sort(Ya), g = p[p.length - 1]?.index;
    return this.batch(() => {
      this.createShapes([
        {
          id: e,
          type: "group",
          parentId: f,
          index: g,
          x: s,
          y: c,
          props: {
            opacity: "1"
          }
        }
      ]), this.reparentShapesById(r, e), this.select(e);
    }), this;
  }
  ungroupShapes(t = this.selectedIds) {
    if (this.isReadOnly)
      return this;
    if (t.length === 0)
      return this;
    if (this.currentToolId !== "select")
      return this;
    this.isIn("select.idle") || this.cancel();
    const e = /* @__PURE__ */ new Set(), n = Gt(t.map((a) => this.getShapeById(a))), r = [];
    return n.forEach((a) => {
      _j.is(a) ? r.push(a) : e.add(a.id);
    }), r.length === 0 ? this : (this.batch(() => {
      let a;
      for (let s = 0, c = r.length; s < c; s++) {
        a = r[s];
        const f = this.getSortedChildIds(a.id);
        for (let p = 0, g = f.length; p < g; p++)
          e.add(f[p]);
        this.reparentShapesById(f, a.parentId, a.index);
      }
      this.deleteShapes(r.map((s) => s.id)), this.select(...e);
    }), this);
  }
};
let en = Oj;
ln([
  pt
], en.prototype, "canMoveCamera", 1);
ln([
  pt
], en.prototype, "_pageTransformCache", 1);
ln([
  pt
], en.prototype, "_pageBoundsCache", 1);
ln([
  pt
], en.prototype, "_pageMaskCache", 1);
ln([
  pt
], en.prototype, "_clipPathCache", 1);
ln([
  pt
], en.prototype, "canUndo", 1);
ln([
  pt
], en.prototype, "canRedo", 1);
ln([
  pt
], en.prototype, "erasingIds", 1);
ln([
  pt
], en.prototype, "hintingIds", 1);
ln([
  pt
], en.prototype, "erasingIdsSet", 1);
ln([
  pt
], en.prototype, "allowUiPaste", 1);
ln([
  pt
], en.prototype, "props", 1);
ln([
  pt
], en.prototype, "_arrowBindingsIndex", 1);
ln([
  pt
], en.prototype, "documentSettings", 1);
ln([
  pt
], en.prototype, "_userDocumentSettings", 1);
ln([
  pt
], en.prototype, "_pageState", 1);
ln([
  pt
], en.prototype, "camera", 1);
ln([
  pt
], en.prototype, "zoomLevel", 1);
ln([
  pt
], en.prototype, "selectedIds", 1);
ln([
  pt
], en.prototype, "selectedIdsSet", 1);
ln([
  pt
], en.prototype, "_pages", 1);
ln([
  pt
], en.prototype, "pages", 1);
ln([
  pt
], en.prototype, "_pageStates", 1);
ln([
  pt
], en.prototype, "renderingShapes", 1);
ln([
  pt
], en.prototype, "allShapesCommonBounds", 1);
ln([
  pt
], en.prototype, "viewportScreenBounds", 1);
ln([
  pt
], en.prototype, "viewportScreenCenter", 1);
ln([
  pt
], en.prototype, "viewportPageBounds", 1);
ln([
  pt
], en.prototype, "cullingBounds", 1);
ln([
  pt
], en.prototype, "cullingBoundsExpanded", 1);
ln([
  pt
], en.prototype, "viewportPageCenter", 1);
ln([
  pt
], en.prototype, "editingShape", 1);
ln([
  pt
], en.prototype, "selectedPageBounds", 1);
ln([
  pt
], en.prototype, "selectionRotation", 1);
ln([
  pt
], en.prototype, "selectionBounds", 1);
ln([
  pt
], en.prototype, "selectionPageCenter", 1);
ln([
  pt
], en.prototype, "shapesArray", 1);
ln([
  pt
], en.prototype, "sortedShapesArray", 1);
ln([
  pt
], en.prototype, "selectedShapes", 1);
ln([
  pt
], en.prototype, "onlySelectedShape", 1);
ln([
  pt
], en.prototype, "_currentUserPresence", 1);
ln([
  pt
], en.prototype, "_assets", 1);
ln([
  pt
], en.prototype, "hoveredId", 1);
ln([
  pt
], en.prototype, "hoveredShape", 1);
function Fw(t, e = t.currentPageId) {
  const n = t.getPageById(e).name;
  t.emit("max-shapes", { name: n, pageId: e, count: wp });
}
const Dj = {
  fonts: {
    draw: "/fonts/Shantell_Sans-Normal-SemiBold.woff2",
    serif: "/fonts/IBMPlexSerif-Medium.woff2",
    sansSerif: "/fonts/IBMPlexSans-Medium.woff2",
    monospace: "/fonts/IBMPlexMono-Medium.woff2"
  }
}, dre = { error: null };
class Ib extends k.Component {
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  state = dre;
  componentDidCatch(e) {
    this.props.onError?.(e);
  }
  render() {
    const { error: e } = this.state;
    return e !== null ? this.props.fallback(e) : this.props.children;
  }
}
var Nj = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(t) {
  (function() {
    var e = {}.hasOwnProperty;
    function n() {
      for (var r = [], a = 0; a < arguments.length; a++) {
        var s = arguments[a];
        if (s) {
          var c = typeof s;
          if (c === "string" || c === "number")
            r.push(s);
          else if (Array.isArray(s)) {
            if (s.length) {
              var f = n.apply(null, s);
              f && r.push(f);
            }
          } else if (c === "object") {
            if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) {
              r.push(s.toString());
              continue;
            }
            for (var p in s)
              e.call(s, p) && s[p] && r.push(p);
          }
        }
      }
      return r.join(" ");
    }
    t.exports ? (n.default = n, t.exports = n) : window.classNames = n;
  })();
})(Nj);
var fre = Nj.exports;
const $n = /* @__PURE__ */ jp(fre), pre = dn(function() {
  const e = Ge(), n = e.brush, r = e.isIn("select.brushing");
  return !n || !r ? null : /* @__PURE__ */ E.jsx(
    "rect",
    {
      className: "rs-brush",
      width: ze(Math.max(1, n.w)),
      height: ze(Math.max(1, n.h)),
      transform: `translate(${n.x},${n.y})`
    }
  );
}), hre = dn(function({ size: e }) {
  const n = Ge(), { x: r, y: a, z: s } = n.camera;
  return n.isGridMode ? /* @__PURE__ */ E.jsxs("svg", { className: "tl-grid", version: "1.1", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ E.jsx("defs", { children: QO.map(({ min: f, mid: p, step: g }, y) => /* @__PURE__ */ E.jsx(
      gre,
      {
        min: f,
        mid: p,
        step: g,
        x: r,
        y: a,
        z: s,
        size: e
      },
      `grid-layer-${y}`
    )) }),
    QO.map(({ step: f }, p) => /* @__PURE__ */ E.jsx("rect", { width: "100%", height: "100%", fill: `url(#grid-${f})` }, `grid-rect-${p}`))
  ] }) : null;
});
function gre({
  step: t,
  min: e,
  mid: n,
  size: r,
  x: a,
  y: s,
  z: c
}) {
  const f = t * r * c, p = 0.5 + a * c, g = 0.5 + s * c, y = p > 0 ? p % f : f + p % f, v = g > 0 ? g % f : f + g % f, S = c < n ? nP(c, [e, n], [0, 1]) : 1;
  return /* @__PURE__ */ E.jsx(
    "pattern",
    {
      id: `grid-${t}`,
      width: f,
      height: f,
      patternUnits: "userSpaceOnUse",
      children: /* @__PURE__ */ E.jsx("circle", { className: "tl-grid-dot", cx: y, cy: v, r: 1, opacity: S })
    },
    `grid-pattern-${t}`
  );
}
function mre({ id: t, handle: e }) {
  const n = aee(t, e.id), { x: r, y: a, type: s } = e;
  return /* @__PURE__ */ E.jsxs(
    "g",
    {
      className: $n("rs-handle", { "rs-handle-hint": s !== "vertex" }),
      "aria-label": "handle",
      transform: `translate(${r}, ${a})`,
      ...n,
      children: [
        /* @__PURE__ */ E.jsx("circle", { className: "rs-handle-bg" }),
        /* @__PURE__ */ E.jsx("circle", { className: "rs-handle-fg" })
      ]
    }
  );
}
const vre = 48, yre = dn(function() {
  const e = Ge(), n = e.zoomLevel, r = e.isChangingStyle, a = e.onlySelectedShape, s = e.isInAny("select.idle", "select.pointing_handle") && !r && !e.isReadOnly;
  if (!(a && s))
    return null;
  const f = e.getShapeUtil(a).handles?.(a);
  if (!f)
    return null;
  const p = e.getPageTransform(a);
  if (!p)
    return null;
  const g = [];
  for (let y = 0, v = f[y]; y < f.length; y++, v = f[y]) {
    if (v.type !== "vertex") {
      const S = f[y - 1], x = f[y + 1];
      if (S && x && Math.hypot(S.y - x.y, S.x - x.x) < vre / n)
        continue;
    }
    g.push(v);
  }
  return g.sort((y) => y.type === "vertex" ? 1 : -1), /* @__PURE__ */ E.jsx("g", { transform: De.toCssString(p), children: g.map((y) => /* @__PURE__ */ E.jsx(mre, { id: a.id, handle: y }, y.id)) });
}), bre = ({ zoom: t, point: e, color: n }) => e ? /* @__PURE__ */ E.jsx(
  "use",
  {
    href: "#cursor",
    transform: `translate(${e.x}, ${e.y}) scale(${1 / t})`,
    color: n
  }
) : null, Sre = k.memo(bre), wre = ({ zoom: t, point: e, color: n, viewport: r }) => {
  const a = $u(e.x, r.minX + 5 / t, r.maxX - 5 / t), s = $u(e.y, r.minY + 5 / t, r.maxY - 5 / t), c = RL(O.Angle(r.center, e));
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: /* @__PURE__ */ E.jsx(
    "use",
    {
      href: "#cursor_hint",
      transform: `translate(${a}, ${s}) scale(${1 / t}) rotate(${c})`,
      color: n
    }
  ) });
};
class xre {
  constructor(e) {
    this.shape = e;
  }
  equals(e) {
    return this.shape?.props === e?.shape?.props;
  }
}
const Ere = ({ shape: t, util: e }) => MI("Indicator:", () => e.indicator(t)), Cre = ({ app: t, id: e }) => {
  const n = un("shape", () => new xre(t.store.get(e)), [t, e]);
  return n.shape ? /* @__PURE__ */ E.jsx(
    Ib,
    {
      fallback: _re,
      onError: (r) => t.annotateError(r, { origin: "react.shapeIndicator", willCrashApp: !1 }),
      children: /* @__PURE__ */ E.jsx(Ere, { shape: n.shape, util: t.getShapeUtil(n.shape) })
    }
  ) : null;
};
function _re() {
  return /* @__PURE__ */ E.jsx("circle", { cx: 4, cy: 4, r: 8, strokeWidth: "1", stroke: "red" });
}
const w1 = k.memo(function({
  id: e,
  isHinting: n,
  color: r
}) {
  const a = Ge(), s = un(
    "transform",
    () => {
      const c = a.getPageTransformById(e);
      return c ? De.toCssString(c) : "";
    },
    [a, e]
  );
  return /* @__PURE__ */ E.jsx(
    "g",
    {
      className: $n("rs-shape-indicator", {
        "rs-shape-indicator__hinting": n
      }),
      transform: s,
      stroke: r ?? "var(--color-selected)",
      children: /* @__PURE__ */ E.jsx(Cre, { app: a, id: e })
    }
  );
}), Tre = () => {
  const t = Ge(), e = LL("time", Date.now());
  return It.useEffect(() => {
    const n = setInterval(() => e.set(Date.now()), 5e3);
    return () => clearInterval(n);
  }, [e]), k.useMemo(
    () => t.store.query.records("user_presence", () => ({
      lastActivityTimestamp: { gt: e.value - Pre },
      userId: { neq: t.userId }
    })),
    [t, e]
  );
}, kre = dn(function() {
  const e = Ge(), { viewportPageBounds: n, zoomLevel: r } = e, a = Tre();
  return /* @__PURE__ */ E.jsx("g", { children: a.value.map((s) => /* @__PURE__ */ E.jsx(
    Ire,
    {
      presence: s,
      viewport: n,
      zoom: r
    },
    s.id
  )) });
}), Pre = 1e3 * 10, Ire = dn(function({
  presence: e,
  viewport: n,
  zoom: r
}) {
  const a = Ge(), { userId: s, color: c, cursor: f, lastUsedInstanceId: p } = e, g = k.useMemo(
    () => p ? a.store.query.record("instance_page_state", () => ({
      instanceId: { eq: p },
      pageId: { eq: a.currentPageId }
    })) : null,
    [a, p]
  );
  if (!p || !g)
    return null;
  const y = a.store.get(p);
  if (!y || y.currentPageId !== a.currentPageId || !g.value)
    return null;
  const { brush: v, scribble: S } = y, { selectedIds: x } = g.value, _ = !(f.x < n.minX - 12 / r || f.y < n.minY - 16 / r || f.x > n.maxX - 12 / r || f.y > n.maxY - 16 / r);
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    v ? /* @__PURE__ */ E.jsxs(
      "g",
      {
        className: "rs-collaborator-brush",
        transform: `translate(${v.x},${v.y})`,
        children: [
          /* @__PURE__ */ E.jsx(
            "rect",
            {
              width: ze(Math.max(1, v.w)),
              height: ze(Math.max(1, v.h)),
              fill: c,
              opacity: 0.1
            }
          ),
          /* @__PURE__ */ E.jsx(
            "rect",
            {
              width: ze(Math.max(1, v.w)),
              height: ze(Math.max(1, v.h)),
              fill: "none",
              stroke: c,
              opacity: 0.1
            }
          )
        ]
      },
      s + "_brush"
    ) : null,
    _ ? /* @__PURE__ */ E.jsx(Sre, { point: f, color: c, zoom: r }, s + "_cursor") : /* @__PURE__ */ E.jsx(
      wre,
      {
        point: f,
        color: c,
        zoom: r,
        viewport: n
      },
      s + "_cursor_hint"
    ),
    S ? /* @__PURE__ */ E.jsx(
      Rre,
      {
        scribble: S,
        color: c,
        zoom: r
      },
      s + "_scribble"
    ) : null,
    x.map((T) => /* @__PURE__ */ E.jsx(w1, { id: T, color: c }, s + "_" + T))
  ] });
});
function Rre({
  scribble: t,
  color: e,
  zoom: n
}) {
  if (!t)
    return null;
  const r = ot.FromPoints(t.points), a = nf(
    f1(t.points, {
      size: t.size / n,
      start: { taper: !0 },
      last: t.state === "stopping" || r.width < 128 && r.height < 128
    })
  );
  return /* @__PURE__ */ E.jsx("path", { className: "tl-scribble", d: a, fill: e, opacity: 0.1 });
}
const $re = dn(function() {
  const e = Ge(), n = e.scribble, r = e.zoomLevel;
  if (!n)
    return null;
  const a = nf(
    f1(n.points, {
      size: n.size / r,
      start: { taper: !0, easing: fa.linear },
      last: !1,
      simulatePressure: !1
    })
  );
  return /* @__PURE__ */ E.jsx(
    "path",
    {
      className: "tl-scribble",
      d: a,
      fill: `var(--color-${n.color})`,
      opacity: n.opacity
    }
  );
}), Mre = dn(function() {
  const e = Ge(), n = k.useMemo(() => ({
    onPointerDown: (S) => {
      if (S.isKilled)
        return;
      xb(S.currentTarget, S);
      const x = {
        type: "pointer",
        target: "selection",
        name: "pointer_down",
        ...Yi(S, e.getContainer())
      };
      e.dispatch(x);
    },
    onPointerMove: (S) => {
      if (S.isKilled)
        return;
      const x = {
        type: "pointer",
        target: "selection",
        name: "pointer_move",
        ...Yi(S, e.getContainer())
      };
      e.dispatch(x);
    },
    onPointerUp: (S) => {
      if (S.isKilled)
        return;
      Eb(S.currentTarget, S);
      const x = {
        type: "pointer",
        target: "selection",
        name: "pointer_up",
        ...Yi(S, e.getContainer())
      };
      e.dispatch(x);
    },
    onPointerEnter: (S) => {
      if (S.isKilled)
        return;
      const x = {
        type: "pointer",
        target: "selection",
        name: "pointer_enter",
        ...Yi(S, e.getContainer())
      };
      e.dispatch(x);
    },
    onPointerLeave: (S) => {
      if (S.isKilled)
        return;
      const x = {
        type: "pointer",
        target: "selection",
        name: "pointer_leave",
        ...Yi(S, e.getContainer())
      };
      e.dispatch(x);
    }
  }), [e]), { selectionBounds: r, selectedIds: a } = e;
  if (!r)
    return null;
  const s = e.isInAny(
    "select.idle",
    "select.brushing",
    "select.scribble_brushing",
    "select.pointing_shape",
    "select.pointing_selection",
    "text.resizing"
  );
  if (a.length === 1) {
    const f = e.getShapeById(a[0]);
    if (!f || e.getShapeUtil(f).hideSelectionBoundsBg(f))
      return null;
  }
  const c = De.toCssString(
    De.Compose(
      De.Translate(r.minX, r.minY),
      De.Rotate(e.selectionRotation)
    )
  );
  return /* @__PURE__ */ E.jsx(
    "div",
    {
      className: "tlui-selection__bg",
      draggable: !1,
      style: {
        transform: c,
        width: ze(Math.max(1, r.width)),
        height: ze(Math.max(1, r.height)),
        pointerEvents: s ? "all" : "none",
        opacity: s ? 1 : 0
      },
      ...n
    }
  );
});
function Ec(t) {
  const e = Ge();
  return k.useMemo(
    function() {
      const a = (g) => {
        if (g.isKilled || g.button !== 0)
          return;
        const y = Dx(g.currentTarget);
        function v() {
          y.removeEventListener("pointerup", v), Eb(y, g);
        }
        xb(y, g), y.addEventListener("pointerup", v), e.dispatch({
          name: "pointer_down",
          type: "pointer",
          target: "selection",
          handle: t,
          ...Yi(g, e.getContainer())
        }), g.stopPropagation();
      };
      let s, c;
      function f(g) {
        g.isKilled || g.button === 0 && (g.clientX === s && g.clientY === c || (s = g.clientX, c = g.clientY, e.dispatch({
          name: "pointer_move",
          type: "pointer",
          target: "selection",
          handle: t,
          ...Yi(g, e.getContainer())
        })));
      }
      return {
        onPointerDown: a,
        onPointerMove: f,
        onPointerUp: (g) => {
          g.isKilled || g.button === 0 && e.dispatch({
            name: "pointer_up",
            type: "pointer",
            target: "selection",
            handle: t,
            ...Yi(g, e.getContainer())
          });
        }
      };
    },
    [e, t]
  );
}
const Are = Math.sqrt(Math.PI), Ore = function({
  cx: e,
  cy: n,
  size: r,
  isHidden: a,
  "data-wd": s
}) {
  const c = Ec("mobile_rotate");
  return /* @__PURE__ */ E.jsxs("g", { children: [
    /* @__PURE__ */ E.jsx(
      "circle",
      {
        "data-wd": s,
        className: $n("rs-transparent", "rs-mobile-rotate__bg", { "rs-hidden": a }),
        cx: e,
        cy: n,
        ...c
      }
    ),
    /* @__PURE__ */ E.jsx(
      "circle",
      {
        className: $n("rs-mobile-rotate__fg", { "rs-hidden": a }),
        cx: e,
        cy: n,
        r: r / Are
      }
    )
  ] });
}, Hw = function({
  cx: e,
  cy: n,
  targetSize: r,
  corner: a,
  cursor: s,
  isHidden: c,
  "data-wd": f
}) {
  const p = Ec(a);
  return /* @__PURE__ */ E.jsx(
    "rect",
    {
      className: $n("rs-transparent", "rs-rotate-corner", { "rs-hidden": c }),
      "data-wd": f,
      "aria-label": `${a} target`,
      x: ze(e - r * 3),
      y: ze(n - r * 3),
      width: ze(Math.max(1, r * 3)),
      height: ze(Math.max(1, r * 3)),
      cursor: s,
      ...p
    }
  );
}, Dre = dn(function() {
  const e = Ge(), n = un("isReadOnlyMode", () => e.isReadOnly, [e]), r = Ec("top"), a = Ec("right"), s = Ec("bottom"), c = Ec("left"), f = Ec("top_left"), p = Ec("top_right"), g = Ec("bottom_right"), y = Ec("bottom_left"), v = !e.isMenuOpen && e.cursor.type === "default", S = e.isCoarsePointer, x = e.selectionBounds;
  if (!x)
    return null;
  const _ = e.selectedShapes, T = e.selectionRotation, I = e.isChangingStyle, D = Math.max(1, x.width), N = Math.max(1, x.height), j = e.zoomLevel, L = 8 / j, z = D < L * 2, F = N < L * 2, K = D < L * 4, X = N < L * 4, se = S ? 1.75 : 1, ue = 6 / j * se, pe = (K ? ue / 2 : ue) * (se * 0.75), Pe = (X ? ue / 2 : ue) * (se * 0.75), ve = De.toCssString(
    De.Compose(
      De.Translate(x.minX, x.minY),
      De.Rotate(e.selectionRotation)
    )
  ), Y = _.length === 1 ? _[0] : null, le = (Y ? !e.getShapeUtil(Y).hideSelectionBoundsFg(Y) : !0) && !I, Re = (e.isInAny(
    "select.idle",
    "select.brushing",
    "select.editing_shape",
    "select.scribble_brushing",
    "select.pointing_canvas",
    "select.pointing_selection",
    "select.pointing_shape"
  ) || e.isIn("select.resizing") && Y && _[0].type === "text" || e.isIn("select") && e.inputs.ctrlKey) && le, he = e.isInAny(
    "select.idle",
    "select.pointing_selection",
    "select.pointing_shape",
    "select.pointing_selection"
  ) && !I && !n, te = !S && !(z || F) && he && (Y ? !e.getShapeUtil(Y).hideRotateHandle(Y) : !0), de = S && (!K || !X) && he && (Y ? !e.getShapeUtil(Y).hideRotateHandle(Y) : !0), W = he && (Y ? e.getShapeUtil(Y).canResize(Y) && !e.getShapeUtil(Y).hideResizeHandles(Y) : !0), fe = z || F, ce = z && F, xe = !he || !te, $e = !he || !de, Me = !he || !W, re = !he || !W || fe, Qe = !he || !W || fe, ke = !he || !W || ce;
  let rt = S;
  rt && _.every((Tt) => e.getShapeUtil(Tt).isAspectRatioLocked(Tt)) && (rt = !1);
  const St = !he || !W || fe || ce || rt;
  return /* @__PURE__ */ E.jsxs("g", { transform: ve, children: [
    Re && /* @__PURE__ */ E.jsx(
      "rect",
      {
        className: "tlui-selection__fg-outline",
        width: ze(D),
        height: ze(N)
      }
    ),
    /* @__PURE__ */ E.jsxs("g", { children: [
      /* @__PURE__ */ E.jsx("g", { pointerEvents: "all", children: /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
        /* @__PURE__ */ E.jsx(
          Hw,
          {
            "data-wd": "selection.rotate.top-left",
            cx: 0,
            cy: 0,
            targetSize: ue,
            corner: "top_left_rotate",
            cursor: v ? cs("nwse-rotate", T) : void 0,
            isHidden: xe
          }
        ),
        /* @__PURE__ */ E.jsx(
          Hw,
          {
            "data-wd": "selection.rotate.top-right",
            cx: D + ue * 3,
            cy: 0,
            targetSize: ue,
            corner: "top_right_rotate",
            cursor: v ? cs("nesw-rotate", T) : void 0,
            isHidden: xe
          }
        ),
        /* @__PURE__ */ E.jsx(
          Hw,
          {
            "data-wd": "selection.rotate.bottom-left",
            cx: 0,
            cy: N + ue * 3,
            targetSize: ue,
            corner: "bottom_left_rotate",
            cursor: v ? cs("swne-rotate", T) : void 0,
            isHidden: xe
          }
        ),
        /* @__PURE__ */ E.jsx(
          Hw,
          {
            "data-wd": "selection.rotate.bottom-right",
            cx: D + ue * 3,
            cy: N + ue * 3,
            targetSize: ue,
            corner: "bottom_right_rotate",
            cursor: v ? cs("senw-rotate", T) : void 0,
            isHidden: xe
          }
        )
      ] }) }),
      /* @__PURE__ */ E.jsx(
        Ore,
        {
          "data-wd": "selection.rotate.mobile",
          cx: K ? -ue * 1.5 : D / 2,
          cy: K ? N / 2 : -ue * 1.5,
          size: L,
          isHidden: $e
        }
      ),
      /* @__PURE__ */ E.jsxs("g", { pointerEvents: "all", children: [
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            className: $n("rs-transparent", {
              "rs-hidden": St
            }),
            "data-wd": "selection.resize.top",
            "aria-label": "top target",
            x: 0,
            y: ze(0 - (X ? Pe * 2 : Pe)),
            width: ze(Math.max(1, D)),
            height: ze(Math.max(1, Pe * 2)),
            style: v ? { cursor: cs("ns-resize", T) } : void 0,
            ...r
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            className: $n("rs-transparent", {
              "rs-hidden": St
            }),
            "data-wd": "selection.resize.right",
            "aria-label": "right target",
            x: ze(D - (K ? 0 : pe)),
            y: 0,
            height: ze(Math.max(1, N)),
            width: ze(Math.max(1, pe * 2)),
            style: v ? { cursor: cs("ew-resize", T) } : void 0,
            ...a
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            className: $n("rs-transparent", {
              "rs-hidden": St
            }),
            "data-wd": "selection.resize.bottom",
            "aria-label": "bottom target",
            x: 0,
            y: ze(N - (X ? 0 : Pe)),
            width: ze(Math.max(1, D)),
            height: ze(Math.max(1, Pe * 2)),
            style: v ? { cursor: cs("ns-resize", T) } : void 0,
            ...s
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            className: $n("rs-transparent", {
              "rs-hidden": St
            }),
            "data-wd": "selection.resize.left",
            "aria-label": "left target",
            x: ze(0 - (K ? pe * 2 : pe)),
            y: 0,
            height: ze(Math.max(1, N)),
            width: ze(Math.max(1, pe * 2)),
            style: v ? { cursor: cs("ew-resize", T) } : void 0,
            ...c
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            className: $n("rs-transparent", {
              "rs-hidden": Me
            }),
            "data-wd": "selection.resize.top-left",
            "aria-label": "top-left target",
            x: ze(0 - (K ? pe * 2 : pe * 1.5)),
            y: ze(0 - (X ? Pe * 2 : Pe * 1.5)),
            width: ze(pe * 3),
            height: ze(Pe * 3),
            style: v ? { cursor: cs("nwse-resize", T) } : void 0,
            ...f
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            className: $n("rs-transparent", {
              "rs-hidden": re
            }),
            "data-wd": "selection.resize.top-right",
            "aria-label": "top-right target",
            x: ze(D - (K ? 0 : pe * 1.5)),
            y: ze(0 - (X ? Pe * 2 : Pe * 1.5)),
            width: ze(pe * 3),
            height: ze(Pe * 3),
            style: v ? { cursor: cs("nesw-resize", T) } : void 0,
            ...p
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            className: $n("rs-transparent", {
              "rs-hidden": ke
            }),
            "data-wd": "selection.resize.bottom-right",
            "aria-label": "bottom-right target",
            x: ze(D - (K ? pe : pe * 1.5)),
            y: ze(N - (X ? Pe : Pe * 1.5)),
            width: ze(pe * 3),
            height: ze(Pe * 3),
            style: v ? { cursor: cs("nwse-resize", T) } : void 0,
            ...g
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            className: $n("rs-transparent", {
              "rs-hidden": Qe
            }),
            "data-wd": "selection.resize.bottom-left",
            "aria-label": "bottom-left target",
            x: ze(0 - (K ? pe * 3 : pe * 1.5)),
            y: ze(N - (X ? 0 : Pe * 1.5)),
            width: ze(pe * 3),
            height: ze(Pe * 3),
            style: v ? { cursor: cs("nesw-resize", T) } : void 0,
            ...y
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            "data-wd": "selection.resize.top-left",
            className: $n("rs-corner-handle", {
              "rs-hidden": Me
            }),
            "aria-label": "top_left handle",
            x: ze(0 - L / 2),
            y: ze(0 - L / 2),
            width: ze(L),
            height: ze(L)
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            "data-wd": "selection.resize.top-right",
            className: $n("rs-corner-handle", {
              "rs-hidden": re
            }),
            "aria-label": "top_right handle",
            x: ze(D - L / 2),
            y: ze(0 - L / 2),
            width: ze(L),
            height: ze(L)
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            "data-wd": "selection.resize.bottom-right",
            className: $n("rs-corner-handle", {
              "rs-hidden": ke
            }),
            "aria-label": "bottom_right handle",
            x: ze(D - L / 2),
            y: ze(N - L / 2),
            width: ze(L),
            height: ze(L)
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            "data-wd": "selection.resize.bottom-left",
            className: $n("rs-corner-handle", {
              "rs-hidden": Qe
            }),
            "aria-label": "bottom_left handle",
            x: ze(0 - L / 2),
            y: ze(N - L / 2),
            width: ze(L),
            height: ze(L)
          }
        )
      ] })
    ] })
  ] });
});
function Nre() {
  return /* @__PURE__ */ E.jsx("div", { className: "rs-shape-error-boundary" });
}
const VD = dn(function({
  id: e,
  index: n,
  opacity: r,
  isCulled: a
}) {
  const s = Ge(), c = Ree(e), f = k.useRef(null);
  Ip(
    "set shape container transform position",
    () => {
      const y = f.current;
      if (!y)
        return;
      const v = s.getShapeById(e), S = s.getPageTransformById(e);
      if (!v || !S)
        return null;
      const x = De.toCssString(S);
      y.style.setProperty("transform", x);
    },
    [s]
  ), Ip(
    "set shape container clip path / color",
    () => {
      const y = f.current, v = s.getShapeById(e);
      if (!y)
        return;
      if (!v)
        return null;
      const S = s.getClipPathById(e);
      y.style.setProperty("clip-path", S ?? "none"), "color" in v.props && y.style.setProperty("color", s.getCssColor(v.props.color));
    },
    [s]
  ), Ip(
    "set shape height and width",
    () => {
      const y = f.current, v = s.getShapeById(e);
      if (!y)
        return;
      if (!v)
        return null;
      const x = s.getShapeUtil(v).bounds(v);
      y.style.setProperty("width", Math.ceil(x.width) + "px"), y.style.setProperty("height", Math.ceil(x.height) + "px");
    },
    [s]
  ), k.useLayoutEffect(() => {
    const y = f.current;
    y && (y.style.setProperty("opacity", r + ""), y.style.setProperty("z-index", n + ""));
  }, [r, n]);
  const p = s.getShapeById(e);
  if (!p)
    return null;
  const g = s.getShapeUtil(p);
  return /* @__PURE__ */ E.jsx(
    "div",
    {
      ref: f,
      className: "rs-shape",
      "data-shape-type": p.type,
      draggable: !1,
      onPointerDown: c.onPointerDown,
      onPointerMove: c.onPointerMove,
      onPointerUp: c.onPointerUp,
      onPointerEnter: c.onPointerEnter,
      onPointerLeave: c.onPointerLeave,
      children: a && g.canUnmount(p) ? /* @__PURE__ */ E.jsx(jre, { shape: p, util: g }) : /* @__PURE__ */ E.jsxs(
        Ib,
        {
          fallback: Nre,
          onError: (y) => s.annotateError(y, { origin: "react.shape", willCrashApp: !1 }),
          children: [
            " ",
            /* @__PURE__ */ E.jsx(Lre, { shape: p, util: g })
          ]
        }
      )
    },
    e
  );
}), Lre = k.memo(
  function({ shape: e, util: n }) {
    return MI("InnerShape:" + n.type, () => n.render(e));
  },
  (t, e) => t.shape.props === e.shape.props
), jre = k.memo(
  function({ shape: e, util: n }) {
    const r = n.bounds(e);
    return /* @__PURE__ */ E.jsx(
      "div",
      {
        className: "rs-shape__culled",
        style: {
          transform: `translate(${r.minX}px, ${r.minY}px)`,
          width: r.width,
          height: r.height
        }
      }
    );
  },
  () => !0
);
function zre({ points: t, zoom: e }) {
  const n = 2.5 / e, r = t.reduce((S, x) => Math.min(S, x.x), 1 / 0), a = t.reduce((S, x) => Math.max(S, x.x), -1 / 0), s = t.reduce((S, x) => Math.min(S, x.y), 1 / 0), c = t.reduce((S, x) => Math.max(S, x.y), -1 / 0), f = t.some((S) => S.x === r && S.y === s);
  let p, g, y, v;
  return f ? (p = r, g = s, y = a, v = c) : (p = r, g = c, y = a, v = s), /* @__PURE__ */ E.jsxs("g", { className: "rs-snap-line", children: [
    /* @__PURE__ */ E.jsx("line", { x1: p, y1: g, x2: y, y2: v }),
    t.map((S, x) => /* @__PURE__ */ E.jsx("g", { transform: `translate(${S.x},${S.y})`, children: /* @__PURE__ */ E.jsx(
      "path",
      {
        className: "rs-snap-point",
        d: `M ${-n},${-n} L ${n},${n} M ${-n},${n} L ${n},${-n}`
      }
    ) }, x))
  ] });
}
function Ure({ gaps: t, direction: e, zoom: n }) {
  const r = 3.5 / n;
  let a = [-1 / 0, 1 / 0], s = null;
  const c = e === "horizontal";
  for (const p of t) {
    if (s = Il(
      a[0],
      a[1],
      c ? p.startEdge[0].y : p.startEdge[0].x,
      c ? p.startEdge[1].y : p.startEdge[1].x
    ), s)
      a = s;
    else
      continue;
    if (s = Il(
      a[0],
      a[1],
      c ? p.endEdge[0].y : p.endEdge[0].x,
      c ? p.endEdge[1].y : p.endEdge[1].x
    ), s)
      a = s;
    else
      continue;
  }
  if (a === null)
    return null;
  const f = (a[0] + a[1]) / 2;
  return /* @__PURE__ */ E.jsx("g", { className: "rs-snap-line", children: t.map(({ startEdge: p, endEdge: g }, y) => /* @__PURE__ */ E.jsx(k.Fragment, { children: c ? (
    // horizontal gap
    /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(
        "line",
        {
          x1: p[0].x,
          y1: f - 2 * r,
          x2: p[1].x,
          y2: f + 2 * r
        }
      ),
      /* @__PURE__ */ E.jsx(
        "line",
        {
          x1: g[0].x,
          y1: f - 2 * r,
          x2: g[1].x,
          y2: f + 2 * r
        }
      ),
      /* @__PURE__ */ E.jsx("line", { x1: p[0].x, y1: f, x2: g[0].x, y2: f }),
      /* @__PURE__ */ E.jsx(
        "line",
        {
          x1: (p[0].x + g[0].x) / 2,
          y1: f - r,
          x2: (p[0].x + g[0].x) / 2,
          y2: f + r
        }
      )
    ] })
  ) : (
    // vertical gap
    /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(
        "line",
        {
          x1: f - 2 * r,
          y1: p[0].y,
          x2: f + 2 * r,
          y2: p[1].y
        }
      ),
      /* @__PURE__ */ E.jsx(
        "line",
        {
          x1: f - 2 * r,
          y1: g[0].y,
          x2: f + 2 * r,
          y2: g[1].y
        }
      ),
      /* @__PURE__ */ E.jsx("line", { x1: f, y1: p[0].y, x2: f, y2: g[0].y }),
      /* @__PURE__ */ E.jsx(
        "line",
        {
          x1: f - r,
          y1: (p[0].y + g[0].y) / 2,
          x2: f + r,
          y2: (p[0].y + g[0].y) / 2
        }
      )
    ] })
  ) }, y)) });
}
function Bre({ line: t, zoom: e }) {
  switch (t.type) {
    case "points":
      return /* @__PURE__ */ E.jsx(zre, { ...t, zoom: e });
    case "gaps":
      return /* @__PURE__ */ E.jsx(Ure, { ...t, zoom: e });
    default:
      return null;
  }
}
const Fre = dn(function() {
  const e = Ge(), n = e.zoomLevel;
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: e.snaps.lines.map((r) => /* @__PURE__ */ E.jsx(Bre, { line: r, zoom: n }, r.id)) });
}), Hre = dn(function({ id: e }) {
  const n = Ge(), r = n.getShapeById(e), [a, s] = k.useState("");
  return k.useEffect(() => {
    let c = !1;
    return (async () => {
      if (c)
        return;
      const f = n.getPageBoundsById(e), p = await n.getSvg([e], { padding: 0 });
      p && f && !c && (p.style.setProperty("overflow", "visible"), p.setAttribute("preserveAspectRatio", "xMidYMin slice"), p.style.setProperty("transform", `translate(${f.x}px, ${f.y + f.h + 12}px)`), p.style.setProperty("border", "1px solid black"), s(p?.outerHTML));
    })(), () => {
      c = !0;
    };
  }, [n, r, e]), /* @__PURE__ */ E.jsx("div", { style: { paddingTop: 12, position: "absolute" }, children: /* @__PURE__ */ E.jsx("div", { style: { display: "flex" }, dangerouslySetInnerHTML: { __html: a } }) });
}), Lj = dn(function({
  onDropOverride: e
}) {
  const n = Ge(), r = k.useRef(null), a = k.useRef(null), s = k.useRef(null);
  QZ(), HZ(), oee(r), tJ(r), Iee(), Ip(
    "position layers",
    () => {
      const g = s.current, y = a.current;
      if (!(g && y))
        return;
      const { x: v, y: S, z: x } = n.camera, _ = x >= 1 ? nP(x, [1, 8], [0.125, 0.5], !0) : nP(x, [0.1, 1], [-2, 0.125], !0);
      g.style.setProperty(
        "transform",
        `scale(${ze(x)}) translate(${ze(v)}px,${ze(S)}px)`
      ), y.style.setProperty(
        "transform",
        `scale(${ze(x)}) translate(${ze(v + _)}px,${ze(
          S + _
        )}px)`
      );
    },
    [n]
  );
  const { context: c, isReady: f } = lee(), p = FZ();
  return e && (p.onDrop = e(p.onDrop)), k.useEffect(() => {
    if (f && n.isSafari) {
      const g = s.current, y = a.current;
      g && y && requestAnimationFrame(() => {
        g.style.display = "none", y.style.display = "none", requestAnimationFrame(() => {
          g.style.display = "", y.style.display = "";
        });
      });
    }
  }, [n, f]), k.useEffect(() => {
    r.current?.focus();
  }, []), /* @__PURE__ */ E.jsxs(
    "div",
    {
      ref: r,
      tabIndex: -1,
      draggable: !1,
      className: "rs-canvas",
      "data-wd": "canvas",
      ...p,
      children: [
        /* @__PURE__ */ E.jsx(hre, { size: n.gridSize }),
        /* @__PURE__ */ E.jsxs("div", { ref: a, className: "rs-html-layer", draggable: !1, children: [
          /* @__PURE__ */ E.jsx(Mre, {}),
          /* @__PURE__ */ E.jsx(Vre, {})
        ] }),
        /* @__PURE__ */ E.jsxs("svg", { className: "rs-svg-layer", children: [
          c,
          /* @__PURE__ */ E.jsxs("defs", { children: [
            /* @__PURE__ */ E.jsx(Gre, {}),
            /* @__PURE__ */ E.jsx(Xre, {}),
            /* @__PURE__ */ E.jsx("marker", { id: "arrowhead-dot", className: "rs-arrow-hint", refX: "3.0", refY: "3.0", orient: "0", children: /* @__PURE__ */ E.jsx("circle", { cx: "3", cy: "3", r: "2", strokeDasharray: "100%" }) }),
            /* @__PURE__ */ E.jsxs(
              "marker",
              {
                id: "arrowhead-cross",
                className: "rs-arrow-hint",
                refX: "3.0",
                refY: "3.0",
                orient: "auto",
                children: [
                  /* @__PURE__ */ E.jsx("line", { x1: "1.5", y1: "1.5", x2: "4.5", y2: "4.5", strokeDasharray: "100%" }),
                  /* @__PURE__ */ E.jsx("line", { x1: "1.5", y1: "4.5", x2: "4.5", y2: "1.5", strokeDasharray: "100%" })
                ]
              }
            )
          ] }),
          /* @__PURE__ */ E.jsxs("g", { ref: s, children: [
            /* @__PURE__ */ E.jsx(kre, {}),
            /* @__PURE__ */ E.jsx($re, {}),
            /* @__PURE__ */ E.jsx(pre, {}),
            /* @__PURE__ */ E.jsx(Yre, {}),
            /* @__PURE__ */ E.jsx(Kre, {}),
            /* @__PURE__ */ E.jsx(Dre, {}),
            /* @__PURE__ */ E.jsx(Wre, {}),
            /* @__PURE__ */ E.jsx(yre, {}),
            /* @__PURE__ */ E.jsx(Fre, {})
          ] })
        ] })
      ]
    }
  );
}), Vre = dn(function() {
  const e = Ge(), { renderingShapes: n } = e;
  return hs.debugSvg.value ? /* @__PURE__ */ E.jsx(E.Fragment, { children: n.map((a) => /* @__PURE__ */ E.jsxs(k.Fragment, { children: [
    /* @__PURE__ */ E.jsx(VD, { ...a }, a.id + "_shape"),
    /* @__PURE__ */ E.jsx(Hre, { id: a.id }, a.id + "_shape_debug")
  ] }, a.id + "_fragment")) }) : /* @__PURE__ */ E.jsx(E.Fragment, { children: n.map((a) => /* @__PURE__ */ E.jsx(VD, { ...a }, a.id + "_shape")) });
}), Yre = dn(function() {
  const e = Ge(), n = e.selectedIds, r = e.isChangingStyle;
  return e.isInAny(
    "select.idle",
    "select.brushing",
    "select.scribble_brushing",
    "select.pointing_shape",
    "select.pointing_selection",
    "select.pointing_handle"
  ) && !r ? /* @__PURE__ */ E.jsx("g", { "aria-label": "SELECTED INDICATORS", children: n.map((s) => /* @__PURE__ */ E.jsx(w1, { id: s }, s + "_indicator")) }) : null;
}), Kre = dn(function() {
  const e = Ge(), n = e.pageState.hoveredId, r = e.isInAny("select.idle", "select.editing_shape");
  return n && r ? /* @__PURE__ */ E.jsx(w1, { id: n }, n) : null;
}), Wre = dn(function() {
  const e = Ge(), n = xx(e.hintingIds);
  return n.length ? /* @__PURE__ */ E.jsx("g", { "aria-label": "HINTED SHAPES", children: n.map((r) => /* @__PURE__ */ E.jsx(w1, { id: r, isHinting: !0 }, r + "_hinting")) }) : null;
});
function Gre() {
  return /* @__PURE__ */ E.jsxs("g", { id: "cursor", children: [
    /* @__PURE__ */ E.jsxs("g", { fill: "rgba(0,0,0,.2)", transform: "translate(-11,-11)", children: [
      /* @__PURE__ */ E.jsx("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
      /* @__PURE__ */ E.jsx("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
    ] }),
    /* @__PURE__ */ E.jsxs("g", { fill: "white", transform: "translate(-12,-12)", children: [
      /* @__PURE__ */ E.jsx("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
      /* @__PURE__ */ E.jsx("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
    ] }),
    /* @__PURE__ */ E.jsxs("g", { fill: "currentColor", transform: "translate(-12,-12)", children: [
      /* @__PURE__ */ E.jsx("path", { d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" }),
      /* @__PURE__ */ E.jsx("path", { d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z" })
    ] })
  ] });
}
function Xre() {
  return /* @__PURE__ */ E.jsx("path", { id: "cursor_hint", fill: "currentColor", d: "M -2,-5 2,0 -2,5 Z", opacity: ".8" });
}
const qre = "https://github.com/tldraw/editor/issues/new";
function Qre() {
}
function fP({ error: t, app: e }) {
  const n = k.useRef(null), [r, a] = k.useState({}.NODE_ENV === "development"), [s, c] = k.useState(!1), [f, p] = k.useState(!1), g = t instanceof Error ? t.message : String(t), y = t instanceof Error ? t.stack : null, v = un(
    "isDarkMode",
    () => {
      try {
        if (e)
          return e.userDocumentSettings.isDarkMode;
      } catch {
      }
      return null;
    },
    [e]
  ), [S, x] = k.useState(null);
  k.useLayoutEffect(() => {
    v !== null && x(v);
    let N = n.current?.parentElement, j = !1;
    for (; N; ) {
      if (N.classList.contains("rs-theme__dark") || N.classList.contains("rs-theme__light")) {
        j = !0;
        break;
      }
      N = N.parentElement;
    }
    if (j) {
      x(null);
      return;
    }
    x(window.matchMedia("(prefers-color-scheme: dark)").matches);
  }, [v]), k.useEffect(() => {
    if (s) {
      const N = setTimeout(() => {
        c(!1);
      }, 2e3);
      return () => clearTimeout(N);
    }
  }, [s]);
  const _ = () => {
    const N = document.createElement("textarea");
    N.value = y ?? g, document.body.appendChild(N), N.select(), document.execCommand("copy"), N.remove(), c(!0);
  }, T = () => {
    window.location.reload();
  }, I = async () => {
    await window.__tldraw__hardReset?.();
  }, D = new URL(qre);
  return D.searchParams.set("title", g), D.searchParams.set("labels", "bug"), D.searchParams.set(
    "body",
    `Hey, I ran into an error while using tldraw:

\`\`\`js
${y ?? g}
\`\`\`

My browser: ${navigator.userAgent}`
  ), /* @__PURE__ */ E.jsxs(
    "div",
    {
      ref: n,
      className: $n(
        "rs-container rs-error-boundary",
        // error-boundary is sometimes used outside of the theme
        // container, so we need to provide it with a theme for our
        // styles to work correctly
        S === null ? "" : S ? "rs-theme__dark" : "rs-theme__light"
      ),
      children: [
        /* @__PURE__ */ E.jsx("div", { className: "rs-error-boundary__overlay" }),
        e && // opportunistically attempt to render the canvas to reassure
        // the user that their document is still there. there's a good
        // chance this won't work (ie the error that we're currently
        // notifying the user about originates in the canvas) so it's
        // not a big deal if it doesn't work - in that case we just have
        // a plain grey background.
        /* @__PURE__ */ E.jsx(Ib, { onError: Qre, fallback: () => null, children: /* @__PURE__ */ E.jsx(AI.Provider, { value: e, children: /* @__PURE__ */ E.jsx("div", { className: "rs-overlay rs-error-boundary__canvas", children: /* @__PURE__ */ E.jsx(Lj, {}) }) }) }),
        /* @__PURE__ */ E.jsx(
          "div",
          {
            className: $n("rs-modal", "rs-error-boundary__content", {
              "rs-error-boundary__content__expanded": r && !f
            }),
            children: f ? /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
              /* @__PURE__ */ E.jsx("h2", { children: "Are you sure?" }),
              /* @__PURE__ */ E.jsx("p", { children: "Resetting your data will delete your drawing and cannot be undone." }),
              /* @__PURE__ */ E.jsxs("div", { className: "rs-error-boundary__content__actions", children: [
                /* @__PURE__ */ E.jsx("button", { onClick: () => p(!1), children: "Cancel" }),
                /* @__PURE__ */ E.jsx("button", { className: "rs-error-boundary__reset", onClick: I, children: "Reset data" })
              ] })
            ] }) : /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
              /* @__PURE__ */ E.jsx("h2", { children: "Something's gone wrong." }),
              /* @__PURE__ */ E.jsxs("p", { children: [
                "Sorry, we encountered an error. Please refresh the page to continue. If you keep seeing this error, you can ",
                /* @__PURE__ */ E.jsx("a", { href: D.toString(), children: "create a GitHub issue" }),
                " or",
                " ",
                /* @__PURE__ */ E.jsx("a", { href: "https://discord.gg/Cq6cPsTfNy", children: "ask for help on Discord" }),
                "."
              ] }),
              r && /* @__PURE__ */ E.jsxs("div", { className: "rs-error-boundary__content__error", children: [
                /* @__PURE__ */ E.jsx("pre", { children: /* @__PURE__ */ E.jsx("code", { children: y ?? g }) }),
                /* @__PURE__ */ E.jsx("button", { onClick: _, children: s ? "Copied!" : "Copy" })
              ] }),
              /* @__PURE__ */ E.jsxs("div", { className: "rs-error-boundary__content__actions", children: [
                /* @__PURE__ */ E.jsx("button", { onClick: () => a(!r), children: r ? "Hide details" : "Show details" }),
                /* @__PURE__ */ E.jsxs("div", { className: "rs-error-boundary__content__actions__group", children: [
                  /* @__PURE__ */ E.jsx(
                    "button",
                    {
                      className: "rs-error-boundary__reset",
                      onClick: () => p(!0),
                      children: "Reset data"
                    }
                  ),
                  /* @__PURE__ */ E.jsx("button", { className: "rs-error-boundary__refresh", onClick: T, children: "Refresh Page" })
                ] })
              ] })
            ] })
          }
        )
      ]
    }
  );
}
let jj = !1;
if (typeof window < "u") {
  const t = window.navigator.userAgent, e = !!t.match(/iPad/i) || !!t.match(/iPhone/i), n = !!t.match(/WebKit/i);
  jj = e && n && !t.match(/CriOS/i);
}
function Zre() {
  const t = Ge();
  k.useEffect(() => {
    if (!jj)
      return;
    function e(n) {
      (n.target instanceof HTMLInputElement && n.target.type === "text" || n.target instanceof HTMLTextAreaElement) && t.complete();
    }
    return document.addEventListener("focusout", e), () => document.removeEventListener("focusout", e);
  }, [t]);
}
const Jre = ({ children: t }) => ($ee(), XZ(), qZ(), nJ(), Zre(), t), Vw = (t, e) => {
  const [n, r] = k.useState(
    2
    /* WAITING */
  );
  return k.useEffect(() => {
    const {
      url: a,
      style: s = "normal",
      weight: c = "500",
      display: f,
      featureSettings: p,
      stretch: g,
      unicodeRange: y,
      variant: v
    } = e;
    let S = !1;
    r(
      2
      /* WAITING */
    );
    const x = {
      style: s,
      weight: c,
      display: f,
      featureSettings: p,
      stretch: g,
      unicodeRange: y,
      variant: v
    }, _ = new FontFace(t, `url(${a})`, x);
    return _.load().then(() => {
      S || (document.fonts.add(_), r(
        0
        /* SUCCESS */
      ));
    }).catch((T) => {
      S || (console.error(T), r(
        1
        /* FAILED */
      ));
    }), _.$$_url = a, _.$$_fontface = `
@font-face {
	font-family: ${_.family};
	font-stretch: ${_.stretch};
	font-weight: ${_.weight};
	font-style: ${_.style};
	src: url("${a}") format("woff2")
}`, () => {
      document.fonts.delete(_), S = !0;
    };
  }, [t, e]), n;
};
function eie(t) {
  return {
    draw: { url: t.fonts.draw },
    serif: { url: t.fonts.serif },
    sansSerif: { url: t.fonts.sansSerif },
    monospace: { url: t.fonts.monospace }
  };
}
function tie(t) {
  const e = k.useMemo(() => eie(t), [t]), n = [
    Vw("tldraw_draw", e.draw),
    Vw("tldraw_serif", e.serif),
    Vw("tldraw_sans", e.sansSerif),
    Vw("tldraw_mono", e.monospace)
  ];
  return {
    // If any of the results have errored, then preloading has failed
    error: n.some(
      (r) => r === 1
      /* FAILED */
    ),
    // If any of the results are waiting, then we're not done yet
    done: !n.some(
      (r) => r === 2
      /* WAITING */
    )
  };
}
function nie(t) {
  const [e, n] = It.useState(null);
  return /* @__PURE__ */ E.jsx("div", { ref: n, draggable: !1, className: "rs-container rs-theme__light", children: /* @__PURE__ */ E.jsx(
    Ib,
    {
      fallback: (r) => /* @__PURE__ */ E.jsx(fP, { error: r }),
      onError: (r) => pI(r, { tags: { origin: "react.tldraw-before-app" } }),
      children: e && /* @__PURE__ */ E.jsx(VZ, { container: e, children: /* @__PURE__ */ E.jsx(rie, { ...t }) })
    }
  ) });
}
function rie({
  config: t = kb.default,
  userId: e,
  instanceId: n,
  store: r,
  ...a
}) {
  const { done: s, error: c } = tie(
    a.assetUrls ?? Dj
  );
  r ??= t.createStore({
    userId: e ?? $p.createId(),
    instanceId: n ?? Rp.createId()
  });
  let f;
  if (r instanceof mL)
    f = r;
  else {
    if (r.error)
      throw r.error;
    if (!r.store)
      return /* @__PURE__ */ E.jsx(pP, { children: "Connecting..." });
    f = r.store;
  }
  return n && f.props.instanceId !== n && console.error(
    `The store's instanceId (${f.props.instanceId}) does not match the instanceId prop (${n}). This may cause unexpected behavior.`
  ), e && f.props.userId !== e && console.error(
    `The store's userId (${f.props.userId}) does not match the userId prop (${e}). This may cause unexpected behavior.`
  ), c ? /* @__PURE__ */ E.jsx(oie, { children: "Could not load assets. Please refresh the page." }) : s ? /* @__PURE__ */ E.jsx(iie, { ...a, store: f, config: t }) : /* @__PURE__ */ E.jsx(pP, { children: "Loading assets..." });
}
function iie({
  onMount: t,
  config: e,
  isDarkMode: n,
  children: r,
  onCreateAssetFromFile: a,
  onCreateBookmarkFromUrl: s,
  store: c
}) {
  const f = va(), [p, g] = It.useState(null);
  It.useLayoutEffect(() => {
    const S = new en({
      store: c,
      getContainer: () => f,
      config: e
    });
    return g(S), window.app = S, () => {
      S.dispose(), g((x) => x === S ? null : x);
    };
  }, [f, e, c]), It.useEffect(() => {
    p && (a && (p.onCreateAssetFromFile = a), s && (p.onCreateBookmarkFromUrl = s));
  }, [p, n, a, s]);
  const y = JZ((S) => t?.(S));
  It.useEffect(() => {
    p && (n !== void 0 && p.updateUserDocumentSettings({ isDarkMode: n }), window.tldrawReady = !0, y(p));
  }, [p, y, n]);
  const v = k.useSyncExternalStore(
    k.useCallback(
      (S) => p ? (p.on("crash", S), () => p.off("crash", S)) : () => {
      },
      [p]
    ),
    () => p?.crashingError ?? null
  );
  return p ? (
    // the top-level tldraw component also renders an error boundary almost
    // identical to this one. the reason we have two is because this one has
    // access to `App`, which means that here we can enrich errors with data
    // from app for reporting, and also still attempt to render the user's
    // document in the event of an error to reassure them that their work is
    // not lost.
    /* @__PURE__ */ E.jsx(Ib, {
      fallback: (S) => /* @__PURE__ */ E.jsx(fP, { error: S, app: p }),
      onError: (S) => p.annotateError(S, { origin: "react.tldraw", willCrashApp: !0 }),
      children: v ? /* @__PURE__ */ E.jsx(fP, { error: v, app: p }) : /* @__PURE__ */ E.jsx(AI.Provider, { value: p, children: /* @__PURE__ */ E.jsx(Jre, { children: r }) })
    })
  ) : null;
}
function pP({ children: t }) {
  return /* @__PURE__ */ E.jsxs("div", { className: "rs-loading", children: [
    /* @__PURE__ */ E.jsx(y1, {}),
    t
  ] });
}
function oie({ children: t }) {
  return /* @__PURE__ */ E.jsx("div", { className: "rs-loading", children: t });
}
const aie = (t, e) => e.some((n) => t instanceof n);
let YD, KD;
function sie() {
  return YD || (YD = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function lie() {
  return KD || (KD = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const zj = /* @__PURE__ */ new WeakMap(), hP = /* @__PURE__ */ new WeakMap(), Uj = /* @__PURE__ */ new WeakMap(), pk = /* @__PURE__ */ new WeakMap(), qI = /* @__PURE__ */ new WeakMap();
function cie(t) {
  const e = new Promise((n, r) => {
    const a = () => {
      t.removeEventListener("success", s), t.removeEventListener("error", c);
    }, s = () => {
      n(Xg(t.result)), a();
    }, c = () => {
      r(t.error), a();
    };
    t.addEventListener("success", s), t.addEventListener("error", c);
  });
  return e.then((n) => {
    n instanceof IDBCursor && zj.set(n, t);
  }).catch(() => {
  }), qI.set(e, t), e;
}
function uie(t) {
  if (hP.has(t))
    return;
  const e = new Promise((n, r) => {
    const a = () => {
      t.removeEventListener("complete", s), t.removeEventListener("error", c), t.removeEventListener("abort", c);
    }, s = () => {
      n(), a();
    }, c = () => {
      r(t.error || new DOMException("AbortError", "AbortError")), a();
    };
    t.addEventListener("complete", s), t.addEventListener("error", c), t.addEventListener("abort", c);
  });
  hP.set(t, e);
}
let gP = {
  get(t, e, n) {
    if (t instanceof IDBTransaction) {
      if (e === "done")
        return hP.get(t);
      if (e === "objectStoreNames")
        return t.objectStoreNames || Uj.get(t);
      if (e === "store")
        return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]);
    }
    return Xg(t[e]);
  },
  set(t, e, n) {
    return t[e] = n, !0;
  },
  has(t, e) {
    return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t;
  }
};
function die(t) {
  gP = t(gP);
}
function fie(t) {
  return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...n) {
    const r = t.call(hk(this), e, ...n);
    return Uj.set(r, e.sort ? e.sort() : [e]), Xg(r);
  } : lie().includes(t) ? function(...e) {
    return t.apply(hk(this), e), Xg(zj.get(this));
  } : function(...e) {
    return Xg(t.apply(hk(this), e));
  };
}
function pie(t) {
  return typeof t == "function" ? fie(t) : (t instanceof IDBTransaction && uie(t), aie(t, sie()) ? new Proxy(t, gP) : t);
}
function Xg(t) {
  if (t instanceof IDBRequest)
    return cie(t);
  if (pk.has(t))
    return pk.get(t);
  const e = pie(t);
  return e !== t && (pk.set(t, e), qI.set(e, t)), e;
}
const hk = (t) => qI.get(t);
function hie(t, { blocked: e } = {}) {
  const n = indexedDB.deleteDatabase(t);
  return e && n.addEventListener("blocked", (r) => e(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    r.oldVersion,
    r
  )), Xg(n).then(() => {
  });
}
const gie = ["get", "getKey", "getAll", "getAllKeys", "count"], mie = ["put", "add", "delete", "clear"], gk = /* @__PURE__ */ new Map();
function WD(t, e) {
  if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string"))
    return;
  if (gk.get(e))
    return gk.get(e);
  const n = e.replace(/FromIndex$/, ""), r = e !== n, a = mie.includes(n);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(a || gie.includes(n))
  )
    return;
  const s = async function(c, ...f) {
    const p = this.transaction(c, a ? "readwrite" : "readonly");
    let g = p.store;
    return r && (g = g.index(f.shift())), (await Promise.all([
      g[n](...f),
      a && p.done
    ]))[0];
  };
  return gk.set(e, s), s;
}
die((t) => ({
  ...t,
  get: (e, n, r) => WD(e, n) || t.get(e, n, r),
  has: (e, n) => !!WD(e, n) || t.has(e, n)
}));
const qg = "TLDRAW_TAB_ID_v2", To = globalThis.window;
function vie() {
  return To ? ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(
    To.navigator.platform
  ) || // iPad on iOS 13 detection
  To.navigator.userAgent.includes("Mac") && "ontouchend" in document : !1;
}
const Bj = "TLDRAW_USER_DATA_v2", yie = hi(
  "globalUserData",
  JSON.parse(To?.localStorage.getItem(Bj) || "null") ?? $p.create({})
);
o1("set global user data", () => {
  To && To.localStorage.setItem(Bj, JSON.stringify(yie.value));
});
const Fj = "TLDRAW_DEFAULT_DOCUMENT_NAME_v2", bie = To?.localStorage.getItem(Fj) ?? $i();
To?.localStorage.setItem(Fj, bie);
const mP = To?.[qg] ?? To?.sessionStorage[qg] ?? Rp.createId();
To && (To[qg] = mP, vie() ? To.sessionStorage[qg] = mP : delete To.sessionStorage[qg]);
To?.addEventListener("beforeunload", () => {
  To.sessionStorage[qg] = mP;
});
const Sie = "TLDRAW_DB_NAME_INDEX_v2";
function wie() {
  const t = JSON.parse(To?.localStorage.getItem(Sie) || "[]") ?? [];
  return Array.isArray(t) ? t : [];
}
async function GD({ shouldReload: t = !0 } = {}) {
  sessionStorage.clear(), await Promise.all(wie().map((e) => hie(e))), localStorage.clear(), t && window.location.reload();
}
typeof window < "u" && ({}.NODE_ENV === "development" && (window.hardReset = GD), window.__tldraw__hardReset = GD);
function qe() {
  return qe = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, qe.apply(this, arguments);
}
var vP = { exports: {} }, Ha = {}, Yw = { exports: {} }, mk = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var XD;
function xie() {
  return XD || (XD = 1, function(t) {
    function e(te, de) {
      var W = te.length;
      te.push(de);
      e:
        for (; 0 < W; ) {
          var fe = W - 1 >>> 1, ce = te[fe];
          if (0 < a(ce, de))
            te[fe] = de, te[W] = ce, W = fe;
          else
            break e;
        }
    }
    function n(te) {
      return te.length === 0 ? null : te[0];
    }
    function r(te) {
      if (te.length === 0)
        return null;
      var de = te[0], W = te.pop();
      if (W !== de) {
        te[0] = W;
        e:
          for (var fe = 0, ce = te.length, xe = ce >>> 1; fe < xe; ) {
            var $e = 2 * (fe + 1) - 1, Me = te[$e], re = $e + 1, Qe = te[re];
            if (0 > a(Me, W))
              re < ce && 0 > a(Qe, Me) ? (te[fe] = Qe, te[re] = W, fe = re) : (te[fe] = Me, te[$e] = W, fe = $e);
            else if (re < ce && 0 > a(Qe, W))
              te[fe] = Qe, te[re] = W, fe = re;
            else
              break e;
          }
      }
      return de;
    }
    function a(te, de) {
      var W = te.sortIndex - de.sortIndex;
      return W !== 0 ? W : te.id - de.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      t.unstable_now = function() {
        return s.now();
      };
    } else {
      var c = Date, f = c.now();
      t.unstable_now = function() {
        return c.now() - f;
      };
    }
    var p = [], g = [], y = 1, v = null, S = 3, x = !1, _ = !1, T = !1, I = typeof setTimeout == "function" ? setTimeout : null, D = typeof clearTimeout == "function" ? clearTimeout : null, N = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function j(te) {
      for (var de = n(g); de !== null; ) {
        if (de.callback === null)
          r(g);
        else if (de.startTime <= te)
          r(g), de.sortIndex = de.expirationTime, e(p, de);
        else
          break;
        de = n(g);
      }
    }
    function L(te) {
      if (T = !1, j(te), !_)
        if (n(p) !== null)
          _ = !0, Re(z);
        else {
          var de = n(g);
          de !== null && he(L, de.startTime - te);
        }
    }
    function z(te, de) {
      _ = !1, T && (T = !1, D(X), X = -1), x = !0;
      var W = S;
      try {
        for (j(de), v = n(p); v !== null && (!(v.expirationTime > de) || te && !pe()); ) {
          var fe = v.callback;
          if (typeof fe == "function") {
            v.callback = null, S = v.priorityLevel;
            var ce = fe(v.expirationTime <= de);
            de = t.unstable_now(), typeof ce == "function" ? v.callback = ce : v === n(p) && r(p), j(de);
          } else
            r(p);
          v = n(p);
        }
        if (v !== null)
          var xe = !0;
        else {
          var $e = n(g);
          $e !== null && he(L, $e.startTime - de), xe = !1;
        }
        return xe;
      } finally {
        v = null, S = W, x = !1;
      }
    }
    var F = !1, K = null, X = -1, se = 5, ue = -1;
    function pe() {
      return !(t.unstable_now() - ue < se);
    }
    function Pe() {
      if (K !== null) {
        var te = t.unstable_now();
        ue = te;
        var de = !0;
        try {
          de = K(!0, te);
        } finally {
          de ? ve() : (F = !1, K = null);
        }
      } else
        F = !1;
    }
    var ve;
    if (typeof N == "function")
      ve = function() {
        N(Pe);
      };
    else if (typeof MessageChannel < "u") {
      var Y = new MessageChannel(), le = Y.port2;
      Y.port1.onmessage = Pe, ve = function() {
        le.postMessage(null);
      };
    } else
      ve = function() {
        I(Pe, 0);
      };
    function Re(te) {
      K = te, F || (F = !0, ve());
    }
    function he(te, de) {
      X = I(function() {
        te(t.unstable_now());
      }, de);
    }
    t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(te) {
      te.callback = null;
    }, t.unstable_continueExecution = function() {
      _ || x || (_ = !0, Re(z));
    }, t.unstable_forceFrameRate = function(te) {
      0 > te || 125 < te ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : se = 0 < te ? Math.floor(1e3 / te) : 5;
    }, t.unstable_getCurrentPriorityLevel = function() {
      return S;
    }, t.unstable_getFirstCallbackNode = function() {
      return n(p);
    }, t.unstable_next = function(te) {
      switch (S) {
        case 1:
        case 2:
        case 3:
          var de = 3;
          break;
        default:
          de = S;
      }
      var W = S;
      S = de;
      try {
        return te();
      } finally {
        S = W;
      }
    }, t.unstable_pauseExecution = function() {
    }, t.unstable_requestPaint = function() {
    }, t.unstable_runWithPriority = function(te, de) {
      switch (te) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          te = 3;
      }
      var W = S;
      S = te;
      try {
        return de();
      } finally {
        S = W;
      }
    }, t.unstable_scheduleCallback = function(te, de, W) {
      var fe = t.unstable_now();
      switch (typeof W == "object" && W !== null ? (W = W.delay, W = typeof W == "number" && 0 < W ? fe + W : fe) : W = fe, te) {
        case 1:
          var ce = -1;
          break;
        case 2:
          ce = 250;
          break;
        case 5:
          ce = 1073741823;
          break;
        case 4:
          ce = 1e4;
          break;
        default:
          ce = 5e3;
      }
      return ce = W + ce, te = { id: y++, callback: de, priorityLevel: te, startTime: W, expirationTime: ce, sortIndex: -1 }, W > fe ? (te.sortIndex = W, e(g, te), n(p) === null && te === n(g) && (T ? (D(X), X = -1) : T = !0, he(L, W - fe))) : (te.sortIndex = ce, e(p, te), _ || x || (_ = !0, Re(z))), te;
    }, t.unstable_shouldYield = pe, t.unstable_wrapCallback = function(te) {
      var de = S;
      return function() {
        var W = S;
        S = de;
        try {
          return te.apply(this, arguments);
        } finally {
          S = W;
        }
      };
    };
  }(mk)), mk;
}
var vk = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qD;
function Eie() {
  return qD || (qD = 1, function(t) {
    ({}).NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, n = !1, r = 5;
      function a(Je, Et) {
        var nn = Je.length;
        Je.push(Et), f(Je, Et, nn);
      }
      function s(Je) {
        return Je.length === 0 ? null : Je[0];
      }
      function c(Je) {
        if (Je.length === 0)
          return null;
        var Et = Je[0], nn = Je.pop();
        return nn !== Et && (Je[0] = nn, p(Je, nn, 0)), Et;
      }
      function f(Je, Et, nn) {
        for (var kn = nn; kn > 0; ) {
          var xn = kn - 1 >>> 1, _r = Je[xn];
          if (g(_r, Et) > 0)
            Je[xn] = Et, Je[kn] = _r, kn = xn;
          else
            return;
        }
      }
      function p(Je, Et, nn) {
        for (var kn = nn, xn = Je.length, _r = xn >>> 1; kn < _r; ) {
          var ur = (kn + 1) * 2 - 1, mi = Je[ur], pn = ur + 1, vi = Je[pn];
          if (g(mi, Et) < 0)
            pn < xn && g(vi, mi) < 0 ? (Je[kn] = vi, Je[pn] = Et, kn = pn) : (Je[kn] = mi, Je[ur] = Et, kn = ur);
          else if (pn < xn && g(vi, Et) < 0)
            Je[kn] = vi, Je[pn] = Et, kn = pn;
          else
            return;
        }
      }
      function g(Je, Et) {
        var nn = Je.sortIndex - Et.sortIndex;
        return nn !== 0 ? nn : Je.id - Et.id;
      }
      var y = 1, v = 2, S = 3, x = 4, _ = 5;
      function T(Je, Et) {
      }
      var I = typeof performance == "object" && typeof performance.now == "function";
      if (I) {
        var D = performance;
        t.unstable_now = function() {
          return D.now();
        };
      } else {
        var N = Date, j = N.now();
        t.unstable_now = function() {
          return N.now() - j;
        };
      }
      var L = 1073741823, z = -1, F = 250, K = 5e3, X = 1e4, se = L, ue = [], pe = [], Pe = 1, ve = null, Y = S, le = !1, Re = !1, he = !1, te = typeof setTimeout == "function" ? setTimeout : null, de = typeof clearTimeout == "function" ? clearTimeout : null, W = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function fe(Je) {
        for (var Et = s(pe); Et !== null; ) {
          if (Et.callback === null)
            c(pe);
          else if (Et.startTime <= Je)
            c(pe), Et.sortIndex = Et.expirationTime, a(ue, Et);
          else
            return;
          Et = s(pe);
        }
      }
      function ce(Je) {
        if (he = !1, fe(Je), !Re)
          if (s(ue) !== null)
            Re = !0, ni(xe);
          else {
            var Et = s(pe);
            Et !== null && An(ce, Et.startTime - Je);
          }
      }
      function xe(Je, Et) {
        Re = !1, he && (he = !1, qn()), le = !0;
        var nn = Y;
        try {
          var kn;
          if (!n)
            return $e(Je, Et);
        } finally {
          ve = null, Y = nn, le = !1;
        }
      }
      function $e(Je, Et) {
        var nn = Et;
        for (fe(nn), ve = s(ue); ve !== null && !e && !(ve.expirationTime > nn && (!Je || Er())); ) {
          var kn = ve.callback;
          if (typeof kn == "function") {
            ve.callback = null, Y = ve.priorityLevel;
            var xn = ve.expirationTime <= nn, _r = kn(xn);
            nn = t.unstable_now(), typeof _r == "function" ? ve.callback = _r : ve === s(ue) && c(ue), fe(nn);
          } else
            c(ue);
          ve = s(ue);
        }
        if (ve !== null)
          return !0;
        var ur = s(pe);
        return ur !== null && An(ce, ur.startTime - nn), !1;
      }
      function Me(Je, Et) {
        switch (Je) {
          case y:
          case v:
          case S:
          case x:
          case _:
            break;
          default:
            Je = S;
        }
        var nn = Y;
        Y = Je;
        try {
          return Et();
        } finally {
          Y = nn;
        }
      }
      function re(Je) {
        var Et;
        switch (Y) {
          case y:
          case v:
          case S:
            Et = S;
            break;
          default:
            Et = Y;
            break;
        }
        var nn = Y;
        Y = Et;
        try {
          return Je();
        } finally {
          Y = nn;
        }
      }
      function Qe(Je) {
        var Et = Y;
        return function() {
          var nn = Y;
          Y = Et;
          try {
            return Je.apply(this, arguments);
          } finally {
            Y = nn;
          }
        };
      }
      function ke(Je, Et, nn) {
        var kn = t.unstable_now(), xn;
        if (typeof nn == "object" && nn !== null) {
          var _r = nn.delay;
          typeof _r == "number" && _r > 0 ? xn = kn + _r : xn = kn;
        } else
          xn = kn;
        var ur;
        switch (Je) {
          case y:
            ur = z;
            break;
          case v:
            ur = F;
            break;
          case _:
            ur = se;
            break;
          case x:
            ur = X;
            break;
          case S:
          default:
            ur = K;
            break;
        }
        var mi = xn + ur, pn = {
          id: Pe++,
          callback: Et,
          priorityLevel: Je,
          startTime: xn,
          expirationTime: mi,
          sortIndex: -1
        };
        return xn > kn ? (pn.sortIndex = xn, a(pe, pn), s(ue) === null && pn === s(pe) && (he ? qn() : he = !0, An(ce, xn - kn))) : (pn.sortIndex = mi, a(ue, pn), !Re && !le && (Re = !0, ni(xe))), pn;
      }
      function rt() {
      }
      function St() {
        !Re && !le && (Re = !0, ni(xe));
      }
      function Tt() {
        return s(ue);
      }
      function Le(Je) {
        Je.callback = null;
      }
      function Nt() {
        return Y;
      }
      var Ke = !1, yt = null, Xt = -1, kt = r, yn = -1;
      function Er() {
        var Je = t.unstable_now() - yn;
        return !(Je < kt);
      }
      function tn() {
      }
      function Mr(Je) {
        if (Je < 0 || Je > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Je > 0 ? kt = Math.floor(1e3 / Je) : kt = r;
      }
      var Ur = function() {
        if (yt !== null) {
          var Je = t.unstable_now();
          yn = Je;
          var Et = !0, nn = !0;
          try {
            nn = yt(Et, Je);
          } finally {
            nn ? Hn() : (Ke = !1, yt = null);
          }
        } else
          Ke = !1;
      }, Hn;
      if (typeof W == "function")
        Hn = function() {
          W(Ur);
        };
      else if (typeof MessageChannel < "u") {
        var xt = new MessageChannel(), cn = xt.port2;
        xt.port1.onmessage = Ur, Hn = function() {
          cn.postMessage(null);
        };
      } else
        Hn = function() {
          te(Ur, 0);
        };
      function ni(Je) {
        yt = Je, Ke || (Ke = !0, Hn());
      }
      function An(Je, Et) {
        Xt = te(function() {
          Je(t.unstable_now());
        }, Et);
      }
      function qn() {
        de(Xt), Xt = -1;
      }
      var Go = tn, Cr = null;
      t.unstable_IdlePriority = _, t.unstable_ImmediatePriority = y, t.unstable_LowPriority = x, t.unstable_NormalPriority = S, t.unstable_Profiling = Cr, t.unstable_UserBlockingPriority = v, t.unstable_cancelCallback = Le, t.unstable_continueExecution = St, t.unstable_forceFrameRate = Mr, t.unstable_getCurrentPriorityLevel = Nt, t.unstable_getFirstCallbackNode = Tt, t.unstable_next = re, t.unstable_pauseExecution = rt, t.unstable_requestPaint = Go, t.unstable_runWithPriority = Me, t.unstable_scheduleCallback = ke, t.unstable_shouldYield = Er, t.unstable_wrapCallback = Qe, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(vk)), vk;
}
var QD;
function Hj() {
  return QD || (QD = 1, {}.NODE_ENV === "production" ? Yw.exports = xie() : Yw.exports = Eie()), Yw.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ZD;
function Cie() {
  if (ZD)
    return Ha;
  ZD = 1;
  var t = k, e = Hj();
  function n(l) {
    for (var u = "https://reactjs.org/docs/error-decoder.html?invariant=" + l, m = 1; m < arguments.length; m++)
      u += "&args[]=" + encodeURIComponent(arguments[m]);
    return "Minified React error #" + l + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = /* @__PURE__ */ new Set(), a = {};
  function s(l, u) {
    c(l, u), c(l + "Capture", u);
  }
  function c(l, u) {
    for (a[l] = u, l = 0; l < u.length; l++)
      r.add(u[l]);
  }
  var f = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), p = Object.prototype.hasOwnProperty, g = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, y = {}, v = {};
  function S(l) {
    return p.call(v, l) ? !0 : p.call(y, l) ? !1 : g.test(l) ? v[l] = !0 : (y[l] = !0, !1);
  }
  function x(l, u, m, w) {
    if (m !== null && m.type === 0)
      return !1;
    switch (typeof u) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return w ? !1 : m !== null ? !m.acceptsBooleans : (l = l.toLowerCase().slice(0, 5), l !== "data-" && l !== "aria-");
      default:
        return !1;
    }
  }
  function _(l, u, m, w) {
    if (u === null || typeof u > "u" || x(l, u, m, w))
      return !0;
    if (w)
      return !1;
    if (m !== null)
      switch (m.type) {
        case 3:
          return !u;
        case 4:
          return u === !1;
        case 5:
          return isNaN(u);
        case 6:
          return isNaN(u) || 1 > u;
      }
    return !1;
  }
  function T(l, u, m, w, P, M, H) {
    this.acceptsBooleans = u === 2 || u === 3 || u === 4, this.attributeName = w, this.attributeNamespace = P, this.mustUseProperty = m, this.propertyName = l, this.type = u, this.sanitizeURL = M, this.removeEmptyString = H;
  }
  var I = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(l) {
    I[l] = new T(l, 0, !1, l, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(l) {
    var u = l[0];
    I[u] = new T(u, 1, !1, l[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(l) {
    I[l] = new T(l, 2, !1, l.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(l) {
    I[l] = new T(l, 2, !1, l, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(l) {
    I[l] = new T(l, 3, !1, l.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(l) {
    I[l] = new T(l, 3, !0, l, null, !1, !1);
  }), ["capture", "download"].forEach(function(l) {
    I[l] = new T(l, 4, !1, l, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(l) {
    I[l] = new T(l, 6, !1, l, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(l) {
    I[l] = new T(l, 5, !1, l.toLowerCase(), null, !1, !1);
  });
  var D = /[\-:]([a-z])/g;
  function N(l) {
    return l[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(l) {
    var u = l.replace(
      D,
      N
    );
    I[u] = new T(u, 1, !1, l, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(l) {
    var u = l.replace(D, N);
    I[u] = new T(u, 1, !1, l, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(l) {
    var u = l.replace(D, N);
    I[u] = new T(u, 1, !1, l, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(l) {
    I[l] = new T(l, 1, !1, l.toLowerCase(), null, !1, !1);
  }), I.xlinkHref = new T("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(l) {
    I[l] = new T(l, 1, !1, l.toLowerCase(), null, !0, !0);
  });
  function j(l, u, m, w) {
    var P = I.hasOwnProperty(u) ? I[u] : null;
    (P !== null ? P.type !== 0 : w || !(2 < u.length) || u[0] !== "o" && u[0] !== "O" || u[1] !== "n" && u[1] !== "N") && (_(u, m, P, w) && (m = null), w || P === null ? S(u) && (m === null ? l.removeAttribute(u) : l.setAttribute(u, "" + m)) : P.mustUseProperty ? l[P.propertyName] = m === null ? P.type === 3 ? !1 : "" : m : (u = P.attributeName, w = P.attributeNamespace, m === null ? l.removeAttribute(u) : (P = P.type, m = P === 3 || P === 4 && m === !0 ? "" : "" + m, w ? l.setAttributeNS(w, u, m) : l.setAttribute(u, m))));
  }
  var L = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, z = Symbol.for("react.element"), F = Symbol.for("react.portal"), K = Symbol.for("react.fragment"), X = Symbol.for("react.strict_mode"), se = Symbol.for("react.profiler"), ue = Symbol.for("react.provider"), pe = Symbol.for("react.context"), Pe = Symbol.for("react.forward_ref"), ve = Symbol.for("react.suspense"), Y = Symbol.for("react.suspense_list"), le = Symbol.for("react.memo"), Re = Symbol.for("react.lazy"), he = Symbol.for("react.offscreen"), te = Symbol.iterator;
  function de(l) {
    return l === null || typeof l != "object" ? null : (l = te && l[te] || l["@@iterator"], typeof l == "function" ? l : null);
  }
  var W = Object.assign, fe;
  function ce(l) {
    if (fe === void 0)
      try {
        throw Error();
      } catch (m) {
        var u = m.stack.trim().match(/\n( *(at )?)/);
        fe = u && u[1] || "";
      }
    return `
` + fe + l;
  }
  var xe = !1;
  function $e(l, u) {
    if (!l || xe)
      return "";
    xe = !0;
    var m = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (u)
        if (u = function() {
          throw Error();
        }, Object.defineProperty(u.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(u, []);
          } catch (Te) {
            var w = Te;
          }
          Reflect.construct(l, [], u);
        } else {
          try {
            u.call();
          } catch (Te) {
            w = Te;
          }
          l.call(u.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Te) {
          w = Te;
        }
        l();
      }
    } catch (Te) {
      if (Te && w && typeof Te.stack == "string") {
        for (var P = Te.stack.split(`
`), M = w.stack.split(`
`), H = P.length - 1, Q = M.length - 1; 1 <= H && 0 <= Q && P[H] !== M[Q]; )
          Q--;
        for (; 1 <= H && 0 <= Q; H--, Q--)
          if (P[H] !== M[Q]) {
            if (H !== 1 || Q !== 1)
              do
                if (H--, Q--, 0 > Q || P[H] !== M[Q]) {
                  var ee = `
` + P[H].replace(" at new ", " at ");
                  return l.displayName && ee.includes("<anonymous>") && (ee = ee.replace("<anonymous>", l.displayName)), ee;
                }
              while (1 <= H && 0 <= Q);
            break;
          }
      }
    } finally {
      xe = !1, Error.prepareStackTrace = m;
    }
    return (l = l ? l.displayName || l.name : "") ? ce(l) : "";
  }
  function Me(l) {
    switch (l.tag) {
      case 5:
        return ce(l.type);
      case 16:
        return ce("Lazy");
      case 13:
        return ce("Suspense");
      case 19:
        return ce("SuspenseList");
      case 0:
      case 2:
      case 15:
        return l = $e(l.type, !1), l;
      case 11:
        return l = $e(l.type.render, !1), l;
      case 1:
        return l = $e(l.type, !0), l;
      default:
        return "";
    }
  }
  function re(l) {
    if (l == null)
      return null;
    if (typeof l == "function")
      return l.displayName || l.name || null;
    if (typeof l == "string")
      return l;
    switch (l) {
      case K:
        return "Fragment";
      case F:
        return "Portal";
      case se:
        return "Profiler";
      case X:
        return "StrictMode";
      case ve:
        return "Suspense";
      case Y:
        return "SuspenseList";
    }
    if (typeof l == "object")
      switch (l.$$typeof) {
        case pe:
          return (l.displayName || "Context") + ".Consumer";
        case ue:
          return (l._context.displayName || "Context") + ".Provider";
        case Pe:
          var u = l.render;
          return l = l.displayName, l || (l = u.displayName || u.name || "", l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef"), l;
        case le:
          return u = l.displayName || null, u !== null ? u : re(l.type) || "Memo";
        case Re:
          u = l._payload, l = l._init;
          try {
            return re(l(u));
          } catch {
          }
      }
    return null;
  }
  function Qe(l) {
    var u = l.type;
    switch (l.tag) {
      case 24:
        return "Cache";
      case 9:
        return (u.displayName || "Context") + ".Consumer";
      case 10:
        return (u._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return l = u.render, l = l.displayName || l.name || "", u.displayName || (l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return u;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return re(u);
      case 8:
        return u === X ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof u == "function")
          return u.displayName || u.name || null;
        if (typeof u == "string")
          return u;
    }
    return null;
  }
  function ke(l) {
    switch (typeof l) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return l;
      case "object":
        return l;
      default:
        return "";
    }
  }
  function rt(l) {
    var u = l.type;
    return (l = l.nodeName) && l.toLowerCase() === "input" && (u === "checkbox" || u === "radio");
  }
  function St(l) {
    var u = rt(l) ? "checked" : "value", m = Object.getOwnPropertyDescriptor(l.constructor.prototype, u), w = "" + l[u];
    if (!l.hasOwnProperty(u) && typeof m < "u" && typeof m.get == "function" && typeof m.set == "function") {
      var P = m.get, M = m.set;
      return Object.defineProperty(l, u, { configurable: !0, get: function() {
        return P.call(this);
      }, set: function(H) {
        w = "" + H, M.call(this, H);
      } }), Object.defineProperty(l, u, { enumerable: m.enumerable }), { getValue: function() {
        return w;
      }, setValue: function(H) {
        w = "" + H;
      }, stopTracking: function() {
        l._valueTracker = null, delete l[u];
      } };
    }
  }
  function Tt(l) {
    l._valueTracker || (l._valueTracker = St(l));
  }
  function Le(l) {
    if (!l)
      return !1;
    var u = l._valueTracker;
    if (!u)
      return !0;
    var m = u.getValue(), w = "";
    return l && (w = rt(l) ? l.checked ? "true" : "false" : l.value), l = w, l !== m ? (u.setValue(l), !0) : !1;
  }
  function Nt(l) {
    if (l = l || (typeof document < "u" ? document : void 0), typeof l > "u")
      return null;
    try {
      return l.activeElement || l.body;
    } catch {
      return l.body;
    }
  }
  function Ke(l, u) {
    var m = u.checked;
    return W({}, u, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: m ?? l._wrapperState.initialChecked });
  }
  function yt(l, u) {
    var m = u.defaultValue == null ? "" : u.defaultValue, w = u.checked != null ? u.checked : u.defaultChecked;
    m = ke(u.value != null ? u.value : m), l._wrapperState = { initialChecked: w, initialValue: m, controlled: u.type === "checkbox" || u.type === "radio" ? u.checked != null : u.value != null };
  }
  function Xt(l, u) {
    u = u.checked, u != null && j(l, "checked", u, !1);
  }
  function kt(l, u) {
    Xt(l, u);
    var m = ke(u.value), w = u.type;
    if (m != null)
      w === "number" ? (m === 0 && l.value === "" || l.value != m) && (l.value = "" + m) : l.value !== "" + m && (l.value = "" + m);
    else if (w === "submit" || w === "reset") {
      l.removeAttribute("value");
      return;
    }
    u.hasOwnProperty("value") ? Er(l, u.type, m) : u.hasOwnProperty("defaultValue") && Er(l, u.type, ke(u.defaultValue)), u.checked == null && u.defaultChecked != null && (l.defaultChecked = !!u.defaultChecked);
  }
  function yn(l, u, m) {
    if (u.hasOwnProperty("value") || u.hasOwnProperty("defaultValue")) {
      var w = u.type;
      if (!(w !== "submit" && w !== "reset" || u.value !== void 0 && u.value !== null))
        return;
      u = "" + l._wrapperState.initialValue, m || u === l.value || (l.value = u), l.defaultValue = u;
    }
    m = l.name, m !== "" && (l.name = ""), l.defaultChecked = !!l._wrapperState.initialChecked, m !== "" && (l.name = m);
  }
  function Er(l, u, m) {
    (u !== "number" || Nt(l.ownerDocument) !== l) && (m == null ? l.defaultValue = "" + l._wrapperState.initialValue : l.defaultValue !== "" + m && (l.defaultValue = "" + m));
  }
  var tn = Array.isArray;
  function Mr(l, u, m, w) {
    if (l = l.options, u) {
      u = {};
      for (var P = 0; P < m.length; P++)
        u["$" + m[P]] = !0;
      for (m = 0; m < l.length; m++)
        P = u.hasOwnProperty("$" + l[m].value), l[m].selected !== P && (l[m].selected = P), P && w && (l[m].defaultSelected = !0);
    } else {
      for (m = "" + ke(m), u = null, P = 0; P < l.length; P++) {
        if (l[P].value === m) {
          l[P].selected = !0, w && (l[P].defaultSelected = !0);
          return;
        }
        u !== null || l[P].disabled || (u = l[P]);
      }
      u !== null && (u.selected = !0);
    }
  }
  function Ur(l, u) {
    if (u.dangerouslySetInnerHTML != null)
      throw Error(n(91));
    return W({}, u, { value: void 0, defaultValue: void 0, children: "" + l._wrapperState.initialValue });
  }
  function Hn(l, u) {
    var m = u.value;
    if (m == null) {
      if (m = u.children, u = u.defaultValue, m != null) {
        if (u != null)
          throw Error(n(92));
        if (tn(m)) {
          if (1 < m.length)
            throw Error(n(93));
          m = m[0];
        }
        u = m;
      }
      u == null && (u = ""), m = u;
    }
    l._wrapperState = { initialValue: ke(m) };
  }
  function xt(l, u) {
    var m = ke(u.value), w = ke(u.defaultValue);
    m != null && (m = "" + m, m !== l.value && (l.value = m), u.defaultValue == null && l.defaultValue !== m && (l.defaultValue = m)), w != null && (l.defaultValue = "" + w);
  }
  function cn(l) {
    var u = l.textContent;
    u === l._wrapperState.initialValue && u !== "" && u !== null && (l.value = u);
  }
  function ni(l) {
    switch (l) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function An(l, u) {
    return l == null || l === "http://www.w3.org/1999/xhtml" ? ni(u) : l === "http://www.w3.org/2000/svg" && u === "foreignObject" ? "http://www.w3.org/1999/xhtml" : l;
  }
  var qn, Go = function(l) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(u, m, w, P) {
      MSApp.execUnsafeLocalFunction(function() {
        return l(u, m, w, P);
      });
    } : l;
  }(function(l, u) {
    if (l.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in l)
      l.innerHTML = u;
    else {
      for (qn = qn || document.createElement("div"), qn.innerHTML = "<svg>" + u.valueOf().toString() + "</svg>", u = qn.firstChild; l.firstChild; )
        l.removeChild(l.firstChild);
      for (; u.firstChild; )
        l.appendChild(u.firstChild);
    }
  });
  function Cr(l, u) {
    if (u) {
      var m = l.firstChild;
      if (m && m === l.lastChild && m.nodeType === 3) {
        m.nodeValue = u;
        return;
      }
    }
    l.textContent = u;
  }
  var Je = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, Et = ["Webkit", "ms", "Moz", "O"];
  Object.keys(Je).forEach(function(l) {
    Et.forEach(function(u) {
      u = u + l.charAt(0).toUpperCase() + l.substring(1), Je[u] = Je[l];
    });
  });
  function nn(l, u, m) {
    return u == null || typeof u == "boolean" || u === "" ? "" : m || typeof u != "number" || u === 0 || Je.hasOwnProperty(l) && Je[l] ? ("" + u).trim() : u + "px";
  }
  function kn(l, u) {
    l = l.style;
    for (var m in u)
      if (u.hasOwnProperty(m)) {
        var w = m.indexOf("--") === 0, P = nn(m, u[m], w);
        m === "float" && (m = "cssFloat"), w ? l.setProperty(m, P) : l[m] = P;
      }
  }
  var xn = W({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function _r(l, u) {
    if (u) {
      if (xn[l] && (u.children != null || u.dangerouslySetInnerHTML != null))
        throw Error(n(137, l));
      if (u.dangerouslySetInnerHTML != null) {
        if (u.children != null)
          throw Error(n(60));
        if (typeof u.dangerouslySetInnerHTML != "object" || !("__html" in u.dangerouslySetInnerHTML))
          throw Error(n(61));
      }
      if (u.style != null && typeof u.style != "object")
        throw Error(n(62));
    }
  }
  function ur(l, u) {
    if (l.indexOf("-") === -1)
      return typeof u.is == "string";
    switch (l) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var mi = null;
  function pn(l) {
    return l = l.target || l.srcElement || window, l.correspondingUseElement && (l = l.correspondingUseElement), l.nodeType === 3 ? l.parentNode : l;
  }
  var vi = null, On = null, Dn = null;
  function ao(l) {
    if (l = If(l)) {
      if (typeof vi != "function")
        throw Error(n(280));
      var u = l.stateNode;
      u && (u = Mt(u), vi(l.stateNode, l.type, u));
    }
  }
  function yi(l) {
    On ? Dn ? Dn.push(l) : Dn = [l] : On = l;
  }
  function Sa() {
    if (On) {
      var l = On, u = Dn;
      if (Dn = On = null, ao(l), u)
        for (l = 0; l < u.length; l++)
          ao(u[l]);
    }
  }
  function Qa(l, u) {
    return l(u);
  }
  function vs() {
  }
  var so = !1;
  function ys(l, u, m) {
    if (so)
      return l(u, m);
    so = !0;
    try {
      return Qa(l, u, m);
    } finally {
      so = !1, (On !== null || Dn !== null) && (vs(), Sa());
    }
  }
  function lo(l, u) {
    var m = l.stateNode;
    if (m === null)
      return null;
    var w = Mt(m);
    if (w === null)
      return null;
    m = w[u];
    e:
      switch (u) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (w = !w.disabled) || (l = l.type, w = !(l === "button" || l === "input" || l === "select" || l === "textarea")), l = !w;
          break e;
        default:
          l = !1;
      }
    if (l)
      return null;
    if (m && typeof m != "function")
      throw Error(n(231, u, typeof m));
    return m;
  }
  var wa = !1;
  if (f)
    try {
      var co = {};
      Object.defineProperty(co, "passive", { get: function() {
        wa = !0;
      } }), window.addEventListener("test", co, co), window.removeEventListener("test", co, co);
    } catch {
      wa = !1;
    }
  function xa(l, u, m, w, P, M, H, Q, ee) {
    var Te = Array.prototype.slice.call(arguments, 3);
    try {
      u.apply(m, Te);
    } catch (Ve) {
      this.onError(Ve);
    }
  }
  var bi = !1, Mi = null, Si = !1, J = null, Be = { onError: function(l) {
    bi = !0, Mi = l;
  } };
  function et(l, u, m, w, P, M, H, Q, ee) {
    bi = !1, Mi = null, xa.apply(Be, arguments);
  }
  function st(l, u, m, w, P, M, H, Q, ee) {
    if (et.apply(this, arguments), bi) {
      if (bi) {
        var Te = Mi;
        bi = !1, Mi = null;
      } else
        throw Error(n(198));
      Si || (Si = !0, J = Te);
    }
  }
  function Kt(l) {
    var u = l, m = l;
    if (l.alternate)
      for (; u.return; )
        u = u.return;
    else {
      l = u;
      do
        u = l, u.flags & 4098 && (m = u.return), l = u.return;
      while (l);
    }
    return u.tag === 3 ? m : null;
  }
  function qt(l) {
    if (l.tag === 13) {
      var u = l.memoizedState;
      if (u === null && (l = l.alternate, l !== null && (u = l.memoizedState)), u !== null)
        return u.dehydrated;
    }
    return null;
  }
  function Qt(l) {
    if (Kt(l) !== l)
      throw Error(n(188));
  }
  function Rt(l) {
    var u = l.alternate;
    if (!u) {
      if (u = Kt(l), u === null)
        throw Error(n(188));
      return u !== l ? null : l;
    }
    for (var m = l, w = u; ; ) {
      var P = m.return;
      if (P === null)
        break;
      var M = P.alternate;
      if (M === null) {
        if (w = P.return, w !== null) {
          m = w;
          continue;
        }
        break;
      }
      if (P.child === M.child) {
        for (M = P.child; M; ) {
          if (M === m)
            return Qt(P), l;
          if (M === w)
            return Qt(P), u;
          M = M.sibling;
        }
        throw Error(n(188));
      }
      if (m.return !== w.return)
        m = P, w = M;
      else {
        for (var H = !1, Q = P.child; Q; ) {
          if (Q === m) {
            H = !0, m = P, w = M;
            break;
          }
          if (Q === w) {
            H = !0, w = P, m = M;
            break;
          }
          Q = Q.sibling;
        }
        if (!H) {
          for (Q = M.child; Q; ) {
            if (Q === m) {
              H = !0, m = M, w = P;
              break;
            }
            if (Q === w) {
              H = !0, w = M, m = P;
              break;
            }
            Q = Q.sibling;
          }
          if (!H)
            throw Error(n(189));
        }
      }
      if (m.alternate !== w)
        throw Error(n(190));
    }
    if (m.tag !== 3)
      throw Error(n(188));
    return m.stateNode.current === m ? l : u;
  }
  function Br(l) {
    return l = Rt(l), l !== null ? Qn(l) : null;
  }
  function Qn(l) {
    if (l.tag === 5 || l.tag === 6)
      return l;
    for (l = l.child; l !== null; ) {
      var u = Qn(l);
      if (u !== null)
        return u;
      l = l.sibling;
    }
    return null;
  }
  var Zn = e.unstable_scheduleCallback, hr = e.unstable_cancelCallback, Ea = e.unstable_shouldYield, jl = e.unstable_requestPaint, bn = e.unstable_now, hf = e.unstable_getCurrentPriorityLevel, Xo = e.unstable_ImmediatePriority, Jt = e.unstable_UserBlockingPriority, Ca = e.unstable_NormalPriority, bs = e.unstable_LowPriority, uo = e.unstable_IdlePriority, Ss = null, Wi = null;
  function jc(l) {
    if (Wi && typeof Wi.onCommitFiberRoot == "function")
      try {
        Wi.onCommitFiberRoot(Ss, l, void 0, (l.current.flags & 128) === 128);
      } catch {
      }
  }
  var Ai = Math.clz32 ? Math.clz32 : Qs, zc = Math.log, Uc = Math.LN2;
  function Qs(l) {
    return l >>>= 0, l === 0 ? 32 : 31 - (zc(l) / Uc | 0) | 0;
  }
  var zl = 64, Po = 4194304;
  function Io(l) {
    switch (l & -l) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return l & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return l;
    }
  }
  function wi(l, u) {
    var m = l.pendingLanes;
    if (m === 0)
      return 0;
    var w = 0, P = l.suspendedLanes, M = l.pingedLanes, H = m & 268435455;
    if (H !== 0) {
      var Q = H & ~P;
      Q !== 0 ? w = Io(Q) : (M &= H, M !== 0 && (w = Io(M)));
    } else
      H = m & ~P, H !== 0 ? w = Io(H) : M !== 0 && (w = Io(M));
    if (w === 0)
      return 0;
    if (u !== 0 && u !== w && !(u & P) && (P = w & -w, M = u & -u, P >= M || P === 16 && (M & 4194240) !== 0))
      return u;
    if (w & 4 && (w |= m & 16), u = l.entangledLanes, u !== 0)
      for (l = l.entanglements, u &= w; 0 < u; )
        m = 31 - Ai(u), P = 1 << m, w |= l[m], u &= ~P;
    return w;
  }
  function ws(l, u) {
    switch (l) {
      case 1:
      case 2:
      case 4:
        return u + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return u + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function xs(l, u) {
    for (var m = l.suspendedLanes, w = l.pingedLanes, P = l.expirationTimes, M = l.pendingLanes; 0 < M; ) {
      var H = 31 - Ai(M), Q = 1 << H, ee = P[H];
      ee === -1 ? (!(Q & m) || Q & w) && (P[H] = ws(Q, u)) : ee <= u && (l.expiredLanes |= Q), M &= ~Q;
    }
  }
  function Es(l) {
    return l = l.pendingLanes & -1073741825, l !== 0 ? l : l & 1073741824 ? 1073741824 : 0;
  }
  function Ul() {
    var l = zl;
    return zl <<= 1, !(zl & 4194240) && (zl = 64), l;
  }
  function Zs(l) {
    for (var u = [], m = 0; 31 > m; m++)
      u.push(l);
    return u;
  }
  function Za(l, u, m) {
    l.pendingLanes |= u, u !== 536870912 && (l.suspendedLanes = 0, l.pingedLanes = 0), l = l.eventTimes, u = 31 - Ai(u), l[u] = m;
  }
  function gf(l, u) {
    var m = l.pendingLanes & ~u;
    l.pendingLanes = u, l.suspendedLanes = 0, l.pingedLanes = 0, l.expiredLanes &= u, l.mutableReadLanes &= u, l.entangledLanes &= u, u = l.entanglements;
    var w = l.eventTimes;
    for (l = l.expirationTimes; 0 < m; ) {
      var P = 31 - Ai(m), M = 1 << P;
      u[P] = 0, w[P] = -1, l[P] = -1, m &= ~M;
    }
  }
  function qo(l, u) {
    var m = l.entangledLanes |= u;
    for (l = l.entanglements; m; ) {
      var w = 31 - Ai(m), P = 1 << w;
      P & u | l[w] & u && (l[w] |= u), m &= ~P;
    }
  }
  var hn = 0;
  function Qo(l) {
    return l &= -l, 1 < l ? 4 < l ? l & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var Js, Bl, rn, Fl, Hl, Ft = !1, el = [], gr = null, Fr = null, xi = null, Cs = /* @__PURE__ */ new Map(), or = /* @__PURE__ */ new Map(), Nn = [], Vl = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Gi(l, u) {
    switch (l) {
      case "focusin":
      case "focusout":
        gr = null;
        break;
      case "dragenter":
      case "dragleave":
        Fr = null;
        break;
      case "mouseover":
      case "mouseout":
        xi = null;
        break;
      case "pointerover":
      case "pointerout":
        Cs.delete(u.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        or.delete(u.pointerId);
    }
  }
  function Gr(l, u, m, w, P, M) {
    return l === null || l.nativeEvent !== M ? (l = { blockedOn: u, domEventName: m, eventSystemFlags: w, nativeEvent: M, targetContainers: [P] }, u !== null && (u = If(u), u !== null && Bl(u)), l) : (l.eventSystemFlags |= w, u = l.targetContainers, P !== null && u.indexOf(P) === -1 && u.push(P), l);
  }
  function Zo(l, u, m, w, P) {
    switch (u) {
      case "focusin":
        return gr = Gr(gr, l, u, m, w, P), !0;
      case "dragenter":
        return Fr = Gr(Fr, l, u, m, w, P), !0;
      case "mouseover":
        return xi = Gr(xi, l, u, m, w, P), !0;
      case "pointerover":
        var M = P.pointerId;
        return Cs.set(M, Gr(Cs.get(M) || null, l, u, m, w, P)), !0;
      case "gotpointercapture":
        return M = P.pointerId, or.set(M, Gr(or.get(M) || null, l, u, m, w, P)), !0;
    }
    return !1;
  }
  function Bc(l) {
    var u = Ta(l.target);
    if (u !== null) {
      var m = Kt(u);
      if (m !== null) {
        if (u = m.tag, u === 13) {
          if (u = qt(m), u !== null) {
            l.blockedOn = u, Hl(l.priority, function() {
              rn(m);
            });
            return;
          }
        } else if (u === 3 && m.stateNode.current.memoizedState.isDehydrated) {
          l.blockedOn = m.tag === 3 ? m.stateNode.containerInfo : null;
          return;
        }
      }
    }
    l.blockedOn = null;
  }
  function fo(l) {
    if (l.blockedOn !== null)
      return !1;
    for (var u = l.targetContainers; 0 < u.length; ) {
      var m = Kn(l.domEventName, l.eventSystemFlags, u[0], l.nativeEvent);
      if (m === null) {
        m = l.nativeEvent;
        var w = new m.constructor(m.type, m);
        mi = w, m.target.dispatchEvent(w), mi = null;
      } else
        return u = If(m), u !== null && Bl(u), l.blockedOn = m, !1;
      u.shift();
    }
    return !0;
  }
  function Ja(l, u, m) {
    fo(l) && m.delete(u);
  }
  function Yu() {
    Ft = !1, gr !== null && fo(gr) && (gr = null), Fr !== null && fo(Fr) && (Fr = null), xi !== null && fo(xi) && (xi = null), Cs.forEach(Ja), or.forEach(Ja);
  }
  function Ro(l, u) {
    l.blockedOn === u && (l.blockedOn = null, Ft || (Ft = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, Yu)));
  }
  function _s(l) {
    function u(P) {
      return Ro(P, l);
    }
    if (0 < el.length) {
      Ro(el[0], l);
      for (var m = 1; m < el.length; m++) {
        var w = el[m];
        w.blockedOn === l && (w.blockedOn = null);
      }
    }
    for (gr !== null && Ro(gr, l), Fr !== null && Ro(Fr, l), xi !== null && Ro(xi, l), Cs.forEach(u), or.forEach(u), m = 0; m < Nn.length; m++)
      w = Nn[m], w.blockedOn === l && (w.blockedOn = null);
    for (; 0 < Nn.length && (m = Nn[0], m.blockedOn === null); )
      Bc(m), m.blockedOn === null && Nn.shift();
  }
  var q = L.ReactCurrentBatchConfig, ie = !0;
  function Ue(l, u, m, w) {
    var P = hn, M = q.transition;
    q.transition = null;
    try {
      hn = 1, Pn(l, u, m, w);
    } finally {
      hn = P, q.transition = M;
    }
  }
  function it(l, u, m, w) {
    var P = hn, M = q.transition;
    q.transition = null;
    try {
      hn = 4, Pn(l, u, m, w);
    } finally {
      hn = P, q.transition = M;
    }
  }
  function Pn(l, u, m, w) {
    if (ie) {
      var P = Kn(l, u, m, w);
      if (P === null)
        Jp(l, u, w, Ut, m), Gi(l, w);
      else if (Zo(P, l, u, m, w))
        w.stopPropagation();
      else if (Gi(l, w), u & 4 && -1 < Vl.indexOf(l)) {
        for (; P !== null; ) {
          var M = If(P);
          if (M !== null && Js(M), M = Kn(l, u, m, w), M === null && Jp(l, u, w, Ut, m), M === P)
            break;
          P = M;
        }
        P !== null && w.stopPropagation();
      } else
        Jp(l, u, w, null, m);
    }
  }
  var Ut = null;
  function Kn(l, u, m, w) {
    if (Ut = null, l = pn(w), l = Ta(l), l !== null)
      if (u = Kt(l), u === null)
        l = null;
      else if (m = u.tag, m === 13) {
        if (l = qt(u), l !== null)
          return l;
        l = null;
      } else if (m === 3) {
        if (u.stateNode.current.memoizedState.isDehydrated)
          return u.tag === 3 ? u.stateNode.containerInfo : null;
        l = null;
      } else
        u !== l && (l = null);
    return Ut = l, null;
  }
  function Tr(l) {
    switch (l) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (hf()) {
          case Xo:
            return 1;
          case Jt:
            return 4;
          case Ca:
          case bs:
            return 16;
          case uo:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Wn = null, U = null, Z = null;
  function ye() {
    if (Z)
      return Z;
    var l, u = U, m = u.length, w, P = "value" in Wn ? Wn.value : Wn.textContent, M = P.length;
    for (l = 0; l < m && u[l] === P[l]; l++)
      ;
    var H = m - l;
    for (w = 1; w <= H && u[m - w] === P[M - w]; w++)
      ;
    return Z = P.slice(l, 1 < w ? 1 - w : void 0);
  }
  function Ee(l) {
    var u = l.keyCode;
    return "charCode" in l ? (l = l.charCode, l === 0 && u === 13 && (l = 13)) : l = u, l === 10 && (l = 13), 32 <= l || l === 13 ? l : 0;
  }
  function Fe() {
    return !0;
  }
  function ht() {
    return !1;
  }
  function Ze(l) {
    function u(m, w, P, M, H) {
      this._reactName = m, this._targetInst = P, this.type = w, this.nativeEvent = M, this.target = H, this.currentTarget = null;
      for (var Q in l)
        l.hasOwnProperty(Q) && (m = l[Q], this[Q] = m ? m(M) : M[Q]);
      return this.isDefaultPrevented = (M.defaultPrevented != null ? M.defaultPrevented : M.returnValue === !1) ? Fe : ht, this.isPropagationStopped = ht, this;
    }
    return W(u.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var m = this.nativeEvent;
      m && (m.preventDefault ? m.preventDefault() : typeof m.returnValue != "unknown" && (m.returnValue = !1), this.isDefaultPrevented = Fe);
    }, stopPropagation: function() {
      var m = this.nativeEvent;
      m && (m.stopPropagation ? m.stopPropagation() : typeof m.cancelBubble != "unknown" && (m.cancelBubble = !0), this.isPropagationStopped = Fe);
    }, persist: function() {
    }, isPersistent: Fe }), u;
  }
  var bt = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(l) {
    return l.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Yt = Ze(bt), gn = W({}, bt, { view: 0, detail: 0 }), Ln = Ze(gn), In, ar, dr, Sn = W({}, gn, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: xm, button: 0, buttons: 0, relatedTarget: function(l) {
    return l.relatedTarget === void 0 ? l.fromElement === l.srcElement ? l.toElement : l.fromElement : l.relatedTarget;
  }, movementX: function(l) {
    return "movementX" in l ? l.movementX : (l !== dr && (dr && l.type === "mousemove" ? (In = l.screenX - dr.screenX, ar = l.screenY - dr.screenY) : ar = In = 0, dr = l), In);
  }, movementY: function(l) {
    return "movementY" in l ? l.movementY : ar;
  } }), tl = Ze(Sn), Ku = W({}, Sn, { dataTransfer: 0 }), mf = Ze(Ku), ym = W({}, gn, { relatedTarget: 0 }), es = Ze(ym), vf = W({}, bt, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), yf = Ze(vf), bm = W({}, bt, { clipboardData: function(l) {
    return "clipboardData" in l ? l.clipboardData : window.clipboardData;
  } }), K1 = Ze(bm), W1 = W({}, bt, { data: 0 }), Sm = Ze(W1), wm = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Lb = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, jb = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function zb(l) {
    var u = this.nativeEvent;
    return u.getModifierState ? u.getModifierState(l) : (l = jb[l]) ? !!u[l] : !1;
  }
  function xm() {
    return zb;
  }
  var nl = W({}, gn, { key: function(l) {
    if (l.key) {
      var u = wm[l.key] || l.key;
      if (u !== "Unidentified")
        return u;
    }
    return l.type === "keypress" ? (l = Ee(l), l === 13 ? "Enter" : String.fromCharCode(l)) : l.type === "keydown" || l.type === "keyup" ? Lb[l.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: xm, charCode: function(l) {
    return l.type === "keypress" ? Ee(l) : 0;
  }, keyCode: function(l) {
    return l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0;
  }, which: function(l) {
    return l.type === "keypress" ? Ee(l) : l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0;
  } }), G1 = Ze(nl), Em = W({}, Sn, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Yp = Ze(Em), Cm = W({}, gn, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: xm }), X1 = Ze(Cm), Kp = W({}, bt, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Ub = Ze(Kp), $o = W({}, Sn, {
    deltaX: function(l) {
      return "deltaX" in l ? l.deltaX : "wheelDeltaX" in l ? -l.wheelDeltaX : 0;
    },
    deltaY: function(l) {
      return "deltaY" in l ? l.deltaY : "wheelDeltaY" in l ? -l.wheelDeltaY : "wheelDelta" in l ? -l.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), rl = Ze($o), ri = [9, 13, 27, 32], ts = f && "CompositionEvent" in window, Fc = null;
  f && "documentMode" in document && (Fc = document.documentMode);
  var Wp = f && "TextEvent" in window && !Fc, Bb = f && (!ts || Fc && 8 < Fc && 11 >= Fc), Wu = String.fromCharCode(32), Fb = !1;
  function Hb(l, u) {
    switch (l) {
      case "keyup":
        return ri.indexOf(u.keyCode) !== -1;
      case "keydown":
        return u.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Gp(l) {
    return l = l.detail, typeof l == "object" && "data" in l ? l.data : null;
  }
  var Gu = !1;
  function q1(l, u) {
    switch (l) {
      case "compositionend":
        return Gp(u);
      case "keypress":
        return u.which !== 32 ? null : (Fb = !0, Wu);
      case "textInput":
        return l = u.data, l === Wu && Fb ? null : l;
      default:
        return null;
    }
  }
  function Q1(l, u) {
    if (Gu)
      return l === "compositionend" || !ts && Hb(l, u) ? (l = ye(), Z = U = Wn = null, Gu = !1, l) : null;
    switch (l) {
      case "paste":
        return null;
      case "keypress":
        if (!(u.ctrlKey || u.altKey || u.metaKey) || u.ctrlKey && u.altKey) {
          if (u.char && 1 < u.char.length)
            return u.char;
          if (u.which)
            return String.fromCharCode(u.which);
        }
        return null;
      case "compositionend":
        return Bb && u.locale !== "ko" ? null : u.data;
      default:
        return null;
    }
  }
  var Vb = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function Yb(l) {
    var u = l && l.nodeName && l.nodeName.toLowerCase();
    return u === "input" ? !!Vb[l.type] : u === "textarea";
  }
  function Kb(l, u, m, w) {
    yi(w), u = Tf(u, "onChange"), 0 < u.length && (m = new Yt("onChange", "change", null, m, w), l.push({ event: m, listeners: u }));
  }
  var bf = null, Xu = null;
  function qu(l) {
    Zp(l, 0);
  }
  function Qu(l) {
    var u = Ju(l);
    if (Le(u))
      return l;
  }
  function Wb(l, u) {
    if (l === "change")
      return u;
  }
  var _m = !1;
  if (f) {
    var Tm;
    if (f) {
      var km = "oninput" in document;
      if (!km) {
        var Gb = document.createElement("div");
        Gb.setAttribute("oninput", "return;"), km = typeof Gb.oninput == "function";
      }
      Tm = km;
    } else
      Tm = !1;
    _m = Tm && (!document.documentMode || 9 < document.documentMode);
  }
  function Xb() {
    bf && (bf.detachEvent("onpropertychange", qb), Xu = bf = null);
  }
  function qb(l) {
    if (l.propertyName === "value" && Qu(Xu)) {
      var u = [];
      Kb(u, Xu, l, pn(l)), ys(qu, u);
    }
  }
  function Z1(l, u, m) {
    l === "focusin" ? (Xb(), bf = u, Xu = m, bf.attachEvent("onpropertychange", qb)) : l === "focusout" && Xb();
  }
  function J1(l) {
    if (l === "selectionchange" || l === "keyup" || l === "keydown")
      return Qu(Xu);
  }
  function eE(l, u) {
    if (l === "click")
      return Qu(u);
  }
  function Qb(l, u) {
    if (l === "input" || l === "change")
      return Qu(u);
  }
  function tE(l, u) {
    return l === u && (l !== 0 || 1 / l === 1 / u) || l !== l && u !== u;
  }
  var _a = typeof Object.is == "function" ? Object.is : tE;
  function Sf(l, u) {
    if (_a(l, u))
      return !0;
    if (typeof l != "object" || l === null || typeof u != "object" || u === null)
      return !1;
    var m = Object.keys(l), w = Object.keys(u);
    if (m.length !== w.length)
      return !1;
    for (w = 0; w < m.length; w++) {
      var P = m[w];
      if (!p.call(u, P) || !_a(l[P], u[P]))
        return !1;
    }
    return !0;
  }
  function Zb(l) {
    for (; l && l.firstChild; )
      l = l.firstChild;
    return l;
  }
  function Jb(l, u) {
    var m = Zb(l);
    l = 0;
    for (var w; m; ) {
      if (m.nodeType === 3) {
        if (w = l + m.textContent.length, l <= u && w >= u)
          return { node: m, offset: u - l };
        l = w;
      }
      e: {
        for (; m; ) {
          if (m.nextSibling) {
            m = m.nextSibling;
            break e;
          }
          m = m.parentNode;
        }
        m = void 0;
      }
      m = Zb(m);
    }
  }
  function e0(l, u) {
    return l && u ? l === u ? !0 : l && l.nodeType === 3 ? !1 : u && u.nodeType === 3 ? e0(l, u.parentNode) : "contains" in l ? l.contains(u) : l.compareDocumentPosition ? !!(l.compareDocumentPosition(u) & 16) : !1 : !1;
  }
  function Xp() {
    for (var l = window, u = Nt(); u instanceof l.HTMLIFrameElement; ) {
      try {
        var m = typeof u.contentWindow.location.href == "string";
      } catch {
        m = !1;
      }
      if (m)
        l = u.contentWindow;
      else
        break;
      u = Nt(l.document);
    }
    return u;
  }
  function il(l) {
    var u = l && l.nodeName && l.nodeName.toLowerCase();
    return u && (u === "input" && (l.type === "text" || l.type === "search" || l.type === "tel" || l.type === "url" || l.type === "password") || u === "textarea" || l.contentEditable === "true");
  }
  function qp(l) {
    var u = Xp(), m = l.focusedElem, w = l.selectionRange;
    if (u !== m && m && m.ownerDocument && e0(m.ownerDocument.documentElement, m)) {
      if (w !== null && il(m)) {
        if (u = w.start, l = w.end, l === void 0 && (l = u), "selectionStart" in m)
          m.selectionStart = u, m.selectionEnd = Math.min(l, m.value.length);
        else if (l = (u = m.ownerDocument || document) && u.defaultView || window, l.getSelection) {
          l = l.getSelection();
          var P = m.textContent.length, M = Math.min(w.start, P);
          w = w.end === void 0 ? M : Math.min(w.end, P), !l.extend && M > w && (P = w, w = M, M = P), P = Jb(m, M);
          var H = Jb(
            m,
            w
          );
          P && H && (l.rangeCount !== 1 || l.anchorNode !== P.node || l.anchorOffset !== P.offset || l.focusNode !== H.node || l.focusOffset !== H.offset) && (u = u.createRange(), u.setStart(P.node, P.offset), l.removeAllRanges(), M > w ? (l.addRange(u), l.extend(H.node, H.offset)) : (u.setEnd(H.node, H.offset), l.addRange(u)));
        }
      }
      for (u = [], l = m; l = l.parentNode; )
        l.nodeType === 1 && u.push({ element: l, left: l.scrollLeft, top: l.scrollTop });
      for (typeof m.focus == "function" && m.focus(), m = 0; m < u.length; m++)
        l = u[m], l.element.scrollLeft = l.left, l.element.scrollTop = l.top;
    }
  }
  var t0 = f && "documentMode" in document && 11 >= document.documentMode, ns = null, Pm = null, wf = null, Im = !1;
  function n0(l, u, m) {
    var w = m.window === m ? m.document : m.nodeType === 9 ? m : m.ownerDocument;
    Im || ns == null || ns !== Nt(w) || (w = ns, "selectionStart" in w && il(w) ? w = { start: w.selectionStart, end: w.selectionEnd } : (w = (w.ownerDocument && w.ownerDocument.defaultView || window).getSelection(), w = { anchorNode: w.anchorNode, anchorOffset: w.anchorOffset, focusNode: w.focusNode, focusOffset: w.focusOffset }), wf && Sf(wf, w) || (wf = w, w = Tf(Pm, "onSelect"), 0 < w.length && (u = new Yt("onSelect", "select", null, u, m), l.push({ event: u, listeners: w }), u.target = ns)));
  }
  function Qp(l, u) {
    var m = {};
    return m[l.toLowerCase()] = u.toLowerCase(), m["Webkit" + l] = "webkit" + u, m["Moz" + l] = "moz" + u, m;
  }
  var Hc = { animationend: Qp("Animation", "AnimationEnd"), animationiteration: Qp("Animation", "AnimationIteration"), animationstart: Qp("Animation", "AnimationStart"), transitionend: Qp("Transition", "TransitionEnd") }, Rm = {}, $m = {};
  f && ($m = document.createElement("div").style, "AnimationEvent" in window || (delete Hc.animationend.animation, delete Hc.animationiteration.animation, delete Hc.animationstart.animation), "TransitionEvent" in window || delete Hc.transitionend.transition);
  function Ei(l) {
    if (Rm[l])
      return Rm[l];
    if (!Hc[l])
      return l;
    var u = Hc[l], m;
    for (m in u)
      if (u.hasOwnProperty(m) && m in $m)
        return Rm[l] = u[m];
    return l;
  }
  var Mm = Ei("animationend"), r0 = Ei("animationiteration"), i0 = Ei("animationstart"), o0 = Ei("transitionend"), a0 = /* @__PURE__ */ new Map(), s0 = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ol(l, u) {
    a0.set(l, u), s(u, [l]);
  }
  for (var xf = 0; xf < s0.length; xf++) {
    var Vc = s0[xf], nE = Vc.toLowerCase(), Ef = Vc[0].toUpperCase() + Vc.slice(1);
    ol(nE, "on" + Ef);
  }
  ol(Mm, "onAnimationEnd"), ol(r0, "onAnimationIteration"), ol(i0, "onAnimationStart"), ol("dblclick", "onDoubleClick"), ol("focusin", "onFocus"), ol("focusout", "onBlur"), ol(o0, "onTransitionEnd"), c("onMouseEnter", ["mouseout", "mouseover"]), c("onMouseLeave", ["mouseout", "mouseover"]), c("onPointerEnter", ["pointerout", "pointerover"]), c("onPointerLeave", ["pointerout", "pointerover"]), s("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), s("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), s("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), s("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Cf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), rE = new Set("cancel close invalid load scroll toggle".split(" ").concat(Cf));
  function l0(l, u, m) {
    var w = l.type || "unknown-event";
    l.currentTarget = m, st(w, u, void 0, l), l.currentTarget = null;
  }
  function Zp(l, u) {
    u = (u & 4) !== 0;
    for (var m = 0; m < l.length; m++) {
      var w = l[m], P = w.event;
      w = w.listeners;
      e: {
        var M = void 0;
        if (u)
          for (var H = w.length - 1; 0 <= H; H--) {
            var Q = w[H], ee = Q.instance, Te = Q.currentTarget;
            if (Q = Q.listener, ee !== M && P.isPropagationStopped())
              break e;
            l0(P, Q, Te), M = ee;
          }
        else
          for (H = 0; H < w.length; H++) {
            if (Q = w[H], ee = Q.instance, Te = Q.currentTarget, Q = Q.listener, ee !== M && P.isPropagationStopped())
              break e;
            l0(P, Q, Te), M = ee;
          }
      }
    }
    if (Si)
      throw l = J, Si = !1, J = null, l;
  }
  function sr(l, u) {
    var m = u[zm];
    m === void 0 && (m = u[zm] = /* @__PURE__ */ new Set());
    var w = l + "__bubble";
    m.has(w) || (c0(u, l, 2, !1), m.add(w));
  }
  function Yl(l, u, m) {
    var w = 0;
    u && (w |= 4), c0(m, l, w, u);
  }
  var al = "_reactListening" + Math.random().toString(36).slice(2);
  function Zu(l) {
    if (!l[al]) {
      l[al] = !0, r.forEach(function(m) {
        m !== "selectionchange" && (rE.has(m) || Yl(m, !1, l), Yl(m, !0, l));
      });
      var u = l.nodeType === 9 ? l : l.ownerDocument;
      u === null || u[al] || (u[al] = !0, Yl("selectionchange", !1, u));
    }
  }
  function c0(l, u, m, w) {
    switch (Tr(u)) {
      case 1:
        var P = Ue;
        break;
      case 4:
        P = it;
        break;
      default:
        P = Pn;
    }
    m = P.bind(null, u, m, l), P = void 0, !wa || u !== "touchstart" && u !== "touchmove" && u !== "wheel" || (P = !0), w ? P !== void 0 ? l.addEventListener(u, m, { capture: !0, passive: P }) : l.addEventListener(u, m, !0) : P !== void 0 ? l.addEventListener(u, m, { passive: P }) : l.addEventListener(u, m, !1);
  }
  function Jp(l, u, m, w, P) {
    var M = w;
    if (!(u & 1) && !(u & 2) && w !== null)
      e:
        for (; ; ) {
          if (w === null)
            return;
          var H = w.tag;
          if (H === 3 || H === 4) {
            var Q = w.stateNode.containerInfo;
            if (Q === P || Q.nodeType === 8 && Q.parentNode === P)
              break;
            if (H === 4)
              for (H = w.return; H !== null; ) {
                var ee = H.tag;
                if ((ee === 3 || ee === 4) && (ee = H.stateNode.containerInfo, ee === P || ee.nodeType === 8 && ee.parentNode === P))
                  return;
                H = H.return;
              }
            for (; Q !== null; ) {
              if (H = Ta(Q), H === null)
                return;
              if (ee = H.tag, ee === 5 || ee === 6) {
                w = M = H;
                continue e;
              }
              Q = Q.parentNode;
            }
          }
          w = w.return;
        }
    ys(function() {
      var Te = M, Ve = pn(m), Ye = [];
      e: {
        var He = a0.get(l);
        if (He !== void 0) {
          var lt = Yt, gt = l;
          switch (l) {
            case "keypress":
              if (Ee(m) === 0)
                break e;
            case "keydown":
            case "keyup":
              lt = G1;
              break;
            case "focusin":
              gt = "focus", lt = es;
              break;
            case "focusout":
              gt = "blur", lt = es;
              break;
            case "beforeblur":
            case "afterblur":
              lt = es;
              break;
            case "click":
              if (m.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              lt = tl;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              lt = mf;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              lt = X1;
              break;
            case Mm:
            case r0:
            case i0:
              lt = yf;
              break;
            case o0:
              lt = Ub;
              break;
            case "scroll":
              lt = Ln;
              break;
            case "wheel":
              lt = rl;
              break;
            case "copy":
            case "cut":
            case "paste":
              lt = K1;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              lt = Yp;
          }
          var wt = (u & 4) !== 0, qr = !wt && l === "scroll", ge = wt ? He !== null ? He + "Capture" : null : He;
          wt = [];
          for (var oe = Te, we; oe !== null; ) {
            we = oe;
            var Xe = we.stateNode;
            if (we.tag === 5 && Xe !== null && (we = Xe, ge !== null && (Xe = lo(oe, ge), Xe != null && wt.push(_f(oe, Xe, we)))), qr)
              break;
            oe = oe.return;
          }
          0 < wt.length && (He = new lt(He, gt, null, m, Ve), Ye.push({ event: He, listeners: wt }));
        }
      }
      if (!(u & 7)) {
        e: {
          if (He = l === "mouseover" || l === "pointerover", lt = l === "mouseout" || l === "pointerout", He && m !== mi && (gt = m.relatedTarget || m.fromElement) && (Ta(gt) || gt[sl]))
            break e;
          if ((lt || He) && (He = Ve.window === Ve ? Ve : (He = Ve.ownerDocument) ? He.defaultView || He.parentWindow : window, lt ? (gt = m.relatedTarget || m.toElement, lt = Te, gt = gt ? Ta(gt) : null, gt !== null && (qr = Kt(gt), gt !== qr || gt.tag !== 5 && gt.tag !== 6) && (gt = null)) : (lt = null, gt = Te), lt !== gt)) {
            if (wt = tl, Xe = "onMouseLeave", ge = "onMouseEnter", oe = "mouse", (l === "pointerout" || l === "pointerover") && (wt = Yp, Xe = "onPointerLeave", ge = "onPointerEnter", oe = "pointer"), qr = lt == null ? He : Ju(lt), we = gt == null ? He : Ju(gt), He = new wt(Xe, oe + "leave", lt, m, Ve), He.target = qr, He.relatedTarget = we, Xe = null, Ta(Ve) === Te && (wt = new wt(ge, oe + "enter", gt, m, Ve), wt.target = we, wt.relatedTarget = qr, Xe = wt), qr = Xe, lt && gt)
              t: {
                for (wt = lt, ge = gt, oe = 0, we = wt; we; we = Yc(we))
                  oe++;
                for (we = 0, Xe = ge; Xe; Xe = Yc(Xe))
                  we++;
                for (; 0 < oe - we; )
                  wt = Yc(wt), oe--;
                for (; 0 < we - oe; )
                  ge = Yc(ge), we--;
                for (; oe--; ) {
                  if (wt === ge || ge !== null && wt === ge.alternate)
                    break t;
                  wt = Yc(wt), ge = Yc(ge);
                }
                wt = null;
              }
            else
              wt = null;
            lt !== null && Am(Ye, He, lt, wt, !1), gt !== null && qr !== null && Am(Ye, qr, gt, wt, !0);
          }
        }
        e: {
          if (He = Te ? Ju(Te) : window, lt = He.nodeName && He.nodeName.toLowerCase(), lt === "select" || lt === "input" && He.type === "file")
            var Ct = Wb;
          else if (Yb(He))
            if (_m)
              Ct = Qb;
            else {
              Ct = J1;
              var mt = Z1;
            }
          else
            (lt = He.nodeName) && lt.toLowerCase() === "input" && (He.type === "checkbox" || He.type === "radio") && (Ct = eE);
          if (Ct && (Ct = Ct(l, Te))) {
            Kb(Ye, Ct, m, Ve);
            break e;
          }
          mt && mt(l, He, Te), l === "focusout" && (mt = He._wrapperState) && mt.controlled && He.type === "number" && Er(He, "number", He.value);
        }
        switch (mt = Te ? Ju(Te) : window, l) {
          case "focusin":
            (Yb(mt) || mt.contentEditable === "true") && (ns = mt, Pm = Te, wf = null);
            break;
          case "focusout":
            wf = Pm = ns = null;
            break;
          case "mousedown":
            Im = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Im = !1, n0(Ye, m, Ve);
            break;
          case "selectionchange":
            if (t0)
              break;
          case "keydown":
          case "keyup":
            n0(Ye, m, Ve);
        }
        var $t;
        if (ts)
          e: {
            switch (l) {
              case "compositionstart":
                var Vt = "onCompositionStart";
                break e;
              case "compositionend":
                Vt = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Vt = "onCompositionUpdate";
                break e;
            }
            Vt = void 0;
          }
        else
          Gu ? Hb(l, m) && (Vt = "onCompositionEnd") : l === "keydown" && m.keyCode === 229 && (Vt = "onCompositionStart");
        Vt && (Bb && m.locale !== "ko" && (Gu || Vt !== "onCompositionStart" ? Vt === "onCompositionEnd" && Gu && ($t = ye()) : (Wn = Ve, U = "value" in Wn ? Wn.value : Wn.textContent, Gu = !0)), mt = Tf(Te, Vt), 0 < mt.length && (Vt = new Sm(Vt, l, null, m, Ve), Ye.push({ event: Vt, listeners: mt }), $t ? Vt.data = $t : ($t = Gp(m), $t !== null && (Vt.data = $t)))), ($t = Wp ? q1(l, m) : Q1(l, m)) && (Te = Tf(Te, "onBeforeInput"), 0 < Te.length && (Ve = new Sm("onBeforeInput", "beforeinput", null, m, Ve), Ye.push({ event: Ve, listeners: Te }), Ve.data = $t));
      }
      Zp(Ye, u);
    });
  }
  function _f(l, u, m) {
    return { instance: l, listener: u, currentTarget: m };
  }
  function Tf(l, u) {
    for (var m = u + "Capture", w = []; l !== null; ) {
      var P = l, M = P.stateNode;
      P.tag === 5 && M !== null && (P = M, M = lo(l, m), M != null && w.unshift(_f(l, M, P)), M = lo(l, u), M != null && w.push(_f(l, M, P))), l = l.return;
    }
    return w;
  }
  function Yc(l) {
    if (l === null)
      return null;
    do
      l = l.return;
    while (l && l.tag !== 5);
    return l || null;
  }
  function Am(l, u, m, w, P) {
    for (var M = u._reactName, H = []; m !== null && m !== w; ) {
      var Q = m, ee = Q.alternate, Te = Q.stateNode;
      if (ee !== null && ee === w)
        break;
      Q.tag === 5 && Te !== null && (Q = Te, P ? (ee = lo(m, M), ee != null && H.unshift(_f(m, ee, Q))) : P || (ee = lo(m, M), ee != null && H.push(_f(m, ee, Q)))), m = m.return;
    }
    H.length !== 0 && l.push({ event: u, listeners: H });
  }
  var Om = /\r\n?/g, iE = /\u0000|\uFFFD/g;
  function Dm(l) {
    return (typeof l == "string" ? l : "" + l).replace(Om, `
`).replace(iE, "");
  }
  function eh(l, u, m) {
    if (u = Dm(u), Dm(l) !== u && m)
      throw Error(n(425));
  }
  function th() {
  }
  var Nm = null, Kc = null;
  function kf(l, u) {
    return l === "textarea" || l === "noscript" || typeof u.children == "string" || typeof u.children == "number" || typeof u.dangerouslySetInnerHTML == "object" && u.dangerouslySetInnerHTML !== null && u.dangerouslySetInnerHTML.__html != null;
  }
  var Wc = typeof setTimeout == "function" ? setTimeout : void 0, u0 = typeof clearTimeout == "function" ? clearTimeout : void 0, Lm = typeof Promise == "function" ? Promise : void 0, jm = typeof queueMicrotask == "function" ? queueMicrotask : typeof Lm < "u" ? function(l) {
    return Lm.resolve(null).then(l).catch(oE);
  } : Wc;
  function oE(l) {
    setTimeout(function() {
      throw l;
    });
  }
  function Kl(l, u) {
    var m = u, w = 0;
    do {
      var P = m.nextSibling;
      if (l.removeChild(m), P && P.nodeType === 8)
        if (m = P.data, m === "/$") {
          if (w === 0) {
            l.removeChild(P), _s(u);
            return;
          }
          w--;
        } else
          m !== "$" && m !== "$?" && m !== "$!" || w++;
      m = P;
    } while (m);
    _s(u);
  }
  function rs(l) {
    for (; l != null; l = l.nextSibling) {
      var u = l.nodeType;
      if (u === 1 || u === 3)
        break;
      if (u === 8) {
        if (u = l.data, u === "$" || u === "$!" || u === "$?")
          break;
        if (u === "/$")
          return null;
      }
    }
    return l;
  }
  function Pf(l) {
    l = l.previousSibling;
    for (var u = 0; l; ) {
      if (l.nodeType === 8) {
        var m = l.data;
        if (m === "$" || m === "$!" || m === "$?") {
          if (u === 0)
            return l;
          u--;
        } else
          m === "/$" && u++;
      }
      l = l.previousSibling;
    }
    return null;
  }
  var Wl = Math.random().toString(36).slice(2), Ts = "__reactFiber$" + Wl, Gc = "__reactProps$" + Wl, sl = "__reactContainer$" + Wl, zm = "__reactEvents$" + Wl, aE = "__reactListeners$" + Wl, Um = "__reactHandles$" + Wl;
  function Ta(l) {
    var u = l[Ts];
    if (u)
      return u;
    for (var m = l.parentNode; m; ) {
      if (u = m[sl] || m[Ts]) {
        if (m = u.alternate, u.child !== null || m !== null && m.child !== null)
          for (l = Pf(l); l !== null; ) {
            if (m = l[Ts])
              return m;
            l = Pf(l);
          }
        return u;
      }
      l = m, m = l.parentNode;
    }
    return null;
  }
  function If(l) {
    return l = l[Ts] || l[sl], !l || l.tag !== 5 && l.tag !== 6 && l.tag !== 13 && l.tag !== 3 ? null : l;
  }
  function Ju(l) {
    if (l.tag === 5 || l.tag === 6)
      return l.stateNode;
    throw Error(n(33));
  }
  function Mt(l) {
    return l[Gc] || null;
  }
  var Gl = [], mr = -1;
  function on(l) {
    return { current: l };
  }
  function Un(l) {
    0 > mr || (l.current = Gl[mr], Gl[mr] = null, mr--);
  }
  function Vn(l, u) {
    mr++, Gl[mr] = l.current, l.current = u;
  }
  var ks = {}, Ht = on(ks), Hr = on(!1), Mo = ks;
  function ka(l, u) {
    var m = l.type.contextTypes;
    if (!m)
      return ks;
    var w = l.stateNode;
    if (w && w.__reactInternalMemoizedUnmaskedChildContext === u)
      return w.__reactInternalMemoizedMaskedChildContext;
    var P = {}, M;
    for (M in m)
      P[M] = u[M];
    return w && (l = l.stateNode, l.__reactInternalMemoizedUnmaskedChildContext = u, l.__reactInternalMemoizedMaskedChildContext = P), P;
  }
  function kr(l) {
    return l = l.childContextTypes, l != null;
  }
  function Pa() {
    Un(Hr), Un(Ht);
  }
  function Xl(l, u, m) {
    if (Ht.current !== ks)
      throw Error(n(168));
    Vn(Ht, u), Vn(Hr, m);
  }
  function Rf(l, u, m) {
    var w = l.stateNode;
    if (u = u.childContextTypes, typeof w.getChildContext != "function")
      return m;
    w = w.getChildContext();
    for (var P in w)
      if (!(P in u))
        throw Error(n(108, Qe(l) || "Unknown", P));
    return W({}, m, w);
  }
  function nh(l) {
    return l = (l = l.stateNode) && l.__reactInternalMemoizedMergedChildContext || ks, Mo = Ht.current, Vn(Ht, l), Vn(Hr, Hr.current), !0;
  }
  function d0(l, u, m) {
    var w = l.stateNode;
    if (!w)
      throw Error(n(169));
    m ? (l = Rf(l, u, Mo), w.__reactInternalMemoizedMergedChildContext = l, Un(Hr), Un(Ht), Vn(Ht, l)) : Un(Hr), Vn(Hr, m);
  }
  var Jo = null, Ci = !1, $f = !1;
  function Bm(l) {
    Jo === null ? Jo = [l] : Jo.push(l);
  }
  function Fm(l) {
    Ci = !0, Bm(l);
  }
  function Ao() {
    if (!$f && Jo !== null) {
      $f = !0;
      var l = 0, u = hn;
      try {
        var m = Jo;
        for (hn = 1; l < m.length; l++) {
          var w = m[l];
          do
            w = w(!0);
          while (w !== null);
        }
        Jo = null, Ci = !1;
      } catch (P) {
        throw Jo !== null && (Jo = Jo.slice(l + 1)), Zn(Xo, Ao), P;
      } finally {
        hn = u, $f = !1;
      }
    }
    return null;
  }
  var ql = [], Oo = 0, Xc = null, ed = 0, Do = [], Xi = 0, Ia = null, Oi = 1, ll = "";
  function ea(l, u) {
    ql[Oo++] = ed, ql[Oo++] = Xc, Xc = l, ed = u;
  }
  function Hm(l, u, m) {
    Do[Xi++] = Oi, Do[Xi++] = ll, Do[Xi++] = Ia, Ia = l;
    var w = Oi;
    l = ll;
    var P = 32 - Ai(w) - 1;
    w &= ~(1 << P), m += 1;
    var M = 32 - Ai(u) + P;
    if (30 < M) {
      var H = P - P % 5;
      M = (w & (1 << H) - 1).toString(32), w >>= H, P -= H, Oi = 1 << 32 - Ai(u) + P | m << P | w, ll = M + l;
    } else
      Oi = 1 << M | m << P | w, ll = l;
  }
  function rh(l) {
    l.return !== null && (ea(l, 1), Hm(l, 1, 0));
  }
  function Vm(l) {
    for (; l === Xc; )
      Xc = ql[--Oo], ql[Oo] = null, ed = ql[--Oo], ql[Oo] = null;
    for (; l === Ia; )
      Ia = Do[--Xi], Do[Xi] = null, ll = Do[--Xi], Do[Xi] = null, Oi = Do[--Xi], Do[Xi] = null;
  }
  var ta = null, No = null, vr = !1, Ra = null;
  function Ym(l, u) {
    var m = Na(5, null, null, 0);
    m.elementType = "DELETED", m.stateNode = u, m.return = l, u = l.deletions, u === null ? (l.deletions = [m], l.flags |= 16) : u.push(m);
  }
  function f0(l, u) {
    switch (l.tag) {
      case 5:
        var m = l.type;
        return u = u.nodeType !== 1 || m.toLowerCase() !== u.nodeName.toLowerCase() ? null : u, u !== null ? (l.stateNode = u, ta = l, No = rs(u.firstChild), !0) : !1;
      case 6:
        return u = l.pendingProps === "" || u.nodeType !== 3 ? null : u, u !== null ? (l.stateNode = u, ta = l, No = null, !0) : !1;
      case 13:
        return u = u.nodeType !== 8 ? null : u, u !== null ? (m = Ia !== null ? { id: Oi, overflow: ll } : null, l.memoizedState = { dehydrated: u, treeContext: m, retryLane: 1073741824 }, m = Na(18, null, null, 0), m.stateNode = u, m.return = l, l.child = m, ta = l, No = null, !0) : !1;
      default:
        return !1;
    }
  }
  function ih(l) {
    return (l.mode & 1) !== 0 && (l.flags & 128) === 0;
  }
  function oh(l) {
    if (vr) {
      var u = No;
      if (u) {
        var m = u;
        if (!f0(l, u)) {
          if (ih(l))
            throw Error(n(418));
          u = rs(m.nextSibling);
          var w = ta;
          u && f0(l, u) ? Ym(w, m) : (l.flags = l.flags & -4097 | 2, vr = !1, ta = l);
        }
      } else {
        if (ih(l))
          throw Error(n(418));
        l.flags = l.flags & -4097 | 2, vr = !1, ta = l;
      }
    }
  }
  function p0(l) {
    for (l = l.return; l !== null && l.tag !== 5 && l.tag !== 3 && l.tag !== 13; )
      l = l.return;
    ta = l;
  }
  function ah(l) {
    if (l !== ta)
      return !1;
    if (!vr)
      return p0(l), vr = !0, !1;
    var u;
    if ((u = l.tag !== 3) && !(u = l.tag !== 5) && (u = l.type, u = u !== "head" && u !== "body" && !kf(l.type, l.memoizedProps)), u && (u = No)) {
      if (ih(l))
        throw h0(), Error(n(418));
      for (; u; )
        Ym(l, u), u = rs(u.nextSibling);
    }
    if (p0(l), l.tag === 13) {
      if (l = l.memoizedState, l = l !== null ? l.dehydrated : null, !l)
        throw Error(n(317));
      e: {
        for (l = l.nextSibling, u = 0; l; ) {
          if (l.nodeType === 8) {
            var m = l.data;
            if (m === "/$") {
              if (u === 0) {
                No = rs(l.nextSibling);
                break e;
              }
              u--;
            } else
              m !== "$" && m !== "$!" && m !== "$?" || u++;
          }
          l = l.nextSibling;
        }
        No = null;
      }
    } else
      No = ta ? rs(l.stateNode.nextSibling) : null;
    return !0;
  }
  function h0() {
    for (var l = No; l; )
      l = rs(l.nextSibling);
  }
  function Ar() {
    No = ta = null, vr = !1;
  }
  function Km(l) {
    Ra === null ? Ra = [l] : Ra.push(l);
  }
  var sh = L.ReactCurrentBatchConfig;
  function na(l, u) {
    if (l && l.defaultProps) {
      u = W({}, u), l = l.defaultProps;
      for (var m in l)
        u[m] === void 0 && (u[m] = l[m]);
      return u;
    }
    return u;
  }
  var Ps = on(null), lh = null, Ql = null, Wm = null;
  function Gm() {
    Wm = Ql = lh = null;
  }
  function Zl(l) {
    var u = Ps.current;
    Un(Ps), l._currentValue = u;
  }
  function _i(l, u, m) {
    for (; l !== null; ) {
      var w = l.alternate;
      if ((l.childLanes & u) !== u ? (l.childLanes |= u, w !== null && (w.childLanes |= u)) : w !== null && (w.childLanes & u) !== u && (w.childLanes |= u), l === m)
        break;
      l = l.return;
    }
  }
  function tt(l, u) {
    lh = l, Wm = Ql = null, l = l.dependencies, l !== null && l.firstContext !== null && (l.lanes & u && (ii = !0), l.firstContext = null);
  }
  function Xr(l) {
    var u = l._currentValue;
    if (Wm !== l)
      if (l = { context: l, memoizedValue: u, next: null }, Ql === null) {
        if (lh === null)
          throw Error(n(308));
        Ql = l, lh.dependencies = { lanes: 0, firstContext: l };
      } else
        Ql = Ql.next = l;
    return u;
  }
  var Di = null;
  function Xm(l) {
    Di === null ? Di = [l] : Di.push(l);
  }
  function g0(l, u, m, w) {
    var P = u.interleaved;
    return P === null ? (m.next = m, Xm(u)) : (m.next = P.next, P.next = m), u.interleaved = m, cl(l, w);
  }
  function cl(l, u) {
    l.lanes |= u;
    var m = l.alternate;
    for (m !== null && (m.lanes |= u), m = l, l = l.return; l !== null; )
      l.childLanes |= u, m = l.alternate, m !== null && (m.childLanes |= u), m = l, l = l.return;
    return m.tag === 3 ? m.stateNode : null;
  }
  var Jl = !1;
  function qm(l) {
    l.updateQueue = { baseState: l.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function si(l, u) {
    l = l.updateQueue, u.updateQueue === l && (u.updateQueue = { baseState: l.baseState, firstBaseUpdate: l.firstBaseUpdate, lastBaseUpdate: l.lastBaseUpdate, shared: l.shared, effects: l.effects });
  }
  function ul(l, u) {
    return { eventTime: l, lane: u, tag: 0, payload: null, callback: null, next: null };
  }
  function ec(l, u, m) {
    var w = l.updateQueue;
    if (w === null)
      return null;
    if (w = w.shared, mn & 2) {
      var P = w.pending;
      return P === null ? u.next = u : (u.next = P.next, P.next = u), w.pending = u, cl(l, m);
    }
    return P = w.interleaved, P === null ? (u.next = u, Xm(w)) : (u.next = P.next, P.next = u), w.interleaved = u, cl(l, m);
  }
  function ch(l, u, m) {
    if (u = u.updateQueue, u !== null && (u = u.shared, (m & 4194240) !== 0)) {
      var w = u.lanes;
      w &= l.pendingLanes, m |= w, u.lanes = m, qo(l, m);
    }
  }
  function Qm(l, u) {
    var m = l.updateQueue, w = l.alternate;
    if (w !== null && (w = w.updateQueue, m === w)) {
      var P = null, M = null;
      if (m = m.firstBaseUpdate, m !== null) {
        do {
          var H = { eventTime: m.eventTime, lane: m.lane, tag: m.tag, payload: m.payload, callback: m.callback, next: null };
          M === null ? P = M = H : M = M.next = H, m = m.next;
        } while (m !== null);
        M === null ? P = M = u : M = M.next = u;
      } else
        P = M = u;
      m = { baseState: w.baseState, firstBaseUpdate: P, lastBaseUpdate: M, shared: w.shared, effects: w.effects }, l.updateQueue = m;
      return;
    }
    l = m.lastBaseUpdate, l === null ? m.firstBaseUpdate = u : l.next = u, m.lastBaseUpdate = u;
  }
  function tc(l, u, m, w) {
    var P = l.updateQueue;
    Jl = !1;
    var M = P.firstBaseUpdate, H = P.lastBaseUpdate, Q = P.shared.pending;
    if (Q !== null) {
      P.shared.pending = null;
      var ee = Q, Te = ee.next;
      ee.next = null, H === null ? M = Te : H.next = Te, H = ee;
      var Ve = l.alternate;
      Ve !== null && (Ve = Ve.updateQueue, Q = Ve.lastBaseUpdate, Q !== H && (Q === null ? Ve.firstBaseUpdate = Te : Q.next = Te, Ve.lastBaseUpdate = ee));
    }
    if (M !== null) {
      var Ye = P.baseState;
      H = 0, Ve = Te = ee = null, Q = M;
      do {
        var He = Q.lane, lt = Q.eventTime;
        if ((w & He) === He) {
          Ve !== null && (Ve = Ve.next = {
            eventTime: lt,
            lane: 0,
            tag: Q.tag,
            payload: Q.payload,
            callback: Q.callback,
            next: null
          });
          e: {
            var gt = l, wt = Q;
            switch (He = u, lt = m, wt.tag) {
              case 1:
                if (gt = wt.payload, typeof gt == "function") {
                  Ye = gt.call(lt, Ye, He);
                  break e;
                }
                Ye = gt;
                break e;
              case 3:
                gt.flags = gt.flags & -65537 | 128;
              case 0:
                if (gt = wt.payload, He = typeof gt == "function" ? gt.call(lt, Ye, He) : gt, He == null)
                  break e;
                Ye = W({}, Ye, He);
                break e;
              case 2:
                Jl = !0;
            }
          }
          Q.callback !== null && Q.lane !== 0 && (l.flags |= 64, He = P.effects, He === null ? P.effects = [Q] : He.push(Q));
        } else
          lt = { eventTime: lt, lane: He, tag: Q.tag, payload: Q.payload, callback: Q.callback, next: null }, Ve === null ? (Te = Ve = lt, ee = Ye) : Ve = Ve.next = lt, H |= He;
        if (Q = Q.next, Q === null) {
          if (Q = P.shared.pending, Q === null)
            break;
          He = Q, Q = He.next, He.next = null, P.lastBaseUpdate = He, P.shared.pending = null;
        }
      } while (1);
      if (Ve === null && (ee = Ye), P.baseState = ee, P.firstBaseUpdate = Te, P.lastBaseUpdate = Ve, u = P.shared.interleaved, u !== null) {
        P = u;
        do
          H |= P.lane, P = P.next;
        while (P !== u);
      } else
        M === null && (P.shared.lanes = 0);
      hl |= H, l.lanes = H, l.memoizedState = Ye;
    }
  }
  function qc(l, u, m) {
    if (l = u.effects, u.effects = null, l !== null)
      for (u = 0; u < l.length; u++) {
        var w = l[u], P = w.callback;
        if (P !== null) {
          if (w.callback = null, w = m, typeof P != "function")
            throw Error(n(191, P));
          P.call(w);
        }
      }
  }
  var m0 = new t.Component().refs;
  function Zm(l, u, m, w) {
    u = l.memoizedState, m = m(w, u), m = m == null ? u : W({}, u, m), l.memoizedState = m, l.lanes === 0 && (l.updateQueue.baseState = m);
  }
  var uh = { isMounted: function(l) {
    return (l = l._reactInternals) ? Kt(l) === l : !1;
  }, enqueueSetState: function(l, u, m) {
    l = l._reactInternals;
    var w = Ji(), P = oi(l), M = ul(w, P);
    M.payload = u, m != null && (M.callback = m), u = ec(l, M, P), u !== null && (eo(u, l, P, w), ch(u, l, P));
  }, enqueueReplaceState: function(l, u, m) {
    l = l._reactInternals;
    var w = Ji(), P = oi(l), M = ul(w, P);
    M.tag = 1, M.payload = u, m != null && (M.callback = m), u = ec(l, M, P), u !== null && (eo(u, l, P, w), ch(u, l, P));
  }, enqueueForceUpdate: function(l, u) {
    l = l._reactInternals;
    var m = Ji(), w = oi(l), P = ul(m, w);
    P.tag = 2, u != null && (P.callback = u), u = ec(l, P, w), u !== null && (eo(u, l, w, m), ch(u, l, w));
  } };
  function v0(l, u, m, w, P, M, H) {
    return l = l.stateNode, typeof l.shouldComponentUpdate == "function" ? l.shouldComponentUpdate(w, M, H) : u.prototype && u.prototype.isPureReactComponent ? !Sf(m, w) || !Sf(P, M) : !0;
  }
  function y0(l, u, m) {
    var w = !1, P = ks, M = u.contextType;
    return typeof M == "object" && M !== null ? M = Xr(M) : (P = kr(u) ? Mo : Ht.current, w = u.contextTypes, M = (w = w != null) ? ka(l, P) : ks), u = new u(m, M), l.memoizedState = u.state !== null && u.state !== void 0 ? u.state : null, u.updater = uh, l.stateNode = u, u._reactInternals = l, w && (l = l.stateNode, l.__reactInternalMemoizedUnmaskedChildContext = P, l.__reactInternalMemoizedMaskedChildContext = M), u;
  }
  function b0(l, u, m, w) {
    l = u.state, typeof u.componentWillReceiveProps == "function" && u.componentWillReceiveProps(m, w), typeof u.UNSAFE_componentWillReceiveProps == "function" && u.UNSAFE_componentWillReceiveProps(m, w), u.state !== l && uh.enqueueReplaceState(u, u.state, null);
  }
  function dh(l, u, m, w) {
    var P = l.stateNode;
    P.props = m, P.state = l.memoizedState, P.refs = m0, qm(l);
    var M = u.contextType;
    typeof M == "object" && M !== null ? P.context = Xr(M) : (M = kr(u) ? Mo : Ht.current, P.context = ka(l, M)), P.state = l.memoizedState, M = u.getDerivedStateFromProps, typeof M == "function" && (Zm(l, u, M, m), P.state = l.memoizedState), typeof u.getDerivedStateFromProps == "function" || typeof P.getSnapshotBeforeUpdate == "function" || typeof P.UNSAFE_componentWillMount != "function" && typeof P.componentWillMount != "function" || (u = P.state, typeof P.componentWillMount == "function" && P.componentWillMount(), typeof P.UNSAFE_componentWillMount == "function" && P.UNSAFE_componentWillMount(), u !== P.state && uh.enqueueReplaceState(P, P.state, null), tc(l, m, P, w), P.state = l.memoizedState), typeof P.componentDidMount == "function" && (l.flags |= 4194308);
  }
  function td(l, u, m) {
    if (l = m.ref, l !== null && typeof l != "function" && typeof l != "object") {
      if (m._owner) {
        if (m = m._owner, m) {
          if (m.tag !== 1)
            throw Error(n(309));
          var w = m.stateNode;
        }
        if (!w)
          throw Error(n(147, l));
        var P = w, M = "" + l;
        return u !== null && u.ref !== null && typeof u.ref == "function" && u.ref._stringRef === M ? u.ref : (u = function(H) {
          var Q = P.refs;
          Q === m0 && (Q = P.refs = {}), H === null ? delete Q[M] : Q[M] = H;
        }, u._stringRef = M, u);
      }
      if (typeof l != "string")
        throw Error(n(284));
      if (!m._owner)
        throw Error(n(290, l));
    }
    return l;
  }
  function fh(l, u) {
    throw l = Object.prototype.toString.call(u), Error(n(31, l === "[object Object]" ? "object with keys {" + Object.keys(u).join(", ") + "}" : l));
  }
  function S0(l) {
    var u = l._init;
    return u(l._payload);
  }
  function w0(l) {
    function u(ge, oe) {
      if (l) {
        var we = ge.deletions;
        we === null ? (ge.deletions = [oe], ge.flags |= 16) : we.push(oe);
      }
    }
    function m(ge, oe) {
      if (!l)
        return null;
      for (; oe !== null; )
        u(ge, oe), oe = oe.sibling;
      return null;
    }
    function w(ge, oe) {
      for (ge = /* @__PURE__ */ new Map(); oe !== null; )
        oe.key !== null ? ge.set(oe.key, oe) : ge.set(oe.index, oe), oe = oe.sibling;
      return ge;
    }
    function P(ge, oe) {
      return ge = cc(ge, oe), ge.index = 0, ge.sibling = null, ge;
    }
    function M(ge, oe, we) {
      return ge.index = we, l ? (we = ge.alternate, we !== null ? (we = we.index, we < oe ? (ge.flags |= 2, oe) : we) : (ge.flags |= 2, oe)) : (ge.flags |= 1048576, oe);
    }
    function H(ge) {
      return l && ge.alternate === null && (ge.flags |= 2), ge;
    }
    function Q(ge, oe, we, Xe) {
      return oe === null || oe.tag !== 6 ? (oe = qf(we, ge.mode, Xe), oe.return = ge, oe) : (oe = P(oe, we), oe.return = ge, oe);
    }
    function ee(ge, oe, we, Xe) {
      var Ct = we.type;
      return Ct === K ? Ve(ge, oe, we.props.children, Xe, we.key) : oe !== null && (oe.elementType === Ct || typeof Ct == "object" && Ct !== null && Ct.$$typeof === Re && S0(Ct) === oe.type) ? (Xe = P(oe, we.props), Xe.ref = td(ge, oe, we), Xe.return = ge, Xe) : (Xe = Vh(we.type, we.key, we.props, null, ge.mode, Xe), Xe.ref = td(ge, oe, we), Xe.return = ge, Xe);
    }
    function Te(ge, oe, we, Xe) {
      return oe === null || oe.tag !== 4 || oe.stateNode.containerInfo !== we.containerInfo || oe.stateNode.implementation !== we.implementation ? (oe = gu(we, ge.mode, Xe), oe.return = ge, oe) : (oe = P(oe, we.children || []), oe.return = ge, oe);
    }
    function Ve(ge, oe, we, Xe, Ct) {
      return oe === null || oe.tag !== 7 ? (oe = hu(we, ge.mode, Xe, Ct), oe.return = ge, oe) : (oe = P(oe, we), oe.return = ge, oe);
    }
    function Ye(ge, oe, we) {
      if (typeof oe == "string" && oe !== "" || typeof oe == "number")
        return oe = qf("" + oe, ge.mode, we), oe.return = ge, oe;
      if (typeof oe == "object" && oe !== null) {
        switch (oe.$$typeof) {
          case z:
            return we = Vh(oe.type, oe.key, oe.props, null, ge.mode, we), we.ref = td(ge, null, oe), we.return = ge, we;
          case F:
            return oe = gu(oe, ge.mode, we), oe.return = ge, oe;
          case Re:
            var Xe = oe._init;
            return Ye(ge, Xe(oe._payload), we);
        }
        if (tn(oe) || de(oe))
          return oe = hu(oe, ge.mode, we, null), oe.return = ge, oe;
        fh(ge, oe);
      }
      return null;
    }
    function He(ge, oe, we, Xe) {
      var Ct = oe !== null ? oe.key : null;
      if (typeof we == "string" && we !== "" || typeof we == "number")
        return Ct !== null ? null : Q(ge, oe, "" + we, Xe);
      if (typeof we == "object" && we !== null) {
        switch (we.$$typeof) {
          case z:
            return we.key === Ct ? ee(ge, oe, we, Xe) : null;
          case F:
            return we.key === Ct ? Te(ge, oe, we, Xe) : null;
          case Re:
            return Ct = we._init, He(
              ge,
              oe,
              Ct(we._payload),
              Xe
            );
        }
        if (tn(we) || de(we))
          return Ct !== null ? null : Ve(ge, oe, we, Xe, null);
        fh(ge, we);
      }
      return null;
    }
    function lt(ge, oe, we, Xe, Ct) {
      if (typeof Xe == "string" && Xe !== "" || typeof Xe == "number")
        return ge = ge.get(we) || null, Q(oe, ge, "" + Xe, Ct);
      if (typeof Xe == "object" && Xe !== null) {
        switch (Xe.$$typeof) {
          case z:
            return ge = ge.get(Xe.key === null ? we : Xe.key) || null, ee(oe, ge, Xe, Ct);
          case F:
            return ge = ge.get(Xe.key === null ? we : Xe.key) || null, Te(oe, ge, Xe, Ct);
          case Re:
            var mt = Xe._init;
            return lt(ge, oe, we, mt(Xe._payload), Ct);
        }
        if (tn(Xe) || de(Xe))
          return ge = ge.get(we) || null, Ve(oe, ge, Xe, Ct, null);
        fh(oe, Xe);
      }
      return null;
    }
    function gt(ge, oe, we, Xe) {
      for (var Ct = null, mt = null, $t = oe, Vt = oe = 0, Pi = null; $t !== null && Vt < we.length; Vt++) {
        $t.index > Vt ? (Pi = $t, $t = null) : Pi = $t.sibling;
        var Rn = He(ge, $t, we[Vt], Xe);
        if (Rn === null) {
          $t === null && ($t = Pi);
          break;
        }
        l && $t && Rn.alternate === null && u(ge, $t), oe = M(Rn, oe, Vt), mt === null ? Ct = Rn : mt.sibling = Rn, mt = Rn, $t = Pi;
      }
      if (Vt === we.length)
        return m(ge, $t), vr && ea(ge, Vt), Ct;
      if ($t === null) {
        for (; Vt < we.length; Vt++)
          $t = Ye(ge, we[Vt], Xe), $t !== null && (oe = M($t, oe, Vt), mt === null ? Ct = $t : mt.sibling = $t, mt = $t);
        return vr && ea(ge, Vt), Ct;
      }
      for ($t = w(ge, $t); Vt < we.length; Vt++)
        Pi = lt($t, ge, Vt, we[Vt], Xe), Pi !== null && (l && Pi.alternate !== null && $t.delete(Pi.key === null ? Vt : Pi.key), oe = M(Pi, oe, Vt), mt === null ? Ct = Pi : mt.sibling = Pi, mt = Pi);
      return l && $t.forEach(function(uc) {
        return u(ge, uc);
      }), vr && ea(ge, Vt), Ct;
    }
    function wt(ge, oe, we, Xe) {
      var Ct = de(we);
      if (typeof Ct != "function")
        throw Error(n(150));
      if (we = Ct.call(we), we == null)
        throw Error(n(151));
      for (var mt = Ct = null, $t = oe, Vt = oe = 0, Pi = null, Rn = we.next(); $t !== null && !Rn.done; Vt++, Rn = we.next()) {
        $t.index > Vt ? (Pi = $t, $t = null) : Pi = $t.sibling;
        var uc = He(ge, $t, Rn.value, Xe);
        if (uc === null) {
          $t === null && ($t = Pi);
          break;
        }
        l && $t && uc.alternate === null && u(ge, $t), oe = M(uc, oe, Vt), mt === null ? Ct = uc : mt.sibling = uc, mt = uc, $t = Pi;
      }
      if (Rn.done)
        return m(
          ge,
          $t
        ), vr && ea(ge, Vt), Ct;
      if ($t === null) {
        for (; !Rn.done; Vt++, Rn = we.next())
          Rn = Ye(ge, Rn.value, Xe), Rn !== null && (oe = M(Rn, oe, Vt), mt === null ? Ct = Rn : mt.sibling = Rn, mt = Rn);
        return vr && ea(ge, Vt), Ct;
      }
      for ($t = w(ge, $t); !Rn.done; Vt++, Rn = we.next())
        Rn = lt($t, ge, Vt, Rn.value, Xe), Rn !== null && (l && Rn.alternate !== null && $t.delete(Rn.key === null ? Vt : Rn.key), oe = M(Rn, oe, Vt), mt === null ? Ct = Rn : mt.sibling = Rn, mt = Rn);
      return l && $t.forEach(function(TE) {
        return u(ge, TE);
      }), vr && ea(ge, Vt), Ct;
    }
    function qr(ge, oe, we, Xe) {
      if (typeof we == "object" && we !== null && we.type === K && we.key === null && (we = we.props.children), typeof we == "object" && we !== null) {
        switch (we.$$typeof) {
          case z:
            e: {
              for (var Ct = we.key, mt = oe; mt !== null; ) {
                if (mt.key === Ct) {
                  if (Ct = we.type, Ct === K) {
                    if (mt.tag === 7) {
                      m(ge, mt.sibling), oe = P(mt, we.props.children), oe.return = ge, ge = oe;
                      break e;
                    }
                  } else if (mt.elementType === Ct || typeof Ct == "object" && Ct !== null && Ct.$$typeof === Re && S0(Ct) === mt.type) {
                    m(ge, mt.sibling), oe = P(mt, we.props), oe.ref = td(ge, mt, we), oe.return = ge, ge = oe;
                    break e;
                  }
                  m(ge, mt);
                  break;
                } else
                  u(ge, mt);
                mt = mt.sibling;
              }
              we.type === K ? (oe = hu(we.props.children, ge.mode, Xe, we.key), oe.return = ge, ge = oe) : (Xe = Vh(we.type, we.key, we.props, null, ge.mode, Xe), Xe.ref = td(ge, oe, we), Xe.return = ge, ge = Xe);
            }
            return H(ge);
          case F:
            e: {
              for (mt = we.key; oe !== null; ) {
                if (oe.key === mt)
                  if (oe.tag === 4 && oe.stateNode.containerInfo === we.containerInfo && oe.stateNode.implementation === we.implementation) {
                    m(ge, oe.sibling), oe = P(oe, we.children || []), oe.return = ge, ge = oe;
                    break e;
                  } else {
                    m(ge, oe);
                    break;
                  }
                else
                  u(ge, oe);
                oe = oe.sibling;
              }
              oe = gu(we, ge.mode, Xe), oe.return = ge, ge = oe;
            }
            return H(ge);
          case Re:
            return mt = we._init, qr(ge, oe, mt(we._payload), Xe);
        }
        if (tn(we))
          return gt(ge, oe, we, Xe);
        if (de(we))
          return wt(ge, oe, we, Xe);
        fh(ge, we);
      }
      return typeof we == "string" && we !== "" || typeof we == "number" ? (we = "" + we, oe !== null && oe.tag === 6 ? (m(ge, oe.sibling), oe = P(oe, we), oe.return = ge, ge = oe) : (m(ge, oe), oe = qf(we, ge.mode, Xe), oe.return = ge, ge = oe), H(ge)) : m(ge, oe);
    }
    return qr;
  }
  var nd = w0(!0), x0 = w0(!1), Mf = {}, is = on(Mf), Af = on(Mf), rd = on(Mf);
  function Qc(l) {
    if (l === Mf)
      throw Error(n(174));
    return l;
  }
  function Jm(l, u) {
    switch (Vn(rd, u), Vn(Af, l), Vn(is, Mf), l = u.nodeType, l) {
      case 9:
      case 11:
        u = (u = u.documentElement) ? u.namespaceURI : An(null, "");
        break;
      default:
        l = l === 8 ? u.parentNode : u, u = l.namespaceURI || null, l = l.tagName, u = An(u, l);
    }
    Un(is), Vn(is, u);
  }
  function nc() {
    Un(is), Un(Af), Un(rd);
  }
  function Dt(l) {
    Qc(rd.current);
    var u = Qc(is.current), m = An(u, l.type);
    u !== m && (Vn(Af, l), Vn(is, m));
  }
  function fn(l) {
    Af.current === l && (Un(is), Un(Af));
  }
  var Lt = on(0);
  function Or(l) {
    for (var u = l; u !== null; ) {
      if (u.tag === 13) {
        var m = u.memoizedState;
        if (m !== null && (m = m.dehydrated, m === null || m.data === "$?" || m.data === "$!"))
          return u;
      } else if (u.tag === 19 && u.memoizedProps.revealOrder !== void 0) {
        if (u.flags & 128)
          return u;
      } else if (u.child !== null) {
        u.child.return = u, u = u.child;
        continue;
      }
      if (u === l)
        break;
      for (; u.sibling === null; ) {
        if (u.return === null || u.return === l)
          return null;
        u = u.return;
      }
      u.sibling.return = u.return, u = u.sibling;
    }
    return null;
  }
  var $a = [];
  function ph() {
    for (var l = 0; l < $a.length; l++)
      $a[l]._workInProgressVersionPrimary = null;
    $a.length = 0;
  }
  var hh = L.ReactCurrentDispatcher, ev = L.ReactCurrentBatchConfig, Zc = 0, yr = null, Ne = null, En = null, jt = !1, Is = !1, ra = 0, Jc = 0;
  function br() {
    throw Error(n(321));
  }
  function eu(l, u) {
    if (u === null)
      return !1;
    for (var m = 0; m < u.length && m < l.length; m++)
      if (!_a(l[m], u[m]))
        return !1;
    return !0;
  }
  function rc(l, u, m, w, P, M) {
    if (Zc = M, yr = u, u.memoizedState = null, u.updateQueue = null, u.lanes = 0, hh.current = l === null || l.memoizedState === null ? lE : cE, l = m(w, P), Is) {
      M = 0;
      do {
        if (Is = !1, ra = 0, 25 <= M)
          throw Error(n(301));
        M += 1, En = Ne = null, u.updateQueue = null, hh.current = nv, l = m(w, P);
      } while (Is);
    }
    if (hh.current = Rh, u = Ne !== null && Ne.next !== null, Zc = 0, En = Ne = yr = null, jt = !1, u)
      throw Error(n(300));
    return l;
  }
  function tu() {
    var l = ra !== 0;
    return ra = 0, l;
  }
  function Ma() {
    var l = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return En === null ? yr.memoizedState = En = l : En = En.next = l, En;
  }
  function Lo() {
    if (Ne === null) {
      var l = yr.alternate;
      l = l !== null ? l.memoizedState : null;
    } else
      l = Ne.next;
    var u = En === null ? yr.memoizedState : En.next;
    if (u !== null)
      En = u, Ne = l;
    else {
      if (l === null)
        throw Error(n(310));
      Ne = l, l = { memoizedState: Ne.memoizedState, baseState: Ne.baseState, baseQueue: Ne.baseQueue, queue: Ne.queue, next: null }, En === null ? yr.memoizedState = En = l : En = En.next = l;
    }
    return En;
  }
  function nu(l, u) {
    return typeof u == "function" ? u(l) : u;
  }
  function Of(l) {
    var u = Lo(), m = u.queue;
    if (m === null)
      throw Error(n(311));
    m.lastRenderedReducer = l;
    var w = Ne, P = w.baseQueue, M = m.pending;
    if (M !== null) {
      if (P !== null) {
        var H = P.next;
        P.next = M.next, M.next = H;
      }
      w.baseQueue = P = M, m.pending = null;
    }
    if (P !== null) {
      M = P.next, w = w.baseState;
      var Q = H = null, ee = null, Te = M;
      do {
        var Ve = Te.lane;
        if ((Zc & Ve) === Ve)
          ee !== null && (ee = ee.next = { lane: 0, action: Te.action, hasEagerState: Te.hasEagerState, eagerState: Te.eagerState, next: null }), w = Te.hasEagerState ? Te.eagerState : l(w, Te.action);
        else {
          var Ye = {
            lane: Ve,
            action: Te.action,
            hasEagerState: Te.hasEagerState,
            eagerState: Te.eagerState,
            next: null
          };
          ee === null ? (Q = ee = Ye, H = w) : ee = ee.next = Ye, yr.lanes |= Ve, hl |= Ve;
        }
        Te = Te.next;
      } while (Te !== null && Te !== M);
      ee === null ? H = w : ee.next = Q, _a(w, u.memoizedState) || (ii = !0), u.memoizedState = w, u.baseState = H, u.baseQueue = ee, m.lastRenderedState = w;
    }
    if (l = m.interleaved, l !== null) {
      P = l;
      do
        M = P.lane, yr.lanes |= M, hl |= M, P = P.next;
      while (P !== l);
    } else
      P === null && (m.lanes = 0);
    return [u.memoizedState, m.dispatch];
  }
  function Df(l) {
    var u = Lo(), m = u.queue;
    if (m === null)
      throw Error(n(311));
    m.lastRenderedReducer = l;
    var w = m.dispatch, P = m.pending, M = u.memoizedState;
    if (P !== null) {
      m.pending = null;
      var H = P = P.next;
      do
        M = l(M, H.action), H = H.next;
      while (H !== P);
      _a(M, u.memoizedState) || (ii = !0), u.memoizedState = M, u.baseQueue === null && (u.baseState = M), m.lastRenderedState = M;
    }
    return [M, w];
  }
  function gh() {
  }
  function mh(l, u) {
    var m = yr, w = Lo(), P = u(), M = !_a(w.memoizedState, P);
    if (M && (w.memoizedState = P, ii = !0), w = w.queue, Nf(bh.bind(null, m, w, l), [l]), w.getSnapshot !== u || M || En !== null && En.memoizedState.tag & 1) {
      if (m.flags |= 2048, ru(9, yh.bind(null, m, w, P, u), void 0, null), Dr === null)
        throw Error(n(349));
      Zc & 30 || vh(m, u, P);
    }
    return P;
  }
  function vh(l, u, m) {
    l.flags |= 16384, l = { getSnapshot: u, value: m }, u = yr.updateQueue, u === null ? (u = { lastEffect: null, stores: null }, yr.updateQueue = u, u.stores = [l]) : (m = u.stores, m === null ? u.stores = [l] : m.push(l));
  }
  function yh(l, u, m, w) {
    u.value = m, u.getSnapshot = w, Sh(u) && wh(l);
  }
  function bh(l, u, m) {
    return m(function() {
      Sh(u) && wh(l);
    });
  }
  function Sh(l) {
    var u = l.getSnapshot;
    l = l.value;
    try {
      var m = u();
      return !_a(l, m);
    } catch {
      return !0;
    }
  }
  function wh(l) {
    var u = cl(l, 1);
    u !== null && eo(u, l, 1, -1);
  }
  function xh(l) {
    var u = Ma();
    return typeof l == "function" && (l = l()), u.memoizedState = u.baseState = l, l = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: nu, lastRenderedState: l }, u.queue = l, l = l.dispatch = Ih.bind(null, yr, l), [u.memoizedState, l];
  }
  function ru(l, u, m, w) {
    return l = { tag: l, create: u, destroy: m, deps: w, next: null }, u = yr.updateQueue, u === null ? (u = { lastEffect: null, stores: null }, yr.updateQueue = u, u.lastEffect = l.next = l) : (m = u.lastEffect, m === null ? u.lastEffect = l.next = l : (w = m.next, m.next = l, l.next = w, u.lastEffect = l)), l;
  }
  function Eh() {
    return Lo().memoizedState;
  }
  function iu(l, u, m, w) {
    var P = Ma();
    yr.flags |= l, P.memoizedState = ru(1 | u, m, void 0, w === void 0 ? null : w);
  }
  function dl(l, u, m, w) {
    var P = Lo();
    w = w === void 0 ? null : w;
    var M = void 0;
    if (Ne !== null) {
      var H = Ne.memoizedState;
      if (M = H.destroy, w !== null && eu(w, H.deps)) {
        P.memoizedState = ru(u, m, M, w);
        return;
      }
    }
    yr.flags |= l, P.memoizedState = ru(1 | u, m, M, w);
  }
  function Ch(l, u) {
    return iu(8390656, 8, l, u);
  }
  function Nf(l, u) {
    return dl(2048, 8, l, u);
  }
  function _h(l, u) {
    return dl(4, 2, l, u);
  }
  function Th(l, u) {
    return dl(4, 4, l, u);
  }
  function tv(l, u) {
    if (typeof u == "function")
      return l = l(), u(l), function() {
        u(null);
      };
    if (u != null)
      return l = l(), u.current = l, function() {
        u.current = null;
      };
  }
  function id(l, u, m) {
    return m = m != null ? m.concat([l]) : null, dl(4, 4, tv.bind(null, u, l), m);
  }
  function kh() {
  }
  function od(l, u) {
    var m = Lo();
    u = u === void 0 ? null : u;
    var w = m.memoizedState;
    return w !== null && u !== null && eu(u, w[1]) ? w[0] : (m.memoizedState = [l, u], l);
  }
  function ic(l, u) {
    var m = Lo();
    u = u === void 0 ? null : u;
    var w = m.memoizedState;
    return w !== null && u !== null && eu(u, w[1]) ? w[0] : (l = l(), m.memoizedState = [l, u], l);
  }
  function jo(l, u, m) {
    return Zc & 21 ? (_a(m, u) || (m = Ul(), yr.lanes |= m, hl |= m, l.baseState = !0), u) : (l.baseState && (l.baseState = !1, ii = !0), l.memoizedState = m);
  }
  function sE(l, u) {
    var m = hn;
    hn = m !== 0 && 4 > m ? m : 4, l(!0);
    var w = ev.transition;
    ev.transition = {};
    try {
      l(!1), u();
    } finally {
      hn = m, ev.transition = w;
    }
  }
  function lr() {
    return Lo().memoizedState;
  }
  function Ph(l, u, m) {
    var w = oi(l);
    if (m = { lane: w, action: m, hasEagerState: !1, eagerState: null, next: null }, ad(l))
      Lf(u, m);
    else if (m = g0(l, u, m, w), m !== null) {
      var P = Ji();
      eo(m, l, w, P), E0(m, u, w);
    }
  }
  function Ih(l, u, m) {
    var w = oi(l), P = { lane: w, action: m, hasEagerState: !1, eagerState: null, next: null };
    if (ad(l))
      Lf(u, P);
    else {
      var M = l.alternate;
      if (l.lanes === 0 && (M === null || M.lanes === 0) && (M = u.lastRenderedReducer, M !== null))
        try {
          var H = u.lastRenderedState, Q = M(H, m);
          if (P.hasEagerState = !0, P.eagerState = Q, _a(Q, H)) {
            var ee = u.interleaved;
            ee === null ? (P.next = P, Xm(u)) : (P.next = ee.next, ee.next = P), u.interleaved = P;
            return;
          }
        } catch {
        } finally {
        }
      m = g0(l, u, P, w), m !== null && (P = Ji(), eo(m, l, w, P), E0(m, u, w));
    }
  }
  function ad(l) {
    var u = l.alternate;
    return l === yr || u !== null && u === yr;
  }
  function Lf(l, u) {
    Is = jt = !0;
    var m = l.pending;
    m === null ? u.next = u : (u.next = m.next, m.next = u), l.pending = u;
  }
  function E0(l, u, m) {
    if (m & 4194240) {
      var w = u.lanes;
      w &= l.pendingLanes, m |= w, u.lanes = m, qo(l, m);
    }
  }
  var Rh = { readContext: Xr, useCallback: br, useContext: br, useEffect: br, useImperativeHandle: br, useInsertionEffect: br, useLayoutEffect: br, useMemo: br, useReducer: br, useRef: br, useState: br, useDebugValue: br, useDeferredValue: br, useTransition: br, useMutableSource: br, useSyncExternalStore: br, useId: br, unstable_isNewReconciler: !1 }, lE = { readContext: Xr, useCallback: function(l, u) {
    return Ma().memoizedState = [l, u === void 0 ? null : u], l;
  }, useContext: Xr, useEffect: Ch, useImperativeHandle: function(l, u, m) {
    return m = m != null ? m.concat([l]) : null, iu(
      4194308,
      4,
      tv.bind(null, u, l),
      m
    );
  }, useLayoutEffect: function(l, u) {
    return iu(4194308, 4, l, u);
  }, useInsertionEffect: function(l, u) {
    return iu(4, 2, l, u);
  }, useMemo: function(l, u) {
    var m = Ma();
    return u = u === void 0 ? null : u, l = l(), m.memoizedState = [l, u], l;
  }, useReducer: function(l, u, m) {
    var w = Ma();
    return u = m !== void 0 ? m(u) : u, w.memoizedState = w.baseState = u, l = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: l, lastRenderedState: u }, w.queue = l, l = l.dispatch = Ph.bind(null, yr, l), [w.memoizedState, l];
  }, useRef: function(l) {
    var u = Ma();
    return l = { current: l }, u.memoizedState = l;
  }, useState: xh, useDebugValue: kh, useDeferredValue: function(l) {
    return Ma().memoizedState = l;
  }, useTransition: function() {
    var l = xh(!1), u = l[0];
    return l = sE.bind(null, l[1]), Ma().memoizedState = l, [u, l];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(l, u, m) {
    var w = yr, P = Ma();
    if (vr) {
      if (m === void 0)
        throw Error(n(407));
      m = m();
    } else {
      if (m = u(), Dr === null)
        throw Error(n(349));
      Zc & 30 || vh(w, u, m);
    }
    P.memoizedState = m;
    var M = { value: m, getSnapshot: u };
    return P.queue = M, Ch(bh.bind(
      null,
      w,
      M,
      l
    ), [l]), w.flags |= 2048, ru(9, yh.bind(null, w, M, m, u), void 0, null), m;
  }, useId: function() {
    var l = Ma(), u = Dr.identifierPrefix;
    if (vr) {
      var m = ll, w = Oi;
      m = (w & ~(1 << 32 - Ai(w) - 1)).toString(32) + m, u = ":" + u + "R" + m, m = ra++, 0 < m && (u += "H" + m.toString(32)), u += ":";
    } else
      m = Jc++, u = ":" + u + "r" + m.toString(32) + ":";
    return l.memoizedState = u;
  }, unstable_isNewReconciler: !1 }, cE = {
    readContext: Xr,
    useCallback: od,
    useContext: Xr,
    useEffect: Nf,
    useImperativeHandle: id,
    useInsertionEffect: _h,
    useLayoutEffect: Th,
    useMemo: ic,
    useReducer: Of,
    useRef: Eh,
    useState: function() {
      return Of(nu);
    },
    useDebugValue: kh,
    useDeferredValue: function(l) {
      var u = Lo();
      return jo(u, Ne.memoizedState, l);
    },
    useTransition: function() {
      var l = Of(nu)[0], u = Lo().memoizedState;
      return [l, u];
    },
    useMutableSource: gh,
    useSyncExternalStore: mh,
    useId: lr,
    unstable_isNewReconciler: !1
  }, nv = { readContext: Xr, useCallback: od, useContext: Xr, useEffect: Nf, useImperativeHandle: id, useInsertionEffect: _h, useLayoutEffect: Th, useMemo: ic, useReducer: Df, useRef: Eh, useState: function() {
    return Df(nu);
  }, useDebugValue: kh, useDeferredValue: function(l) {
    var u = Lo();
    return Ne === null ? u.memoizedState = l : jo(u, Ne.memoizedState, l);
  }, useTransition: function() {
    var l = Df(nu)[0], u = Lo().memoizedState;
    return [l, u];
  }, useMutableSource: gh, useSyncExternalStore: mh, useId: lr, unstable_isNewReconciler: !1 };
  function sd(l, u) {
    try {
      var m = "", w = u;
      do
        m += Me(w), w = w.return;
      while (w);
      var P = m;
    } catch (M) {
      P = `
Error generating stack: ` + M.message + `
` + M.stack;
    }
    return { value: l, source: u, stack: P, digest: null };
  }
  function jf(l, u, m) {
    return { value: l, source: null, stack: m ?? null, digest: u ?? null };
  }
  function $h(l, u) {
    try {
      console.error(u.value);
    } catch (m) {
      setTimeout(function() {
        throw m;
      });
    }
  }
  var uE = typeof WeakMap == "function" ? WeakMap : Map;
  function C0(l, u, m) {
    m = ul(-1, m), m.tag = 3, m.payload = { element: null };
    var w = u.value;
    return m.callback = function() {
      jh || (jh = !0, cu = w), $h(l, u);
    }, m;
  }
  function zf(l, u, m) {
    m = ul(-1, m), m.tag = 3;
    var w = l.type.getDerivedStateFromError;
    if (typeof w == "function") {
      var P = u.value;
      m.payload = function() {
        return w(P);
      }, m.callback = function() {
        $h(l, u);
      };
    }
    var M = l.stateNode;
    return M !== null && typeof M.componentDidCatch == "function" && (m.callback = function() {
      $h(l, u), typeof w != "function" && (Ms === null ? Ms = /* @__PURE__ */ new Set([this]) : Ms.add(this));
      var H = u.stack;
      this.componentDidCatch(u.value, { componentStack: H !== null ? H : "" });
    }), m;
  }
  function _0(l, u, m) {
    var w = l.pingCache;
    if (w === null) {
      w = l.pingCache = new uE();
      var P = /* @__PURE__ */ new Set();
      w.set(u, P);
    } else
      P = w.get(u), P === void 0 && (P = /* @__PURE__ */ new Set(), w.set(u, P));
    P.has(m) || (P.add(m), l = vE.bind(null, l, u, m), u.then(l, l));
  }
  function rv(l) {
    do {
      var u;
      if ((u = l.tag === 13) && (u = l.memoizedState, u = u !== null ? u.dehydrated !== null : !0), u)
        return l;
      l = l.return;
    } while (l !== null);
    return null;
  }
  function iv(l, u, m, w, P) {
    return l.mode & 1 ? (l.flags |= 65536, l.lanes = P, l) : (l === u ? l.flags |= 65536 : (l.flags |= 128, m.flags |= 131072, m.flags &= -52805, m.tag === 1 && (m.alternate === null ? m.tag = 17 : (u = ul(-1, 1), u.tag = 2, ec(m, u, 1))), m.lanes |= 1), l);
  }
  var dE = L.ReactCurrentOwner, ii = !1;
  function li(l, u, m, w) {
    u.child = l === null ? x0(u, null, m, w) : nd(u, l.child, m, w);
  }
  function oc(l, u, m, w, P) {
    m = m.render;
    var M = u.ref;
    return tt(u, P), w = rc(l, u, m, w, M, P), m = tu(), l !== null && !ii ? (u.updateQueue = l.updateQueue, u.flags &= -2053, l.lanes &= ~P, Ni(l, u, P)) : (vr && m && rh(u), u.flags |= 1, li(l, u, w, P), u.child);
  }
  function Mh(l, u, m, w, P) {
    if (l === null) {
      var M = m.type;
      return typeof M == "function" && !Ev(M) && M.defaultProps === void 0 && m.compare === null && m.defaultProps === void 0 ? (u.tag = 15, u.type = M, zo(l, u, M, w, P)) : (l = Vh(m.type, null, w, u, u.mode, P), l.ref = u.ref, l.return = u, u.child = l);
    }
    if (M = l.child, !(l.lanes & P)) {
      var H = M.memoizedProps;
      if (m = m.compare, m = m !== null ? m : Sf, m(H, w) && l.ref === u.ref)
        return Ni(l, u, P);
    }
    return u.flags |= 1, l = cc(M, w), l.ref = u.ref, l.return = u, u.child = l;
  }
  function zo(l, u, m, w, P) {
    if (l !== null) {
      var M = l.memoizedProps;
      if (Sf(M, w) && l.ref === u.ref)
        if (ii = !1, u.pendingProps = w = M, (l.lanes & P) !== 0)
          l.flags & 131072 && (ii = !0);
        else
          return u.lanes = l.lanes, Ni(l, u, P);
    }
    return ld(l, u, m, w, P);
  }
  function ou(l, u, m) {
    var w = u.pendingProps, P = w.children, M = l !== null ? l.memoizedState : null;
    if (w.mode === "hidden")
      if (!(u.mode & 1))
        u.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Vn(hd, ia), ia |= m;
      else {
        if (!(m & 1073741824))
          return l = M !== null ? M.baseLanes | m : m, u.lanes = u.childLanes = 1073741824, u.memoizedState = { baseLanes: l, cachePool: null, transitions: null }, u.updateQueue = null, Vn(hd, ia), ia |= l, null;
        u.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, w = M !== null ? M.baseLanes : m, Vn(hd, ia), ia |= w;
      }
    else
      M !== null ? (w = M.baseLanes | m, u.memoizedState = null) : w = m, Vn(hd, ia), ia |= w;
    return li(l, u, P, m), u.child;
  }
  function an(l, u) {
    var m = u.ref;
    (l === null && m !== null || l !== null && l.ref !== m) && (u.flags |= 512, u.flags |= 2097152);
  }
  function ld(l, u, m, w, P) {
    var M = kr(m) ? Mo : Ht.current;
    return M = ka(u, M), tt(u, P), m = rc(l, u, m, w, M, P), w = tu(), l !== null && !ii ? (u.updateQueue = l.updateQueue, u.flags &= -2053, l.lanes &= ~P, Ni(l, u, P)) : (vr && w && rh(u), u.flags |= 1, li(l, u, m, P), u.child);
  }
  function ov(l, u, m, w, P) {
    if (kr(m)) {
      var M = !0;
      nh(u);
    } else
      M = !1;
    if (tt(u, P), u.stateNode === null)
      qi(l, u), y0(u, m, w), dh(u, m, w, P), w = !0;
    else if (l === null) {
      var H = u.stateNode, Q = u.memoizedProps;
      H.props = Q;
      var ee = H.context, Te = m.contextType;
      typeof Te == "object" && Te !== null ? Te = Xr(Te) : (Te = kr(m) ? Mo : Ht.current, Te = ka(u, Te));
      var Ve = m.getDerivedStateFromProps, Ye = typeof Ve == "function" || typeof H.getSnapshotBeforeUpdate == "function";
      Ye || typeof H.UNSAFE_componentWillReceiveProps != "function" && typeof H.componentWillReceiveProps != "function" || (Q !== w || ee !== Te) && b0(u, H, w, Te), Jl = !1;
      var He = u.memoizedState;
      H.state = He, tc(u, w, H, P), ee = u.memoizedState, Q !== w || He !== ee || Hr.current || Jl ? (typeof Ve == "function" && (Zm(u, m, Ve, w), ee = u.memoizedState), (Q = Jl || v0(u, m, Q, w, He, ee, Te)) ? (Ye || typeof H.UNSAFE_componentWillMount != "function" && typeof H.componentWillMount != "function" || (typeof H.componentWillMount == "function" && H.componentWillMount(), typeof H.UNSAFE_componentWillMount == "function" && H.UNSAFE_componentWillMount()), typeof H.componentDidMount == "function" && (u.flags |= 4194308)) : (typeof H.componentDidMount == "function" && (u.flags |= 4194308), u.memoizedProps = w, u.memoizedState = ee), H.props = w, H.state = ee, H.context = Te, w = Q) : (typeof H.componentDidMount == "function" && (u.flags |= 4194308), w = !1);
    } else {
      H = u.stateNode, si(l, u), Q = u.memoizedProps, Te = u.type === u.elementType ? Q : na(u.type, Q), H.props = Te, Ye = u.pendingProps, He = H.context, ee = m.contextType, typeof ee == "object" && ee !== null ? ee = Xr(ee) : (ee = kr(m) ? Mo : Ht.current, ee = ka(u, ee));
      var lt = m.getDerivedStateFromProps;
      (Ve = typeof lt == "function" || typeof H.getSnapshotBeforeUpdate == "function") || typeof H.UNSAFE_componentWillReceiveProps != "function" && typeof H.componentWillReceiveProps != "function" || (Q !== Ye || He !== ee) && b0(u, H, w, ee), Jl = !1, He = u.memoizedState, H.state = He, tc(u, w, H, P);
      var gt = u.memoizedState;
      Q !== Ye || He !== gt || Hr.current || Jl ? (typeof lt == "function" && (Zm(u, m, lt, w), gt = u.memoizedState), (Te = Jl || v0(u, m, Te, w, He, gt, ee) || !1) ? (Ve || typeof H.UNSAFE_componentWillUpdate != "function" && typeof H.componentWillUpdate != "function" || (typeof H.componentWillUpdate == "function" && H.componentWillUpdate(w, gt, ee), typeof H.UNSAFE_componentWillUpdate == "function" && H.UNSAFE_componentWillUpdate(w, gt, ee)), typeof H.componentDidUpdate == "function" && (u.flags |= 4), typeof H.getSnapshotBeforeUpdate == "function" && (u.flags |= 1024)) : (typeof H.componentDidUpdate != "function" || Q === l.memoizedProps && He === l.memoizedState || (u.flags |= 4), typeof H.getSnapshotBeforeUpdate != "function" || Q === l.memoizedProps && He === l.memoizedState || (u.flags |= 1024), u.memoizedProps = w, u.memoizedState = gt), H.props = w, H.state = gt, H.context = ee, w = Te) : (typeof H.componentDidUpdate != "function" || Q === l.memoizedProps && He === l.memoizedState || (u.flags |= 4), typeof H.getSnapshotBeforeUpdate != "function" || Q === l.memoizedProps && He === l.memoizedState || (u.flags |= 1024), w = !1);
    }
    return T0(l, u, m, w, M, P);
  }
  function T0(l, u, m, w, P, M) {
    an(l, u);
    var H = (u.flags & 128) !== 0;
    if (!w && !H)
      return P && d0(u, m, !1), Ni(l, u, M);
    w = u.stateNode, dE.current = u;
    var Q = H && typeof m.getDerivedStateFromError != "function" ? null : w.render();
    return u.flags |= 1, l !== null && H ? (u.child = nd(u, l.child, null, M), u.child = nd(u, null, Q, M)) : li(l, u, Q, M), u.memoizedState = w.state, P && d0(u, m, !0), u.child;
  }
  function k0(l) {
    var u = l.stateNode;
    u.pendingContext ? Xl(l, u.pendingContext, u.pendingContext !== u.context) : u.context && Xl(l, u.context, !1), Jm(l, u.containerInfo);
  }
  function Ah(l, u, m, w, P) {
    return Ar(), Km(P), u.flags |= 256, li(l, u, m, w), u.child;
  }
  var au = { dehydrated: null, treeContext: null, retryLane: 0 };
  function av(l) {
    return { baseLanes: l, cachePool: null, transitions: null };
  }
  function sv(l, u, m) {
    var w = u.pendingProps, P = Lt.current, M = !1, H = (u.flags & 128) !== 0, Q;
    if ((Q = H) || (Q = l !== null && l.memoizedState === null ? !1 : (P & 2) !== 0), Q ? (M = !0, u.flags &= -129) : (l === null || l.memoizedState !== null) && (P |= 1), Vn(Lt, P & 1), l === null)
      return oh(u), l = u.memoizedState, l !== null && (l = l.dehydrated, l !== null) ? (u.mode & 1 ? l.data === "$!" ? u.lanes = 8 : u.lanes = 1073741824 : u.lanes = 1, null) : (H = w.children, l = w.fallback, M ? (w = u.mode, M = u.child, H = { mode: "hidden", children: H }, !(w & 1) && M !== null ? (M.childLanes = 0, M.pendingProps = H) : M = Xf(H, w, 0, null), l = hu(l, w, m, null), M.return = u, l.return = u, M.sibling = l, u.child = M, u.child.memoizedState = av(m), u.memoizedState = au, l) : lv(u, H));
    if (P = l.memoizedState, P !== null && (Q = P.dehydrated, Q !== null))
      return fE(l, u, H, w, Q, P, m);
    if (M) {
      M = w.fallback, H = u.mode, P = l.child, Q = P.sibling;
      var ee = { mode: "hidden", children: w.children };
      return !(H & 1) && u.child !== P ? (w = u.child, w.childLanes = 0, w.pendingProps = ee, u.deletions = null) : (w = cc(P, ee), w.subtreeFlags = P.subtreeFlags & 14680064), Q !== null ? M = cc(Q, M) : (M = hu(M, H, m, null), M.flags |= 2), M.return = u, w.return = u, w.sibling = M, u.child = w, w = M, M = u.child, H = l.child.memoizedState, H = H === null ? av(m) : { baseLanes: H.baseLanes | m, cachePool: null, transitions: H.transitions }, M.memoizedState = H, M.childLanes = l.childLanes & ~m, u.memoizedState = au, w;
    }
    return M = l.child, l = M.sibling, w = cc(M, { mode: "visible", children: w.children }), !(u.mode & 1) && (w.lanes = m), w.return = u, w.sibling = null, l !== null && (m = u.deletions, m === null ? (u.deletions = [l], u.flags |= 16) : m.push(l)), u.child = w, u.memoizedState = null, w;
  }
  function lv(l, u) {
    return u = Xf({ mode: "visible", children: u }, l.mode, 0, null), u.return = l, l.child = u;
  }
  function cd(l, u, m, w) {
    return w !== null && Km(w), nd(u, l.child, null, m), l = lv(u, u.pendingProps.children), l.flags |= 2, u.memoizedState = null, l;
  }
  function fE(l, u, m, w, P, M, H) {
    if (m)
      return u.flags & 256 ? (u.flags &= -257, w = jf(Error(n(422))), cd(l, u, H, w)) : u.memoizedState !== null ? (u.child = l.child, u.flags |= 128, null) : (M = w.fallback, P = u.mode, w = Xf({ mode: "visible", children: w.children }, P, 0, null), M = hu(M, P, H, null), M.flags |= 2, w.return = u, M.return = u, w.sibling = M, u.child = w, u.mode & 1 && nd(u, l.child, null, H), u.child.memoizedState = av(H), u.memoizedState = au, M);
    if (!(u.mode & 1))
      return cd(l, u, H, null);
    if (P.data === "$!") {
      if (w = P.nextSibling && P.nextSibling.dataset, w)
        var Q = w.dgst;
      return w = Q, M = Error(n(419)), w = jf(M, w, void 0), cd(l, u, H, w);
    }
    if (Q = (H & l.childLanes) !== 0, ii || Q) {
      if (w = Dr, w !== null) {
        switch (H & -H) {
          case 4:
            P = 2;
            break;
          case 16:
            P = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            P = 32;
            break;
          case 536870912:
            P = 268435456;
            break;
          default:
            P = 0;
        }
        P = P & (w.suspendedLanes | H) ? 0 : P, P !== 0 && P !== M.retryLane && (M.retryLane = P, cl(l, P), eo(w, l, P, -1));
      }
      return Sv(), w = jf(Error(n(421))), cd(l, u, H, w);
    }
    return P.data === "$?" ? (u.flags |= 128, u.child = l.child, u = yE.bind(null, l), P._reactRetry = u, null) : (l = M.treeContext, No = rs(P.nextSibling), ta = u, vr = !0, Ra = null, l !== null && (Do[Xi++] = Oi, Do[Xi++] = ll, Do[Xi++] = Ia, Oi = l.id, ll = l.overflow, Ia = u), u = lv(u, w.children), u.flags |= 4096, u);
  }
  function cv(l, u, m) {
    l.lanes |= u;
    var w = l.alternate;
    w !== null && (w.lanes |= u), _i(l.return, u, m);
  }
  function Oh(l, u, m, w, P) {
    var M = l.memoizedState;
    M === null ? l.memoizedState = { isBackwards: u, rendering: null, renderingStartTime: 0, last: w, tail: m, tailMode: P } : (M.isBackwards = u, M.rendering = null, M.renderingStartTime = 0, M.last = w, M.tail = m, M.tailMode = P);
  }
  function uv(l, u, m) {
    var w = u.pendingProps, P = w.revealOrder, M = w.tail;
    if (li(l, u, w.children, m), w = Lt.current, w & 2)
      w = w & 1 | 2, u.flags |= 128;
    else {
      if (l !== null && l.flags & 128)
        e:
          for (l = u.child; l !== null; ) {
            if (l.tag === 13)
              l.memoizedState !== null && cv(l, m, u);
            else if (l.tag === 19)
              cv(l, m, u);
            else if (l.child !== null) {
              l.child.return = l, l = l.child;
              continue;
            }
            if (l === u)
              break e;
            for (; l.sibling === null; ) {
              if (l.return === null || l.return === u)
                break e;
              l = l.return;
            }
            l.sibling.return = l.return, l = l.sibling;
          }
      w &= 1;
    }
    if (Vn(Lt, w), !(u.mode & 1))
      u.memoizedState = null;
    else
      switch (P) {
        case "forwards":
          for (m = u.child, P = null; m !== null; )
            l = m.alternate, l !== null && Or(l) === null && (P = m), m = m.sibling;
          m = P, m === null ? (P = u.child, u.child = null) : (P = m.sibling, m.sibling = null), Oh(u, !1, P, m, M);
          break;
        case "backwards":
          for (m = null, P = u.child, u.child = null; P !== null; ) {
            if (l = P.alternate, l !== null && Or(l) === null) {
              u.child = P;
              break;
            }
            l = P.sibling, P.sibling = m, m = P, P = l;
          }
          Oh(u, !0, m, null, M);
          break;
        case "together":
          Oh(u, !1, null, null, void 0);
          break;
        default:
          u.memoizedState = null;
      }
    return u.child;
  }
  function qi(l, u) {
    !(u.mode & 1) && l !== null && (l.alternate = null, u.alternate = null, u.flags |= 2);
  }
  function Ni(l, u, m) {
    if (l !== null && (u.dependencies = l.dependencies), hl |= u.lanes, !(m & u.childLanes))
      return null;
    if (l !== null && u.child !== l.child)
      throw Error(n(153));
    if (u.child !== null) {
      for (l = u.child, m = cc(l, l.pendingProps), u.child = m, m.return = u; l.sibling !== null; )
        l = l.sibling, m = m.sibling = cc(l, l.pendingProps), m.return = u;
      m.sibling = null;
    }
    return u.child;
  }
  function fl(l, u, m) {
    switch (u.tag) {
      case 3:
        k0(u), Ar();
        break;
      case 5:
        Dt(u);
        break;
      case 1:
        kr(u.type) && nh(u);
        break;
      case 4:
        Jm(u, u.stateNode.containerInfo);
        break;
      case 10:
        var w = u.type._context, P = u.memoizedProps.value;
        Vn(Ps, w._currentValue), w._currentValue = P;
        break;
      case 13:
        if (w = u.memoizedState, w !== null)
          return w.dehydrated !== null ? (Vn(Lt, Lt.current & 1), u.flags |= 128, null) : m & u.child.childLanes ? sv(l, u, m) : (Vn(Lt, Lt.current & 1), l = Ni(l, u, m), l !== null ? l.sibling : null);
        Vn(Lt, Lt.current & 1);
        break;
      case 19:
        if (w = (m & u.childLanes) !== 0, l.flags & 128) {
          if (w)
            return uv(l, u, m);
          u.flags |= 128;
        }
        if (P = u.memoizedState, P !== null && (P.rendering = null, P.tail = null, P.lastEffect = null), Vn(Lt, Lt.current), w)
          break;
        return null;
      case 22:
      case 23:
        return u.lanes = 0, ou(l, u, m);
    }
    return Ni(l, u, m);
  }
  var Uf, su, Aa, ci;
  Uf = function(l, u) {
    for (var m = u.child; m !== null; ) {
      if (m.tag === 5 || m.tag === 6)
        l.appendChild(m.stateNode);
      else if (m.tag !== 4 && m.child !== null) {
        m.child.return = m, m = m.child;
        continue;
      }
      if (m === u)
        break;
      for (; m.sibling === null; ) {
        if (m.return === null || m.return === u)
          return;
        m = m.return;
      }
      m.sibling.return = m.return, m = m.sibling;
    }
  }, su = function() {
  }, Aa = function(l, u, m, w) {
    var P = l.memoizedProps;
    if (P !== w) {
      l = u.stateNode, Qc(is.current);
      var M = null;
      switch (m) {
        case "input":
          P = Ke(l, P), w = Ke(l, w), M = [];
          break;
        case "select":
          P = W({}, P, { value: void 0 }), w = W({}, w, { value: void 0 }), M = [];
          break;
        case "textarea":
          P = Ur(l, P), w = Ur(l, w), M = [];
          break;
        default:
          typeof P.onClick != "function" && typeof w.onClick == "function" && (l.onclick = th);
      }
      _r(m, w);
      var H;
      m = null;
      for (Te in P)
        if (!w.hasOwnProperty(Te) && P.hasOwnProperty(Te) && P[Te] != null)
          if (Te === "style") {
            var Q = P[Te];
            for (H in Q)
              Q.hasOwnProperty(H) && (m || (m = {}), m[H] = "");
          } else
            Te !== "dangerouslySetInnerHTML" && Te !== "children" && Te !== "suppressContentEditableWarning" && Te !== "suppressHydrationWarning" && Te !== "autoFocus" && (a.hasOwnProperty(Te) ? M || (M = []) : (M = M || []).push(Te, null));
      for (Te in w) {
        var ee = w[Te];
        if (Q = P?.[Te], w.hasOwnProperty(Te) && ee !== Q && (ee != null || Q != null))
          if (Te === "style")
            if (Q) {
              for (H in Q)
                !Q.hasOwnProperty(H) || ee && ee.hasOwnProperty(H) || (m || (m = {}), m[H] = "");
              for (H in ee)
                ee.hasOwnProperty(H) && Q[H] !== ee[H] && (m || (m = {}), m[H] = ee[H]);
            } else
              m || (M || (M = []), M.push(
                Te,
                m
              )), m = ee;
          else
            Te === "dangerouslySetInnerHTML" ? (ee = ee ? ee.__html : void 0, Q = Q ? Q.__html : void 0, ee != null && Q !== ee && (M = M || []).push(Te, ee)) : Te === "children" ? typeof ee != "string" && typeof ee != "number" || (M = M || []).push(Te, "" + ee) : Te !== "suppressContentEditableWarning" && Te !== "suppressHydrationWarning" && (a.hasOwnProperty(Te) ? (ee != null && Te === "onScroll" && sr("scroll", l), M || Q === ee || (M = [])) : (M = M || []).push(Te, ee));
      }
      m && (M = M || []).push("style", m);
      var Te = M;
      (u.updateQueue = Te) && (u.flags |= 4);
    }
  }, ci = function(l, u, m, w) {
    m !== w && (u.flags |= 4);
  };
  function Bf(l, u) {
    if (!vr)
      switch (l.tailMode) {
        case "hidden":
          u = l.tail;
          for (var m = null; u !== null; )
            u.alternate !== null && (m = u), u = u.sibling;
          m === null ? l.tail = null : m.sibling = null;
          break;
        case "collapsed":
          m = l.tail;
          for (var w = null; m !== null; )
            m.alternate !== null && (w = m), m = m.sibling;
          w === null ? u || l.tail === null ? l.tail = null : l.tail.sibling = null : w.sibling = null;
      }
  }
  function Qi(l) {
    var u = l.alternate !== null && l.alternate.child === l.child, m = 0, w = 0;
    if (u)
      for (var P = l.child; P !== null; )
        m |= P.lanes | P.childLanes, w |= P.subtreeFlags & 14680064, w |= P.flags & 14680064, P.return = l, P = P.sibling;
    else
      for (P = l.child; P !== null; )
        m |= P.lanes | P.childLanes, w |= P.subtreeFlags, w |= P.flags, P.return = l, P = P.sibling;
    return l.subtreeFlags |= w, l.childLanes = m, u;
  }
  function pE(l, u, m) {
    var w = u.pendingProps;
    switch (Vm(u), u.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Qi(u), null;
      case 1:
        return kr(u.type) && Pa(), Qi(u), null;
      case 3:
        return w = u.stateNode, nc(), Un(Hr), Un(Ht), ph(), w.pendingContext && (w.context = w.pendingContext, w.pendingContext = null), (l === null || l.child === null) && (ah(u) ? u.flags |= 4 : l === null || l.memoizedState.isDehydrated && !(u.flags & 256) || (u.flags |= 1024, Ra !== null && (Gf(Ra), Ra = null))), su(l, u), Qi(u), null;
      case 5:
        fn(u);
        var P = Qc(rd.current);
        if (m = u.type, l !== null && u.stateNode != null)
          Aa(l, u, m, w, P), l.ref !== u.ref && (u.flags |= 512, u.flags |= 2097152);
        else {
          if (!w) {
            if (u.stateNode === null)
              throw Error(n(166));
            return Qi(u), null;
          }
          if (l = Qc(is.current), ah(u)) {
            w = u.stateNode, m = u.type;
            var M = u.memoizedProps;
            switch (w[Ts] = u, w[Gc] = M, l = (u.mode & 1) !== 0, m) {
              case "dialog":
                sr("cancel", w), sr("close", w);
                break;
              case "iframe":
              case "object":
              case "embed":
                sr("load", w);
                break;
              case "video":
              case "audio":
                for (P = 0; P < Cf.length; P++)
                  sr(Cf[P], w);
                break;
              case "source":
                sr("error", w);
                break;
              case "img":
              case "image":
              case "link":
                sr(
                  "error",
                  w
                ), sr("load", w);
                break;
              case "details":
                sr("toggle", w);
                break;
              case "input":
                yt(w, M), sr("invalid", w);
                break;
              case "select":
                w._wrapperState = { wasMultiple: !!M.multiple }, sr("invalid", w);
                break;
              case "textarea":
                Hn(w, M), sr("invalid", w);
            }
            _r(m, M), P = null;
            for (var H in M)
              if (M.hasOwnProperty(H)) {
                var Q = M[H];
                H === "children" ? typeof Q == "string" ? w.textContent !== Q && (M.suppressHydrationWarning !== !0 && eh(w.textContent, Q, l), P = ["children", Q]) : typeof Q == "number" && w.textContent !== "" + Q && (M.suppressHydrationWarning !== !0 && eh(
                  w.textContent,
                  Q,
                  l
                ), P = ["children", "" + Q]) : a.hasOwnProperty(H) && Q != null && H === "onScroll" && sr("scroll", w);
              }
            switch (m) {
              case "input":
                Tt(w), yn(w, M, !0);
                break;
              case "textarea":
                Tt(w), cn(w);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof M.onClick == "function" && (w.onclick = th);
            }
            w = P, u.updateQueue = w, w !== null && (u.flags |= 4);
          } else {
            H = P.nodeType === 9 ? P : P.ownerDocument, l === "http://www.w3.org/1999/xhtml" && (l = ni(m)), l === "http://www.w3.org/1999/xhtml" ? m === "script" ? (l = H.createElement("div"), l.innerHTML = "<script><\/script>", l = l.removeChild(l.firstChild)) : typeof w.is == "string" ? l = H.createElement(m, { is: w.is }) : (l = H.createElement(m), m === "select" && (H = l, w.multiple ? H.multiple = !0 : w.size && (H.size = w.size))) : l = H.createElementNS(l, m), l[Ts] = u, l[Gc] = w, Uf(l, u, !1, !1), u.stateNode = l;
            e: {
              switch (H = ur(m, w), m) {
                case "dialog":
                  sr("cancel", l), sr("close", l), P = w;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  sr("load", l), P = w;
                  break;
                case "video":
                case "audio":
                  for (P = 0; P < Cf.length; P++)
                    sr(Cf[P], l);
                  P = w;
                  break;
                case "source":
                  sr("error", l), P = w;
                  break;
                case "img":
                case "image":
                case "link":
                  sr(
                    "error",
                    l
                  ), sr("load", l), P = w;
                  break;
                case "details":
                  sr("toggle", l), P = w;
                  break;
                case "input":
                  yt(l, w), P = Ke(l, w), sr("invalid", l);
                  break;
                case "option":
                  P = w;
                  break;
                case "select":
                  l._wrapperState = { wasMultiple: !!w.multiple }, P = W({}, w, { value: void 0 }), sr("invalid", l);
                  break;
                case "textarea":
                  Hn(l, w), P = Ur(l, w), sr("invalid", l);
                  break;
                default:
                  P = w;
              }
              _r(m, P), Q = P;
              for (M in Q)
                if (Q.hasOwnProperty(M)) {
                  var ee = Q[M];
                  M === "style" ? kn(l, ee) : M === "dangerouslySetInnerHTML" ? (ee = ee ? ee.__html : void 0, ee != null && Go(l, ee)) : M === "children" ? typeof ee == "string" ? (m !== "textarea" || ee !== "") && Cr(l, ee) : typeof ee == "number" && Cr(l, "" + ee) : M !== "suppressContentEditableWarning" && M !== "suppressHydrationWarning" && M !== "autoFocus" && (a.hasOwnProperty(M) ? ee != null && M === "onScroll" && sr("scroll", l) : ee != null && j(l, M, ee, H));
                }
              switch (m) {
                case "input":
                  Tt(l), yn(l, w, !1);
                  break;
                case "textarea":
                  Tt(l), cn(l);
                  break;
                case "option":
                  w.value != null && l.setAttribute("value", "" + ke(w.value));
                  break;
                case "select":
                  l.multiple = !!w.multiple, M = w.value, M != null ? Mr(l, !!w.multiple, M, !1) : w.defaultValue != null && Mr(
                    l,
                    !!w.multiple,
                    w.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof P.onClick == "function" && (l.onclick = th);
              }
              switch (m) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  w = !!w.autoFocus;
                  break e;
                case "img":
                  w = !0;
                  break e;
                default:
                  w = !1;
              }
            }
            w && (u.flags |= 4);
          }
          u.ref !== null && (u.flags |= 512, u.flags |= 2097152);
        }
        return Qi(u), null;
      case 6:
        if (l && u.stateNode != null)
          ci(l, u, l.memoizedProps, w);
        else {
          if (typeof w != "string" && u.stateNode === null)
            throw Error(n(166));
          if (m = Qc(rd.current), Qc(is.current), ah(u)) {
            if (w = u.stateNode, m = u.memoizedProps, w[Ts] = u, (M = w.nodeValue !== m) && (l = ta, l !== null))
              switch (l.tag) {
                case 3:
                  eh(w.nodeValue, m, (l.mode & 1) !== 0);
                  break;
                case 5:
                  l.memoizedProps.suppressHydrationWarning !== !0 && eh(w.nodeValue, m, (l.mode & 1) !== 0);
              }
            M && (u.flags |= 4);
          } else
            w = (m.nodeType === 9 ? m : m.ownerDocument).createTextNode(w), w[Ts] = u, u.stateNode = w;
        }
        return Qi(u), null;
      case 13:
        if (Un(Lt), w = u.memoizedState, l === null || l.memoizedState !== null && l.memoizedState.dehydrated !== null) {
          if (vr && No !== null && u.mode & 1 && !(u.flags & 128))
            h0(), Ar(), u.flags |= 98560, M = !1;
          else if (M = ah(u), w !== null && w.dehydrated !== null) {
            if (l === null) {
              if (!M)
                throw Error(n(318));
              if (M = u.memoizedState, M = M !== null ? M.dehydrated : null, !M)
                throw Error(n(317));
              M[Ts] = u;
            } else
              Ar(), !(u.flags & 128) && (u.memoizedState = null), u.flags |= 4;
            Qi(u), M = !1;
          } else
            Ra !== null && (Gf(Ra), Ra = null), M = !0;
          if (!M)
            return u.flags & 65536 ? u : null;
        }
        return u.flags & 128 ? (u.lanes = m, u) : (w = w !== null, w !== (l !== null && l.memoizedState !== null) && w && (u.child.flags |= 8192, u.mode & 1 && (l === null || Lt.current & 1 ? fi === 0 && (fi = 3) : Sv())), u.updateQueue !== null && (u.flags |= 4), Qi(u), null);
      case 4:
        return nc(), su(l, u), l === null && Zu(u.stateNode.containerInfo), Qi(u), null;
      case 10:
        return Zl(u.type._context), Qi(u), null;
      case 17:
        return kr(u.type) && Pa(), Qi(u), null;
      case 19:
        if (Un(Lt), M = u.memoizedState, M === null)
          return Qi(u), null;
        if (w = (u.flags & 128) !== 0, H = M.rendering, H === null)
          if (w)
            Bf(M, !1);
          else {
            if (fi !== 0 || l !== null && l.flags & 128)
              for (l = u.child; l !== null; ) {
                if (H = Or(l), H !== null) {
                  for (u.flags |= 128, Bf(M, !1), w = H.updateQueue, w !== null && (u.updateQueue = w, u.flags |= 4), u.subtreeFlags = 0, w = m, m = u.child; m !== null; )
                    M = m, l = w, M.flags &= 14680066, H = M.alternate, H === null ? (M.childLanes = 0, M.lanes = l, M.child = null, M.subtreeFlags = 0, M.memoizedProps = null, M.memoizedState = null, M.updateQueue = null, M.dependencies = null, M.stateNode = null) : (M.childLanes = H.childLanes, M.lanes = H.lanes, M.child = H.child, M.subtreeFlags = 0, M.deletions = null, M.memoizedProps = H.memoizedProps, M.memoizedState = H.memoizedState, M.updateQueue = H.updateQueue, M.type = H.type, l = H.dependencies, M.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }), m = m.sibling;
                  return Vn(Lt, Lt.current & 1 | 2), u.child;
                }
                l = l.sibling;
              }
            M.tail !== null && bn() > md && (u.flags |= 128, w = !0, Bf(M, !1), u.lanes = 4194304);
          }
        else {
          if (!w)
            if (l = Or(H), l !== null) {
              if (u.flags |= 128, w = !0, m = l.updateQueue, m !== null && (u.updateQueue = m, u.flags |= 4), Bf(M, !0), M.tail === null && M.tailMode === "hidden" && !H.alternate && !vr)
                return Qi(u), null;
            } else
              2 * bn() - M.renderingStartTime > md && m !== 1073741824 && (u.flags |= 128, w = !0, Bf(M, !1), u.lanes = 4194304);
          M.isBackwards ? (H.sibling = u.child, u.child = H) : (m = M.last, m !== null ? m.sibling = H : u.child = H, M.last = H);
        }
        return M.tail !== null ? (u = M.tail, M.rendering = u, M.tail = u.sibling, M.renderingStartTime = bn(), u.sibling = null, m = Lt.current, Vn(Lt, w ? m & 1 | 2 : m & 1), u) : (Qi(u), null);
      case 22:
      case 23:
        return bv(), w = u.memoizedState !== null, l !== null && l.memoizedState !== null !== w && (u.flags |= 8192), w && u.mode & 1 ? ia & 1073741824 && (Qi(u), u.subtreeFlags & 6 && (u.flags |= 8192)) : Qi(u), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(n(156, u.tag));
  }
  function dv(l, u) {
    switch (Vm(u), u.tag) {
      case 1:
        return kr(u.type) && Pa(), l = u.flags, l & 65536 ? (u.flags = l & -65537 | 128, u) : null;
      case 3:
        return nc(), Un(Hr), Un(Ht), ph(), l = u.flags, l & 65536 && !(l & 128) ? (u.flags = l & -65537 | 128, u) : null;
      case 5:
        return fn(u), null;
      case 13:
        if (Un(Lt), l = u.memoizedState, l !== null && l.dehydrated !== null) {
          if (u.alternate === null)
            throw Error(n(340));
          Ar();
        }
        return l = u.flags, l & 65536 ? (u.flags = l & -65537 | 128, u) : null;
      case 19:
        return Un(Lt), null;
      case 4:
        return nc(), null;
      case 10:
        return Zl(u.type._context), null;
      case 22:
      case 23:
        return bv(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Ff = !1, di = !1, P0 = typeof WeakSet == "function" ? WeakSet : Set, ft = null;
  function ud(l, u) {
    var m = l.ref;
    if (m !== null)
      if (typeof m == "function")
        try {
          m(null);
        } catch (w) {
          Yr(l, u, w);
        }
      else
        m.current = null;
  }
  function Hf(l, u, m) {
    try {
      m();
    } catch (w) {
      Yr(l, u, w);
    }
  }
  var I0 = !1;
  function R0(l, u) {
    if (Nm = ie, l = Xp(), il(l)) {
      if ("selectionStart" in l)
        var m = { start: l.selectionStart, end: l.selectionEnd };
      else
        e: {
          m = (m = l.ownerDocument) && m.defaultView || window;
          var w = m.getSelection && m.getSelection();
          if (w && w.rangeCount !== 0) {
            m = w.anchorNode;
            var P = w.anchorOffset, M = w.focusNode;
            w = w.focusOffset;
            try {
              m.nodeType, M.nodeType;
            } catch {
              m = null;
              break e;
            }
            var H = 0, Q = -1, ee = -1, Te = 0, Ve = 0, Ye = l, He = null;
            t:
              for (; ; ) {
                for (var lt; Ye !== m || P !== 0 && Ye.nodeType !== 3 || (Q = H + P), Ye !== M || w !== 0 && Ye.nodeType !== 3 || (ee = H + w), Ye.nodeType === 3 && (H += Ye.nodeValue.length), (lt = Ye.firstChild) !== null; )
                  He = Ye, Ye = lt;
                for (; ; ) {
                  if (Ye === l)
                    break t;
                  if (He === m && ++Te === P && (Q = H), He === M && ++Ve === w && (ee = H), (lt = Ye.nextSibling) !== null)
                    break;
                  Ye = He, He = Ye.parentNode;
                }
                Ye = lt;
              }
            m = Q === -1 || ee === -1 ? null : { start: Q, end: ee };
          } else
            m = null;
        }
      m = m || { start: 0, end: 0 };
    } else
      m = null;
    for (Kc = { focusedElem: l, selectionRange: m }, ie = !1, ft = u; ft !== null; )
      if (u = ft, l = u.child, (u.subtreeFlags & 1028) !== 0 && l !== null)
        l.return = u, ft = l;
      else
        for (; ft !== null; ) {
          u = ft;
          try {
            var gt = u.alternate;
            if (u.flags & 1024)
              switch (u.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (gt !== null) {
                    var wt = gt.memoizedProps, qr = gt.memoizedState, ge = u.stateNode, oe = ge.getSnapshotBeforeUpdate(u.elementType === u.type ? wt : na(u.type, wt), qr);
                    ge.__reactInternalSnapshotBeforeUpdate = oe;
                  }
                  break;
                case 3:
                  var we = u.stateNode.containerInfo;
                  we.nodeType === 1 ? we.textContent = "" : we.nodeType === 9 && we.documentElement && we.removeChild(we.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(n(163));
              }
          } catch (Xe) {
            Yr(u, u.return, Xe);
          }
          if (l = u.sibling, l !== null) {
            l.return = u.return, ft = l;
            break;
          }
          ft = u.return;
        }
    return gt = I0, I0 = !1, gt;
  }
  function Vf(l, u, m) {
    var w = u.updateQueue;
    if (w = w !== null ? w.lastEffect : null, w !== null) {
      var P = w = w.next;
      do {
        if ((P.tag & l) === l) {
          var M = P.destroy;
          P.destroy = void 0, M !== void 0 && Hf(u, m, M);
        }
        P = P.next;
      } while (P !== w);
    }
  }
  function Yf(l, u) {
    if (u = u.updateQueue, u = u !== null ? u.lastEffect : null, u !== null) {
      var m = u = u.next;
      do {
        if ((m.tag & l) === l) {
          var w = m.create;
          m.destroy = w();
        }
        m = m.next;
      } while (m !== u);
    }
  }
  function fv(l) {
    var u = l.ref;
    if (u !== null) {
      var m = l.stateNode;
      switch (l.tag) {
        case 5:
          l = m;
          break;
        default:
          l = m;
      }
      typeof u == "function" ? u(l) : u.current = l;
    }
  }
  function pv(l) {
    var u = l.alternate;
    u !== null && (l.alternate = null, pv(u)), l.child = null, l.deletions = null, l.sibling = null, l.tag === 5 && (u = l.stateNode, u !== null && (delete u[Ts], delete u[Gc], delete u[zm], delete u[aE], delete u[Um])), l.stateNode = null, l.return = null, l.dependencies = null, l.memoizedProps = null, l.memoizedState = null, l.pendingProps = null, l.stateNode = null, l.updateQueue = null;
  }
  function $0(l) {
    return l.tag === 5 || l.tag === 3 || l.tag === 4;
  }
  function Dh(l) {
    e:
      for (; ; ) {
        for (; l.sibling === null; ) {
          if (l.return === null || $0(l.return))
            return null;
          l = l.return;
        }
        for (l.sibling.return = l.return, l = l.sibling; l.tag !== 5 && l.tag !== 6 && l.tag !== 18; ) {
          if (l.flags & 2 || l.child === null || l.tag === 4)
            continue e;
          l.child.return = l, l = l.child;
        }
        if (!(l.flags & 2))
          return l.stateNode;
      }
  }
  function dd(l, u, m) {
    var w = l.tag;
    if (w === 5 || w === 6)
      l = l.stateNode, u ? m.nodeType === 8 ? m.parentNode.insertBefore(l, u) : m.insertBefore(l, u) : (m.nodeType === 8 ? (u = m.parentNode, u.insertBefore(l, m)) : (u = m, u.appendChild(l)), m = m._reactRootContainer, m != null || u.onclick !== null || (u.onclick = th));
    else if (w !== 4 && (l = l.child, l !== null))
      for (dd(l, u, m), l = l.sibling; l !== null; )
        dd(l, u, m), l = l.sibling;
  }
  function Rs(l, u, m) {
    var w = l.tag;
    if (w === 5 || w === 6)
      l = l.stateNode, u ? m.insertBefore(l, u) : m.appendChild(l);
    else if (w !== 4 && (l = l.child, l !== null))
      for (Rs(l, u, m), l = l.sibling; l !== null; )
        Rs(l, u, m), l = l.sibling;
  }
  var Pr = null, Ti = !1;
  function Oa(l, u, m) {
    for (m = m.child; m !== null; )
      fd(l, u, m), m = m.sibling;
  }
  function fd(l, u, m) {
    if (Wi && typeof Wi.onCommitFiberUnmount == "function")
      try {
        Wi.onCommitFiberUnmount(Ss, m);
      } catch {
      }
    switch (m.tag) {
      case 5:
        di || ud(m, u);
      case 6:
        var w = Pr, P = Ti;
        Pr = null, Oa(l, u, m), Pr = w, Ti = P, Pr !== null && (Ti ? (l = Pr, m = m.stateNode, l.nodeType === 8 ? l.parentNode.removeChild(m) : l.removeChild(m)) : Pr.removeChild(m.stateNode));
        break;
      case 18:
        Pr !== null && (Ti ? (l = Pr, m = m.stateNode, l.nodeType === 8 ? Kl(l.parentNode, m) : l.nodeType === 1 && Kl(l, m), _s(l)) : Kl(Pr, m.stateNode));
        break;
      case 4:
        w = Pr, P = Ti, Pr = m.stateNode.containerInfo, Ti = !0, Oa(l, u, m), Pr = w, Ti = P;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!di && (w = m.updateQueue, w !== null && (w = w.lastEffect, w !== null))) {
          P = w = w.next;
          do {
            var M = P, H = M.destroy;
            M = M.tag, H !== void 0 && (M & 2 || M & 4) && Hf(m, u, H), P = P.next;
          } while (P !== w);
        }
        Oa(l, u, m);
        break;
      case 1:
        if (!di && (ud(m, u), w = m.stateNode, typeof w.componentWillUnmount == "function"))
          try {
            w.props = m.memoizedProps, w.state = m.memoizedState, w.componentWillUnmount();
          } catch (Q) {
            Yr(m, u, Q);
          }
        Oa(l, u, m);
        break;
      case 21:
        Oa(l, u, m);
        break;
      case 22:
        m.mode & 1 ? (di = (w = di) || m.memoizedState !== null, Oa(l, u, m), di = w) : Oa(l, u, m);
        break;
      default:
        Oa(l, u, m);
    }
  }
  function pl(l) {
    var u = l.updateQueue;
    if (u !== null) {
      l.updateQueue = null;
      var m = l.stateNode;
      m === null && (m = l.stateNode = new P0()), u.forEach(function(w) {
        var P = bE.bind(null, l, w);
        m.has(w) || (m.add(w), w.then(P, P));
      });
    }
  }
  function os(l, u) {
    var m = u.deletions;
    if (m !== null)
      for (var w = 0; w < m.length; w++) {
        var P = m[w];
        try {
          var M = l, H = u, Q = H;
          e:
            for (; Q !== null; ) {
              switch (Q.tag) {
                case 5:
                  Pr = Q.stateNode, Ti = !1;
                  break e;
                case 3:
                  Pr = Q.stateNode.containerInfo, Ti = !0;
                  break e;
                case 4:
                  Pr = Q.stateNode.containerInfo, Ti = !0;
                  break e;
              }
              Q = Q.return;
            }
          if (Pr === null)
            throw Error(n(160));
          fd(M, H, P), Pr = null, Ti = !1;
          var ee = P.alternate;
          ee !== null && (ee.return = null), P.return = null;
        } catch (Te) {
          Yr(P, u, Te);
        }
      }
    if (u.subtreeFlags & 12854)
      for (u = u.child; u !== null; )
        M0(u, l), u = u.sibling;
  }
  function M0(l, u) {
    var m = l.alternate, w = l.flags;
    switch (l.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (os(u, l), $s(l), w & 4) {
          try {
            Vf(3, l, l.return), Yf(3, l);
          } catch (wt) {
            Yr(l, l.return, wt);
          }
          try {
            Vf(5, l, l.return);
          } catch (wt) {
            Yr(l, l.return, wt);
          }
        }
        break;
      case 1:
        os(u, l), $s(l), w & 512 && m !== null && ud(m, m.return);
        break;
      case 5:
        if (os(u, l), $s(l), w & 512 && m !== null && ud(m, m.return), l.flags & 32) {
          var P = l.stateNode;
          try {
            Cr(P, "");
          } catch (wt) {
            Yr(l, l.return, wt);
          }
        }
        if (w & 4 && (P = l.stateNode, P != null)) {
          var M = l.memoizedProps, H = m !== null ? m.memoizedProps : M, Q = l.type, ee = l.updateQueue;
          if (l.updateQueue = null, ee !== null)
            try {
              Q === "input" && M.type === "radio" && M.name != null && Xt(P, M), ur(Q, H);
              var Te = ur(Q, M);
              for (H = 0; H < ee.length; H += 2) {
                var Ve = ee[H], Ye = ee[H + 1];
                Ve === "style" ? kn(P, Ye) : Ve === "dangerouslySetInnerHTML" ? Go(P, Ye) : Ve === "children" ? Cr(P, Ye) : j(P, Ve, Ye, Te);
              }
              switch (Q) {
                case "input":
                  kt(P, M);
                  break;
                case "textarea":
                  xt(P, M);
                  break;
                case "select":
                  var He = P._wrapperState.wasMultiple;
                  P._wrapperState.wasMultiple = !!M.multiple;
                  var lt = M.value;
                  lt != null ? Mr(P, !!M.multiple, lt, !1) : He !== !!M.multiple && (M.defaultValue != null ? Mr(
                    P,
                    !!M.multiple,
                    M.defaultValue,
                    !0
                  ) : Mr(P, !!M.multiple, M.multiple ? [] : "", !1));
              }
              P[Gc] = M;
            } catch (wt) {
              Yr(l, l.return, wt);
            }
        }
        break;
      case 6:
        if (os(u, l), $s(l), w & 4) {
          if (l.stateNode === null)
            throw Error(n(162));
          P = l.stateNode, M = l.memoizedProps;
          try {
            P.nodeValue = M;
          } catch (wt) {
            Yr(l, l.return, wt);
          }
        }
        break;
      case 3:
        if (os(u, l), $s(l), w & 4 && m !== null && m.memoizedState.isDehydrated)
          try {
            _s(u.containerInfo);
          } catch (wt) {
            Yr(l, l.return, wt);
          }
        break;
      case 4:
        os(u, l), $s(l);
        break;
      case 13:
        os(u, l), $s(l), P = l.child, P.flags & 8192 && (M = P.memoizedState !== null, P.stateNode.isHidden = M, !M || P.alternate !== null && P.alternate.memoizedState !== null || (mv = bn())), w & 4 && pl(l);
        break;
      case 22:
        if (Ve = m !== null && m.memoizedState !== null, l.mode & 1 ? (di = (Te = di) || Ve, os(u, l), di = Te) : os(u, l), $s(l), w & 8192) {
          if (Te = l.memoizedState !== null, (l.stateNode.isHidden = Te) && !Ve && l.mode & 1)
            for (ft = l, Ve = l.child; Ve !== null; ) {
              for (Ye = ft = Ve; ft !== null; ) {
                switch (He = ft, lt = He.child, He.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Vf(4, He, He.return);
                    break;
                  case 1:
                    ud(He, He.return);
                    var gt = He.stateNode;
                    if (typeof gt.componentWillUnmount == "function") {
                      w = He, m = He.return;
                      try {
                        u = w, gt.props = u.memoizedProps, gt.state = u.memoizedState, gt.componentWillUnmount();
                      } catch (wt) {
                        Yr(w, m, wt);
                      }
                    }
                    break;
                  case 5:
                    ud(He, He.return);
                    break;
                  case 22:
                    if (He.memoizedState !== null) {
                      hv(Ye);
                      continue;
                    }
                }
                lt !== null ? (lt.return = He, ft = lt) : hv(Ye);
              }
              Ve = Ve.sibling;
            }
          e:
            for (Ve = null, Ye = l; ; ) {
              if (Ye.tag === 5) {
                if (Ve === null) {
                  Ve = Ye;
                  try {
                    P = Ye.stateNode, Te ? (M = P.style, typeof M.setProperty == "function" ? M.setProperty("display", "none", "important") : M.display = "none") : (Q = Ye.stateNode, ee = Ye.memoizedProps.style, H = ee != null && ee.hasOwnProperty("display") ? ee.display : null, Q.style.display = nn("display", H));
                  } catch (wt) {
                    Yr(l, l.return, wt);
                  }
                }
              } else if (Ye.tag === 6) {
                if (Ve === null)
                  try {
                    Ye.stateNode.nodeValue = Te ? "" : Ye.memoizedProps;
                  } catch (wt) {
                    Yr(l, l.return, wt);
                  }
              } else if ((Ye.tag !== 22 && Ye.tag !== 23 || Ye.memoizedState === null || Ye === l) && Ye.child !== null) {
                Ye.child.return = Ye, Ye = Ye.child;
                continue;
              }
              if (Ye === l)
                break e;
              for (; Ye.sibling === null; ) {
                if (Ye.return === null || Ye.return === l)
                  break e;
                Ve === Ye && (Ve = null), Ye = Ye.return;
              }
              Ve === Ye && (Ve = null), Ye.sibling.return = Ye.return, Ye = Ye.sibling;
            }
        }
        break;
      case 19:
        os(u, l), $s(l), w & 4 && pl(l);
        break;
      case 21:
        break;
      default:
        os(
          u,
          l
        ), $s(l);
    }
  }
  function $s(l) {
    var u = l.flags;
    if (u & 2) {
      try {
        e: {
          for (var m = l.return; m !== null; ) {
            if ($0(m)) {
              var w = m;
              break e;
            }
            m = m.return;
          }
          throw Error(n(160));
        }
        switch (w.tag) {
          case 5:
            var P = w.stateNode;
            w.flags & 32 && (Cr(P, ""), w.flags &= -33);
            var M = Dh(l);
            Rs(l, M, P);
            break;
          case 3:
          case 4:
            var H = w.stateNode.containerInfo, Q = Dh(l);
            dd(l, Q, H);
            break;
          default:
            throw Error(n(161));
        }
      } catch (ee) {
        Yr(l, l.return, ee);
      }
      l.flags &= -3;
    }
    u & 4096 && (l.flags &= -4097);
  }
  function A0(l, u, m) {
    ft = l, pd(l);
  }
  function pd(l, u, m) {
    for (var w = (l.mode & 1) !== 0; ft !== null; ) {
      var P = ft, M = P.child;
      if (P.tag === 22 && w) {
        var H = P.memoizedState !== null || Ff;
        if (!H) {
          var Q = P.alternate, ee = Q !== null && Q.memoizedState !== null || di;
          Q = Ff;
          var Te = di;
          if (Ff = H, (di = ee) && !Te)
            for (ft = P; ft !== null; )
              H = ft, ee = H.child, H.tag === 22 && H.memoizedState !== null ? D0(P) : ee !== null ? (ee.return = H, ft = ee) : D0(P);
          for (; M !== null; )
            ft = M, pd(M), M = M.sibling;
          ft = P, Ff = Q, di = Te;
        }
        O0(l);
      } else
        P.subtreeFlags & 8772 && M !== null ? (M.return = P, ft = M) : O0(l);
    }
  }
  function O0(l) {
    for (; ft !== null; ) {
      var u = ft;
      if (u.flags & 8772) {
        var m = u.alternate;
        try {
          if (u.flags & 8772)
            switch (u.tag) {
              case 0:
              case 11:
              case 15:
                di || Yf(5, u);
                break;
              case 1:
                var w = u.stateNode;
                if (u.flags & 4 && !di)
                  if (m === null)
                    w.componentDidMount();
                  else {
                    var P = u.elementType === u.type ? m.memoizedProps : na(u.type, m.memoizedProps);
                    w.componentDidUpdate(P, m.memoizedState, w.__reactInternalSnapshotBeforeUpdate);
                  }
                var M = u.updateQueue;
                M !== null && qc(u, M, w);
                break;
              case 3:
                var H = u.updateQueue;
                if (H !== null) {
                  if (m = null, u.child !== null)
                    switch (u.child.tag) {
                      case 5:
                        m = u.child.stateNode;
                        break;
                      case 1:
                        m = u.child.stateNode;
                    }
                  qc(u, H, m);
                }
                break;
              case 5:
                var Q = u.stateNode;
                if (m === null && u.flags & 4) {
                  m = Q;
                  var ee = u.memoizedProps;
                  switch (u.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      ee.autoFocus && m.focus();
                      break;
                    case "img":
                      ee.src && (m.src = ee.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (u.memoizedState === null) {
                  var Te = u.alternate;
                  if (Te !== null) {
                    var Ve = Te.memoizedState;
                    if (Ve !== null) {
                      var Ye = Ve.dehydrated;
                      Ye !== null && _s(Ye);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(n(163));
            }
          di || u.flags & 512 && fv(u);
        } catch (He) {
          Yr(u, u.return, He);
        }
      }
      if (u === l) {
        ft = null;
        break;
      }
      if (m = u.sibling, m !== null) {
        m.return = u.return, ft = m;
        break;
      }
      ft = u.return;
    }
  }
  function hv(l) {
    for (; ft !== null; ) {
      var u = ft;
      if (u === l) {
        ft = null;
        break;
      }
      var m = u.sibling;
      if (m !== null) {
        m.return = u.return, ft = m;
        break;
      }
      ft = u.return;
    }
  }
  function D0(l) {
    for (; ft !== null; ) {
      var u = ft;
      try {
        switch (u.tag) {
          case 0:
          case 11:
          case 15:
            var m = u.return;
            try {
              Yf(4, u);
            } catch (ee) {
              Yr(u, m, ee);
            }
            break;
          case 1:
            var w = u.stateNode;
            if (typeof w.componentDidMount == "function") {
              var P = u.return;
              try {
                w.componentDidMount();
              } catch (ee) {
                Yr(u, P, ee);
              }
            }
            var M = u.return;
            try {
              fv(u);
            } catch (ee) {
              Yr(u, M, ee);
            }
            break;
          case 5:
            var H = u.return;
            try {
              fv(u);
            } catch (ee) {
              Yr(u, H, ee);
            }
        }
      } catch (ee) {
        Yr(u, u.return, ee);
      }
      if (u === l) {
        ft = null;
        break;
      }
      var Q = u.sibling;
      if (Q !== null) {
        Q.return = u.return, ft = Q;
        break;
      }
      ft = u.return;
    }
  }
  var Nh = Math.ceil, Kf = L.ReactCurrentDispatcher, gv = L.ReactCurrentOwner, Zi = L.ReactCurrentBatchConfig, mn = 0, Dr = null, Vr = null, ki = 0, ia = 0, hd = on(0), fi = 0, Wf = null, hl = 0, Lh = 0, gd = 0, lu = null, po = null, mv = 0, md = 1 / 0, gl = null, jh = !1, cu = null, Ms = null, ac = !1, sc = null, zh = 0, vd = 0, Uh = null, uu = -1, du = 0;
  function Ji() {
    return mn & 6 ? bn() : uu !== -1 ? uu : uu = bn();
  }
  function oi(l) {
    return l.mode & 1 ? mn & 2 && ki !== 0 ? ki & -ki : sh.transition !== null ? (du === 0 && (du = Ul()), du) : (l = hn, l !== 0 || (l = window.event, l = l === void 0 ? 16 : Tr(l.type)), l) : 1;
  }
  function eo(l, u, m, w) {
    if (50 < vd)
      throw vd = 0, Uh = null, Error(n(185));
    Za(l, m, w), (!(mn & 2) || l !== Dr) && (l === Dr && (!(mn & 2) && (Lh |= m), fi === 4 && Da(l, ki)), to(l, w), m === 1 && mn === 0 && !(u.mode & 1) && (md = bn() + 500, Ci && Ao()));
  }
  function to(l, u) {
    var m = l.callbackNode;
    xs(l, u);
    var w = wi(l, l === Dr ? ki : 0);
    if (w === 0)
      m !== null && hr(m), l.callbackNode = null, l.callbackPriority = 0;
    else if (u = w & -w, l.callbackPriority !== u) {
      if (m != null && hr(m), u === 1)
        l.tag === 0 ? Fm(N0.bind(null, l)) : Bm(N0.bind(null, l)), jm(function() {
          !(mn & 6) && Ao();
        }), m = null;
      else {
        switch (Qo(w)) {
          case 1:
            m = Xo;
            break;
          case 4:
            m = Jt;
            break;
          case 16:
            m = Ca;
            break;
          case 536870912:
            m = uo;
            break;
          default:
            m = Ca;
        }
        m = xv(m, yd.bind(null, l));
      }
      l.callbackPriority = u, l.callbackNode = m;
    }
  }
  function yd(l, u) {
    if (uu = -1, du = 0, mn & 6)
      throw Error(n(327));
    var m = l.callbackNode;
    if (Sd() && l.callbackNode !== m)
      return null;
    var w = wi(l, l === Dr ? ki : 0);
    if (w === 0)
      return null;
    if (w & 30 || w & l.expiredLanes || u)
      u = Fh(l, w);
    else {
      u = w;
      var P = mn;
      mn |= 2;
      var M = Bh();
      (Dr !== l || ki !== u) && (gl = null, md = bn() + 500, fu(l, u));
      do
        try {
          gE();
          break;
        } catch (Q) {
          L0(l, Q);
        }
      while (1);
      Gm(), Kf.current = M, mn = P, Vr !== null ? u = 0 : (Dr = null, ki = 0, u = fi);
    }
    if (u !== 0) {
      if (u === 2 && (P = Es(l), P !== 0 && (w = P, u = vv(l, P))), u === 1)
        throw m = Wf, fu(l, 0), Da(l, w), to(l, bn()), m;
      if (u === 6)
        Da(l, w);
      else {
        if (P = l.current.alternate, !(w & 30) && !yv(P) && (u = Fh(l, w), u === 2 && (M = Es(l), M !== 0 && (w = M, u = vv(l, M))), u === 1))
          throw m = Wf, fu(l, 0), Da(l, w), to(l, bn()), m;
        switch (l.finishedWork = P, l.finishedLanes = w, u) {
          case 0:
          case 1:
            throw Error(n(345));
          case 2:
            pu(l, po, gl);
            break;
          case 3:
            if (Da(l, w), (w & 130023424) === w && (u = mv + 500 - bn(), 10 < u)) {
              if (wi(l, 0) !== 0)
                break;
              if (P = l.suspendedLanes, (P & w) !== w) {
                Ji(), l.pingedLanes |= l.suspendedLanes & P;
                break;
              }
              l.timeoutHandle = Wc(pu.bind(null, l, po, gl), u);
              break;
            }
            pu(l, po, gl);
            break;
          case 4:
            if (Da(l, w), (w & 4194240) === w)
              break;
            for (u = l.eventTimes, P = -1; 0 < w; ) {
              var H = 31 - Ai(w);
              M = 1 << H, H = u[H], H > P && (P = H), w &= ~M;
            }
            if (w = P, w = bn() - w, w = (120 > w ? 120 : 480 > w ? 480 : 1080 > w ? 1080 : 1920 > w ? 1920 : 3e3 > w ? 3e3 : 4320 > w ? 4320 : 1960 * Nh(w / 1960)) - w, 10 < w) {
              l.timeoutHandle = Wc(pu.bind(null, l, po, gl), w);
              break;
            }
            pu(l, po, gl);
            break;
          case 5:
            pu(l, po, gl);
            break;
          default:
            throw Error(n(329));
        }
      }
    }
    return to(l, bn()), l.callbackNode === m ? yd.bind(null, l) : null;
  }
  function vv(l, u) {
    var m = lu;
    return l.current.memoizedState.isDehydrated && (fu(l, u).flags |= 256), l = Fh(l, u), l !== 2 && (u = po, po = m, u !== null && Gf(u)), l;
  }
  function Gf(l) {
    po === null ? po = l : po.push.apply(po, l);
  }
  function yv(l) {
    for (var u = l; ; ) {
      if (u.flags & 16384) {
        var m = u.updateQueue;
        if (m !== null && (m = m.stores, m !== null))
          for (var w = 0; w < m.length; w++) {
            var P = m[w], M = P.getSnapshot;
            P = P.value;
            try {
              if (!_a(M(), P))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (m = u.child, u.subtreeFlags & 16384 && m !== null)
        m.return = u, u = m;
      else {
        if (u === l)
          break;
        for (; u.sibling === null; ) {
          if (u.return === null || u.return === l)
            return !0;
          u = u.return;
        }
        u.sibling.return = u.return, u = u.sibling;
      }
    }
    return !0;
  }
  function Da(l, u) {
    for (u &= ~gd, u &= ~Lh, l.suspendedLanes |= u, l.pingedLanes &= ~u, l = l.expirationTimes; 0 < u; ) {
      var m = 31 - Ai(u), w = 1 << m;
      l[m] = -1, u &= ~w;
    }
  }
  function N0(l) {
    if (mn & 6)
      throw Error(n(327));
    Sd();
    var u = wi(l, 0);
    if (!(u & 1))
      return to(l, bn()), null;
    var m = Fh(l, u);
    if (l.tag !== 0 && m === 2) {
      var w = Es(l);
      w !== 0 && (u = w, m = vv(l, w));
    }
    if (m === 1)
      throw m = Wf, fu(l, 0), Da(l, u), to(l, bn()), m;
    if (m === 6)
      throw Error(n(345));
    return l.finishedWork = l.current.alternate, l.finishedLanes = u, pu(l, po, gl), to(l, bn()), null;
  }
  function bd(l, u) {
    var m = mn;
    mn |= 1;
    try {
      return l(u);
    } finally {
      mn = m, mn === 0 && (md = bn() + 500, Ci && Ao());
    }
  }
  function lc(l) {
    sc !== null && sc.tag === 0 && !(mn & 6) && Sd();
    var u = mn;
    mn |= 1;
    var m = Zi.transition, w = hn;
    try {
      if (Zi.transition = null, hn = 1, l)
        return l();
    } finally {
      hn = w, Zi.transition = m, mn = u, !(mn & 6) && Ao();
    }
  }
  function bv() {
    ia = hd.current, Un(hd);
  }
  function fu(l, u) {
    l.finishedWork = null, l.finishedLanes = 0;
    var m = l.timeoutHandle;
    if (m !== -1 && (l.timeoutHandle = -1, u0(m)), Vr !== null)
      for (m = Vr.return; m !== null; ) {
        var w = m;
        switch (Vm(w), w.tag) {
          case 1:
            w = w.type.childContextTypes, w != null && Pa();
            break;
          case 3:
            nc(), Un(Hr), Un(Ht), ph();
            break;
          case 5:
            fn(w);
            break;
          case 4:
            nc();
            break;
          case 13:
            Un(Lt);
            break;
          case 19:
            Un(Lt);
            break;
          case 10:
            Zl(w.type._context);
            break;
          case 22:
          case 23:
            bv();
        }
        m = m.return;
      }
    if (Dr = l, Vr = l = cc(l.current, null), ki = ia = u, fi = 0, Wf = null, gd = Lh = hl = 0, po = lu = null, Di !== null) {
      for (u = 0; u < Di.length; u++)
        if (m = Di[u], w = m.interleaved, w !== null) {
          m.interleaved = null;
          var P = w.next, M = m.pending;
          if (M !== null) {
            var H = M.next;
            M.next = P, w.next = H;
          }
          m.pending = w;
        }
      Di = null;
    }
    return l;
  }
  function L0(l, u) {
    do {
      var m = Vr;
      try {
        if (Gm(), hh.current = Rh, jt) {
          for (var w = yr.memoizedState; w !== null; ) {
            var P = w.queue;
            P !== null && (P.pending = null), w = w.next;
          }
          jt = !1;
        }
        if (Zc = 0, En = Ne = yr = null, Is = !1, ra = 0, gv.current = null, m === null || m.return === null) {
          fi = 1, Wf = u, Vr = null;
          break;
        }
        e: {
          var M = l, H = m.return, Q = m, ee = u;
          if (u = ki, Q.flags |= 32768, ee !== null && typeof ee == "object" && typeof ee.then == "function") {
            var Te = ee, Ve = Q, Ye = Ve.tag;
            if (!(Ve.mode & 1) && (Ye === 0 || Ye === 11 || Ye === 15)) {
              var He = Ve.alternate;
              He ? (Ve.updateQueue = He.updateQueue, Ve.memoizedState = He.memoizedState, Ve.lanes = He.lanes) : (Ve.updateQueue = null, Ve.memoizedState = null);
            }
            var lt = rv(H);
            if (lt !== null) {
              lt.flags &= -257, iv(lt, H, Q, M, u), lt.mode & 1 && _0(M, Te, u), u = lt, ee = Te;
              var gt = u.updateQueue;
              if (gt === null) {
                var wt = /* @__PURE__ */ new Set();
                wt.add(ee), u.updateQueue = wt;
              } else
                gt.add(ee);
              break e;
            } else {
              if (!(u & 1)) {
                _0(M, Te, u), Sv();
                break e;
              }
              ee = Error(n(426));
            }
          } else if (vr && Q.mode & 1) {
            var qr = rv(H);
            if (qr !== null) {
              !(qr.flags & 65536) && (qr.flags |= 256), iv(qr, H, Q, M, u), Km(sd(ee, Q));
              break e;
            }
          }
          M = ee = sd(ee, Q), fi !== 4 && (fi = 2), lu === null ? lu = [M] : lu.push(M), M = H;
          do {
            switch (M.tag) {
              case 3:
                M.flags |= 65536, u &= -u, M.lanes |= u;
                var ge = C0(M, ee, u);
                Qm(M, ge);
                break e;
              case 1:
                Q = ee;
                var oe = M.type, we = M.stateNode;
                if (!(M.flags & 128) && (typeof oe.getDerivedStateFromError == "function" || we !== null && typeof we.componentDidCatch == "function" && (Ms === null || !Ms.has(we)))) {
                  M.flags |= 65536, u &= -u, M.lanes |= u;
                  var Xe = zf(M, Q, u);
                  Qm(M, Xe);
                  break e;
                }
            }
            M = M.return;
          } while (M !== null);
        }
        wv(m);
      } catch (Ct) {
        u = Ct, Vr === m && m !== null && (Vr = m = m.return);
        continue;
      }
      break;
    } while (1);
  }
  function Bh() {
    var l = Kf.current;
    return Kf.current = Rh, l === null ? Rh : l;
  }
  function Sv() {
    (fi === 0 || fi === 3 || fi === 2) && (fi = 4), Dr === null || !(hl & 268435455) && !(Lh & 268435455) || Da(Dr, ki);
  }
  function Fh(l, u) {
    var m = mn;
    mn |= 2;
    var w = Bh();
    (Dr !== l || ki !== u) && (gl = null, fu(l, u));
    do
      try {
        hE();
        break;
      } catch (P) {
        L0(l, P);
      }
    while (1);
    if (Gm(), mn = m, Kf.current = w, Vr !== null)
      throw Error(n(261));
    return Dr = null, ki = 0, fi;
  }
  function hE() {
    for (; Vr !== null; )
      j0(Vr);
  }
  function gE() {
    for (; Vr !== null && !Ea(); )
      j0(Vr);
  }
  function j0(l) {
    var u = U0(l.alternate, l, ia);
    l.memoizedProps = l.pendingProps, u === null ? wv(l) : Vr = u, gv.current = null;
  }
  function wv(l) {
    var u = l;
    do {
      var m = u.alternate;
      if (l = u.return, u.flags & 32768) {
        if (m = dv(m, u), m !== null) {
          m.flags &= 32767, Vr = m;
          return;
        }
        if (l !== null)
          l.flags |= 32768, l.subtreeFlags = 0, l.deletions = null;
        else {
          fi = 6, Vr = null;
          return;
        }
      } else if (m = pE(m, u, ia), m !== null) {
        Vr = m;
        return;
      }
      if (u = u.sibling, u !== null) {
        Vr = u;
        return;
      }
      Vr = u = l;
    } while (u !== null);
    fi === 0 && (fi = 5);
  }
  function pu(l, u, m) {
    var w = hn, P = Zi.transition;
    try {
      Zi.transition = null, hn = 1, mE(l, u, m, w);
    } finally {
      Zi.transition = P, hn = w;
    }
    return null;
  }
  function mE(l, u, m, w) {
    do
      Sd();
    while (sc !== null);
    if (mn & 6)
      throw Error(n(327));
    m = l.finishedWork;
    var P = l.finishedLanes;
    if (m === null)
      return null;
    if (l.finishedWork = null, l.finishedLanes = 0, m === l.current)
      throw Error(n(177));
    l.callbackNode = null, l.callbackPriority = 0;
    var M = m.lanes | m.childLanes;
    if (gf(l, M), l === Dr && (Vr = Dr = null, ki = 0), !(m.subtreeFlags & 2064) && !(m.flags & 2064) || ac || (ac = !0, xv(Ca, function() {
      return Sd(), null;
    })), M = (m.flags & 15990) !== 0, m.subtreeFlags & 15990 || M) {
      M = Zi.transition, Zi.transition = null;
      var H = hn;
      hn = 1;
      var Q = mn;
      mn |= 4, gv.current = null, R0(l, m), M0(m, l), qp(Kc), ie = !!Nm, Kc = Nm = null, l.current = m, A0(m), jl(), mn = Q, hn = H, Zi.transition = M;
    } else
      l.current = m;
    if (ac && (ac = !1, sc = l, zh = P), M = l.pendingLanes, M === 0 && (Ms = null), jc(m.stateNode), to(l, bn()), u !== null)
      for (w = l.onRecoverableError, m = 0; m < u.length; m++)
        P = u[m], w(P.value, { componentStack: P.stack, digest: P.digest });
    if (jh)
      throw jh = !1, l = cu, cu = null, l;
    return zh & 1 && l.tag !== 0 && Sd(), M = l.pendingLanes, M & 1 ? l === Uh ? vd++ : (vd = 0, Uh = l) : vd = 0, Ao(), null;
  }
  function Sd() {
    if (sc !== null) {
      var l = Qo(zh), u = Zi.transition, m = hn;
      try {
        if (Zi.transition = null, hn = 16 > l ? 16 : l, sc === null)
          var w = !1;
        else {
          if (l = sc, sc = null, zh = 0, mn & 6)
            throw Error(n(331));
          var P = mn;
          for (mn |= 4, ft = l.current; ft !== null; ) {
            var M = ft, H = M.child;
            if (ft.flags & 16) {
              var Q = M.deletions;
              if (Q !== null) {
                for (var ee = 0; ee < Q.length; ee++) {
                  var Te = Q[ee];
                  for (ft = Te; ft !== null; ) {
                    var Ve = ft;
                    switch (Ve.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Vf(8, Ve, M);
                    }
                    var Ye = Ve.child;
                    if (Ye !== null)
                      Ye.return = Ve, ft = Ye;
                    else
                      for (; ft !== null; ) {
                        Ve = ft;
                        var He = Ve.sibling, lt = Ve.return;
                        if (pv(Ve), Ve === Te) {
                          ft = null;
                          break;
                        }
                        if (He !== null) {
                          He.return = lt, ft = He;
                          break;
                        }
                        ft = lt;
                      }
                  }
                }
                var gt = M.alternate;
                if (gt !== null) {
                  var wt = gt.child;
                  if (wt !== null) {
                    gt.child = null;
                    do {
                      var qr = wt.sibling;
                      wt.sibling = null, wt = qr;
                    } while (wt !== null);
                  }
                }
                ft = M;
              }
            }
            if (M.subtreeFlags & 2064 && H !== null)
              H.return = M, ft = H;
            else
              e:
                for (; ft !== null; ) {
                  if (M = ft, M.flags & 2048)
                    switch (M.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Vf(9, M, M.return);
                    }
                  var ge = M.sibling;
                  if (ge !== null) {
                    ge.return = M.return, ft = ge;
                    break e;
                  }
                  ft = M.return;
                }
          }
          var oe = l.current;
          for (ft = oe; ft !== null; ) {
            H = ft;
            var we = H.child;
            if (H.subtreeFlags & 2064 && we !== null)
              we.return = H, ft = we;
            else
              e:
                for (H = oe; ft !== null; ) {
                  if (Q = ft, Q.flags & 2048)
                    try {
                      switch (Q.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Yf(9, Q);
                      }
                    } catch (Ct) {
                      Yr(Q, Q.return, Ct);
                    }
                  if (Q === H) {
                    ft = null;
                    break e;
                  }
                  var Xe = Q.sibling;
                  if (Xe !== null) {
                    Xe.return = Q.return, ft = Xe;
                    break e;
                  }
                  ft = Q.return;
                }
          }
          if (mn = P, Ao(), Wi && typeof Wi.onPostCommitFiberRoot == "function")
            try {
              Wi.onPostCommitFiberRoot(Ss, l);
            } catch {
            }
          w = !0;
        }
        return w;
      } finally {
        hn = m, Zi.transition = u;
      }
    }
    return !1;
  }
  function z0(l, u, m) {
    u = sd(m, u), u = C0(l, u, 1), l = ec(l, u, 1), u = Ji(), l !== null && (Za(l, 1, u), to(l, u));
  }
  function Yr(l, u, m) {
    if (l.tag === 3)
      z0(l, l, m);
    else
      for (; u !== null; ) {
        if (u.tag === 3) {
          z0(u, l, m);
          break;
        } else if (u.tag === 1) {
          var w = u.stateNode;
          if (typeof u.type.getDerivedStateFromError == "function" || typeof w.componentDidCatch == "function" && (Ms === null || !Ms.has(w))) {
            l = sd(m, l), l = zf(u, l, 1), u = ec(u, l, 1), l = Ji(), u !== null && (Za(u, 1, l), to(u, l));
            break;
          }
        }
        u = u.return;
      }
  }
  function vE(l, u, m) {
    var w = l.pingCache;
    w !== null && w.delete(u), u = Ji(), l.pingedLanes |= l.suspendedLanes & m, Dr === l && (ki & m) === m && (fi === 4 || fi === 3 && (ki & 130023424) === ki && 500 > bn() - mv ? fu(l, 0) : gd |= m), to(l, u);
  }
  function Hh(l, u) {
    u === 0 && (l.mode & 1 ? (u = Po, Po <<= 1, !(Po & 130023424) && (Po = 4194304)) : u = 1);
    var m = Ji();
    l = cl(l, u), l !== null && (Za(l, u, m), to(l, m));
  }
  function yE(l) {
    var u = l.memoizedState, m = 0;
    u !== null && (m = u.retryLane), Hh(l, m);
  }
  function bE(l, u) {
    var m = 0;
    switch (l.tag) {
      case 13:
        var w = l.stateNode, P = l.memoizedState;
        P !== null && (m = P.retryLane);
        break;
      case 19:
        w = l.stateNode;
        break;
      default:
        throw Error(n(314));
    }
    w !== null && w.delete(u), Hh(l, m);
  }
  var U0;
  U0 = function(l, u, m) {
    if (l !== null)
      if (l.memoizedProps !== u.pendingProps || Hr.current)
        ii = !0;
      else {
        if (!(l.lanes & m) && !(u.flags & 128))
          return ii = !1, fl(l, u, m);
        ii = !!(l.flags & 131072);
      }
    else
      ii = !1, vr && u.flags & 1048576 && Hm(u, ed, u.index);
    switch (u.lanes = 0, u.tag) {
      case 2:
        var w = u.type;
        qi(l, u), l = u.pendingProps;
        var P = ka(u, Ht.current);
        tt(u, m), P = rc(null, u, w, l, P, m);
        var M = tu();
        return u.flags |= 1, typeof P == "object" && P !== null && typeof P.render == "function" && P.$$typeof === void 0 ? (u.tag = 1, u.memoizedState = null, u.updateQueue = null, kr(w) ? (M = !0, nh(u)) : M = !1, u.memoizedState = P.state !== null && P.state !== void 0 ? P.state : null, qm(u), P.updater = uh, u.stateNode = P, P._reactInternals = u, dh(u, w, l, m), u = T0(null, u, w, !0, M, m)) : (u.tag = 0, vr && M && rh(u), li(null, u, P, m), u = u.child), u;
      case 16:
        w = u.elementType;
        e: {
          switch (qi(l, u), l = u.pendingProps, P = w._init, w = P(w._payload), u.type = w, P = u.tag = wE(w), l = na(w, l), P) {
            case 0:
              u = ld(null, u, w, l, m);
              break e;
            case 1:
              u = ov(null, u, w, l, m);
              break e;
            case 11:
              u = oc(null, u, w, l, m);
              break e;
            case 14:
              u = Mh(null, u, w, na(w.type, l), m);
              break e;
          }
          throw Error(n(
            306,
            w,
            ""
          ));
        }
        return u;
      case 0:
        return w = u.type, P = u.pendingProps, P = u.elementType === w ? P : na(w, P), ld(l, u, w, P, m);
      case 1:
        return w = u.type, P = u.pendingProps, P = u.elementType === w ? P : na(w, P), ov(l, u, w, P, m);
      case 3:
        e: {
          if (k0(u), l === null)
            throw Error(n(387));
          w = u.pendingProps, M = u.memoizedState, P = M.element, si(l, u), tc(u, w, null, m);
          var H = u.memoizedState;
          if (w = H.element, M.isDehydrated)
            if (M = { element: w, isDehydrated: !1, cache: H.cache, pendingSuspenseBoundaries: H.pendingSuspenseBoundaries, transitions: H.transitions }, u.updateQueue.baseState = M, u.memoizedState = M, u.flags & 256) {
              P = sd(Error(n(423)), u), u = Ah(l, u, w, m, P);
              break e;
            } else if (w !== P) {
              P = sd(Error(n(424)), u), u = Ah(l, u, w, m, P);
              break e;
            } else
              for (No = rs(u.stateNode.containerInfo.firstChild), ta = u, vr = !0, Ra = null, m = x0(u, null, w, m), u.child = m; m; )
                m.flags = m.flags & -3 | 4096, m = m.sibling;
          else {
            if (Ar(), w === P) {
              u = Ni(l, u, m);
              break e;
            }
            li(l, u, w, m);
          }
          u = u.child;
        }
        return u;
      case 5:
        return Dt(u), l === null && oh(u), w = u.type, P = u.pendingProps, M = l !== null ? l.memoizedProps : null, H = P.children, kf(w, P) ? H = null : M !== null && kf(w, M) && (u.flags |= 32), an(l, u), li(l, u, H, m), u.child;
      case 6:
        return l === null && oh(u), null;
      case 13:
        return sv(l, u, m);
      case 4:
        return Jm(u, u.stateNode.containerInfo), w = u.pendingProps, l === null ? u.child = nd(u, null, w, m) : li(l, u, w, m), u.child;
      case 11:
        return w = u.type, P = u.pendingProps, P = u.elementType === w ? P : na(w, P), oc(l, u, w, P, m);
      case 7:
        return li(l, u, u.pendingProps, m), u.child;
      case 8:
        return li(l, u, u.pendingProps.children, m), u.child;
      case 12:
        return li(l, u, u.pendingProps.children, m), u.child;
      case 10:
        e: {
          if (w = u.type._context, P = u.pendingProps, M = u.memoizedProps, H = P.value, Vn(Ps, w._currentValue), w._currentValue = H, M !== null)
            if (_a(M.value, H)) {
              if (M.children === P.children && !Hr.current) {
                u = Ni(l, u, m);
                break e;
              }
            } else
              for (M = u.child, M !== null && (M.return = u); M !== null; ) {
                var Q = M.dependencies;
                if (Q !== null) {
                  H = M.child;
                  for (var ee = Q.firstContext; ee !== null; ) {
                    if (ee.context === w) {
                      if (M.tag === 1) {
                        ee = ul(-1, m & -m), ee.tag = 2;
                        var Te = M.updateQueue;
                        if (Te !== null) {
                          Te = Te.shared;
                          var Ve = Te.pending;
                          Ve === null ? ee.next = ee : (ee.next = Ve.next, Ve.next = ee), Te.pending = ee;
                        }
                      }
                      M.lanes |= m, ee = M.alternate, ee !== null && (ee.lanes |= m), _i(
                        M.return,
                        m,
                        u
                      ), Q.lanes |= m;
                      break;
                    }
                    ee = ee.next;
                  }
                } else if (M.tag === 10)
                  H = M.type === u.type ? null : M.child;
                else if (M.tag === 18) {
                  if (H = M.return, H === null)
                    throw Error(n(341));
                  H.lanes |= m, Q = H.alternate, Q !== null && (Q.lanes |= m), _i(H, m, u), H = M.sibling;
                } else
                  H = M.child;
                if (H !== null)
                  H.return = M;
                else
                  for (H = M; H !== null; ) {
                    if (H === u) {
                      H = null;
                      break;
                    }
                    if (M = H.sibling, M !== null) {
                      M.return = H.return, H = M;
                      break;
                    }
                    H = H.return;
                  }
                M = H;
              }
          li(l, u, P.children, m), u = u.child;
        }
        return u;
      case 9:
        return P = u.type, w = u.pendingProps.children, tt(u, m), P = Xr(P), w = w(P), u.flags |= 1, li(l, u, w, m), u.child;
      case 14:
        return w = u.type, P = na(w, u.pendingProps), P = na(w.type, P), Mh(l, u, w, P, m);
      case 15:
        return zo(l, u, u.type, u.pendingProps, m);
      case 17:
        return w = u.type, P = u.pendingProps, P = u.elementType === w ? P : na(w, P), qi(l, u), u.tag = 1, kr(w) ? (l = !0, nh(u)) : l = !1, tt(u, m), y0(u, w, P), dh(u, w, P, m), T0(null, u, w, !0, l, m);
      case 19:
        return uv(l, u, m);
      case 22:
        return ou(l, u, m);
    }
    throw Error(n(156, u.tag));
  };
  function xv(l, u) {
    return Zn(l, u);
  }
  function SE(l, u, m, w) {
    this.tag = l, this.key = m, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = u, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = w, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Na(l, u, m, w) {
    return new SE(l, u, m, w);
  }
  function Ev(l) {
    return l = l.prototype, !(!l || !l.isReactComponent);
  }
  function wE(l) {
    if (typeof l == "function")
      return Ev(l) ? 1 : 0;
    if (l != null) {
      if (l = l.$$typeof, l === Pe)
        return 11;
      if (l === le)
        return 14;
    }
    return 2;
  }
  function cc(l, u) {
    var m = l.alternate;
    return m === null ? (m = Na(l.tag, u, l.key, l.mode), m.elementType = l.elementType, m.type = l.type, m.stateNode = l.stateNode, m.alternate = l, l.alternate = m) : (m.pendingProps = u, m.type = l.type, m.flags = 0, m.subtreeFlags = 0, m.deletions = null), m.flags = l.flags & 14680064, m.childLanes = l.childLanes, m.lanes = l.lanes, m.child = l.child, m.memoizedProps = l.memoizedProps, m.memoizedState = l.memoizedState, m.updateQueue = l.updateQueue, u = l.dependencies, m.dependencies = u === null ? null : { lanes: u.lanes, firstContext: u.firstContext }, m.sibling = l.sibling, m.index = l.index, m.ref = l.ref, m;
  }
  function Vh(l, u, m, w, P, M) {
    var H = 2;
    if (w = l, typeof l == "function")
      Ev(l) && (H = 1);
    else if (typeof l == "string")
      H = 5;
    else
      e:
        switch (l) {
          case K:
            return hu(m.children, P, M, u);
          case X:
            H = 8, P |= 8;
            break;
          case se:
            return l = Na(12, m, u, P | 2), l.elementType = se, l.lanes = M, l;
          case ve:
            return l = Na(13, m, u, P), l.elementType = ve, l.lanes = M, l;
          case Y:
            return l = Na(19, m, u, P), l.elementType = Y, l.lanes = M, l;
          case he:
            return Xf(m, P, M, u);
          default:
            if (typeof l == "object" && l !== null)
              switch (l.$$typeof) {
                case ue:
                  H = 10;
                  break e;
                case pe:
                  H = 9;
                  break e;
                case Pe:
                  H = 11;
                  break e;
                case le:
                  H = 14;
                  break e;
                case Re:
                  H = 16, w = null;
                  break e;
              }
            throw Error(n(130, l == null ? l : typeof l, ""));
        }
    return u = Na(H, m, u, P), u.elementType = l, u.type = w, u.lanes = M, u;
  }
  function hu(l, u, m, w) {
    return l = Na(7, l, w, u), l.lanes = m, l;
  }
  function Xf(l, u, m, w) {
    return l = Na(22, l, w, u), l.elementType = he, l.lanes = m, l.stateNode = { isHidden: !1 }, l;
  }
  function qf(l, u, m) {
    return l = Na(6, l, null, u), l.lanes = m, l;
  }
  function gu(l, u, m) {
    return u = Na(4, l.children !== null ? l.children : [], l.key, u), u.lanes = m, u.stateNode = { containerInfo: l.containerInfo, pendingChildren: null, implementation: l.implementation }, u;
  }
  function xE(l, u, m, w, P) {
    this.tag = u, this.containerInfo = l, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Zs(0), this.expirationTimes = Zs(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Zs(0), this.identifierPrefix = w, this.onRecoverableError = P, this.mutableSourceEagerHydrationData = null;
  }
  function Yh(l, u, m, w, P, M, H, Q, ee) {
    return l = new xE(l, u, m, Q, ee), u === 1 ? (u = 1, M === !0 && (u |= 8)) : u = 0, M = Na(3, null, null, u), l.current = M, M.stateNode = l, M.memoizedState = { element: w, isDehydrated: m, cache: null, transitions: null, pendingSuspenseBoundaries: null }, qm(M), l;
  }
  function B0(l, u, m) {
    var w = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: F, key: w == null ? null : "" + w, children: l, containerInfo: u, implementation: m };
  }
  function Cv(l) {
    if (!l)
      return ks;
    l = l._reactInternals;
    e: {
      if (Kt(l) !== l || l.tag !== 1)
        throw Error(n(170));
      var u = l;
      do {
        switch (u.tag) {
          case 3:
            u = u.stateNode.context;
            break e;
          case 1:
            if (kr(u.type)) {
              u = u.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        u = u.return;
      } while (u !== null);
      throw Error(n(171));
    }
    if (l.tag === 1) {
      var m = l.type;
      if (kr(m))
        return Rf(l, m, u);
    }
    return u;
  }
  function F0(l, u, m, w, P, M, H, Q, ee) {
    return l = Yh(m, w, !0, l, P, M, H, Q, ee), l.context = Cv(null), m = l.current, w = Ji(), P = oi(m), M = ul(w, P), M.callback = u ?? null, ec(m, M, P), l.current.lanes = P, Za(l, P, w), to(l, w), l;
  }
  function Qf(l, u, m, w) {
    var P = u.current, M = Ji(), H = oi(P);
    return m = Cv(m), u.context === null ? u.context = m : u.pendingContext = m, u = ul(M, H), u.payload = { element: l }, w = w === void 0 ? null : w, w !== null && (u.callback = w), l = ec(P, u, H), l !== null && (eo(l, P, H, M), ch(l, P, H)), H;
  }
  function Kh(l) {
    if (l = l.current, !l.child)
      return null;
    switch (l.child.tag) {
      case 5:
        return l.child.stateNode;
      default:
        return l.child.stateNode;
    }
  }
  function H0(l, u) {
    if (l = l.memoizedState, l !== null && l.dehydrated !== null) {
      var m = l.retryLane;
      l.retryLane = m !== 0 && m < u ? m : u;
    }
  }
  function _v(l, u) {
    H0(l, u), (l = l.alternate) && H0(l, u);
  }
  function V0() {
    return null;
  }
  var Tv = typeof reportError == "function" ? reportError : function(l) {
    console.error(l);
  };
  function Wh(l) {
    this._internalRoot = l;
  }
  ml.prototype.render = Wh.prototype.render = function(l) {
    var u = this._internalRoot;
    if (u === null)
      throw Error(n(409));
    Qf(l, u, null, null);
  }, ml.prototype.unmount = Wh.prototype.unmount = function() {
    var l = this._internalRoot;
    if (l !== null) {
      this._internalRoot = null;
      var u = l.containerInfo;
      lc(function() {
        Qf(null, l, null, null);
      }), u[sl] = null;
    }
  };
  function ml(l) {
    this._internalRoot = l;
  }
  ml.prototype.unstable_scheduleHydration = function(l) {
    if (l) {
      var u = Fl();
      l = { blockedOn: null, target: l, priority: u };
      for (var m = 0; m < Nn.length && u !== 0 && u < Nn[m].priority; m++)
        ;
      Nn.splice(m, 0, l), m === 0 && Bc(l);
    }
  };
  function kv(l) {
    return !(!l || l.nodeType !== 1 && l.nodeType !== 9 && l.nodeType !== 11);
  }
  function Gh(l) {
    return !(!l || l.nodeType !== 1 && l.nodeType !== 9 && l.nodeType !== 11 && (l.nodeType !== 8 || l.nodeValue !== " react-mount-point-unstable "));
  }
  function Y0() {
  }
  function EE(l, u, m, w, P) {
    if (P) {
      if (typeof w == "function") {
        var M = w;
        w = function() {
          var Te = Kh(H);
          M.call(Te);
        };
      }
      var H = F0(u, w, l, 0, null, !1, !1, "", Y0);
      return l._reactRootContainer = H, l[sl] = H.current, Zu(l.nodeType === 8 ? l.parentNode : l), lc(), H;
    }
    for (; P = l.lastChild; )
      l.removeChild(P);
    if (typeof w == "function") {
      var Q = w;
      w = function() {
        var Te = Kh(ee);
        Q.call(Te);
      };
    }
    var ee = Yh(l, 0, !1, null, null, !1, !1, "", Y0);
    return l._reactRootContainer = ee, l[sl] = ee.current, Zu(l.nodeType === 8 ? l.parentNode : l), lc(function() {
      Qf(u, ee, m, w);
    }), ee;
  }
  function Xh(l, u, m, w, P) {
    var M = m._reactRootContainer;
    if (M) {
      var H = M;
      if (typeof P == "function") {
        var Q = P;
        P = function() {
          var ee = Kh(H);
          Q.call(ee);
        };
      }
      Qf(u, H, l, P);
    } else
      H = EE(m, u, l, P, w);
    return Kh(H);
  }
  Js = function(l) {
    switch (l.tag) {
      case 3:
        var u = l.stateNode;
        if (u.current.memoizedState.isDehydrated) {
          var m = Io(u.pendingLanes);
          m !== 0 && (qo(u, m | 1), to(u, bn()), !(mn & 6) && (md = bn() + 500, Ao()));
        }
        break;
      case 13:
        lc(function() {
          var w = cl(l, 1);
          if (w !== null) {
            var P = Ji();
            eo(w, l, 1, P);
          }
        }), _v(l, 1);
    }
  }, Bl = function(l) {
    if (l.tag === 13) {
      var u = cl(l, 134217728);
      if (u !== null) {
        var m = Ji();
        eo(u, l, 134217728, m);
      }
      _v(l, 134217728);
    }
  }, rn = function(l) {
    if (l.tag === 13) {
      var u = oi(l), m = cl(l, u);
      if (m !== null) {
        var w = Ji();
        eo(m, l, u, w);
      }
      _v(l, u);
    }
  }, Fl = function() {
    return hn;
  }, Hl = function(l, u) {
    var m = hn;
    try {
      return hn = l, u();
    } finally {
      hn = m;
    }
  }, vi = function(l, u, m) {
    switch (u) {
      case "input":
        if (kt(l, m), u = m.name, m.type === "radio" && u != null) {
          for (m = l; m.parentNode; )
            m = m.parentNode;
          for (m = m.querySelectorAll("input[name=" + JSON.stringify("" + u) + '][type="radio"]'), u = 0; u < m.length; u++) {
            var w = m[u];
            if (w !== l && w.form === l.form) {
              var P = Mt(w);
              if (!P)
                throw Error(n(90));
              Le(w), kt(w, P);
            }
          }
        }
        break;
      case "textarea":
        xt(l, m);
        break;
      case "select":
        u = m.value, u != null && Mr(l, !!m.multiple, u, !1);
    }
  }, Qa = bd, vs = lc;
  var CE = { usingClientEntryPoint: !1, Events: [If, Ju, Mt, yi, Sa, bd] }, wd = { findFiberByHostInstance: Ta, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, _E = { bundleType: wd.bundleType, version: wd.version, rendererPackageName: wd.rendererPackageName, rendererConfig: wd.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: L.ReactCurrentDispatcher, findHostInstanceByFiber: function(l) {
    return l = Br(l), l === null ? null : l.stateNode;
  }, findFiberByHostInstance: wd.findFiberByHostInstance || V0, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var qh = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!qh.isDisabled && qh.supportsFiber)
      try {
        Ss = qh.inject(_E), Wi = qh;
      } catch {
      }
  }
  return Ha.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = CE, Ha.createPortal = function(l, u) {
    var m = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!kv(u))
      throw Error(n(200));
    return B0(l, u, null, m);
  }, Ha.createRoot = function(l, u) {
    if (!kv(l))
      throw Error(n(299));
    var m = !1, w = "", P = Tv;
    return u != null && (u.unstable_strictMode === !0 && (m = !0), u.identifierPrefix !== void 0 && (w = u.identifierPrefix), u.onRecoverableError !== void 0 && (P = u.onRecoverableError)), u = Yh(l, 1, !1, null, null, m, !1, w, P), l[sl] = u.current, Zu(l.nodeType === 8 ? l.parentNode : l), new Wh(u);
  }, Ha.findDOMNode = function(l) {
    if (l == null)
      return null;
    if (l.nodeType === 1)
      return l;
    var u = l._reactInternals;
    if (u === void 0)
      throw typeof l.render == "function" ? Error(n(188)) : (l = Object.keys(l).join(","), Error(n(268, l)));
    return l = Br(u), l = l === null ? null : l.stateNode, l;
  }, Ha.flushSync = function(l) {
    return lc(l);
  }, Ha.hydrate = function(l, u, m) {
    if (!Gh(u))
      throw Error(n(200));
    return Xh(null, l, u, !0, m);
  }, Ha.hydrateRoot = function(l, u, m) {
    if (!kv(l))
      throw Error(n(405));
    var w = m != null && m.hydratedSources || null, P = !1, M = "", H = Tv;
    if (m != null && (m.unstable_strictMode === !0 && (P = !0), m.identifierPrefix !== void 0 && (M = m.identifierPrefix), m.onRecoverableError !== void 0 && (H = m.onRecoverableError)), u = F0(u, null, l, 1, m ?? null, P, !1, M, H), l[sl] = u.current, Zu(l), w)
      for (l = 0; l < w.length; l++)
        m = w[l], P = m._getVersion, P = P(m._source), u.mutableSourceEagerHydrationData == null ? u.mutableSourceEagerHydrationData = [m, P] : u.mutableSourceEagerHydrationData.push(
          m,
          P
        );
    return new ml(u);
  }, Ha.render = function(l, u, m) {
    if (!Gh(u))
      throw Error(n(200));
    return Xh(null, l, u, !1, m);
  }, Ha.unmountComponentAtNode = function(l) {
    if (!Gh(l))
      throw Error(n(40));
    return l._reactRootContainer ? (lc(function() {
      Xh(null, null, l, !1, function() {
        l._reactRootContainer = null, l[sl] = null;
      });
    }), !0) : !1;
  }, Ha.unstable_batchedUpdates = bd, Ha.unstable_renderSubtreeIntoContainer = function(l, u, m, w) {
    if (!Gh(m))
      throw Error(n(200));
    if (l == null || l._reactInternals === void 0)
      throw Error(n(38));
    return Xh(l, u, m, !1, w);
  }, Ha.version = "18.2.0-next-9e3b772b8-20220608", Ha;
}
var Va = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JD;
function _ie() {
  return JD || (JD = 1, {}.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = k, e = Hj(), n = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, r = !1;
    function a(i) {
      r = i;
    }
    function s(i) {
      if (!r) {
        for (var o = arguments.length, d = new Array(o > 1 ? o - 1 : 0), h = 1; h < o; h++)
          d[h - 1] = arguments[h];
        f("warn", i, d);
      }
    }
    function c(i) {
      if (!r) {
        for (var o = arguments.length, d = new Array(o > 1 ? o - 1 : 0), h = 1; h < o; h++)
          d[h - 1] = arguments[h];
        f("error", i, d);
      }
    }
    function f(i, o, d) {
      {
        var h = n.ReactDebugCurrentFrame, b = h.getStackAddendum();
        b !== "" && (o += "%s", d = d.concat([b]));
        var C = d.map(function(R) {
          return String(R);
        });
        C.unshift("Warning: " + o), Function.prototype.apply.call(console[i], console, C);
      }
    }
    var p = 0, g = 1, y = 2, v = 3, S = 4, x = 5, _ = 6, T = 7, I = 8, D = 9, N = 10, j = 11, L = 12, z = 13, F = 14, K = 15, X = 16, se = 17, ue = 18, pe = 19, Pe = 21, ve = 22, Y = 23, le = 24, Re = 25, he = !0, te = !1, de = !1, W = !1, fe = !1, ce = !0, xe = !1, $e = !1, Me = !0, re = !0, Qe = !0, ke = /* @__PURE__ */ new Set(), rt = {}, St = {};
    function Tt(i, o) {
      Le(i, o), Le(i + "Capture", o);
    }
    function Le(i, o) {
      rt[i] && c("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", i), rt[i] = o;
      {
        var d = i.toLowerCase();
        St[d] = i, i === "onDoubleClick" && (St.ondblclick = i);
      }
      for (var h = 0; h < o.length; h++)
        ke.add(o[h]);
    }
    var Nt = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Ke = Object.prototype.hasOwnProperty;
    function yt(i) {
      {
        var o = typeof Symbol == "function" && Symbol.toStringTag, d = o && i[Symbol.toStringTag] || i.constructor.name || "Object";
        return d;
      }
    }
    function Xt(i) {
      try {
        return kt(i), !1;
      } catch {
        return !0;
      }
    }
    function kt(i) {
      return "" + i;
    }
    function yn(i, o) {
      if (Xt(i))
        return c("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", o, yt(i)), kt(i);
    }
    function Er(i) {
      if (Xt(i))
        return c("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", yt(i)), kt(i);
    }
    function tn(i, o) {
      if (Xt(i))
        return c("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", o, yt(i)), kt(i);
    }
    function Mr(i, o) {
      if (Xt(i))
        return c("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", o, yt(i)), kt(i);
    }
    function Ur(i) {
      if (Xt(i))
        return c("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", yt(i)), kt(i);
    }
    function Hn(i) {
      if (Xt(i))
        return c("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", yt(i)), kt(i);
    }
    var xt = 0, cn = 1, ni = 2, An = 3, qn = 4, Go = 5, Cr = 6, Je = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Et = Je + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", nn = new RegExp("^[" + Je + "][" + Et + "]*$"), kn = {}, xn = {};
    function _r(i) {
      return Ke.call(xn, i) ? !0 : Ke.call(kn, i) ? !1 : nn.test(i) ? (xn[i] = !0, !0) : (kn[i] = !0, c("Invalid attribute name: `%s`", i), !1);
    }
    function ur(i, o, d) {
      return o !== null ? o.type === xt : d ? !1 : i.length > 2 && (i[0] === "o" || i[0] === "O") && (i[1] === "n" || i[1] === "N");
    }
    function mi(i, o, d, h) {
      if (d !== null && d.type === xt)
        return !1;
      switch (typeof o) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (h)
            return !1;
          if (d !== null)
            return !d.acceptsBooleans;
          var b = i.toLowerCase().slice(0, 5);
          return b !== "data-" && b !== "aria-";
        }
        default:
          return !1;
      }
    }
    function pn(i, o, d, h) {
      if (o === null || typeof o > "u" || mi(i, o, d, h))
        return !0;
      if (h)
        return !1;
      if (d !== null)
        switch (d.type) {
          case An:
            return !o;
          case qn:
            return o === !1;
          case Go:
            return isNaN(o);
          case Cr:
            return isNaN(o) || o < 1;
        }
      return !1;
    }
    function vi(i) {
      return Dn.hasOwnProperty(i) ? Dn[i] : null;
    }
    function On(i, o, d, h, b, C, R) {
      this.acceptsBooleans = o === ni || o === An || o === qn, this.attributeName = h, this.attributeNamespace = b, this.mustUseProperty = d, this.propertyName = i, this.type = o, this.sanitizeURL = C, this.removeEmptyString = R;
    }
    var Dn = {}, ao = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    ao.forEach(function(i) {
      Dn[i] = new On(
        i,
        xt,
        !1,
        // mustUseProperty
        i,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(i) {
      var o = i[0], d = i[1];
      Dn[o] = new On(
        o,
        cn,
        !1,
        // mustUseProperty
        d,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(i) {
      Dn[i] = new On(
        i,
        ni,
        !1,
        // mustUseProperty
        i.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(i) {
      Dn[i] = new On(
        i,
        ni,
        !1,
        // mustUseProperty
        i,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(i) {
      Dn[i] = new On(
        i,
        An,
        !1,
        // mustUseProperty
        i.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(i) {
      Dn[i] = new On(
        i,
        An,
        !0,
        // mustUseProperty
        i,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(i) {
      Dn[i] = new On(
        i,
        qn,
        !1,
        // mustUseProperty
        i,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(i) {
      Dn[i] = new On(
        i,
        Cr,
        !1,
        // mustUseProperty
        i,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(i) {
      Dn[i] = new On(
        i,
        Go,
        !1,
        // mustUseProperty
        i.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var yi = /[\-\:]([a-z])/g, Sa = function(i) {
      return i[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(i) {
      var o = i.replace(yi, Sa);
      Dn[o] = new On(
        o,
        cn,
        !1,
        // mustUseProperty
        i,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(i) {
      var o = i.replace(yi, Sa);
      Dn[o] = new On(
        o,
        cn,
        !1,
        // mustUseProperty
        i,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(i) {
      var o = i.replace(yi, Sa);
      Dn[o] = new On(
        o,
        cn,
        !1,
        // mustUseProperty
        i,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(i) {
      Dn[i] = new On(
        i,
        cn,
        !1,
        // mustUseProperty
        i.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Qa = "xlinkHref";
    Dn[Qa] = new On(
      "xlinkHref",
      cn,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(i) {
      Dn[i] = new On(
        i,
        cn,
        !1,
        // mustUseProperty
        i.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var vs = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, so = !1;
    function ys(i) {
      !so && vs.test(i) && (so = !0, c("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(i)));
    }
    function lo(i, o, d, h) {
      if (h.mustUseProperty) {
        var b = h.propertyName;
        return i[b];
      } else {
        yn(d, o), h.sanitizeURL && ys("" + d);
        var C = h.attributeName, R = null;
        if (h.type === qn) {
          if (i.hasAttribute(C)) {
            var A = i.getAttribute(C);
            return A === "" ? !0 : pn(o, d, h, !1) ? A : A === "" + d ? d : A;
          }
        } else if (i.hasAttribute(C)) {
          if (pn(o, d, h, !1))
            return i.getAttribute(C);
          if (h.type === An)
            return d;
          R = i.getAttribute(C);
        }
        return pn(o, d, h, !1) ? R === null ? d : R : R === "" + d ? d : R;
      }
    }
    function wa(i, o, d, h) {
      {
        if (!_r(o))
          return;
        if (!i.hasAttribute(o))
          return d === void 0 ? void 0 : null;
        var b = i.getAttribute(o);
        return yn(d, o), b === "" + d ? d : b;
      }
    }
    function co(i, o, d, h) {
      var b = vi(o);
      if (!ur(o, b, h)) {
        if (pn(o, d, b, h) && (d = null), h || b === null) {
          if (_r(o)) {
            var C = o;
            d === null ? i.removeAttribute(C) : (yn(d, o), i.setAttribute(C, "" + d));
          }
          return;
        }
        var R = b.mustUseProperty;
        if (R) {
          var A = b.propertyName;
          if (d === null) {
            var B = b.type;
            i[A] = B === An ? !1 : "";
          } else
            i[A] = d;
          return;
        }
        var V = b.attributeName, G = b.attributeNamespace;
        if (d === null)
          i.removeAttribute(V);
        else {
          var ae = b.type, ne;
          ae === An || ae === qn && d === !0 ? ne = "" : (yn(d, V), ne = "" + d, b.sanitizeURL && ys(ne.toString())), G ? i.setAttributeNS(G, V, ne) : i.setAttribute(V, ne);
        }
      }
    }
    var xa = Symbol.for("react.element"), bi = Symbol.for("react.portal"), Mi = Symbol.for("react.fragment"), Si = Symbol.for("react.strict_mode"), J = Symbol.for("react.profiler"), Be = Symbol.for("react.provider"), et = Symbol.for("react.context"), st = Symbol.for("react.forward_ref"), Kt = Symbol.for("react.suspense"), qt = Symbol.for("react.suspense_list"), Qt = Symbol.for("react.memo"), Rt = Symbol.for("react.lazy"), Br = Symbol.for("react.scope"), Qn = Symbol.for("react.debug_trace_mode"), Zn = Symbol.for("react.offscreen"), hr = Symbol.for("react.legacy_hidden"), Ea = Symbol.for("react.cache"), jl = Symbol.for("react.tracing_marker"), bn = Symbol.iterator, hf = "@@iterator";
    function Xo(i) {
      if (i === null || typeof i != "object")
        return null;
      var o = bn && i[bn] || i[hf];
      return typeof o == "function" ? o : null;
    }
    var Jt = Object.assign, Ca = 0, bs, uo, Ss, Wi, jc, Ai, zc;
    function Uc() {
    }
    Uc.__reactDisabledLog = !0;
    function Qs() {
      {
        if (Ca === 0) {
          bs = console.log, uo = console.info, Ss = console.warn, Wi = console.error, jc = console.group, Ai = console.groupCollapsed, zc = console.groupEnd;
          var i = {
            configurable: !0,
            enumerable: !0,
            value: Uc,
            writable: !0
          };
          Object.defineProperties(console, {
            info: i,
            log: i,
            warn: i,
            error: i,
            group: i,
            groupCollapsed: i,
            groupEnd: i
          });
        }
        Ca++;
      }
    }
    function zl() {
      {
        if (Ca--, Ca === 0) {
          var i = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Jt({}, i, {
              value: bs
            }),
            info: Jt({}, i, {
              value: uo
            }),
            warn: Jt({}, i, {
              value: Ss
            }),
            error: Jt({}, i, {
              value: Wi
            }),
            group: Jt({}, i, {
              value: jc
            }),
            groupCollapsed: Jt({}, i, {
              value: Ai
            }),
            groupEnd: Jt({}, i, {
              value: zc
            })
          });
        }
        Ca < 0 && c("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Po = n.ReactCurrentDispatcher, Io;
    function wi(i, o, d) {
      {
        if (Io === void 0)
          try {
            throw Error();
          } catch (b) {
            var h = b.stack.trim().match(/\n( *(at )?)/);
            Io = h && h[1] || "";
          }
        return `
` + Io + i;
      }
    }
    var ws = !1, xs;
    {
      var Es = typeof WeakMap == "function" ? WeakMap : Map;
      xs = new Es();
    }
    function Ul(i, o) {
      if (!i || ws)
        return "";
      {
        var d = xs.get(i);
        if (d !== void 0)
          return d;
      }
      var h;
      ws = !0;
      var b = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var C;
      C = Po.current, Po.current = null, Qs();
      try {
        if (o) {
          var R = function() {
            throw Error();
          };
          if (Object.defineProperty(R.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(R, []);
            } catch (_e) {
              h = _e;
            }
            Reflect.construct(i, [], R);
          } else {
            try {
              R.call();
            } catch (_e) {
              h = _e;
            }
            i.call(R.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (_e) {
            h = _e;
          }
          i();
        }
      } catch (_e) {
        if (_e && h && typeof _e.stack == "string") {
          for (var A = _e.stack.split(`
`), B = h.stack.split(`
`), V = A.length - 1, G = B.length - 1; V >= 1 && G >= 0 && A[V] !== B[G]; )
            G--;
          for (; V >= 1 && G >= 0; V--, G--)
            if (A[V] !== B[G]) {
              if (V !== 1 || G !== 1)
                do
                  if (V--, G--, G < 0 || A[V] !== B[G]) {
                    var ae = `
` + A[V].replace(" at new ", " at ");
                    return i.displayName && ae.includes("<anonymous>") && (ae = ae.replace("<anonymous>", i.displayName)), typeof i == "function" && xs.set(i, ae), ae;
                  }
                while (V >= 1 && G >= 0);
              break;
            }
        }
      } finally {
        ws = !1, Po.current = C, zl(), Error.prepareStackTrace = b;
      }
      var ne = i ? i.displayName || i.name : "", Ce = ne ? wi(ne) : "";
      return typeof i == "function" && xs.set(i, Ce), Ce;
    }
    function Zs(i, o, d) {
      return Ul(i, !0);
    }
    function Za(i, o, d) {
      return Ul(i, !1);
    }
    function gf(i) {
      var o = i.prototype;
      return !!(o && o.isReactComponent);
    }
    function qo(i, o, d) {
      if (i == null)
        return "";
      if (typeof i == "function")
        return Ul(i, gf(i));
      if (typeof i == "string")
        return wi(i);
      switch (i) {
        case Kt:
          return wi("Suspense");
        case qt:
          return wi("SuspenseList");
      }
      if (typeof i == "object")
        switch (i.$$typeof) {
          case st:
            return Za(i.render);
          case Qt:
            return qo(i.type, o, d);
          case Rt: {
            var h = i, b = h._payload, C = h._init;
            try {
              return qo(C(b), o, d);
            } catch {
            }
          }
        }
      return "";
    }
    function hn(i) {
      switch (i._debugOwner && i._debugOwner.type, i._debugSource, i.tag) {
        case x:
          return wi(i.type);
        case X:
          return wi("Lazy");
        case z:
          return wi("Suspense");
        case pe:
          return wi("SuspenseList");
        case p:
        case y:
        case K:
          return Za(i.type);
        case j:
          return Za(i.type.render);
        case g:
          return Zs(i.type);
        default:
          return "";
      }
    }
    function Qo(i) {
      try {
        var o = "", d = i;
        do
          o += hn(d), d = d.return;
        while (d);
        return o;
      } catch (h) {
        return `
Error generating stack: ` + h.message + `
` + h.stack;
      }
    }
    function Js(i, o, d) {
      var h = i.displayName;
      if (h)
        return h;
      var b = o.displayName || o.name || "";
      return b !== "" ? d + "(" + b + ")" : d;
    }
    function Bl(i) {
      return i.displayName || "Context";
    }
    function rn(i) {
      if (i == null)
        return null;
      if (typeof i.tag == "number" && c("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof i == "function")
        return i.displayName || i.name || null;
      if (typeof i == "string")
        return i;
      switch (i) {
        case Mi:
          return "Fragment";
        case bi:
          return "Portal";
        case J:
          return "Profiler";
        case Si:
          return "StrictMode";
        case Kt:
          return "Suspense";
        case qt:
          return "SuspenseList";
      }
      if (typeof i == "object")
        switch (i.$$typeof) {
          case et:
            var o = i;
            return Bl(o) + ".Consumer";
          case Be:
            var d = i;
            return Bl(d._context) + ".Provider";
          case st:
            return Js(i, i.render, "ForwardRef");
          case Qt:
            var h = i.displayName || null;
            return h !== null ? h : rn(i.type) || "Memo";
          case Rt: {
            var b = i, C = b._payload, R = b._init;
            try {
              return rn(R(C));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Fl(i, o, d) {
      var h = o.displayName || o.name || "";
      return i.displayName || (h !== "" ? d + "(" + h + ")" : d);
    }
    function Hl(i) {
      return i.displayName || "Context";
    }
    function Ft(i) {
      var o = i.tag, d = i.type;
      switch (o) {
        case le:
          return "Cache";
        case D:
          var h = d;
          return Hl(h) + ".Consumer";
        case N:
          var b = d;
          return Hl(b._context) + ".Provider";
        case ue:
          return "DehydratedFragment";
        case j:
          return Fl(d, d.render, "ForwardRef");
        case T:
          return "Fragment";
        case x:
          return d;
        case S:
          return "Portal";
        case v:
          return "Root";
        case _:
          return "Text";
        case X:
          return rn(d);
        case I:
          return d === Si ? "StrictMode" : "Mode";
        case ve:
          return "Offscreen";
        case L:
          return "Profiler";
        case Pe:
          return "Scope";
        case z:
          return "Suspense";
        case pe:
          return "SuspenseList";
        case Re:
          return "TracingMarker";
        case g:
        case p:
        case se:
        case y:
        case F:
        case K:
          if (typeof d == "function")
            return d.displayName || d.name || null;
          if (typeof d == "string")
            return d;
          break;
      }
      return null;
    }
    var el = n.ReactDebugCurrentFrame, gr = null, Fr = !1;
    function xi() {
      {
        if (gr === null)
          return null;
        var i = gr._debugOwner;
        if (i !== null && typeof i < "u")
          return Ft(i);
      }
      return null;
    }
    function Cs() {
      return gr === null ? "" : Qo(gr);
    }
    function or() {
      el.getCurrentStack = null, gr = null, Fr = !1;
    }
    function Nn(i) {
      el.getCurrentStack = i === null ? null : Cs, gr = i, Fr = !1;
    }
    function Vl() {
      return gr;
    }
    function Gi(i) {
      Fr = i;
    }
    function Gr(i) {
      return "" + i;
    }
    function Zo(i) {
      switch (typeof i) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return i;
        case "object":
          return Hn(i), i;
        default:
          return "";
      }
    }
    var Bc = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function fo(i, o) {
      Bc[o.type] || o.onChange || o.onInput || o.readOnly || o.disabled || o.value == null || c("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), o.onChange || o.readOnly || o.disabled || o.checked == null || c("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Ja(i) {
      var o = i.type, d = i.nodeName;
      return d && d.toLowerCase() === "input" && (o === "checkbox" || o === "radio");
    }
    function Yu(i) {
      return i._valueTracker;
    }
    function Ro(i) {
      i._valueTracker = null;
    }
    function _s(i) {
      var o = "";
      return i && (Ja(i) ? o = i.checked ? "true" : "false" : o = i.value), o;
    }
    function q(i) {
      var o = Ja(i) ? "checked" : "value", d = Object.getOwnPropertyDescriptor(i.constructor.prototype, o);
      Hn(i[o]);
      var h = "" + i[o];
      if (!(i.hasOwnProperty(o) || typeof d > "u" || typeof d.get != "function" || typeof d.set != "function")) {
        var b = d.get, C = d.set;
        Object.defineProperty(i, o, {
          configurable: !0,
          get: function() {
            return b.call(this);
          },
          set: function(A) {
            Hn(A), h = "" + A, C.call(this, A);
          }
        }), Object.defineProperty(i, o, {
          enumerable: d.enumerable
        });
        var R = {
          getValue: function() {
            return h;
          },
          setValue: function(A) {
            Hn(A), h = "" + A;
          },
          stopTracking: function() {
            Ro(i), delete i[o];
          }
        };
        return R;
      }
    }
    function ie(i) {
      Yu(i) || (i._valueTracker = q(i));
    }
    function Ue(i) {
      if (!i)
        return !1;
      var o = Yu(i);
      if (!o)
        return !0;
      var d = o.getValue(), h = _s(i);
      return h !== d ? (o.setValue(h), !0) : !1;
    }
    function it(i) {
      if (i = i || (typeof document < "u" ? document : void 0), typeof i > "u")
        return null;
      try {
        return i.activeElement || i.body;
      } catch {
        return i.body;
      }
    }
    var Pn = !1, Ut = !1, Kn = !1, Tr = !1;
    function Wn(i) {
      var o = i.type === "checkbox" || i.type === "radio";
      return o ? i.checked != null : i.value != null;
    }
    function U(i, o) {
      var d = i, h = o.checked, b = Jt({}, o, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: h ?? d._wrapperState.initialChecked
      });
      return b;
    }
    function Z(i, o) {
      fo("input", o), o.checked !== void 0 && o.defaultChecked !== void 0 && !Ut && (c("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", xi() || "A component", o.type), Ut = !0), o.value !== void 0 && o.defaultValue !== void 0 && !Pn && (c("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", xi() || "A component", o.type), Pn = !0);
      var d = i, h = o.defaultValue == null ? "" : o.defaultValue;
      d._wrapperState = {
        initialChecked: o.checked != null ? o.checked : o.defaultChecked,
        initialValue: Zo(o.value != null ? o.value : h),
        controlled: Wn(o)
      };
    }
    function ye(i, o) {
      var d = i, h = o.checked;
      h != null && co(d, "checked", h, !1);
    }
    function Ee(i, o) {
      var d = i;
      {
        var h = Wn(o);
        !d._wrapperState.controlled && h && !Tr && (c("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Tr = !0), d._wrapperState.controlled && !h && !Kn && (c("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Kn = !0);
      }
      ye(i, o);
      var b = Zo(o.value), C = o.type;
      if (b != null)
        C === "number" ? (b === 0 && d.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        d.value != b) && (d.value = Gr(b)) : d.value !== Gr(b) && (d.value = Gr(b));
      else if (C === "submit" || C === "reset") {
        d.removeAttribute("value");
        return;
      }
      o.hasOwnProperty("value") ? bt(d, o.type, b) : o.hasOwnProperty("defaultValue") && bt(d, o.type, Zo(o.defaultValue)), o.checked == null && o.defaultChecked != null && (d.defaultChecked = !!o.defaultChecked);
    }
    function Fe(i, o, d) {
      var h = i;
      if (o.hasOwnProperty("value") || o.hasOwnProperty("defaultValue")) {
        var b = o.type, C = b === "submit" || b === "reset";
        if (C && (o.value === void 0 || o.value === null))
          return;
        var R = Gr(h._wrapperState.initialValue);
        d || R !== h.value && (h.value = R), h.defaultValue = R;
      }
      var A = h.name;
      A !== "" && (h.name = ""), h.defaultChecked = !h.defaultChecked, h.defaultChecked = !!h._wrapperState.initialChecked, A !== "" && (h.name = A);
    }
    function ht(i, o) {
      var d = i;
      Ee(d, o), Ze(d, o);
    }
    function Ze(i, o) {
      var d = o.name;
      if (o.type === "radio" && d != null) {
        for (var h = i; h.parentNode; )
          h = h.parentNode;
        yn(d, "name");
        for (var b = h.querySelectorAll("input[name=" + JSON.stringify("" + d) + '][type="radio"]'), C = 0; C < b.length; C++) {
          var R = b[C];
          if (!(R === i || R.form !== i.form)) {
            var A = lS(R);
            if (!A)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            Ue(R), Ee(R, A);
          }
        }
      }
    }
    function bt(i, o, d) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (o !== "number" || it(i.ownerDocument) !== i) && (d == null ? i.defaultValue = Gr(i._wrapperState.initialValue) : i.defaultValue !== Gr(d) && (i.defaultValue = Gr(d)));
    }
    var Yt = !1, gn = !1, Ln = !1;
    function In(i, o) {
      o.value == null && (typeof o.children == "object" && o.children !== null ? t.Children.forEach(o.children, function(d) {
        d != null && (typeof d == "string" || typeof d == "number" || gn || (gn = !0, c("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : o.dangerouslySetInnerHTML != null && (Ln || (Ln = !0, c("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), o.selected != null && !Yt && (c("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Yt = !0);
    }
    function ar(i, o) {
      o.value != null && i.setAttribute("value", Gr(Zo(o.value)));
    }
    var dr = Array.isArray;
    function Sn(i) {
      return dr(i);
    }
    var tl;
    tl = !1;
    function Ku() {
      var i = xi();
      return i ? `

Check the render method of \`` + i + "`." : "";
    }
    var mf = ["value", "defaultValue"];
    function ym(i) {
      {
        fo("select", i);
        for (var o = 0; o < mf.length; o++) {
          var d = mf[o];
          if (i[d] != null) {
            var h = Sn(i[d]);
            i.multiple && !h ? c("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", d, Ku()) : !i.multiple && h && c("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", d, Ku());
          }
        }
      }
    }
    function es(i, o, d, h) {
      var b = i.options;
      if (o) {
        for (var C = d, R = {}, A = 0; A < C.length; A++)
          R["$" + C[A]] = !0;
        for (var B = 0; B < b.length; B++) {
          var V = R.hasOwnProperty("$" + b[B].value);
          b[B].selected !== V && (b[B].selected = V), V && h && (b[B].defaultSelected = !0);
        }
      } else {
        for (var G = Gr(Zo(d)), ae = null, ne = 0; ne < b.length; ne++) {
          if (b[ne].value === G) {
            b[ne].selected = !0, h && (b[ne].defaultSelected = !0);
            return;
          }
          ae === null && !b[ne].disabled && (ae = b[ne]);
        }
        ae !== null && (ae.selected = !0);
      }
    }
    function vf(i, o) {
      return Jt({}, o, {
        value: void 0
      });
    }
    function yf(i, o) {
      var d = i;
      ym(o), d._wrapperState = {
        wasMultiple: !!o.multiple
      }, o.value !== void 0 && o.defaultValue !== void 0 && !tl && (c("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), tl = !0);
    }
    function bm(i, o) {
      var d = i;
      d.multiple = !!o.multiple;
      var h = o.value;
      h != null ? es(d, !!o.multiple, h, !1) : o.defaultValue != null && es(d, !!o.multiple, o.defaultValue, !0);
    }
    function K1(i, o) {
      var d = i, h = d._wrapperState.wasMultiple;
      d._wrapperState.wasMultiple = !!o.multiple;
      var b = o.value;
      b != null ? es(d, !!o.multiple, b, !1) : h !== !!o.multiple && (o.defaultValue != null ? es(d, !!o.multiple, o.defaultValue, !0) : es(d, !!o.multiple, o.multiple ? [] : "", !1));
    }
    function W1(i, o) {
      var d = i, h = o.value;
      h != null && es(d, !!o.multiple, h, !1);
    }
    var Sm = !1;
    function wm(i, o) {
      var d = i;
      if (o.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var h = Jt({}, o, {
        value: void 0,
        defaultValue: void 0,
        children: Gr(d._wrapperState.initialValue)
      });
      return h;
    }
    function Lb(i, o) {
      var d = i;
      fo("textarea", o), o.value !== void 0 && o.defaultValue !== void 0 && !Sm && (c("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", xi() || "A component"), Sm = !0);
      var h = o.value;
      if (h == null) {
        var b = o.children, C = o.defaultValue;
        if (b != null) {
          c("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (C != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (Sn(b)) {
              if (b.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              b = b[0];
            }
            C = b;
          }
        }
        C == null && (C = ""), h = C;
      }
      d._wrapperState = {
        initialValue: Zo(h)
      };
    }
    function jb(i, o) {
      var d = i, h = Zo(o.value), b = Zo(o.defaultValue);
      if (h != null) {
        var C = Gr(h);
        C !== d.value && (d.value = C), o.defaultValue == null && d.defaultValue !== C && (d.defaultValue = C);
      }
      b != null && (d.defaultValue = Gr(b));
    }
    function zb(i, o) {
      var d = i, h = d.textContent;
      h === d._wrapperState.initialValue && h !== "" && h !== null && (d.value = h);
    }
    function xm(i, o) {
      jb(i, o);
    }
    var nl = "http://www.w3.org/1999/xhtml", G1 = "http://www.w3.org/1998/Math/MathML", Em = "http://www.w3.org/2000/svg";
    function Yp(i) {
      switch (i) {
        case "svg":
          return Em;
        case "math":
          return G1;
        default:
          return nl;
      }
    }
    function Cm(i, o) {
      return i == null || i === nl ? Yp(o) : i === Em && o === "foreignObject" ? nl : i;
    }
    var X1 = function(i) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(o, d, h, b) {
        MSApp.execUnsafeLocalFunction(function() {
          return i(o, d, h, b);
        });
      } : i;
    }, Kp, Ub = X1(function(i, o) {
      if (i.namespaceURI === Em && !("innerHTML" in i)) {
        Kp = Kp || document.createElement("div"), Kp.innerHTML = "<svg>" + o.valueOf().toString() + "</svg>";
        for (var d = Kp.firstChild; i.firstChild; )
          i.removeChild(i.firstChild);
        for (; d.firstChild; )
          i.appendChild(d.firstChild);
        return;
      }
      i.innerHTML = o;
    }), $o = 1, rl = 3, ri = 8, ts = 9, Fc = 11, Wp = function(i, o) {
      if (o) {
        var d = i.firstChild;
        if (d && d === i.lastChild && d.nodeType === rl) {
          d.nodeValue = o;
          return;
        }
      }
      i.textContent = o;
    }, Bb = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, Wu = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Fb(i, o) {
      return i + o.charAt(0).toUpperCase() + o.substring(1);
    }
    var Hb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Wu).forEach(function(i) {
      Hb.forEach(function(o) {
        Wu[Fb(o, i)] = Wu[i];
      });
    });
    function Gp(i, o, d) {
      var h = o == null || typeof o == "boolean" || o === "";
      return h ? "" : !d && typeof o == "number" && o !== 0 && !(Wu.hasOwnProperty(i) && Wu[i]) ? o + "px" : (Mr(o, i), ("" + o).trim());
    }
    var Gu = /([A-Z])/g, q1 = /^ms-/;
    function Q1(i) {
      return i.replace(Gu, "-$1").toLowerCase().replace(q1, "-ms-");
    }
    var Vb = function() {
    };
    {
      var Yb = /^(?:webkit|moz|o)[A-Z]/, Kb = /^-ms-/, bf = /-(.)/g, Xu = /;\s*$/, qu = {}, Qu = {}, Wb = !1, _m = !1, Tm = function(i) {
        return i.replace(bf, function(o, d) {
          return d.toUpperCase();
        });
      }, km = function(i) {
        qu.hasOwnProperty(i) && qu[i] || (qu[i] = !0, c(
          "Unsupported style property %s. Did you mean %s?",
          i,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Tm(i.replace(Kb, "ms-"))
        ));
      }, Gb = function(i) {
        qu.hasOwnProperty(i) && qu[i] || (qu[i] = !0, c("Unsupported vendor-prefixed style property %s. Did you mean %s?", i, i.charAt(0).toUpperCase() + i.slice(1)));
      }, Xb = function(i, o) {
        Qu.hasOwnProperty(o) && Qu[o] || (Qu[o] = !0, c(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, i, o.replace(Xu, "")));
      }, qb = function(i, o) {
        Wb || (Wb = !0, c("`NaN` is an invalid value for the `%s` css style property.", i));
      }, Z1 = function(i, o) {
        _m || (_m = !0, c("`Infinity` is an invalid value for the `%s` css style property.", i));
      };
      Vb = function(i, o) {
        i.indexOf("-") > -1 ? km(i) : Yb.test(i) ? Gb(i) : Xu.test(o) && Xb(i, o), typeof o == "number" && (isNaN(o) ? qb(i, o) : isFinite(o) || Z1(i, o));
      };
    }
    var J1 = Vb;
    function eE(i) {
      {
        var o = "", d = "";
        for (var h in i)
          if (i.hasOwnProperty(h)) {
            var b = i[h];
            if (b != null) {
              var C = h.indexOf("--") === 0;
              o += d + (C ? h : Q1(h)) + ":", o += Gp(h, b, C), d = ";";
            }
          }
        return o || null;
      }
    }
    function Qb(i, o) {
      var d = i.style;
      for (var h in o)
        if (o.hasOwnProperty(h)) {
          var b = h.indexOf("--") === 0;
          b || J1(h, o[h]);
          var C = Gp(h, o[h], b);
          h === "float" && (h = "cssFloat"), b ? d.setProperty(h, C) : d[h] = C;
        }
    }
    function tE(i) {
      return i == null || typeof i == "boolean" || i === "";
    }
    function _a(i) {
      var o = {};
      for (var d in i)
        for (var h = Bb[d] || [d], b = 0; b < h.length; b++)
          o[h[b]] = d;
      return o;
    }
    function Sf(i, o) {
      {
        if (!o)
          return;
        var d = _a(i), h = _a(o), b = {};
        for (var C in d) {
          var R = d[C], A = h[C];
          if (A && R !== A) {
            var B = R + "," + A;
            if (b[B])
              continue;
            b[B] = !0, c("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", tE(i[R]) ? "Removing" : "Updating", R, A);
          }
        }
      }
    }
    var Zb = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, Jb = Jt({
      menuitem: !0
    }, Zb), e0 = "__html";
    function Xp(i, o) {
      if (o) {
        if (Jb[i] && (o.children != null || o.dangerouslySetInnerHTML != null))
          throw new Error(i + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (o.dangerouslySetInnerHTML != null) {
          if (o.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof o.dangerouslySetInnerHTML != "object" || !(e0 in o.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!o.suppressContentEditableWarning && o.contentEditable && o.children != null && c("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), o.style != null && typeof o.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function il(i, o) {
      if (i.indexOf("-") === -1)
        return typeof o.is == "string";
      switch (i) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var qp = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, t0 = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, ns = {}, Pm = new RegExp("^(aria)-[" + Et + "]*$"), wf = new RegExp("^(aria)[A-Z][" + Et + "]*$");
    function Im(i, o) {
      {
        if (Ke.call(ns, o) && ns[o])
          return !0;
        if (wf.test(o)) {
          var d = "aria-" + o.slice(4).toLowerCase(), h = t0.hasOwnProperty(d) ? d : null;
          if (h == null)
            return c("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", o), ns[o] = !0, !0;
          if (o !== h)
            return c("Invalid ARIA attribute `%s`. Did you mean `%s`?", o, h), ns[o] = !0, !0;
        }
        if (Pm.test(o)) {
          var b = o.toLowerCase(), C = t0.hasOwnProperty(b) ? b : null;
          if (C == null)
            return ns[o] = !0, !1;
          if (o !== C)
            return c("Unknown ARIA attribute `%s`. Did you mean `%s`?", o, C), ns[o] = !0, !0;
        }
      }
      return !0;
    }
    function n0(i, o) {
      {
        var d = [];
        for (var h in o) {
          var b = Im(i, h);
          b || d.push(h);
        }
        var C = d.map(function(R) {
          return "`" + R + "`";
        }).join(", ");
        d.length === 1 ? c("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", C, i) : d.length > 1 && c("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", C, i);
      }
    }
    function Qp(i, o) {
      il(i, o) || n0(i, o);
    }
    var Hc = !1;
    function Rm(i, o) {
      {
        if (i !== "input" && i !== "textarea" && i !== "select")
          return;
        o != null && o.value === null && !Hc && (Hc = !0, i === "select" && o.multiple ? c("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", i) : c("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", i));
      }
    }
    var $m = function() {
    };
    {
      var Ei = {}, Mm = /^on./, r0 = /^on[^A-Z]/, i0 = new RegExp("^(aria)-[" + Et + "]*$"), o0 = new RegExp("^(aria)[A-Z][" + Et + "]*$");
      $m = function(i, o, d, h) {
        if (Ke.call(Ei, o) && Ei[o])
          return !0;
        var b = o.toLowerCase();
        if (b === "onfocusin" || b === "onfocusout")
          return c("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), Ei[o] = !0, !0;
        if (h != null) {
          var C = h.registrationNameDependencies, R = h.possibleRegistrationNames;
          if (C.hasOwnProperty(o))
            return !0;
          var A = R.hasOwnProperty(b) ? R[b] : null;
          if (A != null)
            return c("Invalid event handler property `%s`. Did you mean `%s`?", o, A), Ei[o] = !0, !0;
          if (Mm.test(o))
            return c("Unknown event handler property `%s`. It will be ignored.", o), Ei[o] = !0, !0;
        } else if (Mm.test(o))
          return r0.test(o) && c("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", o), Ei[o] = !0, !0;
        if (i0.test(o) || o0.test(o))
          return !0;
        if (b === "innerhtml")
          return c("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), Ei[o] = !0, !0;
        if (b === "aria")
          return c("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), Ei[o] = !0, !0;
        if (b === "is" && d !== null && d !== void 0 && typeof d != "string")
          return c("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof d), Ei[o] = !0, !0;
        if (typeof d == "number" && isNaN(d))
          return c("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", o), Ei[o] = !0, !0;
        var B = vi(o), V = B !== null && B.type === xt;
        if (qp.hasOwnProperty(b)) {
          var G = qp[b];
          if (G !== o)
            return c("Invalid DOM property `%s`. Did you mean `%s`?", o, G), Ei[o] = !0, !0;
        } else if (!V && o !== b)
          return c("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", o, b), Ei[o] = !0, !0;
        return typeof d == "boolean" && mi(o, d, B, !1) ? (d ? c('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', d, o, o, d, o) : c('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', d, o, o, d, o, o, o), Ei[o] = !0, !0) : V ? !0 : mi(o, d, B, !1) ? (Ei[o] = !0, !1) : ((d === "false" || d === "true") && B !== null && B.type === An && (c("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", d, o, d === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', o, d), Ei[o] = !0), !0);
      };
    }
    var a0 = function(i, o, d) {
      {
        var h = [];
        for (var b in o) {
          var C = $m(i, b, o[b], d);
          C || h.push(b);
        }
        var R = h.map(function(A) {
          return "`" + A + "`";
        }).join(", ");
        h.length === 1 ? c("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", R, i) : h.length > 1 && c("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", R, i);
      }
    };
    function s0(i, o, d) {
      il(i, o) || a0(i, o, d);
    }
    var ol = 1, xf = 1 << 1, Vc = 1 << 2, nE = ol | xf | Vc, Ef = null;
    function Cf(i) {
      Ef !== null && c("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Ef = i;
    }
    function rE() {
      Ef === null && c("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Ef = null;
    }
    function l0(i) {
      return i === Ef;
    }
    function Zp(i) {
      var o = i.target || i.srcElement || window;
      return o.correspondingUseElement && (o = o.correspondingUseElement), o.nodeType === rl ? o.parentNode : o;
    }
    var sr = null, Yl = null, al = null;
    function Zu(i) {
      var o = Cd(i);
      if (o) {
        if (typeof sr != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var d = o.stateNode;
        if (d) {
          var h = lS(d);
          sr(o.stateNode, o.type, h);
        }
      }
    }
    function c0(i) {
      sr = i;
    }
    function Jp(i) {
      Yl ? al ? al.push(i) : al = [i] : Yl = i;
    }
    function _f() {
      return Yl !== null || al !== null;
    }
    function Tf() {
      if (Yl) {
        var i = Yl, o = al;
        if (Yl = null, al = null, Zu(i), o)
          for (var d = 0; d < o.length; d++)
            Zu(o[d]);
      }
    }
    var Yc = function(i, o) {
      return i(o);
    }, Am = function() {
    }, Om = !1;
    function iE() {
      var i = _f();
      i && (Am(), Tf());
    }
    function Dm(i, o, d) {
      if (Om)
        return i(o, d);
      Om = !0;
      try {
        return Yc(i, o, d);
      } finally {
        Om = !1, iE();
      }
    }
    function eh(i, o, d) {
      Yc = i, Am = d;
    }
    function th(i) {
      return i === "button" || i === "input" || i === "select" || i === "textarea";
    }
    function Nm(i, o, d) {
      switch (i) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(d.disabled && th(o));
        default:
          return !1;
      }
    }
    function Kc(i, o) {
      var d = i.stateNode;
      if (d === null)
        return null;
      var h = lS(d);
      if (h === null)
        return null;
      var b = h[o];
      if (Nm(o, i.type, h))
        return null;
      if (b && typeof b != "function")
        throw new Error("Expected `" + o + "` listener to be a function, instead got a value of `" + typeof b + "` type.");
      return b;
    }
    var kf = !1;
    if (Nt)
      try {
        var Wc = {};
        Object.defineProperty(Wc, "passive", {
          get: function() {
            kf = !0;
          }
        }), window.addEventListener("test", Wc, Wc), window.removeEventListener("test", Wc, Wc);
      } catch {
        kf = !1;
      }
    function u0(i, o, d, h, b, C, R, A, B) {
      var V = Array.prototype.slice.call(arguments, 3);
      try {
        o.apply(d, V);
      } catch (G) {
        this.onError(G);
      }
    }
    var Lm = u0;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var jm = document.createElement("react");
      Lm = function(o, d, h, b, C, R, A, B, V) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var G = document.createEvent("Event"), ae = !1, ne = !0, Ce = window.event, _e = Object.getOwnPropertyDescriptor(window, "event");
        function Ae() {
          jm.removeEventListener(Oe, Ot, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Ce);
        }
        var ut = Array.prototype.slice.call(arguments, 3);
        function Ot() {
          ae = !0, Ae(), d.apply(h, ut), ne = !1;
        }
        var Pt, _n = !1, vn = !1;
        function be(Se) {
          if (Pt = Se.error, _n = !0, Pt === null && Se.colno === 0 && Se.lineno === 0 && (vn = !0), Se.defaultPrevented && Pt != null && typeof Pt == "object")
            try {
              Pt._suppressLogging = !0;
            } catch {
            }
        }
        var Oe = "react-" + (o || "invokeguardedcallback");
        if (window.addEventListener("error", be), jm.addEventListener(Oe, Ot, !1), G.initEvent(Oe, !1, !1), jm.dispatchEvent(G), _e && Object.defineProperty(window, "event", _e), ae && ne && (_n ? vn && (Pt = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Pt = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Pt)), window.removeEventListener("error", be), !ae)
          return Ae(), u0.apply(this, arguments);
      };
    }
    var oE = Lm, Kl = !1, rs = null, Pf = !1, Wl = null, Ts = {
      onError: function(i) {
        Kl = !0, rs = i;
      }
    };
    function Gc(i, o, d, h, b, C, R, A, B) {
      Kl = !1, rs = null, oE.apply(Ts, arguments);
    }
    function sl(i, o, d, h, b, C, R, A, B) {
      if (Gc.apply(this, arguments), Kl) {
        var V = Um();
        Pf || (Pf = !0, Wl = V);
      }
    }
    function zm() {
      if (Pf) {
        var i = Wl;
        throw Pf = !1, Wl = null, i;
      }
    }
    function aE() {
      return Kl;
    }
    function Um() {
      if (Kl) {
        var i = rs;
        return Kl = !1, rs = null, i;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Ta(i) {
      return i._reactInternals;
    }
    function If(i) {
      return i._reactInternals !== void 0;
    }
    function Ju(i, o) {
      i._reactInternals = o;
    }
    var Mt = (
      /*                      */
      0
    ), Gl = (
      /*                */
      1
    ), mr = (
      /*                    */
      2
    ), on = (
      /*                       */
      4
    ), Un = (
      /*                */
      16
    ), Vn = (
      /*                 */
      32
    ), ks = (
      /*                     */
      64
    ), Ht = (
      /*                   */
      128
    ), Hr = (
      /*            */
      256
    ), Mo = (
      /*                          */
      512
    ), ka = (
      /*                     */
      1024
    ), kr = (
      /*                      */
      2048
    ), Pa = (
      /*                    */
      4096
    ), Xl = (
      /*                   */
      8192
    ), Rf = (
      /*             */
      16384
    ), nh = kr | on | ks | Mo | ka | Rf, d0 = (
      /*               */
      32767
    ), Jo = (
      /*                   */
      32768
    ), Ci = (
      /*                */
      65536
    ), $f = (
      /* */
      131072
    ), Bm = (
      /*                       */
      1048576
    ), Fm = (
      /*                    */
      2097152
    ), Ao = (
      /*                 */
      4194304
    ), ql = (
      /*                */
      8388608
    ), Oo = (
      /*               */
      16777216
    ), Xc = (
      /*              */
      33554432
    ), ed = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      on | ka | 0
    ), Do = mr | on | Un | Vn | Mo | Pa | Xl, Xi = on | ks | Mo | Xl, Ia = kr | Un, Oi = Ao | ql | Fm, ll = n.ReactCurrentOwner;
    function ea(i) {
      var o = i, d = i;
      if (i.alternate)
        for (; o.return; )
          o = o.return;
      else {
        var h = o;
        do
          o = h, (o.flags & (mr | Pa)) !== Mt && (d = o.return), h = o.return;
        while (h);
      }
      return o.tag === v ? d : null;
    }
    function Hm(i) {
      if (i.tag === z) {
        var o = i.memoizedState;
        if (o === null) {
          var d = i.alternate;
          d !== null && (o = d.memoizedState);
        }
        if (o !== null)
          return o.dehydrated;
      }
      return null;
    }
    function rh(i) {
      return i.tag === v ? i.stateNode.containerInfo : null;
    }
    function Vm(i) {
      return ea(i) === i;
    }
    function ta(i) {
      {
        var o = ll.current;
        if (o !== null && o.tag === g) {
          var d = o, h = d.stateNode;
          h._warnedAboutRefsInRender || c("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Ft(d) || "A component"), h._warnedAboutRefsInRender = !0;
        }
      }
      var b = Ta(i);
      return b ? ea(b) === b : !1;
    }
    function No(i) {
      if (ea(i) !== i)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function vr(i) {
      var o = i.alternate;
      if (!o) {
        var d = ea(i);
        if (d === null)
          throw new Error("Unable to find node on an unmounted component.");
        return d !== i ? null : i;
      }
      for (var h = i, b = o; ; ) {
        var C = h.return;
        if (C === null)
          break;
        var R = C.alternate;
        if (R === null) {
          var A = C.return;
          if (A !== null) {
            h = b = A;
            continue;
          }
          break;
        }
        if (C.child === R.child) {
          for (var B = C.child; B; ) {
            if (B === h)
              return No(C), i;
            if (B === b)
              return No(C), o;
            B = B.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (h.return !== b.return)
          h = C, b = R;
        else {
          for (var V = !1, G = C.child; G; ) {
            if (G === h) {
              V = !0, h = C, b = R;
              break;
            }
            if (G === b) {
              V = !0, b = C, h = R;
              break;
            }
            G = G.sibling;
          }
          if (!V) {
            for (G = R.child; G; ) {
              if (G === h) {
                V = !0, h = R, b = C;
                break;
              }
              if (G === b) {
                V = !0, b = R, h = C;
                break;
              }
              G = G.sibling;
            }
            if (!V)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (h.alternate !== b)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (h.tag !== v)
        throw new Error("Unable to find node on an unmounted component.");
      return h.stateNode.current === h ? i : o;
    }
    function Ra(i) {
      var o = vr(i);
      return o !== null ? Ym(o) : null;
    }
    function Ym(i) {
      if (i.tag === x || i.tag === _)
        return i;
      for (var o = i.child; o !== null; ) {
        var d = Ym(o);
        if (d !== null)
          return d;
        o = o.sibling;
      }
      return null;
    }
    function f0(i) {
      var o = vr(i);
      return o !== null ? ih(o) : null;
    }
    function ih(i) {
      if (i.tag === x || i.tag === _)
        return i;
      for (var o = i.child; o !== null; ) {
        if (o.tag !== S) {
          var d = ih(o);
          if (d !== null)
            return d;
        }
        o = o.sibling;
      }
      return null;
    }
    var oh = e.unstable_scheduleCallback, p0 = e.unstable_cancelCallback, ah = e.unstable_shouldYield, h0 = e.unstable_requestPaint, Ar = e.unstable_now, Km = e.unstable_getCurrentPriorityLevel, sh = e.unstable_ImmediatePriority, na = e.unstable_UserBlockingPriority, Ps = e.unstable_NormalPriority, lh = e.unstable_LowPriority, Ql = e.unstable_IdlePriority, Wm = e.unstable_yieldValue, Gm = e.unstable_setDisableYieldValue, Zl = null, _i = null, tt = null, Xr = !1, Di = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function Xm(i) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var o = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (o.isDisabled)
        return !0;
      if (!o.supportsFiber)
        return c("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        Me && (i = Jt({}, i, {
          getLaneLabelMap: ec,
          injectProfilingHooks: ul
        })), Zl = o.inject(i), _i = o;
      } catch (d) {
        c("React instrumentation encountered an error: %s.", d);
      }
      return !!o.checkDCE;
    }
    function g0(i, o) {
      if (_i && typeof _i.onScheduleFiberRoot == "function")
        try {
          _i.onScheduleFiberRoot(Zl, i, o);
        } catch (d) {
          Xr || (Xr = !0, c("React instrumentation encountered an error: %s", d));
        }
    }
    function cl(i, o) {
      if (_i && typeof _i.onCommitFiberRoot == "function")
        try {
          var d = (i.current.flags & Ht) === Ht;
          if (re) {
            var h;
            switch (o) {
              case qi:
                h = sh;
                break;
              case Ni:
                h = na;
                break;
              case fl:
                h = Ps;
                break;
              case Uf:
                h = Ql;
                break;
              default:
                h = Ps;
                break;
            }
            _i.onCommitFiberRoot(Zl, i, h, d);
          }
        } catch (b) {
          Xr || (Xr = !0, c("React instrumentation encountered an error: %s", b));
        }
    }
    function Jl(i) {
      if (_i && typeof _i.onPostCommitFiberRoot == "function")
        try {
          _i.onPostCommitFiberRoot(Zl, i);
        } catch (o) {
          Xr || (Xr = !0, c("React instrumentation encountered an error: %s", o));
        }
    }
    function qm(i) {
      if (_i && typeof _i.onCommitFiberUnmount == "function")
        try {
          _i.onCommitFiberUnmount(Zl, i);
        } catch (o) {
          Xr || (Xr = !0, c("React instrumentation encountered an error: %s", o));
        }
    }
    function si(i) {
      if (typeof Wm == "function" && (Gm(i), a(i)), _i && typeof _i.setStrictMode == "function")
        try {
          _i.setStrictMode(Zl, i);
        } catch (o) {
          Xr || (Xr = !0, c("React instrumentation encountered an error: %s", o));
        }
    }
    function ul(i) {
      tt = i;
    }
    function ec() {
      {
        for (var i = /* @__PURE__ */ new Map(), o = 1, d = 0; d < yr; d++) {
          var h = sE(o);
          i.set(o, h), o *= 2;
        }
        return i;
      }
    }
    function ch(i) {
      tt !== null && typeof tt.markCommitStarted == "function" && tt.markCommitStarted(i);
    }
    function Qm() {
      tt !== null && typeof tt.markCommitStopped == "function" && tt.markCommitStopped();
    }
    function tc(i) {
      tt !== null && typeof tt.markComponentRenderStarted == "function" && tt.markComponentRenderStarted(i);
    }
    function qc() {
      tt !== null && typeof tt.markComponentRenderStopped == "function" && tt.markComponentRenderStopped();
    }
    function m0(i) {
      tt !== null && typeof tt.markComponentPassiveEffectMountStarted == "function" && tt.markComponentPassiveEffectMountStarted(i);
    }
    function Zm() {
      tt !== null && typeof tt.markComponentPassiveEffectMountStopped == "function" && tt.markComponentPassiveEffectMountStopped();
    }
    function uh(i) {
      tt !== null && typeof tt.markComponentPassiveEffectUnmountStarted == "function" && tt.markComponentPassiveEffectUnmountStarted(i);
    }
    function v0() {
      tt !== null && typeof tt.markComponentPassiveEffectUnmountStopped == "function" && tt.markComponentPassiveEffectUnmountStopped();
    }
    function y0(i) {
      tt !== null && typeof tt.markComponentLayoutEffectMountStarted == "function" && tt.markComponentLayoutEffectMountStarted(i);
    }
    function b0() {
      tt !== null && typeof tt.markComponentLayoutEffectMountStopped == "function" && tt.markComponentLayoutEffectMountStopped();
    }
    function dh(i) {
      tt !== null && typeof tt.markComponentLayoutEffectUnmountStarted == "function" && tt.markComponentLayoutEffectUnmountStarted(i);
    }
    function td() {
      tt !== null && typeof tt.markComponentLayoutEffectUnmountStopped == "function" && tt.markComponentLayoutEffectUnmountStopped();
    }
    function fh(i, o, d) {
      tt !== null && typeof tt.markComponentErrored == "function" && tt.markComponentErrored(i, o, d);
    }
    function S0(i, o, d) {
      tt !== null && typeof tt.markComponentSuspended == "function" && tt.markComponentSuspended(i, o, d);
    }
    function w0(i) {
      tt !== null && typeof tt.markLayoutEffectsStarted == "function" && tt.markLayoutEffectsStarted(i);
    }
    function nd() {
      tt !== null && typeof tt.markLayoutEffectsStopped == "function" && tt.markLayoutEffectsStopped();
    }
    function x0(i) {
      tt !== null && typeof tt.markPassiveEffectsStarted == "function" && tt.markPassiveEffectsStarted(i);
    }
    function Mf() {
      tt !== null && typeof tt.markPassiveEffectsStopped == "function" && tt.markPassiveEffectsStopped();
    }
    function is(i) {
      tt !== null && typeof tt.markRenderStarted == "function" && tt.markRenderStarted(i);
    }
    function Af() {
      tt !== null && typeof tt.markRenderYielded == "function" && tt.markRenderYielded();
    }
    function rd() {
      tt !== null && typeof tt.markRenderStopped == "function" && tt.markRenderStopped();
    }
    function Qc(i) {
      tt !== null && typeof tt.markRenderScheduled == "function" && tt.markRenderScheduled(i);
    }
    function Jm(i, o) {
      tt !== null && typeof tt.markForceUpdateScheduled == "function" && tt.markForceUpdateScheduled(i, o);
    }
    function nc(i, o) {
      tt !== null && typeof tt.markStateUpdateScheduled == "function" && tt.markStateUpdateScheduled(i, o);
    }
    var Dt = (
      /*                         */
      0
    ), fn = (
      /*                 */
      1
    ), Lt = (
      /*                    */
      2
    ), Or = (
      /*               */
      8
    ), $a = (
      /*              */
      16
    ), ph = Math.clz32 ? Math.clz32 : Zc, hh = Math.log, ev = Math.LN2;
    function Zc(i) {
      var o = i >>> 0;
      return o === 0 ? 32 : 31 - (hh(o) / ev | 0) | 0;
    }
    var yr = 31, Ne = (
      /*                        */
      0
    ), En = (
      /*                          */
      0
    ), jt = (
      /*                        */
      1
    ), Is = (
      /*    */
      2
    ), ra = (
      /*             */
      4
    ), Jc = (
      /*            */
      8
    ), br = (
      /*                     */
      16
    ), eu = (
      /*                */
      32
    ), rc = (
      /*                       */
      4194240
    ), tu = (
      /*                        */
      64
    ), Ma = (
      /*                        */
      128
    ), Lo = (
      /*                        */
      256
    ), nu = (
      /*                        */
      512
    ), Of = (
      /*                        */
      1024
    ), Df = (
      /*                        */
      2048
    ), gh = (
      /*                        */
      4096
    ), mh = (
      /*                        */
      8192
    ), vh = (
      /*                        */
      16384
    ), yh = (
      /*                       */
      32768
    ), bh = (
      /*                       */
      65536
    ), Sh = (
      /*                       */
      131072
    ), wh = (
      /*                       */
      262144
    ), xh = (
      /*                       */
      524288
    ), ru = (
      /*                       */
      1048576
    ), Eh = (
      /*                       */
      2097152
    ), iu = (
      /*                            */
      130023424
    ), dl = (
      /*                             */
      4194304
    ), Ch = (
      /*                             */
      8388608
    ), Nf = (
      /*                             */
      16777216
    ), _h = (
      /*                             */
      33554432
    ), Th = (
      /*                             */
      67108864
    ), tv = dl, id = (
      /*          */
      134217728
    ), kh = (
      /*                          */
      268435455
    ), od = (
      /*               */
      268435456
    ), ic = (
      /*                        */
      536870912
    ), jo = (
      /*                   */
      1073741824
    );
    function sE(i) {
      {
        if (i & jt)
          return "Sync";
        if (i & Is)
          return "InputContinuousHydration";
        if (i & ra)
          return "InputContinuous";
        if (i & Jc)
          return "DefaultHydration";
        if (i & br)
          return "Default";
        if (i & eu)
          return "TransitionHydration";
        if (i & rc)
          return "Transition";
        if (i & iu)
          return "Retry";
        if (i & id)
          return "SelectiveHydration";
        if (i & od)
          return "IdleHydration";
        if (i & ic)
          return "Idle";
        if (i & jo)
          return "Offscreen";
      }
    }
    var lr = -1, Ph = tu, Ih = dl;
    function ad(i) {
      switch (ii(i)) {
        case jt:
          return jt;
        case Is:
          return Is;
        case ra:
          return ra;
        case Jc:
          return Jc;
        case br:
          return br;
        case eu:
          return eu;
        case tu:
        case Ma:
        case Lo:
        case nu:
        case Of:
        case Df:
        case gh:
        case mh:
        case vh:
        case yh:
        case bh:
        case Sh:
        case wh:
        case xh:
        case ru:
        case Eh:
          return i & rc;
        case dl:
        case Ch:
        case Nf:
        case _h:
        case Th:
          return i & iu;
        case id:
          return id;
        case od:
          return od;
        case ic:
          return ic;
        case jo:
          return jo;
        default:
          return c("Should have found matching lanes. This is a bug in React."), i;
      }
    }
    function Lf(i, o) {
      var d = i.pendingLanes;
      if (d === Ne)
        return Ne;
      var h = Ne, b = i.suspendedLanes, C = i.pingedLanes, R = d & kh;
      if (R !== Ne) {
        var A = R & ~b;
        if (A !== Ne)
          h = ad(A);
        else {
          var B = R & C;
          B !== Ne && (h = ad(B));
        }
      } else {
        var V = d & ~b;
        V !== Ne ? h = ad(V) : C !== Ne && (h = ad(C));
      }
      if (h === Ne)
        return Ne;
      if (o !== Ne && o !== h && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (o & b) === Ne) {
        var G = ii(h), ae = ii(o);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          G >= ae || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          G === br && (ae & rc) !== Ne
        )
          return o;
      }
      (h & ra) !== Ne && (h |= d & br);
      var ne = i.entangledLanes;
      if (ne !== Ne)
        for (var Ce = i.entanglements, _e = h & ne; _e > 0; ) {
          var Ae = oc(_e), ut = 1 << Ae;
          h |= Ce[Ae], _e &= ~ut;
        }
      return h;
    }
    function E0(i, o) {
      for (var d = i.eventTimes, h = lr; o > 0; ) {
        var b = oc(o), C = 1 << b, R = d[b];
        R > h && (h = R), o &= ~C;
      }
      return h;
    }
    function Rh(i, o) {
      switch (i) {
        case jt:
        case Is:
        case ra:
          return o + 250;
        case Jc:
        case br:
        case eu:
        case tu:
        case Ma:
        case Lo:
        case nu:
        case Of:
        case Df:
        case gh:
        case mh:
        case vh:
        case yh:
        case bh:
        case Sh:
        case wh:
        case xh:
        case ru:
        case Eh:
          return o + 5e3;
        case dl:
        case Ch:
        case Nf:
        case _h:
        case Th:
          return lr;
        case id:
        case od:
        case ic:
        case jo:
          return lr;
        default:
          return c("Should have found matching lanes. This is a bug in React."), lr;
      }
    }
    function lE(i, o) {
      for (var d = i.pendingLanes, h = i.suspendedLanes, b = i.pingedLanes, C = i.expirationTimes, R = d; R > 0; ) {
        var A = oc(R), B = 1 << A, V = C[A];
        V === lr ? ((B & h) === Ne || (B & b) !== Ne) && (C[A] = Rh(B, o)) : V <= o && (i.expiredLanes |= B), R &= ~B;
      }
    }
    function cE(i) {
      return ad(i.pendingLanes);
    }
    function nv(i) {
      var o = i.pendingLanes & ~jo;
      return o !== Ne ? o : o & jo ? jo : Ne;
    }
    function sd(i) {
      return (i & jt) !== Ne;
    }
    function jf(i) {
      return (i & kh) !== Ne;
    }
    function $h(i) {
      return (i & iu) === i;
    }
    function uE(i) {
      var o = jt | ra | br;
      return (i & o) === Ne;
    }
    function C0(i) {
      return (i & rc) === i;
    }
    function zf(i, o) {
      var d = Is | ra | Jc | br;
      return (o & d) !== Ne;
    }
    function _0(i, o) {
      return (o & i.expiredLanes) !== Ne;
    }
    function rv(i) {
      return (i & rc) !== Ne;
    }
    function iv() {
      var i = Ph;
      return Ph <<= 1, (Ph & rc) === Ne && (Ph = tu), i;
    }
    function dE() {
      var i = Ih;
      return Ih <<= 1, (Ih & iu) === Ne && (Ih = dl), i;
    }
    function ii(i) {
      return i & -i;
    }
    function li(i) {
      return ii(i);
    }
    function oc(i) {
      return 31 - ph(i);
    }
    function Mh(i) {
      return oc(i);
    }
    function zo(i, o) {
      return (i & o) !== Ne;
    }
    function ou(i, o) {
      return (i & o) === o;
    }
    function an(i, o) {
      return i | o;
    }
    function ld(i, o) {
      return i & ~o;
    }
    function ov(i, o) {
      return i & o;
    }
    function T0(i) {
      return i;
    }
    function k0(i, o) {
      return i !== En && i < o ? i : o;
    }
    function Ah(i) {
      for (var o = [], d = 0; d < yr; d++)
        o.push(i);
      return o;
    }
    function au(i, o, d) {
      i.pendingLanes |= o, o !== ic && (i.suspendedLanes = Ne, i.pingedLanes = Ne);
      var h = i.eventTimes, b = Mh(o);
      h[b] = d;
    }
    function av(i, o) {
      i.suspendedLanes |= o, i.pingedLanes &= ~o;
      for (var d = i.expirationTimes, h = o; h > 0; ) {
        var b = oc(h), C = 1 << b;
        d[b] = lr, h &= ~C;
      }
    }
    function sv(i, o, d) {
      i.pingedLanes |= i.suspendedLanes & o;
    }
    function lv(i, o) {
      var d = i.pendingLanes & ~o;
      i.pendingLanes = o, i.suspendedLanes = Ne, i.pingedLanes = Ne, i.expiredLanes &= o, i.mutableReadLanes &= o, i.entangledLanes &= o;
      for (var h = i.entanglements, b = i.eventTimes, C = i.expirationTimes, R = d; R > 0; ) {
        var A = oc(R), B = 1 << A;
        h[A] = Ne, b[A] = lr, C[A] = lr, R &= ~B;
      }
    }
    function cd(i, o) {
      for (var d = i.entangledLanes |= o, h = i.entanglements, b = d; b; ) {
        var C = oc(b), R = 1 << C;
        // Is this one of the newly entangled lanes?
        R & o | // Is this lane transitively entangled with the newly entangled lanes?
        h[C] & o && (h[C] |= o), b &= ~R;
      }
    }
    function fE(i, o) {
      var d = ii(o), h;
      switch (d) {
        case ra:
          h = Is;
          break;
        case br:
          h = Jc;
          break;
        case tu:
        case Ma:
        case Lo:
        case nu:
        case Of:
        case Df:
        case gh:
        case mh:
        case vh:
        case yh:
        case bh:
        case Sh:
        case wh:
        case xh:
        case ru:
        case Eh:
        case dl:
        case Ch:
        case Nf:
        case _h:
        case Th:
          h = eu;
          break;
        case ic:
          h = od;
          break;
        default:
          h = En;
          break;
      }
      return (h & (i.suspendedLanes | o)) !== En ? En : h;
    }
    function cv(i, o, d) {
      if (Di)
        for (var h = i.pendingUpdatersLaneMap; d > 0; ) {
          var b = Mh(d), C = 1 << b, R = h[b];
          R.add(o), d &= ~C;
        }
    }
    function Oh(i, o) {
      if (Di)
        for (var d = i.pendingUpdatersLaneMap, h = i.memoizedUpdaters; o > 0; ) {
          var b = Mh(o), C = 1 << b, R = d[b];
          R.size > 0 && (R.forEach(function(A) {
            var B = A.alternate;
            (B === null || !h.has(B)) && h.add(A);
          }), R.clear()), o &= ~C;
        }
    }
    function uv(i, o) {
      return null;
    }
    var qi = jt, Ni = ra, fl = br, Uf = ic, su = En;
    function Aa() {
      return su;
    }
    function ci(i) {
      su = i;
    }
    function Bf(i, o) {
      var d = su;
      try {
        return su = i, o();
      } finally {
        su = d;
      }
    }
    function Qi(i, o) {
      return i !== 0 && i < o ? i : o;
    }
    function pE(i, o) {
      return i === 0 || i > o ? i : o;
    }
    function dv(i, o) {
      return i !== 0 && i < o;
    }
    function Ff(i) {
      var o = ii(i);
      return dv(qi, o) ? dv(Ni, o) ? jf(o) ? fl : Uf : Ni : qi;
    }
    function di(i) {
      var o = i.current.memoizedState;
      return o.isDehydrated;
    }
    var P0;
    function ft(i) {
      P0 = i;
    }
    function ud(i) {
      P0(i);
    }
    var Hf;
    function I0(i) {
      Hf = i;
    }
    var R0;
    function Vf(i) {
      R0 = i;
    }
    var Yf;
    function fv(i) {
      Yf = i;
    }
    var pv;
    function $0(i) {
      pv = i;
    }
    var Dh = !1, dd = [], Rs = null, Pr = null, Ti = null, Oa = /* @__PURE__ */ new Map(), fd = /* @__PURE__ */ new Map(), pl = [], os = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function M0(i) {
      return os.indexOf(i) > -1;
    }
    function $s(i, o, d, h, b) {
      return {
        blockedOn: i,
        domEventName: o,
        eventSystemFlags: d,
        nativeEvent: b,
        targetContainers: [h]
      };
    }
    function A0(i, o) {
      switch (i) {
        case "focusin":
        case "focusout":
          Rs = null;
          break;
        case "dragenter":
        case "dragleave":
          Pr = null;
          break;
        case "mouseover":
        case "mouseout":
          Ti = null;
          break;
        case "pointerover":
        case "pointerout": {
          var d = o.pointerId;
          Oa.delete(d);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var h = o.pointerId;
          fd.delete(h);
          break;
        }
      }
    }
    function pd(i, o, d, h, b, C) {
      if (i === null || i.nativeEvent !== C) {
        var R = $s(o, d, h, b, C);
        if (o !== null) {
          var A = Cd(o);
          A !== null && Hf(A);
        }
        return R;
      }
      i.eventSystemFlags |= h;
      var B = i.targetContainers;
      return b !== null && B.indexOf(b) === -1 && B.push(b), i;
    }
    function O0(i, o, d, h, b) {
      switch (o) {
        case "focusin": {
          var C = b;
          return Rs = pd(Rs, i, o, d, h, C), !0;
        }
        case "dragenter": {
          var R = b;
          return Pr = pd(Pr, i, o, d, h, R), !0;
        }
        case "mouseover": {
          var A = b;
          return Ti = pd(Ti, i, o, d, h, A), !0;
        }
        case "pointerover": {
          var B = b, V = B.pointerId;
          return Oa.set(V, pd(Oa.get(V) || null, i, o, d, h, B)), !0;
        }
        case "gotpointercapture": {
          var G = b, ae = G.pointerId;
          return fd.set(ae, pd(fd.get(ae) || null, i, o, d, h, G)), !0;
        }
      }
      return !1;
    }
    function hv(i) {
      var o = ep(i.target);
      if (o !== null) {
        var d = ea(o);
        if (d !== null) {
          var h = d.tag;
          if (h === z) {
            var b = Hm(d);
            if (b !== null) {
              i.blockedOn = b, pv(i.priority, function() {
                R0(d);
              });
              return;
            }
          } else if (h === v) {
            var C = d.stateNode;
            if (di(C)) {
              i.blockedOn = rh(d);
              return;
            }
          }
        }
      }
      i.blockedOn = null;
    }
    function D0(i) {
      for (var o = Yf(), d = {
        blockedOn: null,
        target: i,
        priority: o
      }, h = 0; h < pl.length && dv(o, pl[h].priority); h++)
        ;
      pl.splice(h, 0, d), h === 0 && hv(d);
    }
    function Nh(i) {
      if (i.blockedOn !== null)
        return !1;
      for (var o = i.targetContainers; o.length > 0; ) {
        var d = o[0], h = lu(i.domEventName, i.eventSystemFlags, d, i.nativeEvent);
        if (h === null) {
          var b = i.nativeEvent, C = new b.constructor(b.type, b);
          Cf(C), b.target.dispatchEvent(C), rE();
        } else {
          var R = Cd(h);
          return R !== null && Hf(R), i.blockedOn = h, !1;
        }
        o.shift();
      }
      return !0;
    }
    function Kf(i, o, d) {
      Nh(i) && d.delete(o);
    }
    function gv() {
      Dh = !1, Rs !== null && Nh(Rs) && (Rs = null), Pr !== null && Nh(Pr) && (Pr = null), Ti !== null && Nh(Ti) && (Ti = null), Oa.forEach(Kf), fd.forEach(Kf);
    }
    function Zi(i, o) {
      i.blockedOn === o && (i.blockedOn = null, Dh || (Dh = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, gv)));
    }
    function mn(i) {
      if (dd.length > 0) {
        Zi(dd[0], i);
        for (var o = 1; o < dd.length; o++) {
          var d = dd[o];
          d.blockedOn === i && (d.blockedOn = null);
        }
      }
      Rs !== null && Zi(Rs, i), Pr !== null && Zi(Pr, i), Ti !== null && Zi(Ti, i);
      var h = function(A) {
        return Zi(A, i);
      };
      Oa.forEach(h), fd.forEach(h);
      for (var b = 0; b < pl.length; b++) {
        var C = pl[b];
        C.blockedOn === i && (C.blockedOn = null);
      }
      for (; pl.length > 0; ) {
        var R = pl[0];
        if (R.blockedOn !== null)
          break;
        hv(R), R.blockedOn === null && pl.shift();
      }
    }
    var Dr = n.ReactCurrentBatchConfig, Vr = !0;
    function ki(i) {
      Vr = !!i;
    }
    function ia() {
      return Vr;
    }
    function hd(i, o, d) {
      var h = po(o), b;
      switch (h) {
        case qi:
          b = fi;
          break;
        case Ni:
          b = Wf;
          break;
        case fl:
        default:
          b = hl;
          break;
      }
      return b.bind(null, o, d, i);
    }
    function fi(i, o, d, h) {
      var b = Aa(), C = Dr.transition;
      Dr.transition = null;
      try {
        ci(qi), hl(i, o, d, h);
      } finally {
        ci(b), Dr.transition = C;
      }
    }
    function Wf(i, o, d, h) {
      var b = Aa(), C = Dr.transition;
      Dr.transition = null;
      try {
        ci(Ni), hl(i, o, d, h);
      } finally {
        ci(b), Dr.transition = C;
      }
    }
    function hl(i, o, d, h) {
      Vr && Lh(i, o, d, h);
    }
    function Lh(i, o, d, h) {
      var b = lu(i, o, d, h);
      if (b === null) {
        AE(i, o, h, gd, d), A0(i, h);
        return;
      }
      if (O0(b, i, o, d, h)) {
        h.stopPropagation();
        return;
      }
      if (A0(i, h), o & Vc && M0(i)) {
        for (; b !== null; ) {
          var C = Cd(b);
          C !== null && ud(C);
          var R = lu(i, o, d, h);
          if (R === null && AE(i, o, h, gd, d), R === b)
            break;
          b = R;
        }
        b !== null && h.stopPropagation();
        return;
      }
      AE(i, o, h, null, d);
    }
    var gd = null;
    function lu(i, o, d, h) {
      gd = null;
      var b = Zp(h), C = ep(b);
      if (C !== null) {
        var R = ea(C);
        if (R === null)
          C = null;
        else {
          var A = R.tag;
          if (A === z) {
            var B = Hm(R);
            if (B !== null)
              return B;
            C = null;
          } else if (A === v) {
            var V = R.stateNode;
            if (di(V))
              return rh(R);
            C = null;
          } else
            R !== C && (C = null);
        }
      }
      return gd = C, null;
    }
    function po(i) {
      switch (i) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return qi;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Ni;
        case "message": {
          var o = Km();
          switch (o) {
            case sh:
              return qi;
            case na:
              return Ni;
            case Ps:
            case lh:
              return fl;
            case Ql:
              return Uf;
            default:
              return fl;
          }
        }
        default:
          return fl;
      }
    }
    function mv(i, o, d) {
      return i.addEventListener(o, d, !1), d;
    }
    function md(i, o, d) {
      return i.addEventListener(o, d, !0), d;
    }
    function gl(i, o, d, h) {
      return i.addEventListener(o, d, {
        capture: !0,
        passive: h
      }), d;
    }
    function jh(i, o, d, h) {
      return i.addEventListener(o, d, {
        passive: h
      }), d;
    }
    var cu = null, Ms = null, ac = null;
    function sc(i) {
      return cu = i, Ms = Uh(), !0;
    }
    function zh() {
      cu = null, Ms = null, ac = null;
    }
    function vd() {
      if (ac)
        return ac;
      var i, o = Ms, d = o.length, h, b = Uh(), C = b.length;
      for (i = 0; i < d && o[i] === b[i]; i++)
        ;
      var R = d - i;
      for (h = 1; h <= R && o[d - h] === b[C - h]; h++)
        ;
      var A = h > 1 ? 1 - h : void 0;
      return ac = b.slice(i, A), ac;
    }
    function Uh() {
      return "value" in cu ? cu.value : cu.textContent;
    }
    function uu(i) {
      var o, d = i.keyCode;
      return "charCode" in i ? (o = i.charCode, o === 0 && d === 13 && (o = 13)) : o = d, o === 10 && (o = 13), o >= 32 || o === 13 ? o : 0;
    }
    function du() {
      return !0;
    }
    function Ji() {
      return !1;
    }
    function oi(i) {
      function o(d, h, b, C, R) {
        this._reactName = d, this._targetInst = b, this.type = h, this.nativeEvent = C, this.target = R, this.currentTarget = null;
        for (var A in i)
          if (i.hasOwnProperty(A)) {
            var B = i[A];
            B ? this[A] = B(C) : this[A] = C[A];
          }
        var V = C.defaultPrevented != null ? C.defaultPrevented : C.returnValue === !1;
        return V ? this.isDefaultPrevented = du : this.isDefaultPrevented = Ji, this.isPropagationStopped = Ji, this;
      }
      return Jt(o.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var d = this.nativeEvent;
          d && (d.preventDefault ? d.preventDefault() : typeof d.returnValue != "unknown" && (d.returnValue = !1), this.isDefaultPrevented = du);
        },
        stopPropagation: function() {
          var d = this.nativeEvent;
          d && (d.stopPropagation ? d.stopPropagation() : typeof d.cancelBubble != "unknown" && (d.cancelBubble = !0), this.isPropagationStopped = du);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: du
      }), o;
    }
    var eo = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(i) {
        return i.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, to = oi(eo), yd = Jt({}, eo, {
      view: 0,
      detail: 0
    }), vv = oi(yd), Gf, yv, Da;
    function N0(i) {
      i !== Da && (Da && i.type === "mousemove" ? (Gf = i.screenX - Da.screenX, yv = i.screenY - Da.screenY) : (Gf = 0, yv = 0), Da = i);
    }
    var bd = Jt({}, yd, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Hh,
      button: 0,
      buttons: 0,
      relatedTarget: function(i) {
        return i.relatedTarget === void 0 ? i.fromElement === i.srcElement ? i.toElement : i.fromElement : i.relatedTarget;
      },
      movementX: function(i) {
        return "movementX" in i ? i.movementX : (N0(i), Gf);
      },
      movementY: function(i) {
        return "movementY" in i ? i.movementY : yv;
      }
    }), lc = oi(bd), bv = Jt({}, bd, {
      dataTransfer: 0
    }), fu = oi(bv), L0 = Jt({}, yd, {
      relatedTarget: 0
    }), Bh = oi(L0), Sv = Jt({}, eo, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Fh = oi(Sv), hE = Jt({}, eo, {
      clipboardData: function(i) {
        return "clipboardData" in i ? i.clipboardData : window.clipboardData;
      }
    }), gE = oi(hE), j0 = Jt({}, eo, {
      data: 0
    }), wv = oi(j0), pu = wv, mE = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Sd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function z0(i) {
      if (i.key) {
        var o = mE[i.key] || i.key;
        if (o !== "Unidentified")
          return o;
      }
      if (i.type === "keypress") {
        var d = uu(i);
        return d === 13 ? "Enter" : String.fromCharCode(d);
      }
      return i.type === "keydown" || i.type === "keyup" ? Sd[i.keyCode] || "Unidentified" : "";
    }
    var Yr = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function vE(i) {
      var o = this, d = o.nativeEvent;
      if (d.getModifierState)
        return d.getModifierState(i);
      var h = Yr[i];
      return h ? !!d[h] : !1;
    }
    function Hh(i) {
      return vE;
    }
    var yE = Jt({}, yd, {
      key: z0,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Hh,
      // Legacy Interface
      charCode: function(i) {
        return i.type === "keypress" ? uu(i) : 0;
      },
      keyCode: function(i) {
        return i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
      },
      which: function(i) {
        return i.type === "keypress" ? uu(i) : i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
      }
    }), bE = oi(yE), U0 = Jt({}, bd, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), xv = oi(U0), SE = Jt({}, yd, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Hh
    }), Na = oi(SE), Ev = Jt({}, eo, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), wE = oi(Ev), cc = Jt({}, bd, {
      deltaX: function(i) {
        return "deltaX" in i ? i.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in i ? -i.wheelDeltaX : 0
        );
      },
      deltaY: function(i) {
        return "deltaY" in i ? i.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in i ? -i.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in i ? -i.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), Vh = oi(cc), hu = [9, 13, 27, 32], Xf = 229, qf = Nt && "CompositionEvent" in window, gu = null;
    Nt && "documentMode" in document && (gu = document.documentMode);
    var xE = Nt && "TextEvent" in window && !gu, Yh = Nt && (!qf || gu && gu > 8 && gu <= 11), B0 = 32, Cv = String.fromCharCode(B0);
    function F0() {
      Tt("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Tt("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Tt("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Tt("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Qf = !1;
    function Kh(i) {
      return (i.ctrlKey || i.altKey || i.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(i.ctrlKey && i.altKey);
    }
    function H0(i) {
      switch (i) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function _v(i, o) {
      return i === "keydown" && o.keyCode === Xf;
    }
    function V0(i, o) {
      switch (i) {
        case "keyup":
          return hu.indexOf(o.keyCode) !== -1;
        case "keydown":
          return o.keyCode !== Xf;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function Tv(i) {
      var o = i.detail;
      return typeof o == "object" && "data" in o ? o.data : null;
    }
    function Wh(i) {
      return i.locale === "ko";
    }
    var ml = !1;
    function kv(i, o, d, h, b) {
      var C, R;
      if (qf ? C = H0(o) : ml ? V0(o, h) && (C = "onCompositionEnd") : _v(o, h) && (C = "onCompositionStart"), !C)
        return null;
      Yh && !Wh(h) && (!ml && C === "onCompositionStart" ? ml = sc(b) : C === "onCompositionEnd" && ml && (R = vd()));
      var A = X0(d, C);
      if (A.length > 0) {
        var B = new wv(C, o, null, h, b);
        if (i.push({
          event: B,
          listeners: A
        }), R)
          B.data = R;
        else {
          var V = Tv(h);
          V !== null && (B.data = V);
        }
      }
    }
    function Gh(i, o) {
      switch (i) {
        case "compositionend":
          return Tv(o);
        case "keypress":
          var d = o.which;
          return d !== B0 ? null : (Qf = !0, Cv);
        case "textInput":
          var h = o.data;
          return h === Cv && Qf ? null : h;
        default:
          return null;
      }
    }
    function Y0(i, o) {
      if (ml) {
        if (i === "compositionend" || !qf && V0(i, o)) {
          var d = vd();
          return zh(), ml = !1, d;
        }
        return null;
      }
      switch (i) {
        case "paste":
          return null;
        case "keypress":
          if (!Kh(o)) {
            if (o.char && o.char.length > 1)
              return o.char;
            if (o.which)
              return String.fromCharCode(o.which);
          }
          return null;
        case "compositionend":
          return Yh && !Wh(o) ? null : o.data;
        default:
          return null;
      }
    }
    function EE(i, o, d, h, b) {
      var C;
      if (xE ? C = Gh(o, h) : C = Y0(o, h), !C)
        return null;
      var R = X0(d, "onBeforeInput");
      if (R.length > 0) {
        var A = new pu("onBeforeInput", "beforeinput", null, h, b);
        i.push({
          event: A,
          listeners: R
        }), A.data = C;
      }
    }
    function Xh(i, o, d, h, b, C, R) {
      kv(i, o, d, h, b), EE(i, o, d, h, b);
    }
    var CE = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function wd(i) {
      var o = i && i.nodeName && i.nodeName.toLowerCase();
      return o === "input" ? !!CE[i.type] : o === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function _E(i) {
      if (!Nt)
        return !1;
      var o = "on" + i, d = o in document;
      if (!d) {
        var h = document.createElement("div");
        h.setAttribute(o, "return;"), d = typeof h[o] == "function";
      }
      return d;
    }
    function qh() {
      Tt("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function l(i, o, d, h) {
      Jp(h);
      var b = X0(o, "onChange");
      if (b.length > 0) {
        var C = new to("onChange", "change", null, d, h);
        i.push({
          event: C,
          listeners: b
        });
      }
    }
    var u = null, m = null;
    function w(i) {
      var o = i.nodeName && i.nodeName.toLowerCase();
      return o === "select" || o === "input" && i.type === "file";
    }
    function P(i) {
      var o = [];
      l(o, m, i, Zp(i)), Dm(M, o);
    }
    function M(i) {
      nR(i, 0);
    }
    function H(i) {
      var o = ng(i);
      if (Ue(o))
        return i;
    }
    function Q(i, o) {
      if (i === "change")
        return o;
    }
    var ee = !1;
    Nt && (ee = _E("input") && (!document.documentMode || document.documentMode > 9));
    function Te(i, o) {
      u = i, m = o, u.attachEvent("onpropertychange", Ye);
    }
    function Ve() {
      u && (u.detachEvent("onpropertychange", Ye), u = null, m = null);
    }
    function Ye(i) {
      i.propertyName === "value" && H(m) && P(i);
    }
    function He(i, o, d) {
      i === "focusin" ? (Ve(), Te(o, d)) : i === "focusout" && Ve();
    }
    function lt(i, o) {
      if (i === "selectionchange" || i === "keyup" || i === "keydown")
        return H(m);
    }
    function gt(i) {
      var o = i.nodeName;
      return o && o.toLowerCase() === "input" && (i.type === "checkbox" || i.type === "radio");
    }
    function wt(i, o) {
      if (i === "click")
        return H(o);
    }
    function qr(i, o) {
      if (i === "input" || i === "change")
        return H(o);
    }
    function ge(i) {
      var o = i._wrapperState;
      !o || !o.controlled || i.type !== "number" || bt(i, "number", i.value);
    }
    function oe(i, o, d, h, b, C, R) {
      var A = d ? ng(d) : window, B, V;
      if (w(A) ? B = Q : wd(A) ? ee ? B = qr : (B = lt, V = He) : gt(A) && (B = wt), B) {
        var G = B(o, d);
        if (G) {
          l(i, G, h, b);
          return;
        }
      }
      V && V(o, A, d), o === "focusout" && ge(A);
    }
    function we() {
      Le("onMouseEnter", ["mouseout", "mouseover"]), Le("onMouseLeave", ["mouseout", "mouseover"]), Le("onPointerEnter", ["pointerout", "pointerover"]), Le("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function Xe(i, o, d, h, b, C, R) {
      var A = o === "mouseover" || o === "pointerover", B = o === "mouseout" || o === "pointerout";
      if (A && !l0(h)) {
        var V = h.relatedTarget || h.fromElement;
        if (V && (ep(V) || Bv(V)))
          return;
      }
      if (!(!B && !A)) {
        var G;
        if (b.window === b)
          G = b;
        else {
          var ae = b.ownerDocument;
          ae ? G = ae.defaultView || ae.parentWindow : G = window;
        }
        var ne, Ce;
        if (B) {
          var _e = h.relatedTarget || h.toElement;
          if (ne = d, Ce = _e ? ep(_e) : null, Ce !== null) {
            var Ae = ea(Ce);
            (Ce !== Ae || Ce.tag !== x && Ce.tag !== _) && (Ce = null);
          }
        } else
          ne = null, Ce = d;
        if (ne !== Ce) {
          var ut = lc, Ot = "onMouseLeave", Pt = "onMouseEnter", _n = "mouse";
          (o === "pointerout" || o === "pointerover") && (ut = xv, Ot = "onPointerLeave", Pt = "onPointerEnter", _n = "pointer");
          var vn = ne == null ? G : ng(ne), be = Ce == null ? G : ng(Ce), Oe = new ut(Ot, _n + "leave", ne, h, b);
          Oe.target = vn, Oe.relatedTarget = be;
          var Se = null, We = ep(b);
          if (We === d) {
            var dt = new ut(Pt, _n + "enter", Ce, h, b);
            dt.target = be, dt.relatedTarget = vn, Se = dt;
          }
          g6(i, Oe, Se, ne, Ce);
        }
      }
    }
    function Ct(i, o) {
      return i === o && (i !== 0 || 1 / i === 1 / o) || i !== i && o !== o;
    }
    var mt = typeof Object.is == "function" ? Object.is : Ct;
    function $t(i, o) {
      if (mt(i, o))
        return !0;
      if (typeof i != "object" || i === null || typeof o != "object" || o === null)
        return !1;
      var d = Object.keys(i), h = Object.keys(o);
      if (d.length !== h.length)
        return !1;
      for (var b = 0; b < d.length; b++) {
        var C = d[b];
        if (!Ke.call(o, C) || !mt(i[C], o[C]))
          return !1;
      }
      return !0;
    }
    function Vt(i) {
      for (; i && i.firstChild; )
        i = i.firstChild;
      return i;
    }
    function Pi(i) {
      for (; i; ) {
        if (i.nextSibling)
          return i.nextSibling;
        i = i.parentNode;
      }
    }
    function Rn(i, o) {
      for (var d = Vt(i), h = 0, b = 0; d; ) {
        if (d.nodeType === rl) {
          if (b = h + d.textContent.length, h <= o && b >= o)
            return {
              node: d,
              offset: o - h
            };
          h = b;
        }
        d = Vt(Pi(d));
      }
    }
    function uc(i) {
      var o = i.ownerDocument, d = o && o.defaultView || window, h = d.getSelection && d.getSelection();
      if (!h || h.rangeCount === 0)
        return null;
      var b = h.anchorNode, C = h.anchorOffset, R = h.focusNode, A = h.focusOffset;
      try {
        b.nodeType, R.nodeType;
      } catch {
        return null;
      }
      return TE(i, b, C, R, A);
    }
    function TE(i, o, d, h, b) {
      var C = 0, R = -1, A = -1, B = 0, V = 0, G = i, ae = null;
      e:
        for (; ; ) {
          for (var ne = null; G === o && (d === 0 || G.nodeType === rl) && (R = C + d), G === h && (b === 0 || G.nodeType === rl) && (A = C + b), G.nodeType === rl && (C += G.nodeValue.length), (ne = G.firstChild) !== null; )
            ae = G, G = ne;
          for (; ; ) {
            if (G === i)
              break e;
            if (ae === o && ++B === d && (R = C), ae === h && ++V === b && (A = C), (ne = G.nextSibling) !== null)
              break;
            G = ae, ae = G.parentNode;
          }
          G = ne;
        }
      return R === -1 || A === -1 ? null : {
        start: R,
        end: A
      };
    }
    function q5(i, o) {
      var d = i.ownerDocument || document, h = d && d.defaultView || window;
      if (h.getSelection) {
        var b = h.getSelection(), C = i.textContent.length, R = Math.min(o.start, C), A = o.end === void 0 ? R : Math.min(o.end, C);
        if (!b.extend && R > A) {
          var B = A;
          A = R, R = B;
        }
        var V = Rn(i, R), G = Rn(i, A);
        if (V && G) {
          if (b.rangeCount === 1 && b.anchorNode === V.node && b.anchorOffset === V.offset && b.focusNode === G.node && b.focusOffset === G.offset)
            return;
          var ae = d.createRange();
          ae.setStart(V.node, V.offset), b.removeAllRanges(), R > A ? (b.addRange(ae), b.extend(G.node, G.offset)) : (ae.setEnd(G.node, G.offset), b.addRange(ae));
        }
      }
    }
    function V2(i) {
      return i && i.nodeType === rl;
    }
    function Y2(i, o) {
      return !i || !o ? !1 : i === o ? !0 : V2(i) ? !1 : V2(o) ? Y2(i, o.parentNode) : "contains" in i ? i.contains(o) : i.compareDocumentPosition ? !!(i.compareDocumentPosition(o) & 16) : !1;
    }
    function Q5(i) {
      return i && i.ownerDocument && Y2(i.ownerDocument.documentElement, i);
    }
    function Z5(i) {
      try {
        return typeof i.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function K2() {
      for (var i = window, o = it(); o instanceof i.HTMLIFrameElement; ) {
        if (Z5(o))
          i = o.contentWindow;
        else
          return o;
        o = it(i.document);
      }
      return o;
    }
    function kE(i) {
      var o = i && i.nodeName && i.nodeName.toLowerCase();
      return o && (o === "input" && (i.type === "text" || i.type === "search" || i.type === "tel" || i.type === "url" || i.type === "password") || o === "textarea" || i.contentEditable === "true");
    }
    function J5() {
      var i = K2();
      return {
        focusedElem: i,
        selectionRange: kE(i) ? t6(i) : null
      };
    }
    function e6(i) {
      var o = K2(), d = i.focusedElem, h = i.selectionRange;
      if (o !== d && Q5(d)) {
        h !== null && kE(d) && n6(d, h);
        for (var b = [], C = d; C = C.parentNode; )
          C.nodeType === $o && b.push({
            element: C,
            left: C.scrollLeft,
            top: C.scrollTop
          });
        typeof d.focus == "function" && d.focus();
        for (var R = 0; R < b.length; R++) {
          var A = b[R];
          A.element.scrollLeft = A.left, A.element.scrollTop = A.top;
        }
      }
    }
    function t6(i) {
      var o;
      return "selectionStart" in i ? o = {
        start: i.selectionStart,
        end: i.selectionEnd
      } : o = uc(i), o || {
        start: 0,
        end: 0
      };
    }
    function n6(i, o) {
      var d = o.start, h = o.end;
      h === void 0 && (h = d), "selectionStart" in i ? (i.selectionStart = d, i.selectionEnd = Math.min(h, i.value.length)) : q5(i, o);
    }
    var r6 = Nt && "documentMode" in document && document.documentMode <= 11;
    function i6() {
      Tt("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var Qh = null, PE = null, Pv = null, IE = !1;
    function o6(i) {
      if ("selectionStart" in i && kE(i))
        return {
          start: i.selectionStart,
          end: i.selectionEnd
        };
      var o = i.ownerDocument && i.ownerDocument.defaultView || window, d = o.getSelection();
      return {
        anchorNode: d.anchorNode,
        anchorOffset: d.anchorOffset,
        focusNode: d.focusNode,
        focusOffset: d.focusOffset
      };
    }
    function a6(i) {
      return i.window === i ? i.document : i.nodeType === ts ? i : i.ownerDocument;
    }
    function W2(i, o, d) {
      var h = a6(d);
      if (!(IE || Qh == null || Qh !== it(h))) {
        var b = o6(Qh);
        if (!Pv || !$t(Pv, b)) {
          Pv = b;
          var C = X0(PE, "onSelect");
          if (C.length > 0) {
            var R = new to("onSelect", "select", null, o, d);
            i.push({
              event: R,
              listeners: C
            }), R.target = Qh;
          }
        }
      }
    }
    function s6(i, o, d, h, b, C, R) {
      var A = d ? ng(d) : window;
      switch (o) {
        case "focusin":
          (wd(A) || A.contentEditable === "true") && (Qh = A, PE = d, Pv = null);
          break;
        case "focusout":
          Qh = null, PE = null, Pv = null;
          break;
        case "mousedown":
          IE = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          IE = !1, W2(i, h, b);
          break;
        case "selectionchange":
          if (r6)
            break;
        case "keydown":
        case "keyup":
          W2(i, h, b);
      }
    }
    function K0(i, o) {
      var d = {};
      return d[i.toLowerCase()] = o.toLowerCase(), d["Webkit" + i] = "webkit" + o, d["Moz" + i] = "moz" + o, d;
    }
    var Zh = {
      animationend: K0("Animation", "AnimationEnd"),
      animationiteration: K0("Animation", "AnimationIteration"),
      animationstart: K0("Animation", "AnimationStart"),
      transitionend: K0("Transition", "TransitionEnd")
    }, RE = {}, G2 = {};
    Nt && (G2 = document.createElement("div").style, "AnimationEvent" in window || (delete Zh.animationend.animation, delete Zh.animationiteration.animation, delete Zh.animationstart.animation), "TransitionEvent" in window || delete Zh.transitionend.transition);
    function W0(i) {
      if (RE[i])
        return RE[i];
      if (!Zh[i])
        return i;
      var o = Zh[i];
      for (var d in o)
        if (o.hasOwnProperty(d) && d in G2)
          return RE[i] = o[d];
      return i;
    }
    var X2 = W0("animationend"), q2 = W0("animationiteration"), Q2 = W0("animationstart"), Z2 = W0("transitionend"), J2 = /* @__PURE__ */ new Map(), eR = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function xd(i, o) {
      J2.set(i, o), Tt(o, [i]);
    }
    function l6() {
      for (var i = 0; i < eR.length; i++) {
        var o = eR[i], d = o.toLowerCase(), h = o[0].toUpperCase() + o.slice(1);
        xd(d, "on" + h);
      }
      xd(X2, "onAnimationEnd"), xd(q2, "onAnimationIteration"), xd(Q2, "onAnimationStart"), xd("dblclick", "onDoubleClick"), xd("focusin", "onFocus"), xd("focusout", "onBlur"), xd(Z2, "onTransitionEnd");
    }
    function c6(i, o, d, h, b, C, R) {
      var A = J2.get(o);
      if (A !== void 0) {
        var B = to, V = o;
        switch (o) {
          case "keypress":
            if (uu(h) === 0)
              return;
          case "keydown":
          case "keyup":
            B = bE;
            break;
          case "focusin":
            V = "focus", B = Bh;
            break;
          case "focusout":
            V = "blur", B = Bh;
            break;
          case "beforeblur":
          case "afterblur":
            B = Bh;
            break;
          case "click":
            if (h.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            B = lc;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            B = fu;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            B = Na;
            break;
          case X2:
          case q2:
          case Q2:
            B = Fh;
            break;
          case Z2:
            B = wE;
            break;
          case "scroll":
            B = vv;
            break;
          case "wheel":
            B = Vh;
            break;
          case "copy":
          case "cut":
          case "paste":
            B = gE;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            B = xv;
            break;
        }
        var G = (C & Vc) !== 0;
        {
          var ae = !G && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          o === "scroll", ne = p6(d, A, h.type, G, ae);
          if (ne.length > 0) {
            var Ce = new B(A, V, null, h, b);
            i.push({
              event: Ce,
              listeners: ne
            });
          }
        }
      }
    }
    l6(), we(), qh(), i6(), F0();
    function u6(i, o, d, h, b, C, R) {
      c6(i, o, d, h, b, C);
      var A = (C & nE) === 0;
      A && (Xe(i, o, d, h, b), oe(i, o, d, h, b), s6(i, o, d, h, b), Xh(i, o, d, h, b));
    }
    var Iv = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], $E = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(Iv));
    function tR(i, o, d) {
      var h = i.type || "unknown-event";
      i.currentTarget = d, sl(h, o, void 0, i), i.currentTarget = null;
    }
    function d6(i, o, d) {
      var h;
      if (d)
        for (var b = o.length - 1; b >= 0; b--) {
          var C = o[b], R = C.instance, A = C.currentTarget, B = C.listener;
          if (R !== h && i.isPropagationStopped())
            return;
          tR(i, B, A), h = R;
        }
      else
        for (var V = 0; V < o.length; V++) {
          var G = o[V], ae = G.instance, ne = G.currentTarget, Ce = G.listener;
          if (ae !== h && i.isPropagationStopped())
            return;
          tR(i, Ce, ne), h = ae;
        }
    }
    function nR(i, o) {
      for (var d = (o & Vc) !== 0, h = 0; h < i.length; h++) {
        var b = i[h], C = b.event, R = b.listeners;
        d6(C, R, d);
      }
      zm();
    }
    function f6(i, o, d, h, b) {
      var C = Zp(d), R = [];
      u6(R, i, h, d, C, o), nR(R, o);
    }
    function Nr(i, o) {
      $E.has(i) || c('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', i);
      var d = !1, h = FU(o), b = m6(i, d);
      h.has(b) || (rR(o, i, xf, d), h.add(b));
    }
    function ME(i, o, d) {
      $E.has(i) && !o && c('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', i);
      var h = 0;
      o && (h |= Vc), rR(d, i, h, o);
    }
    var G0 = "_reactListening" + Math.random().toString(36).slice(2);
    function Rv(i) {
      if (!i[G0]) {
        i[G0] = !0, ke.forEach(function(d) {
          d !== "selectionchange" && ($E.has(d) || ME(d, !1, i), ME(d, !0, i));
        });
        var o = i.nodeType === ts ? i : i.ownerDocument;
        o !== null && (o[G0] || (o[G0] = !0, ME("selectionchange", !1, o)));
      }
    }
    function rR(i, o, d, h, b) {
      var C = hd(i, o, d), R = void 0;
      kf && (o === "touchstart" || o === "touchmove" || o === "wheel") && (R = !0), i = i, h ? R !== void 0 ? gl(i, o, C, R) : md(i, o, C) : R !== void 0 ? jh(i, o, C, R) : mv(i, o, C);
    }
    function iR(i, o) {
      return i === o || i.nodeType === ri && i.parentNode === o;
    }
    function AE(i, o, d, h, b) {
      var C = h;
      if (!(o & ol) && !(o & xf)) {
        var R = b;
        if (h !== null) {
          var A = h;
          e:
            for (; ; ) {
              if (A === null)
                return;
              var B = A.tag;
              if (B === v || B === S) {
                var V = A.stateNode.containerInfo;
                if (iR(V, R))
                  break;
                if (B === S)
                  for (var G = A.return; G !== null; ) {
                    var ae = G.tag;
                    if (ae === v || ae === S) {
                      var ne = G.stateNode.containerInfo;
                      if (iR(ne, R))
                        return;
                    }
                    G = G.return;
                  }
                for (; V !== null; ) {
                  var Ce = ep(V);
                  if (Ce === null)
                    return;
                  var _e = Ce.tag;
                  if (_e === x || _e === _) {
                    A = C = Ce;
                    continue e;
                  }
                  V = V.parentNode;
                }
              }
              A = A.return;
            }
        }
      }
      Dm(function() {
        return f6(i, o, d, C);
      });
    }
    function $v(i, o, d) {
      return {
        instance: i,
        listener: o,
        currentTarget: d
      };
    }
    function p6(i, o, d, h, b, C) {
      for (var R = o !== null ? o + "Capture" : null, A = h ? R : o, B = [], V = i, G = null; V !== null; ) {
        var ae = V, ne = ae.stateNode, Ce = ae.tag;
        if (Ce === x && ne !== null && (G = ne, A !== null)) {
          var _e = Kc(V, A);
          _e != null && B.push($v(V, _e, G));
        }
        if (b)
          break;
        V = V.return;
      }
      return B;
    }
    function X0(i, o) {
      for (var d = o + "Capture", h = [], b = i; b !== null; ) {
        var C = b, R = C.stateNode, A = C.tag;
        if (A === x && R !== null) {
          var B = R, V = Kc(b, d);
          V != null && h.unshift($v(b, V, B));
          var G = Kc(b, o);
          G != null && h.push($v(b, G, B));
        }
        b = b.return;
      }
      return h;
    }
    function Jh(i) {
      if (i === null)
        return null;
      do
        i = i.return;
      while (i && i.tag !== x);
      return i || null;
    }
    function h6(i, o) {
      for (var d = i, h = o, b = 0, C = d; C; C = Jh(C))
        b++;
      for (var R = 0, A = h; A; A = Jh(A))
        R++;
      for (; b - R > 0; )
        d = Jh(d), b--;
      for (; R - b > 0; )
        h = Jh(h), R--;
      for (var B = b; B--; ) {
        if (d === h || h !== null && d === h.alternate)
          return d;
        d = Jh(d), h = Jh(h);
      }
      return null;
    }
    function oR(i, o, d, h, b) {
      for (var C = o._reactName, R = [], A = d; A !== null && A !== h; ) {
        var B = A, V = B.alternate, G = B.stateNode, ae = B.tag;
        if (V !== null && V === h)
          break;
        if (ae === x && G !== null) {
          var ne = G;
          if (b) {
            var Ce = Kc(A, C);
            Ce != null && R.unshift($v(A, Ce, ne));
          } else if (!b) {
            var _e = Kc(A, C);
            _e != null && R.push($v(A, _e, ne));
          }
        }
        A = A.return;
      }
      R.length !== 0 && i.push({
        event: o,
        listeners: R
      });
    }
    function g6(i, o, d, h, b) {
      var C = h && b ? h6(h, b) : null;
      h !== null && oR(i, o, h, C, !1), b !== null && d !== null && oR(i, d, b, C, !0);
    }
    function m6(i, o) {
      return i + "__" + (o ? "capture" : "bubble");
    }
    var La = !1, Mv = "dangerouslySetInnerHTML", q0 = "suppressContentEditableWarning", Ed = "suppressHydrationWarning", aR = "autoFocus", Zf = "children", Jf = "style", Q0 = "__html", OE, Z0, Av, sR, J0, lR, cR;
    OE = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, Z0 = function(i, o) {
      Qp(i, o), Rm(i, o), s0(i, o, {
        registrationNameDependencies: rt,
        possibleRegistrationNames: St
      });
    }, lR = Nt && !document.documentMode, Av = function(i, o, d) {
      if (!La) {
        var h = eS(d), b = eS(o);
        b !== h && (La = !0, c("Prop `%s` did not match. Server: %s Client: %s", i, JSON.stringify(b), JSON.stringify(h)));
      }
    }, sR = function(i) {
      if (!La) {
        La = !0;
        var o = [];
        i.forEach(function(d) {
          o.push(d);
        }), c("Extra attributes from the server: %s", o);
      }
    }, J0 = function(i, o) {
      o === !1 ? c("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", i, i, i) : c("Expected `%s` listener to be a function, instead got a value of `%s` type.", i, typeof o);
    }, cR = function(i, o) {
      var d = i.namespaceURI === nl ? i.ownerDocument.createElement(i.tagName) : i.ownerDocument.createElementNS(i.namespaceURI, i.tagName);
      return d.innerHTML = o, d.innerHTML;
    };
    var v6 = /\r\n?/g, y6 = /\u0000|\uFFFD/g;
    function eS(i) {
      Ur(i);
      var o = typeof i == "string" ? i : "" + i;
      return o.replace(v6, `
`).replace(y6, "");
    }
    function tS(i, o, d, h) {
      var b = eS(o), C = eS(i);
      if (C !== b && (h && (La || (La = !0, c('Text content did not match. Server: "%s" Client: "%s"', C, b))), d && he))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function uR(i) {
      return i.nodeType === ts ? i : i.ownerDocument;
    }
    function b6() {
    }
    function nS(i) {
      i.onclick = b6;
    }
    function S6(i, o, d, h, b) {
      for (var C in h)
        if (h.hasOwnProperty(C)) {
          var R = h[C];
          if (C === Jf)
            R && Object.freeze(R), Qb(o, R);
          else if (C === Mv) {
            var A = R ? R[Q0] : void 0;
            A != null && Ub(o, A);
          } else if (C === Zf)
            if (typeof R == "string") {
              var B = i !== "textarea" || R !== "";
              B && Wp(o, R);
            } else
              typeof R == "number" && Wp(o, "" + R);
          else
            C === q0 || C === Ed || C === aR || (rt.hasOwnProperty(C) ? R != null && (typeof R != "function" && J0(C, R), C === "onScroll" && Nr("scroll", o)) : R != null && co(o, C, R, b));
        }
    }
    function w6(i, o, d, h) {
      for (var b = 0; b < o.length; b += 2) {
        var C = o[b], R = o[b + 1];
        C === Jf ? Qb(i, R) : C === Mv ? Ub(i, R) : C === Zf ? Wp(i, R) : co(i, C, R, h);
      }
    }
    function x6(i, o, d, h) {
      var b, C = uR(d), R, A = h;
      if (A === nl && (A = Yp(i)), A === nl) {
        if (b = il(i, o), !b && i !== i.toLowerCase() && c("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", i), i === "script") {
          var B = C.createElement("div");
          B.innerHTML = "<script><\/script>";
          var V = B.firstChild;
          R = B.removeChild(V);
        } else if (typeof o.is == "string")
          R = C.createElement(i, {
            is: o.is
          });
        else if (R = C.createElement(i), i === "select") {
          var G = R;
          o.multiple ? G.multiple = !0 : o.size && (G.size = o.size);
        }
      } else
        R = C.createElementNS(A, i);
      return A === nl && !b && Object.prototype.toString.call(R) === "[object HTMLUnknownElement]" && !Ke.call(OE, i) && (OE[i] = !0, c("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", i)), R;
    }
    function E6(i, o) {
      return uR(o).createTextNode(i);
    }
    function C6(i, o, d, h) {
      var b = il(o, d);
      Z0(o, d);
      var C;
      switch (o) {
        case "dialog":
          Nr("cancel", i), Nr("close", i), C = d;
          break;
        case "iframe":
        case "object":
        case "embed":
          Nr("load", i), C = d;
          break;
        case "video":
        case "audio":
          for (var R = 0; R < Iv.length; R++)
            Nr(Iv[R], i);
          C = d;
          break;
        case "source":
          Nr("error", i), C = d;
          break;
        case "img":
        case "image":
        case "link":
          Nr("error", i), Nr("load", i), C = d;
          break;
        case "details":
          Nr("toggle", i), C = d;
          break;
        case "input":
          Z(i, d), C = U(i, d), Nr("invalid", i);
          break;
        case "option":
          In(i, d), C = d;
          break;
        case "select":
          yf(i, d), C = vf(i, d), Nr("invalid", i);
          break;
        case "textarea":
          Lb(i, d), C = wm(i, d), Nr("invalid", i);
          break;
        default:
          C = d;
      }
      switch (Xp(o, C), S6(o, i, h, C, b), o) {
        case "input":
          ie(i), Fe(i, d, !1);
          break;
        case "textarea":
          ie(i), zb(i);
          break;
        case "option":
          ar(i, d);
          break;
        case "select":
          bm(i, d);
          break;
        default:
          typeof C.onClick == "function" && nS(i);
          break;
      }
    }
    function _6(i, o, d, h, b) {
      Z0(o, h);
      var C = null, R, A;
      switch (o) {
        case "input":
          R = U(i, d), A = U(i, h), C = [];
          break;
        case "select":
          R = vf(i, d), A = vf(i, h), C = [];
          break;
        case "textarea":
          R = wm(i, d), A = wm(i, h), C = [];
          break;
        default:
          R = d, A = h, typeof R.onClick != "function" && typeof A.onClick == "function" && nS(i);
          break;
      }
      Xp(o, A);
      var B, V, G = null;
      for (B in R)
        if (!(A.hasOwnProperty(B) || !R.hasOwnProperty(B) || R[B] == null))
          if (B === Jf) {
            var ae = R[B];
            for (V in ae)
              ae.hasOwnProperty(V) && (G || (G = {}), G[V] = "");
          } else
            B === Mv || B === Zf || B === q0 || B === Ed || B === aR || (rt.hasOwnProperty(B) ? C || (C = []) : (C = C || []).push(B, null));
      for (B in A) {
        var ne = A[B], Ce = R?.[B];
        if (!(!A.hasOwnProperty(B) || ne === Ce || ne == null && Ce == null))
          if (B === Jf)
            if (ne && Object.freeze(ne), Ce) {
              for (V in Ce)
                Ce.hasOwnProperty(V) && (!ne || !ne.hasOwnProperty(V)) && (G || (G = {}), G[V] = "");
              for (V in ne)
                ne.hasOwnProperty(V) && Ce[V] !== ne[V] && (G || (G = {}), G[V] = ne[V]);
            } else
              G || (C || (C = []), C.push(B, G)), G = ne;
          else if (B === Mv) {
            var _e = ne ? ne[Q0] : void 0, Ae = Ce ? Ce[Q0] : void 0;
            _e != null && Ae !== _e && (C = C || []).push(B, _e);
          } else
            B === Zf ? (typeof ne == "string" || typeof ne == "number") && (C = C || []).push(B, "" + ne) : B === q0 || B === Ed || (rt.hasOwnProperty(B) ? (ne != null && (typeof ne != "function" && J0(B, ne), B === "onScroll" && Nr("scroll", i)), !C && Ce !== ne && (C = [])) : (C = C || []).push(B, ne));
      }
      return G && (Sf(G, A[Jf]), (C = C || []).push(Jf, G)), C;
    }
    function T6(i, o, d, h, b) {
      d === "input" && b.type === "radio" && b.name != null && ye(i, b);
      var C = il(d, h), R = il(d, b);
      switch (w6(i, o, C, R), d) {
        case "input":
          Ee(i, b);
          break;
        case "textarea":
          jb(i, b);
          break;
        case "select":
          K1(i, b);
          break;
      }
    }
    function k6(i) {
      {
        var o = i.toLowerCase();
        return qp.hasOwnProperty(o) && qp[o] || null;
      }
    }
    function P6(i, o, d, h, b, C, R) {
      var A, B;
      switch (A = il(o, d), Z0(o, d), o) {
        case "dialog":
          Nr("cancel", i), Nr("close", i);
          break;
        case "iframe":
        case "object":
        case "embed":
          Nr("load", i);
          break;
        case "video":
        case "audio":
          for (var V = 0; V < Iv.length; V++)
            Nr(Iv[V], i);
          break;
        case "source":
          Nr("error", i);
          break;
        case "img":
        case "image":
        case "link":
          Nr("error", i), Nr("load", i);
          break;
        case "details":
          Nr("toggle", i);
          break;
        case "input":
          Z(i, d), Nr("invalid", i);
          break;
        case "option":
          In(i, d);
          break;
        case "select":
          yf(i, d), Nr("invalid", i);
          break;
        case "textarea":
          Lb(i, d), Nr("invalid", i);
          break;
      }
      Xp(o, d);
      {
        B = /* @__PURE__ */ new Set();
        for (var G = i.attributes, ae = 0; ae < G.length; ae++) {
          var ne = G[ae].name.toLowerCase();
          switch (ne) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              B.add(G[ae].name);
          }
        }
      }
      var Ce = null;
      for (var _e in d)
        if (d.hasOwnProperty(_e)) {
          var Ae = d[_e];
          if (_e === Zf)
            typeof Ae == "string" ? i.textContent !== Ae && (d[Ed] !== !0 && tS(i.textContent, Ae, C, R), Ce = [Zf, Ae]) : typeof Ae == "number" && i.textContent !== "" + Ae && (d[Ed] !== !0 && tS(i.textContent, Ae, C, R), Ce = [Zf, "" + Ae]);
          else if (rt.hasOwnProperty(_e))
            Ae != null && (typeof Ae != "function" && J0(_e, Ae), _e === "onScroll" && Nr("scroll", i));
          else if (R && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof A == "boolean") {
            var ut = void 0, Ot = A && xe ? null : vi(_e);
            if (d[Ed] !== !0) {
              if (!(_e === q0 || _e === Ed || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              _e === "value" || _e === "checked" || _e === "selected")) {
                if (_e === Mv) {
                  var Pt = i.innerHTML, _n = Ae ? Ae[Q0] : void 0;
                  if (_n != null) {
                    var vn = cR(i, _n);
                    vn !== Pt && Av(_e, Pt, vn);
                  }
                } else if (_e === Jf) {
                  if (B.delete(_e), lR) {
                    var be = eE(Ae);
                    ut = i.getAttribute("style"), be !== ut && Av(_e, ut, be);
                  }
                } else if (A && !xe)
                  B.delete(_e.toLowerCase()), ut = wa(i, _e, Ae), Ae !== ut && Av(_e, ut, Ae);
                else if (!ur(_e, Ot, A) && !pn(_e, Ae, Ot, A)) {
                  var Oe = !1;
                  if (Ot !== null)
                    B.delete(Ot.attributeName), ut = lo(i, _e, Ae, Ot);
                  else {
                    var Se = h;
                    if (Se === nl && (Se = Yp(o)), Se === nl)
                      B.delete(_e.toLowerCase());
                    else {
                      var We = k6(_e);
                      We !== null && We !== _e && (Oe = !0, B.delete(We)), B.delete(_e);
                    }
                    ut = wa(i, _e, Ae);
                  }
                  var dt = xe;
                  !dt && Ae !== ut && !Oe && Av(_e, ut, Ae);
                }
              }
            }
          }
        }
      switch (R && // $FlowFixMe - Should be inferred as not undefined.
      B.size > 0 && d[Ed] !== !0 && sR(B), o) {
        case "input":
          ie(i), Fe(i, d, !0);
          break;
        case "textarea":
          ie(i), zb(i);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof d.onClick == "function" && nS(i);
          break;
      }
      return Ce;
    }
    function I6(i, o, d) {
      var h = i.nodeValue !== o;
      return h;
    }
    function DE(i, o) {
      {
        if (La)
          return;
        La = !0, c("Did not expect server HTML to contain a <%s> in <%s>.", o.nodeName.toLowerCase(), i.nodeName.toLowerCase());
      }
    }
    function NE(i, o) {
      {
        if (La)
          return;
        La = !0, c('Did not expect server HTML to contain the text node "%s" in <%s>.', o.nodeValue, i.nodeName.toLowerCase());
      }
    }
    function LE(i, o, d) {
      {
        if (La)
          return;
        La = !0, c("Expected server HTML to contain a matching <%s> in <%s>.", o, i.nodeName.toLowerCase());
      }
    }
    function jE(i, o) {
      {
        if (o === "" || La)
          return;
        La = !0, c('Expected server HTML to contain a matching text node for "%s" in <%s>.', o, i.nodeName.toLowerCase());
      }
    }
    function R6(i, o, d) {
      switch (o) {
        case "input":
          ht(i, d);
          return;
        case "textarea":
          xm(i, d);
          return;
        case "select":
          W1(i, d);
          return;
      }
    }
    var Ov = function() {
    }, Dv = function() {
    };
    {
      var $6 = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], dR = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], M6 = dR.concat(["button"]), A6 = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], fR = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      Dv = function(i, o) {
        var d = Jt({}, i || fR), h = {
          tag: o
        };
        return dR.indexOf(o) !== -1 && (d.aTagInScope = null, d.buttonTagInScope = null, d.nobrTagInScope = null), M6.indexOf(o) !== -1 && (d.pTagInButtonScope = null), $6.indexOf(o) !== -1 && o !== "address" && o !== "div" && o !== "p" && (d.listItemTagAutoclosing = null, d.dlItemTagAutoclosing = null), d.current = h, o === "form" && (d.formTag = h), o === "a" && (d.aTagInScope = h), o === "button" && (d.buttonTagInScope = h), o === "nobr" && (d.nobrTagInScope = h), o === "p" && (d.pTagInButtonScope = h), o === "li" && (d.listItemTagAutoclosing = h), (o === "dd" || o === "dt") && (d.dlItemTagAutoclosing = h), d;
      };
      var O6 = function(i, o) {
        switch (o) {
          case "select":
            return i === "option" || i === "optgroup" || i === "#text";
          case "optgroup":
            return i === "option" || i === "#text";
          case "option":
            return i === "#text";
          case "tr":
            return i === "th" || i === "td" || i === "style" || i === "script" || i === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return i === "tr" || i === "style" || i === "script" || i === "template";
          case "colgroup":
            return i === "col" || i === "template";
          case "table":
            return i === "caption" || i === "colgroup" || i === "tbody" || i === "tfoot" || i === "thead" || i === "style" || i === "script" || i === "template";
          case "head":
            return i === "base" || i === "basefont" || i === "bgsound" || i === "link" || i === "meta" || i === "title" || i === "noscript" || i === "noframes" || i === "style" || i === "script" || i === "template";
          case "html":
            return i === "head" || i === "body" || i === "frameset";
          case "frameset":
            return i === "frame";
          case "#document":
            return i === "html";
        }
        switch (i) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return o !== "h1" && o !== "h2" && o !== "h3" && o !== "h4" && o !== "h5" && o !== "h6";
          case "rp":
          case "rt":
            return A6.indexOf(o) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return o == null;
        }
        return !0;
      }, D6 = function(i, o) {
        switch (i) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return o.pTagInButtonScope;
          case "form":
            return o.formTag || o.pTagInButtonScope;
          case "li":
            return o.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return o.dlItemTagAutoclosing;
          case "button":
            return o.buttonTagInScope;
          case "a":
            return o.aTagInScope;
          case "nobr":
            return o.nobrTagInScope;
        }
        return null;
      }, pR = {};
      Ov = function(i, o, d) {
        d = d || fR;
        var h = d.current, b = h && h.tag;
        o != null && (i != null && c("validateDOMNesting: when childText is passed, childTag should be null"), i = "#text");
        var C = O6(i, b) ? null : h, R = C ? null : D6(i, d), A = C || R;
        if (A) {
          var B = A.tag, V = !!C + "|" + i + "|" + B;
          if (!pR[V]) {
            pR[V] = !0;
            var G = i, ae = "";
            if (i === "#text" ? /\S/.test(o) ? G = "Text nodes" : (G = "Whitespace text nodes", ae = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : G = "<" + i + ">", C) {
              var ne = "";
              B === "table" && i === "tr" && (ne += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), c("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", G, B, ae, ne);
            } else
              c("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", G, B);
          }
        }
      };
    }
    var rS = "suppressHydrationWarning", iS = "$", oS = "/$", Nv = "$?", Lv = "$!", N6 = "style", zE = null, UE = null;
    function L6(i) {
      var o, d, h = i.nodeType;
      switch (h) {
        case ts:
        case Fc: {
          o = h === ts ? "#document" : "#fragment";
          var b = i.documentElement;
          d = b ? b.namespaceURI : Cm(null, "");
          break;
        }
        default: {
          var C = h === ri ? i.parentNode : i, R = C.namespaceURI || null;
          o = C.tagName, d = Cm(R, o);
          break;
        }
      }
      {
        var A = o.toLowerCase(), B = Dv(null, A);
        return {
          namespace: d,
          ancestorInfo: B
        };
      }
    }
    function j6(i, o, d) {
      {
        var h = i, b = Cm(h.namespace, o), C = Dv(h.ancestorInfo, o);
        return {
          namespace: b,
          ancestorInfo: C
        };
      }
    }
    function Mpe(i) {
      return i;
    }
    function z6(i) {
      zE = ia(), UE = J5();
      var o = null;
      return ki(!1), o;
    }
    function U6(i) {
      e6(UE), ki(zE), zE = null, UE = null;
    }
    function B6(i, o, d, h, b) {
      var C;
      {
        var R = h;
        if (Ov(i, null, R.ancestorInfo), typeof o.children == "string" || typeof o.children == "number") {
          var A = "" + o.children, B = Dv(R.ancestorInfo, i);
          Ov(null, A, B);
        }
        C = R.namespace;
      }
      var V = x6(i, o, d, C);
      return Uv(b, V), GE(V, o), V;
    }
    function F6(i, o) {
      i.appendChild(o);
    }
    function H6(i, o, d, h, b) {
      switch (C6(i, o, d, h), o) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!d.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function V6(i, o, d, h, b, C) {
      {
        var R = C;
        if (typeof h.children != typeof d.children && (typeof h.children == "string" || typeof h.children == "number")) {
          var A = "" + h.children, B = Dv(R.ancestorInfo, o);
          Ov(null, A, B);
        }
      }
      return _6(i, o, d, h);
    }
    function BE(i, o) {
      return i === "textarea" || i === "noscript" || typeof o.children == "string" || typeof o.children == "number" || typeof o.dangerouslySetInnerHTML == "object" && o.dangerouslySetInnerHTML !== null && o.dangerouslySetInnerHTML.__html != null;
    }
    function Y6(i, o, d, h) {
      {
        var b = d;
        Ov(null, i, b.ancestorInfo);
      }
      var C = E6(i, o);
      return Uv(h, C), C;
    }
    function K6() {
      var i = window.event;
      return i === void 0 ? fl : po(i.type);
    }
    var FE = typeof setTimeout == "function" ? setTimeout : void 0, W6 = typeof clearTimeout == "function" ? clearTimeout : void 0, HE = -1, hR = typeof Promise == "function" ? Promise : void 0, G6 = typeof queueMicrotask == "function" ? queueMicrotask : typeof hR < "u" ? function(i) {
      return hR.resolve(null).then(i).catch(X6);
    } : FE;
    function X6(i) {
      setTimeout(function() {
        throw i;
      });
    }
    function q6(i, o, d, h) {
      switch (o) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          d.autoFocus && i.focus();
          return;
        case "img": {
          d.src && (i.src = d.src);
          return;
        }
      }
    }
    function Q6(i, o, d, h, b, C) {
      T6(i, o, d, h, b), GE(i, b);
    }
    function gR(i) {
      Wp(i, "");
    }
    function Z6(i, o, d) {
      i.nodeValue = d;
    }
    function J6(i, o) {
      i.appendChild(o);
    }
    function eU(i, o) {
      var d;
      i.nodeType === ri ? (d = i.parentNode, d.insertBefore(o, i)) : (d = i, d.appendChild(o));
      var h = i._reactRootContainer;
      h == null && d.onclick === null && nS(d);
    }
    function tU(i, o, d) {
      i.insertBefore(o, d);
    }
    function nU(i, o, d) {
      i.nodeType === ri ? i.parentNode.insertBefore(o, d) : i.insertBefore(o, d);
    }
    function rU(i, o) {
      i.removeChild(o);
    }
    function iU(i, o) {
      i.nodeType === ri ? i.parentNode.removeChild(o) : i.removeChild(o);
    }
    function VE(i, o) {
      var d = o, h = 0;
      do {
        var b = d.nextSibling;
        if (i.removeChild(d), b && b.nodeType === ri) {
          var C = b.data;
          if (C === oS)
            if (h === 0) {
              i.removeChild(b), mn(o);
              return;
            } else
              h--;
          else
            (C === iS || C === Nv || C === Lv) && h++;
        }
        d = b;
      } while (d);
      mn(o);
    }
    function oU(i, o) {
      i.nodeType === ri ? VE(i.parentNode, o) : i.nodeType === $o && VE(i, o), mn(i);
    }
    function aU(i) {
      i = i;
      var o = i.style;
      typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none";
    }
    function sU(i) {
      i.nodeValue = "";
    }
    function lU(i, o) {
      i = i;
      var d = o[N6], h = d != null && d.hasOwnProperty("display") ? d.display : null;
      i.style.display = Gp("display", h);
    }
    function cU(i, o) {
      i.nodeValue = o;
    }
    function uU(i) {
      i.nodeType === $o ? i.textContent = "" : i.nodeType === ts && i.documentElement && i.removeChild(i.documentElement);
    }
    function dU(i, o, d) {
      return i.nodeType !== $o || o.toLowerCase() !== i.nodeName.toLowerCase() ? null : i;
    }
    function fU(i, o) {
      return o === "" || i.nodeType !== rl ? null : i;
    }
    function pU(i) {
      return i.nodeType !== ri ? null : i;
    }
    function mR(i) {
      return i.data === Nv;
    }
    function YE(i) {
      return i.data === Lv;
    }
    function hU(i) {
      var o = i.nextSibling && i.nextSibling.dataset, d, h, b;
      return o && (d = o.dgst, h = o.msg, b = o.stck), {
        message: h,
        digest: d,
        stack: b
      };
    }
    function gU(i, o) {
      i._reactRetry = o;
    }
    function aS(i) {
      for (; i != null; i = i.nextSibling) {
        var o = i.nodeType;
        if (o === $o || o === rl)
          break;
        if (o === ri) {
          var d = i.data;
          if (d === iS || d === Lv || d === Nv)
            break;
          if (d === oS)
            return null;
        }
      }
      return i;
    }
    function jv(i) {
      return aS(i.nextSibling);
    }
    function mU(i) {
      return aS(i.firstChild);
    }
    function vU(i) {
      return aS(i.firstChild);
    }
    function yU(i) {
      return aS(i.nextSibling);
    }
    function bU(i, o, d, h, b, C, R) {
      Uv(C, i), GE(i, d);
      var A;
      {
        var B = b;
        A = B.namespace;
      }
      var V = (C.mode & fn) !== Dt;
      return P6(i, o, d, A, h, V, R);
    }
    function SU(i, o, d, h) {
      return Uv(d, i), d.mode & fn, I6(i, o);
    }
    function wU(i, o) {
      Uv(o, i);
    }
    function xU(i) {
      for (var o = i.nextSibling, d = 0; o; ) {
        if (o.nodeType === ri) {
          var h = o.data;
          if (h === oS) {
            if (d === 0)
              return jv(o);
            d--;
          } else
            (h === iS || h === Lv || h === Nv) && d++;
        }
        o = o.nextSibling;
      }
      return null;
    }
    function vR(i) {
      for (var o = i.previousSibling, d = 0; o; ) {
        if (o.nodeType === ri) {
          var h = o.data;
          if (h === iS || h === Lv || h === Nv) {
            if (d === 0)
              return o;
            d--;
          } else
            h === oS && d++;
        }
        o = o.previousSibling;
      }
      return null;
    }
    function EU(i) {
      mn(i);
    }
    function CU(i) {
      mn(i);
    }
    function _U(i) {
      return i !== "head" && i !== "body";
    }
    function TU(i, o, d, h) {
      var b = !0;
      tS(o.nodeValue, d, h, b);
    }
    function kU(i, o, d, h, b, C) {
      if (o[rS] !== !0) {
        var R = !0;
        tS(h.nodeValue, b, C, R);
      }
    }
    function PU(i, o) {
      o.nodeType === $o ? DE(i, o) : o.nodeType === ri || NE(i, o);
    }
    function IU(i, o) {
      {
        var d = i.parentNode;
        d !== null && (o.nodeType === $o ? DE(d, o) : o.nodeType === ri || NE(d, o));
      }
    }
    function RU(i, o, d, h, b) {
      (b || o[rS] !== !0) && (h.nodeType === $o ? DE(d, h) : h.nodeType === ri || NE(d, h));
    }
    function $U(i, o, d) {
      LE(i, o);
    }
    function MU(i, o) {
      jE(i, o);
    }
    function AU(i, o, d) {
      {
        var h = i.parentNode;
        h !== null && LE(h, o);
      }
    }
    function OU(i, o) {
      {
        var d = i.parentNode;
        d !== null && jE(d, o);
      }
    }
    function DU(i, o, d, h, b, C) {
      (C || o[rS] !== !0) && LE(d, h);
    }
    function NU(i, o, d, h, b) {
      (b || o[rS] !== !0) && jE(d, h);
    }
    function LU(i) {
      c("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", i.nodeName.toLowerCase());
    }
    function jU(i) {
      Rv(i);
    }
    var eg = Math.random().toString(36).slice(2), tg = "__reactFiber$" + eg, KE = "__reactProps$" + eg, zv = "__reactContainer$" + eg, WE = "__reactEvents$" + eg, zU = "__reactListeners$" + eg, UU = "__reactHandles$" + eg;
    function BU(i) {
      delete i[tg], delete i[KE], delete i[WE], delete i[zU], delete i[UU];
    }
    function Uv(i, o) {
      o[tg] = i;
    }
    function sS(i, o) {
      o[zv] = i;
    }
    function yR(i) {
      i[zv] = null;
    }
    function Bv(i) {
      return !!i[zv];
    }
    function ep(i) {
      var o = i[tg];
      if (o)
        return o;
      for (var d = i.parentNode; d; ) {
        if (o = d[zv] || d[tg], o) {
          var h = o.alternate;
          if (o.child !== null || h !== null && h.child !== null)
            for (var b = vR(i); b !== null; ) {
              var C = b[tg];
              if (C)
                return C;
              b = vR(b);
            }
          return o;
        }
        i = d, d = i.parentNode;
      }
      return null;
    }
    function Cd(i) {
      var o = i[tg] || i[zv];
      return o && (o.tag === x || o.tag === _ || o.tag === z || o.tag === v) ? o : null;
    }
    function ng(i) {
      if (i.tag === x || i.tag === _)
        return i.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function lS(i) {
      return i[KE] || null;
    }
    function GE(i, o) {
      i[KE] = o;
    }
    function FU(i) {
      var o = i[WE];
      return o === void 0 && (o = i[WE] = /* @__PURE__ */ new Set()), o;
    }
    var bR = {}, SR = n.ReactDebugCurrentFrame;
    function cS(i) {
      if (i) {
        var o = i._owner, d = qo(i.type, i._source, o ? o.type : null);
        SR.setExtraStackFrame(d);
      } else
        SR.setExtraStackFrame(null);
    }
    function vl(i, o, d, h, b) {
      {
        var C = Function.call.bind(Ke);
        for (var R in i)
          if (C(i, R)) {
            var A = void 0;
            try {
              if (typeof i[R] != "function") {
                var B = Error((h || "React class") + ": " + d + " type `" + R + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[R] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw B.name = "Invariant Violation", B;
              }
              A = i[R](o, R, h, d, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (V) {
              A = V;
            }
            A && !(A instanceof Error) && (cS(b), c("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", h || "React class", d, R, typeof A), cS(null)), A instanceof Error && !(A.message in bR) && (bR[A.message] = !0, cS(b), c("Failed %s type: %s", d, A.message), cS(null));
          }
      }
    }
    var XE = [], uS;
    uS = [];
    var mu = -1;
    function _d(i) {
      return {
        current: i
      };
    }
    function Uo(i, o) {
      if (mu < 0) {
        c("Unexpected pop.");
        return;
      }
      o !== uS[mu] && c("Unexpected Fiber popped."), i.current = XE[mu], XE[mu] = null, uS[mu] = null, mu--;
    }
    function Bo(i, o, d) {
      mu++, XE[mu] = i.current, uS[mu] = d, i.current = o;
    }
    var qE;
    qE = {};
    var as = {};
    Object.freeze(as);
    var vu = _d(as), dc = _d(!1), QE = as;
    function rg(i, o, d) {
      return d && fc(o) ? QE : vu.current;
    }
    function wR(i, o, d) {
      {
        var h = i.stateNode;
        h.__reactInternalMemoizedUnmaskedChildContext = o, h.__reactInternalMemoizedMaskedChildContext = d;
      }
    }
    function ig(i, o) {
      {
        var d = i.type, h = d.contextTypes;
        if (!h)
          return as;
        var b = i.stateNode;
        if (b && b.__reactInternalMemoizedUnmaskedChildContext === o)
          return b.__reactInternalMemoizedMaskedChildContext;
        var C = {};
        for (var R in h)
          C[R] = o[R];
        {
          var A = Ft(i) || "Unknown";
          vl(h, C, "context", A);
        }
        return b && wR(i, o, C), C;
      }
    }
    function dS() {
      return dc.current;
    }
    function fc(i) {
      {
        var o = i.childContextTypes;
        return o != null;
      }
    }
    function fS(i) {
      Uo(dc, i), Uo(vu, i);
    }
    function ZE(i) {
      Uo(dc, i), Uo(vu, i);
    }
    function xR(i, o, d) {
      {
        if (vu.current !== as)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Bo(vu, o, i), Bo(dc, d, i);
      }
    }
    function ER(i, o, d) {
      {
        var h = i.stateNode, b = o.childContextTypes;
        if (typeof h.getChildContext != "function") {
          {
            var C = Ft(i) || "Unknown";
            qE[C] || (qE[C] = !0, c("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", C, C));
          }
          return d;
        }
        var R = h.getChildContext();
        for (var A in R)
          if (!(A in b))
            throw new Error((Ft(i) || "Unknown") + '.getChildContext(): key "' + A + '" is not defined in childContextTypes.');
        {
          var B = Ft(i) || "Unknown";
          vl(b, R, "child context", B);
        }
        return Jt({}, d, R);
      }
    }
    function pS(i) {
      {
        var o = i.stateNode, d = o && o.__reactInternalMemoizedMergedChildContext || as;
        return QE = vu.current, Bo(vu, d, i), Bo(dc, dc.current, i), !0;
      }
    }
    function CR(i, o, d) {
      {
        var h = i.stateNode;
        if (!h)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (d) {
          var b = ER(i, o, QE);
          h.__reactInternalMemoizedMergedChildContext = b, Uo(dc, i), Uo(vu, i), Bo(vu, b, i), Bo(dc, d, i);
        } else
          Uo(dc, i), Bo(dc, d, i);
      }
    }
    function HU(i) {
      {
        if (!Vm(i) || i.tag !== g)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var o = i;
        do {
          switch (o.tag) {
            case v:
              return o.stateNode.context;
            case g: {
              var d = o.type;
              if (fc(d))
                return o.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          o = o.return;
        } while (o !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Td = 0, hS = 1, yu = null, JE = !1, eC = !1;
    function _R(i) {
      yu === null ? yu = [i] : yu.push(i);
    }
    function VU(i) {
      JE = !0, _R(i);
    }
    function TR() {
      JE && kd();
    }
    function kd() {
      if (!eC && yu !== null) {
        eC = !0;
        var i = 0, o = Aa();
        try {
          var d = !0, h = yu;
          for (ci(qi); i < h.length; i++) {
            var b = h[i];
            do
              b = b(d);
            while (b !== null);
          }
          yu = null, JE = !1;
        } catch (C) {
          throw yu !== null && (yu = yu.slice(i + 1)), oh(sh, kd), C;
        } finally {
          ci(o), eC = !1;
        }
      }
      return null;
    }
    var og = [], ag = 0, gS = null, mS = 0, As = [], Os = 0, tp = null, bu = 1, Su = "";
    function YU(i) {
      return rp(), (i.flags & Bm) !== Mt;
    }
    function KU(i) {
      return rp(), mS;
    }
    function WU() {
      var i = Su, o = bu, d = o & ~GU(o);
      return d.toString(32) + i;
    }
    function np(i, o) {
      rp(), og[ag++] = mS, og[ag++] = gS, gS = i, mS = o;
    }
    function kR(i, o, d) {
      rp(), As[Os++] = bu, As[Os++] = Su, As[Os++] = tp, tp = i;
      var h = bu, b = Su, C = vS(h) - 1, R = h & ~(1 << C), A = d + 1, B = vS(o) + C;
      if (B > 30) {
        var V = C - C % 5, G = (1 << V) - 1, ae = (R & G).toString(32), ne = R >> V, Ce = C - V, _e = vS(o) + Ce, Ae = A << Ce, ut = Ae | ne, Ot = ae + b;
        bu = 1 << _e | ut, Su = Ot;
      } else {
        var Pt = A << C, _n = Pt | R, vn = b;
        bu = 1 << B | _n, Su = vn;
      }
    }
    function tC(i) {
      rp();
      var o = i.return;
      if (o !== null) {
        var d = 1, h = 0;
        np(i, d), kR(i, d, h);
      }
    }
    function vS(i) {
      return 32 - ph(i);
    }
    function GU(i) {
      return 1 << vS(i) - 1;
    }
    function nC(i) {
      for (; i === gS; )
        gS = og[--ag], og[ag] = null, mS = og[--ag], og[ag] = null;
      for (; i === tp; )
        tp = As[--Os], As[Os] = null, Su = As[--Os], As[Os] = null, bu = As[--Os], As[Os] = null;
    }
    function XU() {
      return rp(), tp !== null ? {
        id: bu,
        overflow: Su
      } : null;
    }
    function qU(i, o) {
      rp(), As[Os++] = bu, As[Os++] = Su, As[Os++] = tp, bu = o.id, Su = o.overflow, tp = i;
    }
    function rp() {
      go() || c("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var ho = null, Ds = null, yl = !1, ip = !1, Pd = null;
    function QU() {
      yl && c("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function PR() {
      ip = !0;
    }
    function ZU() {
      return ip;
    }
    function JU(i) {
      var o = i.stateNode.containerInfo;
      return Ds = vU(o), ho = i, yl = !0, Pd = null, ip = !1, !0;
    }
    function eB(i, o, d) {
      return Ds = yU(o), ho = i, yl = !0, Pd = null, ip = !1, d !== null && qU(i, d), !0;
    }
    function IR(i, o) {
      switch (i.tag) {
        case v: {
          PU(i.stateNode.containerInfo, o);
          break;
        }
        case x: {
          var d = (i.mode & fn) !== Dt;
          RU(
            i.type,
            i.memoizedProps,
            i.stateNode,
            o,
            // TODO: Delete this argument when we remove the legacy root API.
            d
          );
          break;
        }
        case z: {
          var h = i.memoizedState;
          h.dehydrated !== null && IU(h.dehydrated, o);
          break;
        }
      }
    }
    function RR(i, o) {
      IR(i, o);
      var d = r7();
      d.stateNode = o, d.return = i;
      var h = i.deletions;
      h === null ? (i.deletions = [d], i.flags |= Un) : h.push(d);
    }
    function rC(i, o) {
      {
        if (ip)
          return;
        switch (i.tag) {
          case v: {
            var d = i.stateNode.containerInfo;
            switch (o.tag) {
              case x:
                var h = o.type;
                o.pendingProps, $U(d, h);
                break;
              case _:
                var b = o.pendingProps;
                MU(d, b);
                break;
            }
            break;
          }
          case x: {
            var C = i.type, R = i.memoizedProps, A = i.stateNode;
            switch (o.tag) {
              case x: {
                var B = o.type, V = o.pendingProps, G = (i.mode & fn) !== Dt;
                DU(
                  C,
                  R,
                  A,
                  B,
                  V,
                  // TODO: Delete this argument when we remove the legacy root API.
                  G
                );
                break;
              }
              case _: {
                var ae = o.pendingProps, ne = (i.mode & fn) !== Dt;
                NU(
                  C,
                  R,
                  A,
                  ae,
                  // TODO: Delete this argument when we remove the legacy root API.
                  ne
                );
                break;
              }
            }
            break;
          }
          case z: {
            var Ce = i.memoizedState, _e = Ce.dehydrated;
            if (_e !== null)
              switch (o.tag) {
                case x:
                  var Ae = o.type;
                  o.pendingProps, AU(_e, Ae);
                  break;
                case _:
                  var ut = o.pendingProps;
                  OU(_e, ut);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function $R(i, o) {
      o.flags = o.flags & ~Pa | mr, rC(i, o);
    }
    function MR(i, o) {
      switch (i.tag) {
        case x: {
          var d = i.type;
          i.pendingProps;
          var h = dU(o, d);
          return h !== null ? (i.stateNode = h, ho = i, Ds = mU(h), !0) : !1;
        }
        case _: {
          var b = i.pendingProps, C = fU(o, b);
          return C !== null ? (i.stateNode = C, ho = i, Ds = null, !0) : !1;
        }
        case z: {
          var R = pU(o);
          if (R !== null) {
            var A = {
              dehydrated: R,
              treeContext: XU(),
              retryLane: jo
            };
            i.memoizedState = A;
            var B = i7(R);
            return B.return = i, i.child = B, ho = i, Ds = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function iC(i) {
      return (i.mode & fn) !== Dt && (i.flags & Ht) === Mt;
    }
    function oC(i) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function aC(i) {
      if (yl) {
        var o = Ds;
        if (!o) {
          iC(i) && (rC(ho, i), oC()), $R(ho, i), yl = !1, ho = i;
          return;
        }
        var d = o;
        if (!MR(i, o)) {
          iC(i) && (rC(ho, i), oC()), o = jv(d);
          var h = ho;
          if (!o || !MR(i, o)) {
            $R(ho, i), yl = !1, ho = i;
            return;
          }
          RR(h, d);
        }
      }
    }
    function tB(i, o, d) {
      var h = i.stateNode, b = !ip, C = bU(h, i.type, i.memoizedProps, o, d, i, b);
      return i.updateQueue = C, C !== null;
    }
    function nB(i) {
      var o = i.stateNode, d = i.memoizedProps, h = SU(o, d, i);
      if (h) {
        var b = ho;
        if (b !== null)
          switch (b.tag) {
            case v: {
              var C = b.stateNode.containerInfo, R = (b.mode & fn) !== Dt;
              TU(
                C,
                o,
                d,
                // TODO: Delete this argument when we remove the legacy root API.
                R
              );
              break;
            }
            case x: {
              var A = b.type, B = b.memoizedProps, V = b.stateNode, G = (b.mode & fn) !== Dt;
              kU(
                A,
                B,
                V,
                o,
                d,
                // TODO: Delete this argument when we remove the legacy root API.
                G
              );
              break;
            }
          }
      }
      return h;
    }
    function rB(i) {
      var o = i.memoizedState, d = o !== null ? o.dehydrated : null;
      if (!d)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      wU(d, i);
    }
    function iB(i) {
      var o = i.memoizedState, d = o !== null ? o.dehydrated : null;
      if (!d)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return xU(d);
    }
    function AR(i) {
      for (var o = i.return; o !== null && o.tag !== x && o.tag !== v && o.tag !== z; )
        o = o.return;
      ho = o;
    }
    function yS(i) {
      if (i !== ho)
        return !1;
      if (!yl)
        return AR(i), yl = !0, !1;
      if (i.tag !== v && (i.tag !== x || _U(i.type) && !BE(i.type, i.memoizedProps))) {
        var o = Ds;
        if (o)
          if (iC(i))
            OR(i), oC();
          else
            for (; o; )
              RR(i, o), o = jv(o);
      }
      return AR(i), i.tag === z ? Ds = iB(i) : Ds = ho ? jv(i.stateNode) : null, !0;
    }
    function oB() {
      return yl && Ds !== null;
    }
    function OR(i) {
      for (var o = Ds; o; )
        IR(i, o), o = jv(o);
    }
    function sg() {
      ho = null, Ds = null, yl = !1, ip = !1;
    }
    function DR() {
      Pd !== null && (IM(Pd), Pd = null);
    }
    function go() {
      return yl;
    }
    function sC(i) {
      Pd === null ? Pd = [i] : Pd.push(i);
    }
    var aB = n.ReactCurrentBatchConfig, sB = null;
    function lB() {
      return aB.transition;
    }
    var bl = {
      recordUnsafeLifecycleWarnings: function(i, o) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(i, o) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var cB = function(i) {
        for (var o = null, d = i; d !== null; )
          d.mode & Or && (o = d), d = d.return;
        return o;
      }, op = function(i) {
        var o = [];
        return i.forEach(function(d) {
          o.push(d);
        }), o.sort().join(", ");
      }, Fv = [], Hv = [], Vv = [], Yv = [], Kv = [], Wv = [], ap = /* @__PURE__ */ new Set();
      bl.recordUnsafeLifecycleWarnings = function(i, o) {
        ap.has(i.type) || (typeof o.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        o.componentWillMount.__suppressDeprecationWarning !== !0 && Fv.push(i), i.mode & Or && typeof o.UNSAFE_componentWillMount == "function" && Hv.push(i), typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Vv.push(i), i.mode & Or && typeof o.UNSAFE_componentWillReceiveProps == "function" && Yv.push(i), typeof o.componentWillUpdate == "function" && o.componentWillUpdate.__suppressDeprecationWarning !== !0 && Kv.push(i), i.mode & Or && typeof o.UNSAFE_componentWillUpdate == "function" && Wv.push(i));
      }, bl.flushPendingUnsafeLifecycleWarnings = function() {
        var i = /* @__PURE__ */ new Set();
        Fv.length > 0 && (Fv.forEach(function(ne) {
          i.add(Ft(ne) || "Component"), ap.add(ne.type);
        }), Fv = []);
        var o = /* @__PURE__ */ new Set();
        Hv.length > 0 && (Hv.forEach(function(ne) {
          o.add(Ft(ne) || "Component"), ap.add(ne.type);
        }), Hv = []);
        var d = /* @__PURE__ */ new Set();
        Vv.length > 0 && (Vv.forEach(function(ne) {
          d.add(Ft(ne) || "Component"), ap.add(ne.type);
        }), Vv = []);
        var h = /* @__PURE__ */ new Set();
        Yv.length > 0 && (Yv.forEach(function(ne) {
          h.add(Ft(ne) || "Component"), ap.add(ne.type);
        }), Yv = []);
        var b = /* @__PURE__ */ new Set();
        Kv.length > 0 && (Kv.forEach(function(ne) {
          b.add(Ft(ne) || "Component"), ap.add(ne.type);
        }), Kv = []);
        var C = /* @__PURE__ */ new Set();
        if (Wv.length > 0 && (Wv.forEach(function(ne) {
          C.add(Ft(ne) || "Component"), ap.add(ne.type);
        }), Wv = []), o.size > 0) {
          var R = op(o);
          c(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, R);
        }
        if (h.size > 0) {
          var A = op(h);
          c(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, A);
        }
        if (C.size > 0) {
          var B = op(C);
          c(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, B);
        }
        if (i.size > 0) {
          var V = op(i);
          s(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, V);
        }
        if (d.size > 0) {
          var G = op(d);
          s(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, G);
        }
        if (b.size > 0) {
          var ae = op(b);
          s(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ae);
        }
      };
      var bS = /* @__PURE__ */ new Map(), NR = /* @__PURE__ */ new Set();
      bl.recordLegacyContextWarning = function(i, o) {
        var d = cB(i);
        if (d === null) {
          c("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!NR.has(i.type)) {
          var h = bS.get(d);
          (i.type.contextTypes != null || i.type.childContextTypes != null || o !== null && typeof o.getChildContext == "function") && (h === void 0 && (h = [], bS.set(d, h)), h.push(i));
        }
      }, bl.flushLegacyContextWarning = function() {
        bS.forEach(function(i, o) {
          if (i.length !== 0) {
            var d = i[0], h = /* @__PURE__ */ new Set();
            i.forEach(function(C) {
              h.add(Ft(C) || "Component"), NR.add(C.type);
            });
            var b = op(h);
            try {
              Nn(d), c(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, b);
            } finally {
              or();
            }
          }
        });
      }, bl.discardPendingWarnings = function() {
        Fv = [], Hv = [], Vv = [], Yv = [], Kv = [], Wv = [], bS = /* @__PURE__ */ new Map();
      };
    }
    function Sl(i, o) {
      if (i && i.defaultProps) {
        var d = Jt({}, o), h = i.defaultProps;
        for (var b in h)
          d[b] === void 0 && (d[b] = h[b]);
        return d;
      }
      return o;
    }
    var lC = _d(null), cC;
    cC = {};
    var SS = null, lg = null, uC = null, wS = !1;
    function xS() {
      SS = null, lg = null, uC = null, wS = !1;
    }
    function LR() {
      wS = !0;
    }
    function jR() {
      wS = !1;
    }
    function zR(i, o, d) {
      Bo(lC, o._currentValue, i), o._currentValue = d, o._currentRenderer !== void 0 && o._currentRenderer !== null && o._currentRenderer !== cC && c("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), o._currentRenderer = cC;
    }
    function dC(i, o) {
      var d = lC.current;
      Uo(lC, o), i._currentValue = d;
    }
    function fC(i, o, d) {
      for (var h = i; h !== null; ) {
        var b = h.alternate;
        if (ou(h.childLanes, o) ? b !== null && !ou(b.childLanes, o) && (b.childLanes = an(b.childLanes, o)) : (h.childLanes = an(h.childLanes, o), b !== null && (b.childLanes = an(b.childLanes, o))), h === d)
          break;
        h = h.return;
      }
      h !== d && c("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function uB(i, o, d) {
      dB(i, o, d);
    }
    function dB(i, o, d) {
      var h = i.child;
      for (h !== null && (h.return = i); h !== null; ) {
        var b = void 0, C = h.dependencies;
        if (C !== null) {
          b = h.child;
          for (var R = C.firstContext; R !== null; ) {
            if (R.context === o) {
              if (h.tag === g) {
                var A = li(d), B = wu(lr, A);
                B.tag = CS;
                var V = h.updateQueue;
                if (V !== null) {
                  var G = V.shared, ae = G.pending;
                  ae === null ? B.next = B : (B.next = ae.next, ae.next = B), G.pending = B;
                }
              }
              h.lanes = an(h.lanes, d);
              var ne = h.alternate;
              ne !== null && (ne.lanes = an(ne.lanes, d)), fC(h.return, d, i), C.lanes = an(C.lanes, d);
              break;
            }
            R = R.next;
          }
        } else if (h.tag === N)
          b = h.type === i.type ? null : h.child;
        else if (h.tag === ue) {
          var Ce = h.return;
          if (Ce === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Ce.lanes = an(Ce.lanes, d);
          var _e = Ce.alternate;
          _e !== null && (_e.lanes = an(_e.lanes, d)), fC(Ce, d, i), b = h.sibling;
        } else
          b = h.child;
        if (b !== null)
          b.return = h;
        else
          for (b = h; b !== null; ) {
            if (b === i) {
              b = null;
              break;
            }
            var Ae = b.sibling;
            if (Ae !== null) {
              Ae.return = b.return, b = Ae;
              break;
            }
            b = b.return;
          }
        h = b;
      }
    }
    function cg(i, o) {
      SS = i, lg = null, uC = null;
      var d = i.dependencies;
      if (d !== null) {
        var h = d.firstContext;
        h !== null && (zo(d.lanes, o) && sy(), d.firstContext = null);
      }
    }
    function Ii(i) {
      wS && c("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var o = i._currentValue;
      if (uC !== i) {
        var d = {
          context: i,
          memoizedValue: o,
          next: null
        };
        if (lg === null) {
          if (SS === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          lg = d, SS.dependencies = {
            lanes: Ne,
            firstContext: d
          };
        } else
          lg = lg.next = d;
      }
      return o;
    }
    var sp = null;
    function pC(i) {
      sp === null ? sp = [i] : sp.push(i);
    }
    function fB() {
      if (sp !== null) {
        for (var i = 0; i < sp.length; i++) {
          var o = sp[i], d = o.interleaved;
          if (d !== null) {
            o.interleaved = null;
            var h = d.next, b = o.pending;
            if (b !== null) {
              var C = b.next;
              b.next = h, d.next = C;
            }
            o.pending = d;
          }
        }
        sp = null;
      }
    }
    function UR(i, o, d, h) {
      var b = o.interleaved;
      return b === null ? (d.next = d, pC(o)) : (d.next = b.next, b.next = d), o.interleaved = d, ES(i, h);
    }
    function pB(i, o, d, h) {
      var b = o.interleaved;
      b === null ? (d.next = d, pC(o)) : (d.next = b.next, b.next = d), o.interleaved = d;
    }
    function hB(i, o, d, h) {
      var b = o.interleaved;
      return b === null ? (d.next = d, pC(o)) : (d.next = b.next, b.next = d), o.interleaved = d, ES(i, h);
    }
    function ja(i, o) {
      return ES(i, o);
    }
    var gB = ES;
    function ES(i, o) {
      i.lanes = an(i.lanes, o);
      var d = i.alternate;
      d !== null && (d.lanes = an(d.lanes, o)), d === null && (i.flags & (mr | Pa)) !== Mt && BM(i);
      for (var h = i, b = i.return; b !== null; )
        b.childLanes = an(b.childLanes, o), d = b.alternate, d !== null ? d.childLanes = an(d.childLanes, o) : (b.flags & (mr | Pa)) !== Mt && BM(i), h = b, b = b.return;
      if (h.tag === v) {
        var C = h.stateNode;
        return C;
      } else
        return null;
    }
    var BR = 0, FR = 1, CS = 2, hC = 3, _S = !1, gC, TS;
    gC = !1, TS = null;
    function mC(i) {
      var o = {
        baseState: i.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Ne
        },
        effects: null
      };
      i.updateQueue = o;
    }
    function HR(i, o) {
      var d = o.updateQueue, h = i.updateQueue;
      if (d === h) {
        var b = {
          baseState: h.baseState,
          firstBaseUpdate: h.firstBaseUpdate,
          lastBaseUpdate: h.lastBaseUpdate,
          shared: h.shared,
          effects: h.effects
        };
        o.updateQueue = b;
      }
    }
    function wu(i, o) {
      var d = {
        eventTime: i,
        lane: o,
        tag: BR,
        payload: null,
        callback: null,
        next: null
      };
      return d;
    }
    function Id(i, o, d) {
      var h = i.updateQueue;
      if (h === null)
        return null;
      var b = h.shared;
      if (TS === b && !gC && (c("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), gC = !0), gF()) {
        var C = b.pending;
        return C === null ? o.next = o : (o.next = C.next, C.next = o), b.pending = o, gB(i, d);
      } else
        return hB(i, b, o, d);
    }
    function kS(i, o, d) {
      var h = o.updateQueue;
      if (h !== null) {
        var b = h.shared;
        if (rv(d)) {
          var C = b.lanes;
          C = ov(C, i.pendingLanes);
          var R = an(C, d);
          b.lanes = R, cd(i, R);
        }
      }
    }
    function vC(i, o) {
      var d = i.updateQueue, h = i.alternate;
      if (h !== null) {
        var b = h.updateQueue;
        if (d === b) {
          var C = null, R = null, A = d.firstBaseUpdate;
          if (A !== null) {
            var B = A;
            do {
              var V = {
                eventTime: B.eventTime,
                lane: B.lane,
                tag: B.tag,
                payload: B.payload,
                callback: B.callback,
                next: null
              };
              R === null ? C = R = V : (R.next = V, R = V), B = B.next;
            } while (B !== null);
            R === null ? C = R = o : (R.next = o, R = o);
          } else
            C = R = o;
          d = {
            baseState: b.baseState,
            firstBaseUpdate: C,
            lastBaseUpdate: R,
            shared: b.shared,
            effects: b.effects
          }, i.updateQueue = d;
          return;
        }
      }
      var G = d.lastBaseUpdate;
      G === null ? d.firstBaseUpdate = o : G.next = o, d.lastBaseUpdate = o;
    }
    function mB(i, o, d, h, b, C) {
      switch (d.tag) {
        case FR: {
          var R = d.payload;
          if (typeof R == "function") {
            LR();
            var A = R.call(C, h, b);
            {
              if (i.mode & Or) {
                si(!0);
                try {
                  R.call(C, h, b);
                } finally {
                  si(!1);
                }
              }
              jR();
            }
            return A;
          }
          return R;
        }
        case hC:
          i.flags = i.flags & ~Ci | Ht;
        case BR: {
          var B = d.payload, V;
          if (typeof B == "function") {
            LR(), V = B.call(C, h, b);
            {
              if (i.mode & Or) {
                si(!0);
                try {
                  B.call(C, h, b);
                } finally {
                  si(!1);
                }
              }
              jR();
            }
          } else
            V = B;
          return V == null ? h : Jt({}, h, V);
        }
        case CS:
          return _S = !0, h;
      }
      return h;
    }
    function PS(i, o, d, h) {
      var b = i.updateQueue;
      _S = !1, TS = b.shared;
      var C = b.firstBaseUpdate, R = b.lastBaseUpdate, A = b.shared.pending;
      if (A !== null) {
        b.shared.pending = null;
        var B = A, V = B.next;
        B.next = null, R === null ? C = V : R.next = V, R = B;
        var G = i.alternate;
        if (G !== null) {
          var ae = G.updateQueue, ne = ae.lastBaseUpdate;
          ne !== R && (ne === null ? ae.firstBaseUpdate = V : ne.next = V, ae.lastBaseUpdate = B);
        }
      }
      if (C !== null) {
        var Ce = b.baseState, _e = Ne, Ae = null, ut = null, Ot = null, Pt = C;
        do {
          var _n = Pt.lane, vn = Pt.eventTime;
          if (ou(h, _n)) {
            if (Ot !== null) {
              var Oe = {
                eventTime: vn,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: En,
                tag: Pt.tag,
                payload: Pt.payload,
                callback: Pt.callback,
                next: null
              };
              Ot = Ot.next = Oe;
            }
            Ce = mB(i, b, Pt, Ce, o, d);
            var Se = Pt.callback;
            if (Se !== null && // If the update was already committed, we should not queue its
            // callback again.
            Pt.lane !== En) {
              i.flags |= ks;
              var We = b.effects;
              We === null ? b.effects = [Pt] : We.push(Pt);
            }
          } else {
            var be = {
              eventTime: vn,
              lane: _n,
              tag: Pt.tag,
              payload: Pt.payload,
              callback: Pt.callback,
              next: null
            };
            Ot === null ? (ut = Ot = be, Ae = Ce) : Ot = Ot.next = be, _e = an(_e, _n);
          }
          if (Pt = Pt.next, Pt === null) {
            if (A = b.shared.pending, A === null)
              break;
            var dt = A, at = dt.next;
            dt.next = null, Pt = at, b.lastBaseUpdate = dt, b.shared.pending = null;
          }
        } while (!0);
        Ot === null && (Ae = Ce), b.baseState = Ae, b.firstBaseUpdate = ut, b.lastBaseUpdate = Ot;
        var Bt = b.shared.interleaved;
        if (Bt !== null) {
          var Zt = Bt;
          do
            _e = an(_e, Zt.lane), Zt = Zt.next;
          while (Zt !== Bt);
        } else
          C === null && (b.shared.lanes = Ne);
        by(_e), i.lanes = _e, i.memoizedState = Ce;
      }
      TS = null;
    }
    function vB(i, o) {
      if (typeof i != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + i));
      i.call(o);
    }
    function VR() {
      _S = !1;
    }
    function IS() {
      return _S;
    }
    function YR(i, o, d) {
      var h = o.effects;
      if (o.effects = null, h !== null)
        for (var b = 0; b < h.length; b++) {
          var C = h[b], R = C.callback;
          R !== null && (C.callback = null, vB(R, d));
        }
    }
    var yC = {}, KR = new t.Component().refs, bC, SC, wC, xC, EC, WR, RS, CC, _C, TC;
    {
      bC = /* @__PURE__ */ new Set(), SC = /* @__PURE__ */ new Set(), wC = /* @__PURE__ */ new Set(), xC = /* @__PURE__ */ new Set(), CC = /* @__PURE__ */ new Set(), EC = /* @__PURE__ */ new Set(), _C = /* @__PURE__ */ new Set(), TC = /* @__PURE__ */ new Set();
      var GR = /* @__PURE__ */ new Set();
      RS = function(i, o) {
        if (!(i === null || typeof i == "function")) {
          var d = o + "_" + i;
          GR.has(d) || (GR.add(d), c("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", o, i));
        }
      }, WR = function(i, o) {
        if (o === void 0) {
          var d = rn(i) || "Component";
          EC.has(d) || (EC.add(d), c("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", d));
        }
      }, Object.defineProperty(yC, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(yC);
    }
    function kC(i, o, d, h) {
      var b = i.memoizedState, C = d(h, b);
      {
        if (i.mode & Or) {
          si(!0);
          try {
            C = d(h, b);
          } finally {
            si(!1);
          }
        }
        WR(o, C);
      }
      var R = C == null ? b : Jt({}, b, C);
      if (i.memoizedState = R, i.lanes === Ne) {
        var A = i.updateQueue;
        A.baseState = R;
      }
    }
    var PC = {
      isMounted: ta,
      enqueueSetState: function(i, o, d) {
        var h = Ta(i), b = sa(), C = Ld(h), R = wu(b, C);
        R.payload = o, d != null && (RS(d, "setState"), R.callback = d);
        var A = Id(h, R, C);
        A !== null && (Vi(A, h, C, b), kS(A, h, C)), nc(h, C);
      },
      enqueueReplaceState: function(i, o, d) {
        var h = Ta(i), b = sa(), C = Ld(h), R = wu(b, C);
        R.tag = FR, R.payload = o, d != null && (RS(d, "replaceState"), R.callback = d);
        var A = Id(h, R, C);
        A !== null && (Vi(A, h, C, b), kS(A, h, C)), nc(h, C);
      },
      enqueueForceUpdate: function(i, o) {
        var d = Ta(i), h = sa(), b = Ld(d), C = wu(h, b);
        C.tag = CS, o != null && (RS(o, "forceUpdate"), C.callback = o);
        var R = Id(d, C, b);
        R !== null && (Vi(R, d, b, h), kS(R, d, b)), Jm(d, b);
      }
    };
    function XR(i, o, d, h, b, C, R) {
      var A = i.stateNode;
      if (typeof A.shouldComponentUpdate == "function") {
        var B = A.shouldComponentUpdate(h, C, R);
        {
          if (i.mode & Or) {
            si(!0);
            try {
              B = A.shouldComponentUpdate(h, C, R);
            } finally {
              si(!1);
            }
          }
          B === void 0 && c("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", rn(o) || "Component");
        }
        return B;
      }
      return o.prototype && o.prototype.isPureReactComponent ? !$t(d, h) || !$t(b, C) : !0;
    }
    function yB(i, o, d) {
      var h = i.stateNode;
      {
        var b = rn(o) || "Component", C = h.render;
        C || (o.prototype && typeof o.prototype.render == "function" ? c("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", b) : c("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", b)), h.getInitialState && !h.getInitialState.isReactClassApproved && !h.state && c("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", b), h.getDefaultProps && !h.getDefaultProps.isReactClassApproved && c("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", b), h.propTypes && c("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", b), h.contextType && c("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", b), h.contextTypes && c("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", b), o.contextType && o.contextTypes && !_C.has(o) && (_C.add(o), c("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", b)), typeof h.componentShouldUpdate == "function" && c("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", b), o.prototype && o.prototype.isPureReactComponent && typeof h.shouldComponentUpdate < "u" && c("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", rn(o) || "A pure component"), typeof h.componentDidUnmount == "function" && c("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", b), typeof h.componentDidReceiveProps == "function" && c("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", b), typeof h.componentWillRecieveProps == "function" && c("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", b), typeof h.UNSAFE_componentWillRecieveProps == "function" && c("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", b);
        var R = h.props !== d;
        h.props !== void 0 && R && c("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", b, b), h.defaultProps && c("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", b, b), typeof h.getSnapshotBeforeUpdate == "function" && typeof h.componentDidUpdate != "function" && !wC.has(o) && (wC.add(o), c("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", rn(o))), typeof h.getDerivedStateFromProps == "function" && c("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", b), typeof h.getDerivedStateFromError == "function" && c("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", b), typeof o.getSnapshotBeforeUpdate == "function" && c("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", b);
        var A = h.state;
        A && (typeof A != "object" || Sn(A)) && c("%s.state: must be set to an object or null", b), typeof h.getChildContext == "function" && typeof o.childContextTypes != "object" && c("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", b);
      }
    }
    function qR(i, o) {
      o.updater = PC, i.stateNode = o, Ju(o, i), o._reactInternalInstance = yC;
    }
    function QR(i, o, d) {
      var h = !1, b = as, C = as, R = o.contextType;
      if ("contextType" in o) {
        var A = (
          // Allow null for conditional declaration
          R === null || R !== void 0 && R.$$typeof === et && R._context === void 0
        );
        if (!A && !TC.has(o)) {
          TC.add(o);
          var B = "";
          R === void 0 ? B = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof R != "object" ? B = " However, it is set to a " + typeof R + "." : R.$$typeof === Be ? B = " Did you accidentally pass the Context.Provider instead?" : R._context !== void 0 ? B = " Did you accidentally pass the Context.Consumer instead?" : B = " However, it is set to an object with keys {" + Object.keys(R).join(", ") + "}.", c("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", rn(o) || "Component", B);
        }
      }
      if (typeof R == "object" && R !== null)
        C = Ii(R);
      else {
        b = rg(i, o, !0);
        var V = o.contextTypes;
        h = V != null, C = h ? ig(i, b) : as;
      }
      var G = new o(d, C);
      if (i.mode & Or) {
        si(!0);
        try {
          G = new o(d, C);
        } finally {
          si(!1);
        }
      }
      var ae = i.memoizedState = G.state !== null && G.state !== void 0 ? G.state : null;
      qR(i, G);
      {
        if (typeof o.getDerivedStateFromProps == "function" && ae === null) {
          var ne = rn(o) || "Component";
          SC.has(ne) || (SC.add(ne), c("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", ne, G.state === null ? "null" : "undefined", ne));
        }
        if (typeof o.getDerivedStateFromProps == "function" || typeof G.getSnapshotBeforeUpdate == "function") {
          var Ce = null, _e = null, Ae = null;
          if (typeof G.componentWillMount == "function" && G.componentWillMount.__suppressDeprecationWarning !== !0 ? Ce = "componentWillMount" : typeof G.UNSAFE_componentWillMount == "function" && (Ce = "UNSAFE_componentWillMount"), typeof G.componentWillReceiveProps == "function" && G.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? _e = "componentWillReceiveProps" : typeof G.UNSAFE_componentWillReceiveProps == "function" && (_e = "UNSAFE_componentWillReceiveProps"), typeof G.componentWillUpdate == "function" && G.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Ae = "componentWillUpdate" : typeof G.UNSAFE_componentWillUpdate == "function" && (Ae = "UNSAFE_componentWillUpdate"), Ce !== null || _e !== null || Ae !== null) {
            var ut = rn(o) || "Component", Ot = typeof o.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            xC.has(ut) || (xC.add(ut), c(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, ut, Ot, Ce !== null ? `
  ` + Ce : "", _e !== null ? `
  ` + _e : "", Ae !== null ? `
  ` + Ae : ""));
          }
        }
      }
      return h && wR(i, b, C), G;
    }
    function bB(i, o) {
      var d = o.state;
      typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount(), d !== o.state && (c("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Ft(i) || "Component"), PC.enqueueReplaceState(o, o.state, null));
    }
    function ZR(i, o, d, h) {
      var b = o.state;
      if (typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps(d, h), typeof o.UNSAFE_componentWillReceiveProps == "function" && o.UNSAFE_componentWillReceiveProps(d, h), o.state !== b) {
        {
          var C = Ft(i) || "Component";
          bC.has(C) || (bC.add(C), c("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", C));
        }
        PC.enqueueReplaceState(o, o.state, null);
      }
    }
    function IC(i, o, d, h) {
      yB(i, o, d);
      var b = i.stateNode;
      b.props = d, b.state = i.memoizedState, b.refs = KR, mC(i);
      var C = o.contextType;
      if (typeof C == "object" && C !== null)
        b.context = Ii(C);
      else {
        var R = rg(i, o, !0);
        b.context = ig(i, R);
      }
      {
        if (b.state === d) {
          var A = rn(o) || "Component";
          CC.has(A) || (CC.add(A), c("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", A));
        }
        i.mode & Or && bl.recordLegacyContextWarning(i, b), bl.recordUnsafeLifecycleWarnings(i, b);
      }
      b.state = i.memoizedState;
      var B = o.getDerivedStateFromProps;
      if (typeof B == "function" && (kC(i, o, B, d), b.state = i.memoizedState), typeof o.getDerivedStateFromProps != "function" && typeof b.getSnapshotBeforeUpdate != "function" && (typeof b.UNSAFE_componentWillMount == "function" || typeof b.componentWillMount == "function") && (bB(i, b), PS(i, d, b, h), b.state = i.memoizedState), typeof b.componentDidMount == "function") {
        var V = on;
        V |= Ao, (i.mode & $a) !== Dt && (V |= Oo), i.flags |= V;
      }
    }
    function SB(i, o, d, h) {
      var b = i.stateNode, C = i.memoizedProps;
      b.props = C;
      var R = b.context, A = o.contextType, B = as;
      if (typeof A == "object" && A !== null)
        B = Ii(A);
      else {
        var V = rg(i, o, !0);
        B = ig(i, V);
      }
      var G = o.getDerivedStateFromProps, ae = typeof G == "function" || typeof b.getSnapshotBeforeUpdate == "function";
      !ae && (typeof b.UNSAFE_componentWillReceiveProps == "function" || typeof b.componentWillReceiveProps == "function") && (C !== d || R !== B) && ZR(i, b, d, B), VR();
      var ne = i.memoizedState, Ce = b.state = ne;
      if (PS(i, d, b, h), Ce = i.memoizedState, C === d && ne === Ce && !dS() && !IS()) {
        if (typeof b.componentDidMount == "function") {
          var _e = on;
          _e |= Ao, (i.mode & $a) !== Dt && (_e |= Oo), i.flags |= _e;
        }
        return !1;
      }
      typeof G == "function" && (kC(i, o, G, d), Ce = i.memoizedState);
      var Ae = IS() || XR(i, o, C, d, ne, Ce, B);
      if (Ae) {
        if (!ae && (typeof b.UNSAFE_componentWillMount == "function" || typeof b.componentWillMount == "function") && (typeof b.componentWillMount == "function" && b.componentWillMount(), typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount()), typeof b.componentDidMount == "function") {
          var ut = on;
          ut |= Ao, (i.mode & $a) !== Dt && (ut |= Oo), i.flags |= ut;
        }
      } else {
        if (typeof b.componentDidMount == "function") {
          var Ot = on;
          Ot |= Ao, (i.mode & $a) !== Dt && (Ot |= Oo), i.flags |= Ot;
        }
        i.memoizedProps = d, i.memoizedState = Ce;
      }
      return b.props = d, b.state = Ce, b.context = B, Ae;
    }
    function wB(i, o, d, h, b) {
      var C = o.stateNode;
      HR(i, o);
      var R = o.memoizedProps, A = o.type === o.elementType ? R : Sl(o.type, R);
      C.props = A;
      var B = o.pendingProps, V = C.context, G = d.contextType, ae = as;
      if (typeof G == "object" && G !== null)
        ae = Ii(G);
      else {
        var ne = rg(o, d, !0);
        ae = ig(o, ne);
      }
      var Ce = d.getDerivedStateFromProps, _e = typeof Ce == "function" || typeof C.getSnapshotBeforeUpdate == "function";
      !_e && (typeof C.UNSAFE_componentWillReceiveProps == "function" || typeof C.componentWillReceiveProps == "function") && (R !== B || V !== ae) && ZR(o, C, h, ae), VR();
      var Ae = o.memoizedState, ut = C.state = Ae;
      if (PS(o, h, C, b), ut = o.memoizedState, R === B && Ae === ut && !dS() && !IS() && !de)
        return typeof C.componentDidUpdate == "function" && (R !== i.memoizedProps || Ae !== i.memoizedState) && (o.flags |= on), typeof C.getSnapshotBeforeUpdate == "function" && (R !== i.memoizedProps || Ae !== i.memoizedState) && (o.flags |= ka), !1;
      typeof Ce == "function" && (kC(o, d, Ce, h), ut = o.memoizedState);
      var Ot = IS() || XR(o, d, A, h, Ae, ut, ae) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      de;
      return Ot ? (!_e && (typeof C.UNSAFE_componentWillUpdate == "function" || typeof C.componentWillUpdate == "function") && (typeof C.componentWillUpdate == "function" && C.componentWillUpdate(h, ut, ae), typeof C.UNSAFE_componentWillUpdate == "function" && C.UNSAFE_componentWillUpdate(h, ut, ae)), typeof C.componentDidUpdate == "function" && (o.flags |= on), typeof C.getSnapshotBeforeUpdate == "function" && (o.flags |= ka)) : (typeof C.componentDidUpdate == "function" && (R !== i.memoizedProps || Ae !== i.memoizedState) && (o.flags |= on), typeof C.getSnapshotBeforeUpdate == "function" && (R !== i.memoizedProps || Ae !== i.memoizedState) && (o.flags |= ka), o.memoizedProps = h, o.memoizedState = ut), C.props = h, C.state = ut, C.context = ae, Ot;
    }
    var RC, $C, MC, AC, OC, JR = function(i, o) {
    };
    RC = !1, $C = !1, MC = {}, AC = {}, OC = {}, JR = function(i, o) {
      if (!(i === null || typeof i != "object") && !(!i._store || i._store.validated || i.key != null)) {
        if (typeof i._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        i._store.validated = !0;
        var d = Ft(o) || "Component";
        AC[d] || (AC[d] = !0, c('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function Gv(i, o, d) {
      var h = d.ref;
      if (h !== null && typeof h != "function" && typeof h != "object") {
        if ((i.mode & Or || $e) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(d._owner && d._self && d._owner.stateNode !== d._self)) {
          var b = Ft(i) || "Component";
          MC[b] || (c('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', h), MC[b] = !0);
        }
        if (d._owner) {
          var C = d._owner, R;
          if (C) {
            var A = C;
            if (A.tag !== g)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            R = A.stateNode;
          }
          if (!R)
            throw new Error("Missing owner for string ref " + h + ". This error is likely caused by a bug in React. Please file an issue.");
          var B = R;
          tn(h, "ref");
          var V = "" + h;
          if (o !== null && o.ref !== null && typeof o.ref == "function" && o.ref._stringRef === V)
            return o.ref;
          var G = function(ae) {
            var ne = B.refs;
            ne === KR && (ne = B.refs = {}), ae === null ? delete ne[V] : ne[V] = ae;
          };
          return G._stringRef = V, G;
        } else {
          if (typeof h != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!d._owner)
            throw new Error("Element ref was specified as a string (" + h + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return h;
    }
    function $S(i, o) {
      var d = Object.prototype.toString.call(o);
      throw new Error("Objects are not valid as a React child (found: " + (d === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : d) + "). If you meant to render a collection of children, use an array instead.");
    }
    function MS(i) {
      {
        var o = Ft(i) || "Component";
        if (OC[o])
          return;
        OC[o] = !0, c("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function e$(i) {
      var o = i._payload, d = i._init;
      return d(o);
    }
    function t$(i) {
      function o(be, Oe) {
        if (i) {
          var Se = be.deletions;
          Se === null ? (be.deletions = [Oe], be.flags |= Un) : Se.push(Oe);
        }
      }
      function d(be, Oe) {
        if (!i)
          return null;
        for (var Se = Oe; Se !== null; )
          o(be, Se), Se = Se.sibling;
        return null;
      }
      function h(be, Oe) {
        for (var Se = /* @__PURE__ */ new Map(), We = Oe; We !== null; )
          We.key !== null ? Se.set(We.key, We) : Se.set(We.index, We), We = We.sibling;
        return Se;
      }
      function b(be, Oe) {
        var Se = gp(be, Oe);
        return Se.index = 0, Se.sibling = null, Se;
      }
      function C(be, Oe, Se) {
        if (be.index = Se, !i)
          return be.flags |= Bm, Oe;
        var We = be.alternate;
        if (We !== null) {
          var dt = We.index;
          return dt < Oe ? (be.flags |= mr, Oe) : dt;
        } else
          return be.flags |= mr, Oe;
      }
      function R(be) {
        return i && be.alternate === null && (be.flags |= mr), be;
      }
      function A(be, Oe, Se, We) {
        if (Oe === null || Oe.tag !== _) {
          var dt = sT(Se, be.mode, We);
          return dt.return = be, dt;
        } else {
          var at = b(Oe, Se);
          return at.return = be, at;
        }
      }
      function B(be, Oe, Se, We) {
        var dt = Se.type;
        if (dt === Mi)
          return G(be, Oe, Se.props.children, We, Se.key);
        if (Oe !== null && (Oe.elementType === dt || // Keep this check inline so it only runs on the false path:
        YM(Oe, Se) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof dt == "object" && dt !== null && dt.$$typeof === Rt && e$(dt) === Oe.type)) {
          var at = b(Oe, Se.props);
          return at.ref = Gv(be, Oe, Se), at.return = be, at._debugSource = Se._source, at._debugOwner = Se._owner, at;
        }
        var Bt = aT(Se, be.mode, We);
        return Bt.ref = Gv(be, Oe, Se), Bt.return = be, Bt;
      }
      function V(be, Oe, Se, We) {
        if (Oe === null || Oe.tag !== S || Oe.stateNode.containerInfo !== Se.containerInfo || Oe.stateNode.implementation !== Se.implementation) {
          var dt = lT(Se, be.mode, We);
          return dt.return = be, dt;
        } else {
          var at = b(Oe, Se.children || []);
          return at.return = be, at;
        }
      }
      function G(be, Oe, Se, We, dt) {
        if (Oe === null || Oe.tag !== T) {
          var at = zd(Se, be.mode, We, dt);
          return at.return = be, at;
        } else {
          var Bt = b(Oe, Se);
          return Bt.return = be, Bt;
        }
      }
      function ae(be, Oe, Se) {
        if (typeof Oe == "string" && Oe !== "" || typeof Oe == "number") {
          var We = sT("" + Oe, be.mode, Se);
          return We.return = be, We;
        }
        if (typeof Oe == "object" && Oe !== null) {
          switch (Oe.$$typeof) {
            case xa: {
              var dt = aT(Oe, be.mode, Se);
              return dt.ref = Gv(be, null, Oe), dt.return = be, dt;
            }
            case bi: {
              var at = lT(Oe, be.mode, Se);
              return at.return = be, at;
            }
            case Rt: {
              var Bt = Oe._payload, Zt = Oe._init;
              return ae(be, Zt(Bt), Se);
            }
          }
          if (Sn(Oe) || Xo(Oe)) {
            var er = zd(Oe, be.mode, Se, null);
            return er.return = be, er;
          }
          $S(be, Oe);
        }
        return typeof Oe == "function" && MS(be), null;
      }
      function ne(be, Oe, Se, We) {
        var dt = Oe !== null ? Oe.key : null;
        if (typeof Se == "string" && Se !== "" || typeof Se == "number")
          return dt !== null ? null : A(be, Oe, "" + Se, We);
        if (typeof Se == "object" && Se !== null) {
          switch (Se.$$typeof) {
            case xa:
              return Se.key === dt ? B(be, Oe, Se, We) : null;
            case bi:
              return Se.key === dt ? V(be, Oe, Se, We) : null;
            case Rt: {
              var at = Se._payload, Bt = Se._init;
              return ne(be, Oe, Bt(at), We);
            }
          }
          if (Sn(Se) || Xo(Se))
            return dt !== null ? null : G(be, Oe, Se, We, null);
          $S(be, Se);
        }
        return typeof Se == "function" && MS(be), null;
      }
      function Ce(be, Oe, Se, We, dt) {
        if (typeof We == "string" && We !== "" || typeof We == "number") {
          var at = be.get(Se) || null;
          return A(Oe, at, "" + We, dt);
        }
        if (typeof We == "object" && We !== null) {
          switch (We.$$typeof) {
            case xa: {
              var Bt = be.get(We.key === null ? Se : We.key) || null;
              return B(Oe, Bt, We, dt);
            }
            case bi: {
              var Zt = be.get(We.key === null ? Se : We.key) || null;
              return V(Oe, Zt, We, dt);
            }
            case Rt:
              var er = We._payload, jn = We._init;
              return Ce(be, Oe, Se, jn(er), dt);
          }
          if (Sn(We) || Xo(We)) {
            var pi = be.get(Se) || null;
            return G(Oe, pi, We, dt, null);
          }
          $S(Oe, We);
        }
        return typeof We == "function" && MS(Oe), null;
      }
      function _e(be, Oe, Se) {
        {
          if (typeof be != "object" || be === null)
            return Oe;
          switch (be.$$typeof) {
            case xa:
            case bi:
              JR(be, Se);
              var We = be.key;
              if (typeof We != "string")
                break;
              if (Oe === null) {
                Oe = /* @__PURE__ */ new Set(), Oe.add(We);
                break;
              }
              if (!Oe.has(We)) {
                Oe.add(We);
                break;
              }
              c("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", We);
              break;
            case Rt:
              var dt = be._payload, at = be._init;
              _e(at(dt), Oe, Se);
              break;
          }
        }
        return Oe;
      }
      function Ae(be, Oe, Se, We) {
        for (var dt = null, at = 0; at < Se.length; at++) {
          var Bt = Se[at];
          dt = _e(Bt, dt, be);
        }
        for (var Zt = null, er = null, jn = Oe, pi = 0, zn = 0, ai = null; jn !== null && zn < Se.length; zn++) {
          jn.index > zn ? (ai = jn, jn = null) : ai = jn.sibling;
          var Ho = ne(be, jn, Se[zn], We);
          if (Ho === null) {
            jn === null && (jn = ai);
            break;
          }
          i && jn && Ho.alternate === null && o(be, jn), pi = C(Ho, pi, zn), er === null ? Zt = Ho : er.sibling = Ho, er = Ho, jn = ai;
        }
        if (zn === Se.length) {
          if (d(be, jn), go()) {
            var xo = zn;
            np(be, xo);
          }
          return Zt;
        }
        if (jn === null) {
          for (; zn < Se.length; zn++) {
            var ls = ae(be, Se[zn], We);
            ls !== null && (pi = C(ls, pi, zn), er === null ? Zt = ls : er.sibling = ls, er = ls);
          }
          if (go()) {
            var la = zn;
            np(be, la);
          }
          return Zt;
        }
        for (var ca = h(be, jn); zn < Se.length; zn++) {
          var Vo = Ce(ca, be, zn, Se[zn], We);
          Vo !== null && (i && Vo.alternate !== null && ca.delete(Vo.key === null ? zn : Vo.key), pi = C(Vo, pi, zn), er === null ? Zt = Vo : er.sibling = Vo, er = Vo);
        }
        if (i && ca.forEach(function(Tg) {
          return o(be, Tg);
        }), go()) {
          var ku = zn;
          np(be, ku);
        }
        return Zt;
      }
      function ut(be, Oe, Se, We) {
        var dt = Xo(Se);
        if (typeof dt != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          Se[Symbol.toStringTag] === "Generator" && ($C || c("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), $C = !0), Se.entries === dt && (RC || c("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), RC = !0);
          var at = dt.call(Se);
          if (at)
            for (var Bt = null, Zt = at.next(); !Zt.done; Zt = at.next()) {
              var er = Zt.value;
              Bt = _e(er, Bt, be);
            }
        }
        var jn = dt.call(Se);
        if (jn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var pi = null, zn = null, ai = Oe, Ho = 0, xo = 0, ls = null, la = jn.next(); ai !== null && !la.done; xo++, la = jn.next()) {
          ai.index > xo ? (ls = ai, ai = null) : ls = ai.sibling;
          var ca = ne(be, ai, la.value, We);
          if (ca === null) {
            ai === null && (ai = ls);
            break;
          }
          i && ai && ca.alternate === null && o(be, ai), Ho = C(ca, Ho, xo), zn === null ? pi = ca : zn.sibling = ca, zn = ca, ai = ls;
        }
        if (la.done) {
          if (d(be, ai), go()) {
            var Vo = xo;
            np(be, Vo);
          }
          return pi;
        }
        if (ai === null) {
          for (; !la.done; xo++, la = jn.next()) {
            var ku = ae(be, la.value, We);
            ku !== null && (Ho = C(ku, Ho, xo), zn === null ? pi = ku : zn.sibling = ku, zn = ku);
          }
          if (go()) {
            var Tg = xo;
            np(be, Tg);
          }
          return pi;
        }
        for (var Cy = h(be, ai); !la.done; xo++, la = jn.next()) {
          var Sc = Ce(Cy, be, xo, la.value, We);
          Sc !== null && (i && Sc.alternate !== null && Cy.delete(Sc.key === null ? xo : Sc.key), Ho = C(Sc, Ho, xo), zn === null ? pi = Sc : zn.sibling = Sc, zn = Sc);
        }
        if (i && Cy.forEach(function(D7) {
          return o(be, D7);
        }), go()) {
          var O7 = xo;
          np(be, O7);
        }
        return pi;
      }
      function Ot(be, Oe, Se, We) {
        if (Oe !== null && Oe.tag === _) {
          d(be, Oe.sibling);
          var dt = b(Oe, Se);
          return dt.return = be, dt;
        }
        d(be, Oe);
        var at = sT(Se, be.mode, We);
        return at.return = be, at;
      }
      function Pt(be, Oe, Se, We) {
        for (var dt = Se.key, at = Oe; at !== null; ) {
          if (at.key === dt) {
            var Bt = Se.type;
            if (Bt === Mi) {
              if (at.tag === T) {
                d(be, at.sibling);
                var Zt = b(at, Se.props.children);
                return Zt.return = be, Zt._debugSource = Se._source, Zt._debugOwner = Se._owner, Zt;
              }
            } else if (at.elementType === Bt || // Keep this check inline so it only runs on the false path:
            YM(at, Se) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof Bt == "object" && Bt !== null && Bt.$$typeof === Rt && e$(Bt) === at.type) {
              d(be, at.sibling);
              var er = b(at, Se.props);
              return er.ref = Gv(be, at, Se), er.return = be, er._debugSource = Se._source, er._debugOwner = Se._owner, er;
            }
            d(be, at);
            break;
          } else
            o(be, at);
          at = at.sibling;
        }
        if (Se.type === Mi) {
          var jn = zd(Se.props.children, be.mode, We, Se.key);
          return jn.return = be, jn;
        } else {
          var pi = aT(Se, be.mode, We);
          return pi.ref = Gv(be, Oe, Se), pi.return = be, pi;
        }
      }
      function _n(be, Oe, Se, We) {
        for (var dt = Se.key, at = Oe; at !== null; ) {
          if (at.key === dt)
            if (at.tag === S && at.stateNode.containerInfo === Se.containerInfo && at.stateNode.implementation === Se.implementation) {
              d(be, at.sibling);
              var Bt = b(at, Se.children || []);
              return Bt.return = be, Bt;
            } else {
              d(be, at);
              break;
            }
          else
            o(be, at);
          at = at.sibling;
        }
        var Zt = lT(Se, be.mode, We);
        return Zt.return = be, Zt;
      }
      function vn(be, Oe, Se, We) {
        var dt = typeof Se == "object" && Se !== null && Se.type === Mi && Se.key === null;
        if (dt && (Se = Se.props.children), typeof Se == "object" && Se !== null) {
          switch (Se.$$typeof) {
            case xa:
              return R(Pt(be, Oe, Se, We));
            case bi:
              return R(_n(be, Oe, Se, We));
            case Rt:
              var at = Se._payload, Bt = Se._init;
              return vn(be, Oe, Bt(at), We);
          }
          if (Sn(Se))
            return Ae(be, Oe, Se, We);
          if (Xo(Se))
            return ut(be, Oe, Se, We);
          $S(be, Se);
        }
        return typeof Se == "string" && Se !== "" || typeof Se == "number" ? R(Ot(be, Oe, "" + Se, We)) : (typeof Se == "function" && MS(be), d(be, Oe));
      }
      return vn;
    }
    var ug = t$(!0), n$ = t$(!1);
    function xB(i, o) {
      if (i !== null && o.child !== i.child)
        throw new Error("Resuming work not yet implemented.");
      if (o.child !== null) {
        var d = o.child, h = gp(d, d.pendingProps);
        for (o.child = h, h.return = o; d.sibling !== null; )
          d = d.sibling, h = h.sibling = gp(d, d.pendingProps), h.return = o;
        h.sibling = null;
      }
    }
    function EB(i, o) {
      for (var d = i.child; d !== null; )
        ZF(d, o), d = d.sibling;
    }
    var Xv = {}, Rd = _d(Xv), qv = _d(Xv), AS = _d(Xv);
    function OS(i) {
      if (i === Xv)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return i;
    }
    function r$() {
      var i = OS(AS.current);
      return i;
    }
    function DC(i, o) {
      Bo(AS, o, i), Bo(qv, i, i), Bo(Rd, Xv, i);
      var d = L6(o);
      Uo(Rd, i), Bo(Rd, d, i);
    }
    function dg(i) {
      Uo(Rd, i), Uo(qv, i), Uo(AS, i);
    }
    function NC() {
      var i = OS(Rd.current);
      return i;
    }
    function i$(i) {
      OS(AS.current);
      var o = OS(Rd.current), d = j6(o, i.type);
      o !== d && (Bo(qv, i, i), Bo(Rd, d, i));
    }
    function LC(i) {
      qv.current === i && (Uo(Rd, i), Uo(qv, i));
    }
    var CB = 0, o$ = 1, a$ = 1, Qv = 2, wl = _d(CB);
    function jC(i, o) {
      return (i & o) !== 0;
    }
    function fg(i) {
      return i & o$;
    }
    function zC(i, o) {
      return i & o$ | o;
    }
    function _B(i, o) {
      return i | o;
    }
    function $d(i, o) {
      Bo(wl, o, i);
    }
    function pg(i) {
      Uo(wl, i);
    }
    function TB(i, o) {
      var d = i.memoizedState;
      return d !== null ? d.dehydrated !== null : (i.memoizedProps, !0);
    }
    function DS(i) {
      for (var o = i; o !== null; ) {
        if (o.tag === z) {
          var d = o.memoizedState;
          if (d !== null) {
            var h = d.dehydrated;
            if (h === null || mR(h) || YE(h))
              return o;
          }
        } else if (o.tag === pe && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        o.memoizedProps.revealOrder !== void 0) {
          var b = (o.flags & Ht) !== Mt;
          if (b)
            return o;
        } else if (o.child !== null) {
          o.child.return = o, o = o.child;
          continue;
        }
        if (o === i)
          return null;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === i)
            return null;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
      return null;
    }
    var za = (
      /*   */
      0
    ), Li = (
      /* */
      1
    ), pc = (
      /*  */
      2
    ), ji = (
      /*    */
      4
    ), mo = (
      /*   */
      8
    ), UC = [];
    function BC() {
      for (var i = 0; i < UC.length; i++) {
        var o = UC[i];
        o._workInProgressVersionPrimary = null;
      }
      UC.length = 0;
    }
    function kB(i, o) {
      var d = o._getVersion, h = d(o._source);
      i.mutableSourceEagerHydrationData == null ? i.mutableSourceEagerHydrationData = [o, h] : i.mutableSourceEagerHydrationData.push(o, h);
    }
    var ct = n.ReactCurrentDispatcher, Zv = n.ReactCurrentBatchConfig, FC, hg;
    FC = /* @__PURE__ */ new Set();
    var lp = Ne, Jn = null, zi = null, Ui = null, NS = !1, Jv = !1, ey = 0, PB = 0, IB = 25, je = null, Ns = null, Md = -1, HC = !1;
    function Yn() {
      {
        var i = je;
        Ns === null ? Ns = [i] : Ns.push(i);
      }
    }
    function nt() {
      {
        var i = je;
        Ns !== null && (Md++, Ns[Md] !== i && RB(i));
      }
    }
    function gg(i) {
      i != null && !Sn(i) && c("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", je, typeof i);
    }
    function RB(i) {
      {
        var o = Ft(Jn);
        if (!FC.has(o) && (FC.add(o), Ns !== null)) {
          for (var d = "", h = 30, b = 0; b <= Md; b++) {
            for (var C = Ns[b], R = b === Md ? i : C, A = b + 1 + ". " + C; A.length < h; )
              A += " ";
            A += R + `
`, d += A;
          }
          c(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, o, d);
        }
      }
    }
    function Fo() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function VC(i, o) {
      if (HC)
        return !1;
      if (o === null)
        return c("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", je), !1;
      i.length !== o.length && c(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, je, "[" + o.join(", ") + "]", "[" + i.join(", ") + "]");
      for (var d = 0; d < o.length && d < i.length; d++)
        if (!mt(i[d], o[d]))
          return !1;
      return !0;
    }
    function mg(i, o, d, h, b, C) {
      lp = C, Jn = o, Ns = i !== null ? i._debugHookTypes : null, Md = -1, HC = i !== null && i.type !== o.type, o.memoizedState = null, o.updateQueue = null, o.lanes = Ne, i !== null && i.memoizedState !== null ? ct.current = P$ : Ns !== null ? ct.current = k$ : ct.current = T$;
      var R = d(h, b);
      if (Jv) {
        var A = 0;
        do {
          if (Jv = !1, ey = 0, A >= IB)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          A += 1, HC = !1, zi = null, Ui = null, o.updateQueue = null, Md = -1, ct.current = I$, R = d(h, b);
        } while (Jv);
      }
      ct.current = XS, o._debugHookTypes = Ns;
      var B = zi !== null && zi.next !== null;
      if (lp = Ne, Jn = null, zi = null, Ui = null, je = null, Ns = null, Md = -1, i !== null && (i.flags & Oi) !== (o.flags & Oi) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (i.mode & fn) !== Dt && c("Internal React error: Expected static flag was missing. Please notify the React team."), NS = !1, B)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return R;
    }
    function vg() {
      var i = ey !== 0;
      return ey = 0, i;
    }
    function s$(i, o, d) {
      o.updateQueue = i.updateQueue, (o.mode & $a) !== Dt ? o.flags &= ~(Xc | Oo | kr | on) : o.flags &= ~(kr | on), i.lanes = ld(i.lanes, d);
    }
    function l$() {
      if (ct.current = XS, NS) {
        for (var i = Jn.memoizedState; i !== null; ) {
          var o = i.queue;
          o !== null && (o.pending = null), i = i.next;
        }
        NS = !1;
      }
      lp = Ne, Jn = null, zi = null, Ui = null, Ns = null, Md = -1, je = null, w$ = !1, Jv = !1, ey = 0;
    }
    function hc() {
      var i = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Ui === null ? Jn.memoizedState = Ui = i : Ui = Ui.next = i, Ui;
    }
    function Ls() {
      var i;
      if (zi === null) {
        var o = Jn.alternate;
        o !== null ? i = o.memoizedState : i = null;
      } else
        i = zi.next;
      var d;
      if (Ui === null ? d = Jn.memoizedState : d = Ui.next, d !== null)
        Ui = d, d = Ui.next, zi = i;
      else {
        if (i === null)
          throw new Error("Rendered more hooks than during the previous render.");
        zi = i;
        var h = {
          memoizedState: zi.memoizedState,
          baseState: zi.baseState,
          baseQueue: zi.baseQueue,
          queue: zi.queue,
          next: null
        };
        Ui === null ? Jn.memoizedState = Ui = h : Ui = Ui.next = h;
      }
      return Ui;
    }
    function c$() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function YC(i, o) {
      return typeof o == "function" ? o(i) : o;
    }
    function KC(i, o, d) {
      var h = hc(), b;
      d !== void 0 ? b = d(o) : b = o, h.memoizedState = h.baseState = b;
      var C = {
        pending: null,
        interleaved: null,
        lanes: Ne,
        dispatch: null,
        lastRenderedReducer: i,
        lastRenderedState: b
      };
      h.queue = C;
      var R = C.dispatch = OB.bind(null, Jn, C);
      return [h.memoizedState, R];
    }
    function WC(i, o, d) {
      var h = Ls(), b = h.queue;
      if (b === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      b.lastRenderedReducer = i;
      var C = zi, R = C.baseQueue, A = b.pending;
      if (A !== null) {
        if (R !== null) {
          var B = R.next, V = A.next;
          R.next = V, A.next = B;
        }
        C.baseQueue !== R && c("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), C.baseQueue = R = A, b.pending = null;
      }
      if (R !== null) {
        var G = R.next, ae = C.baseState, ne = null, Ce = null, _e = null, Ae = G;
        do {
          var ut = Ae.lane;
          if (ou(lp, ut)) {
            if (_e !== null) {
              var Pt = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: En,
                action: Ae.action,
                hasEagerState: Ae.hasEagerState,
                eagerState: Ae.eagerState,
                next: null
              };
              _e = _e.next = Pt;
            }
            if (Ae.hasEagerState)
              ae = Ae.eagerState;
            else {
              var _n = Ae.action;
              ae = i(ae, _n);
            }
          } else {
            var Ot = {
              lane: ut,
              action: Ae.action,
              hasEagerState: Ae.hasEagerState,
              eagerState: Ae.eagerState,
              next: null
            };
            _e === null ? (Ce = _e = Ot, ne = ae) : _e = _e.next = Ot, Jn.lanes = an(Jn.lanes, ut), by(ut);
          }
          Ae = Ae.next;
        } while (Ae !== null && Ae !== G);
        _e === null ? ne = ae : _e.next = Ce, mt(ae, h.memoizedState) || sy(), h.memoizedState = ae, h.baseState = ne, h.baseQueue = _e, b.lastRenderedState = ae;
      }
      var vn = b.interleaved;
      if (vn !== null) {
        var be = vn;
        do {
          var Oe = be.lane;
          Jn.lanes = an(Jn.lanes, Oe), by(Oe), be = be.next;
        } while (be !== vn);
      } else
        R === null && (b.lanes = Ne);
      var Se = b.dispatch;
      return [h.memoizedState, Se];
    }
    function GC(i, o, d) {
      var h = Ls(), b = h.queue;
      if (b === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      b.lastRenderedReducer = i;
      var C = b.dispatch, R = b.pending, A = h.memoizedState;
      if (R !== null) {
        b.pending = null;
        var B = R.next, V = B;
        do {
          var G = V.action;
          A = i(A, G), V = V.next;
        } while (V !== B);
        mt(A, h.memoizedState) || sy(), h.memoizedState = A, h.baseQueue === null && (h.baseState = A), b.lastRenderedState = A;
      }
      return [A, C];
    }
    function Ape(i, o, d) {
    }
    function Ope(i, o, d) {
    }
    function XC(i, o, d) {
      var h = Jn, b = hc(), C, R = go();
      if (R) {
        if (d === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        C = d(), hg || C !== d() && (c("The result of getServerSnapshot should be cached to avoid an infinite loop"), hg = !0);
      } else {
        if (C = o(), !hg) {
          var A = o();
          mt(C, A) || (c("The result of getSnapshot should be cached to avoid an infinite loop"), hg = !0);
        }
        var B = pw();
        if (B === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        zf(B, lp) || u$(h, o, C);
      }
      b.memoizedState = C;
      var V = {
        value: C,
        getSnapshot: o
      };
      return b.queue = V, BS(f$.bind(null, h, V, i), [i]), h.flags |= kr, ty(Li | mo, d$.bind(null, h, V, C, o), void 0, null), C;
    }
    function LS(i, o, d) {
      var h = Jn, b = Ls(), C = o();
      if (!hg) {
        var R = o();
        mt(C, R) || (c("The result of getSnapshot should be cached to avoid an infinite loop"), hg = !0);
      }
      var A = b.memoizedState, B = !mt(A, C);
      B && (b.memoizedState = C, sy());
      var V = b.queue;
      if (ry(f$.bind(null, h, V, i), [i]), V.getSnapshot !== o || B || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Ui !== null && Ui.memoizedState.tag & Li) {
        h.flags |= kr, ty(Li | mo, d$.bind(null, h, V, C, o), void 0, null);
        var G = pw();
        if (G === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        zf(G, lp) || u$(h, o, C);
      }
      return C;
    }
    function u$(i, o, d) {
      i.flags |= Rf;
      var h = {
        getSnapshot: o,
        value: d
      }, b = Jn.updateQueue;
      if (b === null)
        b = c$(), Jn.updateQueue = b, b.stores = [h];
      else {
        var C = b.stores;
        C === null ? b.stores = [h] : C.push(h);
      }
    }
    function d$(i, o, d, h) {
      o.value = d, o.getSnapshot = h, p$(o) && h$(i);
    }
    function f$(i, o, d) {
      var h = function() {
        p$(o) && h$(i);
      };
      return d(h);
    }
    function p$(i) {
      var o = i.getSnapshot, d = i.value;
      try {
        var h = o();
        return !mt(d, h);
      } catch {
        return !0;
      }
    }
    function h$(i) {
      var o = ja(i, jt);
      o !== null && Vi(o, i, jt, lr);
    }
    function jS(i) {
      var o = hc();
      typeof i == "function" && (i = i()), o.memoizedState = o.baseState = i;
      var d = {
        pending: null,
        interleaved: null,
        lanes: Ne,
        dispatch: null,
        lastRenderedReducer: YC,
        lastRenderedState: i
      };
      o.queue = d;
      var h = d.dispatch = DB.bind(null, Jn, d);
      return [o.memoizedState, h];
    }
    function qC(i) {
      return WC(YC);
    }
    function QC(i) {
      return GC(YC);
    }
    function ty(i, o, d, h) {
      var b = {
        tag: i,
        create: o,
        destroy: d,
        deps: h,
        // Circular
        next: null
      }, C = Jn.updateQueue;
      if (C === null)
        C = c$(), Jn.updateQueue = C, C.lastEffect = b.next = b;
      else {
        var R = C.lastEffect;
        if (R === null)
          C.lastEffect = b.next = b;
        else {
          var A = R.next;
          R.next = b, b.next = A, C.lastEffect = b;
        }
      }
      return b;
    }
    function ZC(i) {
      var o = hc();
      {
        var d = {
          current: i
        };
        return o.memoizedState = d, d;
      }
    }
    function zS(i) {
      var o = Ls();
      return o.memoizedState;
    }
    function ny(i, o, d, h) {
      var b = hc(), C = h === void 0 ? null : h;
      Jn.flags |= i, b.memoizedState = ty(Li | o, d, void 0, C);
    }
    function US(i, o, d, h) {
      var b = Ls(), C = h === void 0 ? null : h, R = void 0;
      if (zi !== null) {
        var A = zi.memoizedState;
        if (R = A.destroy, C !== null) {
          var B = A.deps;
          if (VC(C, B)) {
            b.memoizedState = ty(o, d, R, C);
            return;
          }
        }
      }
      Jn.flags |= i, b.memoizedState = ty(Li | o, d, R, C);
    }
    function BS(i, o) {
      return (Jn.mode & $a) !== Dt ? ny(Xc | kr | ql, mo, i, o) : ny(kr | ql, mo, i, o);
    }
    function ry(i, o) {
      return US(kr, mo, i, o);
    }
    function JC(i, o) {
      return ny(on, pc, i, o);
    }
    function FS(i, o) {
      return US(on, pc, i, o);
    }
    function e_(i, o) {
      var d = on;
      return d |= Ao, (Jn.mode & $a) !== Dt && (d |= Oo), ny(d, ji, i, o);
    }
    function HS(i, o) {
      return US(on, ji, i, o);
    }
    function g$(i, o) {
      if (typeof o == "function") {
        var d = o, h = i();
        return d(h), function() {
          d(null);
        };
      } else if (o != null) {
        var b = o;
        b.hasOwnProperty("current") || c("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(b).join(", ") + "}");
        var C = i();
        return b.current = C, function() {
          b.current = null;
        };
      }
    }
    function t_(i, o, d) {
      typeof o != "function" && c("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", o !== null ? typeof o : "null");
      var h = d != null ? d.concat([i]) : null, b = on;
      return b |= Ao, (Jn.mode & $a) !== Dt && (b |= Oo), ny(b, ji, g$.bind(null, o, i), h);
    }
    function VS(i, o, d) {
      typeof o != "function" && c("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", o !== null ? typeof o : "null");
      var h = d != null ? d.concat([i]) : null;
      return US(on, ji, g$.bind(null, o, i), h);
    }
    function $B(i, o) {
    }
    var YS = $B;
    function n_(i, o) {
      var d = hc(), h = o === void 0 ? null : o;
      return d.memoizedState = [i, h], i;
    }
    function KS(i, o) {
      var d = Ls(), h = o === void 0 ? null : o, b = d.memoizedState;
      if (b !== null && h !== null) {
        var C = b[1];
        if (VC(h, C))
          return b[0];
      }
      return d.memoizedState = [i, h], i;
    }
    function r_(i, o) {
      var d = hc(), h = o === void 0 ? null : o, b = i();
      return d.memoizedState = [b, h], b;
    }
    function WS(i, o) {
      var d = Ls(), h = o === void 0 ? null : o, b = d.memoizedState;
      if (b !== null && h !== null) {
        var C = b[1];
        if (VC(h, C))
          return b[0];
      }
      var R = i();
      return d.memoizedState = [R, h], R;
    }
    function i_(i) {
      var o = hc();
      return o.memoizedState = i, i;
    }
    function m$(i) {
      var o = Ls(), d = zi, h = d.memoizedState;
      return y$(o, h, i);
    }
    function v$(i) {
      var o = Ls();
      if (zi === null)
        return o.memoizedState = i, i;
      var d = zi.memoizedState;
      return y$(o, d, i);
    }
    function y$(i, o, d) {
      var h = !uE(lp);
      if (h) {
        if (!mt(d, o)) {
          var b = iv();
          Jn.lanes = an(Jn.lanes, b), by(b), i.baseState = !0;
        }
        return o;
      } else
        return i.baseState && (i.baseState = !1, sy()), i.memoizedState = d, d;
    }
    function MB(i, o, d) {
      var h = Aa();
      ci(Qi(h, Ni)), i(!0);
      var b = Zv.transition;
      Zv.transition = {};
      var C = Zv.transition;
      Zv.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        i(!1), o();
      } finally {
        if (ci(h), Zv.transition = b, b === null && C._updatedFibers) {
          var R = C._updatedFibers.size;
          R > 10 && s("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), C._updatedFibers.clear();
        }
      }
    }
    function o_() {
      var i = jS(!1), o = i[0], d = i[1], h = MB.bind(null, d), b = hc();
      return b.memoizedState = h, [o, h];
    }
    function b$() {
      var i = qC(), o = i[0], d = Ls(), h = d.memoizedState;
      return [o, h];
    }
    function S$() {
      var i = QC(), o = i[0], d = Ls(), h = d.memoizedState;
      return [o, h];
    }
    var w$ = !1;
    function AB() {
      return w$;
    }
    function a_() {
      var i = hc(), o = pw(), d = o.identifierPrefix, h;
      if (go()) {
        var b = WU();
        h = ":" + d + "R" + b;
        var C = ey++;
        C > 0 && (h += "H" + C.toString(32)), h += ":";
      } else {
        var R = PB++;
        h = ":" + d + "r" + R.toString(32) + ":";
      }
      return i.memoizedState = h, h;
    }
    function GS() {
      var i = Ls(), o = i.memoizedState;
      return o;
    }
    function OB(i, o, d) {
      typeof arguments[3] == "function" && c("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var h = Ld(i), b = {
        lane: h,
        action: d,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (x$(i))
        E$(o, b);
      else {
        var C = UR(i, o, b, h);
        if (C !== null) {
          var R = sa();
          Vi(C, i, h, R), C$(C, o, h);
        }
      }
      _$(i, h);
    }
    function DB(i, o, d) {
      typeof arguments[3] == "function" && c("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var h = Ld(i), b = {
        lane: h,
        action: d,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (x$(i))
        E$(o, b);
      else {
        var C = i.alternate;
        if (i.lanes === Ne && (C === null || C.lanes === Ne)) {
          var R = o.lastRenderedReducer;
          if (R !== null) {
            var A;
            A = ct.current, ct.current = xl;
            try {
              var B = o.lastRenderedState, V = R(B, d);
              if (b.hasEagerState = !0, b.eagerState = V, mt(V, B)) {
                pB(i, o, b, h);
                return;
              }
            } catch {
            } finally {
              ct.current = A;
            }
          }
        }
        var G = UR(i, o, b, h);
        if (G !== null) {
          var ae = sa();
          Vi(G, i, h, ae), C$(G, o, h);
        }
      }
      _$(i, h);
    }
    function x$(i) {
      var o = i.alternate;
      return i === Jn || o !== null && o === Jn;
    }
    function E$(i, o) {
      Jv = NS = !0;
      var d = i.pending;
      d === null ? o.next = o : (o.next = d.next, d.next = o), i.pending = o;
    }
    function C$(i, o, d) {
      if (rv(d)) {
        var h = o.lanes;
        h = ov(h, i.pendingLanes);
        var b = an(h, d);
        o.lanes = b, cd(i, b);
      }
    }
    function _$(i, o, d) {
      nc(i, o);
    }
    var XS = {
      readContext: Ii,
      useCallback: Fo,
      useContext: Fo,
      useEffect: Fo,
      useImperativeHandle: Fo,
      useInsertionEffect: Fo,
      useLayoutEffect: Fo,
      useMemo: Fo,
      useReducer: Fo,
      useRef: Fo,
      useState: Fo,
      useDebugValue: Fo,
      useDeferredValue: Fo,
      useTransition: Fo,
      useMutableSource: Fo,
      useSyncExternalStore: Fo,
      useId: Fo,
      unstable_isNewReconciler: te
    }, T$ = null, k$ = null, P$ = null, I$ = null, gc = null, xl = null, qS = null;
    {
      var s_ = function() {
        c("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Wt = function() {
        c("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      T$ = {
        readContext: function(i) {
          return Ii(i);
        },
        useCallback: function(i, o) {
          return je = "useCallback", Yn(), gg(o), n_(i, o);
        },
        useContext: function(i) {
          return je = "useContext", Yn(), Ii(i);
        },
        useEffect: function(i, o) {
          return je = "useEffect", Yn(), gg(o), BS(i, o);
        },
        useImperativeHandle: function(i, o, d) {
          return je = "useImperativeHandle", Yn(), gg(d), t_(i, o, d);
        },
        useInsertionEffect: function(i, o) {
          return je = "useInsertionEffect", Yn(), gg(o), JC(i, o);
        },
        useLayoutEffect: function(i, o) {
          return je = "useLayoutEffect", Yn(), gg(o), e_(i, o);
        },
        useMemo: function(i, o) {
          je = "useMemo", Yn(), gg(o);
          var d = ct.current;
          ct.current = gc;
          try {
            return r_(i, o);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(i, o, d) {
          je = "useReducer", Yn();
          var h = ct.current;
          ct.current = gc;
          try {
            return KC(i, o, d);
          } finally {
            ct.current = h;
          }
        },
        useRef: function(i) {
          return je = "useRef", Yn(), ZC(i);
        },
        useState: function(i) {
          je = "useState", Yn();
          var o = ct.current;
          ct.current = gc;
          try {
            return jS(i);
          } finally {
            ct.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return je = "useDebugValue", Yn(), void 0;
        },
        useDeferredValue: function(i) {
          return je = "useDeferredValue", Yn(), i_(i);
        },
        useTransition: function() {
          return je = "useTransition", Yn(), o_();
        },
        useMutableSource: function(i, o, d) {
          return je = "useMutableSource", Yn(), void 0;
        },
        useSyncExternalStore: function(i, o, d) {
          return je = "useSyncExternalStore", Yn(), XC(i, o, d);
        },
        useId: function() {
          return je = "useId", Yn(), a_();
        },
        unstable_isNewReconciler: te
      }, k$ = {
        readContext: function(i) {
          return Ii(i);
        },
        useCallback: function(i, o) {
          return je = "useCallback", nt(), n_(i, o);
        },
        useContext: function(i) {
          return je = "useContext", nt(), Ii(i);
        },
        useEffect: function(i, o) {
          return je = "useEffect", nt(), BS(i, o);
        },
        useImperativeHandle: function(i, o, d) {
          return je = "useImperativeHandle", nt(), t_(i, o, d);
        },
        useInsertionEffect: function(i, o) {
          return je = "useInsertionEffect", nt(), JC(i, o);
        },
        useLayoutEffect: function(i, o) {
          return je = "useLayoutEffect", nt(), e_(i, o);
        },
        useMemo: function(i, o) {
          je = "useMemo", nt();
          var d = ct.current;
          ct.current = gc;
          try {
            return r_(i, o);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(i, o, d) {
          je = "useReducer", nt();
          var h = ct.current;
          ct.current = gc;
          try {
            return KC(i, o, d);
          } finally {
            ct.current = h;
          }
        },
        useRef: function(i) {
          return je = "useRef", nt(), ZC(i);
        },
        useState: function(i) {
          je = "useState", nt();
          var o = ct.current;
          ct.current = gc;
          try {
            return jS(i);
          } finally {
            ct.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return je = "useDebugValue", nt(), void 0;
        },
        useDeferredValue: function(i) {
          return je = "useDeferredValue", nt(), i_(i);
        },
        useTransition: function() {
          return je = "useTransition", nt(), o_();
        },
        useMutableSource: function(i, o, d) {
          return je = "useMutableSource", nt(), void 0;
        },
        useSyncExternalStore: function(i, o, d) {
          return je = "useSyncExternalStore", nt(), XC(i, o, d);
        },
        useId: function() {
          return je = "useId", nt(), a_();
        },
        unstable_isNewReconciler: te
      }, P$ = {
        readContext: function(i) {
          return Ii(i);
        },
        useCallback: function(i, o) {
          return je = "useCallback", nt(), KS(i, o);
        },
        useContext: function(i) {
          return je = "useContext", nt(), Ii(i);
        },
        useEffect: function(i, o) {
          return je = "useEffect", nt(), ry(i, o);
        },
        useImperativeHandle: function(i, o, d) {
          return je = "useImperativeHandle", nt(), VS(i, o, d);
        },
        useInsertionEffect: function(i, o) {
          return je = "useInsertionEffect", nt(), FS(i, o);
        },
        useLayoutEffect: function(i, o) {
          return je = "useLayoutEffect", nt(), HS(i, o);
        },
        useMemo: function(i, o) {
          je = "useMemo", nt();
          var d = ct.current;
          ct.current = xl;
          try {
            return WS(i, o);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(i, o, d) {
          je = "useReducer", nt();
          var h = ct.current;
          ct.current = xl;
          try {
            return WC(i, o, d);
          } finally {
            ct.current = h;
          }
        },
        useRef: function(i) {
          return je = "useRef", nt(), zS();
        },
        useState: function(i) {
          je = "useState", nt();
          var o = ct.current;
          ct.current = xl;
          try {
            return qC(i);
          } finally {
            ct.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return je = "useDebugValue", nt(), YS();
        },
        useDeferredValue: function(i) {
          return je = "useDeferredValue", nt(), m$(i);
        },
        useTransition: function() {
          return je = "useTransition", nt(), b$();
        },
        useMutableSource: function(i, o, d) {
          return je = "useMutableSource", nt(), void 0;
        },
        useSyncExternalStore: function(i, o, d) {
          return je = "useSyncExternalStore", nt(), LS(i, o);
        },
        useId: function() {
          return je = "useId", nt(), GS();
        },
        unstable_isNewReconciler: te
      }, I$ = {
        readContext: function(i) {
          return Ii(i);
        },
        useCallback: function(i, o) {
          return je = "useCallback", nt(), KS(i, o);
        },
        useContext: function(i) {
          return je = "useContext", nt(), Ii(i);
        },
        useEffect: function(i, o) {
          return je = "useEffect", nt(), ry(i, o);
        },
        useImperativeHandle: function(i, o, d) {
          return je = "useImperativeHandle", nt(), VS(i, o, d);
        },
        useInsertionEffect: function(i, o) {
          return je = "useInsertionEffect", nt(), FS(i, o);
        },
        useLayoutEffect: function(i, o) {
          return je = "useLayoutEffect", nt(), HS(i, o);
        },
        useMemo: function(i, o) {
          je = "useMemo", nt();
          var d = ct.current;
          ct.current = qS;
          try {
            return WS(i, o);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(i, o, d) {
          je = "useReducer", nt();
          var h = ct.current;
          ct.current = qS;
          try {
            return GC(i, o, d);
          } finally {
            ct.current = h;
          }
        },
        useRef: function(i) {
          return je = "useRef", nt(), zS();
        },
        useState: function(i) {
          je = "useState", nt();
          var o = ct.current;
          ct.current = qS;
          try {
            return QC(i);
          } finally {
            ct.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return je = "useDebugValue", nt(), YS();
        },
        useDeferredValue: function(i) {
          return je = "useDeferredValue", nt(), v$(i);
        },
        useTransition: function() {
          return je = "useTransition", nt(), S$();
        },
        useMutableSource: function(i, o, d) {
          return je = "useMutableSource", nt(), void 0;
        },
        useSyncExternalStore: function(i, o, d) {
          return je = "useSyncExternalStore", nt(), LS(i, o);
        },
        useId: function() {
          return je = "useId", nt(), GS();
        },
        unstable_isNewReconciler: te
      }, gc = {
        readContext: function(i) {
          return s_(), Ii(i);
        },
        useCallback: function(i, o) {
          return je = "useCallback", Wt(), Yn(), n_(i, o);
        },
        useContext: function(i) {
          return je = "useContext", Wt(), Yn(), Ii(i);
        },
        useEffect: function(i, o) {
          return je = "useEffect", Wt(), Yn(), BS(i, o);
        },
        useImperativeHandle: function(i, o, d) {
          return je = "useImperativeHandle", Wt(), Yn(), t_(i, o, d);
        },
        useInsertionEffect: function(i, o) {
          return je = "useInsertionEffect", Wt(), Yn(), JC(i, o);
        },
        useLayoutEffect: function(i, o) {
          return je = "useLayoutEffect", Wt(), Yn(), e_(i, o);
        },
        useMemo: function(i, o) {
          je = "useMemo", Wt(), Yn();
          var d = ct.current;
          ct.current = gc;
          try {
            return r_(i, o);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(i, o, d) {
          je = "useReducer", Wt(), Yn();
          var h = ct.current;
          ct.current = gc;
          try {
            return KC(i, o, d);
          } finally {
            ct.current = h;
          }
        },
        useRef: function(i) {
          return je = "useRef", Wt(), Yn(), ZC(i);
        },
        useState: function(i) {
          je = "useState", Wt(), Yn();
          var o = ct.current;
          ct.current = gc;
          try {
            return jS(i);
          } finally {
            ct.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return je = "useDebugValue", Wt(), Yn(), void 0;
        },
        useDeferredValue: function(i) {
          return je = "useDeferredValue", Wt(), Yn(), i_(i);
        },
        useTransition: function() {
          return je = "useTransition", Wt(), Yn(), o_();
        },
        useMutableSource: function(i, o, d) {
          return je = "useMutableSource", Wt(), Yn(), void 0;
        },
        useSyncExternalStore: function(i, o, d) {
          return je = "useSyncExternalStore", Wt(), Yn(), XC(i, o, d);
        },
        useId: function() {
          return je = "useId", Wt(), Yn(), a_();
        },
        unstable_isNewReconciler: te
      }, xl = {
        readContext: function(i) {
          return s_(), Ii(i);
        },
        useCallback: function(i, o) {
          return je = "useCallback", Wt(), nt(), KS(i, o);
        },
        useContext: function(i) {
          return je = "useContext", Wt(), nt(), Ii(i);
        },
        useEffect: function(i, o) {
          return je = "useEffect", Wt(), nt(), ry(i, o);
        },
        useImperativeHandle: function(i, o, d) {
          return je = "useImperativeHandle", Wt(), nt(), VS(i, o, d);
        },
        useInsertionEffect: function(i, o) {
          return je = "useInsertionEffect", Wt(), nt(), FS(i, o);
        },
        useLayoutEffect: function(i, o) {
          return je = "useLayoutEffect", Wt(), nt(), HS(i, o);
        },
        useMemo: function(i, o) {
          je = "useMemo", Wt(), nt();
          var d = ct.current;
          ct.current = xl;
          try {
            return WS(i, o);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(i, o, d) {
          je = "useReducer", Wt(), nt();
          var h = ct.current;
          ct.current = xl;
          try {
            return WC(i, o, d);
          } finally {
            ct.current = h;
          }
        },
        useRef: function(i) {
          return je = "useRef", Wt(), nt(), zS();
        },
        useState: function(i) {
          je = "useState", Wt(), nt();
          var o = ct.current;
          ct.current = xl;
          try {
            return qC(i);
          } finally {
            ct.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return je = "useDebugValue", Wt(), nt(), YS();
        },
        useDeferredValue: function(i) {
          return je = "useDeferredValue", Wt(), nt(), m$(i);
        },
        useTransition: function() {
          return je = "useTransition", Wt(), nt(), b$();
        },
        useMutableSource: function(i, o, d) {
          return je = "useMutableSource", Wt(), nt(), void 0;
        },
        useSyncExternalStore: function(i, o, d) {
          return je = "useSyncExternalStore", Wt(), nt(), LS(i, o);
        },
        useId: function() {
          return je = "useId", Wt(), nt(), GS();
        },
        unstable_isNewReconciler: te
      }, qS = {
        readContext: function(i) {
          return s_(), Ii(i);
        },
        useCallback: function(i, o) {
          return je = "useCallback", Wt(), nt(), KS(i, o);
        },
        useContext: function(i) {
          return je = "useContext", Wt(), nt(), Ii(i);
        },
        useEffect: function(i, o) {
          return je = "useEffect", Wt(), nt(), ry(i, o);
        },
        useImperativeHandle: function(i, o, d) {
          return je = "useImperativeHandle", Wt(), nt(), VS(i, o, d);
        },
        useInsertionEffect: function(i, o) {
          return je = "useInsertionEffect", Wt(), nt(), FS(i, o);
        },
        useLayoutEffect: function(i, o) {
          return je = "useLayoutEffect", Wt(), nt(), HS(i, o);
        },
        useMemo: function(i, o) {
          je = "useMemo", Wt(), nt();
          var d = ct.current;
          ct.current = xl;
          try {
            return WS(i, o);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(i, o, d) {
          je = "useReducer", Wt(), nt();
          var h = ct.current;
          ct.current = xl;
          try {
            return GC(i, o, d);
          } finally {
            ct.current = h;
          }
        },
        useRef: function(i) {
          return je = "useRef", Wt(), nt(), zS();
        },
        useState: function(i) {
          je = "useState", Wt(), nt();
          var o = ct.current;
          ct.current = xl;
          try {
            return QC(i);
          } finally {
            ct.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return je = "useDebugValue", Wt(), nt(), YS();
        },
        useDeferredValue: function(i) {
          return je = "useDeferredValue", Wt(), nt(), v$(i);
        },
        useTransition: function() {
          return je = "useTransition", Wt(), nt(), S$();
        },
        useMutableSource: function(i, o, d) {
          return je = "useMutableSource", Wt(), nt(), void 0;
        },
        useSyncExternalStore: function(i, o, d) {
          return je = "useSyncExternalStore", Wt(), nt(), LS(i, o);
        },
        useId: function() {
          return je = "useId", Wt(), nt(), GS();
        },
        unstable_isNewReconciler: te
      };
    }
    var Ad = e.unstable_now, R$ = 0, QS = -1, iy = -1, ZS = -1, l_ = !1, JS = !1;
    function $$() {
      return l_;
    }
    function NB() {
      JS = !0;
    }
    function LB() {
      l_ = !1, JS = !1;
    }
    function jB() {
      l_ = JS, JS = !1;
    }
    function M$() {
      return R$;
    }
    function A$() {
      R$ = Ad();
    }
    function c_(i) {
      iy = Ad(), i.actualStartTime < 0 && (i.actualStartTime = Ad());
    }
    function O$(i) {
      iy = -1;
    }
    function ew(i, o) {
      if (iy >= 0) {
        var d = Ad() - iy;
        i.actualDuration += d, o && (i.selfBaseDuration = d), iy = -1;
      }
    }
    function mc(i) {
      if (QS >= 0) {
        var o = Ad() - QS;
        QS = -1;
        for (var d = i.return; d !== null; ) {
          switch (d.tag) {
            case v:
              var h = d.stateNode;
              h.effectDuration += o;
              return;
            case L:
              var b = d.stateNode;
              b.effectDuration += o;
              return;
          }
          d = d.return;
        }
      }
    }
    function u_(i) {
      if (ZS >= 0) {
        var o = Ad() - ZS;
        ZS = -1;
        for (var d = i.return; d !== null; ) {
          switch (d.tag) {
            case v:
              var h = d.stateNode;
              h !== null && (h.passiveEffectDuration += o);
              return;
            case L:
              var b = d.stateNode;
              b !== null && (b.passiveEffectDuration += o);
              return;
          }
          d = d.return;
        }
      }
    }
    function vc() {
      QS = Ad();
    }
    function d_() {
      ZS = Ad();
    }
    function f_(i) {
      for (var o = i.child; o; )
        i.actualDuration += o.actualDuration, o = o.sibling;
    }
    function cp(i, o) {
      return {
        value: i,
        source: o,
        stack: Qo(o),
        digest: null
      };
    }
    function p_(i, o, d) {
      return {
        value: i,
        source: null,
        stack: d ?? null,
        digest: o ?? null
      };
    }
    function zB(i, o) {
      return !0;
    }
    function h_(i, o) {
      try {
        var d = zB(i, o);
        if (d === !1)
          return;
        var h = o.value, b = o.source, C = o.stack, R = C !== null ? C : "";
        if (h != null && h._suppressLogging) {
          if (i.tag === g)
            return;
          console.error(h);
        }
        var A = b ? Ft(b) : null, B = A ? "The above error occurred in the <" + A + "> component:" : "The above error occurred in one of your React components:", V;
        if (i.tag === v)
          V = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var G = Ft(i) || "Anonymous";
          V = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + G + ".");
        }
        var ae = B + `
` + R + `

` + ("" + V);
        console.error(ae);
      } catch (ne) {
        setTimeout(function() {
          throw ne;
        });
      }
    }
    var UB = typeof WeakMap == "function" ? WeakMap : Map;
    function D$(i, o, d) {
      var h = wu(lr, d);
      h.tag = hC, h.payload = {
        element: null
      };
      var b = o.value;
      return h.callback = function() {
        MF(b), h_(i, o);
      }, h;
    }
    function g_(i, o, d) {
      var h = wu(lr, d);
      h.tag = hC;
      var b = i.type.getDerivedStateFromError;
      if (typeof b == "function") {
        var C = o.value;
        h.payload = function() {
          return b(C);
        }, h.callback = function() {
          KM(i), h_(i, o);
        };
      }
      var R = i.stateNode;
      return R !== null && typeof R.componentDidCatch == "function" && (h.callback = function() {
        KM(i), h_(i, o), typeof b != "function" && RF(this);
        var B = o.value, V = o.stack;
        this.componentDidCatch(B, {
          componentStack: V !== null ? V : ""
        }), typeof b != "function" && (zo(i.lanes, jt) || c("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", Ft(i) || "Unknown"));
      }), h;
    }
    function N$(i, o, d) {
      var h = i.pingCache, b;
      if (h === null ? (h = i.pingCache = new UB(), b = /* @__PURE__ */ new Set(), h.set(o, b)) : (b = h.get(o), b === void 0 && (b = /* @__PURE__ */ new Set(), h.set(o, b))), !b.has(d)) {
        b.add(d);
        var C = AF.bind(null, i, o, d);
        Di && Sy(i, d), o.then(C, C);
      }
    }
    function BB(i, o, d, h) {
      var b = i.updateQueue;
      if (b === null) {
        var C = /* @__PURE__ */ new Set();
        C.add(d), i.updateQueue = C;
      } else
        b.add(d);
    }
    function FB(i, o) {
      var d = i.tag;
      if ((i.mode & fn) === Dt && (d === p || d === j || d === K)) {
        var h = i.alternate;
        h ? (i.updateQueue = h.updateQueue, i.memoizedState = h.memoizedState, i.lanes = h.lanes) : (i.updateQueue = null, i.memoizedState = null);
      }
    }
    function L$(i) {
      var o = i;
      do {
        if (o.tag === z && TB(o))
          return o;
        o = o.return;
      } while (o !== null);
      return null;
    }
    function j$(i, o, d, h, b) {
      if ((i.mode & fn) === Dt) {
        if (i === o)
          i.flags |= Ci;
        else {
          if (i.flags |= Ht, d.flags |= $f, d.flags &= ~(nh | Jo), d.tag === g) {
            var C = d.alternate;
            if (C === null)
              d.tag = se;
            else {
              var R = wu(lr, jt);
              R.tag = CS, Id(d, R, jt);
            }
          }
          d.lanes = an(d.lanes, jt);
        }
        return i;
      }
      return i.flags |= Ci, i.lanes = b, i;
    }
    function HB(i, o, d, h, b) {
      if (d.flags |= Jo, Di && Sy(i, b), h !== null && typeof h == "object" && typeof h.then == "function") {
        var C = h;
        FB(d), go() && d.mode & fn && PR();
        var R = L$(o);
        if (R !== null) {
          R.flags &= ~Hr, j$(R, o, d, i, b), R.mode & fn && N$(i, C, b), BB(R, i, C);
          return;
        } else {
          if (!sd(b)) {
            N$(i, C, b), G_();
            return;
          }
          var A = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          h = A;
        }
      } else if (go() && d.mode & fn) {
        PR();
        var B = L$(o);
        if (B !== null) {
          (B.flags & Ci) === Mt && (B.flags |= Hr), j$(B, o, d, i, b), sC(cp(h, d));
          return;
        }
      }
      h = cp(h, d), xF(h);
      var V = o;
      do {
        switch (V.tag) {
          case v: {
            var G = h;
            V.flags |= Ci;
            var ae = li(b);
            V.lanes = an(V.lanes, ae);
            var ne = D$(V, G, ae);
            vC(V, ne);
            return;
          }
          case g:
            var Ce = h, _e = V.type, Ae = V.stateNode;
            if ((V.flags & Ht) === Mt && (typeof _e.getDerivedStateFromError == "function" || Ae !== null && typeof Ae.componentDidCatch == "function" && !LM(Ae))) {
              V.flags |= Ci;
              var ut = li(b);
              V.lanes = an(V.lanes, ut);
              var Ot = g_(V, Ce, ut);
              vC(V, Ot);
              return;
            }
            break;
        }
        V = V.return;
      } while (V !== null);
    }
    function VB() {
      return null;
    }
    var oy = n.ReactCurrentOwner, El = !1, m_, ay, v_, y_, b_, up, S_, tw;
    m_ = {}, ay = {}, v_ = {}, y_ = {}, b_ = {}, up = !1, S_ = {}, tw = {};
    function oa(i, o, d, h) {
      i === null ? o.child = n$(o, null, d, h) : o.child = ug(o, i.child, d, h);
    }
    function YB(i, o, d, h) {
      o.child = ug(o, i.child, null, h), o.child = ug(o, null, d, h);
    }
    function z$(i, o, d, h, b) {
      if (o.type !== o.elementType) {
        var C = d.propTypes;
        C && vl(
          C,
          h,
          // Resolved props
          "prop",
          rn(d)
        );
      }
      var R = d.render, A = o.ref, B, V;
      cg(o, b), tc(o);
      {
        if (oy.current = o, Gi(!0), B = mg(i, o, R, h, A, b), V = vg(), o.mode & Or) {
          si(!0);
          try {
            B = mg(i, o, R, h, A, b), V = vg();
          } finally {
            si(!1);
          }
        }
        Gi(!1);
      }
      return qc(), i !== null && !El ? (s$(i, o, b), xu(i, o, b)) : (go() && V && tC(o), o.flags |= Gl, oa(i, o, B, b), o.child);
    }
    function U$(i, o, d, h, b) {
      if (i === null) {
        var C = d.type;
        if (qF(C) && d.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        d.defaultProps === void 0) {
          var R = C;
          return R = _g(C), o.tag = K, o.type = R, E_(o, C), B$(i, o, R, h, b);
        }
        {
          var A = C.propTypes;
          A && vl(
            A,
            h,
            // Resolved props
            "prop",
            rn(C)
          );
        }
        var B = oT(d.type, null, h, o, o.mode, b);
        return B.ref = o.ref, B.return = o, o.child = B, B;
      }
      {
        var V = d.type, G = V.propTypes;
        G && vl(
          G,
          h,
          // Resolved props
          "prop",
          rn(V)
        );
      }
      var ae = i.child, ne = I_(i, b);
      if (!ne) {
        var Ce = ae.memoizedProps, _e = d.compare;
        if (_e = _e !== null ? _e : $t, _e(Ce, h) && i.ref === o.ref)
          return xu(i, o, b);
      }
      o.flags |= Gl;
      var Ae = gp(ae, h);
      return Ae.ref = o.ref, Ae.return = o, o.child = Ae, Ae;
    }
    function B$(i, o, d, h, b) {
      if (o.type !== o.elementType) {
        var C = o.elementType;
        if (C.$$typeof === Rt) {
          var R = C, A = R._payload, B = R._init;
          try {
            C = B(A);
          } catch {
            C = null;
          }
          var V = C && C.propTypes;
          V && vl(
            V,
            h,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            rn(C)
          );
        }
      }
      if (i !== null) {
        var G = i.memoizedProps;
        if ($t(G, h) && i.ref === o.ref && // Prevent bailout if the implementation changed due to hot reload.
        o.type === i.type)
          if (El = !1, o.pendingProps = h = G, I_(i, b))
            (i.flags & $f) !== Mt && (El = !0);
          else
            return o.lanes = i.lanes, xu(i, o, b);
      }
      return w_(i, o, d, h, b);
    }
    function F$(i, o, d) {
      var h = o.pendingProps, b = h.children, C = i !== null ? i.memoizedState : null;
      if (h.mode === "hidden" || W)
        if ((o.mode & fn) === Dt) {
          var R = {
            baseLanes: Ne,
            cachePool: null,
            transitions: null
          };
          o.memoizedState = R, hw(o, d);
        } else if (zo(d, jo)) {
          var ae = {
            baseLanes: Ne,
            cachePool: null,
            transitions: null
          };
          o.memoizedState = ae;
          var ne = C !== null ? C.baseLanes : d;
          hw(o, ne);
        } else {
          var A = null, B;
          if (C !== null) {
            var V = C.baseLanes;
            B = an(V, d);
          } else
            B = d;
          o.lanes = o.childLanes = jo;
          var G = {
            baseLanes: B,
            cachePool: A,
            transitions: null
          };
          return o.memoizedState = G, o.updateQueue = null, hw(o, B), null;
        }
      else {
        var Ce;
        C !== null ? (Ce = an(C.baseLanes, d), o.memoizedState = null) : Ce = d, hw(o, Ce);
      }
      return oa(i, o, b, d), o.child;
    }
    function KB(i, o, d) {
      var h = o.pendingProps;
      return oa(i, o, h, d), o.child;
    }
    function WB(i, o, d) {
      var h = o.pendingProps.children;
      return oa(i, o, h, d), o.child;
    }
    function GB(i, o, d) {
      {
        o.flags |= on;
        {
          var h = o.stateNode;
          h.effectDuration = 0, h.passiveEffectDuration = 0;
        }
      }
      var b = o.pendingProps, C = b.children;
      return oa(i, o, C, d), o.child;
    }
    function H$(i, o) {
      var d = o.ref;
      (i === null && d !== null || i !== null && i.ref !== d) && (o.flags |= Mo, o.flags |= Fm);
    }
    function w_(i, o, d, h, b) {
      if (o.type !== o.elementType) {
        var C = d.propTypes;
        C && vl(
          C,
          h,
          // Resolved props
          "prop",
          rn(d)
        );
      }
      var R;
      {
        var A = rg(o, d, !0);
        R = ig(o, A);
      }
      var B, V;
      cg(o, b), tc(o);
      {
        if (oy.current = o, Gi(!0), B = mg(i, o, d, h, R, b), V = vg(), o.mode & Or) {
          si(!0);
          try {
            B = mg(i, o, d, h, R, b), V = vg();
          } finally {
            si(!1);
          }
        }
        Gi(!1);
      }
      return qc(), i !== null && !El ? (s$(i, o, b), xu(i, o, b)) : (go() && V && tC(o), o.flags |= Gl, oa(i, o, B, b), o.child);
    }
    function V$(i, o, d, h, b) {
      {
        switch (d7(o)) {
          case !1: {
            var C = o.stateNode, R = o.type, A = new R(o.memoizedProps, C.context), B = A.state;
            C.updater.enqueueSetState(C, B, null);
            break;
          }
          case !0: {
            o.flags |= Ht, o.flags |= Ci;
            var V = new Error("Simulated error coming from DevTools"), G = li(b);
            o.lanes = an(o.lanes, G);
            var ae = g_(o, cp(V, o), G);
            vC(o, ae);
            break;
          }
        }
        if (o.type !== o.elementType) {
          var ne = d.propTypes;
          ne && vl(
            ne,
            h,
            // Resolved props
            "prop",
            rn(d)
          );
        }
      }
      var Ce;
      fc(d) ? (Ce = !0, pS(o)) : Ce = !1, cg(o, b);
      var _e = o.stateNode, Ae;
      _e === null ? (rw(i, o), QR(o, d, h), IC(o, d, h, b), Ae = !0) : i === null ? Ae = SB(o, d, h, b) : Ae = wB(i, o, d, h, b);
      var ut = x_(i, o, d, Ae, Ce, b);
      {
        var Ot = o.stateNode;
        Ae && Ot.props !== h && (up || c("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Ft(o) || "a component"), up = !0);
      }
      return ut;
    }
    function x_(i, o, d, h, b, C) {
      H$(i, o);
      var R = (o.flags & Ht) !== Mt;
      if (!h && !R)
        return b && CR(o, d, !1), xu(i, o, C);
      var A = o.stateNode;
      oy.current = o;
      var B;
      if (R && typeof d.getDerivedStateFromError != "function")
        B = null, O$();
      else {
        tc(o);
        {
          if (Gi(!0), B = A.render(), o.mode & Or) {
            si(!0);
            try {
              A.render();
            } finally {
              si(!1);
            }
          }
          Gi(!1);
        }
        qc();
      }
      return o.flags |= Gl, i !== null && R ? YB(i, o, B, C) : oa(i, o, B, C), o.memoizedState = A.state, b && CR(o, d, !0), o.child;
    }
    function Y$(i) {
      var o = i.stateNode;
      o.pendingContext ? xR(i, o.pendingContext, o.pendingContext !== o.context) : o.context && xR(i, o.context, !1), DC(i, o.containerInfo);
    }
    function XB(i, o, d) {
      if (Y$(o), i === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var h = o.pendingProps, b = o.memoizedState, C = b.element;
      HR(i, o), PS(o, h, null, d);
      var R = o.memoizedState;
      o.stateNode;
      var A = R.element;
      if (b.isDehydrated) {
        var B = {
          element: A,
          isDehydrated: !1,
          cache: R.cache,
          pendingSuspenseBoundaries: R.pendingSuspenseBoundaries,
          transitions: R.transitions
        }, V = o.updateQueue;
        if (V.baseState = B, o.memoizedState = B, o.flags & Hr) {
          var G = cp(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), o);
          return K$(i, o, A, d, G);
        } else if (A !== C) {
          var ae = cp(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), o);
          return K$(i, o, A, d, ae);
        } else {
          JU(o);
          var ne = n$(o, null, A, d);
          o.child = ne;
          for (var Ce = ne; Ce; )
            Ce.flags = Ce.flags & ~mr | Pa, Ce = Ce.sibling;
        }
      } else {
        if (sg(), A === C)
          return xu(i, o, d);
        oa(i, o, A, d);
      }
      return o.child;
    }
    function K$(i, o, d, h, b) {
      return sg(), sC(b), o.flags |= Hr, oa(i, o, d, h), o.child;
    }
    function qB(i, o, d) {
      i$(o), i === null && aC(o);
      var h = o.type, b = o.pendingProps, C = i !== null ? i.memoizedProps : null, R = b.children, A = BE(h, b);
      return A ? R = null : C !== null && BE(h, C) && (o.flags |= Vn), H$(i, o), oa(i, o, R, d), o.child;
    }
    function QB(i, o) {
      return i === null && aC(o), null;
    }
    function ZB(i, o, d, h) {
      rw(i, o);
      var b = o.pendingProps, C = d, R = C._payload, A = C._init, B = A(R);
      o.type = B;
      var V = o.tag = QF(B), G = Sl(B, b), ae;
      switch (V) {
        case p:
          return E_(o, B), o.type = B = _g(B), ae = w_(null, o, B, G, h), ae;
        case g:
          return o.type = B = J_(B), ae = V$(null, o, B, G, h), ae;
        case j:
          return o.type = B = eT(B), ae = z$(null, o, B, G, h), ae;
        case F: {
          if (o.type !== o.elementType) {
            var ne = B.propTypes;
            ne && vl(
              ne,
              G,
              // Resolved for outer only
              "prop",
              rn(B)
            );
          }
          return ae = U$(
            null,
            o,
            B,
            Sl(B.type, G),
            // The inner type can have defaults too
            h
          ), ae;
        }
      }
      var Ce = "";
      throw B !== null && typeof B == "object" && B.$$typeof === Rt && (Ce = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + B + ". " + ("Lazy element type must resolve to a class or function." + Ce));
    }
    function JB(i, o, d, h, b) {
      rw(i, o), o.tag = g;
      var C;
      return fc(d) ? (C = !0, pS(o)) : C = !1, cg(o, b), QR(o, d, h), IC(o, d, h, b), x_(null, o, d, !0, C, b);
    }
    function e8(i, o, d, h) {
      rw(i, o);
      var b = o.pendingProps, C;
      {
        var R = rg(o, d, !1);
        C = ig(o, R);
      }
      cg(o, h);
      var A, B;
      tc(o);
      {
        if (d.prototype && typeof d.prototype.render == "function") {
          var V = rn(d) || "Unknown";
          m_[V] || (c("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", V, V), m_[V] = !0);
        }
        o.mode & Or && bl.recordLegacyContextWarning(o, null), Gi(!0), oy.current = o, A = mg(null, o, d, b, C, h), B = vg(), Gi(!1);
      }
      if (qc(), o.flags |= Gl, typeof A == "object" && A !== null && typeof A.render == "function" && A.$$typeof === void 0) {
        var G = rn(d) || "Unknown";
        ay[G] || (c("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", G, G, G), ay[G] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof A == "object" && A !== null && typeof A.render == "function" && A.$$typeof === void 0
      ) {
        {
          var ae = rn(d) || "Unknown";
          ay[ae] || (c("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ae, ae, ae), ay[ae] = !0);
        }
        o.tag = g, o.memoizedState = null, o.updateQueue = null;
        var ne = !1;
        return fc(d) ? (ne = !0, pS(o)) : ne = !1, o.memoizedState = A.state !== null && A.state !== void 0 ? A.state : null, mC(o), qR(o, A), IC(o, d, b, h), x_(null, o, d, !0, ne, h);
      } else {
        if (o.tag = p, o.mode & Or) {
          si(!0);
          try {
            A = mg(null, o, d, b, C, h), B = vg();
          } finally {
            si(!1);
          }
        }
        return go() && B && tC(o), oa(null, o, A, h), E_(o, d), o.child;
      }
    }
    function E_(i, o) {
      {
        if (o && o.childContextTypes && c("%s(...): childContextTypes cannot be defined on a function component.", o.displayName || o.name || "Component"), i.ref !== null) {
          var d = "", h = xi();
          h && (d += `

Check the render method of \`` + h + "`.");
          var b = h || "", C = i._debugSource;
          C && (b = C.fileName + ":" + C.lineNumber), b_[b] || (b_[b] = !0, c("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", d));
        }
        if (typeof o.getDerivedStateFromProps == "function") {
          var R = rn(o) || "Unknown";
          y_[R] || (c("%s: Function components do not support getDerivedStateFromProps.", R), y_[R] = !0);
        }
        if (typeof o.contextType == "object" && o.contextType !== null) {
          var A = rn(o) || "Unknown";
          v_[A] || (c("%s: Function components do not support contextType.", A), v_[A] = !0);
        }
      }
    }
    var C_ = {
      dehydrated: null,
      treeContext: null,
      retryLane: En
    };
    function __(i) {
      return {
        baseLanes: i,
        cachePool: VB(),
        transitions: null
      };
    }
    function t8(i, o) {
      var d = null;
      return {
        baseLanes: an(i.baseLanes, o),
        cachePool: d,
        transitions: i.transitions
      };
    }
    function n8(i, o, d, h) {
      if (o !== null) {
        var b = o.memoizedState;
        if (b === null)
          return !1;
      }
      return jC(i, Qv);
    }
    function r8(i, o) {
      return ld(i.childLanes, o);
    }
    function W$(i, o, d) {
      var h = o.pendingProps;
      f7(o) && (o.flags |= Ht);
      var b = wl.current, C = !1, R = (o.flags & Ht) !== Mt;
      if (R || n8(b, i) ? (C = !0, o.flags &= ~Ht) : (i === null || i.memoizedState !== null) && (b = _B(b, a$)), b = fg(b), $d(o, b), i === null) {
        aC(o);
        var A = o.memoizedState;
        if (A !== null) {
          var B = A.dehydrated;
          if (B !== null)
            return l8(o, B);
        }
        var V = h.children, G = h.fallback;
        if (C) {
          var ae = i8(o, V, G, d), ne = o.child;
          return ne.memoizedState = __(d), o.memoizedState = C_, ae;
        } else
          return T_(o, V);
      } else {
        var Ce = i.memoizedState;
        if (Ce !== null) {
          var _e = Ce.dehydrated;
          if (_e !== null)
            return c8(i, o, R, h, _e, Ce, d);
        }
        if (C) {
          var Ae = h.fallback, ut = h.children, Ot = a8(i, o, ut, Ae, d), Pt = o.child, _n = i.child.memoizedState;
          return Pt.memoizedState = _n === null ? __(d) : t8(_n, d), Pt.childLanes = r8(i, d), o.memoizedState = C_, Ot;
        } else {
          var vn = h.children, be = o8(i, o, vn, d);
          return o.memoizedState = null, be;
        }
      }
    }
    function T_(i, o, d) {
      var h = i.mode, b = {
        mode: "visible",
        children: o
      }, C = k_(b, h);
      return C.return = i, i.child = C, C;
    }
    function i8(i, o, d, h) {
      var b = i.mode, C = i.child, R = {
        mode: "hidden",
        children: o
      }, A, B;
      return (b & fn) === Dt && C !== null ? (A = C, A.childLanes = Ne, A.pendingProps = R, i.mode & Lt && (A.actualDuration = 0, A.actualStartTime = -1, A.selfBaseDuration = 0, A.treeBaseDuration = 0), B = zd(d, b, h, null)) : (A = k_(R, b), B = zd(d, b, h, null)), A.return = i, B.return = i, A.sibling = B, i.child = A, B;
    }
    function k_(i, o, d) {
      return GM(i, o, Ne, null);
    }
    function G$(i, o) {
      return gp(i, o);
    }
    function o8(i, o, d, h) {
      var b = i.child, C = b.sibling, R = G$(b, {
        mode: "visible",
        children: d
      });
      if ((o.mode & fn) === Dt && (R.lanes = h), R.return = o, R.sibling = null, C !== null) {
        var A = o.deletions;
        A === null ? (o.deletions = [C], o.flags |= Un) : A.push(C);
      }
      return o.child = R, R;
    }
    function a8(i, o, d, h, b) {
      var C = o.mode, R = i.child, A = R.sibling, B = {
        mode: "hidden",
        children: d
      }, V;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (C & fn) === Dt && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        o.child !== R
      ) {
        var G = o.child;
        V = G, V.childLanes = Ne, V.pendingProps = B, o.mode & Lt && (V.actualDuration = 0, V.actualStartTime = -1, V.selfBaseDuration = R.selfBaseDuration, V.treeBaseDuration = R.treeBaseDuration), o.deletions = null;
      } else
        V = G$(R, B), V.subtreeFlags = R.subtreeFlags & Oi;
      var ae;
      return A !== null ? ae = gp(A, h) : (ae = zd(h, C, b, null), ae.flags |= mr), ae.return = o, V.return = o, V.sibling = ae, o.child = V, ae;
    }
    function nw(i, o, d, h) {
      h !== null && sC(h), ug(o, i.child, null, d);
      var b = o.pendingProps, C = b.children, R = T_(o, C);
      return R.flags |= mr, o.memoizedState = null, R;
    }
    function s8(i, o, d, h, b) {
      var C = o.mode, R = {
        mode: "visible",
        children: d
      }, A = k_(R, C), B = zd(h, C, b, null);
      return B.flags |= mr, A.return = o, B.return = o, A.sibling = B, o.child = A, (o.mode & fn) !== Dt && ug(o, i.child, null, b), B;
    }
    function l8(i, o, d) {
      return (i.mode & fn) === Dt ? (c("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), i.lanes = jt) : YE(o) ? i.lanes = Jc : i.lanes = jo, null;
    }
    function c8(i, o, d, h, b, C, R) {
      if (d)
        if (o.flags & Hr) {
          o.flags &= ~Hr;
          var be = p_(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return nw(i, o, R, be);
        } else {
          if (o.memoizedState !== null)
            return o.child = i.child, o.flags |= Ht, null;
          var Oe = h.children, Se = h.fallback, We = s8(i, o, Oe, Se, R), dt = o.child;
          return dt.memoizedState = __(R), o.memoizedState = C_, We;
        }
      else {
        if (QU(), (o.mode & fn) === Dt)
          return nw(
            i,
            o,
            R,
            // TODO: When we delete legacy mode, we should make this error argument
            // required — every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (YE(b)) {
          var A, B, V;
          {
            var G = hU(b);
            A = G.digest, B = G.message, V = G.stack;
          }
          var ae;
          B ? ae = new Error(B) : ae = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var ne = p_(ae, A, V);
          return nw(i, o, R, ne);
        }
        var Ce = zo(R, i.childLanes);
        if (El || Ce) {
          var _e = pw();
          if (_e !== null) {
            var Ae = fE(_e, R);
            if (Ae !== En && Ae !== C.retryLane) {
              C.retryLane = Ae;
              var ut = lr;
              ja(i, Ae), Vi(_e, i, Ae, ut);
            }
          }
          G_();
          var Ot = p_(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return nw(i, o, R, Ot);
        } else if (mR(b)) {
          o.flags |= Ht, o.child = i.child;
          var Pt = OF.bind(null, i);
          return gU(b, Pt), null;
        } else {
          eB(o, b, C.treeContext);
          var _n = h.children, vn = T_(o, _n);
          return vn.flags |= Pa, vn;
        }
      }
    }
    function X$(i, o, d) {
      i.lanes = an(i.lanes, o);
      var h = i.alternate;
      h !== null && (h.lanes = an(h.lanes, o)), fC(i.return, o, d);
    }
    function u8(i, o, d) {
      for (var h = o; h !== null; ) {
        if (h.tag === z) {
          var b = h.memoizedState;
          b !== null && X$(h, d, i);
        } else if (h.tag === pe)
          X$(h, d, i);
        else if (h.child !== null) {
          h.child.return = h, h = h.child;
          continue;
        }
        if (h === i)
          return;
        for (; h.sibling === null; ) {
          if (h.return === null || h.return === i)
            return;
          h = h.return;
        }
        h.sibling.return = h.return, h = h.sibling;
      }
    }
    function d8(i) {
      for (var o = i, d = null; o !== null; ) {
        var h = o.alternate;
        h !== null && DS(h) === null && (d = o), o = o.sibling;
      }
      return d;
    }
    function f8(i) {
      if (i !== void 0 && i !== "forwards" && i !== "backwards" && i !== "together" && !S_[i])
        if (S_[i] = !0, typeof i == "string")
          switch (i.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              c('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', i, i.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              c('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', i, i.toLowerCase());
              break;
            }
            default:
              c('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', i);
              break;
          }
        else
          c('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', i);
    }
    function p8(i, o) {
      i !== void 0 && !tw[i] && (i !== "collapsed" && i !== "hidden" ? (tw[i] = !0, c('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', i)) : o !== "forwards" && o !== "backwards" && (tw[i] = !0, c('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', i)));
    }
    function q$(i, o) {
      {
        var d = Sn(i), h = !d && typeof Xo(i) == "function";
        if (d || h) {
          var b = d ? "array" : "iterable";
          return c("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", b, o, b), !1;
        }
      }
      return !0;
    }
    function h8(i, o) {
      if ((o === "forwards" || o === "backwards") && i !== void 0 && i !== null && i !== !1)
        if (Sn(i)) {
          for (var d = 0; d < i.length; d++)
            if (!q$(i[d], d))
              return;
        } else {
          var h = Xo(i);
          if (typeof h == "function") {
            var b = h.call(i);
            if (b)
              for (var C = b.next(), R = 0; !C.done; C = b.next()) {
                if (!q$(C.value, R))
                  return;
                R++;
              }
          } else
            c('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', o);
        }
    }
    function P_(i, o, d, h, b) {
      var C = i.memoizedState;
      C === null ? i.memoizedState = {
        isBackwards: o,
        rendering: null,
        renderingStartTime: 0,
        last: h,
        tail: d,
        tailMode: b
      } : (C.isBackwards = o, C.rendering = null, C.renderingStartTime = 0, C.last = h, C.tail = d, C.tailMode = b);
    }
    function Q$(i, o, d) {
      var h = o.pendingProps, b = h.revealOrder, C = h.tail, R = h.children;
      f8(b), p8(C, b), h8(R, b), oa(i, o, R, d);
      var A = wl.current, B = jC(A, Qv);
      if (B)
        A = zC(A, Qv), o.flags |= Ht;
      else {
        var V = i !== null && (i.flags & Ht) !== Mt;
        V && u8(o, o.child, d), A = fg(A);
      }
      if ($d(o, A), (o.mode & fn) === Dt)
        o.memoizedState = null;
      else
        switch (b) {
          case "forwards": {
            var G = d8(o.child), ae;
            G === null ? (ae = o.child, o.child = null) : (ae = G.sibling, G.sibling = null), P_(
              o,
              !1,
              // isBackwards
              ae,
              G,
              C
            );
            break;
          }
          case "backwards": {
            var ne = null, Ce = o.child;
            for (o.child = null; Ce !== null; ) {
              var _e = Ce.alternate;
              if (_e !== null && DS(_e) === null) {
                o.child = Ce;
                break;
              }
              var Ae = Ce.sibling;
              Ce.sibling = ne, ne = Ce, Ce = Ae;
            }
            P_(
              o,
              !0,
              // isBackwards
              ne,
              null,
              // last
              C
            );
            break;
          }
          case "together": {
            P_(
              o,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            o.memoizedState = null;
        }
      return o.child;
    }
    function g8(i, o, d) {
      DC(o, o.stateNode.containerInfo);
      var h = o.pendingProps;
      return i === null ? o.child = ug(o, null, h, d) : oa(i, o, h, d), o.child;
    }
    var Z$ = !1;
    function m8(i, o, d) {
      var h = o.type, b = h._context, C = o.pendingProps, R = o.memoizedProps, A = C.value;
      {
        "value" in C || Z$ || (Z$ = !0, c("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var B = o.type.propTypes;
        B && vl(B, C, "prop", "Context.Provider");
      }
      if (zR(o, b, A), R !== null) {
        var V = R.value;
        if (mt(V, A)) {
          if (R.children === C.children && !dS())
            return xu(i, o, d);
        } else
          uB(o, b, d);
      }
      var G = C.children;
      return oa(i, o, G, d), o.child;
    }
    var J$ = !1;
    function v8(i, o, d) {
      var h = o.type;
      h._context === void 0 ? h !== h.Consumer && (J$ || (J$ = !0, c("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : h = h._context;
      var b = o.pendingProps, C = b.children;
      typeof C != "function" && c("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), cg(o, d);
      var R = Ii(h);
      tc(o);
      var A;
      return oy.current = o, Gi(!0), A = C(R), Gi(!1), qc(), o.flags |= Gl, oa(i, o, A, d), o.child;
    }
    function sy() {
      El = !0;
    }
    function rw(i, o) {
      (o.mode & fn) === Dt && i !== null && (i.alternate = null, o.alternate = null, o.flags |= mr);
    }
    function xu(i, o, d) {
      return i !== null && (o.dependencies = i.dependencies), O$(), by(o.lanes), zo(d, o.childLanes) ? (xB(i, o), o.child) : null;
    }
    function y8(i, o, d) {
      {
        var h = o.return;
        if (h === null)
          throw new Error("Cannot swap the root fiber.");
        if (i.alternate = null, o.alternate = null, d.index = o.index, d.sibling = o.sibling, d.return = o.return, d.ref = o.ref, o === h.child)
          h.child = d;
        else {
          var b = h.child;
          if (b === null)
            throw new Error("Expected parent to have a child.");
          for (; b.sibling !== o; )
            if (b = b.sibling, b === null)
              throw new Error("Expected to find the previous sibling.");
          b.sibling = d;
        }
        var C = h.deletions;
        return C === null ? (h.deletions = [i], h.flags |= Un) : C.push(i), d.flags |= mr, d;
      }
    }
    function I_(i, o) {
      var d = i.lanes;
      return !!zo(d, o);
    }
    function b8(i, o, d) {
      switch (o.tag) {
        case v:
          Y$(o), o.stateNode, sg();
          break;
        case x:
          i$(o);
          break;
        case g: {
          var h = o.type;
          fc(h) && pS(o);
          break;
        }
        case S:
          DC(o, o.stateNode.containerInfo);
          break;
        case N: {
          var b = o.memoizedProps.value, C = o.type._context;
          zR(o, C, b);
          break;
        }
        case L:
          {
            var R = zo(d, o.childLanes);
            R && (o.flags |= on);
            {
              var A = o.stateNode;
              A.effectDuration = 0, A.passiveEffectDuration = 0;
            }
          }
          break;
        case z: {
          var B = o.memoizedState;
          if (B !== null) {
            if (B.dehydrated !== null)
              return $d(o, fg(wl.current)), o.flags |= Ht, null;
            var V = o.child, G = V.childLanes;
            if (zo(d, G))
              return W$(i, o, d);
            $d(o, fg(wl.current));
            var ae = xu(i, o, d);
            return ae !== null ? ae.sibling : null;
          } else
            $d(o, fg(wl.current));
          break;
        }
        case pe: {
          var ne = (i.flags & Ht) !== Mt, Ce = zo(d, o.childLanes);
          if (ne) {
            if (Ce)
              return Q$(i, o, d);
            o.flags |= Ht;
          }
          var _e = o.memoizedState;
          if (_e !== null && (_e.rendering = null, _e.tail = null, _e.lastEffect = null), $d(o, wl.current), Ce)
            break;
          return null;
        }
        case ve:
        case Y:
          return o.lanes = Ne, F$(i, o, d);
      }
      return xu(i, o, d);
    }
    function eM(i, o, d) {
      if (o._debugNeedsRemount && i !== null)
        return y8(i, o, oT(o.type, o.key, o.pendingProps, o._debugOwner || null, o.mode, o.lanes));
      if (i !== null) {
        var h = i.memoizedProps, b = o.pendingProps;
        if (h !== b || dS() || // Force a re-render if the implementation changed due to hot reload:
        o.type !== i.type)
          El = !0;
        else {
          var C = I_(i, d);
          if (!C && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (o.flags & Ht) === Mt)
            return El = !1, b8(i, o, d);
          (i.flags & $f) !== Mt ? El = !0 : El = !1;
        }
      } else if (El = !1, go() && YU(o)) {
        var R = o.index, A = KU();
        kR(o, A, R);
      }
      switch (o.lanes = Ne, o.tag) {
        case y:
          return e8(i, o, o.type, d);
        case X: {
          var B = o.elementType;
          return ZB(i, o, B, d);
        }
        case p: {
          var V = o.type, G = o.pendingProps, ae = o.elementType === V ? G : Sl(V, G);
          return w_(i, o, V, ae, d);
        }
        case g: {
          var ne = o.type, Ce = o.pendingProps, _e = o.elementType === ne ? Ce : Sl(ne, Ce);
          return V$(i, o, ne, _e, d);
        }
        case v:
          return XB(i, o, d);
        case x:
          return qB(i, o, d);
        case _:
          return QB(i, o);
        case z:
          return W$(i, o, d);
        case S:
          return g8(i, o, d);
        case j: {
          var Ae = o.type, ut = o.pendingProps, Ot = o.elementType === Ae ? ut : Sl(Ae, ut);
          return z$(i, o, Ae, Ot, d);
        }
        case T:
          return KB(i, o, d);
        case I:
          return WB(i, o, d);
        case L:
          return GB(i, o, d);
        case N:
          return m8(i, o, d);
        case D:
          return v8(i, o, d);
        case F: {
          var Pt = o.type, _n = o.pendingProps, vn = Sl(Pt, _n);
          if (o.type !== o.elementType) {
            var be = Pt.propTypes;
            be && vl(
              be,
              vn,
              // Resolved for outer only
              "prop",
              rn(Pt)
            );
          }
          return vn = Sl(Pt.type, vn), U$(i, o, Pt, vn, d);
        }
        case K:
          return B$(i, o, o.type, o.pendingProps, d);
        case se: {
          var Oe = o.type, Se = o.pendingProps, We = o.elementType === Oe ? Se : Sl(Oe, Se);
          return JB(i, o, Oe, We, d);
        }
        case pe:
          return Q$(i, o, d);
        case Pe:
          break;
        case ve:
          return F$(i, o, d);
      }
      throw new Error("Unknown unit of work tag (" + o.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function yg(i) {
      i.flags |= on;
    }
    function tM(i) {
      i.flags |= Mo, i.flags |= Fm;
    }
    var nM, R_, rM, iM;
    nM = function(i, o, d, h) {
      for (var b = o.child; b !== null; ) {
        if (b.tag === x || b.tag === _)
          F6(i, b.stateNode);
        else if (b.tag !== S) {
          if (b.child !== null) {
            b.child.return = b, b = b.child;
            continue;
          }
        }
        if (b === o)
          return;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === o)
            return;
          b = b.return;
        }
        b.sibling.return = b.return, b = b.sibling;
      }
    }, R_ = function(i, o) {
    }, rM = function(i, o, d, h, b) {
      var C = i.memoizedProps;
      if (C !== h) {
        var R = o.stateNode, A = NC(), B = V6(R, d, C, h, b, A);
        o.updateQueue = B, B && yg(o);
      }
    }, iM = function(i, o, d, h) {
      d !== h && yg(o);
    };
    function ly(i, o) {
      if (!go())
        switch (i.tailMode) {
          case "hidden": {
            for (var d = i.tail, h = null; d !== null; )
              d.alternate !== null && (h = d), d = d.sibling;
            h === null ? i.tail = null : h.sibling = null;
            break;
          }
          case "collapsed": {
            for (var b = i.tail, C = null; b !== null; )
              b.alternate !== null && (C = b), b = b.sibling;
            C === null ? !o && i.tail !== null ? i.tail.sibling = null : i.tail = null : C.sibling = null;
            break;
          }
        }
    }
    function vo(i) {
      var o = i.alternate !== null && i.alternate.child === i.child, d = Ne, h = Mt;
      if (o) {
        if ((i.mode & Lt) !== Dt) {
          for (var B = i.selfBaseDuration, V = i.child; V !== null; )
            d = an(d, an(V.lanes, V.childLanes)), h |= V.subtreeFlags & Oi, h |= V.flags & Oi, B += V.treeBaseDuration, V = V.sibling;
          i.treeBaseDuration = B;
        } else
          for (var G = i.child; G !== null; )
            d = an(d, an(G.lanes, G.childLanes)), h |= G.subtreeFlags & Oi, h |= G.flags & Oi, G.return = i, G = G.sibling;
        i.subtreeFlags |= h;
      } else {
        if ((i.mode & Lt) !== Dt) {
          for (var b = i.actualDuration, C = i.selfBaseDuration, R = i.child; R !== null; )
            d = an(d, an(R.lanes, R.childLanes)), h |= R.subtreeFlags, h |= R.flags, b += R.actualDuration, C += R.treeBaseDuration, R = R.sibling;
          i.actualDuration = b, i.treeBaseDuration = C;
        } else
          for (var A = i.child; A !== null; )
            d = an(d, an(A.lanes, A.childLanes)), h |= A.subtreeFlags, h |= A.flags, A.return = i, A = A.sibling;
        i.subtreeFlags |= h;
      }
      return i.childLanes = d, o;
    }
    function S8(i, o, d) {
      if (oB() && (o.mode & fn) !== Dt && (o.flags & Ht) === Mt)
        return OR(o), sg(), o.flags |= Hr | Jo | Ci, !1;
      var h = yS(o);
      if (d !== null && d.dehydrated !== null)
        if (i === null) {
          if (!h)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (rB(o), vo(o), (o.mode & Lt) !== Dt) {
            var b = d !== null;
            if (b) {
              var C = o.child;
              C !== null && (o.treeBaseDuration -= C.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (sg(), (o.flags & Ht) === Mt && (o.memoizedState = null), o.flags |= on, vo(o), (o.mode & Lt) !== Dt) {
            var R = d !== null;
            if (R) {
              var A = o.child;
              A !== null && (o.treeBaseDuration -= A.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return DR(), !0;
    }
    function oM(i, o, d) {
      var h = o.pendingProps;
      switch (nC(o), o.tag) {
        case y:
        case X:
        case K:
        case p:
        case j:
        case T:
        case I:
        case L:
        case D:
        case F:
          return vo(o), null;
        case g: {
          var b = o.type;
          return fc(b) && fS(o), vo(o), null;
        }
        case v: {
          var C = o.stateNode;
          if (dg(o), ZE(o), BC(), C.pendingContext && (C.context = C.pendingContext, C.pendingContext = null), i === null || i.child === null) {
            var R = yS(o);
            if (R)
              yg(o);
            else if (i !== null) {
              var A = i.memoizedState;
              // Check if this is a client root
              (!A.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (o.flags & Hr) !== Mt) && (o.flags |= ka, DR());
            }
          }
          return R_(i, o), vo(o), null;
        }
        case x: {
          LC(o);
          var B = r$(), V = o.type;
          if (i !== null && o.stateNode != null)
            rM(i, o, V, h, B), i.ref !== o.ref && tM(o);
          else {
            if (!h) {
              if (o.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return vo(o), null;
            }
            var G = NC(), ae = yS(o);
            if (ae)
              tB(o, B, G) && yg(o);
            else {
              var ne = B6(V, h, B, G, o);
              nM(ne, o, !1, !1), o.stateNode = ne, H6(ne, V, h, B) && yg(o);
            }
            o.ref !== null && tM(o);
          }
          return vo(o), null;
        }
        case _: {
          var Ce = h;
          if (i && o.stateNode != null) {
            var _e = i.memoizedProps;
            iM(i, o, _e, Ce);
          } else {
            if (typeof Ce != "string" && o.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Ae = r$(), ut = NC(), Ot = yS(o);
            Ot ? nB(o) && yg(o) : o.stateNode = Y6(Ce, Ae, ut, o);
          }
          return vo(o), null;
        }
        case z: {
          pg(o);
          var Pt = o.memoizedState;
          if (i === null || i.memoizedState !== null && i.memoizedState.dehydrated !== null) {
            var _n = S8(i, o, Pt);
            if (!_n)
              return o.flags & Ci ? o : null;
          }
          if ((o.flags & Ht) !== Mt)
            return o.lanes = d, (o.mode & Lt) !== Dt && f_(o), o;
          var vn = Pt !== null, be = i !== null && i.memoizedState !== null;
          if (vn !== be && vn) {
            var Oe = o.child;
            if (Oe.flags |= Xl, (o.mode & fn) !== Dt) {
              var Se = i === null && (o.memoizedProps.unstable_avoidThisFallback !== !0 || !fe);
              Se || jC(wl.current, a$) ? wF() : G_();
            }
          }
          var We = o.updateQueue;
          if (We !== null && (o.flags |= on), vo(o), (o.mode & Lt) !== Dt && vn) {
            var dt = o.child;
            dt !== null && (o.treeBaseDuration -= dt.treeBaseDuration);
          }
          return null;
        }
        case S:
          return dg(o), R_(i, o), i === null && jU(o.stateNode.containerInfo), vo(o), null;
        case N:
          var at = o.type._context;
          return dC(at, o), vo(o), null;
        case se: {
          var Bt = o.type;
          return fc(Bt) && fS(o), vo(o), null;
        }
        case pe: {
          pg(o);
          var Zt = o.memoizedState;
          if (Zt === null)
            return vo(o), null;
          var er = (o.flags & Ht) !== Mt, jn = Zt.rendering;
          if (jn === null)
            if (er)
              ly(Zt, !1);
            else {
              var pi = EF() && (i === null || (i.flags & Ht) === Mt);
              if (!pi)
                for (var zn = o.child; zn !== null; ) {
                  var ai = DS(zn);
                  if (ai !== null) {
                    er = !0, o.flags |= Ht, ly(Zt, !1);
                    var Ho = ai.updateQueue;
                    return Ho !== null && (o.updateQueue = Ho, o.flags |= on), o.subtreeFlags = Mt, EB(o, d), $d(o, zC(wl.current, Qv)), o.child;
                  }
                  zn = zn.sibling;
                }
              Zt.tail !== null && Ar() > TM() && (o.flags |= Ht, er = !0, ly(Zt, !1), o.lanes = tv);
            }
          else {
            if (!er) {
              var xo = DS(jn);
              if (xo !== null) {
                o.flags |= Ht, er = !0;
                var ls = xo.updateQueue;
                if (ls !== null && (o.updateQueue = ls, o.flags |= on), ly(Zt, !0), Zt.tail === null && Zt.tailMode === "hidden" && !jn.alternate && !go())
                  return vo(o), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                Ar() * 2 - Zt.renderingStartTime > TM() && d !== jo && (o.flags |= Ht, er = !0, ly(Zt, !1), o.lanes = tv);
            }
            if (Zt.isBackwards)
              jn.sibling = o.child, o.child = jn;
            else {
              var la = Zt.last;
              la !== null ? la.sibling = jn : o.child = jn, Zt.last = jn;
            }
          }
          if (Zt.tail !== null) {
            var ca = Zt.tail;
            Zt.rendering = ca, Zt.tail = ca.sibling, Zt.renderingStartTime = Ar(), ca.sibling = null;
            var Vo = wl.current;
            return er ? Vo = zC(Vo, Qv) : Vo = fg(Vo), $d(o, Vo), ca;
          }
          return vo(o), null;
        }
        case Pe:
          break;
        case ve:
        case Y: {
          W_(o);
          var ku = o.memoizedState, Tg = ku !== null;
          if (i !== null) {
            var Cy = i.memoizedState, Sc = Cy !== null;
            Sc !== Tg && // LegacyHidden doesn't do any hiding — it only pre-renders.
            !W && (o.flags |= Xl);
          }
          return !Tg || (o.mode & fn) === Dt ? vo(o) : zo(bc, jo) && (vo(o), o.subtreeFlags & (mr | on) && (o.flags |= Xl)), null;
        }
        case le:
          return null;
        case Re:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + o.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function w8(i, o, d) {
      switch (nC(o), o.tag) {
        case g: {
          var h = o.type;
          fc(h) && fS(o);
          var b = o.flags;
          return b & Ci ? (o.flags = b & ~Ci | Ht, (o.mode & Lt) !== Dt && f_(o), o) : null;
        }
        case v: {
          o.stateNode, dg(o), ZE(o), BC();
          var C = o.flags;
          return (C & Ci) !== Mt && (C & Ht) === Mt ? (o.flags = C & ~Ci | Ht, o) : null;
        }
        case x:
          return LC(o), null;
        case z: {
          pg(o);
          var R = o.memoizedState;
          if (R !== null && R.dehydrated !== null) {
            if (o.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            sg();
          }
          var A = o.flags;
          return A & Ci ? (o.flags = A & ~Ci | Ht, (o.mode & Lt) !== Dt && f_(o), o) : null;
        }
        case pe:
          return pg(o), null;
        case S:
          return dg(o), null;
        case N:
          var B = o.type._context;
          return dC(B, o), null;
        case ve:
        case Y:
          return W_(o), null;
        case le:
          return null;
        default:
          return null;
      }
    }
    function aM(i, o, d) {
      switch (nC(o), o.tag) {
        case g: {
          var h = o.type.childContextTypes;
          h != null && fS(o);
          break;
        }
        case v: {
          o.stateNode, dg(o), ZE(o), BC();
          break;
        }
        case x: {
          LC(o);
          break;
        }
        case S:
          dg(o);
          break;
        case z:
          pg(o);
          break;
        case pe:
          pg(o);
          break;
        case N:
          var b = o.type._context;
          dC(b, o);
          break;
        case ve:
        case Y:
          W_(o);
          break;
      }
    }
    var sM = null;
    sM = /* @__PURE__ */ new Set();
    var iw = !1, yo = !1, x8 = typeof WeakSet == "function" ? WeakSet : Set, vt = null, bg = null, Sg = null;
    function E8(i) {
      Gc(null, function() {
        throw i;
      }), Um();
    }
    var C8 = function(i, o) {
      if (o.props = i.memoizedProps, o.state = i.memoizedState, i.mode & Lt)
        try {
          vc(), o.componentWillUnmount();
        } finally {
          mc(i);
        }
      else
        o.componentWillUnmount();
    };
    function lM(i, o) {
      try {
        Od(ji, i);
      } catch (d) {
        Sr(i, o, d);
      }
    }
    function $_(i, o, d) {
      try {
        C8(i, d);
      } catch (h) {
        Sr(i, o, h);
      }
    }
    function _8(i, o, d) {
      try {
        d.componentDidMount();
      } catch (h) {
        Sr(i, o, h);
      }
    }
    function cM(i, o) {
      try {
        dM(i);
      } catch (d) {
        Sr(i, o, d);
      }
    }
    function wg(i, o) {
      var d = i.ref;
      if (d !== null)
        if (typeof d == "function") {
          var h;
          try {
            if (re && Qe && i.mode & Lt)
              try {
                vc(), h = d(null);
              } finally {
                mc(i);
              }
            else
              h = d(null);
          } catch (b) {
            Sr(i, o, b);
          }
          typeof h == "function" && c("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Ft(i));
        } else
          d.current = null;
    }
    function ow(i, o, d) {
      try {
        d();
      } catch (h) {
        Sr(i, o, h);
      }
    }
    var uM = !1;
    function T8(i, o) {
      z6(i.containerInfo), vt = o, k8();
      var d = uM;
      return uM = !1, d;
    }
    function k8() {
      for (; vt !== null; ) {
        var i = vt, o = i.child;
        (i.subtreeFlags & ed) !== Mt && o !== null ? (o.return = i, vt = o) : P8();
      }
    }
    function P8() {
      for (; vt !== null; ) {
        var i = vt;
        Nn(i);
        try {
          I8(i);
        } catch (d) {
          Sr(i, i.return, d);
        }
        or();
        var o = i.sibling;
        if (o !== null) {
          o.return = i.return, vt = o;
          return;
        }
        vt = i.return;
      }
    }
    function I8(i) {
      var o = i.alternate, d = i.flags;
      if ((d & ka) !== Mt) {
        switch (Nn(i), i.tag) {
          case p:
          case j:
          case K:
            break;
          case g: {
            if (o !== null) {
              var h = o.memoizedProps, b = o.memoizedState, C = i.stateNode;
              i.type === i.elementType && !up && (C.props !== i.memoizedProps && c("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ft(i) || "instance"), C.state !== i.memoizedState && c("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ft(i) || "instance"));
              var R = C.getSnapshotBeforeUpdate(i.elementType === i.type ? h : Sl(i.type, h), b);
              {
                var A = sM;
                R === void 0 && !A.has(i.type) && (A.add(i.type), c("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", Ft(i)));
              }
              C.__reactInternalSnapshotBeforeUpdate = R;
            }
            break;
          }
          case v: {
            {
              var B = i.stateNode;
              uU(B.containerInfo);
            }
            break;
          }
          case x:
          case _:
          case S:
          case se:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        or();
      }
    }
    function Cl(i, o, d) {
      var h = o.updateQueue, b = h !== null ? h.lastEffect : null;
      if (b !== null) {
        var C = b.next, R = C;
        do {
          if ((R.tag & i) === i) {
            var A = R.destroy;
            R.destroy = void 0, A !== void 0 && ((i & mo) !== za ? uh(o) : (i & ji) !== za && dh(o), (i & pc) !== za && wy(!0), ow(o, d, A), (i & pc) !== za && wy(!1), (i & mo) !== za ? v0() : (i & ji) !== za && td());
          }
          R = R.next;
        } while (R !== C);
      }
    }
    function Od(i, o) {
      var d = o.updateQueue, h = d !== null ? d.lastEffect : null;
      if (h !== null) {
        var b = h.next, C = b;
        do {
          if ((C.tag & i) === i) {
            (i & mo) !== za ? m0(o) : (i & ji) !== za && y0(o);
            var R = C.create;
            (i & pc) !== za && wy(!0), C.destroy = R(), (i & pc) !== za && wy(!1), (i & mo) !== za ? Zm() : (i & ji) !== za && b0();
            {
              var A = C.destroy;
              if (A !== void 0 && typeof A != "function") {
                var B = void 0;
                (C.tag & ji) !== Mt ? B = "useLayoutEffect" : (C.tag & pc) !== Mt ? B = "useInsertionEffect" : B = "useEffect";
                var V = void 0;
                A === null ? V = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof A.then == "function" ? V = `

It looks like you wrote ` + B + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + B + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : V = " You returned: " + A, c("%s must not return anything besides a function, which is used for clean-up.%s", B, V);
              }
            }
          }
          C = C.next;
        } while (C !== b);
      }
    }
    function R8(i, o) {
      if ((o.flags & on) !== Mt)
        switch (o.tag) {
          case L: {
            var d = o.stateNode.passiveEffectDuration, h = o.memoizedProps, b = h.id, C = h.onPostCommit, R = M$(), A = o.alternate === null ? "mount" : "update";
            $$() && (A = "nested-update"), typeof C == "function" && C(b, A, d, R);
            var B = o.return;
            e:
              for (; B !== null; ) {
                switch (B.tag) {
                  case v:
                    var V = B.stateNode;
                    V.passiveEffectDuration += d;
                    break e;
                  case L:
                    var G = B.stateNode;
                    G.passiveEffectDuration += d;
                    break e;
                }
                B = B.return;
              }
            break;
          }
        }
    }
    function $8(i, o, d, h) {
      if ((d.flags & Xi) !== Mt)
        switch (d.tag) {
          case p:
          case j:
          case K: {
            if (!yo)
              if (d.mode & Lt)
                try {
                  vc(), Od(ji | Li, d);
                } finally {
                  mc(d);
                }
              else
                Od(ji | Li, d);
            break;
          }
          case g: {
            var b = d.stateNode;
            if (d.flags & on && !yo)
              if (o === null)
                if (d.type === d.elementType && !up && (b.props !== d.memoizedProps && c("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ft(d) || "instance"), b.state !== d.memoizedState && c("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ft(d) || "instance")), d.mode & Lt)
                  try {
                    vc(), b.componentDidMount();
                  } finally {
                    mc(d);
                  }
                else
                  b.componentDidMount();
              else {
                var C = d.elementType === d.type ? o.memoizedProps : Sl(d.type, o.memoizedProps), R = o.memoizedState;
                if (d.type === d.elementType && !up && (b.props !== d.memoizedProps && c("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ft(d) || "instance"), b.state !== d.memoizedState && c("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ft(d) || "instance")), d.mode & Lt)
                  try {
                    vc(), b.componentDidUpdate(C, R, b.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    mc(d);
                  }
                else
                  b.componentDidUpdate(C, R, b.__reactInternalSnapshotBeforeUpdate);
              }
            var A = d.updateQueue;
            A !== null && (d.type === d.elementType && !up && (b.props !== d.memoizedProps && c("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ft(d) || "instance"), b.state !== d.memoizedState && c("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ft(d) || "instance")), YR(d, A, b));
            break;
          }
          case v: {
            var B = d.updateQueue;
            if (B !== null) {
              var V = null;
              if (d.child !== null)
                switch (d.child.tag) {
                  case x:
                    V = d.child.stateNode;
                    break;
                  case g:
                    V = d.child.stateNode;
                    break;
                }
              YR(d, B, V);
            }
            break;
          }
          case x: {
            var G = d.stateNode;
            if (o === null && d.flags & on) {
              var ae = d.type, ne = d.memoizedProps;
              q6(G, ae, ne);
            }
            break;
          }
          case _:
            break;
          case S:
            break;
          case L: {
            {
              var Ce = d.memoizedProps, _e = Ce.onCommit, Ae = Ce.onRender, ut = d.stateNode.effectDuration, Ot = M$(), Pt = o === null ? "mount" : "update";
              $$() && (Pt = "nested-update"), typeof Ae == "function" && Ae(d.memoizedProps.id, Pt, d.actualDuration, d.treeBaseDuration, d.actualStartTime, Ot);
              {
                typeof _e == "function" && _e(d.memoizedProps.id, Pt, ut, Ot), PF(d);
                var _n = d.return;
                e:
                  for (; _n !== null; ) {
                    switch (_n.tag) {
                      case v:
                        var vn = _n.stateNode;
                        vn.effectDuration += ut;
                        break e;
                      case L:
                        var be = _n.stateNode;
                        be.effectDuration += ut;
                        break e;
                    }
                    _n = _n.return;
                  }
              }
            }
            break;
          }
          case z: {
            z8(i, d);
            break;
          }
          case pe:
          case se:
          case Pe:
          case ve:
          case Y:
          case Re:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      yo || d.flags & Mo && dM(d);
    }
    function M8(i) {
      switch (i.tag) {
        case p:
        case j:
        case K: {
          if (i.mode & Lt)
            try {
              vc(), lM(i, i.return);
            } finally {
              mc(i);
            }
          else
            lM(i, i.return);
          break;
        }
        case g: {
          var o = i.stateNode;
          typeof o.componentDidMount == "function" && _8(i, i.return, o), cM(i, i.return);
          break;
        }
        case x: {
          cM(i, i.return);
          break;
        }
      }
    }
    function A8(i, o) {
      for (var d = null, h = i; ; ) {
        if (h.tag === x) {
          if (d === null) {
            d = h;
            try {
              var b = h.stateNode;
              o ? aU(b) : lU(h.stateNode, h.memoizedProps);
            } catch (R) {
              Sr(i, i.return, R);
            }
          }
        } else if (h.tag === _) {
          if (d === null)
            try {
              var C = h.stateNode;
              o ? sU(C) : cU(C, h.memoizedProps);
            } catch (R) {
              Sr(i, i.return, R);
            }
        } else if (!((h.tag === ve || h.tag === Y) && h.memoizedState !== null && h !== i)) {
          if (h.child !== null) {
            h.child.return = h, h = h.child;
            continue;
          }
        }
        if (h === i)
          return;
        for (; h.sibling === null; ) {
          if (h.return === null || h.return === i)
            return;
          d === h && (d = null), h = h.return;
        }
        d === h && (d = null), h.sibling.return = h.return, h = h.sibling;
      }
    }
    function dM(i) {
      var o = i.ref;
      if (o !== null) {
        var d = i.stateNode, h;
        switch (i.tag) {
          case x:
            h = d;
            break;
          default:
            h = d;
        }
        if (typeof o == "function") {
          var b;
          if (i.mode & Lt)
            try {
              vc(), b = o(h);
            } finally {
              mc(i);
            }
          else
            b = o(h);
          typeof b == "function" && c("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Ft(i));
        } else
          o.hasOwnProperty("current") || c("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", Ft(i)), o.current = h;
      }
    }
    function O8(i) {
      var o = i.alternate;
      o !== null && (o.return = null), i.return = null;
    }
    function fM(i) {
      var o = i.alternate;
      o !== null && (i.alternate = null, fM(o));
      {
        if (i.child = null, i.deletions = null, i.sibling = null, i.tag === x) {
          var d = i.stateNode;
          d !== null && BU(d);
        }
        i.stateNode = null, i._debugOwner = null, i.return = null, i.dependencies = null, i.memoizedProps = null, i.memoizedState = null, i.pendingProps = null, i.stateNode = null, i.updateQueue = null;
      }
    }
    function D8(i) {
      for (var o = i.return; o !== null; ) {
        if (pM(o))
          return o;
        o = o.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function pM(i) {
      return i.tag === x || i.tag === v || i.tag === S;
    }
    function hM(i) {
      var o = i;
      e:
        for (; ; ) {
          for (; o.sibling === null; ) {
            if (o.return === null || pM(o.return))
              return null;
            o = o.return;
          }
          for (o.sibling.return = o.return, o = o.sibling; o.tag !== x && o.tag !== _ && o.tag !== ue; ) {
            if (o.flags & mr || o.child === null || o.tag === S)
              continue e;
            o.child.return = o, o = o.child;
          }
          if (!(o.flags & mr))
            return o.stateNode;
        }
    }
    function N8(i) {
      var o = D8(i);
      switch (o.tag) {
        case x: {
          var d = o.stateNode;
          o.flags & Vn && (gR(d), o.flags &= ~Vn);
          var h = hM(i);
          A_(i, h, d);
          break;
        }
        case v:
        case S: {
          var b = o.stateNode.containerInfo, C = hM(i);
          M_(i, C, b);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function M_(i, o, d) {
      var h = i.tag, b = h === x || h === _;
      if (b) {
        var C = i.stateNode;
        o ? nU(d, C, o) : eU(d, C);
      } else if (h !== S) {
        var R = i.child;
        if (R !== null) {
          M_(R, o, d);
          for (var A = R.sibling; A !== null; )
            M_(A, o, d), A = A.sibling;
        }
      }
    }
    function A_(i, o, d) {
      var h = i.tag, b = h === x || h === _;
      if (b) {
        var C = i.stateNode;
        o ? tU(d, C, o) : J6(d, C);
      } else if (h !== S) {
        var R = i.child;
        if (R !== null) {
          A_(R, o, d);
          for (var A = R.sibling; A !== null; )
            A_(A, o, d), A = A.sibling;
        }
      }
    }
    var bo = null, _l = !1;
    function L8(i, o, d) {
      {
        var h = o;
        e:
          for (; h !== null; ) {
            switch (h.tag) {
              case x: {
                bo = h.stateNode, _l = !1;
                break e;
              }
              case v: {
                bo = h.stateNode.containerInfo, _l = !0;
                break e;
              }
              case S: {
                bo = h.stateNode.containerInfo, _l = !0;
                break e;
              }
            }
            h = h.return;
          }
        if (bo === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        gM(i, o, d), bo = null, _l = !1;
      }
      O8(d);
    }
    function Dd(i, o, d) {
      for (var h = d.child; h !== null; )
        gM(i, o, h), h = h.sibling;
    }
    function gM(i, o, d) {
      switch (qm(d), d.tag) {
        case x:
          yo || wg(d, o);
        case _: {
          {
            var h = bo, b = _l;
            bo = null, Dd(i, o, d), bo = h, _l = b, bo !== null && (_l ? iU(bo, d.stateNode) : rU(bo, d.stateNode));
          }
          return;
        }
        case ue: {
          bo !== null && (_l ? oU(bo, d.stateNode) : VE(bo, d.stateNode));
          return;
        }
        case S: {
          {
            var C = bo, R = _l;
            bo = d.stateNode.containerInfo, _l = !0, Dd(i, o, d), bo = C, _l = R;
          }
          return;
        }
        case p:
        case j:
        case F:
        case K: {
          if (!yo) {
            var A = d.updateQueue;
            if (A !== null) {
              var B = A.lastEffect;
              if (B !== null) {
                var V = B.next, G = V;
                do {
                  var ae = G, ne = ae.destroy, Ce = ae.tag;
                  ne !== void 0 && ((Ce & pc) !== za ? ow(d, o, ne) : (Ce & ji) !== za && (dh(d), d.mode & Lt ? (vc(), ow(d, o, ne), mc(d)) : ow(d, o, ne), td())), G = G.next;
                } while (G !== V);
              }
            }
          }
          Dd(i, o, d);
          return;
        }
        case g: {
          if (!yo) {
            wg(d, o);
            var _e = d.stateNode;
            typeof _e.componentWillUnmount == "function" && $_(d, o, _e);
          }
          Dd(i, o, d);
          return;
        }
        case Pe: {
          Dd(i, o, d);
          return;
        }
        case ve: {
          if (
            // TODO: Remove this dead flag
            d.mode & fn
          ) {
            var Ae = yo;
            yo = Ae || d.memoizedState !== null, Dd(i, o, d), yo = Ae;
          } else
            Dd(i, o, d);
          break;
        }
        default: {
          Dd(i, o, d);
          return;
        }
      }
    }
    function j8(i) {
      i.memoizedState;
    }
    function z8(i, o) {
      var d = o.memoizedState;
      if (d === null) {
        var h = o.alternate;
        if (h !== null) {
          var b = h.memoizedState;
          if (b !== null) {
            var C = b.dehydrated;
            C !== null && CU(C);
          }
        }
      }
    }
    function mM(i) {
      var o = i.updateQueue;
      if (o !== null) {
        i.updateQueue = null;
        var d = i.stateNode;
        d === null && (d = i.stateNode = new x8()), o.forEach(function(h) {
          var b = DF.bind(null, i, h);
          if (!d.has(h)) {
            if (d.add(h), Di)
              if (bg !== null && Sg !== null)
                Sy(Sg, bg);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            h.then(b, b);
          }
        });
      }
    }
    function U8(i, o, d) {
      bg = d, Sg = i, Nn(o), vM(o, i), Nn(o), bg = null, Sg = null;
    }
    function Tl(i, o, d) {
      var h = o.deletions;
      if (h !== null)
        for (var b = 0; b < h.length; b++) {
          var C = h[b];
          try {
            L8(i, o, C);
          } catch (B) {
            Sr(C, o, B);
          }
        }
      var R = Vl();
      if (o.subtreeFlags & Do)
        for (var A = o.child; A !== null; )
          Nn(A), vM(A, i), A = A.sibling;
      Nn(R);
    }
    function vM(i, o, d) {
      var h = i.alternate, b = i.flags;
      switch (i.tag) {
        case p:
        case j:
        case F:
        case K: {
          if (Tl(o, i), yc(i), b & on) {
            try {
              Cl(pc | Li, i, i.return), Od(pc | Li, i);
            } catch (Bt) {
              Sr(i, i.return, Bt);
            }
            if (i.mode & Lt) {
              try {
                vc(), Cl(ji | Li, i, i.return);
              } catch (Bt) {
                Sr(i, i.return, Bt);
              }
              mc(i);
            } else
              try {
                Cl(ji | Li, i, i.return);
              } catch (Bt) {
                Sr(i, i.return, Bt);
              }
          }
          return;
        }
        case g: {
          Tl(o, i), yc(i), b & Mo && h !== null && wg(h, h.return);
          return;
        }
        case x: {
          Tl(o, i), yc(i), b & Mo && h !== null && wg(h, h.return);
          {
            if (i.flags & Vn) {
              var C = i.stateNode;
              try {
                gR(C);
              } catch (Bt) {
                Sr(i, i.return, Bt);
              }
            }
            if (b & on) {
              var R = i.stateNode;
              if (R != null) {
                var A = i.memoizedProps, B = h !== null ? h.memoizedProps : A, V = i.type, G = i.updateQueue;
                if (i.updateQueue = null, G !== null)
                  try {
                    Q6(R, G, V, B, A, i);
                  } catch (Bt) {
                    Sr(i, i.return, Bt);
                  }
              }
            }
          }
          return;
        }
        case _: {
          if (Tl(o, i), yc(i), b & on) {
            if (i.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var ae = i.stateNode, ne = i.memoizedProps, Ce = h !== null ? h.memoizedProps : ne;
            try {
              Z6(ae, Ce, ne);
            } catch (Bt) {
              Sr(i, i.return, Bt);
            }
          }
          return;
        }
        case v: {
          if (Tl(o, i), yc(i), b & on && h !== null) {
            var _e = h.memoizedState;
            if (_e.isDehydrated)
              try {
                EU(o.containerInfo);
              } catch (Bt) {
                Sr(i, i.return, Bt);
              }
          }
          return;
        }
        case S: {
          Tl(o, i), yc(i);
          return;
        }
        case z: {
          Tl(o, i), yc(i);
          var Ae = i.child;
          if (Ae.flags & Xl) {
            var ut = Ae.stateNode, Ot = Ae.memoizedState, Pt = Ot !== null;
            if (ut.isHidden = Pt, Pt) {
              var _n = Ae.alternate !== null && Ae.alternate.memoizedState !== null;
              _n || SF();
            }
          }
          if (b & on) {
            try {
              j8(i);
            } catch (Bt) {
              Sr(i, i.return, Bt);
            }
            mM(i);
          }
          return;
        }
        case ve: {
          var vn = h !== null && h.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            i.mode & fn
          ) {
            var be = yo;
            yo = be || vn, Tl(o, i), yo = be;
          } else
            Tl(o, i);
          if (yc(i), b & Xl) {
            var Oe = i.stateNode, Se = i.memoizedState, We = Se !== null, dt = i;
            if (Oe.isHidden = We, We && !vn && (dt.mode & fn) !== Dt) {
              vt = dt;
              for (var at = dt.child; at !== null; )
                vt = at, F8(at), at = at.sibling;
            }
            A8(dt, We);
          }
          return;
        }
        case pe: {
          Tl(o, i), yc(i), b & on && mM(i);
          return;
        }
        case Pe:
          return;
        default: {
          Tl(o, i), yc(i);
          return;
        }
      }
    }
    function yc(i) {
      var o = i.flags;
      if (o & mr) {
        try {
          N8(i);
        } catch (d) {
          Sr(i, i.return, d);
        }
        i.flags &= ~mr;
      }
      o & Pa && (i.flags &= ~Pa);
    }
    function B8(i, o, d) {
      bg = d, Sg = o, vt = i, yM(i, o, d), bg = null, Sg = null;
    }
    function yM(i, o, d) {
      for (var h = (i.mode & fn) !== Dt; vt !== null; ) {
        var b = vt, C = b.child;
        if (b.tag === ve && h) {
          var R = b.memoizedState !== null, A = R || iw;
          if (A) {
            O_(i, o, d);
            continue;
          } else {
            var B = b.alternate, V = B !== null && B.memoizedState !== null, G = V || yo, ae = iw, ne = yo;
            iw = A, yo = G, yo && !ne && (vt = b, H8(b));
            for (var Ce = C; Ce !== null; )
              vt = Ce, yM(
                Ce,
                // New root; bubble back up to here and stop.
                o,
                d
              ), Ce = Ce.sibling;
            vt = b, iw = ae, yo = ne, O_(i, o, d);
            continue;
          }
        }
        (b.subtreeFlags & Xi) !== Mt && C !== null ? (C.return = b, vt = C) : O_(i, o, d);
      }
    }
    function O_(i, o, d) {
      for (; vt !== null; ) {
        var h = vt;
        if ((h.flags & Xi) !== Mt) {
          var b = h.alternate;
          Nn(h);
          try {
            $8(o, b, h, d);
          } catch (R) {
            Sr(h, h.return, R);
          }
          or();
        }
        if (h === i) {
          vt = null;
          return;
        }
        var C = h.sibling;
        if (C !== null) {
          C.return = h.return, vt = C;
          return;
        }
        vt = h.return;
      }
    }
    function F8(i) {
      for (; vt !== null; ) {
        var o = vt, d = o.child;
        switch (o.tag) {
          case p:
          case j:
          case F:
          case K: {
            if (o.mode & Lt)
              try {
                vc(), Cl(ji, o, o.return);
              } finally {
                mc(o);
              }
            else
              Cl(ji, o, o.return);
            break;
          }
          case g: {
            wg(o, o.return);
            var h = o.stateNode;
            typeof h.componentWillUnmount == "function" && $_(o, o.return, h);
            break;
          }
          case x: {
            wg(o, o.return);
            break;
          }
          case ve: {
            var b = o.memoizedState !== null;
            if (b) {
              bM(i);
              continue;
            }
            break;
          }
        }
        d !== null ? (d.return = o, vt = d) : bM(i);
      }
    }
    function bM(i) {
      for (; vt !== null; ) {
        var o = vt;
        if (o === i) {
          vt = null;
          return;
        }
        var d = o.sibling;
        if (d !== null) {
          d.return = o.return, vt = d;
          return;
        }
        vt = o.return;
      }
    }
    function H8(i) {
      for (; vt !== null; ) {
        var o = vt, d = o.child;
        if (o.tag === ve) {
          var h = o.memoizedState !== null;
          if (h) {
            SM(i);
            continue;
          }
        }
        d !== null ? (d.return = o, vt = d) : SM(i);
      }
    }
    function SM(i) {
      for (; vt !== null; ) {
        var o = vt;
        Nn(o);
        try {
          M8(o);
        } catch (h) {
          Sr(o, o.return, h);
        }
        if (or(), o === i) {
          vt = null;
          return;
        }
        var d = o.sibling;
        if (d !== null) {
          d.return = o.return, vt = d;
          return;
        }
        vt = o.return;
      }
    }
    function V8(i, o, d, h) {
      vt = o, Y8(o, i, d, h);
    }
    function Y8(i, o, d, h) {
      for (; vt !== null; ) {
        var b = vt, C = b.child;
        (b.subtreeFlags & Ia) !== Mt && C !== null ? (C.return = b, vt = C) : K8(i, o, d, h);
      }
    }
    function K8(i, o, d, h) {
      for (; vt !== null; ) {
        var b = vt;
        if ((b.flags & kr) !== Mt) {
          Nn(b);
          try {
            W8(o, b, d, h);
          } catch (R) {
            Sr(b, b.return, R);
          }
          or();
        }
        if (b === i) {
          vt = null;
          return;
        }
        var C = b.sibling;
        if (C !== null) {
          C.return = b.return, vt = C;
          return;
        }
        vt = b.return;
      }
    }
    function W8(i, o, d, h) {
      switch (o.tag) {
        case p:
        case j:
        case K: {
          if (o.mode & Lt) {
            d_();
            try {
              Od(mo | Li, o);
            } finally {
              u_(o);
            }
          } else
            Od(mo | Li, o);
          break;
        }
      }
    }
    function G8(i) {
      vt = i, X8();
    }
    function X8() {
      for (; vt !== null; ) {
        var i = vt, o = i.child;
        if ((vt.flags & Un) !== Mt) {
          var d = i.deletions;
          if (d !== null) {
            for (var h = 0; h < d.length; h++) {
              var b = d[h];
              vt = b, Z8(b, i);
            }
            {
              var C = i.alternate;
              if (C !== null) {
                var R = C.child;
                if (R !== null) {
                  C.child = null;
                  do {
                    var A = R.sibling;
                    R.sibling = null, R = A;
                  } while (R !== null);
                }
              }
            }
            vt = i;
          }
        }
        (i.subtreeFlags & Ia) !== Mt && o !== null ? (o.return = i, vt = o) : q8();
      }
    }
    function q8() {
      for (; vt !== null; ) {
        var i = vt;
        (i.flags & kr) !== Mt && (Nn(i), Q8(i), or());
        var o = i.sibling;
        if (o !== null) {
          o.return = i.return, vt = o;
          return;
        }
        vt = i.return;
      }
    }
    function Q8(i) {
      switch (i.tag) {
        case p:
        case j:
        case K: {
          i.mode & Lt ? (d_(), Cl(mo | Li, i, i.return), u_(i)) : Cl(mo | Li, i, i.return);
          break;
        }
      }
    }
    function Z8(i, o) {
      for (; vt !== null; ) {
        var d = vt;
        Nn(d), eF(d, o), or();
        var h = d.child;
        h !== null ? (h.return = d, vt = h) : J8(i);
      }
    }
    function J8(i) {
      for (; vt !== null; ) {
        var o = vt, d = o.sibling, h = o.return;
        if (fM(o), o === i) {
          vt = null;
          return;
        }
        if (d !== null) {
          d.return = h, vt = d;
          return;
        }
        vt = h;
      }
    }
    function eF(i, o) {
      switch (i.tag) {
        case p:
        case j:
        case K: {
          i.mode & Lt ? (d_(), Cl(mo, i, o), u_(i)) : Cl(mo, i, o);
          break;
        }
      }
    }
    function tF(i) {
      switch (i.tag) {
        case p:
        case j:
        case K: {
          try {
            Od(ji | Li, i);
          } catch (d) {
            Sr(i, i.return, d);
          }
          break;
        }
        case g: {
          var o = i.stateNode;
          try {
            o.componentDidMount();
          } catch (d) {
            Sr(i, i.return, d);
          }
          break;
        }
      }
    }
    function nF(i) {
      switch (i.tag) {
        case p:
        case j:
        case K: {
          try {
            Od(mo | Li, i);
          } catch (o) {
            Sr(i, i.return, o);
          }
          break;
        }
      }
    }
    function rF(i) {
      switch (i.tag) {
        case p:
        case j:
        case K: {
          try {
            Cl(ji | Li, i, i.return);
          } catch (d) {
            Sr(i, i.return, d);
          }
          break;
        }
        case g: {
          var o = i.stateNode;
          typeof o.componentWillUnmount == "function" && $_(i, i.return, o);
          break;
        }
      }
    }
    function iF(i) {
      switch (i.tag) {
        case p:
        case j:
        case K:
          try {
            Cl(mo | Li, i, i.return);
          } catch (o) {
            Sr(i, i.return, o);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var cy = Symbol.for;
      cy("selector.component"), cy("selector.has_pseudo_class"), cy("selector.role"), cy("selector.test_id"), cy("selector.text");
    }
    var oF = [];
    function aF() {
      oF.forEach(function(i) {
        return i();
      });
    }
    var sF = n.ReactCurrentActQueue;
    function lF(i) {
      {
        var o = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), d = typeof jest < "u";
        return d && o !== !1;
      }
    }
    function wM() {
      {
        var i = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !i && sF.current !== null && c("The current testing environment is not configured to support act(...)"), i;
      }
    }
    var cF = Math.ceil, D_ = n.ReactCurrentDispatcher, N_ = n.ReactCurrentOwner, So = n.ReactCurrentBatchConfig, kl = n.ReactCurrentActQueue, Bi = (
      /*             */
      0
    ), xM = (
      /*               */
      1
    ), wo = (
      /*                */
      2
    ), js = (
      /*                */
      4
    ), Eu = 0, uy = 1, dp = 2, aw = 3, dy = 4, EM = 5, L_ = 6, Cn = Bi, aa = null, Qr = null, Fi = Ne, bc = Ne, j_ = _d(Ne), Hi = Eu, fy = null, sw = Ne, py = Ne, lw = Ne, hy = null, Ua = null, z_ = 0, CM = 500, _M = 1 / 0, uF = 500, Cu = null;
    function gy() {
      _M = Ar() + uF;
    }
    function TM() {
      return _M;
    }
    var cw = !1, U_ = null, xg = null, fp = !1, Nd = null, my = Ne, B_ = [], F_ = null, dF = 50, vy = 0, H_ = null, V_ = !1, uw = !1, fF = 50, Eg = 0, dw = null, yy = lr, fw = Ne, kM = !1;
    function pw() {
      return aa;
    }
    function sa() {
      return (Cn & (wo | js)) !== Bi ? Ar() : (yy !== lr || (yy = Ar()), yy);
    }
    function Ld(i) {
      var o = i.mode;
      if ((o & fn) === Dt)
        return jt;
      if ((Cn & wo) !== Bi && Fi !== Ne)
        return li(Fi);
      var d = lB() !== sB;
      if (d) {
        if (So.transition !== null) {
          var h = So.transition;
          h._updatedFibers || (h._updatedFibers = /* @__PURE__ */ new Set()), h._updatedFibers.add(i);
        }
        return fw === En && (fw = iv()), fw;
      }
      var b = Aa();
      if (b !== En)
        return b;
      var C = K6();
      return C;
    }
    function pF(i) {
      var o = i.mode;
      return (o & fn) === Dt ? jt : dE();
    }
    function Vi(i, o, d, h) {
      LF(), kM && c("useInsertionEffect must not schedule updates."), V_ && (uw = !0), au(i, d, h), (Cn & wo) !== Ne && i === aa ? UF(o) : (Di && cv(i, o, d), BF(o), i === aa && ((Cn & wo) === Bi && (py = an(py, d)), Hi === dy && jd(i, Fi)), Ba(i, h), d === jt && Cn === Bi && (o.mode & fn) === Dt && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !kl.isBatchingLegacy && (gy(), TR()));
    }
    function hF(i, o, d) {
      var h = i.current;
      h.lanes = o, au(i, o, d), Ba(i, d);
    }
    function gF(i) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (Cn & wo) !== Bi
      );
    }
    function Ba(i, o) {
      var d = i.callbackNode;
      lE(i, o);
      var h = Lf(i, i === aa ? Fi : Ne);
      if (h === Ne) {
        d !== null && HM(d), i.callbackNode = null, i.callbackPriority = En;
        return;
      }
      var b = ii(h), C = i.callbackPriority;
      if (C === b && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(kl.current !== null && d !== Q_)) {
        d == null && C !== jt && c("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      d != null && HM(d);
      var R;
      if (b === jt)
        i.tag === Td ? (kl.isBatchingLegacy !== null && (kl.didScheduleLegacyUpdate = !0), VU(RM.bind(null, i))) : _R(RM.bind(null, i)), kl.current !== null ? kl.current.push(kd) : G6(function() {
          (Cn & (wo | js)) === Bi && kd();
        }), R = null;
      else {
        var A;
        switch (Ff(h)) {
          case qi:
            A = sh;
            break;
          case Ni:
            A = na;
            break;
          case fl:
            A = Ps;
            break;
          case Uf:
            A = Ql;
            break;
          default:
            A = Ps;
            break;
        }
        R = Z_(A, PM.bind(null, i));
      }
      i.callbackPriority = b, i.callbackNode = R;
    }
    function PM(i, o) {
      if (LB(), yy = lr, fw = Ne, (Cn & (wo | js)) !== Bi)
        throw new Error("Should not already be working.");
      var d = i.callbackNode, h = Tu();
      if (h && i.callbackNode !== d)
        return null;
      var b = Lf(i, i === aa ? Fi : Ne);
      if (b === Ne)
        return null;
      var C = !zf(i, b) && !_0(i, b) && !o, R = C ? _F(i, b) : gw(i, b);
      if (R !== Eu) {
        if (R === dp) {
          var A = nv(i);
          A !== Ne && (b = A, R = Y_(i, A));
        }
        if (R === uy) {
          var B = fy;
          throw pp(i, Ne), jd(i, b), Ba(i, Ar()), B;
        }
        if (R === L_)
          jd(i, b);
        else {
          var V = !zf(i, b), G = i.current.alternate;
          if (V && !vF(G)) {
            if (R = gw(i, b), R === dp) {
              var ae = nv(i);
              ae !== Ne && (b = ae, R = Y_(i, ae));
            }
            if (R === uy) {
              var ne = fy;
              throw pp(i, Ne), jd(i, b), Ba(i, Ar()), ne;
            }
          }
          i.finishedWork = G, i.finishedLanes = b, mF(i, R, b);
        }
      }
      return Ba(i, Ar()), i.callbackNode === d ? PM.bind(null, i) : null;
    }
    function Y_(i, o) {
      var d = hy;
      if (di(i)) {
        var h = pp(i, o);
        h.flags |= Hr, LU(i.containerInfo);
      }
      var b = gw(i, o);
      if (b !== dp) {
        var C = Ua;
        Ua = d, C !== null && IM(C);
      }
      return b;
    }
    function IM(i) {
      Ua === null ? Ua = i : Ua.push.apply(Ua, i);
    }
    function mF(i, o, d) {
      switch (o) {
        case Eu:
        case uy:
          throw new Error("Root did not complete. This is a bug in React.");
        case dp: {
          hp(i, Ua, Cu);
          break;
        }
        case aw: {
          if (jd(i, d), $h(d) && // do not delay if we're inside an act() scope
          !VM()) {
            var h = z_ + CM - Ar();
            if (h > 10) {
              var b = Lf(i, Ne);
              if (b !== Ne)
                break;
              var C = i.suspendedLanes;
              if (!ou(C, d)) {
                sa(), sv(i, C);
                break;
              }
              i.timeoutHandle = FE(hp.bind(null, i, Ua, Cu), h);
              break;
            }
          }
          hp(i, Ua, Cu);
          break;
        }
        case dy: {
          if (jd(i, d), C0(d))
            break;
          if (!VM()) {
            var R = E0(i, d), A = R, B = Ar() - A, V = NF(B) - B;
            if (V > 10) {
              i.timeoutHandle = FE(hp.bind(null, i, Ua, Cu), V);
              break;
            }
          }
          hp(i, Ua, Cu);
          break;
        }
        case EM: {
          hp(i, Ua, Cu);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function vF(i) {
      for (var o = i; ; ) {
        if (o.flags & Rf) {
          var d = o.updateQueue;
          if (d !== null) {
            var h = d.stores;
            if (h !== null)
              for (var b = 0; b < h.length; b++) {
                var C = h[b], R = C.getSnapshot, A = C.value;
                try {
                  if (!mt(R(), A))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var B = o.child;
        if (o.subtreeFlags & Rf && B !== null) {
          B.return = o, o = B;
          continue;
        }
        if (o === i)
          return !0;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === i)
            return !0;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
      return !0;
    }
    function jd(i, o) {
      o = ld(o, lw), o = ld(o, py), av(i, o);
    }
    function RM(i) {
      if (jB(), (Cn & (wo | js)) !== Bi)
        throw new Error("Should not already be working.");
      Tu();
      var o = Lf(i, Ne);
      if (!zo(o, jt))
        return Ba(i, Ar()), null;
      var d = gw(i, o);
      if (i.tag !== Td && d === dp) {
        var h = nv(i);
        h !== Ne && (o = h, d = Y_(i, h));
      }
      if (d === uy) {
        var b = fy;
        throw pp(i, Ne), jd(i, o), Ba(i, Ar()), b;
      }
      if (d === L_)
        throw new Error("Root did not complete. This is a bug in React.");
      var C = i.current.alternate;
      return i.finishedWork = C, i.finishedLanes = o, hp(i, Ua, Cu), Ba(i, Ar()), null;
    }
    function yF(i, o) {
      o !== Ne && (cd(i, an(o, jt)), Ba(i, Ar()), (Cn & (wo | js)) === Bi && (gy(), kd()));
    }
    function K_(i, o) {
      var d = Cn;
      Cn |= xM;
      try {
        return i(o);
      } finally {
        Cn = d, Cn === Bi && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !kl.isBatchingLegacy && (gy(), TR());
      }
    }
    function bF(i, o, d, h, b) {
      var C = Aa(), R = So.transition;
      try {
        return So.transition = null, ci(qi), i(o, d, h, b);
      } finally {
        ci(C), So.transition = R, Cn === Bi && gy();
      }
    }
    function _u(i) {
      Nd !== null && Nd.tag === Td && (Cn & (wo | js)) === Bi && Tu();
      var o = Cn;
      Cn |= xM;
      var d = So.transition, h = Aa();
      try {
        return So.transition = null, ci(qi), i ? i() : void 0;
      } finally {
        ci(h), So.transition = d, Cn = o, (Cn & (wo | js)) === Bi && kd();
      }
    }
    function $M() {
      return (Cn & (wo | js)) !== Bi;
    }
    function hw(i, o) {
      Bo(j_, bc, i), bc = an(bc, o);
    }
    function W_(i) {
      bc = j_.current, Uo(j_, i);
    }
    function pp(i, o) {
      i.finishedWork = null, i.finishedLanes = Ne;
      var d = i.timeoutHandle;
      if (d !== HE && (i.timeoutHandle = HE, W6(d)), Qr !== null)
        for (var h = Qr.return; h !== null; ) {
          var b = h.alternate;
          aM(b, h), h = h.return;
        }
      aa = i;
      var C = gp(i.current, null);
      return Qr = C, Fi = bc = o, Hi = Eu, fy = null, sw = Ne, py = Ne, lw = Ne, hy = null, Ua = null, fB(), bl.discardPendingWarnings(), C;
    }
    function MM(i, o) {
      do {
        var d = Qr;
        try {
          if (xS(), l$(), or(), N_.current = null, d === null || d.return === null) {
            Hi = uy, fy = o, Qr = null;
            return;
          }
          if (re && d.mode & Lt && ew(d, !0), Me)
            if (qc(), o !== null && typeof o == "object" && typeof o.then == "function") {
              var h = o;
              S0(d, h, Fi);
            } else
              fh(d, o, Fi);
          HB(i, d.return, d, o, Fi), NM(d);
        } catch (b) {
          o = b, Qr === d && d !== null ? (d = d.return, Qr = d) : d = Qr;
          continue;
        }
        return;
      } while (!0);
    }
    function AM() {
      var i = D_.current;
      return D_.current = XS, i === null ? XS : i;
    }
    function OM(i) {
      D_.current = i;
    }
    function SF() {
      z_ = Ar();
    }
    function by(i) {
      sw = an(i, sw);
    }
    function wF() {
      Hi === Eu && (Hi = aw);
    }
    function G_() {
      (Hi === Eu || Hi === aw || Hi === dp) && (Hi = dy), aa !== null && (jf(sw) || jf(py)) && jd(aa, Fi);
    }
    function xF(i) {
      Hi !== dy && (Hi = dp), hy === null ? hy = [i] : hy.push(i);
    }
    function EF() {
      return Hi === Eu;
    }
    function gw(i, o) {
      var d = Cn;
      Cn |= wo;
      var h = AM();
      if (aa !== i || Fi !== o) {
        if (Di) {
          var b = i.memoizedUpdaters;
          b.size > 0 && (Sy(i, Fi), b.clear()), Oh(i, o);
        }
        Cu = uv(), pp(i, o);
      }
      is(o);
      do
        try {
          CF();
          break;
        } catch (C) {
          MM(i, C);
        }
      while (!0);
      if (xS(), Cn = d, OM(h), Qr !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return rd(), aa = null, Fi = Ne, Hi;
    }
    function CF() {
      for (; Qr !== null; )
        DM(Qr);
    }
    function _F(i, o) {
      var d = Cn;
      Cn |= wo;
      var h = AM();
      if (aa !== i || Fi !== o) {
        if (Di) {
          var b = i.memoizedUpdaters;
          b.size > 0 && (Sy(i, Fi), b.clear()), Oh(i, o);
        }
        Cu = uv(), gy(), pp(i, o);
      }
      is(o);
      do
        try {
          TF();
          break;
        } catch (C) {
          MM(i, C);
        }
      while (!0);
      return xS(), OM(h), Cn = d, Qr !== null ? (Af(), Eu) : (rd(), aa = null, Fi = Ne, Hi);
    }
    function TF() {
      for (; Qr !== null && !ah(); )
        DM(Qr);
    }
    function DM(i) {
      var o = i.alternate;
      Nn(i);
      var d;
      (i.mode & Lt) !== Dt ? (c_(i), d = X_(o, i, bc), ew(i, !0)) : d = X_(o, i, bc), or(), i.memoizedProps = i.pendingProps, d === null ? NM(i) : Qr = d, N_.current = null;
    }
    function NM(i) {
      var o = i;
      do {
        var d = o.alternate, h = o.return;
        if ((o.flags & Jo) === Mt) {
          Nn(o);
          var b = void 0;
          if ((o.mode & Lt) === Dt ? b = oM(d, o, bc) : (c_(o), b = oM(d, o, bc), ew(o, !1)), or(), b !== null) {
            Qr = b;
            return;
          }
        } else {
          var C = w8(d, o);
          if (C !== null) {
            C.flags &= d0, Qr = C;
            return;
          }
          if ((o.mode & Lt) !== Dt) {
            ew(o, !1);
            for (var R = o.actualDuration, A = o.child; A !== null; )
              R += A.actualDuration, A = A.sibling;
            o.actualDuration = R;
          }
          if (h !== null)
            h.flags |= Jo, h.subtreeFlags = Mt, h.deletions = null;
          else {
            Hi = L_, Qr = null;
            return;
          }
        }
        var B = o.sibling;
        if (B !== null) {
          Qr = B;
          return;
        }
        o = h, Qr = o;
      } while (o !== null);
      Hi === Eu && (Hi = EM);
    }
    function hp(i, o, d) {
      var h = Aa(), b = So.transition;
      try {
        So.transition = null, ci(qi), kF(i, o, d, h);
      } finally {
        So.transition = b, ci(h);
      }
      return null;
    }
    function kF(i, o, d, h) {
      do
        Tu();
      while (Nd !== null);
      if (jF(), (Cn & (wo | js)) !== Bi)
        throw new Error("Should not already be working.");
      var b = i.finishedWork, C = i.finishedLanes;
      if (ch(C), b === null)
        return Qm(), null;
      if (C === Ne && c("root.finishedLanes should not be empty during a commit. This is a bug in React."), i.finishedWork = null, i.finishedLanes = Ne, b === i.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      i.callbackNode = null, i.callbackPriority = En;
      var R = an(b.lanes, b.childLanes);
      lv(i, R), i === aa && (aa = null, Qr = null, Fi = Ne), ((b.subtreeFlags & Ia) !== Mt || (b.flags & Ia) !== Mt) && (fp || (fp = !0, F_ = d, Z_(Ps, function() {
        return Tu(), null;
      })));
      var A = (b.subtreeFlags & (ed | Do | Xi | Ia)) !== Mt, B = (b.flags & (ed | Do | Xi | Ia)) !== Mt;
      if (A || B) {
        var V = So.transition;
        So.transition = null;
        var G = Aa();
        ci(qi);
        var ae = Cn;
        Cn |= js, N_.current = null, T8(i, b), A$(), U8(i, b, C), U6(i.containerInfo), i.current = b, w0(C), B8(b, i, C), nd(), h0(), Cn = ae, ci(G), So.transition = V;
      } else
        i.current = b, A$();
      var ne = fp;
      if (fp ? (fp = !1, Nd = i, my = C) : (Eg = 0, dw = null), R = i.pendingLanes, R === Ne && (xg = null), ne || UM(i.current, !1), cl(b.stateNode, h), Di && i.memoizedUpdaters.clear(), aF(), Ba(i, Ar()), o !== null)
        for (var Ce = i.onRecoverableError, _e = 0; _e < o.length; _e++) {
          var Ae = o[_e], ut = Ae.stack, Ot = Ae.digest;
          Ce(Ae.value, {
            componentStack: ut,
            digest: Ot
          });
        }
      if (cw) {
        cw = !1;
        var Pt = U_;
        throw U_ = null, Pt;
      }
      return zo(my, jt) && i.tag !== Td && Tu(), R = i.pendingLanes, zo(R, jt) ? (NB(), i === H_ ? vy++ : (vy = 0, H_ = i)) : vy = 0, kd(), Qm(), null;
    }
    function Tu() {
      if (Nd !== null) {
        var i = Ff(my), o = pE(fl, i), d = So.transition, h = Aa();
        try {
          return So.transition = null, ci(o), IF();
        } finally {
          ci(h), So.transition = d;
        }
      }
      return !1;
    }
    function PF(i) {
      B_.push(i), fp || (fp = !0, Z_(Ps, function() {
        return Tu(), null;
      }));
    }
    function IF() {
      if (Nd === null)
        return !1;
      var i = F_;
      F_ = null;
      var o = Nd, d = my;
      if (Nd = null, my = Ne, (Cn & (wo | js)) !== Bi)
        throw new Error("Cannot flush passive effects while already rendering.");
      V_ = !0, uw = !1, x0(d);
      var h = Cn;
      Cn |= js, G8(o.current), V8(o, o.current, d, i);
      {
        var b = B_;
        B_ = [];
        for (var C = 0; C < b.length; C++) {
          var R = b[C];
          R8(o, R);
        }
      }
      Mf(), UM(o.current, !0), Cn = h, kd(), uw ? o === dw ? Eg++ : (Eg = 0, dw = o) : Eg = 0, V_ = !1, uw = !1, Jl(o);
      {
        var A = o.current.stateNode;
        A.effectDuration = 0, A.passiveEffectDuration = 0;
      }
      return !0;
    }
    function LM(i) {
      return xg !== null && xg.has(i);
    }
    function RF(i) {
      xg === null ? xg = /* @__PURE__ */ new Set([i]) : xg.add(i);
    }
    function $F(i) {
      cw || (cw = !0, U_ = i);
    }
    var MF = $F;
    function jM(i, o, d) {
      var h = cp(d, o), b = D$(i, h, jt), C = Id(i, b, jt), R = sa();
      C !== null && (au(C, jt, R), Ba(C, R));
    }
    function Sr(i, o, d) {
      if (E8(d), wy(!1), i.tag === v) {
        jM(i, i, d);
        return;
      }
      var h = null;
      for (h = o; h !== null; ) {
        if (h.tag === v) {
          jM(h, i, d);
          return;
        } else if (h.tag === g) {
          var b = h.type, C = h.stateNode;
          if (typeof b.getDerivedStateFromError == "function" || typeof C.componentDidCatch == "function" && !LM(C)) {
            var R = cp(d, i), A = g_(h, R, jt), B = Id(h, A, jt), V = sa();
            B !== null && (au(B, jt, V), Ba(B, V));
            return;
          }
        }
        h = h.return;
      }
      c(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, d);
    }
    function AF(i, o, d) {
      var h = i.pingCache;
      h !== null && h.delete(o);
      var b = sa();
      sv(i, d), FF(i), aa === i && ou(Fi, d) && (Hi === dy || Hi === aw && $h(Fi) && Ar() - z_ < CM ? pp(i, Ne) : lw = an(lw, d)), Ba(i, b);
    }
    function zM(i, o) {
      o === En && (o = pF(i));
      var d = sa(), h = ja(i, o);
      h !== null && (au(h, o, d), Ba(h, d));
    }
    function OF(i) {
      var o = i.memoizedState, d = En;
      o !== null && (d = o.retryLane), zM(i, d);
    }
    function DF(i, o) {
      var d = En, h;
      switch (i.tag) {
        case z:
          h = i.stateNode;
          var b = i.memoizedState;
          b !== null && (d = b.retryLane);
          break;
        case pe:
          h = i.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      h !== null && h.delete(o), zM(i, d);
    }
    function NF(i) {
      return i < 120 ? 120 : i < 480 ? 480 : i < 1080 ? 1080 : i < 1920 ? 1920 : i < 3e3 ? 3e3 : i < 4320 ? 4320 : cF(i / 1960) * 1960;
    }
    function LF() {
      if (vy > dF)
        throw vy = 0, H_ = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Eg > fF && (Eg = 0, dw = null, c("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function jF() {
      bl.flushLegacyContextWarning(), bl.flushPendingUnsafeLifecycleWarnings();
    }
    function UM(i, o) {
      Nn(i), mw(i, Oo, rF), o && mw(i, Xc, iF), mw(i, Oo, tF), o && mw(i, Xc, nF), or();
    }
    function mw(i, o, d) {
      for (var h = i, b = null; h !== null; ) {
        var C = h.subtreeFlags & o;
        h !== b && h.child !== null && C !== Mt ? h = h.child : ((h.flags & o) !== Mt && d(h), h.sibling !== null ? h = h.sibling : h = b = h.return);
      }
    }
    var vw = null;
    function BM(i) {
      {
        if ((Cn & wo) !== Bi || !(i.mode & fn))
          return;
        var o = i.tag;
        if (o !== y && o !== v && o !== g && o !== p && o !== j && o !== F && o !== K)
          return;
        var d = Ft(i) || "ReactComponent";
        if (vw !== null) {
          if (vw.has(d))
            return;
          vw.add(d);
        } else
          vw = /* @__PURE__ */ new Set([d]);
        var h = gr;
        try {
          Nn(i), c("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          h ? Nn(i) : or();
        }
      }
    }
    var X_;
    {
      var zF = null;
      X_ = function(i, o, d) {
        var h = XM(zF, o);
        try {
          return eM(i, o, d);
        } catch (C) {
          if (ZU() || C !== null && typeof C == "object" && typeof C.then == "function")
            throw C;
          if (xS(), l$(), aM(i, o), XM(o, h), o.mode & Lt && c_(o), Gc(null, eM, null, i, o, d), aE()) {
            var b = Um();
            typeof b == "object" && b !== null && b._suppressLogging && typeof C == "object" && C !== null && !C._suppressLogging && (C._suppressLogging = !0);
          }
          throw C;
        }
      };
    }
    var FM = !1, q_;
    q_ = /* @__PURE__ */ new Set();
    function UF(i) {
      if (Fr && !AB())
        switch (i.tag) {
          case p:
          case j:
          case K: {
            var o = Qr && Ft(Qr) || "Unknown", d = o;
            if (!q_.has(d)) {
              q_.add(d);
              var h = Ft(i) || "Unknown";
              c("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", h, o, o);
            }
            break;
          }
          case g: {
            FM || (c("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), FM = !0);
            break;
          }
        }
    }
    function Sy(i, o) {
      if (Di) {
        var d = i.memoizedUpdaters;
        d.forEach(function(h) {
          cv(i, h, o);
        });
      }
    }
    var Q_ = {};
    function Z_(i, o) {
      {
        var d = kl.current;
        return d !== null ? (d.push(o), Q_) : oh(i, o);
      }
    }
    function HM(i) {
      if (i !== Q_)
        return p0(i);
    }
    function VM() {
      return kl.current !== null;
    }
    function BF(i) {
      {
        if (i.mode & fn) {
          if (!wM())
            return;
        } else if (!lF() || Cn !== Bi || i.tag !== p && i.tag !== j && i.tag !== K)
          return;
        if (kl.current === null) {
          var o = gr;
          try {
            Nn(i), c(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, Ft(i));
          } finally {
            o ? Nn(i) : or();
          }
        }
      }
    }
    function FF(i) {
      i.tag !== Td && wM() && kl.current === null && c(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function wy(i) {
      kM = i;
    }
    var zs = null, Cg = null, HF = function(i) {
      zs = i;
    };
    function _g(i) {
      {
        if (zs === null)
          return i;
        var o = zs(i);
        return o === void 0 ? i : o.current;
      }
    }
    function J_(i) {
      return _g(i);
    }
    function eT(i) {
      {
        if (zs === null)
          return i;
        var o = zs(i);
        if (o === void 0) {
          if (i != null && typeof i.render == "function") {
            var d = _g(i.render);
            if (i.render !== d) {
              var h = {
                $$typeof: st,
                render: d
              };
              return i.displayName !== void 0 && (h.displayName = i.displayName), h;
            }
          }
          return i;
        }
        return o.current;
      }
    }
    function YM(i, o) {
      {
        if (zs === null)
          return !1;
        var d = i.elementType, h = o.type, b = !1, C = typeof h == "object" && h !== null ? h.$$typeof : null;
        switch (i.tag) {
          case g: {
            typeof h == "function" && (b = !0);
            break;
          }
          case p: {
            (typeof h == "function" || C === Rt) && (b = !0);
            break;
          }
          case j: {
            (C === st || C === Rt) && (b = !0);
            break;
          }
          case F:
          case K: {
            (C === Qt || C === Rt) && (b = !0);
            break;
          }
          default:
            return !1;
        }
        if (b) {
          var R = zs(d);
          if (R !== void 0 && R === zs(h))
            return !0;
        }
        return !1;
      }
    }
    function KM(i) {
      {
        if (zs === null || typeof WeakSet != "function")
          return;
        Cg === null && (Cg = /* @__PURE__ */ new WeakSet()), Cg.add(i);
      }
    }
    var VF = function(i, o) {
      {
        if (zs === null)
          return;
        var d = o.staleFamilies, h = o.updatedFamilies;
        Tu(), _u(function() {
          tT(i.current, h, d);
        });
      }
    }, YF = function(i, o) {
      {
        if (i.context !== as)
          return;
        Tu(), _u(function() {
          xy(o, i, null, null);
        });
      }
    };
    function tT(i, o, d) {
      {
        var h = i.alternate, b = i.child, C = i.sibling, R = i.tag, A = i.type, B = null;
        switch (R) {
          case p:
          case K:
          case g:
            B = A;
            break;
          case j:
            B = A.render;
            break;
        }
        if (zs === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var V = !1, G = !1;
        if (B !== null) {
          var ae = zs(B);
          ae !== void 0 && (d.has(ae) ? G = !0 : o.has(ae) && (R === g ? G = !0 : V = !0));
        }
        if (Cg !== null && (Cg.has(i) || h !== null && Cg.has(h)) && (G = !0), G && (i._debugNeedsRemount = !0), G || V) {
          var ne = ja(i, jt);
          ne !== null && Vi(ne, i, jt, lr);
        }
        b !== null && !G && tT(b, o, d), C !== null && tT(C, o, d);
      }
    }
    var KF = function(i, o) {
      {
        var d = /* @__PURE__ */ new Set(), h = new Set(o.map(function(b) {
          return b.current;
        }));
        return nT(i.current, h, d), d;
      }
    };
    function nT(i, o, d) {
      {
        var h = i.child, b = i.sibling, C = i.tag, R = i.type, A = null;
        switch (C) {
          case p:
          case K:
          case g:
            A = R;
            break;
          case j:
            A = R.render;
            break;
        }
        var B = !1;
        A !== null && o.has(A) && (B = !0), B ? WF(i, d) : h !== null && nT(h, o, d), b !== null && nT(b, o, d);
      }
    }
    function WF(i, o) {
      {
        var d = GF(i, o);
        if (d)
          return;
        for (var h = i; ; ) {
          switch (h.tag) {
            case x:
              o.add(h.stateNode);
              return;
            case S:
              o.add(h.stateNode.containerInfo);
              return;
            case v:
              o.add(h.stateNode.containerInfo);
              return;
          }
          if (h.return === null)
            throw new Error("Expected to reach root first.");
          h = h.return;
        }
      }
    }
    function GF(i, o) {
      for (var d = i, h = !1; ; ) {
        if (d.tag === x)
          h = !0, o.add(d.stateNode);
        else if (d.child !== null) {
          d.child.return = d, d = d.child;
          continue;
        }
        if (d === i)
          return h;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === i)
            return h;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
      return !1;
    }
    var rT;
    {
      rT = !1;
      try {
        var WM = Object.preventExtensions({});
      } catch {
        rT = !0;
      }
    }
    function XF(i, o, d, h) {
      this.tag = i, this.key = d, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = o, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = h, this.flags = Mt, this.subtreeFlags = Mt, this.deletions = null, this.lanes = Ne, this.childLanes = Ne, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !rT && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var ss = function(i, o, d, h) {
      return new XF(i, o, d, h);
    };
    function iT(i) {
      var o = i.prototype;
      return !!(o && o.isReactComponent);
    }
    function qF(i) {
      return typeof i == "function" && !iT(i) && i.defaultProps === void 0;
    }
    function QF(i) {
      if (typeof i == "function")
        return iT(i) ? g : p;
      if (i != null) {
        var o = i.$$typeof;
        if (o === st)
          return j;
        if (o === Qt)
          return F;
      }
      return y;
    }
    function gp(i, o) {
      var d = i.alternate;
      d === null ? (d = ss(i.tag, o, i.key, i.mode), d.elementType = i.elementType, d.type = i.type, d.stateNode = i.stateNode, d._debugSource = i._debugSource, d._debugOwner = i._debugOwner, d._debugHookTypes = i._debugHookTypes, d.alternate = i, i.alternate = d) : (d.pendingProps = o, d.type = i.type, d.flags = Mt, d.subtreeFlags = Mt, d.deletions = null, d.actualDuration = 0, d.actualStartTime = -1), d.flags = i.flags & Oi, d.childLanes = i.childLanes, d.lanes = i.lanes, d.child = i.child, d.memoizedProps = i.memoizedProps, d.memoizedState = i.memoizedState, d.updateQueue = i.updateQueue;
      var h = i.dependencies;
      switch (d.dependencies = h === null ? null : {
        lanes: h.lanes,
        firstContext: h.firstContext
      }, d.sibling = i.sibling, d.index = i.index, d.ref = i.ref, d.selfBaseDuration = i.selfBaseDuration, d.treeBaseDuration = i.treeBaseDuration, d._debugNeedsRemount = i._debugNeedsRemount, d.tag) {
        case y:
        case p:
        case K:
          d.type = _g(i.type);
          break;
        case g:
          d.type = J_(i.type);
          break;
        case j:
          d.type = eT(i.type);
          break;
      }
      return d;
    }
    function ZF(i, o) {
      i.flags &= Oi | mr;
      var d = i.alternate;
      if (d === null)
        i.childLanes = Ne, i.lanes = o, i.child = null, i.subtreeFlags = Mt, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null, i.selfBaseDuration = 0, i.treeBaseDuration = 0;
      else {
        i.childLanes = d.childLanes, i.lanes = d.lanes, i.child = d.child, i.subtreeFlags = Mt, i.deletions = null, i.memoizedProps = d.memoizedProps, i.memoizedState = d.memoizedState, i.updateQueue = d.updateQueue, i.type = d.type;
        var h = d.dependencies;
        i.dependencies = h === null ? null : {
          lanes: h.lanes,
          firstContext: h.firstContext
        }, i.selfBaseDuration = d.selfBaseDuration, i.treeBaseDuration = d.treeBaseDuration;
      }
      return i;
    }
    function JF(i, o, d) {
      var h;
      return i === hS ? (h = fn, o === !0 && (h |= Or, h |= $a)) : h = Dt, Di && (h |= Lt), ss(v, null, null, h);
    }
    function oT(i, o, d, h, b, C) {
      var R = y, A = i;
      if (typeof i == "function")
        iT(i) ? (R = g, A = J_(A)) : A = _g(A);
      else if (typeof i == "string")
        R = x;
      else
        e:
          switch (i) {
            case Mi:
              return zd(d.children, b, C, o);
            case Si:
              R = I, b |= Or, (b & fn) !== Dt && (b |= $a);
              break;
            case J:
              return e7(d, b, C, o);
            case Kt:
              return t7(d, b, C, o);
            case qt:
              return n7(d, b, C, o);
            case Zn:
              return GM(d, b, C, o);
            case hr:
            case Br:
            case Ea:
            case jl:
            case Qn:
            default: {
              if (typeof i == "object" && i !== null)
                switch (i.$$typeof) {
                  case Be:
                    R = N;
                    break e;
                  case et:
                    R = D;
                    break e;
                  case st:
                    R = j, A = eT(A);
                    break e;
                  case Qt:
                    R = F;
                    break e;
                  case Rt:
                    R = X, A = null;
                    break e;
                }
              var B = "";
              {
                (i === void 0 || typeof i == "object" && i !== null && Object.keys(i).length === 0) && (B += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var V = h ? Ft(h) : null;
                V && (B += `

Check the render method of \`` + V + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (i == null ? i : typeof i) + "." + B));
            }
          }
      var G = ss(R, d, o, b);
      return G.elementType = i, G.type = A, G.lanes = C, G._debugOwner = h, G;
    }
    function aT(i, o, d) {
      var h = null;
      h = i._owner;
      var b = i.type, C = i.key, R = i.props, A = oT(b, C, R, h, o, d);
      return A._debugSource = i._source, A._debugOwner = i._owner, A;
    }
    function zd(i, o, d, h) {
      var b = ss(T, i, h, o);
      return b.lanes = d, b;
    }
    function e7(i, o, d, h) {
      typeof i.id != "string" && c('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof i.id);
      var b = ss(L, i, h, o | Lt);
      return b.elementType = J, b.lanes = d, b.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, b;
    }
    function t7(i, o, d, h) {
      var b = ss(z, i, h, o);
      return b.elementType = Kt, b.lanes = d, b;
    }
    function n7(i, o, d, h) {
      var b = ss(pe, i, h, o);
      return b.elementType = qt, b.lanes = d, b;
    }
    function GM(i, o, d, h) {
      var b = ss(ve, i, h, o);
      b.elementType = Zn, b.lanes = d;
      var C = {
        isHidden: !1
      };
      return b.stateNode = C, b;
    }
    function sT(i, o, d) {
      var h = ss(_, i, null, o);
      return h.lanes = d, h;
    }
    function r7() {
      var i = ss(x, null, null, Dt);
      return i.elementType = "DELETED", i;
    }
    function i7(i) {
      var o = ss(ue, null, null, Dt);
      return o.stateNode = i, o;
    }
    function lT(i, o, d) {
      var h = i.children !== null ? i.children : [], b = ss(S, h, i.key, o);
      return b.lanes = d, b.stateNode = {
        containerInfo: i.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: i.implementation
      }, b;
    }
    function XM(i, o) {
      return i === null && (i = ss(y, null, null, Dt)), i.tag = o.tag, i.key = o.key, i.elementType = o.elementType, i.type = o.type, i.stateNode = o.stateNode, i.return = o.return, i.child = o.child, i.sibling = o.sibling, i.index = o.index, i.ref = o.ref, i.pendingProps = o.pendingProps, i.memoizedProps = o.memoizedProps, i.updateQueue = o.updateQueue, i.memoizedState = o.memoizedState, i.dependencies = o.dependencies, i.mode = o.mode, i.flags = o.flags, i.subtreeFlags = o.subtreeFlags, i.deletions = o.deletions, i.lanes = o.lanes, i.childLanes = o.childLanes, i.alternate = o.alternate, i.actualDuration = o.actualDuration, i.actualStartTime = o.actualStartTime, i.selfBaseDuration = o.selfBaseDuration, i.treeBaseDuration = o.treeBaseDuration, i._debugSource = o._debugSource, i._debugOwner = o._debugOwner, i._debugNeedsRemount = o._debugNeedsRemount, i._debugHookTypes = o._debugHookTypes, i;
    }
    function o7(i, o, d, h, b) {
      this.tag = o, this.containerInfo = i, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = HE, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = En, this.eventTimes = Ah(Ne), this.expirationTimes = Ah(lr), this.pendingLanes = Ne, this.suspendedLanes = Ne, this.pingedLanes = Ne, this.expiredLanes = Ne, this.mutableReadLanes = Ne, this.finishedLanes = Ne, this.entangledLanes = Ne, this.entanglements = Ah(Ne), this.identifierPrefix = h, this.onRecoverableError = b, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var C = this.pendingUpdatersLaneMap = [], R = 0; R < yr; R++)
          C.push(/* @__PURE__ */ new Set());
      }
      switch (o) {
        case hS:
          this._debugRootType = d ? "hydrateRoot()" : "createRoot()";
          break;
        case Td:
          this._debugRootType = d ? "hydrate()" : "render()";
          break;
      }
    }
    function qM(i, o, d, h, b, C, R, A, B, V) {
      var G = new o7(i, o, d, A, B), ae = JF(o, C);
      G.current = ae, ae.stateNode = G;
      {
        var ne = {
          element: h,
          isDehydrated: d,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        ae.memoizedState = ne;
      }
      return mC(ae), G;
    }
    var cT = "18.2.0";
    function a7(i, o, d) {
      var h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Er(h), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: bi,
        key: h == null ? null : "" + h,
        children: i,
        containerInfo: o,
        implementation: d
      };
    }
    var uT, dT;
    uT = !1, dT = {};
    function QM(i) {
      if (!i)
        return as;
      var o = Ta(i), d = HU(o);
      if (o.tag === g) {
        var h = o.type;
        if (fc(h))
          return ER(o, h, d);
      }
      return d;
    }
    function s7(i, o) {
      {
        var d = Ta(i);
        if (d === void 0) {
          if (typeof i.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var h = Object.keys(i).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + h);
        }
        var b = Ra(d);
        if (b === null)
          return null;
        if (b.mode & Or) {
          var C = Ft(d) || "Component";
          if (!dT[C]) {
            dT[C] = !0;
            var R = gr;
            try {
              Nn(b), d.mode & Or ? c("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", o, o, C) : c("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", o, o, C);
            } finally {
              R ? Nn(R) : or();
            }
          }
        }
        return b.stateNode;
      }
    }
    function ZM(i, o, d, h, b, C, R, A) {
      var B = !1, V = null;
      return qM(i, o, B, V, d, h, b, C, R);
    }
    function JM(i, o, d, h, b, C, R, A, B, V) {
      var G = !0, ae = qM(d, h, G, i, b, C, R, A, B);
      ae.context = QM(null);
      var ne = ae.current, Ce = sa(), _e = Ld(ne), Ae = wu(Ce, _e);
      return Ae.callback = o ?? null, Id(ne, Ae, _e), hF(ae, _e, Ce), ae;
    }
    function xy(i, o, d, h) {
      g0(o, i);
      var b = o.current, C = sa(), R = Ld(b);
      Qc(R);
      var A = QM(d);
      o.context === null ? o.context = A : o.pendingContext = A, Fr && gr !== null && !uT && (uT = !0, c(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, Ft(gr) || "Unknown"));
      var B = wu(C, R);
      B.payload = {
        element: i
      }, h = h === void 0 ? null : h, h !== null && (typeof h != "function" && c("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", h), B.callback = h);
      var V = Id(b, B, R);
      return V !== null && (Vi(V, b, R, C), kS(V, b, R)), R;
    }
    function yw(i) {
      var o = i.current;
      if (!o.child)
        return null;
      switch (o.child.tag) {
        case x:
          return o.child.stateNode;
        default:
          return o.child.stateNode;
      }
    }
    function l7(i) {
      switch (i.tag) {
        case v: {
          var o = i.stateNode;
          if (di(o)) {
            var d = cE(o);
            yF(o, d);
          }
          break;
        }
        case z: {
          _u(function() {
            var b = ja(i, jt);
            if (b !== null) {
              var C = sa();
              Vi(b, i, jt, C);
            }
          });
          var h = jt;
          fT(i, h);
          break;
        }
      }
    }
    function eA(i, o) {
      var d = i.memoizedState;
      d !== null && d.dehydrated !== null && (d.retryLane = k0(d.retryLane, o));
    }
    function fT(i, o) {
      eA(i, o);
      var d = i.alternate;
      d && eA(d, o);
    }
    function c7(i) {
      if (i.tag === z) {
        var o = id, d = ja(i, o);
        if (d !== null) {
          var h = sa();
          Vi(d, i, o, h);
        }
        fT(i, o);
      }
    }
    function u7(i) {
      if (i.tag === z) {
        var o = Ld(i), d = ja(i, o);
        if (d !== null) {
          var h = sa();
          Vi(d, i, o, h);
        }
        fT(i, o);
      }
    }
    function tA(i) {
      var o = f0(i);
      return o === null ? null : o.stateNode;
    }
    var nA = function(i) {
      return null;
    };
    function d7(i) {
      return nA(i);
    }
    var rA = function(i) {
      return !1;
    };
    function f7(i) {
      return rA(i);
    }
    var iA = null, oA = null, aA = null, sA = null, lA = null, cA = null, uA = null, dA = null, fA = null;
    {
      var pA = function(i, o, d) {
        var h = o[d], b = Sn(i) ? i.slice() : Jt({}, i);
        return d + 1 === o.length ? (Sn(b) ? b.splice(h, 1) : delete b[h], b) : (b[h] = pA(i[h], o, d + 1), b);
      }, hA = function(i, o) {
        return pA(i, o, 0);
      }, gA = function(i, o, d, h) {
        var b = o[h], C = Sn(i) ? i.slice() : Jt({}, i);
        if (h + 1 === o.length) {
          var R = d[h];
          C[R] = C[b], Sn(C) ? C.splice(b, 1) : delete C[b];
        } else
          C[b] = gA(
            // $FlowFixMe number or string is fine here
            i[b],
            o,
            d,
            h + 1
          );
        return C;
      }, mA = function(i, o, d) {
        if (o.length !== d.length) {
          s("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var h = 0; h < d.length - 1; h++)
            if (o[h] !== d[h]) {
              s("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return gA(i, o, d, 0);
      }, vA = function(i, o, d, h) {
        if (d >= o.length)
          return h;
        var b = o[d], C = Sn(i) ? i.slice() : Jt({}, i);
        return C[b] = vA(i[b], o, d + 1, h), C;
      }, yA = function(i, o, d) {
        return vA(i, o, 0, d);
      }, pT = function(i, o) {
        for (var d = i.memoizedState; d !== null && o > 0; )
          d = d.next, o--;
        return d;
      };
      iA = function(i, o, d, h) {
        var b = pT(i, o);
        if (b !== null) {
          var C = yA(b.memoizedState, d, h);
          b.memoizedState = C, b.baseState = C, i.memoizedProps = Jt({}, i.memoizedProps);
          var R = ja(i, jt);
          R !== null && Vi(R, i, jt, lr);
        }
      }, oA = function(i, o, d) {
        var h = pT(i, o);
        if (h !== null) {
          var b = hA(h.memoizedState, d);
          h.memoizedState = b, h.baseState = b, i.memoizedProps = Jt({}, i.memoizedProps);
          var C = ja(i, jt);
          C !== null && Vi(C, i, jt, lr);
        }
      }, aA = function(i, o, d, h) {
        var b = pT(i, o);
        if (b !== null) {
          var C = mA(b.memoizedState, d, h);
          b.memoizedState = C, b.baseState = C, i.memoizedProps = Jt({}, i.memoizedProps);
          var R = ja(i, jt);
          R !== null && Vi(R, i, jt, lr);
        }
      }, sA = function(i, o, d) {
        i.pendingProps = yA(i.memoizedProps, o, d), i.alternate && (i.alternate.pendingProps = i.pendingProps);
        var h = ja(i, jt);
        h !== null && Vi(h, i, jt, lr);
      }, lA = function(i, o) {
        i.pendingProps = hA(i.memoizedProps, o), i.alternate && (i.alternate.pendingProps = i.pendingProps);
        var d = ja(i, jt);
        d !== null && Vi(d, i, jt, lr);
      }, cA = function(i, o, d) {
        i.pendingProps = mA(i.memoizedProps, o, d), i.alternate && (i.alternate.pendingProps = i.pendingProps);
        var h = ja(i, jt);
        h !== null && Vi(h, i, jt, lr);
      }, uA = function(i) {
        var o = ja(i, jt);
        o !== null && Vi(o, i, jt, lr);
      }, dA = function(i) {
        nA = i;
      }, fA = function(i) {
        rA = i;
      };
    }
    function p7(i) {
      var o = Ra(i);
      return o === null ? null : o.stateNode;
    }
    function h7(i) {
      return null;
    }
    function g7() {
      return gr;
    }
    function m7(i) {
      var o = i.findFiberByHostInstance, d = n.ReactCurrentDispatcher;
      return Xm({
        bundleType: i.bundleType,
        version: i.version,
        rendererPackageName: i.rendererPackageName,
        rendererConfig: i.rendererConfig,
        overrideHookState: iA,
        overrideHookStateDeletePath: oA,
        overrideHookStateRenamePath: aA,
        overrideProps: sA,
        overridePropsDeletePath: lA,
        overridePropsRenamePath: cA,
        setErrorHandler: dA,
        setSuspenseHandler: fA,
        scheduleUpdate: uA,
        currentDispatcherRef: d,
        findHostInstanceByFiber: p7,
        findFiberByHostInstance: o || h7,
        // React Refresh
        findHostInstancesForRefresh: KF,
        scheduleRefresh: VF,
        scheduleRoot: YF,
        setRefreshHandler: HF,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: g7,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: cT
      });
    }
    var bA = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(i) {
      console.error(i);
    };
    function hT(i) {
      this._internalRoot = i;
    }
    bw.prototype.render = hT.prototype.render = function(i) {
      var o = this._internalRoot;
      if (o === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? c("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : Sw(arguments[1]) ? c("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && c("You passed a second argument to root.render(...) but it only accepts one argument.");
        var d = o.containerInfo;
        if (d.nodeType !== ri) {
          var h = tA(o.current);
          h && h.parentNode !== d && c("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      xy(i, o, null, null);
    }, bw.prototype.unmount = hT.prototype.unmount = function() {
      typeof arguments[0] == "function" && c("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var i = this._internalRoot;
      if (i !== null) {
        this._internalRoot = null;
        var o = i.containerInfo;
        $M() && c("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), _u(function() {
          xy(null, i, null, null);
        }), yR(o);
      }
    };
    function v7(i, o) {
      if (!Sw(i))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      SA(i);
      var d = !1, h = !1, b = "", C = bA;
      o != null && (o.hydrate ? s("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof o == "object" && o !== null && o.$$typeof === xa && c(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), o.unstable_strictMode === !0 && (d = !0), o.identifierPrefix !== void 0 && (b = o.identifierPrefix), o.onRecoverableError !== void 0 && (C = o.onRecoverableError), o.transitionCallbacks !== void 0 && o.transitionCallbacks);
      var R = ZM(i, hS, null, d, h, b, C);
      sS(R.current, i);
      var A = i.nodeType === ri ? i.parentNode : i;
      return Rv(A), new hT(R);
    }
    function bw(i) {
      this._internalRoot = i;
    }
    function y7(i) {
      i && D0(i);
    }
    bw.prototype.unstable_scheduleHydration = y7;
    function b7(i, o, d) {
      if (!Sw(i))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      SA(i), o === void 0 && c("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var h = d ?? null, b = d != null && d.hydratedSources || null, C = !1, R = !1, A = "", B = bA;
      d != null && (d.unstable_strictMode === !0 && (C = !0), d.identifierPrefix !== void 0 && (A = d.identifierPrefix), d.onRecoverableError !== void 0 && (B = d.onRecoverableError));
      var V = JM(o, null, i, hS, h, C, R, A, B);
      if (sS(V.current, i), Rv(i), b)
        for (var G = 0; G < b.length; G++) {
          var ae = b[G];
          kB(V, ae);
        }
      return new bw(V);
    }
    function Sw(i) {
      return !!(i && (i.nodeType === $o || i.nodeType === ts || i.nodeType === Fc || !ce));
    }
    function Ey(i) {
      return !!(i && (i.nodeType === $o || i.nodeType === ts || i.nodeType === Fc || i.nodeType === ri && i.nodeValue === " react-mount-point-unstable "));
    }
    function SA(i) {
      i.nodeType === $o && i.tagName && i.tagName.toUpperCase() === "BODY" && c("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), Bv(i) && (i._reactRootContainer ? c("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : c("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var S7 = n.ReactCurrentOwner, wA;
    wA = function(i) {
      if (i._reactRootContainer && i.nodeType !== ri) {
        var o = tA(i._reactRootContainer.current);
        o && o.parentNode !== i && c("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var d = !!i._reactRootContainer, h = gT(i), b = !!(h && Cd(h));
      b && !d && c("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), i.nodeType === $o && i.tagName && i.tagName.toUpperCase() === "BODY" && c("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function gT(i) {
      return i ? i.nodeType === ts ? i.documentElement : i.firstChild : null;
    }
    function xA() {
    }
    function w7(i, o, d, h, b) {
      if (b) {
        if (typeof h == "function") {
          var C = h;
          h = function() {
            var ne = yw(R);
            C.call(ne);
          };
        }
        var R = JM(
          o,
          h,
          i,
          Td,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          xA
        );
        i._reactRootContainer = R, sS(R.current, i);
        var A = i.nodeType === ri ? i.parentNode : i;
        return Rv(A), _u(), R;
      } else {
        for (var B; B = i.lastChild; )
          i.removeChild(B);
        if (typeof h == "function") {
          var V = h;
          h = function() {
            var ne = yw(G);
            V.call(ne);
          };
        }
        var G = ZM(
          i,
          Td,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          xA
        );
        i._reactRootContainer = G, sS(G.current, i);
        var ae = i.nodeType === ri ? i.parentNode : i;
        return Rv(ae), _u(function() {
          xy(o, G, d, h);
        }), G;
      }
    }
    function x7(i, o) {
      i !== null && typeof i != "function" && c("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", o, i);
    }
    function ww(i, o, d, h, b) {
      wA(d), x7(b === void 0 ? null : b, "render");
      var C = d._reactRootContainer, R;
      if (!C)
        R = w7(d, o, i, b, h);
      else {
        if (R = C, typeof b == "function") {
          var A = b;
          b = function() {
            var B = yw(R);
            A.call(B);
          };
        }
        xy(o, R, i, b);
      }
      return yw(R);
    }
    function E7(i) {
      {
        var o = S7.current;
        if (o !== null && o.stateNode !== null) {
          var d = o.stateNode._warnedAboutRefsInRender;
          d || c("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", rn(o.type) || "A component"), o.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return i == null ? null : i.nodeType === $o ? i : s7(i, "findDOMNode");
    }
    function C7(i, o, d) {
      if (c("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Ey(o))
        throw new Error("Target container is not a DOM element.");
      {
        var h = Bv(o) && o._reactRootContainer === void 0;
        h && c("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return ww(null, i, o, !0, d);
    }
    function _7(i, o, d) {
      if (c("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Ey(o))
        throw new Error("Target container is not a DOM element.");
      {
        var h = Bv(o) && o._reactRootContainer === void 0;
        h && c("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return ww(null, i, o, !1, d);
    }
    function T7(i, o, d, h) {
      if (c("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !Ey(d))
        throw new Error("Target container is not a DOM element.");
      if (i == null || !If(i))
        throw new Error("parentComponent must be a valid React Component");
      return ww(i, o, d, !1, h);
    }
    function k7(i) {
      if (!Ey(i))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var o = Bv(i) && i._reactRootContainer === void 0;
        o && c("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (i._reactRootContainer) {
        {
          var d = gT(i), h = d && !Cd(d);
          h && c("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return _u(function() {
          ww(null, null, i, !1, function() {
            i._reactRootContainer = null, yR(i);
          });
        }), !0;
      } else {
        {
          var b = gT(i), C = !!(b && Cd(b)), R = i.nodeType === $o && Ey(i.parentNode) && !!i.parentNode._reactRootContainer;
          C && c("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", R ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    ft(l7), I0(c7), Vf(u7), fv(Aa), $0(Bf), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && c("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), c0(R6), eh(K_, bF, _u);
    function P7(i, o) {
      var d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!Sw(o))
        throw new Error("Target container is not a DOM element.");
      return a7(i, o, null, d);
    }
    function I7(i, o, d, h) {
      return T7(i, o, d, h);
    }
    var mT = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [Cd, ng, lS, Jp, Tf, K_]
    };
    function R7(i, o) {
      return mT.usingClientEntryPoint || c('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), v7(i, o);
    }
    function $7(i, o, d) {
      return mT.usingClientEntryPoint || c('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), b7(i, o, d);
    }
    function M7(i) {
      return $M() && c("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), _u(i);
    }
    var A7 = m7({
      findFiberByHostInstance: ep,
      bundleType: 1,
      version: cT,
      rendererPackageName: "react-dom"
    });
    if (!A7 && Nt && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var EA = window.location.protocol;
      /^(https?|file):$/.test(EA) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (EA === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    Va.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = mT, Va.createPortal = P7, Va.createRoot = R7, Va.findDOMNode = E7, Va.flushSync = M7, Va.hydrate = C7, Va.hydrateRoot = $7, Va.render = _7, Va.unmountComponentAtNode = k7, Va.unstable_batchedUpdates = K_, Va.unstable_renderSubtreeIntoContainer = I7, Va.version = cT, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Va;
}
function Vj() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if ({}.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Vj);
    } catch (t) {
      console.error(t);
    }
  }
}
({}).NODE_ENV === "production" ? (Vj(), vP.exports = Cie()) : vP.exports = _ie();
var pm = vP.exports;
const Tie = /* @__PURE__ */ jp(pm);
function _t(t, e, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(a) {
    if (t?.(a), n === !1 || !a.defaultPrevented)
      return e?.(a);
  };
}
function kie(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function x1(...t) {
  return (e) => t.forEach(
    (n) => kie(n, e)
  );
}
function Rr(...t) {
  return k.useCallback(x1(...t), t);
}
function Nc(t, e = []) {
  let n = [];
  function r(s, c) {
    const f = /* @__PURE__ */ k.createContext(c), p = n.length;
    n = [
      ...n,
      c
    ];
    function g(v) {
      const { scope: S, children: x, ..._ } = v, T = S?.[t][p] || f, I = k.useMemo(
        () => _,
        Object.values(_)
      );
      return /* @__PURE__ */ k.createElement(T.Provider, {
        value: I
      }, x);
    }
    function y(v, S) {
      const x = S?.[t][p] || f, _ = k.useContext(x);
      if (_)
        return _;
      if (c !== void 0)
        return c;
      throw new Error(`\`${v}\` must be used within \`${s}\``);
    }
    return g.displayName = s + "Provider", [
      g,
      y
    ];
  }
  const a = () => {
    const s = n.map((c) => /* @__PURE__ */ k.createContext(c));
    return function(f) {
      const p = f?.[t] || s;
      return k.useMemo(
        () => ({
          [`__scope${t}`]: {
            ...f,
            [t]: p
          }
        }),
        [
          f,
          p
        ]
      );
    };
  };
  return a.scopeName = t, [
    r,
    Pie(a, ...e)
  ];
}
function Pie(...t) {
  const e = t[0];
  if (t.length === 1)
    return e;
  const n = () => {
    const r = t.map(
      (a) => ({
        useScope: a(),
        scopeName: a.scopeName
      })
    );
    return function(s) {
      const c = r.reduce((f, { useScope: p, scopeName: g }) => {
        const v = p(s)[`__scope${g}`];
        return {
          ...f,
          ...v
        };
      }, {});
      return k.useMemo(
        () => ({
          [`__scope${e.scopeName}`]: c
        }),
        [
          c
        ]
      );
    };
  };
  return n.scopeName = e.scopeName, n;
}
const Op = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { children: n, ...r } = t, a = k.Children.toArray(n), s = a.find(Rie);
  if (s) {
    const c = s.props.children, f = a.map((p) => p === s ? k.Children.count(c) > 1 ? k.Children.only(null) : /* @__PURE__ */ k.isValidElement(c) ? c.props.children : null : p);
    return /* @__PURE__ */ k.createElement(yP, qe({}, r, {
      ref: e
    }), /* @__PURE__ */ k.isValidElement(c) ? /* @__PURE__ */ k.cloneElement(c, void 0, f) : null);
  }
  return /* @__PURE__ */ k.createElement(yP, qe({}, r, {
    ref: e
  }), n);
});
Op.displayName = "Slot";
const yP = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { children: n, ...r } = t;
  return /* @__PURE__ */ k.isValidElement(n) ? /* @__PURE__ */ k.cloneElement(n, {
    ...$ie(r, n.props),
    ref: e ? x1(e, n.ref) : n.ref
  }) : k.Children.count(n) > 1 ? k.Children.only(null) : null;
});
yP.displayName = "SlotClone";
const Iie = ({ children: t }) => /* @__PURE__ */ k.createElement(k.Fragment, null, t);
function Rie(t) {
  return /* @__PURE__ */ k.isValidElement(t) && t.type === Iie;
}
function $ie(t, e) {
  const n = {
    ...e
  };
  for (const r in e) {
    const a = t[r], s = e[r];
    /^on[A-Z]/.test(r) ? a && s ? n[r] = (...f) => {
      s(...f), a(...f);
    } : a && (n[r] = a) : r === "style" ? n[r] = {
      ...a,
      ...s
    } : r === "className" && (n[r] = [
      a,
      s
    ].filter(Boolean).join(" "));
  }
  return {
    ...t,
    ...n
  };
}
function E1(t) {
  const e = t + "CollectionProvider", [n, r] = Nc(e), [a, s] = n(e, {
    collectionRef: {
      current: null
    },
    itemMap: /* @__PURE__ */ new Map()
  }), c = (x) => {
    const { scope: _, children: T } = x, I = It.useRef(null), D = It.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ It.createElement(a, {
      scope: _,
      itemMap: D,
      collectionRef: I
    }, T);
  }, f = t + "CollectionSlot", p = /* @__PURE__ */ It.forwardRef((x, _) => {
    const { scope: T, children: I } = x, D = s(f, T), N = Rr(_, D.collectionRef);
    return /* @__PURE__ */ It.createElement(Op, {
      ref: N
    }, I);
  }), g = t + "CollectionItemSlot", y = "data-radix-collection-item", v = /* @__PURE__ */ It.forwardRef((x, _) => {
    const { scope: T, children: I, ...D } = x, N = It.useRef(null), j = Rr(_, N), L = s(g, T);
    return It.useEffect(() => (L.itemMap.set(N, {
      ref: N,
      ...D
    }), () => void L.itemMap.delete(N))), /* @__PURE__ */ It.createElement(Op, {
      [y]: "",
      ref: j
    }, I);
  });
  function S(x) {
    const _ = s(t + "CollectionConsumer", x);
    return It.useCallback(() => {
      const I = _.collectionRef.current;
      if (!I)
        return [];
      const D = Array.from(I.querySelectorAll(`[${y}]`));
      return Array.from(_.itemMap.values()).sort(
        (L, z) => D.indexOf(L.ref.current) - D.indexOf(z.ref.current)
      );
    }, [
      _.collectionRef,
      _.itemMap
    ]);
  }
  return [
    {
      Provider: c,
      Slot: p,
      ItemSlot: v
    },
    S,
    r
  ];
}
const Mie = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], pr = Mie.reduce((t, e) => {
  const n = /* @__PURE__ */ k.forwardRef((r, a) => {
    const { asChild: s, ...c } = r, f = s ? Op : e;
    return k.useEffect(() => {
      window[Symbol.for("radix-ui")] = !0;
    }, []), /* @__PURE__ */ k.createElement(f, qe({}, c, {
      ref: a
    }));
  });
  return n.displayName = `Primitive.${e}`, {
    ...t,
    [e]: n
  };
}, {});
function QI(t, e) {
  t && pm.flushSync(
    () => t.dispatchEvent(e)
  );
}
function Wo(t) {
  const e = k.useRef(t);
  return k.useEffect(() => {
    e.current = t;
  }), k.useMemo(
    () => (...n) => {
      var r;
      return (r = e.current) === null || r === void 0 ? void 0 : r.call(e, ...n);
    },
    []
  );
}
function Aie(t, e = globalThis?.document) {
  const n = Wo(t);
  k.useEffect(() => {
    const r = (a) => {
      a.key === "Escape" && n(a);
    };
    return e.addEventListener("keydown", r), () => e.removeEventListener("keydown", r);
  }, [
    n,
    e
  ]);
}
const bP = "dismissableLayer.update", Oie = "dismissableLayer.pointerDownOutside", Die = "dismissableLayer.focusOutside";
let eN;
const Yj = /* @__PURE__ */ k.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), C1 = /* @__PURE__ */ k.forwardRef((t, e) => {
  var n;
  const { disableOutsidePointerEvents: r = !1, onEscapeKeyDown: a, onPointerDownOutside: s, onFocusOutside: c, onInteractOutside: f, onDismiss: p, ...g } = t, y = k.useContext(Yj), [v, S] = k.useState(null), x = (n = v?.ownerDocument) !== null && n !== void 0 ? n : globalThis?.document, [, _] = k.useState({}), T = Rr(
    e,
    (X) => S(X)
  ), I = Array.from(y.layers), [D] = [
    ...y.layersWithOutsidePointerEventsDisabled
  ].slice(-1), N = I.indexOf(D), j = v ? I.indexOf(v) : -1, L = y.layersWithOutsidePointerEventsDisabled.size > 0, z = j >= N, F = Lie((X) => {
    const se = X.target, ue = [
      ...y.branches
    ].some(
      (pe) => pe.contains(se)
    );
    !z || ue || (s?.(X), f?.(X), X.defaultPrevented || p?.());
  }, x), K = jie((X) => {
    const se = X.target;
    [
      ...y.branches
    ].some(
      (pe) => pe.contains(se)
    ) || (c?.(X), f?.(X), X.defaultPrevented || p?.());
  }, x);
  return Aie((X) => {
    j === y.layers.size - 1 && (a?.(X), !X.defaultPrevented && p && (X.preventDefault(), p()));
  }, x), k.useEffect(() => {
    if (v)
      return r && (y.layersWithOutsidePointerEventsDisabled.size === 0 && (eN = x.body.style.pointerEvents, x.body.style.pointerEvents = "none"), y.layersWithOutsidePointerEventsDisabled.add(v)), y.layers.add(v), tN(), () => {
        r && y.layersWithOutsidePointerEventsDisabled.size === 1 && (x.body.style.pointerEvents = eN);
      };
  }, [
    v,
    x,
    r,
    y
  ]), k.useEffect(() => () => {
    v && (y.layers.delete(v), y.layersWithOutsidePointerEventsDisabled.delete(v), tN());
  }, [
    v,
    y
  ]), k.useEffect(() => {
    const X = () => _({});
    return document.addEventListener(bP, X), () => document.removeEventListener(bP, X);
  }, []), /* @__PURE__ */ k.createElement(pr.div, qe({}, g, {
    ref: T,
    style: {
      pointerEvents: L ? z ? "auto" : "none" : void 0,
      ...t.style
    },
    onFocusCapture: _t(t.onFocusCapture, K.onFocusCapture),
    onBlurCapture: _t(t.onBlurCapture, K.onBlurCapture),
    onPointerDownCapture: _t(t.onPointerDownCapture, F.onPointerDownCapture)
  }));
}), Nie = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = k.useContext(Yj), r = k.useRef(null), a = Rr(e, r);
  return k.useEffect(() => {
    const s = r.current;
    if (s)
      return n.branches.add(s), () => {
        n.branches.delete(s);
      };
  }, [
    n.branches
  ]), /* @__PURE__ */ k.createElement(pr.div, qe({}, t, {
    ref: a
  }));
});
function Lie(t, e = globalThis?.document) {
  const n = Wo(t), r = k.useRef(!1), a = k.useRef(() => {
  });
  return k.useEffect(() => {
    const s = (f) => {
      if (f.target && !r.current) {
        let y = function() {
          Kj(Oie, n, g, {
            discrete: !0
          });
        };
        var p = y;
        const g = {
          originalEvent: f
        };
        f.pointerType === "touch" ? (e.removeEventListener("click", a.current), a.current = y, e.addEventListener("click", a.current, {
          once: !0
        })) : y();
      }
      r.current = !1;
    }, c = window.setTimeout(() => {
      e.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(c), e.removeEventListener("pointerdown", s), e.removeEventListener("click", a.current);
    };
  }, [
    e,
    n
  ]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function jie(t, e = globalThis?.document) {
  const n = Wo(t), r = k.useRef(!1);
  return k.useEffect(() => {
    const a = (s) => {
      s.target && !r.current && Kj(Die, n, {
        originalEvent: s
      }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", a), () => e.removeEventListener("focusin", a);
  }, [
    e,
    n
  ]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function tN() {
  const t = new CustomEvent(bP);
  document.dispatchEvent(t);
}
function Kj(t, e, n, { discrete: r }) {
  const a = n.originalEvent.target, s = new CustomEvent(t, {
    bubbles: !1,
    cancelable: !0,
    detail: n
  });
  e && a.addEventListener(t, e, {
    once: !0
  }), r ? QI(a, s) : a.dispatchEvent(s);
}
const zie = C1, Uie = Nie, _1 = /* @__PURE__ */ k.forwardRef((t, e) => {
  var n;
  const { container: r = globalThis == null || (n = globalThis.document) === null || n === void 0 ? void 0 : n.body, ...a } = t;
  return r ? /* @__PURE__ */ Tie.createPortal(/* @__PURE__ */ k.createElement(pr.div, qe({}, a, {
    ref: e
  })), r) : null;
}), Dp = globalThis?.document ? k.useLayoutEffect : () => {
};
function Bie(t, e) {
  return k.useReducer((n, r) => {
    const a = e[n][r];
    return a ?? n;
  }, t);
}
const Nl = (t) => {
  const { present: e, children: n } = t, r = Fie(e), a = typeof n == "function" ? n({
    present: r.isPresent
  }) : k.Children.only(n), s = Rr(r.ref, a.ref);
  return typeof n == "function" || r.isPresent ? /* @__PURE__ */ k.cloneElement(a, {
    ref: s
  }) : null;
};
Nl.displayName = "Presence";
function Fie(t) {
  const [e, n] = k.useState(), r = k.useRef({}), a = k.useRef(t), s = k.useRef("none"), c = t ? "mounted" : "unmounted", [f, p] = Bie(c, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return k.useEffect(() => {
    const g = Kw(r.current);
    s.current = f === "mounted" ? g : "none";
  }, [
    f
  ]), Dp(() => {
    const g = r.current, y = a.current;
    if (y !== t) {
      const S = s.current, x = Kw(g);
      t ? p("MOUNT") : x === "none" || g?.display === "none" ? p("UNMOUNT") : p(y && S !== x ? "ANIMATION_OUT" : "UNMOUNT"), a.current = t;
    }
  }, [
    t,
    p
  ]), Dp(() => {
    if (e) {
      const g = (v) => {
        const x = Kw(r.current).includes(v.animationName);
        v.target === e && x && pm.flushSync(
          () => p("ANIMATION_END")
        );
      }, y = (v) => {
        v.target === e && (s.current = Kw(r.current));
      };
      return e.addEventListener("animationstart", y), e.addEventListener("animationcancel", g), e.addEventListener("animationend", g), () => {
        e.removeEventListener("animationstart", y), e.removeEventListener("animationcancel", g), e.removeEventListener("animationend", g);
      };
    } else
      p("ANIMATION_END");
  }, [
    e,
    p
  ]), {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(f),
    ref: k.useCallback((g) => {
      g && (r.current = getComputedStyle(g)), n(g);
    }, [])
  };
}
function Kw(t) {
  return t?.animationName || "none";
}
function ff({ prop: t, defaultProp: e, onChange: n = () => {
} }) {
  const [r, a] = Hie({
    defaultProp: e,
    onChange: n
  }), s = t !== void 0, c = s ? t : r, f = Wo(n), p = k.useCallback((g) => {
    if (s) {
      const v = typeof g == "function" ? g(t) : g;
      v !== t && f(v);
    } else
      a(g);
  }, [
    s,
    t,
    a,
    f
  ]);
  return [
    c,
    p
  ];
}
function Hie({ defaultProp: t, onChange: e }) {
  const n = k.useState(t), [r] = n, a = k.useRef(r), s = Wo(e);
  return k.useEffect(() => {
    a.current !== r && (s(r), a.current = r);
  }, [
    r,
    a,
    s
  ]), n;
}
const Wj = /* @__PURE__ */ k.forwardRef((t, e) => /* @__PURE__ */ k.createElement(pr.span, qe({}, t, {
  ref: e,
  style: {
    // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal",
    ...t.style
  }
}))), Gj = "ToastProvider", [ZI, Vie, Yie] = E1("Toast"), [Xj, Qpe] = Nc("Toast", [
  Yie
]), [Kie, T1] = Xj(Gj), qj = (t) => {
  const { __scopeToast: e, label: n = "Notification", duration: r = 5e3, swipeDirection: a = "right", swipeThreshold: s = 50, children: c } = t, [f, p] = k.useState(null), [g, y] = k.useState(0), v = k.useRef(!1), S = k.useRef(!1);
  return /* @__PURE__ */ k.createElement(ZI.Provider, {
    scope: e
  }, /* @__PURE__ */ k.createElement(Kie, {
    scope: e,
    label: n,
    duration: r,
    swipeDirection: a,
    swipeThreshold: s,
    toastCount: g,
    viewport: f,
    onViewportChange: p,
    onToastAdd: k.useCallback(
      () => y(
        (x) => x + 1
      ),
      []
    ),
    onToastRemove: k.useCallback(
      () => y(
        (x) => x - 1
      ),
      []
    ),
    isFocusedToastEscapeKeyDownRef: v,
    isClosePausedRef: S
  }, c));
};
qj.propTypes = {
  label(t) {
    if (t.label && typeof t.label == "string" && !t.label.trim()) {
      const e = `Invalid prop \`label\` supplied to \`${Gj}\`. Expected non-empty \`string\`.`;
      return new Error(e);
    }
    return null;
  }
};
const Wie = "ToastViewport", Gie = [
  "F8"
], SP = "toast.viewportPause", wP = "toast.viewportResume", Xie = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeToast: n, hotkey: r = Gie, label: a = "Notifications ({hotkey})", ...s } = t, c = T1(Wie, n), f = Vie(n), p = k.useRef(null), g = k.useRef(null), y = k.useRef(null), v = k.useRef(null), S = Rr(e, v, c.onViewportChange), x = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), _ = c.toastCount > 0;
  k.useEffect(() => {
    const I = (D) => {
      var N;
      r.every(
        (L) => D[L] || D.code === L
      ) && ((N = v.current) === null || N === void 0 || N.focus());
    };
    return document.addEventListener("keydown", I), () => document.removeEventListener("keydown", I);
  }, [
    r
  ]), k.useEffect(() => {
    const I = p.current, D = v.current;
    if (_ && I && D) {
      const N = () => {
        if (!c.isClosePausedRef.current) {
          const F = new CustomEvent(SP);
          D.dispatchEvent(F), c.isClosePausedRef.current = !0;
        }
      }, j = () => {
        if (c.isClosePausedRef.current) {
          const F = new CustomEvent(wP);
          D.dispatchEvent(F), c.isClosePausedRef.current = !1;
        }
      }, L = (F) => {
        !I.contains(F.relatedTarget) && j();
      }, z = () => {
        I.contains(document.activeElement) || j();
      };
      return I.addEventListener("focusin", N), I.addEventListener("focusout", L), I.addEventListener("pointermove", N), I.addEventListener("pointerleave", z), window.addEventListener("blur", N), window.addEventListener("focus", j), () => {
        I.removeEventListener("focusin", N), I.removeEventListener("focusout", L), I.removeEventListener("pointermove", N), I.removeEventListener("pointerleave", z), window.removeEventListener("blur", N), window.removeEventListener("focus", j);
      };
    }
  }, [
    _,
    c.isClosePausedRef
  ]);
  const T = k.useCallback(({ tabbingDirection: I }) => {
    const N = f().map((j) => {
      const L = j.ref.current, z = [
        L,
        ...doe(L)
      ];
      return I === "forwards" ? z : z.reverse();
    });
    return (I === "forwards" ? N.reverse() : N).flat();
  }, [
    f
  ]);
  return k.useEffect(() => {
    const I = v.current;
    if (I) {
      const D = (N) => {
        const j = N.altKey || N.ctrlKey || N.metaKey;
        if (N.key === "Tab" && !j) {
          const X = document.activeElement, se = N.shiftKey;
          if (N.target === I && se) {
            var z;
            (z = g.current) === null || z === void 0 || z.focus();
            return;
          }
          const Pe = T({
            tabbingDirection: se ? "backwards" : "forwards"
          }), ve = Pe.findIndex(
            (Y) => Y === X
          );
          if (yk(Pe.slice(ve + 1)))
            N.preventDefault();
          else {
            var F, K;
            se ? (F = g.current) === null || F === void 0 || F.focus() : (K = y.current) === null || K === void 0 || K.focus();
          }
        }
      };
      return I.addEventListener("keydown", D), () => I.removeEventListener("keydown", D);
    }
  }, [
    f,
    T
  ]), /* @__PURE__ */ k.createElement(Uie, {
    ref: p,
    role: "region",
    "aria-label": a.replace("{hotkey}", x),
    tabIndex: -1,
    style: {
      pointerEvents: _ ? void 0 : "none"
    }
  }, _ && /* @__PURE__ */ k.createElement(nN, {
    ref: g,
    onFocusFromOutsideViewport: () => {
      const I = T({
        tabbingDirection: "forwards"
      });
      yk(I);
    }
  }), /* @__PURE__ */ k.createElement(ZI.Slot, {
    scope: n
  }, /* @__PURE__ */ k.createElement(pr.ol, qe({
    tabIndex: -1
  }, s, {
    ref: S
  }))), _ && /* @__PURE__ */ k.createElement(nN, {
    ref: y,
    onFocusFromOutsideViewport: () => {
      const I = T({
        tabbingDirection: "backwards"
      });
      yk(I);
    }
  }));
}), qie = "ToastFocusProxy", nN = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeToast: n, onFocusFromOutsideViewport: r, ...a } = t, s = T1(qie, n);
  return /* @__PURE__ */ k.createElement(Wj, qe({
    "aria-hidden": !0,
    tabIndex: 0
  }, a, {
    ref: e,
    style: {
      position: "fixed"
    },
    onFocus: (c) => {
      var f;
      const p = c.relatedTarget;
      !((f = s.viewport) !== null && f !== void 0 && f.contains(p)) && r();
    }
  }));
}), k1 = "Toast", Qie = "toast.swipeStart", Zie = "toast.swipeMove", Jie = "toast.swipeCancel", eoe = "toast.swipeEnd", toe = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { forceMount: n, open: r, defaultOpen: a, onOpenChange: s, ...c } = t, [f = !0, p] = ff({
    prop: r,
    defaultProp: a,
    onChange: s
  });
  return /* @__PURE__ */ k.createElement(Nl, {
    present: n || f
  }, /* @__PURE__ */ k.createElement(Qj, qe({
    open: f
  }, c, {
    ref: e,
    onClose: () => p(!1),
    onPause: Wo(t.onPause),
    onResume: Wo(t.onResume),
    onSwipeStart: _t(t.onSwipeStart, (g) => {
      g.currentTarget.setAttribute("data-swipe", "start");
    }),
    onSwipeMove: _t(t.onSwipeMove, (g) => {
      const { x: y, y: v } = g.detail.delta;
      g.currentTarget.setAttribute("data-swipe", "move"), g.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${y}px`), g.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${v}px`);
    }),
    onSwipeCancel: _t(t.onSwipeCancel, (g) => {
      g.currentTarget.setAttribute("data-swipe", "cancel"), g.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), g.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), g.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), g.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
    }),
    onSwipeEnd: _t(t.onSwipeEnd, (g) => {
      const { x: y, y: v } = g.detail.delta;
      g.currentTarget.setAttribute("data-swipe", "end"), g.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), g.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), g.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${y}px`), g.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${v}px`), p(!1);
    })
  })));
}), [noe, roe] = Xj(k1, {
  onClose() {
  }
}), Qj = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeToast: n, type: r = "foreground", duration: a, open: s, onClose: c, onEscapeKeyDown: f, onPause: p, onResume: g, onSwipeStart: y, onSwipeMove: v, onSwipeCancel: S, onSwipeEnd: x, ..._ } = t, T = T1(k1, n), [I, D] = k.useState(null), N = Rr(
    e,
    (Y) => D(Y)
  ), j = k.useRef(null), L = k.useRef(null), z = a || T.duration, F = k.useRef(0), K = k.useRef(z), X = k.useRef(0), { onToastAdd: se, onToastRemove: ue } = T, pe = Wo(() => {
    var Y;
    I?.contains(document.activeElement) && ((Y = T.viewport) === null || Y === void 0 || Y.focus()), c();
  }), Pe = k.useCallback((Y) => {
    !Y || Y === 1 / 0 || (window.clearTimeout(X.current), F.current = (/* @__PURE__ */ new Date()).getTime(), X.current = window.setTimeout(pe, Y));
  }, [
    pe
  ]);
  k.useEffect(() => {
    const Y = T.viewport;
    if (Y) {
      const le = () => {
        Pe(K.current), g?.();
      }, Re = () => {
        const he = (/* @__PURE__ */ new Date()).getTime() - F.current;
        K.current = K.current - he, window.clearTimeout(X.current), p?.();
      };
      return Y.addEventListener(SP, Re), Y.addEventListener(wP, le), () => {
        Y.removeEventListener(SP, Re), Y.removeEventListener(wP, le);
      };
    }
  }, [
    T.viewport,
    z,
    p,
    g,
    Pe
  ]), k.useEffect(() => {
    s && !T.isClosePausedRef.current && Pe(z);
  }, [
    s,
    z,
    T.isClosePausedRef,
    Pe
  ]), k.useEffect(() => (se(), () => ue()), [
    se,
    ue
  ]);
  const ve = k.useMemo(() => I ? tz(I) : null, [
    I
  ]);
  return T.viewport ? /* @__PURE__ */ k.createElement(k.Fragment, null, ve && /* @__PURE__ */ k.createElement(ioe, {
    __scopeToast: n,
    role: "status",
    "aria-live": r === "foreground" ? "assertive" : "polite",
    "aria-atomic": !0
  }, ve), /* @__PURE__ */ k.createElement(noe, {
    scope: n,
    onClose: pe
  }, /* @__PURE__ */ pm.createPortal(/* @__PURE__ */ k.createElement(ZI.ItemSlot, {
    scope: n
  }, /* @__PURE__ */ k.createElement(zie, {
    asChild: !0,
    onEscapeKeyDown: _t(f, () => {
      T.isFocusedToastEscapeKeyDownRef.current || pe(), T.isFocusedToastEscapeKeyDownRef.current = !1;
    })
  }, /* @__PURE__ */ k.createElement(pr.li, qe({
    // Ensure toasts are announced as status list or status when focused
    role: "status",
    "aria-live": "off",
    "aria-atomic": !0,
    tabIndex: 0,
    "data-state": s ? "open" : "closed",
    "data-swipe-direction": T.swipeDirection
  }, _, {
    ref: N,
    style: {
      userSelect: "none",
      touchAction: "none",
      ...t.style
    },
    onKeyDown: _t(t.onKeyDown, (Y) => {
      Y.key === "Escape" && (f?.(Y.nativeEvent), Y.nativeEvent.defaultPrevented || (T.isFocusedToastEscapeKeyDownRef.current = !0, pe()));
    }),
    onPointerDown: _t(t.onPointerDown, (Y) => {
      Y.button === 0 && (j.current = {
        x: Y.clientX,
        y: Y.clientY
      });
    }),
    onPointerMove: _t(t.onPointerMove, (Y) => {
      if (!j.current)
        return;
      const le = Y.clientX - j.current.x, Re = Y.clientY - j.current.y, he = !!L.current, te = [
        "left",
        "right"
      ].includes(T.swipeDirection), de = [
        "left",
        "up"
      ].includes(T.swipeDirection) ? Math.min : Math.max, W = te ? de(0, le) : 0, fe = te ? 0 : de(0, Re), ce = Y.pointerType === "touch" ? 10 : 2, xe = {
        x: W,
        y: fe
      }, $e = {
        originalEvent: Y,
        delta: xe
      };
      he ? (L.current = xe, Ww(Zie, v, $e, {
        discrete: !1
      })) : rN(xe, T.swipeDirection, ce) ? (L.current = xe, Ww(Qie, y, $e, {
        discrete: !1
      }), Y.target.setPointerCapture(Y.pointerId)) : (Math.abs(le) > ce || Math.abs(Re) > ce) && (j.current = null);
    }),
    onPointerUp: _t(t.onPointerUp, (Y) => {
      const le = L.current, Re = Y.target;
      if (Re.hasPointerCapture(Y.pointerId) && Re.releasePointerCapture(Y.pointerId), L.current = null, j.current = null, le) {
        const he = Y.currentTarget, te = {
          originalEvent: Y,
          delta: le
        };
        rN(le, T.swipeDirection, T.swipeThreshold) ? Ww(eoe, x, te, {
          discrete: !0
        }) : Ww(Jie, S, te, {
          discrete: !0
        }), he.addEventListener(
          "click",
          (de) => de.preventDefault(),
          {
            once: !0
          }
        );
      }
    })
  })))), T.viewport))) : null;
});
Qj.propTypes = {
  type(t) {
    if (t.type && ![
      "foreground",
      "background"
    ].includes(t.type)) {
      const e = `Invalid prop \`type\` supplied to \`${k1}\`. Expected \`foreground | background\`.`;
      return new Error(e);
    }
    return null;
  }
};
const ioe = (t) => {
  const { __scopeToast: e, children: n, ...r } = t, a = T1(k1, e), [s, c] = k.useState(!1), [f, p] = k.useState(!1);
  return coe(
    () => c(!0)
  ), k.useEffect(() => {
    const g = window.setTimeout(
      () => p(!0),
      1e3
    );
    return () => window.clearTimeout(g);
  }, []), f ? null : /* @__PURE__ */ k.createElement(_1, {
    asChild: !0
  }, /* @__PURE__ */ k.createElement(Wj, r, s && /* @__PURE__ */ k.createElement(k.Fragment, null, a.label, " ", n)));
}, ooe = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeToast: n, ...r } = t;
  return /* @__PURE__ */ k.createElement(pr.div, qe({}, r, {
    ref: e
  }));
}), aoe = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeToast: n, ...r } = t;
  return /* @__PURE__ */ k.createElement(pr.div, qe({}, r, {
    ref: e
  }));
}), soe = "ToastAction", Zj = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { altText: n, ...r } = t;
  return n ? /* @__PURE__ */ k.createElement(ez, {
    altText: n,
    asChild: !0
  }, /* @__PURE__ */ k.createElement(Jj, qe({}, r, {
    ref: e
  }))) : null;
});
Zj.propTypes = {
  altText(t) {
    return t.altText ? null : new Error(`Missing prop \`altText\` expected on \`${soe}\``);
  }
};
const loe = "ToastClose", Jj = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeToast: n, ...r } = t, a = roe(loe, n);
  return /* @__PURE__ */ k.createElement(ez, {
    asChild: !0
  }, /* @__PURE__ */ k.createElement(pr.button, qe({
    type: "button"
  }, r, {
    ref: e,
    onClick: _t(t.onClick, a.onClose)
  })));
}), ez = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeToast: n, altText: r, ...a } = t;
  return /* @__PURE__ */ k.createElement(pr.div, qe({
    "data-radix-toast-announce-exclude": "",
    "data-radix-toast-announce-alt": r || void 0
  }, a, {
    ref: e
  }));
});
function tz(t) {
  const e = [];
  return Array.from(t.childNodes).forEach((r) => {
    if (r.nodeType === r.TEXT_NODE && r.textContent && e.push(r.textContent), uoe(r)) {
      const a = r.ariaHidden || r.hidden || r.style.display === "none", s = r.dataset.radixToastAnnounceExclude === "";
      if (!a)
        if (s) {
          const c = r.dataset.radixToastAnnounceAlt;
          c && e.push(c);
        } else
          e.push(...tz(r));
    }
  }), e;
}
function Ww(t, e, n, { discrete: r }) {
  const a = n.originalEvent.currentTarget, s = new CustomEvent(t, {
    bubbles: !0,
    cancelable: !0,
    detail: n
  });
  e && a.addEventListener(t, e, {
    once: !0
  }), r ? QI(a, s) : a.dispatchEvent(s);
}
const rN = (t, e, n = 0) => {
  const r = Math.abs(t.x), a = Math.abs(t.y), s = r > a;
  return e === "left" || e === "right" ? s && r > n : !s && a > n;
};
function coe(t = () => {
}) {
  const e = Wo(t);
  Dp(() => {
    let n = 0, r = 0;
    return n = window.requestAnimationFrame(
      () => r = window.requestAnimationFrame(e)
    ), () => {
      window.cancelAnimationFrame(n), window.cancelAnimationFrame(r);
    };
  }, [
    e
  ]);
}
function uoe(t) {
  return t.nodeType === t.ELEMENT_NODE;
}
function doe(t) {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const a = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || a ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); )
    e.push(n.currentNode);
  return e;
}
function yk(t) {
  const e = document.activeElement;
  return t.some((n) => n === e ? !0 : (n.focus(), document.activeElement !== e));
}
const foe = toe, poe = ooe, hoe = aoe, goe = Zj, iN = Jj, moe = /* @__PURE__ */ k.createContext(void 0);
function JI(t) {
  const e = k.useContext(moe);
  return t || e || "ltr";
}
let bk = 0;
function e2() {
  k.useEffect(() => {
    var t, e;
    const n = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", (t = n[0]) !== null && t !== void 0 ? t : oN()), document.body.insertAdjacentElement("beforeend", (e = n[1]) !== null && e !== void 0 ? e : oN()), bk++, () => {
      bk === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(
        (r) => r.remove()
      ), bk--;
    };
  }, []);
}
function oN() {
  const t = document.createElement("span");
  return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", t;
}
const Sk = "focusScope.autoFocusOnMount", wk = "focusScope.autoFocusOnUnmount", aN = {
  bubbles: !1,
  cancelable: !0
}, t2 = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { loop: n = !1, trapped: r = !1, onMountAutoFocus: a, onUnmountAutoFocus: s, ...c } = t, [f, p] = k.useState(null), g = Wo(a), y = Wo(s), v = k.useRef(null), S = Rr(
    e,
    (T) => p(T)
  ), x = k.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  k.useEffect(() => {
    if (r) {
      let N = function(F) {
        if (x.paused || !f)
          return;
        const K = F.target;
        f.contains(K) ? v.current = K : Fd(v.current, {
          select: !0
        });
      }, j = function(F) {
        if (x.paused || !f)
          return;
        const K = F.relatedTarget;
        K !== null && (f.contains(K) || Fd(v.current, {
          select: !0
        }));
      }, L = function(F) {
        const K = document.activeElement;
        for (const X of F)
          X.removedNodes.length > 0 && (f != null && f.contains(K) || Fd(f));
      };
      var T = N, I = j, D = L;
      document.addEventListener("focusin", N), document.addEventListener("focusout", j);
      const z = new MutationObserver(L);
      return f && z.observe(f, {
        childList: !0,
        subtree: !0
      }), () => {
        document.removeEventListener("focusin", N), document.removeEventListener("focusout", j), z.disconnect();
      };
    }
  }, [
    r,
    f,
    x.paused
  ]), k.useEffect(() => {
    if (f) {
      lN.add(x);
      const T = document.activeElement;
      if (!f.contains(T)) {
        const D = new CustomEvent(Sk, aN);
        f.addEventListener(Sk, g), f.dispatchEvent(D), D.defaultPrevented || (voe(xoe(nz(f)), {
          select: !0
        }), document.activeElement === T && Fd(f));
      }
      return () => {
        f.removeEventListener(Sk, g), setTimeout(() => {
          const D = new CustomEvent(wk, aN);
          f.addEventListener(wk, y), f.dispatchEvent(D), D.defaultPrevented || Fd(T ?? document.body, {
            select: !0
          }), f.removeEventListener(wk, y), lN.remove(x);
        }, 0);
      };
    }
  }, [
    f,
    g,
    y,
    x
  ]);
  const _ = k.useCallback((T) => {
    if (!n && !r || x.paused)
      return;
    const I = T.key === "Tab" && !T.altKey && !T.ctrlKey && !T.metaKey, D = document.activeElement;
    if (I && D) {
      const N = T.currentTarget, [j, L] = yoe(N);
      j && L ? !T.shiftKey && D === L ? (T.preventDefault(), n && Fd(j, {
        select: !0
      })) : T.shiftKey && D === j && (T.preventDefault(), n && Fd(L, {
        select: !0
      })) : D === N && T.preventDefault();
    }
  }, [
    n,
    r,
    x.paused
  ]);
  return /* @__PURE__ */ k.createElement(pr.div, qe({
    tabIndex: -1
  }, c, {
    ref: S,
    onKeyDown: _
  }));
});
function voe(t, { select: e = !1 } = {}) {
  const n = document.activeElement;
  for (const r of t)
    if (Fd(r, {
      select: e
    }), document.activeElement !== n)
      return;
}
function yoe(t) {
  const e = nz(t), n = sN(e, t), r = sN(e.reverse(), t);
  return [
    n,
    r
  ];
}
function nz(t) {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const a = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || a ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); )
    e.push(n.currentNode);
  return e;
}
function sN(t, e) {
  for (const n of t)
    if (!boe(n, {
      upTo: e
    }))
      return n;
}
function boe(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  for (; t; ) {
    if (e !== void 0 && t === e)
      return !1;
    if (getComputedStyle(t).display === "none")
      return !0;
    t = t.parentElement;
  }
  return !1;
}
function Soe(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function Fd(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({
      preventScroll: !0
    }), t !== n && Soe(t) && e && t.select();
  }
}
const lN = woe();
function woe() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && n?.pause(), t = cN(t, e), t.unshift(e);
    },
    remove(e) {
      var n;
      t = cN(t, e), (n = t[0]) === null || n === void 0 || n.resume();
    }
  };
}
function cN(t, e) {
  const n = [
    ...t
  ], r = n.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
function xoe(t) {
  return t.filter(
    (e) => e.tagName !== "A"
  );
}
const Eoe = W7["useId".toString()] || (() => {
});
let Coe = 0;
function ju(t) {
  const [e, n] = k.useState(Eoe());
  return Dp(() => {
    t || n(
      (r) => r ?? String(Coe++)
    );
  }, [
    t
  ]), t || (e ? `radix-${e}` : "");
}
function hm(t) {
  return t.split("-")[1];
}
function n2(t) {
  return t === "y" ? "height" : "width";
}
function zu(t) {
  return t.split("-")[0];
}
function Fp(t) {
  return ["top", "bottom"].includes(zu(t)) ? "x" : "y";
}
function uN(t, e, n) {
  let { reference: r, floating: a } = t;
  const s = r.x + r.width / 2 - a.width / 2, c = r.y + r.height / 2 - a.height / 2, f = Fp(e), p = n2(f), g = r[p] / 2 - a[p] / 2, y = f === "x";
  let v;
  switch (zu(e)) {
    case "top":
      v = { x: s, y: r.y - a.height };
      break;
    case "bottom":
      v = { x: s, y: r.y + r.height };
      break;
    case "right":
      v = { x: r.x + r.width, y: c };
      break;
    case "left":
      v = { x: r.x - a.width, y: c };
      break;
    default:
      v = { x: r.x, y: r.y };
  }
  switch (hm(e)) {
    case "start":
      v[f] -= g * (n && y ? -1 : 1);
      break;
    case "end":
      v[f] += g * (n && y ? -1 : 1);
  }
  return v;
}
const _oe = async (t, e, n) => {
  const { placement: r = "bottom", strategy: a = "absolute", middleware: s = [], platform: c } = n, f = s.filter(Boolean), p = await (c.isRTL == null ? void 0 : c.isRTL(e));
  let g = await c.getElementRects({ reference: t, floating: e, strategy: a }), { x: y, y: v } = uN(g, r, p), S = r, x = {}, _ = 0;
  for (let T = 0; T < f.length; T++) {
    const { name: I, fn: D } = f[T], { x: N, y: j, data: L, reset: z } = await D({ x: y, y: v, initialPlacement: r, placement: S, strategy: a, middlewareData: x, rects: g, platform: c, elements: { reference: t, floating: e } });
    y = N ?? y, v = j ?? v, x = { ...x, [I]: { ...x[I], ...L } }, z && _ <= 50 && (_++, typeof z == "object" && (z.placement && (S = z.placement), z.rects && (g = z.rects === !0 ? await c.getElementRects({ reference: t, floating: e, strategy: a }) : z.rects), { x: y, y: v } = uN(g, S, p)), T = -1);
  }
  return { x: y, y: v, placement: S, strategy: a, middlewareData: x };
};
function rz(t) {
  return typeof t != "number" ? function(e) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...e };
  }(t) : { top: t, right: t, bottom: t, left: t };
}
function Ux(t) {
  return { ...t, top: t.y, left: t.x, right: t.x + t.width, bottom: t.y + t.height };
}
async function ib(t, e) {
  var n;
  e === void 0 && (e = {});
  const { x: r, y: a, platform: s, rects: c, elements: f, strategy: p } = t, { boundary: g = "clippingAncestors", rootBoundary: y = "viewport", elementContext: v = "floating", altBoundary: S = !1, padding: x = 0 } = e, _ = rz(x), T = f[S ? v === "floating" ? "reference" : "floating" : v], I = Ux(await s.getClippingRect({ element: (n = await (s.isElement == null ? void 0 : s.isElement(T))) == null || n ? T : T.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(f.floating)), boundary: g, rootBoundary: y, strategy: p })), D = v === "floating" ? { ...c.floating, x: r, y: a } : c.reference, N = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(f.floating)), j = await (s.isElement == null ? void 0 : s.isElement(N)) && await (s.getScale == null ? void 0 : s.getScale(N)) || { x: 1, y: 1 }, L = Ux(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: D, offsetParent: N, strategy: p }) : D);
  return { top: (I.top - L.top + _.top) / j.y, bottom: (L.bottom - I.bottom + _.bottom) / j.y, left: (I.left - L.left + _.left) / j.x, right: (L.right - I.right + _.right) / j.x };
}
const xP = Math.min, Ep = Math.max;
function EP(t, e, n) {
  return Ep(t, xP(e, n));
}
const dN = (t) => ({ name: "arrow", options: t, async fn(e) {
  const { element: n, padding: r = 0 } = t || {}, { x: a, y: s, placement: c, rects: f, platform: p, elements: g } = e;
  if (n == null)
    return {};
  const y = rz(r), v = { x: a, y: s }, S = Fp(c), x = n2(S), _ = await p.getDimensions(n), T = S === "y", I = T ? "top" : "left", D = T ? "bottom" : "right", N = T ? "clientHeight" : "clientWidth", j = f.reference[x] + f.reference[S] - v[S] - f.floating[x], L = v[S] - f.reference[S], z = await (p.getOffsetParent == null ? void 0 : p.getOffsetParent(n));
  let F = z ? z[N] : 0;
  F && await (p.isElement == null ? void 0 : p.isElement(z)) || (F = g.floating[N] || f.floating[x]);
  const K = j / 2 - L / 2, X = y[I], se = F - _[x] - y[D], ue = F / 2 - _[x] / 2 + K, pe = EP(X, ue, se), Pe = hm(c) != null && ue != pe && f.reference[x] / 2 - (ue < X ? y[I] : y[D]) - _[x] / 2 < 0;
  return { [S]: v[S] - (Pe ? ue < X ? X - ue : se - ue : 0), data: { [S]: pe, centerOffset: ue - pe } };
} }), iz = ["top", "right", "bottom", "left"];
iz.reduce((t, e) => t.concat(e, e + "-start", e + "-end"), []);
const Toe = { left: "right", right: "left", bottom: "top", top: "bottom" };
function Bx(t) {
  return t.replace(/left|right|bottom|top/g, (e) => Toe[e]);
}
function koe(t, e, n) {
  n === void 0 && (n = !1);
  const r = hm(t), a = Fp(t), s = n2(a);
  let c = a === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[s] > e.floating[s] && (c = Bx(c)), { main: c, cross: Bx(c) };
}
const Poe = { start: "end", end: "start" };
function xk(t) {
  return t.replace(/start|end/g, (e) => Poe[e]);
}
const Ioe = function(t) {
  return t === void 0 && (t = {}), { name: "flip", options: t, async fn(e) {
    var n;
    const { placement: r, middlewareData: a, rects: s, initialPlacement: c, platform: f, elements: p } = e, { mainAxis: g = !0, crossAxis: y = !0, fallbackPlacements: v, fallbackStrategy: S = "bestFit", fallbackAxisSideDirection: x = "none", flipAlignment: _ = !0, ...T } = t, I = zu(r), D = zu(c) === c, N = await (f.isRTL == null ? void 0 : f.isRTL(p.floating)), j = v || (D || !_ ? [Bx(c)] : function(pe) {
      const Pe = Bx(pe);
      return [xk(pe), Pe, xk(Pe)];
    }(c));
    v || x === "none" || j.push(...function(pe, Pe, ve, Y) {
      const le = hm(pe);
      let Re = function(he, te, de) {
        const W = ["left", "right"], fe = ["right", "left"], ce = ["top", "bottom"], xe = ["bottom", "top"];
        switch (he) {
          case "top":
          case "bottom":
            return de ? te ? fe : W : te ? W : fe;
          case "left":
          case "right":
            return te ? ce : xe;
          default:
            return [];
        }
      }(zu(pe), ve === "start", Y);
      return le && (Re = Re.map((he) => he + "-" + le), Pe && (Re = Re.concat(Re.map(xk)))), Re;
    }(c, _, x, N));
    const L = [c, ...j], z = await ib(e, T), F = [];
    let K = ((n = a.flip) == null ? void 0 : n.overflows) || [];
    if (g && F.push(z[I]), y) {
      const { main: pe, cross: Pe } = koe(r, s, N);
      F.push(z[pe], z[Pe]);
    }
    if (K = [...K, { placement: r, overflows: F }], !F.every((pe) => pe <= 0)) {
      var X, se;
      const pe = (((X = a.flip) == null ? void 0 : X.index) || 0) + 1, Pe = L[pe];
      if (Pe)
        return { data: { index: pe, overflows: K }, reset: { placement: Pe } };
      let ve = (se = K.filter((Y) => Y.overflows[0] <= 0).sort((Y, le) => Y.overflows[1] - le.overflows[1])[0]) == null ? void 0 : se.placement;
      if (!ve)
        switch (S) {
          case "bestFit": {
            var ue;
            const Y = (ue = K.map((le) => [le.placement, le.overflows.filter((Re) => Re > 0).reduce((Re, he) => Re + he, 0)]).sort((le, Re) => le[1] - Re[1])[0]) == null ? void 0 : ue[0];
            Y && (ve = Y);
            break;
          }
          case "initialPlacement":
            ve = c;
        }
      if (r !== ve)
        return { reset: { placement: ve } };
    }
    return {};
  } };
};
function fN(t, e) {
  return { top: t.top - e.height, right: t.right - e.width, bottom: t.bottom - e.height, left: t.left - e.width };
}
function pN(t) {
  return iz.some((e) => t[e] >= 0);
}
const Roe = function(t) {
  return t === void 0 && (t = {}), { name: "hide", options: t, async fn(e) {
    const { strategy: n = "referenceHidden", ...r } = t, { rects: a } = e;
    switch (n) {
      case "referenceHidden": {
        const s = fN(await ib(e, { ...r, elementContext: "reference" }), a.reference);
        return { data: { referenceHiddenOffsets: s, referenceHidden: pN(s) } };
      }
      case "escaped": {
        const s = fN(await ib(e, { ...r, altBoundary: !0 }), a.floating);
        return { data: { escapedOffsets: s, escaped: pN(s) } };
      }
      default:
        return {};
    }
  } };
}, $oe = function(t) {
  return t === void 0 && (t = 0), { name: "offset", options: t, async fn(e) {
    const { x: n, y: r } = e, a = await async function(s, c) {
      const { placement: f, platform: p, elements: g } = s, y = await (p.isRTL == null ? void 0 : p.isRTL(g.floating)), v = zu(f), S = hm(f), x = Fp(f) === "x", _ = ["left", "top"].includes(v) ? -1 : 1, T = y && x ? -1 : 1, I = typeof c == "function" ? c(s) : c;
      let { mainAxis: D, crossAxis: N, alignmentAxis: j } = typeof I == "number" ? { mainAxis: I, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...I };
      return S && typeof j == "number" && (N = S === "end" ? -1 * j : j), x ? { x: N * T, y: D * _ } : { x: D * _, y: N * T };
    }(e, t);
    return { x: n + a.x, y: r + a.y, data: a };
  } };
};
function oz(t) {
  return t === "x" ? "y" : "x";
}
const Moe = function(t) {
  return t === void 0 && (t = {}), { name: "shift", options: t, async fn(e) {
    const { x: n, y: r, placement: a } = e, { mainAxis: s = !0, crossAxis: c = !1, limiter: f = { fn: (I) => {
      let { x: D, y: N } = I;
      return { x: D, y: N };
    } }, ...p } = t, g = { x: n, y: r }, y = await ib(e, p), v = Fp(zu(a)), S = oz(v);
    let x = g[v], _ = g[S];
    if (s) {
      const I = v === "y" ? "bottom" : "right";
      x = EP(x + y[v === "y" ? "top" : "left"], x, x - y[I]);
    }
    if (c) {
      const I = S === "y" ? "bottom" : "right";
      _ = EP(_ + y[S === "y" ? "top" : "left"], _, _ - y[I]);
    }
    const T = f.fn({ ...e, [v]: x, [S]: _ });
    return { ...T, data: { x: T.x - n, y: T.y - r } };
  } };
}, Aoe = function(t) {
  return t === void 0 && (t = {}), { options: t, fn(e) {
    const { x: n, y: r, placement: a, rects: s, middlewareData: c } = e, { offset: f = 0, mainAxis: p = !0, crossAxis: g = !0 } = t, y = { x: n, y: r }, v = Fp(a), S = oz(v);
    let x = y[v], _ = y[S];
    const T = typeof f == "function" ? f(e) : f, I = typeof T == "number" ? { mainAxis: T, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...T };
    if (p) {
      const j = v === "y" ? "height" : "width", L = s.reference[v] - s.floating[j] + I.mainAxis, z = s.reference[v] + s.reference[j] - I.mainAxis;
      x < L ? x = L : x > z && (x = z);
    }
    if (g) {
      var D, N;
      const j = v === "y" ? "width" : "height", L = ["top", "left"].includes(zu(a)), z = s.reference[S] - s.floating[j] + (L && ((D = c.offset) == null ? void 0 : D[S]) || 0) + (L ? 0 : I.crossAxis), F = s.reference[S] + s.reference[j] + (L ? 0 : ((N = c.offset) == null ? void 0 : N[S]) || 0) - (L ? I.crossAxis : 0);
      _ < z ? _ = z : _ > F && (_ = F);
    }
    return { [v]: x, [S]: _ };
  } };
}, Ooe = function(t) {
  return t === void 0 && (t = {}), { name: "size", options: t, async fn(e) {
    const { placement: n, rects: r, platform: a, elements: s } = e, { apply: c = () => {
    }, ...f } = t, p = await ib(e, f), g = zu(n), y = hm(n), v = Fp(n) === "x", { width: S, height: x } = r.floating;
    let _, T;
    g === "top" || g === "bottom" ? (_ = g, T = y === (await (a.isRTL == null ? void 0 : a.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (T = g, _ = y === "end" ? "top" : "bottom");
    const I = x - p[_], D = S - p[T], N = !e.middlewareData.shift;
    let j = I, L = D;
    if (v) {
      const F = S - p.left - p.right;
      L = y || N ? xP(D, F) : F;
    } else {
      const F = x - p.top - p.bottom;
      j = y || N ? xP(I, F) : F;
    }
    if (N && !y) {
      const F = Ep(p.left, 0), K = Ep(p.right, 0), X = Ep(p.top, 0), se = Ep(p.bottom, 0);
      v ? L = S - 2 * (F !== 0 || K !== 0 ? F + K : Ep(p.left, p.right)) : j = x - 2 * (X !== 0 || se !== 0 ? X + se : Ep(p.top, p.bottom));
    }
    await c({ ...e, availableWidth: L, availableHeight: j });
    const z = await a.getDimensions(s.floating);
    return S !== z.width || x !== z.height ? { reset: { rects: !0 } } : {};
  } };
};
function Xs(t) {
  var e;
  return ((e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function $l(t) {
  return Xs(t).getComputedStyle(t);
}
function az(t) {
  return t instanceof Xs(t).Node;
}
function rf(t) {
  return az(t) ? (t.nodeName || "").toLowerCase() : "";
}
function Dl(t) {
  return t instanceof Xs(t).HTMLElement;
}
function ds(t) {
  return t instanceof Xs(t).Element;
}
function hN(t) {
  return typeof ShadowRoot > "u" ? !1 : t instanceof Xs(t).ShadowRoot || t instanceof ShadowRoot;
}
function ob(t) {
  const { overflow: e, overflowX: n, overflowY: r, display: a } = $l(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !["inline", "contents"].includes(a);
}
function Doe(t) {
  return ["table", "td", "th"].includes(rf(t));
}
function CP(t) {
  const e = r2(), n = $l(t);
  return n.transform !== "none" || n.perspective !== "none" || !e && !!n.backdropFilter && n.backdropFilter !== "none" || !e && !!n.filter && n.filter !== "none" || ["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function r2() {
  return !(typeof CSS > "u" || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none");
}
function P1(t) {
  return ["html", "body", "#document"].includes(rf(t));
}
const gN = Math.min, Vy = Math.max, Fx = Math.round;
function sz(t) {
  const e = $l(t);
  let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const a = Dl(t), s = a ? t.offsetWidth : n, c = a ? t.offsetHeight : r, f = Fx(n) !== s || Fx(r) !== c;
  return f && (n = s, r = c), { width: n, height: r, fallback: f };
}
function lz(t) {
  return ds(t) ? t : t.contextElement;
}
const cz = { x: 1, y: 1 };
function Qg(t) {
  const e = lz(t);
  if (!Dl(e))
    return cz;
  const n = e.getBoundingClientRect(), { width: r, height: a, fallback: s } = sz(e);
  let c = (s ? Fx(n.width) : n.width) / r, f = (s ? Fx(n.height) : n.height) / a;
  return c && Number.isFinite(c) || (c = 1), f && Number.isFinite(f) || (f = 1), { x: c, y: f };
}
const mN = { x: 0, y: 0 };
function uz(t, e, n) {
  var r, a;
  if (e === void 0 && (e = !0), !r2())
    return mN;
  const s = t ? Xs(t) : window;
  return !n || e && n !== s ? mN : { x: ((r = s.visualViewport) == null ? void 0 : r.offsetLeft) || 0, y: ((a = s.visualViewport) == null ? void 0 : a.offsetTop) || 0 };
}
function Np(t, e, n, r) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const a = t.getBoundingClientRect(), s = lz(t);
  let c = cz;
  e && (r ? ds(r) && (c = Qg(r)) : c = Qg(t));
  const f = uz(s, n, r);
  let p = (a.left + f.x) / c.x, g = (a.top + f.y) / c.y, y = a.width / c.x, v = a.height / c.y;
  if (s) {
    const S = Xs(s), x = r && ds(r) ? Xs(r) : r;
    let _ = S.frameElement;
    for (; _ && r && x !== S; ) {
      const T = Qg(_), I = _.getBoundingClientRect(), D = getComputedStyle(_);
      I.x += (_.clientLeft + parseFloat(D.paddingLeft)) * T.x, I.y += (_.clientTop + parseFloat(D.paddingTop)) * T.y, p *= T.x, g *= T.y, y *= T.x, v *= T.y, p += I.x, g += I.y, _ = Xs(_).frameElement;
    }
  }
  return Ux({ width: y, height: v, x: p, y: g });
}
function Zd(t) {
  return ((az(t) ? t.ownerDocument : t.document) || window.document).documentElement;
}
function I1(t) {
  return ds(t) ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop } : { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset };
}
function dz(t) {
  return Np(Zd(t)).left + I1(t).scrollLeft;
}
function em(t) {
  if (rf(t) === "html")
    return t;
  const e = t.assignedSlot || t.parentNode || hN(t) && t.host || Zd(t);
  return hN(e) ? e.host : e;
}
function fz(t) {
  const e = em(t);
  return P1(e) ? e.ownerDocument.body : Dl(e) && ob(e) ? e : fz(e);
}
function Yy(t, e) {
  var n;
  e === void 0 && (e = []);
  const r = fz(t), a = r === ((n = t.ownerDocument) == null ? void 0 : n.body), s = Xs(r);
  return a ? e.concat(s, s.visualViewport || [], ob(r) ? r : []) : e.concat(r, Yy(r));
}
function vN(t, e, n) {
  let r;
  if (e === "viewport")
    r = function(a, s) {
      const c = Xs(a), f = Zd(a), p = c.visualViewport;
      let g = f.clientWidth, y = f.clientHeight, v = 0, S = 0;
      if (p) {
        g = p.width, y = p.height;
        const x = r2();
        (!x || x && s === "fixed") && (v = p.offsetLeft, S = p.offsetTop);
      }
      return { width: g, height: y, x: v, y: S };
    }(t, n);
  else if (e === "document")
    r = function(a) {
      const s = Zd(a), c = I1(a), f = a.ownerDocument.body, p = Vy(s.scrollWidth, s.clientWidth, f.scrollWidth, f.clientWidth), g = Vy(s.scrollHeight, s.clientHeight, f.scrollHeight, f.clientHeight);
      let y = -c.scrollLeft + dz(a);
      const v = -c.scrollTop;
      return $l(f).direction === "rtl" && (y += Vy(s.clientWidth, f.clientWidth) - p), { width: p, height: g, x: y, y: v };
    }(Zd(t));
  else if (ds(e))
    r = function(a, s) {
      const c = Np(a, !0, s === "fixed"), f = c.top + a.clientTop, p = c.left + a.clientLeft, g = Dl(a) ? Qg(a) : { x: 1, y: 1 };
      return { width: a.clientWidth * g.x, height: a.clientHeight * g.y, x: p * g.x, y: f * g.y };
    }(e, n);
  else {
    const a = uz(t);
    r = { ...e, x: e.x - a.x, y: e.y - a.y };
  }
  return Ux(r);
}
function pz(t, e) {
  const n = em(t);
  return !(n === e || !ds(n) || P1(n)) && ($l(n).position === "fixed" || pz(n, e));
}
function yN(t, e) {
  return Dl(t) && $l(t).position !== "fixed" ? e ? e(t) : t.offsetParent : null;
}
function bN(t, e) {
  const n = Xs(t);
  if (!Dl(t))
    return n;
  let r = yN(t, e);
  for (; r && Doe(r) && $l(r).position === "static"; )
    r = yN(r, e);
  return r && (rf(r) === "html" || rf(r) === "body" && $l(r).position === "static" && !CP(r)) ? n : r || function(a) {
    let s = em(a);
    for (; Dl(s) && !P1(s); ) {
      if (CP(s))
        return s;
      s = em(s);
    }
    return null;
  }(t) || n;
}
function Noe(t, e, n) {
  const r = Dl(e), a = Zd(e), s = n === "fixed", c = Np(t, !0, s, e);
  let f = { scrollLeft: 0, scrollTop: 0 };
  const p = { x: 0, y: 0 };
  if (r || !r && !s)
    if ((rf(e) !== "body" || ob(a)) && (f = I1(e)), Dl(e)) {
      const g = Np(e, !0, s, e);
      p.x = g.x + e.clientLeft, p.y = g.y + e.clientTop;
    } else
      a && (p.x = dz(a));
  return { x: c.left + f.scrollLeft - p.x, y: c.top + f.scrollTop - p.y, width: c.width, height: c.height };
}
const Loe = { getClippingRect: function(t) {
  let { element: e, boundary: n, rootBoundary: r, strategy: a } = t;
  const s = n === "clippingAncestors" ? function(g, y) {
    const v = y.get(g);
    if (v)
      return v;
    let S = Yy(g).filter((I) => ds(I) && rf(I) !== "body"), x = null;
    const _ = $l(g).position === "fixed";
    let T = _ ? em(g) : g;
    for (; ds(T) && !P1(T); ) {
      const I = $l(T), D = CP(T);
      D || I.position !== "fixed" || (x = null), (_ ? !D && !x : !D && I.position === "static" && x && ["absolute", "fixed"].includes(x.position) || ob(T) && !D && pz(g, T)) ? S = S.filter((N) => N !== T) : x = I, T = em(T);
    }
    return y.set(g, S), S;
  }(e, this._c) : [].concat(n), c = [...s, r], f = c[0], p = c.reduce((g, y) => {
    const v = vN(e, y, a);
    return g.top = Vy(v.top, g.top), g.right = gN(v.right, g.right), g.bottom = gN(v.bottom, g.bottom), g.left = Vy(v.left, g.left), g;
  }, vN(e, f, a));
  return { width: p.right - p.left, height: p.bottom - p.top, x: p.left, y: p.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(t) {
  let { rect: e, offsetParent: n, strategy: r } = t;
  const a = Dl(n), s = Zd(n);
  if (n === s)
    return e;
  let c = { scrollLeft: 0, scrollTop: 0 }, f = { x: 1, y: 1 };
  const p = { x: 0, y: 0 };
  if ((a || !a && r !== "fixed") && ((rf(n) !== "body" || ob(s)) && (c = I1(n)), Dl(n))) {
    const g = Np(n);
    f = Qg(n), p.x = g.x + n.clientLeft, p.y = g.y + n.clientTop;
  }
  return { width: e.width * f.x, height: e.height * f.y, x: e.x * f.x - c.scrollLeft * f.x + p.x, y: e.y * f.y - c.scrollTop * f.y + p.y };
}, isElement: ds, getDimensions: function(t) {
  return sz(t);
}, getOffsetParent: bN, getDocumentElement: Zd, getScale: Qg, async getElementRects(t) {
  let { reference: e, floating: n, strategy: r } = t;
  const a = this.getOffsetParent || bN, s = this.getDimensions;
  return { reference: Noe(e, await a(n), r), floating: { x: 0, y: 0, ...await s(n) } };
}, getClientRects: (t) => Array.from(t.getClientRects()), isRTL: (t) => $l(t).direction === "rtl" };
function joe(t, e, n, r) {
  r === void 0 && (r = {});
  const { ancestorScroll: a = !0, ancestorResize: s = !0, elementResize: c = !0, animationFrame: f = !1 } = r, p = a || s ? [...ds(t) ? Yy(t) : t.contextElement ? Yy(t.contextElement) : [], ...Yy(e)] : [];
  p.forEach((S) => {
    const x = !ds(S) && S.toString().includes("V");
    !a || f && !x || S.addEventListener("scroll", n, { passive: !0 }), s && S.addEventListener("resize", n);
  });
  let g, y = null;
  c && (y = new ResizeObserver(() => {
    n();
  }), ds(t) && !f && y.observe(t), ds(t) || !t.contextElement || f || y.observe(t.contextElement), y.observe(e));
  let v = f ? Np(t) : null;
  return f && function S() {
    const x = Np(t);
    !v || x.x === v.x && x.y === v.y && x.width === v.width && x.height === v.height || n(), v = x, g = requestAnimationFrame(S);
  }(), n(), () => {
    var S;
    p.forEach((x) => {
      a && x.removeEventListener("scroll", n), s && x.removeEventListener("resize", n);
    }), (S = y) == null || S.disconnect(), y = null, f && cancelAnimationFrame(g);
  };
}
const zoe = (t, e, n) => {
  const r = /* @__PURE__ */ new Map(), a = { platform: Loe, ...n }, s = { ...a.platform, _c: r };
  return _oe(t, e, { ...a, platform: s });
}, Uoe = (t) => {
  const {
    element: e,
    padding: n
  } = t;
  function r(a) {
    return {}.hasOwnProperty.call(a, "current");
  }
  return {
    name: "arrow",
    options: t,
    fn(a) {
      return e && r(e) ? e.current != null ? dN({
        element: e.current,
        padding: n
      }).fn(a) : {} : e ? dN({
        element: e,
        padding: n
      }).fn(a) : {};
    }
  };
};
var hx = typeof document < "u" ? k.useLayoutEffect : k.useEffect;
function Hx(t, e) {
  if (t === e)
    return !0;
  if (typeof t != typeof e)
    return !1;
  if (typeof t == "function" && t.toString() === e.toString())
    return !0;
  let n, r, a;
  if (t && e && typeof t == "object") {
    if (Array.isArray(t)) {
      if (n = t.length, n != e.length)
        return !1;
      for (r = n; r-- !== 0; )
        if (!Hx(t[r], e[r]))
          return !1;
      return !0;
    }
    if (a = Object.keys(t), n = a.length, n !== Object.keys(e).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(e, a[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const s = a[r];
      if (!(s === "_owner" && t.$$typeof) && !Hx(t[s], e[s]))
        return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
}
function hz(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function SN(t, e) {
  const n = hz(t);
  return Math.round(e * n) / n;
}
function wN(t) {
  const e = k.useRef(t);
  return hx(() => {
    e.current = t;
  }), e;
}
function Boe(t) {
  t === void 0 && (t = {});
  const {
    placement: e = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: a,
    elements: {
      reference: s,
      floating: c
    } = {},
    transform: f = !0,
    whileElementsMounted: p,
    open: g
  } = t, [y, v] = k.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [S, x] = k.useState(r);
  Hx(S, r) || x(r);
  const [_, T] = k.useState(null), [I, D] = k.useState(null), N = k.useCallback((Re) => {
    Re != F.current && (F.current = Re, T(Re));
  }, [T]), j = k.useCallback((Re) => {
    Re !== K.current && (K.current = Re, D(Re));
  }, [D]), L = s || _, z = c || I, F = k.useRef(null), K = k.useRef(null), X = k.useRef(y), se = wN(p), ue = wN(a), pe = k.useCallback(() => {
    if (!F.current || !K.current)
      return;
    const Re = {
      placement: e,
      strategy: n,
      middleware: S
    };
    ue.current && (Re.platform = ue.current), zoe(F.current, K.current, Re).then((he) => {
      const te = {
        ...he,
        isPositioned: !0
      };
      Pe.current && !Hx(X.current, te) && (X.current = te, pm.flushSync(() => {
        v(te);
      }));
    });
  }, [S, e, n, ue]);
  hx(() => {
    g === !1 && X.current.isPositioned && (X.current.isPositioned = !1, v((Re) => ({
      ...Re,
      isPositioned: !1
    })));
  }, [g]);
  const Pe = k.useRef(!1);
  hx(() => (Pe.current = !0, () => {
    Pe.current = !1;
  }), []), hx(() => {
    if (L && (F.current = L), z && (K.current = z), L && z) {
      if (se.current)
        return se.current(L, z, pe);
      pe();
    }
  }, [L, z, pe, se]);
  const ve = k.useMemo(() => ({
    reference: F,
    floating: K,
    setReference: N,
    setFloating: j
  }), [N, j]), Y = k.useMemo(() => ({
    reference: L,
    floating: z
  }), [L, z]), le = k.useMemo(() => {
    const Re = {
      position: n,
      left: 0,
      top: 0
    };
    if (!Y.floating)
      return Re;
    const he = SN(Y.floating, y.x), te = SN(Y.floating, y.y);
    return f ? {
      ...Re,
      transform: "translate(" + he + "px, " + te + "px)",
      ...hz(Y.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: he,
      top: te
    };
  }, [n, f, Y.floating, y.x, y.y]);
  return k.useMemo(() => ({
    ...y,
    update: pe,
    refs: ve,
    elements: Y,
    floatingStyles: le
  }), [y, pe, ve, Y, le]);
}
function gz(t) {
  const [e, n] = k.useState(void 0);
  return Dp(() => {
    if (t) {
      n({
        width: t.offsetWidth,
        height: t.offsetHeight
      });
      const r = new ResizeObserver((a) => {
        if (!Array.isArray(a) || !a.length)
          return;
        const s = a[0];
        let c, f;
        if ("borderBoxSize" in s) {
          const p = s.borderBoxSize, g = Array.isArray(p) ? p[0] : p;
          c = g.inlineSize, f = g.blockSize;
        } else
          c = t.offsetWidth, f = t.offsetHeight;
        n({
          width: c,
          height: f
        });
      });
      return r.observe(t, {
        box: "border-box"
      }), () => r.unobserve(t);
    } else
      n(void 0);
  }, [
    t
  ]), e;
}
const mz = "Popper", [vz, R1] = Nc(mz), [Foe, yz] = vz(mz), Hoe = (t) => {
  const { __scopePopper: e, children: n } = t, [r, a] = k.useState(null);
  return /* @__PURE__ */ k.createElement(Foe, {
    scope: e,
    anchor: r,
    onAnchorChange: a
  }, n);
}, Voe = "PopperAnchor", Yoe = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopePopper: n, virtualRef: r, ...a } = t, s = yz(Voe, n), c = k.useRef(null), f = Rr(e, c);
  return k.useEffect(() => {
    s.onAnchorChange(r?.current || c.current);
  }), r ? null : /* @__PURE__ */ k.createElement(pr.div, qe({}, a, {
    ref: f
  }));
}), bz = "PopperContent", [Koe, Zpe] = vz(bz), Woe = /* @__PURE__ */ k.forwardRef((t, e) => {
  var n, r, a, s, c, f, p, g;
  const { __scopePopper: y, side: v = "bottom", sideOffset: S = 0, align: x = "center", alignOffset: _ = 0, arrowPadding: T = 0, collisionBoundary: I = [], collisionPadding: D = 0, sticky: N = "partial", hideWhenDetached: j = !1, avoidCollisions: L = !0, onPlaced: z, ...F } = t, K = yz(bz, y), [X, se] = k.useState(null), ue = Rr(
    e,
    (Ke) => se(Ke)
  ), [pe, Pe] = k.useState(null), ve = gz(pe), Y = (n = ve?.width) !== null && n !== void 0 ? n : 0, le = (r = ve?.height) !== null && r !== void 0 ? r : 0, Re = v + (x !== "center" ? "-" + x : ""), he = typeof D == "number" ? D : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...D
  }, te = Array.isArray(I) ? I : [
    I
  ], de = te.length > 0, W = {
    padding: he,
    boundary: te.filter(Goe),
    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
    altBoundary: de
  }, { refs: fe, floatingStyles: ce, placement: xe, isPositioned: $e, middlewareData: Me } = Boe({
    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
    strategy: "fixed",
    placement: Re,
    whileElementsMounted: joe,
    elements: {
      reference: K.anchor
    },
    middleware: [
      $oe({
        mainAxis: S + le,
        alignmentAxis: _
      }),
      L && Moe({
        mainAxis: !0,
        crossAxis: !1,
        limiter: N === "partial" ? Aoe() : void 0,
        ...W
      }),
      L && Ioe({
        ...W
      }),
      Ooe({
        ...W,
        apply: ({ elements: Ke, rects: yt, availableWidth: Xt, availableHeight: kt }) => {
          const { width: yn, height: Er } = yt.reference, tn = Ke.floating.style;
          tn.setProperty("--radix-popper-available-width", `${Xt}px`), tn.setProperty("--radix-popper-available-height", `${kt}px`), tn.setProperty("--radix-popper-anchor-width", `${yn}px`), tn.setProperty("--radix-popper-anchor-height", `${Er}px`);
        }
      }),
      pe && Uoe({
        element: pe,
        padding: T
      }),
      Xoe({
        arrowWidth: Y,
        arrowHeight: le
      }),
      j && Roe({
        strategy: "referenceHidden"
      })
    ]
  }), [re, Qe] = Sz(xe), ke = Wo(z);
  Dp(() => {
    $e && ke?.();
  }, [
    $e,
    ke
  ]);
  const rt = (a = Me.arrow) === null || a === void 0 ? void 0 : a.x, St = (s = Me.arrow) === null || s === void 0 ? void 0 : s.y, Tt = ((c = Me.arrow) === null || c === void 0 ? void 0 : c.centerOffset) !== 0, [Le, Nt] = k.useState();
  return Dp(() => {
    X && Nt(window.getComputedStyle(X).zIndex);
  }, [
    X
  ]), /* @__PURE__ */ k.createElement("div", {
    ref: fe.setFloating,
    "data-radix-popper-content-wrapper": "",
    style: {
      ...ce,
      transform: $e ? ce.transform : "translate(0, -200%)",
      // keep off the page when measuring
      minWidth: "max-content",
      zIndex: Le,
      ["--radix-popper-transform-origin"]: [
        (f = Me.transformOrigin) === null || f === void 0 ? void 0 : f.x,
        (p = Me.transformOrigin) === null || p === void 0 ? void 0 : p.y
      ].join(" ")
    },
    dir: t.dir
  }, /* @__PURE__ */ k.createElement(Koe, {
    scope: y,
    placedSide: re,
    onArrowChange: Pe,
    arrowX: rt,
    arrowY: St,
    shouldHideArrow: Tt
  }, /* @__PURE__ */ k.createElement(pr.div, qe({
    "data-side": re,
    "data-align": Qe
  }, F, {
    ref: ue,
    style: {
      ...F.style,
      // if the PopperContent hasn't been placed yet (not all measurements done)
      // we prevent animations so that users's animation don't kick in too early referring wrong sides
      animation: $e ? void 0 : "none",
      // hide the content if using the hide middleware and should be hidden
      opacity: (g = Me.hide) !== null && g !== void 0 && g.referenceHidden ? 0 : void 0
    }
  }))));
});
function Goe(t) {
  return t !== null;
}
const Xoe = (t) => ({
  name: "transformOrigin",
  options: t,
  fn(e) {
    var n, r, a, s, c;
    const { placement: f, rects: p, middlewareData: g } = e, v = ((n = g.arrow) === null || n === void 0 ? void 0 : n.centerOffset) !== 0, S = v ? 0 : t.arrowWidth, x = v ? 0 : t.arrowHeight, [_, T] = Sz(f), I = {
      start: "0%",
      center: "50%",
      end: "100%"
    }[T], D = ((r = (a = g.arrow) === null || a === void 0 ? void 0 : a.x) !== null && r !== void 0 ? r : 0) + S / 2, N = ((s = (c = g.arrow) === null || c === void 0 ? void 0 : c.y) !== null && s !== void 0 ? s : 0) + x / 2;
    let j = "", L = "";
    return _ === "bottom" ? (j = v ? I : `${D}px`, L = `${-x}px`) : _ === "top" ? (j = v ? I : `${D}px`, L = `${p.floating.height + x}px`) : _ === "right" ? (j = `${-x}px`, L = v ? I : `${N}px`) : _ === "left" && (j = `${p.floating.width + x}px`, L = v ? I : `${N}px`), {
      data: {
        x: j,
        y: L
      }
    };
  }
});
function Sz(t) {
  const [e, n = "center"] = t.split("-");
  return [
    e,
    n
  ];
}
const i2 = Hoe, wz = Yoe, xz = Woe, Ek = "rovingFocusGroup.onEntryFocus", qoe = {
  bubbles: !1,
  cancelable: !0
}, o2 = "RovingFocusGroup", [_P, Ez, Qoe] = E1(o2), [Zoe, Cz] = Nc(o2, [
  Qoe
]), [Joe, eae] = Zoe(o2), tae = /* @__PURE__ */ k.forwardRef((t, e) => /* @__PURE__ */ k.createElement(_P.Provider, {
  scope: t.__scopeRovingFocusGroup
}, /* @__PURE__ */ k.createElement(_P.Slot, {
  scope: t.__scopeRovingFocusGroup
}, /* @__PURE__ */ k.createElement(nae, qe({}, t, {
  ref: e
}))))), nae = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeRovingFocusGroup: n, orientation: r, loop: a = !1, dir: s, currentTabStopId: c, defaultCurrentTabStopId: f, onCurrentTabStopIdChange: p, onEntryFocus: g, ...y } = t, v = k.useRef(null), S = Rr(e, v), x = JI(s), [_ = null, T] = ff({
    prop: c,
    defaultProp: f,
    onChange: p
  }), [I, D] = k.useState(!1), N = Wo(g), j = Ez(n), L = k.useRef(!1), [z, F] = k.useState(0);
  return k.useEffect(() => {
    const K = v.current;
    if (K)
      return K.addEventListener(Ek, N), () => K.removeEventListener(Ek, N);
  }, [
    N
  ]), /* @__PURE__ */ k.createElement(Joe, {
    scope: n,
    orientation: r,
    dir: x,
    loop: a,
    currentTabStopId: _,
    onItemFocus: k.useCallback(
      (K) => T(K),
      [
        T
      ]
    ),
    onItemShiftTab: k.useCallback(
      () => D(!0),
      []
    ),
    onFocusableItemAdd: k.useCallback(
      () => F(
        (K) => K + 1
      ),
      []
    ),
    onFocusableItemRemove: k.useCallback(
      () => F(
        (K) => K - 1
      ),
      []
    )
  }, /* @__PURE__ */ k.createElement(pr.div, qe({
    tabIndex: I || z === 0 ? -1 : 0,
    "data-orientation": r
  }, y, {
    ref: S,
    style: {
      outline: "none",
      ...t.style
    },
    onMouseDown: _t(t.onMouseDown, () => {
      L.current = !0;
    }),
    onFocus: _t(t.onFocus, (K) => {
      const X = !L.current;
      if (K.target === K.currentTarget && X && !I) {
        const se = new CustomEvent(Ek, qoe);
        if (K.currentTarget.dispatchEvent(se), !se.defaultPrevented) {
          const ue = j().filter(
            (le) => le.focusable
          ), pe = ue.find(
            (le) => le.active
          ), Pe = ue.find(
            (le) => le.id === _
          ), Y = [
            pe,
            Pe,
            ...ue
          ].filter(Boolean).map(
            (le) => le.ref.current
          );
          _z(Y);
        }
      }
      L.current = !1;
    }),
    onBlur: _t(
      t.onBlur,
      () => D(!1)
    )
  })));
}), rae = "RovingFocusGroupItem", iae = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeRovingFocusGroup: n, focusable: r = !0, active: a = !1, tabStopId: s, ...c } = t, f = ju(), p = s || f, g = eae(rae, n), y = g.currentTabStopId === p, v = Ez(n), { onFocusableItemAdd: S, onFocusableItemRemove: x } = g;
  return k.useEffect(() => {
    if (r)
      return S(), () => x();
  }, [
    r,
    S,
    x
  ]), /* @__PURE__ */ k.createElement(_P.ItemSlot, {
    scope: n,
    id: p,
    focusable: r,
    active: a
  }, /* @__PURE__ */ k.createElement(pr.span, qe({
    tabIndex: y ? 0 : -1,
    "data-orientation": g.orientation
  }, c, {
    ref: e,
    onMouseDown: _t(t.onMouseDown, (_) => {
      r ? g.onItemFocus(p) : _.preventDefault();
    }),
    onFocus: _t(
      t.onFocus,
      () => g.onItemFocus(p)
    ),
    onKeyDown: _t(t.onKeyDown, (_) => {
      if (_.key === "Tab" && _.shiftKey) {
        g.onItemShiftTab();
        return;
      }
      if (_.target !== _.currentTarget)
        return;
      const T = sae(_, g.orientation, g.dir);
      if (T !== void 0) {
        _.preventDefault();
        let D = v().filter(
          (N) => N.focusable
        ).map(
          (N) => N.ref.current
        );
        if (T === "last")
          D.reverse();
        else if (T === "prev" || T === "next") {
          T === "prev" && D.reverse();
          const N = D.indexOf(_.currentTarget);
          D = g.loop ? lae(D, N + 1) : D.slice(N + 1);
        }
        setTimeout(
          () => _z(D)
        );
      }
    })
  })));
}), oae = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function aae(t, e) {
  return e !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t;
}
function sae(t, e, n) {
  const r = aae(t.key, n);
  if (!(e === "vertical" && [
    "ArrowLeft",
    "ArrowRight"
  ].includes(r)) && !(e === "horizontal" && [
    "ArrowUp",
    "ArrowDown"
  ].includes(r)))
    return oae[r];
}
function _z(t) {
  const e = document.activeElement;
  for (const n of t)
    if (n === e || (n.focus(), document.activeElement !== e))
      return;
}
function lae(t, e) {
  return t.map(
    (n, r) => t[(e + r) % t.length]
  );
}
const cae = tae, uae = iae;
var dae = function(t) {
  if (typeof document > "u")
    return null;
  var e = Array.isArray(t) ? t[0] : t;
  return e.ownerDocument.body;
}, Lg = /* @__PURE__ */ new WeakMap(), Gw = /* @__PURE__ */ new WeakMap(), Xw = {}, Ck = 0, Tz = function(t) {
  return t && (t.host || Tz(t.parentNode));
}, fae = function(t, e) {
  return e.map(function(n) {
    if (t.contains(n))
      return n;
    var r = Tz(n);
    return r && t.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", t, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, pae = function(t, e, n, r) {
  var a = fae(e, Array.isArray(t) ? t : [t]);
  Xw[n] || (Xw[n] = /* @__PURE__ */ new WeakMap());
  var s = Xw[n], c = [], f = /* @__PURE__ */ new Set(), p = new Set(a), g = function(v) {
    !v || f.has(v) || (f.add(v), g(v.parentNode));
  };
  a.forEach(g);
  var y = function(v) {
    !v || p.has(v) || Array.prototype.forEach.call(v.children, function(S) {
      if (f.has(S))
        y(S);
      else {
        var x = S.getAttribute(r), _ = x !== null && x !== "false", T = (Lg.get(S) || 0) + 1, I = (s.get(S) || 0) + 1;
        Lg.set(S, T), s.set(S, I), c.push(S), T === 1 && _ && Gw.set(S, !0), I === 1 && S.setAttribute(n, "true"), _ || S.setAttribute(r, "true");
      }
    });
  };
  return y(e), f.clear(), Ck++, function() {
    c.forEach(function(v) {
      var S = Lg.get(v) - 1, x = s.get(v) - 1;
      Lg.set(v, S), s.set(v, x), S || (Gw.has(v) || v.removeAttribute(r), Gw.delete(v)), x || v.removeAttribute(n);
    }), Ck--, Ck || (Lg = /* @__PURE__ */ new WeakMap(), Lg = /* @__PURE__ */ new WeakMap(), Gw = /* @__PURE__ */ new WeakMap(), Xw = {});
  };
}, a2 = function(t, e, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(t) ? t : [t]), a = e || dae(t);
  return a ? (r.push.apply(r, Array.from(a.querySelectorAll("[aria-live]"))), pae(r, a, n, "aria-hidden")) : function() {
    return null;
  };
}, Yd = function() {
  return Yd = Object.assign || function(e) {
    for (var n, r = 1, a = arguments.length; r < a; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, Yd.apply(this, arguments);
};
function hae(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(t); a < r.length; a++)
      e.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[a]) && (n[r[a]] = t[r[a]]);
  return n;
}
function gae(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, a = e.length, s; r < a; r++)
      (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
  return t.concat(s || Array.prototype.slice.call(e));
}
var gx = "right-scroll-bar-position", mx = "width-before-scroll-bar", mae = "with-scroll-bars-hidden", vae = "--removed-body-scroll-bar-size";
function yae(t, e) {
  return typeof t == "function" ? t(e) : t && (t.current = e), t;
}
function bae(t, e) {
  var n = k.useState(function() {
    return {
      // value
      value: t,
      // last callback
      callback: e,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var a = n.value;
          a !== r && (n.value = r, n.callback(r, a));
        }
      }
    };
  })[0];
  return n.callback = e, n.facade;
}
function Sae(t, e) {
  return bae(e || null, function(n) {
    return t.forEach(function(r) {
      return yae(r, n);
    });
  });
}
var Vx = function() {
  return Vx = Object.assign || function(e) {
    for (var n, r = 1, a = arguments.length; r < a; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, Vx.apply(this, arguments);
};
function wae(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(t); a < r.length; a++)
      e.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[a]) && (n[r[a]] = t[r[a]]);
  return n;
}
function xae(t) {
  return t;
}
function Eae(t, e) {
  e === void 0 && (e = xae);
  var n = [], r = !1, a = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : t;
    },
    useMedium: function(s) {
      var c = e(s, r);
      return n.push(c), function() {
        n = n.filter(function(f) {
          return f !== c;
        });
      };
    },
    assignSyncMedium: function(s) {
      for (r = !0; n.length; ) {
        var c = n;
        n = [], c.forEach(s);
      }
      n = {
        push: function(f) {
          return s(f);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(s) {
      r = !0;
      var c = [];
      if (n.length) {
        var f = n;
        n = [], f.forEach(s), c = n;
      }
      var p = function() {
        var y = c;
        c = [], y.forEach(s);
      }, g = function() {
        return Promise.resolve().then(p);
      };
      g(), n = {
        push: function(y) {
          c.push(y), g();
        },
        filter: function(y) {
          return c = c.filter(y), n;
        }
      };
    }
  };
  return a;
}
function Cae(t) {
  t === void 0 && (t = {});
  var e = Eae(null);
  return e.options = Vx({ async: !0, ssr: !1 }, t), e;
}
var kz = function(t) {
  var e = t.sideCar, n = wae(t, ["sideCar"]);
  if (!e)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = e.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return k.createElement(r, Vx({}, n));
};
kz.isSideCarExport = !0;
function _ae(t, e) {
  return t.useMedium(e), kz;
}
var Pz = Cae(), _k = function() {
}, $1 = k.forwardRef(function(t, e) {
  var n = k.useRef(null), r = k.useState({
    onScrollCapture: _k,
    onWheelCapture: _k,
    onTouchMoveCapture: _k
  }), a = r[0], s = r[1], c = t.forwardProps, f = t.children, p = t.className, g = t.removeScrollBar, y = t.enabled, v = t.shards, S = t.sideCar, x = t.noIsolation, _ = t.inert, T = t.allowPinchZoom, I = t.as, D = I === void 0 ? "div" : I, N = hae(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]), j = S, L = Sae([n, e]), z = Yd(Yd({}, N), a);
  return k.createElement(
    k.Fragment,
    null,
    y && k.createElement(j, { sideCar: Pz, removeScrollBar: g, shards: v, noIsolation: x, inert: _, setCallbacks: s, allowPinchZoom: !!T, lockRef: n }),
    c ? k.cloneElement(k.Children.only(f), Yd(Yd({}, z), { ref: L })) : k.createElement(D, Yd({}, z, { className: p, ref: L }), f)
  );
});
$1.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
$1.classNames = {
  fullWidth: mx,
  zeroRight: gx
};
var xN, Tae = function() {
  if (xN)
    return xN;
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function kae() {
  if (!document)
    return null;
  var t = document.createElement("style");
  t.type = "text/css";
  var e = Tae();
  return e && t.setAttribute("nonce", e), t;
}
function Pae(t, e) {
  t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e));
}
function Iae(t) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(t);
}
var Rae = function() {
  var t = 0, e = null;
  return {
    add: function(n) {
      t == 0 && (e = kae()) && (Pae(e, n), Iae(e)), t++;
    },
    remove: function() {
      t--, !t && e && (e.parentNode && e.parentNode.removeChild(e), e = null);
    }
  };
}, $ae = function() {
  var t = Rae();
  return function(e, n) {
    k.useEffect(function() {
      return t.add(e), function() {
        t.remove();
      };
    }, [e && n]);
  };
}, Iz = function() {
  var t = $ae(), e = function(n) {
    var r = n.styles, a = n.dynamic;
    return t(r, a), null;
  };
  return e;
}, Mae = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, Tk = function(t) {
  return parseInt(t || "", 10) || 0;
}, Aae = function(t) {
  var e = window.getComputedStyle(document.body), n = e[t === "padding" ? "paddingLeft" : "marginLeft"], r = e[t === "padding" ? "paddingTop" : "marginTop"], a = e[t === "padding" ? "paddingRight" : "marginRight"];
  return [Tk(n), Tk(r), Tk(a)];
}, Oae = function(t) {
  if (t === void 0 && (t = "margin"), typeof window > "u")
    return Mae;
  var e = Aae(t), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: e[0],
    top: e[1],
    right: e[2],
    gap: Math.max(0, r - n + e[2] - e[0])
  };
}, Dae = Iz(), Nae = function(t, e, n, r) {
  var a = t.left, s = t.top, c = t.right, f = t.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(mae, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(f, "px ").concat(r, `;
  }
  body {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    e && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(a, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(c, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(f, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(f, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(gx, ` {
    right: `).concat(f, "px ").concat(r, `;
  }
  
  .`).concat(mx, ` {
    margin-right: `).concat(f, "px ").concat(r, `;
  }
  
  .`).concat(gx, " .").concat(gx, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(mx, " .").concat(mx, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body {
    `).concat(vae, ": ").concat(f, `px;
  }
`);
}, Lae = function(t) {
  var e = t.noRelative, n = t.noImportant, r = t.gapMode, a = r === void 0 ? "margin" : r, s = k.useMemo(function() {
    return Oae(a);
  }, [a]);
  return k.createElement(Dae, { styles: Nae(s, !e, a, n ? "" : "!important") });
}, TP = !1;
if (typeof window < "u")
  try {
    var qw = Object.defineProperty({}, "passive", {
      get: function() {
        return TP = !0, !0;
      }
    });
    window.addEventListener("test", qw, qw), window.removeEventListener("test", qw, qw);
  } catch {
    TP = !1;
  }
var jg = TP ? { passive: !1 } : !1, jae = function(t) {
  return t.tagName === "TEXTAREA";
}, Rz = function(t, e) {
  var n = window.getComputedStyle(t);
  return (
    // not-not-scrollable
    n[e] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !jae(t) && n[e] === "visible")
  );
}, zae = function(t) {
  return Rz(t, "overflowY");
}, Uae = function(t) {
  return Rz(t, "overflowX");
}, EN = function(t, e) {
  var n = e;
  do {
    typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host);
    var r = $z(t, n);
    if (r) {
      var a = Mz(t, n), s = a[1], c = a[2];
      if (s > c)
        return !0;
    }
    n = n.parentNode;
  } while (n && n !== document.body);
  return !1;
}, Bae = function(t) {
  var e = t.scrollTop, n = t.scrollHeight, r = t.clientHeight;
  return [
    e,
    n,
    r
  ];
}, Fae = function(t) {
  var e = t.scrollLeft, n = t.scrollWidth, r = t.clientWidth;
  return [
    e,
    n,
    r
  ];
}, $z = function(t, e) {
  return t === "v" ? zae(e) : Uae(e);
}, Mz = function(t, e) {
  return t === "v" ? Bae(e) : Fae(e);
}, Hae = function(t, e) {
  return t === "h" && e === "rtl" ? -1 : 1;
}, Vae = function(t, e, n, r, a) {
  var s = Hae(t, window.getComputedStyle(e).direction), c = s * r, f = n.target, p = e.contains(f), g = !1, y = c > 0, v = 0, S = 0;
  do {
    var x = Mz(t, f), _ = x[0], T = x[1], I = x[2], D = T - I - s * _;
    (_ || D) && $z(t, f) && (v += D, S += _), f = f.parentNode;
  } while (
    // portaled content
    !p && f !== document.body || // self content
    p && (e.contains(f) || e === f)
  );
  return (y && (a && v === 0 || !a && c > v) || !y && (a && S === 0 || !a && -c > S)) && (g = !0), g;
}, Qw = function(t) {
  return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
}, CN = function(t) {
  return [t.deltaX, t.deltaY];
}, _N = function(t) {
  return t && "current" in t ? t.current : t;
}, Yae = function(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}, Kae = function(t) {
  return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`);
}, Wae = 0, zg = [];
function Gae(t) {
  var e = k.useRef([]), n = k.useRef([0, 0]), r = k.useRef(), a = k.useState(Wae++)[0], s = k.useState(function() {
    return Iz();
  })[0], c = k.useRef(t);
  k.useEffect(function() {
    c.current = t;
  }, [t]), k.useEffect(function() {
    if (t.inert) {
      document.body.classList.add("block-interactivity-".concat(a));
      var T = gae([t.lockRef.current], (t.shards || []).map(_N), !0).filter(Boolean);
      return T.forEach(function(I) {
        return I.classList.add("allow-interactivity-".concat(a));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(a)), T.forEach(function(I) {
          return I.classList.remove("allow-interactivity-".concat(a));
        });
      };
    }
  }, [t.inert, t.lockRef.current, t.shards]);
  var f = k.useCallback(function(T, I) {
    if ("touches" in T && T.touches.length === 2)
      return !c.current.allowPinchZoom;
    var D = Qw(T), N = n.current, j = "deltaX" in T ? T.deltaX : N[0] - D[0], L = "deltaY" in T ? T.deltaY : N[1] - D[1], z, F = T.target, K = Math.abs(j) > Math.abs(L) ? "h" : "v";
    if ("touches" in T && K === "h" && F.type === "range")
      return !1;
    var X = EN(K, F);
    if (!X)
      return !0;
    if (X ? z = K : (z = K === "v" ? "h" : "v", X = EN(K, F)), !X)
      return !1;
    if (!r.current && "changedTouches" in T && (j || L) && (r.current = z), !z)
      return !0;
    var se = r.current || z;
    return Vae(se, I, T, se === "h" ? j : L, !0);
  }, []), p = k.useCallback(function(T) {
    var I = T;
    if (!(!zg.length || zg[zg.length - 1] !== s)) {
      var D = "deltaY" in I ? CN(I) : Qw(I), N = e.current.filter(function(z) {
        return z.name === I.type && z.target === I.target && Yae(z.delta, D);
      })[0];
      if (N && N.should) {
        I.cancelable && I.preventDefault();
        return;
      }
      if (!N) {
        var j = (c.current.shards || []).map(_N).filter(Boolean).filter(function(z) {
          return z.contains(I.target);
        }), L = j.length > 0 ? f(I, j[0]) : !c.current.noIsolation;
        L && I.cancelable && I.preventDefault();
      }
    }
  }, []), g = k.useCallback(function(T, I, D, N) {
    var j = { name: T, delta: I, target: D, should: N };
    e.current.push(j), setTimeout(function() {
      e.current = e.current.filter(function(L) {
        return L !== j;
      });
    }, 1);
  }, []), y = k.useCallback(function(T) {
    n.current = Qw(T), r.current = void 0;
  }, []), v = k.useCallback(function(T) {
    g(T.type, CN(T), T.target, f(T, t.lockRef.current));
  }, []), S = k.useCallback(function(T) {
    g(T.type, Qw(T), T.target, f(T, t.lockRef.current));
  }, []);
  k.useEffect(function() {
    return zg.push(s), t.setCallbacks({
      onScrollCapture: v,
      onWheelCapture: v,
      onTouchMoveCapture: S
    }), document.addEventListener("wheel", p, jg), document.addEventListener("touchmove", p, jg), document.addEventListener("touchstart", y, jg), function() {
      zg = zg.filter(function(T) {
        return T !== s;
      }), document.removeEventListener("wheel", p, jg), document.removeEventListener("touchmove", p, jg), document.removeEventListener("touchstart", y, jg);
    };
  }, []);
  var x = t.removeScrollBar, _ = t.inert;
  return k.createElement(
    k.Fragment,
    null,
    _ ? k.createElement(s, { styles: Kae(a) }) : null,
    x ? k.createElement(Lae, { gapMode: "margin" }) : null
  );
}
const Xae = _ae(Pz, Gae);
var Az = k.forwardRef(function(t, e) {
  return k.createElement($1, Yd({}, t, { ref: e, sideCar: Xae }));
});
Az.classNames = $1.classNames;
const s2 = Az, kP = [
  "Enter",
  " "
], qae = [
  "ArrowDown",
  "PageUp",
  "Home"
], Oz = [
  "ArrowUp",
  "PageDown",
  "End"
], Qae = [
  ...qae,
  ...Oz
], Zae = {
  ltr: [
    ...kP,
    "ArrowRight"
  ],
  rtl: [
    ...kP,
    "ArrowLeft"
  ]
}, Jae = {
  ltr: [
    "ArrowLeft"
  ],
  rtl: [
    "ArrowRight"
  ]
}, M1 = "Menu", [ab, ese, tse] = E1(M1), [Hp, A1] = Nc(M1, [
  tse,
  R1,
  Cz
]), O1 = R1(), Dz = Cz(), [Nz, pf] = Hp(M1), [nse, Rb] = Hp(M1), rse = (t) => {
  const { __scopeMenu: e, open: n = !1, children: r, dir: a, onOpenChange: s, modal: c = !0 } = t, f = O1(e), [p, g] = k.useState(null), y = k.useRef(!1), v = Wo(s), S = JI(a);
  return k.useEffect(() => {
    const x = () => {
      y.current = !0, document.addEventListener("pointerdown", _, {
        capture: !0,
        once: !0
      }), document.addEventListener("pointermove", _, {
        capture: !0,
        once: !0
      });
    }, _ = () => y.current = !1;
    return document.addEventListener("keydown", x, {
      capture: !0
    }), () => {
      document.removeEventListener("keydown", x, {
        capture: !0
      }), document.removeEventListener("pointerdown", _, {
        capture: !0
      }), document.removeEventListener("pointermove", _, {
        capture: !0
      });
    };
  }, []), /* @__PURE__ */ k.createElement(i2, f, /* @__PURE__ */ k.createElement(Nz, {
    scope: e,
    open: n,
    onOpenChange: v,
    content: p,
    onContentChange: g
  }, /* @__PURE__ */ k.createElement(nse, {
    scope: e,
    onClose: k.useCallback(
      () => v(!1),
      [
        v
      ]
    ),
    isUsingKeyboardRef: y,
    dir: S,
    modal: c
  }, r)));
}, Lz = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeMenu: n, ...r } = t, a = O1(n);
  return /* @__PURE__ */ k.createElement(wz, qe({}, a, r, {
    ref: e
  }));
}), jz = "MenuPortal", [ise, zz] = Hp(jz, {
  forceMount: void 0
}), ose = (t) => {
  const { __scopeMenu: e, forceMount: n, children: r, container: a } = t, s = pf(jz, e);
  return /* @__PURE__ */ k.createElement(ise, {
    scope: e,
    forceMount: n
  }, /* @__PURE__ */ k.createElement(Nl, {
    present: n || s.open
  }, /* @__PURE__ */ k.createElement(_1, {
    asChild: !0,
    container: a
  }, r)));
}, Ml = "MenuContent", [ase, l2] = Hp(Ml), sse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = zz(Ml, t.__scopeMenu), { forceMount: r = n.forceMount, ...a } = t, s = pf(Ml, t.__scopeMenu), c = Rb(Ml, t.__scopeMenu);
  return /* @__PURE__ */ k.createElement(ab.Provider, {
    scope: t.__scopeMenu
  }, /* @__PURE__ */ k.createElement(Nl, {
    present: r || s.open
  }, /* @__PURE__ */ k.createElement(ab.Slot, {
    scope: t.__scopeMenu
  }, c.modal ? /* @__PURE__ */ k.createElement(lse, qe({}, a, {
    ref: e
  })) : /* @__PURE__ */ k.createElement(cse, qe({}, a, {
    ref: e
  })))));
}), lse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = pf(Ml, t.__scopeMenu), r = k.useRef(null), a = Rr(e, r);
  return k.useEffect(() => {
    const s = r.current;
    if (s)
      return a2(s);
  }, []), /* @__PURE__ */ k.createElement(c2, qe({}, t, {
    ref: a,
    trapFocus: n.open,
    disableOutsidePointerEvents: n.open,
    disableOutsideScroll: !0,
    onFocusOutside: _t(
      t.onFocusOutside,
      (s) => s.preventDefault(),
      {
        checkForDefaultPrevented: !1
      }
    ),
    onDismiss: () => n.onOpenChange(!1)
  }));
}), cse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = pf(Ml, t.__scopeMenu);
  return /* @__PURE__ */ k.createElement(c2, qe({}, t, {
    ref: e,
    trapFocus: !1,
    disableOutsidePointerEvents: !1,
    disableOutsideScroll: !1,
    onDismiss: () => n.onOpenChange(!1)
  }));
}), c2 = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeMenu: n, loop: r = !1, trapFocus: a, onOpenAutoFocus: s, onCloseAutoFocus: c, disableOutsidePointerEvents: f, onEntryFocus: p, onEscapeKeyDown: g, onPointerDownOutside: y, onFocusOutside: v, onInteractOutside: S, onDismiss: x, disableOutsideScroll: _, ...T } = t, I = pf(Ml, n), D = Rb(Ml, n), N = O1(n), j = Dz(n), L = ese(n), [z, F] = k.useState(null), K = k.useRef(null), X = Rr(e, K, I.onContentChange), se = k.useRef(0), ue = k.useRef(""), pe = k.useRef(0), Pe = k.useRef(null), ve = k.useRef("right"), Y = k.useRef(0), le = _ ? s2 : k.Fragment, Re = _ ? {
    as: Op,
    allowPinchZoom: !0
  } : void 0, he = (de) => {
    var W, fe;
    const ce = ue.current + de, xe = L().filter(
      (rt) => !rt.disabled
    ), $e = document.activeElement, Me = (W = xe.find(
      (rt) => rt.ref.current === $e
    )) === null || W === void 0 ? void 0 : W.textValue, re = xe.map(
      (rt) => rt.textValue
    ), Qe = Ese(re, ce, Me), ke = (fe = xe.find(
      (rt) => rt.textValue === Qe
    )) === null || fe === void 0 ? void 0 : fe.ref.current;
    (function rt(St) {
      ue.current = St, window.clearTimeout(se.current), St !== "" && (se.current = window.setTimeout(
        () => rt(""),
        1e3
      ));
    })(ce), ke && setTimeout(
      () => ke.focus()
    );
  };
  k.useEffect(() => () => window.clearTimeout(se.current), []), e2();
  const te = k.useCallback((de) => {
    var W, fe;
    return ve.current === ((W = Pe.current) === null || W === void 0 ? void 0 : W.side) && _se(de, (fe = Pe.current) === null || fe === void 0 ? void 0 : fe.area);
  }, []);
  return /* @__PURE__ */ k.createElement(ase, {
    scope: n,
    searchRef: ue,
    onItemEnter: k.useCallback((de) => {
      te(de) && de.preventDefault();
    }, [
      te
    ]),
    onItemLeave: k.useCallback((de) => {
      var W;
      te(de) || ((W = K.current) === null || W === void 0 || W.focus(), F(null));
    }, [
      te
    ]),
    onTriggerLeave: k.useCallback((de) => {
      te(de) && de.preventDefault();
    }, [
      te
    ]),
    pointerGraceTimerRef: pe,
    onPointerGraceIntentChange: k.useCallback((de) => {
      Pe.current = de;
    }, [])
  }, /* @__PURE__ */ k.createElement(le, Re, /* @__PURE__ */ k.createElement(t2, {
    asChild: !0,
    trapped: a,
    onMountAutoFocus: _t(s, (de) => {
      var W;
      de.preventDefault(), (W = K.current) === null || W === void 0 || W.focus();
    }),
    onUnmountAutoFocus: c
  }, /* @__PURE__ */ k.createElement(C1, {
    asChild: !0,
    disableOutsidePointerEvents: f,
    onEscapeKeyDown: g,
    onPointerDownOutside: y,
    onFocusOutside: v,
    onInteractOutside: S,
    onDismiss: x
  }, /* @__PURE__ */ k.createElement(cae, qe({
    asChild: !0
  }, j, {
    dir: D.dir,
    orientation: "vertical",
    loop: r,
    currentTabStopId: z,
    onCurrentTabStopIdChange: F,
    onEntryFocus: _t(p, (de) => {
      D.isUsingKeyboardRef.current || de.preventDefault();
    })
  }), /* @__PURE__ */ k.createElement(xz, qe({
    role: "menu",
    "aria-orientation": "vertical",
    "data-state": Yz(I.open),
    "data-radix-menu-content": "",
    dir: D.dir
  }, N, T, {
    ref: X,
    style: {
      outline: "none",
      ...T.style
    },
    onKeyDown: _t(T.onKeyDown, (de) => {
      const fe = de.target.closest("[data-radix-menu-content]") === de.currentTarget, ce = de.ctrlKey || de.altKey || de.metaKey, xe = de.key.length === 1;
      fe && (de.key === "Tab" && de.preventDefault(), !ce && xe && he(de.key));
      const $e = K.current;
      if (de.target !== $e || !Qae.includes(de.key))
        return;
      de.preventDefault();
      const re = L().filter(
        (Qe) => !Qe.disabled
      ).map(
        (Qe) => Qe.ref.current
      );
      Oz.includes(de.key) && re.reverse(), wse(re);
    }),
    onBlur: _t(t.onBlur, (de) => {
      de.currentTarget.contains(de.target) || (window.clearTimeout(se.current), ue.current = "");
    }),
    onPointerMove: _t(t.onPointerMove, sb((de) => {
      const W = de.target, fe = Y.current !== de.clientX;
      if (de.currentTarget.contains(W) && fe) {
        const ce = de.clientX > Y.current ? "right" : "left";
        ve.current = ce, Y.current = de.clientX;
      }
    }))
  })))))));
}), use = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeMenu: n, ...r } = t;
  return /* @__PURE__ */ k.createElement(pr.div, qe({
    role: "group"
  }, r, {
    ref: e
  }));
}), PP = "MenuItem", TN = "menu.itemSelect", Uz = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { disabled: n = !1, onSelect: r, ...a } = t, s = k.useRef(null), c = Rb(PP, t.__scopeMenu), f = l2(PP, t.__scopeMenu), p = Rr(e, s), g = k.useRef(!1), y = () => {
    const v = s.current;
    if (!n && v) {
      const S = new CustomEvent(TN, {
        bubbles: !0,
        cancelable: !0
      });
      v.addEventListener(
        TN,
        (x) => r?.(x),
        {
          once: !0
        }
      ), QI(v, S), S.defaultPrevented ? g.current = !1 : c.onClose();
    }
  };
  return /* @__PURE__ */ k.createElement(Bz, qe({}, a, {
    ref: p,
    disabled: n,
    onClick: _t(t.onClick, y),
    onPointerDown: (v) => {
      var S;
      (S = t.onPointerDown) === null || S === void 0 || S.call(t, v), g.current = !0;
    },
    onPointerUp: _t(t.onPointerUp, (v) => {
      var S;
      g.current || (S = v.currentTarget) === null || S === void 0 || S.click();
    }),
    onKeyDown: _t(t.onKeyDown, (v) => {
      const S = f.searchRef.current !== "";
      n || S && v.key === " " || kP.includes(v.key) && (v.currentTarget.click(), v.preventDefault());
    })
  }));
}), Bz = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeMenu: n, disabled: r = !1, textValue: a, ...s } = t, c = l2(PP, n), f = Dz(n), p = k.useRef(null), g = Rr(e, p), [y, v] = k.useState(!1), [S, x] = k.useState("");
  return k.useEffect(() => {
    const _ = p.current;
    if (_) {
      var T;
      x(((T = _.textContent) !== null && T !== void 0 ? T : "").trim());
    }
  }, [
    s.children
  ]), /* @__PURE__ */ k.createElement(ab.ItemSlot, {
    scope: n,
    disabled: r,
    textValue: a ?? S
  }, /* @__PURE__ */ k.createElement(uae, qe({
    asChild: !0
  }, f, {
    focusable: !r
  }), /* @__PURE__ */ k.createElement(pr.div, qe({
    role: "menuitem",
    "data-highlighted": y ? "" : void 0,
    "aria-disabled": r || void 0,
    "data-disabled": r ? "" : void 0
  }, s, {
    ref: g,
    onPointerMove: _t(t.onPointerMove, sb((_) => {
      r ? c.onItemLeave(_) : (c.onItemEnter(_), _.defaultPrevented || _.currentTarget.focus());
    })),
    onPointerLeave: _t(t.onPointerLeave, sb(
      (_) => c.onItemLeave(_)
    )),
    onFocus: _t(
      t.onFocus,
      () => v(!0)
    ),
    onBlur: _t(
      t.onBlur,
      () => v(!1)
    )
  }))));
}), dse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { checked: n = !1, onCheckedChange: r, ...a } = t;
  return /* @__PURE__ */ k.createElement(pse, {
    scope: t.__scopeMenu,
    checked: n
  }, /* @__PURE__ */ k.createElement(Uz, qe({
    role: "menuitemcheckbox",
    "aria-checked": Yx(n) ? "mixed" : n
  }, a, {
    ref: e,
    "data-state": Kz(n),
    onSelect: _t(
      a.onSelect,
      () => r?.(Yx(n) ? !0 : !n),
      {
        checkForDefaultPrevented: !1
      }
    )
  })));
}), fse = "MenuRadioGroup";
Hp(fse, {
  value: void 0,
  onValueChange: () => {
  }
});
const Fz = "MenuItemIndicator", [pse, hse] = Hp(Fz, {
  checked: !1
}), gse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeMenu: n, forceMount: r, ...a } = t, s = hse(Fz, n);
  return /* @__PURE__ */ k.createElement(Nl, {
    present: r || Yx(s.checked) || s.checked === !0
  }, /* @__PURE__ */ k.createElement(pr.span, qe({}, a, {
    ref: e,
    "data-state": Kz(s.checked)
  })));
}), Hz = "MenuSub", [mse, Vz] = Hp(Hz), vse = (t) => {
  const { __scopeMenu: e, children: n, open: r = !1, onOpenChange: a } = t, s = pf(Hz, e), c = O1(e), [f, p] = k.useState(null), [g, y] = k.useState(null), v = Wo(a);
  return k.useEffect(() => (s.open === !1 && v(!1), () => v(!1)), [
    s.open,
    v
  ]), /* @__PURE__ */ k.createElement(i2, c, /* @__PURE__ */ k.createElement(Nz, {
    scope: e,
    open: r,
    onOpenChange: v,
    content: g,
    onContentChange: y
  }, /* @__PURE__ */ k.createElement(mse, {
    scope: e,
    contentId: ju(),
    triggerId: ju(),
    trigger: f,
    onTriggerChange: p
  }, n)));
}, Zw = "MenuSubTrigger", yse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = pf(Zw, t.__scopeMenu), r = Rb(Zw, t.__scopeMenu), a = Vz(Zw, t.__scopeMenu), s = l2(Zw, t.__scopeMenu), c = k.useRef(null), { pointerGraceTimerRef: f, onPointerGraceIntentChange: p } = s, g = {
    __scopeMenu: t.__scopeMenu
  }, y = k.useCallback(() => {
    c.current && window.clearTimeout(c.current), c.current = null;
  }, []);
  return k.useEffect(
    () => y,
    [
      y
    ]
  ), k.useEffect(() => {
    const v = f.current;
    return () => {
      window.clearTimeout(v), p(null);
    };
  }, [
    f,
    p
  ]), /* @__PURE__ */ k.createElement(Lz, qe({
    asChild: !0
  }, g), /* @__PURE__ */ k.createElement(Bz, qe({
    id: a.triggerId,
    "aria-haspopup": "menu",
    "aria-expanded": n.open,
    "aria-controls": a.contentId,
    "data-state": Yz(n.open)
  }, t, {
    ref: x1(e, a.onTriggerChange),
    onClick: (v) => {
      var S;
      (S = t.onClick) === null || S === void 0 || S.call(t, v), !(t.disabled || v.defaultPrevented) && (v.currentTarget.focus(), n.open || n.onOpenChange(!0));
    },
    onPointerMove: _t(t.onPointerMove, sb((v) => {
      s.onItemEnter(v), !v.defaultPrevented && !t.disabled && !n.open && !c.current && (s.onPointerGraceIntentChange(null), c.current = window.setTimeout(() => {
        n.onOpenChange(!0), y();
      }, 100));
    })),
    onPointerLeave: _t(t.onPointerLeave, sb((v) => {
      var S;
      y();
      const x = (S = n.content) === null || S === void 0 ? void 0 : S.getBoundingClientRect();
      if (x) {
        var _;
        const T = (_ = n.content) === null || _ === void 0 ? void 0 : _.dataset.side, I = T === "right", D = I ? -5 : 5, N = x[I ? "left" : "right"], j = x[I ? "right" : "left"];
        s.onPointerGraceIntentChange({
          area: [
            // consistently within polygon bounds
            {
              x: v.clientX + D,
              y: v.clientY
            },
            {
              x: N,
              y: x.top
            },
            {
              x: j,
              y: x.top
            },
            {
              x: j,
              y: x.bottom
            },
            {
              x: N,
              y: x.bottom
            }
          ],
          side: T
        }), window.clearTimeout(f.current), f.current = window.setTimeout(
          () => s.onPointerGraceIntentChange(null),
          300
        );
      } else {
        if (s.onTriggerLeave(v), v.defaultPrevented)
          return;
        s.onPointerGraceIntentChange(null);
      }
    })),
    onKeyDown: _t(t.onKeyDown, (v) => {
      const S = s.searchRef.current !== "";
      if (!(t.disabled || S && v.key === " ") && Zae[r.dir].includes(v.key)) {
        var x;
        n.onOpenChange(!0), (x = n.content) === null || x === void 0 || x.focus(), v.preventDefault();
      }
    })
  })));
}), bse = "MenuSubContent", Sse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = zz(Ml, t.__scopeMenu), { forceMount: r = n.forceMount, ...a } = t, s = pf(Ml, t.__scopeMenu), c = Rb(Ml, t.__scopeMenu), f = Vz(bse, t.__scopeMenu), p = k.useRef(null), g = Rr(e, p);
  return /* @__PURE__ */ k.createElement(ab.Provider, {
    scope: t.__scopeMenu
  }, /* @__PURE__ */ k.createElement(Nl, {
    present: r || s.open
  }, /* @__PURE__ */ k.createElement(ab.Slot, {
    scope: t.__scopeMenu
  }, /* @__PURE__ */ k.createElement(c2, qe({
    id: f.contentId,
    "aria-labelledby": f.triggerId
  }, a, {
    ref: g,
    align: "start",
    side: c.dir === "rtl" ? "left" : "right",
    disableOutsidePointerEvents: !1,
    disableOutsideScroll: !1,
    trapFocus: !1,
    onOpenAutoFocus: (y) => {
      var v;
      c.isUsingKeyboardRef.current && ((v = p.current) === null || v === void 0 || v.focus()), y.preventDefault();
    },
    onCloseAutoFocus: (y) => y.preventDefault(),
    onFocusOutside: _t(t.onFocusOutside, (y) => {
      y.target !== f.trigger && s.onOpenChange(!1);
    }),
    onEscapeKeyDown: _t(t.onEscapeKeyDown, (y) => {
      c.onClose(), y.preventDefault();
    }),
    onKeyDown: _t(t.onKeyDown, (y) => {
      const v = y.currentTarget.contains(y.target), S = Jae[c.dir].includes(y.key);
      if (v && S) {
        var x;
        s.onOpenChange(!1), (x = f.trigger) === null || x === void 0 || x.focus(), y.preventDefault();
      }
    })
  })))));
});
function Yz(t) {
  return t ? "open" : "closed";
}
function Yx(t) {
  return t === "indeterminate";
}
function Kz(t) {
  return Yx(t) ? "indeterminate" : t ? "checked" : "unchecked";
}
function wse(t) {
  const e = document.activeElement;
  for (const n of t)
    if (n === e || (n.focus(), document.activeElement !== e))
      return;
}
function xse(t, e) {
  return t.map(
    (n, r) => t[(e + r) % t.length]
  );
}
function Ese(t, e, n) {
  const a = e.length > 1 && Array.from(e).every(
    (g) => g === e[0]
  ) ? e[0] : e, s = n ? t.indexOf(n) : -1;
  let c = xse(t, Math.max(s, 0));
  a.length === 1 && (c = c.filter(
    (g) => g !== n
  ));
  const p = c.find(
    (g) => g.toLowerCase().startsWith(a.toLowerCase())
  );
  return p !== n ? p : void 0;
}
function Cse(t, e) {
  const { x: n, y: r } = t;
  let a = !1;
  for (let s = 0, c = e.length - 1; s < e.length; c = s++) {
    const f = e[s].x, p = e[s].y, g = e[c].x, y = e[c].y;
    p > r != y > r && n < (g - f) * (r - p) / (y - p) + f && (a = !a);
  }
  return a;
}
function _se(t, e) {
  if (!e)
    return !1;
  const n = {
    x: t.clientX,
    y: t.clientY
  };
  return Cse(n, e);
}
function sb(t) {
  return (e) => e.pointerType === "mouse" ? t(e) : void 0;
}
const Wz = rse, Gz = Lz, Xz = ose, qz = sse, Qz = use, Zz = Uz, Jz = dse, Tse = gse, e4 = vse, t4 = yse, n4 = Sse, r4 = "ContextMenu", [kse, Jpe] = Nc(r4, [
  A1
]), Lc = A1(), [Pse, i4] = kse(r4), Ise = (t) => {
  const { __scopeContextMenu: e, children: n, onOpenChange: r, dir: a, modal: s = !0 } = t, [c, f] = k.useState(!1), p = Lc(e), g = Wo(r), y = k.useCallback((v) => {
    f(v), g(v);
  }, [
    g
  ]);
  return /* @__PURE__ */ k.createElement(Pse, {
    scope: e,
    open: c,
    onOpenChange: y,
    modal: s
  }, /* @__PURE__ */ k.createElement(Wz, qe({}, p, {
    dir: a,
    open: c,
    onOpenChange: y,
    modal: s
  }), n));
}, Rse = "ContextMenuTrigger", $se = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeContextMenu: n, disabled: r = !1, ...a } = t, s = i4(Rse, n), c = Lc(n), f = k.useRef({
    x: 0,
    y: 0
  }), p = k.useRef({
    getBoundingClientRect: () => DOMRect.fromRect({
      width: 0,
      height: 0,
      ...f.current
    })
  }), g = k.useRef(0), y = k.useCallback(
    () => window.clearTimeout(g.current),
    []
  ), v = (S) => {
    f.current = {
      x: S.clientX,
      y: S.clientY
    }, s.onOpenChange(!0);
  };
  return k.useEffect(
    () => y,
    [
      y
    ]
  ), k.useEffect(
    () => void (r && y()),
    [
      r,
      y
    ]
  ), /* @__PURE__ */ k.createElement(k.Fragment, null, /* @__PURE__ */ k.createElement(Gz, qe({}, c, {
    virtualRef: p
  })), /* @__PURE__ */ k.createElement(pr.span, qe({
    "data-state": s.open ? "open" : "closed",
    "data-disabled": r ? "" : void 0
  }, a, {
    ref: e,
    style: {
      WebkitTouchCallout: "none",
      ...t.style
    },
    onContextMenu: r ? t.onContextMenu : _t(t.onContextMenu, (S) => {
      y(), v(S), S.preventDefault();
    }),
    onPointerDown: r ? t.onPointerDown : _t(t.onPointerDown, Jw((S) => {
      y(), g.current = window.setTimeout(
        () => v(S),
        700
      );
    })),
    onPointerMove: r ? t.onPointerMove : _t(t.onPointerMove, Jw(y)),
    onPointerCancel: r ? t.onPointerCancel : _t(t.onPointerCancel, Jw(y)),
    onPointerUp: r ? t.onPointerUp : _t(t.onPointerUp, Jw(y))
  })));
}), Mse = (t) => {
  const { __scopeContextMenu: e, ...n } = t, r = Lc(e);
  return /* @__PURE__ */ k.createElement(Xz, qe({}, r, n));
}, Ase = "ContextMenuContent", Ose = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, a = i4(Ase, n), s = Lc(n), c = k.useRef(!1);
  return /* @__PURE__ */ k.createElement(qz, qe({}, s, r, {
    ref: e,
    side: "right",
    sideOffset: 2,
    align: "start",
    onCloseAutoFocus: (f) => {
      var p;
      (p = t.onCloseAutoFocus) === null || p === void 0 || p.call(t, f), !f.defaultPrevented && c.current && f.preventDefault(), c.current = !1;
    },
    onInteractOutside: (f) => {
      var p;
      (p = t.onInteractOutside) === null || p === void 0 || p.call(t, f), !f.defaultPrevented && !a.modal && (c.current = !0);
    },
    style: {
      ...t.style,
      "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }));
}), Dse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, a = Lc(n);
  return /* @__PURE__ */ k.createElement(Qz, qe({}, a, r, {
    ref: e
  }));
}), Nse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, a = Lc(n);
  return /* @__PURE__ */ k.createElement(Zz, qe({}, a, r, {
    ref: e
  }));
}), Lse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, a = Lc(n);
  return /* @__PURE__ */ k.createElement(Jz, qe({}, a, r, {
    ref: e
  }));
}), jse = (t) => {
  const { __scopeContextMenu: e, children: n, onOpenChange: r, open: a, defaultOpen: s } = t, c = Lc(e), [f, p] = ff({
    prop: a,
    defaultProp: s,
    onChange: r
  });
  return /* @__PURE__ */ k.createElement(e4, qe({}, c, {
    open: f,
    onOpenChange: p
  }), n);
}, zse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, a = Lc(n);
  return /* @__PURE__ */ k.createElement(t4, qe({}, a, r, {
    ref: e
  }));
}), Use = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, a = Lc(n);
  return /* @__PURE__ */ k.createElement(n4, qe({}, a, r, {
    ref: e,
    style: {
      ...t.style,
      "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }));
});
function Jw(t) {
  return (e) => e.pointerType !== "mouse" ? t(e) : void 0;
}
const Bse = Ise, Fse = $se, IP = Mse, Hse = Ose, RP = Dse, Kx = Nse, Vse = Lse, o4 = jse, a4 = zse, s4 = Use;
function u2(t) {
  return t.filter((e) => e != null && e !== !1);
}
function wn(t, ...e) {
  const n = u2(e);
  return n.length === 0 ? null : {
    id: t,
    type: "group",
    checkbox: n.every((r) => r.type === "item" && r.actionItem.checkbox),
    disabled: n.every((r) => r.disabled),
    readonlyOk: n.some((r) => r.readonlyOk),
    children: n
  };
}
function _c(t, e, ...n) {
  const r = u2(n);
  return r.length === 0 ? null : {
    id: t,
    type: "submenu",
    label: e,
    children: r,
    disabled: r.every((a) => a.disabled),
    readonlyOk: r.some((a) => a.readonlyOk)
  };
}
function Wx(t, e = {}) {
  const { readonlyOk: n = !0, disabled: r = !1 } = e;
  return {
    id: t,
    type: "custom",
    disabled: r,
    readonlyOk: n
  };
}
function Ie(t, e = {}) {
  if (!t)
    throw Error("No action item provided to menuItem");
  if (!t.label)
    throw Error("Trying to create menu item for action item that doesn't have a label");
  const { checked: n = !1, disabled: r = !1 } = e;
  return {
    id: t.id,
    type: "item",
    actionItem: t,
    disabled: r,
    checked: n,
    readonlyOk: t.readonlyOk
  };
}
function l4(t) {
  const { selectedIds: e } = t;
  return e.map((r) => t.getShapeById(r)).filter((r) => !(!r || ro.is(r) && r.props.start.type === "binding" || ro.is(r) && r.props.end.type === "binding"));
}
const c4 = () => {
  const t = Ge();
  return un("threeStackableItems", () => l4(t).length > 2, [t]);
}, d2 = () => {
  const t = Ge();
  return un("allowGroup", () => l4(t).length > 1, [t]);
}, f2 = () => {
  const t = Ge();
  return un(
    "allowUngroup",
    () => t.selectedIds.some((e) => t.getShapeById(e)?.type === "group"),
    []
  );
}, Yse = typeof window < "u" && "navigator" in window && !!navigator.clipboard && !!navigator.clipboard.read, Oy = (t, e, n) => t.meta?.geo ? e === "geo" && n === t.meta?.geo : e === t.id, u4 = "Dialog", [d4, ehe] = Nc(u4), [Kse, Fu] = d4(u4), Wse = (t) => {
  const { __scopeDialog: e, children: n, open: r, defaultOpen: a, onOpenChange: s, modal: c = !0 } = t, f = k.useRef(null), p = k.useRef(null), [g = !1, y] = ff({
    prop: r,
    defaultProp: a,
    onChange: s
  });
  return /* @__PURE__ */ k.createElement(Kse, {
    scope: e,
    triggerRef: f,
    contentRef: p,
    contentId: ju(),
    titleId: ju(),
    descriptionId: ju(),
    open: g,
    onOpenChange: y,
    onOpenToggle: k.useCallback(
      () => y(
        (v) => !v
      ),
      [
        y
      ]
    ),
    modal: c
  }, n);
}, f4 = "DialogPortal", [Gse, p4] = d4(f4, {
  forceMount: void 0
}), Xse = (t) => {
  const { __scopeDialog: e, forceMount: n, children: r, container: a } = t, s = Fu(f4, e);
  return /* @__PURE__ */ k.createElement(Gse, {
    scope: e,
    forceMount: n
  }, k.Children.map(
    r,
    (c) => /* @__PURE__ */ k.createElement(Nl, {
      present: n || s.open
    }, /* @__PURE__ */ k.createElement(_1, {
      asChild: !0,
      container: a
    }, c))
  ));
}, $P = "DialogOverlay", qse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = p4($P, t.__scopeDialog), { forceMount: r = n.forceMount, ...a } = t, s = Fu($P, t.__scopeDialog);
  return s.modal ? /* @__PURE__ */ k.createElement(Nl, {
    present: r || s.open
  }, /* @__PURE__ */ k.createElement(Qse, qe({}, a, {
    ref: e
  }))) : null;
}), Qse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDialog: n, ...r } = t, a = Fu($P, n);
  return (
    // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
    // ie. when `Overlay` and `Content` are siblings
    /* @__PURE__ */ k.createElement(s2, {
      as: Op,
      allowPinchZoom: !0,
      shards: [
        a.contentRef
      ]
    }, /* @__PURE__ */ k.createElement(pr.div, qe({
      "data-state": g4(a.open)
    }, r, {
      ref: e,
      style: {
        pointerEvents: "auto",
        ...r.style
      }
    })))
  );
}), lb = "DialogContent", Zse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = p4(lb, t.__scopeDialog), { forceMount: r = n.forceMount, ...a } = t, s = Fu(lb, t.__scopeDialog);
  return /* @__PURE__ */ k.createElement(Nl, {
    present: r || s.open
  }, s.modal ? /* @__PURE__ */ k.createElement(Jse, qe({}, a, {
    ref: e
  })) : /* @__PURE__ */ k.createElement(ele, qe({}, a, {
    ref: e
  })));
}), Jse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = Fu(lb, t.__scopeDialog), r = k.useRef(null), a = Rr(e, n.contentRef, r);
  return k.useEffect(() => {
    const s = r.current;
    if (s)
      return a2(s);
  }, []), /* @__PURE__ */ k.createElement(h4, qe({}, t, {
    ref: a,
    trapFocus: n.open,
    disableOutsidePointerEvents: !0,
    onCloseAutoFocus: _t(t.onCloseAutoFocus, (s) => {
      var c;
      s.preventDefault(), (c = n.triggerRef.current) === null || c === void 0 || c.focus();
    }),
    onPointerDownOutside: _t(t.onPointerDownOutside, (s) => {
      const c = s.detail.originalEvent, f = c.button === 0 && c.ctrlKey === !0;
      (c.button === 2 || f) && s.preventDefault();
    }),
    onFocusOutside: _t(
      t.onFocusOutside,
      (s) => s.preventDefault()
    )
  }));
}), ele = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = Fu(lb, t.__scopeDialog), r = k.useRef(!1), a = k.useRef(!1);
  return /* @__PURE__ */ k.createElement(h4, qe({}, t, {
    ref: e,
    trapFocus: !1,
    disableOutsidePointerEvents: !1,
    onCloseAutoFocus: (s) => {
      var c;
      if ((c = t.onCloseAutoFocus) === null || c === void 0 || c.call(t, s), !s.defaultPrevented) {
        var f;
        r.current || (f = n.triggerRef.current) === null || f === void 0 || f.focus(), s.preventDefault();
      }
      r.current = !1, a.current = !1;
    },
    onInteractOutside: (s) => {
      var c, f;
      (c = t.onInteractOutside) === null || c === void 0 || c.call(t, s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (a.current = !0));
      const p = s.target;
      ((f = n.triggerRef.current) === null || f === void 0 ? void 0 : f.contains(p)) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && a.current && s.preventDefault();
    }
  }));
}), h4 = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: a, onCloseAutoFocus: s, ...c } = t, f = Fu(lb, n), p = k.useRef(null), g = Rr(e, p);
  return e2(), /* @__PURE__ */ k.createElement(k.Fragment, null, /* @__PURE__ */ k.createElement(t2, {
    asChild: !0,
    loop: !0,
    trapped: r,
    onMountAutoFocus: a,
    onUnmountAutoFocus: s
  }, /* @__PURE__ */ k.createElement(C1, qe({
    role: "dialog",
    id: f.contentId,
    "aria-describedby": f.descriptionId,
    "aria-labelledby": f.titleId,
    "data-state": g4(f.open)
  }, c, {
    ref: g,
    onDismiss: () => f.onOpenChange(!1)
  }))), !1);
}), tle = "DialogTitle", nle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDialog: n, ...r } = t, a = Fu(tle, n);
  return /* @__PURE__ */ k.createElement(pr.h2, qe({
    id: a.titleId
  }, r, {
    ref: e
  }));
}), rle = "DialogClose", ile = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDialog: n, ...r } = t, a = Fu(rle, n);
  return /* @__PURE__ */ k.createElement(pr.button, qe({
    type: "button"
  }, r, {
    ref: e,
    onClick: _t(
      t.onClick,
      () => a.onOpenChange(!1)
    )
  }));
});
function g4(t) {
  return t ? "open" : "closed";
}
const ole = Wse, ale = Xse, sle = qse, lle = Zse;
function cle(t) {
  return /* @__PURE__ */ E.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", ...t, children: /* @__PURE__ */ E.jsxs("g", { strokeWidth: 2, fill: "none", fillRule: "evenodd", children: [
    /* @__PURE__ */ E.jsx("circle", { strokeOpacity: 0.25, cx: 8, cy: 8, r: 7, stroke: "currentColor" }),
    /* @__PURE__ */ E.jsx("path", { strokeLinecap: "round", d: "M15 8c0-4.5-4.5-7-7-7", stroke: "currentColor", children: /* @__PURE__ */ E.jsx(
      "animateTransform",
      {
        attributeName: "transform",
        type: "rotate",
        from: "0 8 8",
        to: "360 8 8",
        dur: "1s",
        repeatCount: "indefinite"
      }
    ) })
  ] }) });
}
const Wa = k.forwardRef(function({ small: e, invertIcon: n, icon: r, className: a, ...s }, c) {
  const f = U1();
  return /* @__PURE__ */ E.jsx(
    "div",
    {
      ref: c,
      ...s,
      className: $n("tlui-icon", { "tlui-icon__small": e }, a),
      style: {
        mask: `url(${f.icons[r]}) center 100% / 100% no-repeat`,
        WebkitMask: `url(${f.icons[r]}) center 100% / 100% no-repeat`,
        backgroundColor: "currentcolor",
        transform: n ? "scale(-1, 1)" : void 0
      }
    }
  );
}), m4 = typeof window > "u" ? !1 : window.navigator.userAgent.toLowerCase().indexOf("mac") > -1, v4 = m4 ? "⌘" : "Ctrl", y4 = m4 ? "⌥" : "Alt";
function ule(t) {
  return t.split(",")[0].split("").map((e) => {
    const n = e.replace(/\$/g, v4).replace(/\?/g, y4).replace(/!/g, "⇧");
    return n[0].toUpperCase() + n.slice(1);
  });
}
function Ic(t) {
  return "— " + t.split(",")[0].split("").map((e) => {
    const n = e.replace(/\$/g, v4).replace(/\?/g, y4).replace(/!/g, "⇧");
    return n[0].toUpperCase() + n.slice(1);
  }).join(" ");
}
function D1({ children: t }) {
  return /* @__PURE__ */ E.jsx("kbd", { className: "tlui-kbd", children: ule(t).map((e, n) => /* @__PURE__ */ E.jsx("span", { children: e }, n)) });
}
const At = k.forwardRef(function({
  label: e,
  icon: n,
  invertIcon: r,
  iconLeft: a,
  smallIcon: s,
  kbd: c,
  isChecked: f = !1,
  type: p = "normal",
  children: g,
  spinner: y,
  ...v
}, S) {
  const x = Fn(), _ = e ? x(e) : "";
  return /* @__PURE__ */ E.jsxs(
    "button",
    {
      ref: S,
      draggable: !1,
      type: "button",
      ...v,
      title: v.title ?? _,
      className: $n("tlui-button", `tlui-button__${p}`, v.className),
      children: [
        a && /* @__PURE__ */ E.jsx(Wa, { icon: a, className: "tlui-icon-left", small: !0 }),
        g,
        e && /* @__PURE__ */ E.jsxs("span", { draggable: !1, children: [
          _,
          f && /* @__PURE__ */ E.jsx(Wa, { icon: "check" })
        ] }),
        c && /* @__PURE__ */ E.jsx(D1, { children: c }),
        n && !y && /* @__PURE__ */ E.jsx(Wa, { icon: n, small: !!e || s, invertIcon: r }),
        y && /* @__PURE__ */ E.jsx(cle, {})
      ]
    }
  );
});
function N1({ className: t, children: e }) {
  return /* @__PURE__ */ E.jsx("div", { className: $n("tlui-dialog__header", t), children: e });
}
function L1({ className: t, children: e }) {
  return /* @__PURE__ */ E.jsx(nle, { dir: "ltr", className: $n("tlui-dialog__header__title", t), children: e });
}
function j1() {
  return /* @__PURE__ */ E.jsx("div", { className: "tlui-dialog__header__close", children: /* @__PURE__ */ E.jsx(ile, { "data-wd": "dialog.close", dir: "ltr", asChild: !0, children: /* @__PURE__ */ E.jsx(At, { "aria-label": "Close", onTouchEnd: (t) => t.target.click(), children: /* @__PURE__ */ E.jsx(Wa, { small: !0, icon: "cross-2" }) }) }) });
}
function cb({
  className: t,
  children: e,
  style: n
}) {
  return /* @__PURE__ */ E.jsx("div", { className: $n("tlui-dialog__body", t), style: n, children: e });
}
function p2({ className: t, children: e }) {
  return /* @__PURE__ */ E.jsx("div", { className: $n("tlui-dialog__footer", t), children: e });
}
const b4 = "DropdownMenu", [dle, the] = Nc(b4, [
  A1
]), Ll = A1(), [fle, S4] = dle(b4), ple = (t) => {
  const { __scopeDropdownMenu: e, children: n, dir: r, open: a, defaultOpen: s, onOpenChange: c, modal: f = !0 } = t, p = Ll(e), g = k.useRef(null), [y = !1, v] = ff({
    prop: a,
    defaultProp: s,
    onChange: c
  });
  return /* @__PURE__ */ k.createElement(fle, {
    scope: e,
    triggerId: ju(),
    triggerRef: g,
    contentId: ju(),
    open: y,
    onOpenChange: v,
    onOpenToggle: k.useCallback(
      () => v(
        (S) => !S
      ),
      [
        v
      ]
    ),
    modal: f
  }, /* @__PURE__ */ k.createElement(Wz, qe({}, p, {
    open: y,
    onOpenChange: v,
    dir: r,
    modal: f
  }), n));
}, hle = "DropdownMenuTrigger", gle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, disabled: r = !1, ...a } = t, s = S4(hle, n), c = Ll(n);
  return /* @__PURE__ */ k.createElement(Gz, qe({
    asChild: !0
  }, c), /* @__PURE__ */ k.createElement(pr.button, qe({
    type: "button",
    id: s.triggerId,
    "aria-haspopup": "menu",
    "aria-expanded": s.open,
    "aria-controls": s.open ? s.contentId : void 0,
    "data-state": s.open ? "open" : "closed",
    "data-disabled": r ? "" : void 0,
    disabled: r
  }, a, {
    ref: x1(e, s.triggerRef),
    onPointerDown: _t(t.onPointerDown, (f) => {
      !r && f.button === 0 && f.ctrlKey === !1 && (s.onOpenToggle(), s.open || f.preventDefault());
    }),
    onKeyDown: _t(t.onKeyDown, (f) => {
      r || ([
        "Enter",
        " "
      ].includes(f.key) && s.onOpenToggle(), f.key === "ArrowDown" && s.onOpenChange(!0), [
        "Enter",
        " ",
        "ArrowDown"
      ].includes(f.key) && f.preventDefault());
    })
  })));
}), mle = (t) => {
  const { __scopeDropdownMenu: e, ...n } = t, r = Ll(e);
  return /* @__PURE__ */ k.createElement(Xz, qe({}, r, n));
}, vle = "DropdownMenuContent", yle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, a = S4(vle, n), s = Ll(n), c = k.useRef(!1);
  return /* @__PURE__ */ k.createElement(qz, qe({
    id: a.contentId,
    "aria-labelledby": a.triggerId
  }, s, r, {
    ref: e,
    onCloseAutoFocus: _t(t.onCloseAutoFocus, (f) => {
      var p;
      c.current || (p = a.triggerRef.current) === null || p === void 0 || p.focus(), c.current = !1, f.preventDefault();
    }),
    onInteractOutside: _t(t.onInteractOutside, (f) => {
      const p = f.detail.originalEvent, g = p.button === 0 && p.ctrlKey === !0, y = p.button === 2 || g;
      (!a.modal || y) && (c.current = !0);
    }),
    style: {
      ...t.style,
      "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }));
}), ble = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, a = Ll(n);
  return /* @__PURE__ */ k.createElement(Qz, qe({}, a, r, {
    ref: e
  }));
}), Sle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, a = Ll(n);
  return /* @__PURE__ */ k.createElement(Zz, qe({}, a, r, {
    ref: e
  }));
}), wle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, a = Ll(n);
  return /* @__PURE__ */ k.createElement(Jz, qe({}, a, r, {
    ref: e
  }));
}), xle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, a = Ll(n);
  return /* @__PURE__ */ k.createElement(Tse, qe({}, a, r, {
    ref: e
  }));
}), Ele = (t) => {
  const { __scopeDropdownMenu: e, children: n, open: r, onOpenChange: a, defaultOpen: s } = t, c = Ll(e), [f = !1, p] = ff({
    prop: r,
    defaultProp: s,
    onChange: a
  });
  return /* @__PURE__ */ k.createElement(e4, qe({}, c, {
    open: f,
    onOpenChange: p
  }), n);
}, Cle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, a = Ll(n);
  return /* @__PURE__ */ k.createElement(t4, qe({}, a, r, {
    ref: e
  }));
}), _le = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, a = Ll(n);
  return /* @__PURE__ */ k.createElement(n4, qe({}, a, r, {
    ref: e,
    style: {
      ...t.style,
      "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }));
}), w4 = ple, ub = gle, h2 = mle, x4 = yle, Tle = ble, Ug = Sle, E4 = wle, kle = xle, Ple = Ele, Ile = Cle, Rle = _le;
function of({
  id: t,
  open: e,
  children: n,
  modal: r = !1
}) {
  const a = gm(t);
  return /* @__PURE__ */ E.jsx(w4, { open: e, dir: "ltr", modal: r, onOpenChange: a, children: n });
}
function $b({ children: t, "data-wd": e }) {
  return /* @__PURE__ */ E.jsx(ub, { dir: "ltr", "data-wd": e, asChild: !0, children: t });
}
function af({
  side: t = "bottom",
  align: e = "start",
  sideOffset: n = 8,
  alignOffset: r = 8,
  children: a
}) {
  const s = va();
  return /* @__PURE__ */ E.jsx(h2, { dir: "ltr", container: s, children: /* @__PURE__ */ E.jsx(
    x4,
    {
      className: "tlui-menu",
      align: e,
      sideOffset: n,
      side: t,
      alignOffset: r,
      collisionPadding: 4,
      children: a
    }
  ) });
}
function g2({ id: t, children: e, open: n }) {
  const r = gm(t);
  return /* @__PURE__ */ E.jsx(Ple, { open: n, onOpenChange: r, children: e });
}
function m2({
  label: t,
  "data-wd": e,
  "data-direction": n
}) {
  return /* @__PURE__ */ E.jsx(Ile, { dir: "ltr", "data-direction": n, "data-wd": e, asChild: !0, children: /* @__PURE__ */ E.jsx(
    At,
    {
      className: "tlui-menu__button tlui-menu__submenu__trigger",
      label: t,
      icon: "chevron-right"
    }
  ) });
}
function v2({
  alignOffset: t = 0,
  sideOffset: e = 5,
  children: n
}) {
  const r = va();
  return /* @__PURE__ */ E.jsx(h2, { container: r, dir: "ltr", children: /* @__PURE__ */ E.jsx(
    Rle,
    {
      className: "tlui-menu tlui-menu__submenu__content",
      alignOffset: t,
      sideOffset: e,
      collisionPadding: 4,
      children: n
    }
  ) });
}
function Lp({
  children: t,
  size: e = "medium"
}) {
  return /* @__PURE__ */ E.jsx(Tle, { dir: "ltr", className: "tlui-menu__group", "data-size": e, children: t });
}
function Ko({ noClose: t, ...e }) {
  return /* @__PURE__ */ E.jsx(
    Ug,
    {
      dir: "ltr",
      asChild: !0,
      onClick: t || e.isChecked !== void 0 ? Gn : void 0,
      children: /* @__PURE__ */ E.jsx(At, { className: "tlui-menu__button", ...e })
    }
  );
}
function $le({ children: t, onSelect: e, ...n }) {
  return /* @__PURE__ */ E.jsxs(
    E4,
    {
      dir: "ltr",
      className: "tlui-button tlui-menu__button tlui-menu__checkbox-item",
      onSelect: (r) => {
        e?.(r), Gn(r);
      },
      ...n,
      children: [
        /* @__PURE__ */ E.jsx(
          "div",
          {
            className: "tlui-menu__checkbox-item__check",
            style: {
              transformOrigin: "75% center",
              transform: `scale(${n.checked ? 1 : 0.5})`,
              opacity: n.checked ? 1 : 0.5
            },
            children: /* @__PURE__ */ E.jsx(Wa, { small: !0, icon: n.checked ? "check" : "checkbox-empty" })
          }
        ),
        t
      ]
    }
  );
}
function Mle({ children: t, onSelect: e, ...n }) {
  return /* @__PURE__ */ E.jsxs(
    E4,
    {
      dir: "ltr",
      className: "tlui-button tlui-menu__button tlui-menu__checkbox-item",
      onSelect: (r) => {
        e?.(r), Gn(r);
      },
      ...n,
      children: [
        /* @__PURE__ */ E.jsx(kle, { dir: "ltr", className: "tlui-menu__checkbox-item__check", children: /* @__PURE__ */ E.jsx(Wa, { icon: "check" }) }),
        t
      ]
    }
  );
}
function Ale(t) {
  const {
    items: e,
    title: n,
    styleType: r,
    value: a = null,
    onValueChange: s,
    columns: c = e.length < 4 ? 2 : 4
  } = t, f = Ge(), p = Fn(), g = k.useRef(!1), {
    handleButtonClick: y,
    handleButtonPointerDown: v,
    handleButtonPointerEnter: S,
    handleButtonPointerUp: x
  } = k.useMemo(() => {
    const _ = () => {
      g.current = !1, window.removeEventListener("pointerup", _);
    };
    return {
      handleButtonClick: (j) => {
        const { id: L } = j.currentTarget.dataset;
        a !== L && (f.mark("point picker item"), s(e.find((z) => z.id === L), !1));
      },
      handleButtonPointerDown: (j) => {
        const { id: L } = j.currentTarget.dataset;
        f.mark("point picker item"), s(e.find((z) => z.id === L), !0), g.current = !0, window.addEventListener("pointerup", _);
      },
      handleButtonPointerEnter: (j) => {
        if (!g.current)
          return;
        const { id: L } = j.currentTarget.dataset;
        s(e.find((z) => z.id === L), !0);
      },
      handleButtonPointerUp: (j) => {
        const { id: L } = j.currentTarget.dataset;
        s(e.find((z) => z.id === L), !1);
      }
    };
  }, [f, a, s, e]);
  return /* @__PURE__ */ E.jsx(
    "div",
    {
      className: $n("tlui-button-grid", {
        "tlui-button-grid__two": c === 2,
        "tlui-button-grid__three": c === 3,
        "tlui-button-grid__four": c === 4
      }),
      children: e.map((_) => /* @__PURE__ */ E.jsx(
        At,
        {
          "data-id": _.id,
          "data-wd": `${t["data-wd"]}.${_.id}`,
          "aria-label": _.id,
          "data-state": a === _.id ? "hinted" : void 0,
          title: n + " — " + p(`${r}-style.${_.id}`),
          className: $n("tlui-button-grid__button"),
          style: _.type === "color" ? { color: `var(--palette-${_.id})` } : void 0,
          onPointerEnter: S,
          onPointerDown: v,
          onPointerUp: x,
          onClick: y,
          icon: _.icon
        },
        _.id
      ))
    }
  );
}
const Yg = k.memo(Ale), y2 = k.forwardRef(function({
  className: e,
  label: n,
  icon: r,
  iconLeft: a,
  autoselect: s = !1,
  autofocus: c = !1,
  defaultValue: f,
  placeholder: p,
  onComplete: g,
  onValueChange: y,
  onCancel: v,
  shouldManuallyMaintainScrollPositionWhenFocused: S = !1,
  children: x
}, _) {
  const T = k.useRef(null);
  k.useImperativeHandle(_, () => T.current);
  const I = Fn(), D = k.useRef(f ?? ""), N = k.useRef(f ?? ""), [j, L] = k.useState(!1), z = k.useCallback(
    (se) => {
      L(!0);
      const ue = se.currentTarget;
      N.current = ue.value, requestAnimationFrame(() => {
        s && ue.select();
      });
    },
    [s]
  ), F = k.useCallback(
    (se) => {
      const ue = se.currentTarget.value;
      N.current = ue, y?.(ue);
    },
    [y]
  ), K = k.useCallback(
    (se) => {
      switch (se.key) {
        case "Enter": {
          se.currentTarget.blur(), se.stopPropagation(), g?.(se.currentTarget.value);
          break;
        }
        case "Escape": {
          se.currentTarget.value = D.current, se.currentTarget.blur(), se.stopPropagation(), v?.(se.currentTarget.value);
          break;
        }
      }
    },
    [g, v]
  ), X = k.useCallback(() => L(!1), []);
  return k.useEffect(() => {
    const se = window.visualViewport;
    if (j && S && se) {
      const ue = () => {
        T.current?.scrollIntoView({ block: "center" });
      };
      return se.addEventListener("resize", ue), se.addEventListener("scroll", ue), requestAnimationFrame(() => {
        T.current?.scrollIntoView({ block: "center" });
      }), () => {
        se.removeEventListener("resize", ue), se.removeEventListener("scroll", ue);
      };
    }
  }, [j, S]), /* @__PURE__ */ E.jsxs("div", { draggable: !1, className: "tlui-input__wrapper", children: [
    x,
    n && /* @__PURE__ */ E.jsx("label", { children: I(n) }),
    a && /* @__PURE__ */ E.jsx(Wa, { icon: a, className: "tlui-icon-left", small: !0 }),
    /* @__PURE__ */ E.jsx(
      "input",
      {
        ref: T,
        className: $n("tlui-input", e),
        type: "text",
        defaultValue: f,
        onKeyUp: K,
        onChange: F,
        onFocus: z,
        onBlur: X,
        autoFocus: c,
        placeholder: p
      }
    ),
    r && /* @__PURE__ */ E.jsx(Wa, { icon: r, small: !!n })
  ] });
});
function C4(t, [e, n]) {
  return Math.min(n, Math.max(e, t));
}
function Ole(t) {
  const e = k.useRef({
    value: t,
    previous: t
  });
  return k.useMemo(() => (e.current.value !== t && (e.current.previous = e.current.value, e.current.value = t), e.current.previous), [
    t
  ]);
}
const _4 = [
  "PageUp",
  "PageDown"
], T4 = [
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight"
], k4 = {
  "from-left": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowLeft"
  ],
  "from-right": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowRight"
  ],
  "from-bottom": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowLeft"
  ],
  "from-top": [
    "Home",
    "PageDown",
    "ArrowUp",
    "ArrowLeft"
  ]
}, Mb = "Slider", [MP, Dle, Nle] = E1(Mb), [P4, nhe] = Nc(Mb, [
  Nle
]), [Lle, z1] = P4(Mb), jle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { name: n, min: r = 0, max: a = 100, step: s = 1, orientation: c = "horizontal", disabled: f = !1, minStepsBetweenThumbs: p = 0, defaultValue: g = [
    r
  ], value: y, onValueChange: v = () => {
  }, onValueCommit: S = () => {
  }, inverted: x = !1, ..._ } = t, [T, I] = k.useState(null), D = Rr(
    e,
    (Y) => I(Y)
  ), N = k.useRef(/* @__PURE__ */ new Set()), j = k.useRef(0), L = c === "horizontal", z = T ? !!T.closest("form") : !0, F = L ? zle : Ule, [K = [], X] = ff({
    prop: y,
    defaultProp: g,
    onChange: (Y) => {
      var le;
      (le = [
        ...N.current
      ][j.current]) === null || le === void 0 || le.focus(), v(Y);
    }
  }), se = k.useRef(K);
  function ue(Y) {
    const le = Xle(K, Y);
    ve(Y, le);
  }
  function pe(Y) {
    ve(Y, j.current);
  }
  function Pe() {
    const Y = se.current[j.current];
    K[j.current] !== Y && S(K);
  }
  function ve(Y, le, { commit: Re } = {
    commit: !1
  }) {
    const he = Jle(s), te = ece(Math.round((Y - r) / s) * s + r, he), de = C4(te, [
      r,
      a
    ]);
    X((W = []) => {
      const fe = Wle(W, de, le);
      if (Zle(fe, p * s)) {
        j.current = fe.indexOf(de);
        const ce = String(fe) !== String(W);
        return ce && Re && S(fe), ce ? fe : W;
      } else
        return W;
    });
  }
  return /* @__PURE__ */ k.createElement(Lle, {
    scope: t.__scopeSlider,
    disabled: f,
    min: r,
    max: a,
    valueIndexToChangeRef: j,
    thumbs: N.current,
    values: K,
    orientation: c
  }, /* @__PURE__ */ k.createElement(MP.Provider, {
    scope: t.__scopeSlider
  }, /* @__PURE__ */ k.createElement(MP.Slot, {
    scope: t.__scopeSlider
  }, /* @__PURE__ */ k.createElement(F, qe({
    "aria-disabled": f,
    "data-disabled": f ? "" : void 0
  }, _, {
    ref: D,
    onPointerDown: _t(_.onPointerDown, () => {
      f || (se.current = K);
    }),
    min: r,
    max: a,
    inverted: x,
    onSlideStart: f ? void 0 : ue,
    onSlideMove: f ? void 0 : pe,
    onSlideEnd: f ? void 0 : Pe,
    onHomeKeyDown: () => !f && ve(r, 0, {
      commit: !0
    }),
    onEndKeyDown: () => !f && ve(a, K.length - 1, {
      commit: !0
    }),
    onStepKeyDown: ({ event: Y, direction: le }) => {
      if (!f) {
        const te = _4.includes(Y.key) || Y.shiftKey && T4.includes(Y.key) ? 10 : 1, de = j.current, W = K[de], fe = s * te * le;
        ve(W + fe, de, {
          commit: !0
        });
      }
    }
  })))), z && K.map(
    (Y, le) => /* @__PURE__ */ k.createElement(Kle, {
      key: le,
      name: n ? n + (K.length > 1 ? "[]" : "") : void 0,
      value: Y
    })
  ));
}), [I4, R4] = P4(Mb, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), zle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { min: n, max: r, dir: a, inverted: s, onSlideStart: c, onSlideMove: f, onSlideEnd: p, onStepKeyDown: g, ...y } = t, [v, S] = k.useState(null), x = Rr(
    e,
    (j) => S(j)
  ), _ = k.useRef(), T = JI(a), I = T === "ltr", D = I && !s || !I && s;
  function N(j) {
    const L = _.current || v.getBoundingClientRect(), z = [
      0,
      L.width
    ], K = b2(z, D ? [
      n,
      r
    ] : [
      r,
      n
    ]);
    return _.current = L, K(j - L.left);
  }
  return /* @__PURE__ */ k.createElement(I4, {
    scope: t.__scopeSlider,
    startEdge: D ? "left" : "right",
    endEdge: D ? "right" : "left",
    direction: D ? 1 : -1,
    size: "width"
  }, /* @__PURE__ */ k.createElement($4, qe({
    dir: T,
    "data-orientation": "horizontal"
  }, y, {
    ref: x,
    style: {
      ...y.style,
      ["--radix-slider-thumb-transform"]: "translateX(-50%)"
    },
    onSlideStart: (j) => {
      const L = N(j.clientX);
      c?.(L);
    },
    onSlideMove: (j) => {
      const L = N(j.clientX);
      f?.(L);
    },
    onSlideEnd: () => {
      _.current = void 0, p?.();
    },
    onStepKeyDown: (j) => {
      const z = k4[D ? "from-left" : "from-right"].includes(j.key);
      g?.({
        event: j,
        direction: z ? -1 : 1
      });
    }
  })));
}), Ule = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { min: n, max: r, inverted: a, onSlideStart: s, onSlideMove: c, onSlideEnd: f, onStepKeyDown: p, ...g } = t, y = k.useRef(null), v = Rr(e, y), S = k.useRef(), x = !a;
  function _(T) {
    const I = S.current || y.current.getBoundingClientRect(), D = [
      0,
      I.height
    ], j = b2(D, x ? [
      r,
      n
    ] : [
      n,
      r
    ]);
    return S.current = I, j(T - I.top);
  }
  return /* @__PURE__ */ k.createElement(I4, {
    scope: t.__scopeSlider,
    startEdge: x ? "bottom" : "top",
    endEdge: x ? "top" : "bottom",
    size: "height",
    direction: x ? 1 : -1
  }, /* @__PURE__ */ k.createElement($4, qe({
    "data-orientation": "vertical"
  }, g, {
    ref: v,
    style: {
      ...g.style,
      ["--radix-slider-thumb-transform"]: "translateY(50%)"
    },
    onSlideStart: (T) => {
      const I = _(T.clientY);
      s?.(I);
    },
    onSlideMove: (T) => {
      const I = _(T.clientY);
      c?.(I);
    },
    onSlideEnd: () => {
      S.current = void 0, f?.();
    },
    onStepKeyDown: (T) => {
      const D = k4[x ? "from-bottom" : "from-top"].includes(T.key);
      p?.({
        event: T,
        direction: D ? -1 : 1
      });
    }
  })));
}), $4 = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeSlider: n, onSlideStart: r, onSlideMove: a, onSlideEnd: s, onHomeKeyDown: c, onEndKeyDown: f, onStepKeyDown: p, ...g } = t, y = z1(Mb, n);
  return /* @__PURE__ */ k.createElement(pr.span, qe({}, g, {
    ref: e,
    onKeyDown: _t(t.onKeyDown, (v) => {
      v.key === "Home" ? (c(v), v.preventDefault()) : v.key === "End" ? (f(v), v.preventDefault()) : _4.concat(T4).includes(v.key) && (p(v), v.preventDefault());
    }),
    onPointerDown: _t(t.onPointerDown, (v) => {
      const S = v.target;
      S.setPointerCapture(v.pointerId), v.preventDefault(), y.thumbs.has(S) ? S.focus() : r(v);
    }),
    onPointerMove: _t(t.onPointerMove, (v) => {
      v.target.hasPointerCapture(v.pointerId) && a(v);
    }),
    onPointerUp: _t(t.onPointerUp, (v) => {
      const S = v.target;
      S.hasPointerCapture(v.pointerId) && (S.releasePointerCapture(v.pointerId), s(v));
    })
  }));
}), Ble = "SliderTrack", Fle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeSlider: n, ...r } = t, a = z1(Ble, n);
  return /* @__PURE__ */ k.createElement(pr.span, qe({
    "data-disabled": a.disabled ? "" : void 0,
    "data-orientation": a.orientation
  }, r, {
    ref: e
  }));
}), kN = "SliderRange", Hle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeSlider: n, ...r } = t, a = z1(kN, n), s = R4(kN, n), c = k.useRef(null), f = Rr(e, c), p = a.values.length, g = a.values.map(
    (S) => M4(S, a.min, a.max)
  ), y = p > 1 ? Math.min(...g) : 0, v = 100 - Math.max(...g);
  return /* @__PURE__ */ k.createElement(pr.span, qe({
    "data-orientation": a.orientation,
    "data-disabled": a.disabled ? "" : void 0
  }, r, {
    ref: f,
    style: {
      ...t.style,
      [s.startEdge]: y + "%",
      [s.endEdge]: v + "%"
    }
  }));
}), PN = "SliderThumb", Vle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = Dle(t.__scopeSlider), [r, a] = k.useState(null), s = Rr(
    e,
    (f) => a(f)
  ), c = k.useMemo(
    () => r ? n().findIndex(
      (f) => f.ref.current === r
    ) : -1,
    [
      n,
      r
    ]
  );
  return /* @__PURE__ */ k.createElement(Yle, qe({}, t, {
    ref: s,
    index: c
  }));
}), Yle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeSlider: n, index: r, ...a } = t, s = z1(PN, n), c = R4(PN, n), [f, p] = k.useState(null), g = Rr(
    e,
    (I) => p(I)
  ), y = gz(f), v = s.values[r], S = v === void 0 ? 0 : M4(v, s.min, s.max), x = Gle(r, s.values.length), _ = y?.[c.size], T = _ ? qle(_, S, c.direction) : 0;
  return k.useEffect(() => {
    if (f)
      return s.thumbs.add(f), () => {
        s.thumbs.delete(f);
      };
  }, [
    f,
    s.thumbs
  ]), /* @__PURE__ */ k.createElement("span", {
    style: {
      transform: "var(--radix-slider-thumb-transform)",
      position: "absolute",
      [c.startEdge]: `calc(${S}% + ${T}px)`
    }
  }, /* @__PURE__ */ k.createElement(MP.ItemSlot, {
    scope: t.__scopeSlider
  }, /* @__PURE__ */ k.createElement(pr.span, qe({
    role: "slider",
    "aria-label": t["aria-label"] || x,
    "aria-valuemin": s.min,
    "aria-valuenow": v,
    "aria-valuemax": s.max,
    "aria-orientation": s.orientation,
    "data-orientation": s.orientation,
    "data-disabled": s.disabled ? "" : void 0,
    tabIndex: s.disabled ? void 0 : 0
  }, a, {
    ref: g,
    style: v === void 0 ? {
      display: "none"
    } : t.style,
    onFocus: _t(t.onFocus, () => {
      s.valueIndexToChangeRef.current = r;
    })
  }))));
}), Kle = (t) => {
  const { value: e, ...n } = t, r = k.useRef(null), a = Ole(e);
  return k.useEffect(() => {
    const s = r.current, c = window.HTMLInputElement.prototype, p = Object.getOwnPropertyDescriptor(c, "value").set;
    if (a !== e && p) {
      const g = new Event("input", {
        bubbles: !0
      });
      p.call(s, e), s.dispatchEvent(g);
    }
  }, [
    a,
    e
  ]), /* @__PURE__ */ k.createElement("input", qe({
    style: {
      display: "none"
    }
  }, n, {
    ref: r,
    defaultValue: e
  }));
};
function Wle(t = [], e, n) {
  const r = [
    ...t
  ];
  return r[n] = e, r.sort(
    (a, s) => a - s
  );
}
function M4(t, e, n) {
  const s = 100 / (n - e) * (t - e);
  return C4(s, [
    0,
    100
  ]);
}
function Gle(t, e) {
  return e > 2 ? `Value ${t + 1} of ${e}` : e === 2 ? [
    "Minimum",
    "Maximum"
  ][t] : void 0;
}
function Xle(t, e) {
  if (t.length === 1)
    return 0;
  const n = t.map(
    (a) => Math.abs(a - e)
  ), r = Math.min(...n);
  return n.indexOf(r);
}
function qle(t, e, n) {
  const r = t / 2, s = b2([
    0,
    50
  ], [
    0,
    r
  ]);
  return (r - s(e) * n) * n;
}
function Qle(t) {
  return t.slice(0, -1).map(
    (e, n) => t[n + 1] - e
  );
}
function Zle(t, e) {
  if (e > 0) {
    const n = Qle(t);
    return Math.min(...n) >= e;
  }
  return !0;
}
function b2(t, e) {
  return (n) => {
    if (t[0] === t[1] || e[0] === e[1])
      return e[0];
    const r = (e[1] - e[0]) / (t[1] - t[0]);
    return e[0] + r * (n - t[0]);
  };
}
function Jle(t) {
  return (String(t).split(".")[1] || "").length;
}
function ece(t, e) {
  const n = Math.pow(10, e);
  return Math.round(t * n) / n;
}
const tce = jle, nce = Fle, rce = Hle, ice = Vle;
function oce(t) {
  const { title: e, steps: n, value: r, label: a, onValueChange: s } = t, c = Ge(), f = Fn(), p = k.useCallback(
    (v) => {
      s(v[0], !0);
    },
    [s]
  ), g = k.useCallback(() => {
    c.mark("click slider");
  }, [c]), y = k.useCallback(() => {
    r && s(r, !1);
  }, [r, s]);
  return /* @__PURE__ */ E.jsx("div", { className: "tlui-slider__container", children: /* @__PURE__ */ E.jsxs(
    tce,
    {
      "data-wd": t["data-wd"],
      className: "tlui-slider",
      "area-label": "Opacity",
      dir: "ltr",
      min: 0,
      max: n,
      step: 1,
      value: r ? [r] : void 0,
      onPointerDown: g,
      onValueChange: p,
      onPointerUp: y,
      title: e + " — " + f(a),
      children: [
        /* @__PURE__ */ E.jsx(nce, { className: "tlui-slider__track", dir: "ltr", children: r !== null && /* @__PURE__ */ E.jsx(rce, { className: "tlui-slider__range", dir: "ltr" }) }),
        r !== null && /* @__PURE__ */ E.jsx(ice, { className: "tlui-slider__thumb", dir: "ltr" })
      ]
    }
  ) });
}
const IN = new RegExp(
  /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:[/?#]\S*)?$/i
);
function kk(t) {
  return IN.test(t) ? !0 : IN.test("https://" + t) ? "needs protocol" : !1;
}
const ace = dn(function({ onClose: e }) {
  const n = Ge(), r = Fn(), a = n.onlySelectedShape, [s, c] = k.useState(kk(a?.props.url)), f = k.useRef(a?.props.url), p = k.useRef(a?.props.url), g = k.useCallback((_) => {
    const T = kk(_.trim());
    c((I) => I === T ? I : T), T && (p.current = _);
  }, []), y = k.useCallback(() => {
    n.setProp("url", "", !1), e();
  }, [n, e]), v = k.useCallback(
    (_) => {
      _ = _.trim();
      const T = kk(_), I = n.selectedShapes[0];
      if (I) {
        const D = I.props.url, N = T ? T === "needs protocol" ? "https://" + _ : _ : I.type === "bookmark" ? f.current : "";
        D !== void 0 && D !== N && n.setProp("url", N, !1);
      }
      e();
    },
    [n, e]
  ), S = k.useCallback(() => {
    e();
  }, [e]);
  if (!a)
    return e(), null;
  const x = f.current && !s;
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsxs(N1, { children: [
      /* @__PURE__ */ E.jsx(L1, { children: r("edit-link-dialog.title") }),
      /* @__PURE__ */ E.jsx(j1, {})
    ] }),
    /* @__PURE__ */ E.jsx(cb, { children: /* @__PURE__ */ E.jsxs("div", { className: "tlui-edit-link-dialog", children: [
      /* @__PURE__ */ E.jsx(
        y2,
        {
          className: "tlui-edit-link-dialog__input",
          label: "edit-link-dialog.url",
          defaultValue: s ? s === "needs protocol" ? "https://" + a.props.url : a.props.url : "https://",
          autofocus: !0,
          onValueChange: g,
          onComplete: v,
          onCancel: S
        }
      ),
      /* @__PURE__ */ E.jsx("div", { children: r(s ? "edit-link-dialog.detail" : "edit-link-dialog.invalid-url") })
    ] }) }),
    /* @__PURE__ */ E.jsxs(p2, { className: "tlui-dialog__footer__actions", children: [
      /* @__PURE__ */ E.jsx(At, { onClick: S, onTouchEnd: S, children: r("edit-link-dialog.cancel") }),
      x ? /* @__PURE__ */ E.jsx(At, { type: "danger", onTouchEnd: y, onClick: y, children: r("edit-link-dialog.clear") }) : /* @__PURE__ */ E.jsx(
        At,
        {
          type: "primary",
          disabled: !s,
          onTouchEnd: () => v(p.current),
          onClick: () => v(p.current),
          children: r("edit-link-dialog.save")
        }
      )
    ] })
  ] });
});
var S2 = { exports: {} };
S2.exports;
(function(t) {
  var e = function() {
    var n = String.fromCharCode, r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", s = {};
    function c(p, g) {
      if (!s[p]) {
        s[p] = {};
        for (var y = 0; y < p.length; y++)
          s[p][p.charAt(y)] = y;
      }
      return s[p][g];
    }
    var f = {
      compressToBase64: function(p) {
        if (p == null)
          return "";
        var g = f._compress(p, 6, function(y) {
          return r.charAt(y);
        });
        switch (g.length % 4) {
          default:
          case 0:
            return g;
          case 1:
            return g + "===";
          case 2:
            return g + "==";
          case 3:
            return g + "=";
        }
      },
      decompressFromBase64: function(p) {
        return p == null ? "" : p == "" ? null : f._decompress(p.length, 32, function(g) {
          return c(r, p.charAt(g));
        });
      },
      compressToUTF16: function(p) {
        return p == null ? "" : f._compress(p, 15, function(g) {
          return n(g + 32);
        }) + " ";
      },
      decompressFromUTF16: function(p) {
        return p == null ? "" : p == "" ? null : f._decompress(p.length, 16384, function(g) {
          return p.charCodeAt(g) - 32;
        });
      },
      //compress into uint8array (UCS-2 big endian format)
      compressToUint8Array: function(p) {
        for (var g = f.compress(p), y = new Uint8Array(g.length * 2), v = 0, S = g.length; v < S; v++) {
          var x = g.charCodeAt(v);
          y[v * 2] = x >>> 8, y[v * 2 + 1] = x % 256;
        }
        return y;
      },
      //decompress from uint8array (UCS-2 big endian format)
      decompressFromUint8Array: function(p) {
        if (p == null)
          return f.decompress(p);
        for (var g = new Array(p.length / 2), y = 0, v = g.length; y < v; y++)
          g[y] = p[y * 2] * 256 + p[y * 2 + 1];
        var S = [];
        return g.forEach(function(x) {
          S.push(n(x));
        }), f.decompress(S.join(""));
      },
      //compress into a string that is already URI encoded
      compressToEncodedURIComponent: function(p) {
        return p == null ? "" : f._compress(p, 6, function(g) {
          return a.charAt(g);
        });
      },
      //decompress from an output of compressToEncodedURIComponent
      decompressFromEncodedURIComponent: function(p) {
        return p == null ? "" : p == "" ? null : (p = p.replace(/ /g, "+"), f._decompress(p.length, 32, function(g) {
          return c(a, p.charAt(g));
        }));
      },
      compress: function(p) {
        return f._compress(p, 16, function(g) {
          return n(g);
        });
      },
      _compress: function(p, g, y) {
        if (p == null)
          return "";
        var v, S, x = {}, _ = {}, T = "", I = "", D = "", N = 2, j = 3, L = 2, z = [], F = 0, K = 0, X;
        for (X = 0; X < p.length; X += 1)
          if (T = p.charAt(X), Object.prototype.hasOwnProperty.call(x, T) || (x[T] = j++, _[T] = !0), I = D + T, Object.prototype.hasOwnProperty.call(x, I))
            D = I;
          else {
            if (Object.prototype.hasOwnProperty.call(_, D)) {
              if (D.charCodeAt(0) < 256) {
                for (v = 0; v < L; v++)
                  F = F << 1, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++;
                for (S = D.charCodeAt(0), v = 0; v < 8; v++)
                  F = F << 1 | S & 1, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++, S = S >> 1;
              } else {
                for (S = 1, v = 0; v < L; v++)
                  F = F << 1 | S, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++, S = 0;
                for (S = D.charCodeAt(0), v = 0; v < 16; v++)
                  F = F << 1 | S & 1, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++, S = S >> 1;
              }
              N--, N == 0 && (N = Math.pow(2, L), L++), delete _[D];
            } else
              for (S = x[D], v = 0; v < L; v++)
                F = F << 1 | S & 1, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++, S = S >> 1;
            N--, N == 0 && (N = Math.pow(2, L), L++), x[I] = j++, D = String(T);
          }
        if (D !== "") {
          if (Object.prototype.hasOwnProperty.call(_, D)) {
            if (D.charCodeAt(0) < 256) {
              for (v = 0; v < L; v++)
                F = F << 1, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++;
              for (S = D.charCodeAt(0), v = 0; v < 8; v++)
                F = F << 1 | S & 1, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++, S = S >> 1;
            } else {
              for (S = 1, v = 0; v < L; v++)
                F = F << 1 | S, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++, S = 0;
              for (S = D.charCodeAt(0), v = 0; v < 16; v++)
                F = F << 1 | S & 1, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++, S = S >> 1;
            }
            N--, N == 0 && (N = Math.pow(2, L), L++), delete _[D];
          } else
            for (S = x[D], v = 0; v < L; v++)
              F = F << 1 | S & 1, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++, S = S >> 1;
          N--, N == 0 && (N = Math.pow(2, L), L++);
        }
        for (S = 2, v = 0; v < L; v++)
          F = F << 1 | S & 1, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++, S = S >> 1;
        for (; ; )
          if (F = F << 1, K == g - 1) {
            z.push(y(F));
            break;
          } else
            K++;
        return z.join("");
      },
      decompress: function(p) {
        return p == null ? "" : p == "" ? null : f._decompress(p.length, 32768, function(g) {
          return p.charCodeAt(g);
        });
      },
      _decompress: function(p, g, y) {
        var v = [], S = 4, x = 4, _ = 3, T = "", I = [], D, N, j, L, z, F, K, X = { val: y(0), position: g, index: 1 };
        for (D = 0; D < 3; D += 1)
          v[D] = D;
        for (j = 0, z = Math.pow(2, 2), F = 1; F != z; )
          L = X.val & X.position, X.position >>= 1, X.position == 0 && (X.position = g, X.val = y(X.index++)), j |= (L > 0 ? 1 : 0) * F, F <<= 1;
        switch (j) {
          case 0:
            for (j = 0, z = Math.pow(2, 8), F = 1; F != z; )
              L = X.val & X.position, X.position >>= 1, X.position == 0 && (X.position = g, X.val = y(X.index++)), j |= (L > 0 ? 1 : 0) * F, F <<= 1;
            K = n(j);
            break;
          case 1:
            for (j = 0, z = Math.pow(2, 16), F = 1; F != z; )
              L = X.val & X.position, X.position >>= 1, X.position == 0 && (X.position = g, X.val = y(X.index++)), j |= (L > 0 ? 1 : 0) * F, F <<= 1;
            K = n(j);
            break;
          case 2:
            return "";
        }
        for (v[3] = K, N = K, I.push(K); ; ) {
          if (X.index > p)
            return "";
          for (j = 0, z = Math.pow(2, _), F = 1; F != z; )
            L = X.val & X.position, X.position >>= 1, X.position == 0 && (X.position = g, X.val = y(X.index++)), j |= (L > 0 ? 1 : 0) * F, F <<= 1;
          switch (K = j) {
            case 0:
              for (j = 0, z = Math.pow(2, 8), F = 1; F != z; )
                L = X.val & X.position, X.position >>= 1, X.position == 0 && (X.position = g, X.val = y(X.index++)), j |= (L > 0 ? 1 : 0) * F, F <<= 1;
              v[x++] = n(j), K = x - 1, S--;
              break;
            case 1:
              for (j = 0, z = Math.pow(2, 16), F = 1; F != z; )
                L = X.val & X.position, X.position >>= 1, X.position == 0 && (X.position = g, X.val = y(X.index++)), j |= (L > 0 ? 1 : 0) * F, F <<= 1;
              v[x++] = n(j), K = x - 1, S--;
              break;
            case 2:
              return I.join("");
          }
          if (S == 0 && (S = Math.pow(2, _), _++), v[K])
            T = v[K];
          else if (K === x)
            T = N + N.charAt(0);
          else
            return null;
          I.push(T), v[x++] = N + T.charAt(0), S--, N = T, S == 0 && (S = Math.pow(2, _), _++);
        }
      }
    };
    return f;
  }();
  t != null ? t.exports = e : typeof angular < "u" && angular != null && angular.module("LZString", []).factory("LZString", function() {
    return e;
  });
})(S2);
var A4 = S2.exports;
async function Pk(t) {
  return new Promise((e, n) => {
    const r = new FileReader();
    r.addEventListener("loadend", () => {
      const a = r.result;
      e(a);
    }), r.addEventListener("error", () => {
      n(r.error);
    }), r.readAsText(t);
  });
}
async function RN(t) {
  return new Promise((e) => {
    t.getAsString((n) => {
      e(n);
    });
  });
}
const sce = ["input", "select", "textarea"];
function Ik(t) {
  const { activeElement: e } = document;
  return t.isMenuOpen || e && (e.getAttribute("contenteditable") || sce.indexOf(e.tagName.toLowerCase()) > -1);
}
function $N(t) {
  const e = document.implementation.createHTMLDocument("");
  return e.documentElement.innerHTML = t, e.body.textContent || e.body.innerText || "";
}
const lce = () => {
  window.navigator.clipboard.writeText("");
}, cce = (t, e) => A4.compressToBase64(
  JSON.stringify({
    type: "application/tldraw",
    kind: e,
    data: t
  })
), O4 = async (t, e, n) => {
  const r = n ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : void 0);
  t.mark("paste"), t.putContent(e, {
    point: r,
    select: !0
  });
}, uce = async (t, e, n) => {
  const r = n ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : t.viewportPageCenter), a = t.getShapeUtilByDef(b1).defaultProps(), { w: s, h: c } = t.textMeasure.measureText({
    ...Ki,
    text: $N(e),
    fontFamily: qd[a.font],
    fontSize: Hg[a.size],
    width: "fit-content"
  });
  t.mark("paste"), t.createShapes([
    {
      id: io(),
      type: "text",
      x: r.x - s / 2,
      y: r.y - c / 2,
      props: {
        text: $N(e),
        autoSize: !0
      }
    }
  ]);
}, AP = async (t, e, n) => {
  const r = n ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : t.viewportPageCenter);
  try {
    if ((await fetch(e)).headers.get("content-type")?.match(/^image\//)) {
      t.mark("paste"), D4(t, [e]);
      return;
    }
  } catch (s) {
    s.message !== "Failed to fetch" && console.error(s);
  }
  const a = Gd(e);
  a ? (t.mark("paste"), GL(t, a.url, r, a.definition)) : (t.mark("paste"), await CZ(t, e, r));
}, dce = (t, e, n) => {
  const r = n ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : t.viewportPageCenter);
  t.mark("paste"), _Z(t, e, r);
}, D4 = async (t, e, n) => {
  const r = n ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : t.viewportPageCenter), s = (await Promise.all(e.map(async (c) => await (await fetch(c)).blob()))).map(
    (c) => new File([c], "TLdrawFile", {
      type: c.type
    })
  );
  t.mark("paste"), await g1(t, s, r, !1), e.forEach((c) => URL.revokeObjectURL(c));
}, Gx = (t) => {
  const e = t.getContent();
  if (!e) {
    lce();
    return;
  }
  const n = cce(e, "content");
  if (typeof window?.navigator < "u") {
    const r = e.shapes.map((a) => b1.is(a) || Cj.is(a) || ro.is(a) ? a.props.text : v1.is(a) || nb.is(a) ? a.props.url : null).filter(WG);
    if (navigator.clipboard?.write) {
      const a = new Blob([`<tldraw>${n}</tldraw>`], {
        type: "text/html"
      });
      let s = r.join(" ");
      s === "" && (s = " "), navigator.clipboard.write([
        new ClipboardItem({
          "text/html": a,
          "text/plain": new Blob([s], { type: "text/plain" })
        })
      ]);
    } else
      navigator.clipboard.writeText && navigator.clipboard.writeText(`<tldraw>${n}</tldraw>`);
  }
}, Kg = (t, e, n) => {
  const r = kZ(e);
  if (r)
    for (const a of r)
      AP(t, a, n);
  else
    TZ(e) ? AP(t, e, n) : PZ(e) ? dce(t, e, n) : uce(t, e, n);
};
async function fce(t, e, n) {
  const { elements: r, files: a } = e, s = {
    shapes: [],
    rootShapeIds: [],
    assets: [],
    schema: t.store.schema.serialize()
  }, c = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Map(), p = (Y) => {
    const le = Y / 100;
    return le < 0.2 ? "0.1" : le < 0.4 ? "0.25" : le < 0.6 ? "0.5" : le < 0.8 ? "0.75" : "1";
  }, g = {
    1: "s",
    2: "m",
    3: "l",
    4: "xl"
  }, y = {
    16: "s",
    20: "m",
    28: "l",
    36: "xl"
  };
  function v(Y) {
    const le = y[Y];
    return le ? { size: le, scale: 1 } : Y < 16 ? { size: "s", scale: Y / 16 } : Y > 36 ? { size: "xl", scale: Y / 36 } : { size: "m", scale: 1 };
  }
  const S = {
    1: "draw",
    2: "sans",
    3: "mono"
  }, x = {
    "#ffffff": "grey",
    // Strokes
    "#000000": "black",
    "#343a40": "grey",
    "#495057": "grey",
    "#c92a2a": "red",
    "#a61e4d": "light-red",
    "#862e9c": "violet",
    "#5f3dc4": "light-violet",
    "#364fc7": "blue",
    "#1864ab": "light-blue",
    "#0b7285": "light-green",
    "#087f5b": "light-green",
    "#2b8a3e": "green",
    "#5c940d": "light-green",
    "#e67700": "yellow",
    "#d9480f": "orange",
    // Backgrounds
    "#ced4da": "grey",
    "#868e96": "grey",
    "#fa5252": "light-red",
    "#e64980": "red",
    "#be4bdb": "light-violet",
    "#7950f2": "violet",
    "#4c6ef5": "blue",
    "#228be6": "light-blue",
    "#15aabf": "light-green",
    "#12b886": "green",
    "#40c057": "green",
    "#82c91e": "light-green",
    "#fab005": "yellow",
    "#fd7e14": "orange",
    "#212529": "grey"
  }, _ = {
    solid: "draw",
    dashed: "dashed",
    dotted: "dotted"
  }, T = {
    "cross-hatch": "pattern",
    hachure: "pattern",
    solid: "solid"
  }, I = {
    left: "start",
    center: "middle",
    right: "end"
  }, D = {
    arrow: "arrow",
    dot: "dot",
    triangle: "triangle",
    bar: "pipe"
  };
  function N(Y, le, Re) {
    let he = 0;
    if (Y.points.length > 2) {
      const te = new O(le[0], le[1]), de = new O(Re[0], Re[1]), W = new O(Y.points[1][0], Y.points[1][1]), fe = O.Sub(de, te), ce = O.Per(fe), xe = O.Med(de, te), $e = O.Sub(xe, ce), Me = O.Add(xe, ce), re = O.NearestPointOnLineSegment($e, Me, W, !1);
      he = O.Dist(re, xe), O.Clockwise(re, de, xe) && (he *= -1);
    }
    return he;
  }
  const j = (Y) => {
    let le = _[Y.strokeStyle] ?? "draw";
    return le === "draw" && Y.roughness === 0 && (le = "solid"), le;
  }, L = (Y) => Y.backgroundColor === "transparent" ? "none" : T[Y.fillStyle] ?? "solid", { currentPageId: z } = t;
  let F = "a1";
  const K = /* @__PURE__ */ new Map(), X = [], se = /* @__PURE__ */ new Set();
  r.forEach((Y) => {
    if (K.set(Y.id, t.createShapeId()), Y.boundElements !== null)
      for (const le of Y.boundElements)
        le.type === "text" && se.add(le.id);
  });
  for (const Y of r) {
    if (se.has(Y.id))
      continue;
    const le = K.get(Y.id), Re = {
      id: le,
      typeName: "shape",
      parentId: z,
      index: F,
      x: Y.x,
      y: Y.y,
      rotation: 0,
      isLocked: Y.locked
    };
    switch (Y.angle !== 0 && f.set(le, Y.angle), Y.groupIds && Y.groupIds.length > 0 ? c.has(Y.groupIds[0]) ? c.get(Y.groupIds[0])?.push(le) : c.set(Y.groupIds[0], [le]) : X.push(le), Y.type) {
      case "rectangle":
      case "ellipse":
      case "diamond": {
        let he = "", te = "middle";
        if (Y.boundElements !== null) {
          for (const W of Y.boundElements)
            if (W.type === "text") {
              const fe = r.find((ce) => ce.id === W.id);
              fe && (he = fe.text, te = I[fe.textAlign]);
            }
        }
        const de = Y.backgroundColor === "transparent" ? Y.strokeColor : Y.backgroundColor;
        s.shapes.push({
          ...Re,
          type: "geo",
          props: {
            geo: Y.type,
            opacity: p(Y.opacity),
            url: Y.link ?? "",
            w: Y.width,
            h: Y.height,
            size: g[Y.strokeWidth] ?? "draw",
            color: x[de] ?? "black",
            text: he,
            align: te,
            dash: j(Y),
            fill: L(Y)
          }
        });
        break;
      }
      case "freedraw": {
        s.shapes.push({
          ...Re,
          type: "draw",
          props: {
            dash: j(Y),
            size: g[Y.strokeWidth],
            opacity: p(Y.opacity),
            color: x[Y.strokeColor] ?? "black",
            segments: [
              {
                type: "free",
                points: Y.points.map(([he, te, de = 0.5]) => ({
                  x: he,
                  y: te,
                  z: de
                }))
              }
            ]
          }
        });
        break;
      }
      case "line": {
        const he = Y.points[0], te = Y.points[Y.points.length - 1], de = tj(Y.points.length);
        s.shapes.push({
          ...Re,
          type: "line",
          props: {
            dash: j(Y),
            size: g[Y.strokeWidth],
            opacity: p(Y.opacity),
            color: x[Y.strokeColor] ?? "black",
            spline: Y.roundness ? "cubic" : "line",
            handles: {
              start: {
                id: "start",
                type: "vertex",
                index: de[0],
                x: he[0],
                y: he[1]
              },
              end: {
                id: "end",
                type: "vertex",
                index: de[de.length - 1],
                x: te[0],
                y: te[1]
              },
              ...Object.fromEntries(
                Y.points.slice(1, -1).map(([W, fe], ce) => {
                  const xe = $i();
                  return [
                    xe,
                    {
                      id: xe,
                      type: "vertex",
                      index: de[ce + 1],
                      x: W,
                      y: fe
                    }
                  ];
                })
              )
            }
          }
        });
        break;
      }
      case "arrow": {
        let he = "";
        if (Y.boundElements !== null) {
          for (const ce of Y.boundElements)
            if (ce.type === "text") {
              const xe = r.find(($e) => $e.id === ce.id);
              xe && (he = xe.text);
            }
        }
        const te = Y.points[0], de = Y.points[Y.points.length - 1], W = K.get(Y.startBinding?.elementId), fe = K.get(Y.endBinding?.elementId);
        s.shapes.push({
          ...Re,
          type: "arrow",
          props: {
            text: he,
            bend: N(Y, te, de),
            dash: j(Y),
            opacity: p(Y.opacity),
            size: g[Y.strokeWidth] ?? "m",
            color: x[Y.strokeColor] ?? "black",
            start: W ? {
              type: "binding",
              boundShapeId: W,
              normalizedAnchor: { x: 0.5, y: 0.5 },
              isExact: !1
            } : {
              type: "point",
              x: te[0],
              y: te[1]
            },
            end: fe ? {
              type: "binding",
              boundShapeId: fe,
              normalizedAnchor: { x: 0.5, y: 0.5 },
              isExact: !1
            } : {
              type: "point",
              x: de[0],
              y: de[1]
            },
            arrowheadEnd: D[Y.endArrowhead] ?? "none",
            arrowheadStart: D[Y.startArrowhead] ?? "none"
          }
        });
        break;
      }
      case "text": {
        const { size: he, scale: te } = v(Y.fontSize);
        s.shapes.push({
          ...Re,
          type: "text",
          props: {
            size: he,
            scale: te,
            font: S[Y.fontFamily] ?? "draw",
            opacity: p(Y.opacity),
            color: x[Y.strokeColor] ?? "black",
            text: Y.text,
            align: I[Y.textAlign]
          }
        });
        break;
      }
      case "image": {
        const he = a[Y.fileId];
        if (!he)
          break;
        const te = cm.createId();
        s.assets.push({
          id: te,
          typeName: "asset",
          type: "image",
          props: {
            w: Y.width,
            h: Y.height,
            name: Y.id ?? "Untitled",
            isAnimated: !1,
            mimeType: he.mimeType,
            src: he.dataURL
          }
        }), s.shapes.push({
          ...Re,
          type: "image",
          props: {
            opacity: p(Y.opacity),
            w: Y.width,
            h: Y.height,
            assetId: te
          }
        });
      }
    }
    F = Mu(F);
  }
  const ue = n ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : void 0);
  t.mark("paste"), t.putContent(s, {
    point: ue,
    select: !1,
    preserveIds: !0
  });
  for (const Y of c.values())
    if (Y.length > 1) {
      t.groupShapes(Y);
      const le = t.getShapeById(Y[0]);
      le?.parentId && Fs(le.parentId) && X.push(le.parentId);
    }
  for (const [Y, le] of f)
    t.select(Y), t.rotateShapesBy([Y], le);
  const pe = Gt(X.map((Y) => t.getShapeById(Y))), Pe = ot.Common(pe.map((Y) => t.getPageBounds(Y))), ve = t.viewportPageBounds.center;
  t.updateShapes(
    pe.map((Y) => {
      const le = {
        x: (Y.x ?? 0) - (Pe.x + Pe.w / 2),
        y: (Y.y ?? 0) - (Pe.y + Pe.h / 2)
      };
      return {
        id: Y.id,
        type: Y.type,
        x: ve.x + le.x,
        y: ve.y + le.y
      };
    })
  ), t.setSelectedIds(X);
}
const N4 = async (t, e, n) => {
  const r = e.map((a) => URL.createObjectURL(a));
  D4(t, r, n);
}, w2 = async (t, e, n) => {
  const r = e.match(/<tldraw[^>]*>(.*)<\/tldraw>/)?.[1];
  if (r)
    try {
      const a = JSON.parse(A4.decompressFromBase64(r));
      a.type === "application/tldraw" ? O4(t, a.data, n) : Kg(t, r, n);
    } catch {
      Kg(t, r, n);
    }
  else {
    const s = new DOMParser().parseFromString(e, "text/html").querySelector("body");
    if (s && Array.from(s.children).filter((f) => f.nodeType === 1).length === 1 && s.firstElementChild && s.firstElementChild.tagName === "A" && s.firstElementChild.hasAttribute("href") && s.firstElementChild.getAttribute("href") !== "") {
      const f = s.firstElementChild.getAttribute("href");
      Kg(t, f, n);
    } else
      Kg(t, e, n);
  }
}, L4 = async (t, e, n) => {
  const r = e.trim();
  if (e.match(/<tldraw[^>]*>(.*)<\/tldraw>/)?.[1])
    w2(t, e);
  else if (r)
    try {
      const s = JSON.parse(r);
      s.type === "application/tldraw" ? O4(t, s.data, n) : s.type === "excalidraw/clipboard" ? fce(t, s, n) : Kg(t, r, n);
    } catch {
      Kg(t, r, n);
    }
}, pce = async (t, e, n) => {
  if (!t.isIn("select.editing") && e) {
    const r = Object.values(e.items), a = r.some((p) => p.kind === "file"), s = r.some((p) => p.type === "text/html"), c = [], f = [];
    r.forEach((p) => {
      if (p.kind === "file") {
        const g = p.getAsFile();
        g && c.push(g);
      } else
        p.kind === "string" && f.push(p);
    }), c.length > 0 && N4(t, c, n);
    for (const p of f)
      !a && p.type === "text/html" ? await w2(t, await RN(p), n) : p.type === "text/plain" && (s || await L4(t, await RN(p), n));
  }
}, j4 = async (t, e, n) => {
  if (t.isIn("select.editing"))
    return;
  const r = (f) => f.types.find((p) => p.match(/^image\//)), a = e.some((f) => r(f)), s = e.some((f) => f.types.includes("text/html")), c = e.filter((f) => !!f.types.find((p) => p.match(/^image\//)));
  await Promise.all(
    c.map(async (f) => {
      const p = f.types.find((g) => g !== "text/plain" && g !== "text/html");
      if (p) {
        const g = await f.getType(p);
        g && await N4(t, [g], n);
      }
    })
  );
  for (const f of e)
    if (f.types.includes("text/html")) {
      if (a)
        break;
      const p = await f.getType("text/html");
      await w2(t, await Pk(p), n);
    } else if (f.types.includes("text/uri-list")) {
      if (s)
        break;
      const p = await f.getType("text/uri-list");
      await AP(t, await Pk(p), n);
    } else if (f.types.includes("text/plain")) {
      if (s)
        break;
      const p = await f.getType("text/plain");
      await L4(t, await Pk(p), n);
    }
};
function x2() {
  const t = Ge(), e = k.useCallback(
    function() {
      t.selectedIds.length !== 0 && Gx(t);
    },
    [t]
  ), n = k.useCallback(
    function() {
      t.selectedIds.length !== 0 && (Gx(t), t.deleteShapes());
    },
    [t]
  ), r = k.useCallback(
    async function(s, c) {
      Array.isArray(s) && s[0] instanceof ClipboardItem ? j4(t, s, c) : navigator.clipboard.read().then((f) => {
        r(f, t.inputs.currentPagePoint);
      });
    },
    [t]
  );
  return {
    copy: e,
    cut: n,
    paste: r
  };
}
function hce() {
  const t = Ge();
  k.useEffect(() => {
    const e = () => {
      t.selectedIds.length === 0 || t.editingId !== null || Ik(t) || Gx(t);
    };
    function n() {
      t.selectedIds.length === 0 || t.editingId !== null || Ik(t) || (Gx(t), t.deleteShapes());
    }
    const r = (a) => {
      t.editingId !== null || Ik(t) || (a.clipboardData && !t.inputs.shiftKey ? pce(t, a.clipboardData) : navigator.clipboard.read().then((s) => {
        Array.isArray(s) && s[0] instanceof ClipboardItem && j4(t, s, t.inputs.currentPagePoint);
      }));
    };
    return document.addEventListener("copy", e), document.addEventListener("cut", n), document.addEventListener("paste", r), () => {
      document.removeEventListener("copy", e), document.removeEventListener("cut", n), document.removeEventListener("paste", r);
    };
  }, [t]);
}
const z4 = k.createContext({});
function gce({ children: t }) {
  const [e, n] = k.useState([]), r = k.useCallback((c) => {
    const f = c.id ?? $i();
    return n((p) => [...p.filter((g) => g.id !== c.id), { ...c, id: f }]), f;
  }, []), a = k.useCallback((c) => (n((f) => f.filter((p) => p.id !== c)), c), []), s = k.useCallback(() => {
    n(() => []);
  }, []);
  return /* @__PURE__ */ E.jsx(z4.Provider, { value: { toasts: e, addToast: r, removeToast: a, clearToasts: s }, children: t });
}
function Hu() {
  const t = k.useContext(z4);
  if (!t)
    throw new Error("useToasts must be used within a ToastsProvider");
  return t;
}
const OP = {
  "action.convert-to-bookmark": "Convert to Bookmark",
  "action.convert-to-embed": "Convert to Embed",
  "action.open-embed-link": "Open link",
  "action.align-bottom": "Align bottom",
  "action.align-center-horizontal": "Align horizontally",
  "action.align-center-vertical": "Align vertically",
  "action.align-center-horizontal.short": "Align H",
  "action.align-center-vertical.short": "Align V",
  "action.align-left": "Align left",
  "action.align-right": "Align right",
  "action.align-top": "Align top",
  "action.back-to-content": "Back to content",
  "action.bring-forward": "Bring forward",
  "action.bring-to-front": "Bring to front",
  "action.copy-as-json.short": "JSON",
  "action.copy-as-json": "Copy as JSON",
  "action.copy-as-png.short": "PNG",
  "action.copy-as-png": "Copy as PNG",
  "action.copy-as-svg.short": "SVG",
  "action.copy-as-svg": "Copy as SVG",
  "action.copy": "Copy",
  "action.cut": "Cut",
  "action.delete": "Delete",
  "action.distribute-horizontal": "Distribute horizontally",
  "action.distribute-vertical": "Distribute vertically",
  "action.distribute-horizontal.short": "Distribute H",
  "action.distribute-vertical.short": "Distribute V",
  "action.duplicate": "Duplicate",
  "action.edit-link": "Edit link",
  "action.exit-pen-mode": "Exit pen mode",
  "action.export-as-json.short": "JSON",
  "action.export-as-json": "Export as JSON",
  "action.export-as-png.short": "PNG",
  "action.export-as-png": "Export as PNG",
  "action.export-as-svg.short": "SVG",
  "action.export-as-svg": "Export as SVG",
  "action.flip-horizontal": "Flip horizontally",
  "action.flip-vertical": "Flip vertically",
  "action.flip-horizontal.short": "Flip H",
  "action.flip-vertical.short": "Flip V",
  "action.group": "Group",
  "action.insert-media": "Upload media",
  "action.new-shared-project": "New shared project",
  "action.nudge-down": "Nudge down",
  "action.nudge-left": "Nudge left",
  "action.nudge-right": "Nudge right",
  "action.nudge-up": "Nudge up",
  "action.open-file": "Open file",
  "action.pack": "Pack",
  "action.paste": "Paste",
  "action.print": "Print",
  "action.redo": "Redo",
  "action.rotate-ccw": "Rotate counterclockwise",
  "action.rotate-cw": "Rotate clockwise",
  "action.save-copy": "Save a copy",
  "action.select-all": "Select all",
  "action.select-none": "Select none",
  "action.send-backward": "Send backward",
  "action.send-to-back": "Send to back",
  "action.share-project": "Share this project",
  "action.stack-horizontal": "Stack horizontally",
  "action.stack-vertical": "Stack vertically",
  "action.stack-horizontal.short": "Stack H",
  "action.stack-vertical.short": "Stack V",
  "action.stretch-horizontal": "Stretch horizontally",
  "action.stretch-vertical": "Stretch vertically",
  "action.stretch-horizontal.short": "Stretch H",
  "action.stretch-vertical.short": "Stretch V",
  "action.toggle-auto-size": "Toggle auto size",
  "action.toggle-dark-mode.menu": "Dark mode",
  "action.toggle-dark-mode": "Toggle dark mode",
  "action.toggle-debug-mode.menu": "Debug mode",
  "action.toggle-debug-mode": "Toggle debug mode",
  "action.toggle-focus-mode.menu": "Focus mode",
  "action.toggle-focus-mode": "Toggle focus mode",
  "action.toggle-grid.menu": "Show grid",
  "action.toggle-grid": "Toggle grid",
  "action.toggle-snap-mode.menu": "Always snap",
  "action.toggle-snap-mode": "Toggle always snap",
  "action.toggle-tool-lock.menu": "Tool lock",
  "action.toggle-tool-lock": "Toggle tool lock",
  "action.toggle-transparent.context-menu": "Transparent",
  "action.toggle-transparent.menu": "Transparent",
  "action.toggle-transparent": "Toggle transparent background",
  "action.undo": "Undo",
  "action.ungroup": "Ungroup",
  "action.zoom-in": "Zoom in",
  "action.zoom-out": "Zoom out",
  "action.zoom-to-100": "Zoom to 100%",
  "action.zoom-to-fit": "Zoom to fit",
  "action.zoom-to-selection": "Zoom to selection",
  "color-style.black": "Black",
  "color-style.blue": "Blue",
  "color-style.green": "Green",
  "color-style.grey": "Grey",
  "color-style.light-blue": "Light blue",
  "color-style.light-green": "Light green",
  "color-style.light-red": "Light red",
  "color-style.light-violet": "Light violet",
  "color-style.orange": "Orange",
  "color-style.red": "Red",
  "color-style.violet": "Violet",
  "color-style.yellow": "Yellow",
  "fill-style.none": "None",
  "fill-style.semi": "Semi",
  "fill-style.solid": "Solid",
  "fill-style.pattern": "Pattern",
  "dash-style.dashed": "Dashed",
  "dash-style.dotted": "Dotted",
  "dash-style.draw": "Draw",
  "dash-style.solid": "Solid",
  "size-style.s": "Small",
  "size-style.m": "Medium",
  "size-style.l": "Large",
  "size-style.xl": "Extra large",
  "opacity-style.0.1": "10%",
  "opacity-style.0.25": "25%",
  "opacity-style.0.5": "50%",
  "opacity-style.0.75": "75%",
  "opacity-style.1": "100%",
  "font-style.draw": "Draw",
  "font-style.sans": "Sans",
  "font-style.serif": "Serif",
  "font-style.mono": "Mono",
  "align-style.start": "Start",
  "align-style.middle": "Middle",
  "align-style.end": "End",
  "align-style.justify": "Justify",
  "geo-style.arrow-down": "Arrow down",
  "geo-style.arrow-left": "Arrow left",
  "geo-style.arrow-right": "Arrow right",
  "geo-style.arrow-up": "Arrow up",
  "geo-style.diamond": "Diamond",
  "geo-style.ellipse": "Ellipse",
  "geo-style.hexagon": "Hexagon",
  "geo-style.octagon": "Octagon",
  "geo-style.oval": "Oval",
  "geo-style.pentagon": "Pentagon",
  "geo-style.rectangle": "Rectangle",
  "geo-style.rhombus-2": "Rhombus 2",
  "geo-style.rhombus": "Rhombus",
  "geo-style.star": "Star",
  "geo-style.trapezoid": "Trapezoid",
  "geo-style.triangle": "Triangle",
  "geo-style.x-box": "X Box",
  "arrowheadStart-style.none": "None",
  "arrowheadStart-style.arrow": "Arrow",
  "arrowheadStart-style.bar": "Bar",
  "arrowheadStart-style.diamond": "Diamond",
  "arrowheadStart-style.dot": "Dot",
  "arrowheadStart-style.inverted": "Inverted",
  "arrowheadStart-style.pipe": "Pipe",
  "arrowheadStart-style.square": "Square",
  "arrowheadStart-style.triangle": "Triangle",
  "arrowheadEnd-style.none": "None",
  "arrowheadEnd-style.arrow": "Arrow",
  "arrowheadEnd-style.bar": "Bar",
  "arrowheadEnd-style.diamond": "Diamond",
  "arrowheadEnd-style.dot": "Dot",
  "arrowheadEnd-style.inverted": "Inverted",
  "arrowheadEnd-style.pipe": "Pipe",
  "arrowheadEnd-style.square": "Square",
  "arrowheadEnd-style.triangle": "Triangle",
  "spline-style.line": "Line",
  "spline-style.cubic": "Cubic",
  "tool.select": "Select",
  "tool.hand": "Hand",
  "tool.draw": "Draw",
  "tool.eraser": "Eraser",
  "tool.arrow-down": "Arrow down",
  "tool.arrow-left": "Arrow left",
  "tool.arrow-right": "Arrow right",
  "tool.arrow-up": "Arrow up",
  "tool.arrow": "Arrow",
  "tool.diamond": "Diamond",
  "tool.ellipse": "Ellipse",
  "tool.hexagon": "Hexagon",
  "tool.line": "Line",
  "tool.octagon": "Octagon",
  "tool.oval": "Oval",
  "tool.pentagon": "Pentagon",
  "tool.rectangle": "Rectangle",
  "tool.rhombus": "Rhombus",
  "tool.star": "Star",
  "tool.trapezoid": "Trapezoid",
  "tool.triangle": "Triangle",
  "tool.x-box": "X box",
  "tool.asset": "Asset",
  "tool.frame": "Frame",
  "tool.note": "Note",
  "tool.embed": "Embed",
  "tool.text": "Text",
  "menu.title": "Menu",
  "menu.copy-as": "Copy as",
  "menu.edit": "Edit",
  "menu.export-as": "Export as",
  "menu.file": "File",
  "menu.language": "Language",
  "menu.preferences": "Preferences",
  "menu.view": "View",
  "context-menu.arrange": "Arrange",
  "context-menu.copy-as": "Copy as",
  "context-menu.export-as": "Export as",
  "context-menu.move-to-page": "Move to page",
  "context-menu.reorder": "Reorder",
  "page-menu.title": "Pages",
  "page-menu.create-new-page": "Create new page",
  "page-menu.edit-pages": "Edit pages",
  "page-menu.max-page-count-reached": "Max pages reached",
  "page-menu.new-page-initial-name": "Page 1",
  "page-menu.page": "Page",
  "page-menu.edit-start": "Edit",
  "page-menu.edit-done": "Done",
  "page-menu.submenu.rename": "Rename",
  "page-menu.submenu.duplicate-page": "Duplicate",
  "page-menu.submenu.go-to-page": "Go to page",
  "page-menu.submenu.title": "Menu",
  "page-menu.submenu.move-down": "Move down",
  "page-menu.submenu.move-up": "Move up",
  "page-menu.submenu.delete": "Delete",
  "share-menu.title": "Share",
  "share-menu.share-project": "Share this project",
  "share-menu.create-project": "New shared project",
  "share-menu.copy-link": "Copy link",
  "share-menu.readonly-link": "Read-only",
  "share-menu.copy-readonly-link": "Copy read-only link",
  "share-menu.offline-note": "Sharing this project will create a hosted live copy at a new URL. You can share the URL with up to thirty other people to view and edit the project together.",
  "share-menu.copy-link-note": "Anyone with the link will be able to view and edit this project.",
  "share-menu.copy-readonly-link-note": "Anyone with the link will be able to view (but not edit) this project.",
  "share-menu.project-too-large": "Sorry, this project can't be shared because it's too large. We're working on it!",
  "people-menu.title": "People",
  "people-menu.change-name": "Change name",
  "people-menu.change-color": "Change color",
  "people-menu.user": "(You)",
  "people-menu.invite": "Invite others",
  "debug-menu.hard-reset": "Hard reset",
  "debug-menu.create-shapes": "Create 100 shapes",
  "help-menu.title": "Help and resources",
  "help-menu.about": "About",
  "help-menu.discord": "Discord",
  "help-menu.github": "GitHub",
  "help-menu.keyboard-shortcuts": "Keyboard shortcuts",
  "help-menu.twitter": "Twitter",
  "links-menu.about": "About",
  "links-menu.discord": "Discord",
  "links-menu.github": "GitHub",
  "links-menu.twitter": "Twitter",
  "actions-menu.title": "Actions",
  "edit-link-dialog.title": "Edit link",
  "edit-link-dialog.invalid-url": "A link must be a valid URL.",
  "edit-link-dialog.detail": "Links will open in a new tab.",
  "edit-link-dialog.url": "URL",
  "edit-link-dialog.clear": "Clear",
  "edit-link-dialog.save": "Continue",
  "edit-link-dialog.cancel": "Cancel",
  "embed-dialog.title": "Create embed",
  "embed-dialog.url-title": "Create %s embed",
  "embed-dialog.url-label": "Paste URL",
  "embed-dialog.back": "Back",
  "embed-dialog.create": "Create",
  "embed-dialog.cancel": "Cancel",
  "embed-dialog.url": "URL",
  "embed-dialog.instruction": "Paste in the site's URL to create the embed.",
  "embed-dialog.invalid-url": "We could not create an embed from that URL.",
  "edit-pages-dialog.title": "Edit pages",
  "edit-pages-dialog.create-new-page": "Create new page",
  "edit-pages-dialog.delete": "Delete",
  "edit-pages-dialog.duplicate-page": "Duplicate",
  "edit-pages-dialog.go-to-page": "Go to page",
  "edit-pages-dialog.max-page-count-reached": "Max pages reached",
  "edit-pages-dialog.more-menu": "Menu",
  "edit-pages-dialog.move-down": "Move down",
  "edit-pages-dialog.move-up": "Move up",
  "edit-pages-dialog.new-page-initial-name": "Page 1",
  "reload-file-dialog.title": "Continue editing file",
  "reload-file-dialog.description": "You were just editing a file. Would you like to continue editing it?",
  "reload-file-dialog.failure": "Failed to reload file. Try again?",
  "reload-file-dialog.reload": "Continue editing",
  "reload-file-dialog.revert": "No thanks",
  "shortcuts-dialog.title": "Keyboard shortcuts",
  "shortcuts-dialog.edit": "Edit",
  "shortcuts-dialog.file": "File",
  "shortcuts-dialog.preferences": "Preferences",
  "shortcuts-dialog.tools": "Tools",
  "shortcuts-dialog.transform": "Transform",
  "shortcuts-dialog.view": "View",
  "shortcuts-dialog.save": "Continue",
  "style-panel.title": "Styles",
  "style-panel.align": "Align",
  "style-panel.arrowheads": "Arrowheads",
  "style-panel.arrowhead-start": "Start",
  "style-panel.arrowhead-end": "End",
  "style-panel.color": "Color",
  "style-panel.dash": "Dash",
  "style-panel.fill": "Fill",
  "style-panel.font": "Font",
  "style-panel.geo": "Shape",
  "style-panel.label": "Label",
  "style-panel.mixed": "Mixed",
  "style-panel.opacity": "Opacity",
  "style-panel.size": "Size",
  "style-panel.spline": "Spline",
  "style-panel.text": "Text",
  "tool-panel.drawing": "Drawing",
  "tool-panel.geo": "Shape",
  "tool-panel.shapes": "Shapes",
  "tool-panel.things": "Things",
  "tool-panel.tools": "Tools",
  "save-changes-prompt.title": "You have unsaved changes",
  "save-changes-prompt.description": "Would you like to save changes to your current file?",
  "save-changes-prompt.go-back": "Go back",
  "save-changes-prompt.continue": "Continue",
  "navigation-zone.toggle-minimap": "Toggle minimap",
  "navigation-zone.zoom": "Zoom",
  "focus-mode.toggle-focus-mode": "Toggle focus mode",
  "toast.close": "Close",
  "file-system.file-open-error.title": "Could not open file",
  "file-system.file-open-error.not-a-tldraw-file": "The file you tried to open doesn't look like a tldraw file.",
  "file-system.file-open-error.file-format-version-too-new": "The file you tried to open is from a newer version of tldraw. Please reload the page and try again.",
  "file-system.file-open-error.generic-corrupted-file": "The file you tried to open is corrupted.",
  "file-system.confirm-open.title": "Overwrite current project?",
  "file-system.confirm-open.description": "Opening a file will replace your current project and any unsaved changes will be lost. Are you sure you want to continue?",
  "file-system.confirm-open.cancel": "Cancel",
  "file-system.confirm-open.open": "Open file",
  "file-system.confirm-open.dont-show-again": "Don't ask again",
  "file-system.shared-document-file-open-error.title": "Could not open file",
  "file-system.shared-document-file-open-error.description": "Opening files from shared projects is not supported.",
  "toast.error.export-fail.title": "Failed export",
  "toast.error.export-fail.desc": "Failed to export image",
  "toast.error.copy-fail.title": "Failed copy",
  "toast.error.copy-fail.desc": "Failed to copy image",
  "context.pages.new-page": "New page",
  "vscode.file-open.desc": "We've updated this document to work with the current version of tldraw. If you'd like to keep the original version (which will work on old.tldraw.com), click below to create a backup.",
  "vscode.file-open.open": "Continue",
  "vscode.file-open.backup": "Backup",
  "vscode.file-open.backup-saved": "Backup saved",
  "vscode.file-open.backup-failed": "Backup failed: this is not a .tldr file.",
  "vscode.file-open.dont-show-again": "Don't ask again"
}, E2 = [
  { locale: "ar", label: "عربي" },
  { locale: "ca", label: "Català" },
  { locale: "da", label: "Danish" },
  { locale: "de", label: "Deutsch" },
  { locale: "en", label: "English" },
  { locale: "es", label: "Español" },
  { locale: "fa", label: "فارسی" },
  { locale: "fi", label: "Suomi" },
  { locale: "fr", label: "Français" },
  { locale: "gl", label: "Galego" },
  { locale: "he", label: "עברית" },
  { locale: "it", label: "Italiano" },
  { locale: "ja", label: "日本語" },
  { locale: "ko-kr", label: "한국어" },
  { locale: "ku", label: "کوردی" },
  { locale: "hi-in", label: "हिन्दी" },
  { locale: "hu", label: "Magyar" },
  { locale: "my", label: "မြန်မာစာ" },
  { locale: "ne", label: "नेपाली" },
  { locale: "no", label: "Norwegian" },
  { locale: "pl", label: "Polski" },
  { locale: "pt-br", label: "Português - Brasil" },
  { locale: "pt-pt", label: "Português - Europeu" },
  { locale: "ro", label: "Română" },
  { locale: "ru", label: "Russian" },
  { locale: "sv", label: "Svenska" },
  { locale: "te", label: "తెలుగు" },
  { locale: "th", label: "ภาษาไทย" },
  { locale: "tr", label: "Türkçe" },
  { locale: "uk", label: "Ukrainian" },
  { locale: "vi", label: "Tiếng Việt" },
  { locale: "zh-cn", label: "Chinese - Simplified" },
  { locale: "zh-tw", label: "繁體中文 (台灣)" }
], bp = {
  locale: "en",
  label: "English",
  messages: OP
};
async function mce(t, e) {
  if (!(await fetch(e.translations.en)).ok)
    return console.warn("No main translations found."), bp;
  if (t === "en")
    return bp;
  const r = E2.find((f) => f.locale === t);
  if (!r)
    return console.warn(`No translation found for locale ${t}`), bp;
  const s = await (await fetch(e.translations[r.locale])).json();
  if (!s)
    return console.warn(`No messages found for locale ${t}`), bp;
  const c = [];
  for (const f in bp)
    s[f] || c.push(f);
  return c.length > 0 && {}.NODE_ENV === "development" && console.warn(`Language ${t}: missing messages for keys:
${c.join(`
`)}`), { ...bp, messages: { ...bp.messages, ...s } };
}
async function vce(t, e) {
  return await mce(t, e);
}
function U4() {
  const t = Ge();
  return { languages: E2, currentLanguage: t.user.locale };
}
const B4 = k.createContext(null);
function yce({
  assetUrls: t,
  children: e
}) {
  return /* @__PURE__ */ E.jsx(B4.Provider, { value: t, children: e });
}
function U1() {
  const t = k.useContext(B4);
  if (!t)
    throw new Error("useAssetUrls must be used within an AssetUrlsProvider");
  return t;
}
const F4 = k.createContext({}), bce = () => k.useContext(F4), Sce = dn(function({
  overrides: e,
  children: n
}) {
  const a = Ge().userSettings.locale, s = U1(), [c, f] = k.useState(() => e && e.en ? {
    locale: "en",
    label: "English",
    messages: { ...OP, ...e.en }
  } : {
    locale: "en",
    label: "English",
    messages: OP
  });
  return k.useEffect(() => {
    let p = !1;
    async function g() {
      const y = a ?? navigator.language.split(/[-_]/)[0], v = await vce(y, s);
      v && !p && (e && e[y] ? f({
        ...v,
        messages: { ...v.messages, ...e[y] }
      }) : f(v));
    }
    return g(), () => {
      p = !0;
    };
  }, [s, a, e]), /* @__PURE__ */ E.jsx(F4.Provider, { value: c, children: n });
});
function Fn() {
  const t = bce();
  return k.useCallback(
    function(n) {
      return t.messages[n] ?? n;
    },
    [t]
  );
}
function wce() {
  const t = Ge(), { addToast: e } = Hu(), n = Fn();
  return k.useCallback(
    // it's important that this function itself isn't async - we need to
    // create the relevant `ClipboardItem`s synchronously to make sure
    // safari knows that the user _wants_ to copy:
    // https://bugs.webkit.org/show_bug.cgi?id=222262
    //
    // this is fine for navigator.clipboard.write, but for fallbacks it's a
    // little awkward.
    function(a = t.selectedIds, s = "svg") {
      if (a.length === 0 && (a = [...t.shapeIds]), a.length !== 0)
        switch (s) {
          case "svg": {
            window.navigator.clipboard && (window.navigator.clipboard.write ? window.navigator.clipboard.write([
              new ClipboardItem({
                "text/plain": xce(t, a)
              })
            ]) : MN(
              async () => FL(await C2(t, a, s))
            ));
            break;
          }
          case "jpeg":
          case "png": {
            const c = s === "jpeg" ? "image/jpeg" : "image/png";
            window.navigator.clipboard.write([
              new ClipboardItem({
                // Note: This needs to use the promise based approach for safari/ios to not bail on a permissions error.
                [c]: Ece(t, a, s).then((f) => {
                  if (f) {
                    if (window.navigator.clipboard)
                      return f;
                    throw new Error("Copy not supported");
                  } else
                    throw e({
                      id: "copy-fail",
                      icon: "warning-triangle",
                      title: n("toast.error.copy-fail.title"),
                      description: n("toast.error.copy-fail.desc")
                    }), new Error("Copy not possible");
                })
              })
            ]);
            break;
          }
          case "json": {
            const c = t.getContent(a);
            if (window.navigator.clipboard) {
              const f = JSON.stringify(c);
              window.navigator.clipboard.write ? window.navigator.clipboard.write([
                new ClipboardItem({
                  "text/plain": new Blob([f], { type: "text/plain" })
                })
              ]) : MN(async () => f);
            }
            break;
          }
          default:
            throw new Error(`Copy type ${s} not supported.`);
        }
    },
    [t, e, n]
  );
}
async function C2(t, e, n) {
  const r = await t.getSvg(e, {
    scale: n === "svg" ? 1 : 2,
    background: t.instanceState.exportBackground
  });
  if (!r)
    throw new Error("Could not construct SVG.");
  return r;
}
async function xce(t, e) {
  return new Blob([FL(await C2(t, e, "svg"))], {
    type: "text/plain"
  });
}
async function Ece(t, e, n) {
  return await HL(await C2(t, e, n), {
    type: n,
    quality: 1,
    scale: 1
  });
}
async function MN(t) {
  navigator.clipboard.writeText(await t());
}
const H4 = k.createContext({});
function Cce({ children: t }) {
  const e = Ge(), [n, r] = k.useState([]), a = k.useCallback(
    (p) => {
      const g = p.id ?? $i();
      return r((y) => [...y.filter((v) => v.id !== p.id), { ...p, id: g }]), e.openMenus.add(g), g;
    },
    [e]
  ), s = k.useCallback(
    (p, g) => (r(
      (y) => y.map((v) => v.id === p ? {
        ...v,
        ...g
      } : v)
    ), e.openMenus.add(p), p),
    [e]
  ), c = k.useCallback(
    (p) => (r(
      (g) => g.filter((y) => y.id === p ? (y.onClose?.(), !1) : !0)
    ), e.openMenus.delete(p), p),
    [e]
  ), f = k.useCallback(() => {
    r((p) => (p.forEach((g) => {
      g.onClose?.(), e.openMenus.delete(g.id);
    }), []));
  }, [e]);
  return /* @__PURE__ */ E.jsx(
    H4.Provider,
    {
      value: { dialogs: n, addDialog: a, removeDialog: c, clearDialogs: f, updateDialog: s },
      children: t
    }
  );
}
function Vp() {
  const t = k.useContext(H4);
  if (!t)
    throw new Error("useDialogs must be used within a DialogsProvider");
  return t;
}
function _ce() {
  const t = Ge(), { addToast: e } = Hu(), n = Fn();
  return k.useCallback(
    async function(a = t.selectedIds, s = "png") {
      if (a.length === 0 && (a = [...t.shapeIds]), a.length === 0)
        return;
      const c = await t.getSvg(a, {
        scale: s === "svg" ? 1 : 2,
        background: t.instanceState.exportBackground
      });
      if (!c)
        throw new Error("Could not construct SVG.");
      const f = a.length === 1 ? t.getShapeById(a[0])?.id.replace(/:/, "_") : "shapes";
      switch (s) {
        case "svg": {
          const p = await VL(c);
          ek(p, `${f || "shapes"}.svg`);
          return;
        }
        case "webp":
        case "png": {
          const p = await HL(c, {
            type: s,
            quality: 1,
            scale: 1
          });
          if (!p) {
            e({
              id: "export-fail",
              // icon: 'error',
              title: n("toast.error.export-fail.title"),
              description: n("toast.error.export-fail.desc")
            });
            return;
          }
          const g = URL.createObjectURL(p);
          ek(g, `${f || "shapes"}.${s}`), URL.revokeObjectURL(g);
          return;
        }
        case "json": {
          const p = t.getContent(a), g = URL.createObjectURL(
            new Blob([JSON.stringify(p, null, 4)], { type: "application/json" })
          );
          ek(g, `${f || "shapes"}.json`), URL.revokeObjectURL(g);
          return;
        }
        default:
          throw new Error(`Export type ${s} not supported.`);
      }
    },
    [t, e, n]
  );
}
function V4() {
  const t = Ge(), e = k.useRef();
  return k.useEffect(() => {
    const n = window.document.createElement("input");
    n.type = "file", n.accept = vZ, n.multiple = !0, e.current = n;
    async function r(a) {
      const s = a.target.files;
      !s || s.length === 0 || (await g1(t, Array.from(s), t.viewportPageBounds.center, !1), n.value = "");
    }
    return n.addEventListener("change", r), () => {
      e.current = void 0, n.removeEventListener("change", r);
    };
  }, [t]), k.useCallback(() => {
    e.current?.click();
  }, [e]);
}
function Tce() {
  const t = Ge(), e = k.useRef(null), n = k.useRef(null);
  return k.useCallback(
    async function() {
      const a = document.createElement("div"), s = document.createElement("style"), c = (D, N) => {
        D && (D.innerHTML = ""), N && document.head.contains(N) && document.head.removeChild(N), D && document.body.contains(D) && document.body.removeChild(D);
      };
      c(e.current, n.current), e.current = a, n.current = s;
      const f = `rs-print-surface-${$i()}`;
      a.className = f, s.innerHTML = `
			.${f} {
				display: none;
			}

			.${f} svg {
				max-width: 100%;
				height: 100%;
				display: block;
			}

			@media print {				  
				html, body {
					min-height: 100%;
					height: 100%;
					margin: 0;
				}

				body {
					position: relative;
				}

				body > * {
					display: none;
				}

				.${f} {
					display: block !important;
					background: white;
					min-height: 100%;
					height: 100%;
					max-width: 100%;
				}

				.${f}__item {
					padding: 10mm;
					display: flex;
					min-height: 100%;
					flex-direction: column;
					page-break-after: always;
					position: relative;
					overflow: hidden;
					height: 100%;
				}

				.${f}__item__main {
					flex: 1;
					display: flex;
					align-items: center;
					justify-content: center;
					max-height: 100%;
				}

				.${f}__item__header {
					display: none;
				}

				.${f}__item__footer {
					display: none;
					text-align: right;
				}

				.${f}__item__footer__hide {
					display: none;
				}

				
			}

		`;
      const p = () => {
        document.head.appendChild(s), document.body.appendChild(a);
      }, g = () => {
        t.once("change-camera", () => {
          c(a, s);
        });
      };
      window.addEventListener("beforeprint", p), window.addEventListener("afterprint", g);
      function y(D, N, j) {
        try {
          a.innerHTML += `<div class="${f}__item">
        <div class="${f}__item__header">
          ${D.replace(/</g, "&lt;").replace(/>/g, "&gt;")}
        </div>
        <div class="${f}__item__main">
          ${j.outerHTML}
        </div>
        <div class="${f}__item__footer ${f}__item__footer__${N ? "" : "hide"}">
          ${N ?? ""}
        </div>
      </div>`;
        } catch (L) {
          console.error(L);
        }
      }
      function v() {
        t.isSafari ? (p(), document.execCommand("print", !1)) : window.print();
      }
      const { pages: S, currentPageId: x, selectedIds: _ } = t, I = {
        scale: 1,
        background: !1,
        darkMode: !1,
        preserveAspectRatio: "xMidYMid meet"
      };
      if (t.selectedIds.length > 0) {
        const D = await t.getSvg(_, I);
        if (D) {
          const N = S.find((j) => j.id === x);
          y(`tldraw — ${N?.name}`, null, D), v();
        }
      } else {
        const D = t.currentPage, N = await t.getSvg(t.getSortedChildIds(D.id), I);
        N && (y(`tldraw — ${D.name}`, null, N), v());
      }
      window.removeEventListener("beforeprint", p), window.removeEventListener("afterprint", g);
    },
    [t]
  );
}
const Y4 = k.createContext({});
function kce(t) {
  return Object.fromEntries(t.map((e) => [e.id, e]));
}
function Pce({ overrides: t, children: e }) {
  const n = Ge(), { addDialog: r, clearDialogs: a } = Vp(), { clearToasts: s } = Hu(), c = V4(), f = Tce(), { cut: p, copy: g } = x2(), y = wce(), v = _ce(), S = k.useMemo(() => {
    const x = kce([
      // 'new-project': {
      // 	id: 'file.new',
      // 	label: 'file.new',
      // 	onSelect() {
      // 		newFile()
      // 	},
      // },
      // 'open-project': {
      // 	id: 'file.open',
      // 	label: 'file.open',
      // 	kbd: '$o',
      // 	onSelect() {
      // 		openFile()
      // 	},
      // },
      // 'save-project': {
      // 	id: 'file.save',
      // 	label: 'file.save',
      // 	kbd: '$s',
      // 	onSelect() {
      // 		saveFile()
      // 	},
      // },
      // 'save-project-as': {
      // 	id: 'file.save-as',
      // 	label: 'file.save-as',
      // 	kbd: '$!s',
      // 	onSelect() {
      // 		saveFileAs()
      // 	},
      // },
      {
        id: "edit-link",
        label: "action.edit-link",
        icon: "link",
        readonlyOk: !1,
        onSelect() {
          n.mark("edit-link"), r({ component: ace });
        }
      },
      {
        id: "insert-media",
        label: "action.insert-media",
        kbd: "$u",
        readonlyOk: !1,
        onSelect() {
          c();
        }
      },
      {
        id: "undo",
        label: "action.undo",
        icon: "undo",
        kbd: "$z",
        readonlyOk: !1,
        onSelect() {
          n.undo();
        }
      },
      {
        id: "redo",
        label: "action.redo",
        icon: "redo",
        kbd: "$!z",
        readonlyOk: !1,
        onSelect() {
          n.redo();
        }
      },
      {
        id: "export-as-svg",
        label: "action.export-as-svg",
        menuLabel: "action.export-as-svg.short",
        contextMenuLabel: "action.export-as-svg.short",
        readonlyOk: !0,
        onSelect() {
          v(n.selectedIds, "svg");
        }
      },
      {
        id: "export-as-png",
        label: "action.export-as-png",
        menuLabel: "action.export-as-png.short",
        contextMenuLabel: "action.export-as-png.short",
        readonlyOk: !0,
        onSelect() {
          v(n.selectedIds, "png");
        }
      },
      {
        id: "export-as-json",
        label: "action.export-as-json",
        menuLabel: "action.export-as-json.short",
        contextMenuLabel: "action.export-as-json.short",
        readonlyOk: !0,
        onSelect() {
          v(n.selectedIds, "json");
        }
      },
      {
        id: "copy-as-svg",
        label: "action.copy-as-svg",
        menuLabel: "action.copy-as-svg.short",
        contextMenuLabel: "action.copy-as-svg.short",
        kbd: "$!c",
        readonlyOk: !0,
        onSelect() {
          y(n.selectedIds, "svg");
        }
      },
      {
        id: "copy-as-png",
        label: "action.copy-as-png",
        menuLabel: "action.copy-as-png.short",
        contextMenuLabel: "action.copy-as-png.short",
        readonlyOk: !0,
        onSelect() {
          y(n.selectedIds, "png");
        }
      },
      {
        id: "copy-as-json",
        label: "action.copy-as-json",
        menuLabel: "action.copy-as-json.short",
        contextMenuLabel: "action.copy-as-json.short",
        readonlyOk: !0,
        onSelect() {
          y(n.selectedIds, "json");
        }
      },
      {
        id: "toggle-auto-size",
        label: "action.toggle-auto-size",
        readonlyOk: !1,
        onSelect() {
          n.mark(), n.updateShapes(
            n.selectedShapes.filter((_) => _ && _.type === "text" && _.props.autoSize === !1).map((_) => ({
              id: _.id,
              type: _.type,
              props: {
                ..._.props,
                w: 8,
                autoSize: !0
              }
            }))
          );
        }
      },
      {
        id: "open-embed-link",
        label: "action.open-embed-link",
        readonlyOk: !0,
        onSelect() {
          const _ = n.selectedIds, T = "No embed shapes selected";
          if (_.length !== 1) {
            console.error(T);
            return;
          }
          const I = n.getShapeById(_[0]);
          if (!I || !nb.is(I)) {
            console.error(T);
            return;
          }
          BZ(I.props.url, "_blank");
        }
      },
      {
        id: "convert-to-bookmark",
        label: "action.convert-to-bookmark",
        readonlyOk: !1,
        onSelect() {
          const T = n.selectedIds.map((N) => n.getShapeById(N)), I = [], D = [];
          for (const N of T) {
            if (!N || !nb.is(N) || !N.props.url)
              continue;
            const j = new O(N.x, N.y);
            j.rot(-N.rotation), j.add(
              new O(
                N.props.w / 2 - DL / 2,
                N.props.h / 2 - NL / 2
              )
            ), j.rot(N.rotation), I.push({
              id: n.createShapeId(),
              type: "bookmark",
              rotation: N.rotation,
              x: j.x,
              y: j.y,
              props: {
                url: N.props.url,
                opacity: "1"
              }
            }), D.push(N.id);
          }
          n.mark("convert shapes to bookmark"), n.deleteShapes(D), n.createShapes(I);
        }
      },
      {
        id: "convert-to-embed",
        label: "action.convert-to-embed",
        readonlyOk: !1,
        onSelect() {
          const _ = n.selectedIds, T = Gt(_.map((N) => n.getShapeById(N))), I = [], D = [];
          for (const N of T) {
            if (!v1.is(N))
              continue;
            const { url: j } = N.props, L = Gd(N.props.url);
            if (!L || !L.definition)
              continue;
            const { width: z, height: F, doesResize: K } = L.definition, X = new O(N.x, N.y);
            X.rot(-N.rotation), X.add(new O(N.props.w / 2 - z / 2, N.props.h / 2 - F / 2)), X.rot(N.rotation), I.push({
              id: n.createShapeId(),
              type: "embed",
              x: X.x,
              y: X.y,
              rotation: N.rotation,
              props: {
                url: j,
                w: z,
                h: F,
                doesResize: K
              }
            }), D.push(N.id);
          }
          n.mark("convert shapes to embed"), n.deleteShapes(D), n.createShapes(I);
        }
      },
      {
        id: "duplicate",
        kbd: "$d",
        label: "action.duplicate",
        icon: "duplicate",
        readonlyOk: !1,
        onSelect() {
          if (n.currentToolId !== "select")
            return;
          const _ = n.selectedIds, T = ot.Common(Gt(_.map((D) => n.getPageBoundsById(D)))), I = n.canMoveCamera ? {
            x: T.width + 10,
            y: 0
          } : {
            x: 16 / n.camera.z,
            y: 16 / n.camera.z
          };
          n.mark("duplicate shapes"), n.duplicateShapes(_, I);
        }
      },
      {
        id: "ungroup",
        label: "action.ungroup",
        kbd: "$!g",
        icon: "ungroup",
        readonlyOk: !1,
        onSelect() {
          n.mark("ungroup"), n.ungroupShapes(n.selectedIds);
        }
      },
      {
        id: "group",
        label: "action.group",
        kbd: "$g",
        icon: "group",
        readonlyOk: !1,
        onSelect() {
          n.selectedShapes.length === 1 && n.selectedShapes[0].type === "group" ? (n.mark("ungroup"), n.ungroupShapes(n.selectedIds)) : (n.mark("group"), n.groupShapes(n.selectedIds));
        }
      },
      {
        id: "align-left",
        label: "action.align-left",
        kbd: "?A",
        icon: "align-left",
        readonlyOk: !1,
        onSelect() {
          n.mark("align left"), n.alignShapes("left", n.selectedIds);
        }
      },
      {
        id: "align-center-horizontal",
        label: "action.align-center-horizontal",
        contextMenuLabel: "action.align-center-horizontal.short",
        kbd: "?H",
        icon: "align-center-horizontal",
        readonlyOk: !1,
        onSelect() {
          n.mark("align center horizontal"), n.alignShapes("center-horizontal", n.selectedIds);
        }
      },
      {
        id: "align-right",
        label: "action.align-right",
        kbd: "?D",
        icon: "align-right",
        readonlyOk: !1,
        onSelect() {
          n.mark("align right"), n.alignShapes("right", n.selectedIds);
        }
      },
      {
        id: "align-center-vertical",
        label: "action.align-center-vertical",
        contextMenuLabel: "action.align-center-vertical.short",
        kbd: "?V",
        icon: "align-center-vertical",
        readonlyOk: !1,
        onSelect() {
          n.mark("align center vertical"), n.alignShapes("center-vertical", n.selectedIds);
        }
      },
      {
        id: "align-top",
        label: "action.align-top",
        icon: "align-top",
        kbd: "?W",
        readonlyOk: !1,
        onSelect() {
          n.mark("align top"), n.alignShapes("top", n.selectedIds);
        }
      },
      {
        id: "align-bottom",
        label: "action.align-bottom",
        icon: "align-bottom",
        kbd: "?S",
        readonlyOk: !1,
        onSelect() {
          n.mark("align bottom"), n.alignShapes("bottom", n.selectedIds);
        }
      },
      {
        id: "distribute-horizontal",
        label: "action.distribute-horizontal",
        contextMenuLabel: "action.distribute-horizontal.short",
        icon: "distribute-horizontal",
        readonlyOk: !1,
        onSelect() {
          n.mark("distribute horizontal"), n.distributeShapes("horizontal", n.selectedIds);
        }
      },
      {
        id: "distribute-vertical",
        label: "action.distribute-vertical",
        contextMenuLabel: "action.distribute-vertical.short",
        icon: "distribute-vertical",
        readonlyOk: !1,
        onSelect() {
          n.mark("distribute vertical"), n.distributeShapes("vertical", n.selectedIds);
        }
      },
      {
        id: "stretch-horizontal",
        label: "action.stretch-horizontal",
        contextMenuLabel: "action.stretch-horizontal.short",
        icon: "stretch-horizontal",
        readonlyOk: !1,
        onSelect() {
          n.mark("stretch horizontal"), n.stretchShapes("horizontal", n.selectedIds);
        }
      },
      {
        id: "stretch-vertical",
        label: "action.stretch-vertical",
        contextMenuLabel: "action.stretch-vertical.short",
        icon: "stretch-vertical",
        readonlyOk: !1,
        onSelect() {
          n.mark("stretch vertical"), n.stretchShapes("vertical", n.selectedIds);
        }
      },
      {
        id: "flip-horizontal",
        label: "action.flip-horizontal",
        contextMenuLabel: "action.flip-horizontal.short",
        kbd: "!h",
        readonlyOk: !1,
        onSelect() {
          n.mark("flip horizontal"), n.flipShapes("horizontal", n.selectedIds);
        }
      },
      {
        id: "flip-vertical",
        label: "action.flip-vertical",
        contextMenuLabel: "action.flip-vertical.short",
        kbd: "!v",
        readonlyOk: !1,
        onSelect() {
          n.mark("flip vertical"), n.flipShapes("vertical", n.selectedIds);
        }
      },
      {
        id: "pack",
        label: "action.pack",
        icon: "pack",
        readonlyOk: !1,
        onSelect() {
          n.mark("pack"), n.packShapes(n.selectedIds);
        }
      },
      {
        id: "stack-vertical",
        label: "action.stack-vertical",
        contextMenuLabel: "action.stack-vertical.short",
        icon: "stack-vertical",
        readonlyOk: !1,
        onSelect() {
          n.mark("stack-vertical"), n.stackShapes("vertical", n.selectedIds);
        }
      },
      {
        id: "stack-horizontal",
        label: "action.stack-horizontal",
        contextMenuLabel: "action.stack-horizontal.short",
        icon: "stack-horizontal",
        readonlyOk: !1,
        onSelect() {
          n.mark("stack-horizontal"), n.stackShapes("horizontal", n.selectedIds);
        }
      },
      {
        id: "bring-to-front",
        label: "action.bring-to-front",
        kbd: "]",
        icon: "bring-to-front",
        readonlyOk: !1,
        onSelect() {
          n.mark("bring to front"), n.bringToFront();
        }
      },
      {
        id: "bring-forward",
        label: "action.bring-forward",
        icon: "bring-forward",
        kbd: "?]",
        readonlyOk: !1,
        onSelect() {
          n.mark("bring forward"), n.bringForward();
        }
      },
      {
        id: "send-backward",
        label: "action.send-backward",
        icon: "send-backward",
        kbd: "?[",
        readonlyOk: !1,
        onSelect() {
          n.mark("send backward"), n.sendBackward();
        }
      },
      {
        id: "send-to-back",
        label: "action.send-to-back",
        icon: "send-to-back",
        kbd: "[",
        readonlyOk: !1,
        onSelect() {
          n.mark("send to back"), n.sendToBack();
        }
      },
      {
        id: "cut",
        label: "action.cut",
        kbd: "$x",
        readonlyOk: !1,
        onSelect() {
          n.mark("cut"), p();
        }
      },
      {
        id: "copy",
        label: "action.copy",
        kbd: "$c",
        readonlyOk: !0,
        onSelect() {
          g();
        }
      },
      {
        id: "paste",
        label: "action.paste",
        kbd: "$v",
        readonlyOk: !1,
        onSelect() {
        }
      },
      {
        id: "select-all",
        label: "action.select-all",
        kbd: "$a",
        readonlyOk: !0,
        onSelect() {
          n.currentToolId !== "select" && (n.cancel(), n.setSelectedTool("select")), n.mark("select all kbd"), n.selectAll();
        }
      },
      {
        id: "select-none",
        label: "action.select-none",
        readonlyOk: !0,
        onSelect() {
          n.mark("select none"), n.selectNone();
        }
      },
      {
        id: "delete",
        label: "action.delete",
        kbd: "⌫",
        icon: "trash",
        readonlyOk: !1,
        onSelect() {
          n.currentToolId === "select" && (n.mark("delete"), n.deleteShapes());
        }
      },
      {
        id: "rotate-cw",
        label: "action.rotate-cw",
        icon: "rotate-cw",
        readonlyOk: !1,
        onSelect() {
          if (n.selectedIds.length === 0)
            return;
          n.mark("rotate-cw");
          const _ = n.selectionRotation % (cr / 2), T = Fy(_, 0) || Fy(_, cr / 2);
          n.rotateShapesBy(n.selectedIds, cr / 2 - (T ? 0 : _));
        }
      },
      {
        id: "rotate-ccw",
        label: "action.rotate-ccw",
        icon: "rotate-ccw",
        readonlyOk: !1,
        onSelect() {
          if (n.selectedIds.length === 0)
            return;
          n.mark("rotate-ccw");
          const _ = n.selectionRotation % (cr / 2), T = Fy(_, 0);
          n.rotateShapesBy(n.selectedIds, T ? -(cr / 2) : -_);
        }
      },
      {
        id: "zoom-in",
        label: "action.zoom-in",
        kbd: "$=",
        readonlyOk: !0,
        onSelect() {
          n.zoomIn(n.viewportScreenCenter, { duration: Au });
        }
      },
      {
        id: "zoom-out",
        label: "action.zoom-out",
        kbd: "$-",
        readonlyOk: !0,
        onSelect() {
          n.zoomOut(n.viewportScreenCenter, { duration: Au });
        }
      },
      {
        id: "zoom-to-100",
        label: "action.zoom-to-100",
        icon: "reset-zoom",
        kbd: "!0",
        readonlyOk: !0,
        onSelect() {
          n.resetZoom(n.viewportScreenCenter, { duration: Au });
        }
      },
      {
        id: "zoom-to-fit",
        label: "action.zoom-to-fit",
        kbd: "!1",
        readonlyOk: !0,
        onSelect() {
          n.zoomToFit({ duration: Au });
        }
      },
      {
        id: "zoom-to-selection",
        label: "action.zoom-to-selection",
        kbd: "!2",
        readonlyOk: !0,
        onSelect() {
          n.zoomToSelection({ duration: Au });
        }
      },
      {
        id: "toggle-snap-mode",
        label: "action.toggle-snap-mode",
        menuLabel: "action.toggle-snap-mode.menu",
        readonlyOk: !1,
        onSelect() {
          n.updateUserDocumentSettings(
            {
              isSnapMode: !n.userDocumentSettings.isSnapMode
            },
            !0
          );
        },
        checkbox: !0
      },
      {
        id: "toggle-dark-mode",
        label: "action.toggle-dark-mode",
        menuLabel: "action.toggle-dark-mode.menu",
        kbd: "$/",
        readonlyOk: !0,
        onSelect() {
          n.updateUserDocumentSettings(
            {
              isDarkMode: !n.userDocumentSettings.isDarkMode
            },
            !0
          );
        },
        checkbox: !0
      },
      {
        id: "toggle-transparent",
        label: "action.toggle-transparent",
        menuLabel: "action.toggle-transparent.menu",
        contextMenuLabel: "action.toggle-transparent.context-menu",
        readonlyOk: !0,
        onSelect() {
          n.updateInstanceState(
            {
              exportBackground: !n.instanceState.exportBackground
            },
            !0
          );
        },
        checkbox: !0
      },
      {
        id: "toggle-tool-lock",
        label: "action.toggle-tool-lock",
        menuLabel: "action.toggle-tool-lock.menu",
        readonlyOk: !1,
        kbd: "q",
        onSelect() {
          n.updateInstanceState(
            {
              isToolLocked: !n.instanceState.isToolLocked
            },
            !0
          );
        },
        checkbox: !0
      },
      {
        id: "toggle-focus-mode",
        label: "action.toggle-focus-mode",
        menuLabel: "action.toggle-focus-mode.menu",
        readonlyOk: !0,
        kbd: "$.",
        checkbox: !0,
        onSelect() {
          requestAnimationFrame(() => {
            n.batch(() => {
              a(), s(), n.updateInstanceState(
                {
                  isFocusMode: !n.instanceState.isFocusMode
                },
                !0
              );
            });
          });
        }
      },
      {
        id: "toggle-grid",
        label: "action.toggle-grid",
        menuLabel: "action.toggle-grid.menu",
        readonlyOk: !0,
        kbd: "$'",
        onSelect() {
          n.updateUserDocumentSettings(
            {
              isGridMode: !n.userDocumentSettings.isGridMode
            },
            !0
          );
        },
        checkbox: !0
      },
      {
        id: "toggle-debug-mode",
        label: "action.toggle-debug-mode",
        menuLabel: "action.toggle-debug-mode.menu",
        readonlyOk: !0,
        onSelect() {
          n.updateInstanceState(
            {
              isDebugMode: !n.instanceState.isDebugMode
            },
            !0
          );
        },
        checkbox: !0
      },
      {
        id: "print",
        label: "action.print",
        kbd: "$p",
        readonlyOk: !0,
        onSelect() {
          f();
        }
      },
      {
        id: "nudge-left",
        kbd: "left,shift+left",
        label: "action.nudge-left",
        readonlyOk: !1,
        onSelect() {
          n.mark("nudge left"), n.nudgeShapes(n.selectedIds, "left", n.inputs.shiftKey);
        }
      },
      {
        id: "nudge-up",
        kbd: "up,shift+up",
        label: "action.nudge-up",
        readonlyOk: !1,
        onSelect() {
          n.mark("nudge up"), n.nudgeShapes(n.selectedIds, "up", n.inputs.shiftKey);
        }
      },
      {
        id: "nudge-right",
        kbd: "right,shift+right",
        label: "action.nudge-right",
        readonlyOk: !1,
        onSelect() {
          n.mark("nudge right"), n.nudgeShapes(n.selectedIds, "right", n.inputs.shiftKey);
        }
      },
      {
        id: "nudge-down",
        kbd: "down,shift+down",
        label: "action.nudge-down",
        readonlyOk: !1,
        onSelect() {
          n.mark("nudge down"), n.nudgeShapes(n.selectedIds, "down", n.inputs.shiftKey);
        }
      },
      {
        id: "exit-pen-mode",
        label: "action.exit-pen-mode",
        icon: "cross-2",
        readonlyOk: !0,
        onSelect() {
          n.setPenMode(!1);
        }
      },
      {
        id: "back-to-content",
        label: "action.back-to-content",
        icon: "arrow-left",
        readonlyOk: !0,
        onSelect() {
          const _ = n.selectedPageBounds ?? n.allShapesCommonBounds;
          _ && n.zoomToBounds(
            _.minX,
            _.minY,
            _.width,
            _.height,
            Math.min(1, n.camera.z),
            { duration: 220 }
          );
        }
      }
    ]);
    return t ? t(n, x, void 0) : x;
  }, [
    t,
    n,
    r,
    c,
    v,
    y,
    p,
    g,
    a,
    s,
    f
  ]);
  return /* @__PURE__ */ E.jsx(Y4.Provider, { value: S, children: e });
}
function ba() {
  const t = k.useContext(Y4);
  if (!t)
    throw new Error("useTools must be used within a ToolProvider");
  return t;
}
const Ice = [0, 380, 420, 460, 580, 640, 840, 1023], K4 = It.createContext(0);
function Rce({ children: t }) {
  const e = Ge(), n = un(
    "breakpoint",
    () => {
      const { width: r } = e.viewportScreenBounds, a = Ice;
      for (let s = 0; s < a.length - 1; s++)
        if (r > a[s] && r <= a[s + 1])
          return s;
      return a.length;
    },
    [e]
  );
  return /* @__PURE__ */ E.jsx(K4.Provider, { value: n, children: t });
}
function qs() {
  let t = k.useContext(K4);
  const e = new URL(window.location.href).searchParams.get("layout");
  return e === "desktop" ? t = 7 : e === "mobile" && (t = 1), t;
}
function _2() {
  const t = Ge();
  return un(
    "hasLinkShapeSelected",
    () => {
      const { selectedShapes: e } = t;
      return e.length === 1 && "url" in e[0].props && e[0].type !== "embed";
    },
    [t]
  );
}
const W4 = It.createContext({}), $ce = dn(function({
  overrides: e,
  children: n
}) {
  const r = Ge(), a = ba(), s = r.selectedIds.length, c = s > 0, f = s > 1, p = s > 2, g = c4(), y = d2(), v = f2(), S = _2(), x = qs(), _ = r.camera.z === 1, T = k.useMemo(() => {
    const I = [
      Ie(a["align-left"], { disabled: !f }),
      Ie(a["align-center-horizontal"], { disabled: !f }),
      Ie(a["align-right"], { disabled: !f }),
      Ie(a["stretch-horizontal"], { disabled: !f }),
      Ie(a["align-top"], { disabled: !f }),
      Ie(a["align-center-vertical"], { disabled: !f }),
      Ie(a["align-bottom"], { disabled: !f }),
      Ie(a["stretch-vertical"], { disabled: !f }),
      Ie(a["distribute-horizontal"], { disabled: !p }),
      Ie(a["distribute-vertical"], { disabled: !p }),
      Ie(a["stack-horizontal"], { disabled: !g }),
      Ie(a["stack-vertical"], { disabled: !g }),
      Ie(a["send-to-back"], { disabled: !c }),
      Ie(a["send-backward"], { disabled: !c }),
      Ie(a["bring-forward"], { disabled: !c }),
      Ie(a["bring-to-front"], { disabled: !c }),
      x < 5 ? Ie(a["zoom-to-100"], { disabled: !!_ }) : Ie(a["rotate-ccw"], { disabled: !c }),
      Ie(a["rotate-cw"], { disabled: !c }),
      Ie(a["edit-link"], { disabled: !S }),
      y ? Ie(a.group, { disabled: !f }) : v ? Ie(a.ungroup) : Ie(a.group, { disabled: !f })
    ];
    return e ? e(r, I, { actions: a, oneSelected: c, twoSelected: f, threeSelected: p }) : I;
  }, [
    r,
    _,
    y,
    e,
    a,
    c,
    f,
    p,
    g,
    v,
    S,
    x
  ]);
  return /* @__PURE__ */ E.jsx(W4.Provider, { value: T, children: n });
});
function Mce() {
  const t = It.useContext(W4);
  if (!t)
    throw new Error("useActionsMenuSchema must be used inside of a ActionsMenuSchemaProvider.");
  return t;
}
function Ace() {
  const t = Ge(), { addToast: e } = Hu();
  k.useEffect(() => {
    function n({ name: a, count: s }) {
      e({
        title: "Maximum Shapes Reached",
        description: `You've reached the maximum number of shapes allowed on ${a} (${s}). Please delete some shapes or move to a different page to continue.`
      });
    }
    function r({ name: a, fromId: s }) {
      e({
        title: "Changed Page",
        description: `Moved to ${a}.`,
        actions: [
          {
            label: "Go Back",
            type: "primary",
            onClick: () => {
              t.mark("change-page"), t.setCurrentPageId(s);
            }
          }
          // prev page
        ]
      });
    }
    return t.addListener("max-shapes", n), t.addListener("moved-to-page", r), () => {
      t.removeListener("max-shapes", n), t.removeListener("moved-to-page", r);
    };
  }, [t, e]);
}
function G4() {
  const t = Ge();
  return un("useCanRedo", () => t.canRedo, [t]);
}
function X4() {
  const t = Ge();
  return un("useCanUndo", () => t.canUndo, [t]);
}
function Oce() {
  const t = Ge();
  return un(
    "onlyFlippableShape",
    () => {
      const { selectedShapes: e } = t;
      return e.length === 1 && e.every((n) => n.type === "group" || ure(n));
    },
    [t]
  );
}
function q4() {
  const t = Ge();
  return un(
    "showAutoSizeToggle",
    () => {
      const { selectedShapes: e } = t;
      return e.length === 1 && e[0].type === "text" && e[0].props.autoSize === !1;
    },
    [t]
  );
}
const Q4 = It.createContext({}), Dce = typeof window < "u" && "navigator" in window && !!navigator.clipboard && !!navigator.clipboard.read, Nce = dn(function({
  overrides: e,
  children: n
}) {
  const r = Ge(), a = ba(), s = q4(), c = Oce(), f = r.selectedIds.length, p = f > 0, g = un(
    "oneEmbedSelected",
    () => r.selectedIds.length !== 1 ? !1 : r.selectedIds.some((z) => {
      const F = r.getShapeById(z);
      return F && nb.is(F) && F.props.url;
    }),
    []
  ), y = un(
    "oneEmbeddableBookmarkSelected",
    () => r.selectedIds.length !== 1 ? !1 : r.selectedIds.some((z) => {
      const F = r.getShapeById(z);
      return F && v1.is(F) && Gd(F.props.url);
    }),
    []
  ), v = f > 1, S = f > 2, x = c4(), _ = un("atLeastOneShapeOnPage", () => r.shapeIds.size > 0, []), T = un("isTransparentBg", () => r.instanceState.exportBackground, []), I = d2(), D = f2(), N = !!window.navigator.clipboard?.write, j = _2(), L = k.useMemo(() => {
    let z = u2([
      wn(
        "selection",
        g && Ie(a["open-embed-link"]),
        g && Ie(a["convert-to-bookmark"]),
        y && Ie(a["convert-to-embed"]),
        s && Ie(a["toggle-auto-size"]),
        j && Ie(a["edit-link"]),
        p && Ie(a.duplicate),
        I && Ie(a.group),
        D && Ie(a.ungroup)
      ),
      wn(
        "modify",
        (v || c) && _c(
          "arrange",
          "context-menu.arrange",
          v && wn(
            "align",
            Ie(a["align-left"]),
            Ie(a["align-center-horizontal"]),
            Ie(a["align-right"]),
            Ie(a["align-top"]),
            Ie(a["align-center-vertical"]),
            Ie(a["align-bottom"])
          ),
          S && wn(
            "distribute",
            Ie(a["distribute-horizontal"]),
            Ie(a["distribute-vertical"])
          ),
          v && wn(
            "stretch",
            Ie(a["stretch-horizontal"]),
            Ie(a["stretch-vertical"])
          ),
          c && wn(
            "flip",
            Ie(a["flip-horizontal"]),
            Ie(a["flip-vertical"])
          ),
          v && wn(
            "order",
            Ie(a.pack, { disabled: !v }),
            x && Ie(a["stack-vertical"]),
            x && Ie(a["stack-horizontal"])
          )
        ),
        p && _c(
          "reorder",
          "context-menu.reorder",
          wn(
            "reorder",
            Ie(a["bring-to-front"]),
            Ie(a["bring-forward"]),
            Ie(a["send-backward"]),
            Ie(a["send-to-back"])
          )
        ),
        p && Wx("MOVE_TO_PAGE_MENU", { readonlyOk: !1 })
      ),
      wn(
        "clipboard-group",
        p && Ie(a.cut),
        p && Ie(a.copy),
        Dce && Wx("MENU_PASTE", { readonlyOk: !1 })
      ),
      _ && wn(
        "conversions",
        _c(
          "copy-as",
          "context-menu.copy-as",
          wn(
            "copy-as-group",
            Ie(a["copy-as-svg"]),
            N && Ie(a["copy-as-png"]),
            Ie(a["copy-as-json"])
          ),
          wn(
            "export-bg",
            Ie(a["toggle-transparent"], { checked: !T })
          )
        ),
        _c(
          "export-as",
          "context-menu.export-as",
          wn(
            "export-as-group",
            Ie(a["export-as-svg"]),
            Ie(a["export-as-png"]),
            Ie(a["export-as-json"])
          ),
          wn(
            "export-bg,",
            Ie(a["toggle-transparent"], { checked: !T })
          )
        )
      ),
      _ && wn(
        "set-selection-group",
        Ie(a["select-all"]),
        p && Ie(a["select-none"])
      ),
      p && wn("delete-group", Ie(a.delete))
    ]);
    return e && (z = e(r, z, {
      actions: a,
      oneSelected: p,
      twoSelected: v,
      threeSelected: S,
      showAutoSizeToggle: s,
      showUngroup: D,
      onlyFlippableShapeSelected: c
    })), z;
  }, [
    r,
    e,
    a,
    p,
    v,
    S,
    s,
    c,
    _,
    x,
    I,
    D,
    N,
    j,
    g,
    y,
    T
  ]);
  return /* @__PURE__ */ E.jsx(Q4.Provider, { value: L, children: n });
});
function Z4() {
  const t = It.useContext(Q4);
  if (!t)
    throw new Error("useContextMenuSchema must be used inside of a ContextMenuSchemaProvider.");
  return t;
}
const Lce = () => {
  const t = Fn(), e = Vu(), n = iue();
  function r(a) {
    if (e && !a.readonlyOk)
      return null;
    switch (a.type) {
      case "group":
        return /* @__PURE__ */ E.jsxs("div", { className: "tlui-shortcuts-dialog__group", children: [
          /* @__PURE__ */ E.jsx("h2", { className: "tlui-shortcuts-dialog__group__title", children: t(a.id) }),
          /* @__PURE__ */ E.jsx("div", { className: "tlui-shortcuts-dialog__group__content", children: a.children.filter((s) => s.type === "item" && s.actionItem.kbd).map(r) })
        ] }, a.id);
      case "item": {
        const { id: s, label: c, shortcutsLabel: f, kbd: p } = a.actionItem;
        return /* @__PURE__ */ E.jsxs("div", { className: "tlui-shortcuts-dialog__key-pair", children: [
          /* @__PURE__ */ E.jsx("div", { className: "tlui-shortcuts-dialog__key-pair__key", children: t(f ?? c) }),
          /* @__PURE__ */ E.jsx("div", { className: "tlui-shortcuts-dialog__key-pair__value", children: /* @__PURE__ */ E.jsx(D1, { children: p }) })
        ] }, s);
      }
    }
  }
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsxs(N1, { className: "tlui-shortcuts-dialog__header", children: [
      /* @__PURE__ */ E.jsx(L1, { children: t("shortcuts-dialog.title") }),
      /* @__PURE__ */ E.jsx(j1, {})
    ] }),
    /* @__PURE__ */ E.jsx(cb, { className: "tlui-shortcuts-dialog__body", children: n.map(r) }),
    /* @__PURE__ */ E.jsx("div", { className: "tlui-dialog__scrim" })
  ] });
}, J4 = It.createContext({}), jce = dn(function({
  overrides: e,
  children: n
}) {
  const r = Ge(), a = ba(), s = r.selectedIds.length, c = s > 0, f = s > 1, p = s > 2, { languages: g, currentLanguage: y } = U4(), { addDialog: v } = Vp(), S = k.useMemo(() => {
    const x = Gt([
      wn(
        "top",
        Wx("LANGUAGE_MENU", { readonlyOk: !0 }),
        Ie({
          id: "keyboard-shortcuts",
          label: "help-menu.keyboard-shortcuts",
          readonlyOk: !0,
          onSelect() {
            v({ component: Lce });
          }
        })
      )
    ]);
    return e ? e(r, x, {
      actions: a,
      currentLanguage: y,
      languages: g,
      oneSelected: c,
      twoSelected: f,
      threeSelected: p
    }) : x;
  }, [
    r,
    e,
    g,
    a,
    c,
    f,
    p,
    y,
    v
  ]);
  return /* @__PURE__ */ E.jsx(J4.Provider, { value: S, children: n });
});
function zce() {
  const t = It.useContext(J4);
  if (!t)
    throw new Error("useHelpMenuSchema must be used inside of a helpMenuSchemaProvider.");
  return t;
}
var Rk = typeof navigator < "u" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : !1;
function $k(t, e, n, r) {
  t.addEventListener ? t.addEventListener(e, n, r) : t.attachEvent && t.attachEvent("on".concat(e), function() {
    n(window.event);
  });
}
function e5(t, e) {
  for (var n = e.slice(0, e.length - 1), r = 0; r < n.length; r++)
    n[r] = t[n[r].toLowerCase()];
  return n;
}
function t5(t) {
  typeof t != "string" && (t = ""), t = t.replace(/\s/g, "");
  for (var e = t.split(","), n = e.lastIndexOf(""); n >= 0; )
    e[n - 1] += ",", e.splice(n, 1), n = e.lastIndexOf("");
  return e;
}
function Uce(t, e) {
  for (var n = t.length >= e.length ? t : e, r = t.length >= e.length ? e : t, a = !0, s = 0; s < n.length; s++)
    r.indexOf(n[s]) === -1 && (a = !1);
  return a;
}
var db = {
  backspace: 8,
  "⌫": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "↩": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "⇪": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": Rk ? 173 : 189,
  "=": Rk ? 61 : 187,
  ";": Rk ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
}, Rc = {
  // shiftKey
  "⇧": 16,
  shift: 16,
  // altKey
  "⌥": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "⌃": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "⌘": 91,
  cmd: 91,
  command: 91
}, DP = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
}, Eo = {
  16: !1,
  18: !1,
  17: !1,
  91: !1
}, Ri = {};
for (var ex = 1; ex < 20; ex++)
  db["f".concat(ex)] = 111 + ex;
var jr = [], AN = !1, n5 = "all", r5 = [], B1 = function(e) {
  return db[e.toLowerCase()] || Rc[e.toLowerCase()] || e.toUpperCase().charCodeAt(0);
}, Bce = function(e) {
  return Object.keys(db).find(function(n) {
    return db[n] === e;
  });
}, Fce = function(e) {
  return Object.keys(Rc).find(function(n) {
    return Rc[n] === e;
  });
};
function i5(t) {
  n5 = t || "all";
}
function fb() {
  return n5 || "all";
}
function Hce() {
  return jr.slice(0);
}
function Vce() {
  return jr.map(function(t) {
    return Bce(t) || Fce(t) || String.fromCharCode(t);
  });
}
function Yce(t) {
  var e = t.target || t.srcElement, n = e.tagName, r = !0;
  return (e.isContentEditable || (n === "INPUT" || n === "TEXTAREA" || n === "SELECT") && !e.readOnly) && (r = !1), r;
}
function Kce(t) {
  return typeof t == "string" && (t = B1(t)), jr.indexOf(t) !== -1;
}
function Wce(t, e) {
  var n, r;
  t || (t = fb());
  for (var a in Ri)
    if (Object.prototype.hasOwnProperty.call(Ri, a))
      for (n = Ri[a], r = 0; r < n.length; )
        n[r].scope === t ? n.splice(r, 1) : r++;
  fb() === t && i5(e || "all");
}
function Gce(t) {
  var e = t.keyCode || t.which || t.charCode, n = jr.indexOf(e);
  if (n >= 0 && jr.splice(n, 1), t.key && t.key.toLowerCase() === "meta" && jr.splice(0, jr.length), (e === 93 || e === 224) && (e = 91), e in Eo) {
    Eo[e] = !1;
    for (var r in Rc)
      Rc[r] === e && (ua[r] = !1);
  }
}
function Xce(t) {
  if (typeof t > "u")
    Object.keys(Ri).forEach(function(c) {
      return delete Ri[c];
    });
  else if (Array.isArray(t))
    t.forEach(function(c) {
      c.key && Mk(c);
    });
  else if (typeof t == "object")
    t.key && Mk(t);
  else if (typeof t == "string") {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
      n[r - 1] = arguments[r];
    var a = n[0], s = n[1];
    typeof a == "function" && (s = a, a = ""), Mk({
      key: t,
      scope: a,
      method: s,
      splitKey: "+"
    });
  }
}
var Mk = function(e) {
  var n = e.key, r = e.scope, a = e.method, s = e.splitKey, c = s === void 0 ? "+" : s, f = t5(n);
  f.forEach(function(p) {
    var g = p.split(c), y = g.length, v = g[y - 1], S = v === "*" ? "*" : B1(v);
    if (Ri[S]) {
      r || (r = fb());
      var x = y > 1 ? e5(Rc, g) : [];
      Ri[S] = Ri[S].filter(function(_) {
        var T = a ? _.method === a : !0;
        return !(T && _.scope === r && Uce(_.mods, x));
      });
    }
  });
};
function ON(t, e, n, r) {
  if (e.element === r) {
    var a;
    if (e.scope === n || e.scope === "all") {
      a = e.mods.length > 0;
      for (var s in Eo)
        Object.prototype.hasOwnProperty.call(Eo, s) && (!Eo[s] && e.mods.indexOf(+s) > -1 || Eo[s] && e.mods.indexOf(+s) === -1) && (a = !1);
      (e.mods.length === 0 && !Eo[16] && !Eo[18] && !Eo[17] && !Eo[91] || a || e.shortcut === "*") && e.method(t, e) === !1 && (t.preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation && t.stopPropagation(), t.cancelBubble && (t.cancelBubble = !0));
    }
  }
}
function DN(t, e) {
  var n = Ri["*"], r = t.keyCode || t.which || t.charCode;
  if (ua.filter.call(this, t)) {
    if ((r === 93 || r === 224) && (r = 91), jr.indexOf(r) === -1 && r !== 229 && jr.push(r), ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(_) {
      var T = DP[_];
      t[_] && jr.indexOf(T) === -1 ? jr.push(T) : !t[_] && jr.indexOf(T) > -1 ? jr.splice(jr.indexOf(T), 1) : _ === "metaKey" && t[_] && jr.length === 3 && (t.ctrlKey || t.shiftKey || t.altKey || (jr = jr.slice(jr.indexOf(T))));
    }), r in Eo) {
      Eo[r] = !0;
      for (var a in Rc)
        Rc[a] === r && (ua[a] = !0);
      if (!n)
        return;
    }
    for (var s in Eo)
      Object.prototype.hasOwnProperty.call(Eo, s) && (Eo[s] = t[DP[s]]);
    t.getModifierState && !(t.altKey && !t.ctrlKey) && t.getModifierState("AltGraph") && (jr.indexOf(17) === -1 && jr.push(17), jr.indexOf(18) === -1 && jr.push(18), Eo[17] = !0, Eo[18] = !0);
    var c = fb();
    if (n)
      for (var f = 0; f < n.length; f++)
        n[f].scope === c && (t.type === "keydown" && n[f].keydown || t.type === "keyup" && n[f].keyup) && ON(t, n[f], c, e);
    if (r in Ri) {
      for (var p = 0; p < Ri[r].length; p++)
        if ((t.type === "keydown" && Ri[r][p].keydown || t.type === "keyup" && Ri[r][p].keyup) && Ri[r][p].key) {
          for (var g = Ri[r][p], y = g.splitKey, v = g.key.split(y), S = [], x = 0; x < v.length; x++)
            S.push(B1(v[x]));
          S.sort().join("") === jr.sort().join("") && ON(t, g, c, e);
        }
    }
  }
}
function qce(t) {
  return r5.indexOf(t) > -1;
}
function ua(t, e, n) {
  jr = [];
  var r = t5(t), a = [], s = "all", c = document, f = 0, p = !1, g = !0, y = "+", v = !1;
  for (n === void 0 && typeof e == "function" && (n = e), Object.prototype.toString.call(e) === "[object Object]" && (e.scope && (s = e.scope), e.element && (c = e.element), e.keyup && (p = e.keyup), e.keydown !== void 0 && (g = e.keydown), e.capture !== void 0 && (v = e.capture), typeof e.splitKey == "string" && (y = e.splitKey)), typeof e == "string" && (s = e); f < r.length; f++)
    t = r[f].split(y), a = [], t.length > 1 && (a = e5(Rc, t)), t = t[t.length - 1], t = t === "*" ? "*" : B1(t), t in Ri || (Ri[t] = []), Ri[t].push({
      keyup: p,
      keydown: g,
      scope: s,
      mods: a,
      shortcut: r[f],
      method: n,
      key: r[f],
      splitKey: y,
      element: c
    });
  typeof c < "u" && !qce(c) && window && (r5.push(c), $k(c, "keydown", function(S) {
    DN(S, c);
  }, v), AN || (AN = !0, $k(window, "focus", function() {
    jr = [];
  }, v)), $k(c, "keyup", function(S) {
    DN(S, c), Gce(S);
  }, v));
}
function Qce(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(Ri).forEach(function(n) {
    var r = Ri[n].filter(function(a) {
      return a.scope === e && a.shortcut === t;
    });
    r.forEach(function(a) {
      a && a.method && a.method();
    });
  });
}
var Ak = {
  getPressedKeyString: Vce,
  setScope: i5,
  getScope: fb,
  deleteScope: Wce,
  getPressedKeyCodes: Hce,
  isPressed: Kce,
  filter: Yce,
  trigger: Qce,
  unbind: Xce,
  keyMap: db,
  modifier: Rc,
  modifierMap: DP
};
for (var Ok in Ak)
  Object.prototype.hasOwnProperty.call(Ak, Ok) && (ua[Ok] = Ak[Ok]);
if (typeof window < "u") {
  var Zce = window.hotkeys;
  ua.noConflict = function(t) {
    return t && window.hotkeys === ua && (window.hotkeys = Zce), ua;
  }, window.hotkeys = ua;
}
function Vu() {
  const t = Ge();
  return un("isReadOnlyMode", () => t.isReadOnly, [t]);
}
const Jce = dn(function({ onClose: e }) {
  const n = Ge(), r = Fn(), a = U1(), [s, c] = k.useState(null), [f, p] = k.useState(""), [g, y] = k.useState(null), [v, S] = k.useState(!1), x = k.useRef(-1);
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsxs(N1, { children: [
      /* @__PURE__ */ E.jsx(L1, { children: s ? `${r("embed-dialog.title")} — ${s.title}` : r("embed-dialog.title") }),
      /* @__PURE__ */ E.jsx(j1, {})
    ] }),
    s ? /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(cb, { className: "tlui-embed-dialog__enter", children: /* @__PURE__ */ E.jsxs("div", { className: "tlui-embed-dialog", children: [
        /* @__PURE__ */ E.jsx(
          y2,
          {
            className: "tlui-embed-dialog__input",
            label: "embed-dialog.url",
            placeholder: "http://example.com",
            autofocus: !0,
            onValueChange: (_) => {
              p(_);
              const T = Gd(_);
              y(
                T && T.definition.type === s.type ? T : null
              ), S(!1), clearTimeout(x.current), x.current = setTimeout(() => S(!T), 320);
            }
          }
        ),
        f === "" ? /* @__PURE__ */ E.jsxs("div", { className: "tlui-embed-dialog__instruction", children: [
          /* @__PURE__ */ E.jsx("span", { children: r("embed-dialog.instruction") }),
          " ",
          s.instructionLink && /* @__PURE__ */ E.jsxs(
            "a",
            {
              target: "_blank",
              rel: "noopener noreferrer",
              href: s.instructionLink,
              className: "tlui-embed-dialog__instruction__link",
              children: [
                "Learn more.",
                /* @__PURE__ */ E.jsx(Wa, { icon: "external-link", small: !0 })
              ]
            }
          )
        ] }) : /* @__PURE__ */ E.jsx("div", { className: "tlui-embed-dialog__warning", children: v ? r("embed-dialog.invalid-url") : " " })
      ] }) }),
      /* @__PURE__ */ E.jsxs(p2, { className: "tlui-dialog__footer__actions", children: [
        /* @__PURE__ */ E.jsx(
          At,
          {
            onClick: () => {
              c(null), y(null), p("");
            },
            label: "embed-dialog.back"
          }
        ),
        /* @__PURE__ */ E.jsx("div", { className: "tlui-spacer" }),
        /* @__PURE__ */ E.jsx(At, { label: "embed-dialog.cancel", onClick: e }),
        /* @__PURE__ */ E.jsx(
          At,
          {
            type: "primary",
            disabled: !g,
            label: "embed-dialog.create",
            onClick: () => {
              g && (GL(n, f, n.viewportPageCenter, {
                width: g.definition.width,
                height: g.definition.height,
                doesResize: g.definition.doesResize
              }), e());
            }
          }
        )
      ] })
    ] }) : /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(cb, { className: "tlui-embed-dialog__list", children: Jg.map((_) => /* @__PURE__ */ E.jsxs(
        "button",
        {
          className: "tlui-embed-dialog__item",
          onClick: () => c(_),
          children: [
            /* @__PURE__ */ E.jsx("div", { className: "tlui-embed-dialog__item__image", children: /* @__PURE__ */ E.jsx(
              "div",
              {
                className: "tlui-embed-dialog__item__image__img",
                style: {
                  backgroundImage: `url(${a.embedIcons[_.type]})`
                }
              }
            ) }),
            /* @__PURE__ */ E.jsx("div", { className: "tlui-embed-dialog__item__title", children: _.title })
          ]
        },
        _.type
      )) }),
      /* @__PURE__ */ E.jsx("div", { className: "tlui-dialog__scrim" })
    ] })
  ] });
}), o5 = k.createContext({});
function eue({ overrides: t, children: e }) {
  const n = Ge(), { addDialog: r } = Vp(), a = V4(), s = k.useMemo(() => {
    const c = tue([
      {
        id: "select",
        label: "tool.select",
        icon: "tool-pointer",
        kbd: "v",
        readonlyOk: !0,
        onSelect() {
          n.setSelectedTool("select");
        }
      },
      {
        id: "hand",
        label: "tool.hand",
        icon: "tool-hand",
        kbd: "h",
        readonlyOk: !0,
        onSelect() {
          n.setSelectedTool("hand");
        }
      },
      {
        id: "eraser",
        label: "tool.eraser",
        icon: "tool-eraser",
        kbd: "e",
        readonlyOk: !0,
        onSelect() {
          n.setSelectedTool("eraser");
        }
      },
      {
        id: "draw",
        label: "tool.draw",
        readonlyOk: !0,
        icon: "tool-pencil",
        kbd: "d,b,x",
        onSelect() {
          n.setSelectedTool("draw");
        }
      },
      ...[...wL].map((f) => ({
        id: f,
        label: `tool.${f}`,
        readonlyOk: !0,
        meta: {
          geo: f
        },
        kbd: f === "rectangle" ? "r" : f === "ellipse" ? "o" : void 0,
        icon: "geo-" + f,
        onSelect() {
          n.batch(() => {
            n.updateInstanceState(
              { propsForNextShape: { ...n.instanceState.propsForNextShape, geo: f } },
              !0
            ), n.setSelectedTool("geo");
          });
        }
      })),
      {
        id: "arrow",
        label: "tool.arrow",
        readonlyOk: !0,
        icon: "tool-arrow",
        kbd: "a",
        onSelect() {
          n.setSelectedTool("arrow");
        }
      },
      {
        id: "line",
        label: "tool.line",
        readonlyOk: !0,
        icon: "tool-line",
        kbd: "l",
        onSelect() {
          n.setSelectedTool("line");
        }
      },
      {
        id: "frame",
        label: "tool.frame",
        readonlyOk: !0,
        icon: "tool-frame",
        kbd: "f",
        onSelect() {
          n.setSelectedTool("frame");
        }
      },
      {
        id: "text",
        label: "tool.text",
        readonlyOk: !0,
        icon: "tool-text",
        kbd: "t",
        onSelect() {
          n.setSelectedTool("text");
        }
      },
      {
        id: "asset",
        label: "tool.asset",
        readonlyOk: !0,
        icon: "tool-media",
        kbd: "$u",
        onSelect() {
          a();
        }
      },
      {
        id: "note",
        label: "tool.note",
        readonlyOk: !0,
        icon: "tool-note",
        kbd: "n",
        onSelect() {
          n.setSelectedTool("note");
        }
      },
      {
        id: "embed",
        label: "tool.embed",
        readonlyOk: !0,
        icon: "tool-embed",
        onSelect() {
          r({ component: Jce });
        }
      }
    ]);
    return t ? t(n, c, { insertMedia: a }) : c;
  }, [n, t, a, r]);
  return /* @__PURE__ */ E.jsx(o5.Provider, { value: s, children: e });
}
function tue(t) {
  return Object.fromEntries(t.map((e) => [e.id, e]));
}
function T2() {
  const t = k.useContext(o5);
  if (!t)
    throw new Error("useTools must be used within a ToolProvider");
  return t;
}
const NN = [
  // we set these in useNativeClipboardEvents instead
  "copy",
  "cut",
  "paste",
  // There's also an upload asset action, so we don't want to set the kbd twice
  "asset"
];
function nue() {
  const t = Ge(), e = Vu(), n = ba(), r = T2();
  k.useEffect(() => {
    const a = () => t.isMenuOpen || t.editingId !== null || t.crashingError;
    for (const s of Object.values(n))
      s.kbd && (e && !s.readonlyOk || NN.includes(s.id) || ua(LN(s.kbd), (c) => {
        a() || (Gn(c), s.onSelect());
      }));
    for (const s of Object.values(r))
      s.kbd && (NN.includes(s.id) || ua(LN(s.kbd), (c) => {
        a() || (Gn(c), s.onSelect());
      }));
    return ua("g", () => {
      a() || t.setSelectedTool("geo");
    }), ua("backspace,del", () => {
      a() || n.delete.onSelect();
    }), ua("=", () => {
      a() || n["zoom-in"].onSelect();
    }), ua("-", () => {
      a() || n["zoom-out"].onSelect();
    }), () => {
      ua.unbind();
    };
  }, [n, r, e, t]);
}
function LN(t) {
  let e = "";
  const n = t.split("");
  return n.length === 1 ? e = n[0] : n[0] === "!" ? e = `shift+${n[1]}` : n[0] === "?" ? e = `alt+${n[1]}` : n[0] === "$" ? n[1] === "!" ? e = `cmd+shift+${n[2]},ctrl+shift+${n[2]}` : n[1] === "?" ? e = `cmd+⌥+${n[2]},ctrl+alt+${n[2]}` : e = `cmd+${n[1]},ctrl+${n[1]}` : e = t, e;
}
const a5 = It.createContext(
  {}
), rue = dn(function({
  overrides: e,
  children: n
}) {
  const r = Ge(), a = T2(), s = ba(), c = k.useMemo(() => {
    const f = Gt([
      wn(
        "shortcuts-dialog.tools",
        Ie(s["toggle-tool-lock"]),
        Ie(a.select),
        Ie(a.draw),
        Ie(a.eraser),
        Ie(a.hand),
        Ie(a.rectangle),
        Ie(a.ellipse),
        Ie(a.arrow),
        Ie(a.line),
        Ie(a.text),
        Ie(a.frame),
        Ie(a.note)
      ),
      wn(
        "shortcuts-dialog.file",
        Ie(s["insert-media"]),
        Ie(s.print)
      ),
      wn(
        "shortcuts-dialog.preferences",
        Ie(s["toggle-dark-mode"]),
        Ie(s["toggle-focus-mode"]),
        Ie(s["toggle-grid"])
      ),
      wn(
        "shortcuts-dialog.edit",
        Ie(s.undo),
        Ie(s.redo),
        Ie(s.cut),
        Ie(s.copy),
        Ie(s.paste),
        Ie(s["select-all"]),
        Ie(s.delete),
        Ie(s.duplicate),
        Ie(s["export-as-svg"]),
        Ie(s["export-as-png"])
      ),
      wn(
        "shortcuts-dialog.view",
        Ie(s["zoom-in"]),
        Ie(s["zoom-out"]),
        Ie(s["zoom-to-100"]),
        Ie(s["zoom-to-fit"]),
        Ie(s["zoom-to-selection"])
      ),
      wn(
        "shortcuts-dialog.transform",
        Ie(s["bring-to-front"]),
        Ie(s["bring-forward"]),
        Ie(s["send-backward"]),
        Ie(s["send-to-back"]),
        Ie(s.group),
        Ie(s.ungroup),
        Ie(s["flip-horizontal"]),
        Ie(s["flip-vertical"]),
        Ie(s["align-top"]),
        Ie(s["align-center-vertical"]),
        Ie(s["align-bottom"]),
        Ie(s["align-left"]),
        Ie(s["align-center-horizontal"]),
        Ie(s["align-right"])
      )
    ]);
    return e ? e(r, f, { tools: a, actions: s }) : f;
  }, [r, e, s, a]);
  return /* @__PURE__ */ E.jsx(a5.Provider, { value: c, children: n });
});
function iue() {
  const t = It.useContext(a5);
  if (!t)
    throw new Error("Shortcuts must be used inside of a ShortcutsProvider.");
  return t;
}
function oue(t, e) {
  const [n, r] = It.useState(e);
  It.useLayoutEffect(() => {
    const s = localStorage.getItem(t);
    if (s)
      try {
        r(JSON.parse(s));
      } catch {
        console.error(`Could not restore value ${t} from local storage.`);
      }
  }, [t]);
  const a = It.useCallback(
    (s) => {
      r((c) => {
        const f = typeof s == "function" ? s(c) : s;
        return localStorage.setItem(t, JSON.stringify(f)), f;
      });
    },
    [t]
  );
  return [n, a];
}
function gm(t, e) {
  const n = Ge(), r = k.useRef(!1), a = k.useCallback(
    (s) => {
      r.current = s, s ? (n.complete(), n.openMenus.add(t)) : (n.openMenus.delete(t), n.openMenus.forEach((c) => {
        c.startsWith(t) && n.openMenus.delete(c);
      })), e?.(s);
    },
    [n, t, e]
  );
  return k.useEffect(() => (r.current && n.openMenus.add(t), () => {
    r.current && (n.openMenus.delete(t), n.openMenus.forEach((s) => {
      s.startsWith(t) && n.openMenus.delete(s);
    }), r.current = !1);
  }), [n, t]), a;
}
const s5 = It.createContext({});
function aue({ overrides: t, children: e }) {
  const n = Ge(), r = ba(), s = qs() < 5, c = un("isDarkMode", () => n.userDocumentSettings.isDarkMode, [n]), f = un("isGridMode", () => n.userDocumentSettings.isGridMode, [n]), p = un("isSnapMode", () => n.userDocumentSettings.isSnapMode, [n]), g = un("isToolLock", () => n.instanceState.isToolLocked, [n]), y = un("isFocusMode", () => n.instanceState.isFocusMode, [n]), v = un("isDebugMode", () => n.instanceState.isDebugMode, [n]), S = un("exportBackground", () => n.instanceState.exportBackground, [
    n
  ]), x = un("emptyPage", () => n.shapeIds.size === 0, [n]), _ = un("selectedCount", () => n.selectedIds.length, [n]), T = _ === 0, I = _ > 0, D = _ > 1, N = _ > 2, j = !!window.navigator.clipboard?.write, L = _2(), z = q4(), F = d2(), K = f2(), X = X4(), se = G4(), ue = un("isZoomedTo100", () => n.camera.z === 1, [n]), pe = k.useMemo(() => {
    const Pe = Gt([
      wn(
        "menu",
        _c(
          "file",
          "menu.file",
          wn("print", Ie(r.print, { disabled: x }))
        ),
        _c(
          "edit",
          "menu.edit",
          wn(
            "undo-actions",
            Ie(r.undo, { disabled: !X }),
            Ie(r.redo, { disabled: !se })
          ),
          wn(
            "clipboard-actions",
            Ie(r.cut, { disabled: T }),
            Ie(r.copy, { disabled: T }),
            {
              id: "MENU_PASTE",
              type: "custom",
              disabled: !Yse,
              readonlyOk: !1
            }
          ),
          wn(
            "conversions",
            _c(
              "copy-as",
              "menu.copy-as",
              wn(
                "copy-as-group",
                Ie(r["copy-as-svg"], { disabled: x }),
                Ie(r["copy-as-png"], { disabled: x || !j }),
                Ie(r["copy-as-json"], { disabled: x })
              ),
              wn(
                "export-bg",
                Ie(r["toggle-transparent"], { checked: !S })
              )
            ),
            _c(
              "export-as",
              "menu.export-as",
              wn(
                "export-as-group",
                Ie(r["export-as-svg"], { disabled: x }),
                Ie(r["export-as-png"], { disabled: x }),
                Ie(r["export-as-json"], { disabled: x })
              ),
              wn(
                "export-bg",
                Ie(r["toggle-transparent"], { checked: !S })
              )
            )
          ),
          wn(
            "set-selection-group",
            Ie(r["select-all"], { disabled: x }),
            Ie(r["select-none"], { disabled: !I })
          ),
          wn(
            "selection",
            z && Ie(r["toggle-auto-size"]),
            L && Ie(r["edit-link"]),
            Ie(r.duplicate, { disabled: !I }),
            F && Ie(r.group),
            K && Ie(r.ungroup)
          ),
          wn("delete-group", Ie(r.delete, { disabled: !I }))
        ),
        _c(
          "view",
          "menu.view",
          wn(
            "view-actions",
            Ie(r["zoom-in"]),
            Ie(r["zoom-out"]),
            Ie(r["zoom-to-100"], { disabled: ue }),
            Ie(r["zoom-to-fit"], { disabled: x }),
            Ie(r["zoom-to-selection"], { disabled: x || !I })
          )
        ),
        Ie(r["insert-media"])
      ),
      wn(
        "preferences",
        _c(
          "preferences",
          "menu.preferences",
          wn(
            "preferences-actions",
            Ie(r["toggle-snap-mode"], { checked: p }),
            Ie(r["toggle-tool-lock"], { checked: g }),
            Ie(r["toggle-grid"], { checked: f }),
            Ie(r["toggle-dark-mode"], { checked: c }),
            Ie(r["toggle-focus-mode"], { checked: y }),
            Ie(r["toggle-debug-mode"], { checked: v })
          )
        ),
        s && Wx("LANGUAGE_MENU", { readonlyOk: !0 })
      )
    ]);
    return t ? t(n, Pe, {
      actions: r,
      noneSelected: T,
      oneSelected: I,
      twoSelected: D,
      threeSelected: N
    }) : Pe;
  }, [
    n,
    t,
    r,
    I,
    D,
    N,
    x,
    s,
    F,
    K,
    L,
    j,
    z,
    T,
    X,
    se,
    c,
    f,
    p,
    g,
    y,
    S,
    v,
    ue
  ]);
  return /* @__PURE__ */ E.jsx(s5.Provider, { value: pe, children: e });
}
function sue() {
  const t = It.useContext(s5);
  if (!t)
    throw new Error("useMenuSchema must be used inside of a MenuSchemaProvider.");
  return t;
}
function wr(t) {
  return {
    id: t.id,
    type: "item",
    readonlyOk: t.readonlyOk,
    toolItem: t
  };
}
const l5 = It.createContext([]);
function lue({ overrides: t, children: e }) {
  const n = Ge(), r = T2(), a = It.useMemo(() => {
    const s = [
      wr(r.select),
      wr(r.hand),
      wr(r.draw),
      wr(r.eraser),
      wr(r.arrow),
      wr(r.text),
      wr(r.note),
      wr(r.asset),
      wr(r.rectangle),
      wr(r.ellipse),
      wr(r.diamond),
      wr(r.triangle),
      wr(r.trapezoid),
      wr(r.rhombus),
      wr(r.pentagon),
      wr(r.hexagon),
      wr(r.octagon),
      wr(r.star),
      wr(r.oval),
      wr(r["x-box"]),
      wr(r["arrow-right"]),
      wr(r["arrow-left"]),
      wr(r["arrow-up"]),
      wr(r["arrow-down"]),
      wr(r.line),
      wr(r.frame),
      wr(r.embed)
    ];
    return t ? t(n, s, { tools: r }) : s;
  }, [n, t, r]);
  return /* @__PURE__ */ E.jsx(l5.Provider, { value: a, children: e });
}
function cue() {
  const t = It.useContext(l5);
  if (!t)
    throw new Error("useToolbarSchema must be used within a ToolbarSchemaProvider");
  return t;
}
const uue = dn(function() {
  const e = Ge(), n = va(), r = e.pages, a = e.currentPageId, s = Fn();
  return /* @__PURE__ */ E.jsxs(o4, { children: [
    /* @__PURE__ */ E.jsx(a4, { dir: "ltr", asChild: !0, children: /* @__PURE__ */ E.jsx(
      At,
      {
        className: "tlui-menu__button",
        label: "context-menu.move-to-page",
        "data-wd": "menu-item.move-to-page",
        icon: "chevron-right"
      }
    ) }),
    /* @__PURE__ */ E.jsx(IP, { container: n, dir: "ltr", children: /* @__PURE__ */ E.jsxs(s4, { className: "tlui-menu", sideOffset: -4, collisionPadding: 4, children: [
      /* @__PURE__ */ E.jsx(
        RP,
        {
          dir: "ltr",
          className: "tlui-menu__group",
          "data-wd": "menu-item.pages",
          children: r.map((c) => /* @__PURE__ */ E.jsx(
            Kx,
            {
              disabled: a === c.id,
              onSelect: () => {
                e.mark("move_shapes_to_page"), e.moveShapesToPage(e.selectedIds, c.id);
              },
              asChild: !0,
              children: /* @__PURE__ */ E.jsx(
                At,
                {
                  title: c.name,
                  className: "tlui-menu__button tlui-context-menu__move-to-page__name",
                  children: /* @__PURE__ */ E.jsx("span", { children: c.name })
                }
              )
            },
            c.id
          ))
        },
        "pages"
      ),
      /* @__PURE__ */ E.jsx(
        RP,
        {
          dir: "ltr",
          className: "tlui-menu__group",
          "data-wd": "menu-item.new-page",
          children: /* @__PURE__ */ E.jsx(
            Kx,
            {
              onSelect: () => {
                e.mark("move_shapes_to_page");
                const c = fr.createId(), f = e.selectedIds, p = e.currentPageId;
                e.batch(() => {
                  e.createPage("Page 1", c), e.setCurrentPageId(p), e.moveShapesToPage(f, c);
                });
              },
              asChild: !0,
              children: /* @__PURE__ */ E.jsx(
                At,
                {
                  title: s("context.pages.new-page"),
                  className: "tlui-menu__button tlui-context-menu__move-to-page__name",
                  children: s("context.pages.new-page")
                }
              )
            },
            "new-page"
          )
        },
        "new-page"
      )
    ] }) })
  ] });
}), due = function({ children: e }) {
  const n = Ge(), r = Z4(), a = gm("context menu"), s = Vu(), c = r.length === 0 || s && r.every((g) => !g.readonlyOk), p = !un("isSelectToolActive", () => n.currentToolId === "select", [
    n
  ]) || c;
  return /* @__PURE__ */ E.jsxs(Bse, { dir: "ltr", onOpenChange: a, children: [
    /* @__PURE__ */ E.jsx(
      Fse,
      {
        onContextMenu: p ? Gn : void 0,
        dir: "ltr",
        disabled: p,
        children: e
      }
    ),
    /* @__PURE__ */ E.jsx(fue, {})
  ] });
};
function fue() {
  const t = Ge(), e = Fn(), n = Z4(), r = gm("context menu sub"), a = Vu(), { paste: s } = x2(), c = qs(), f = va(), [p, g] = k.useState(!1);
  function y(v, S, x, _) {
    if (a && !S.readonlyOk)
      return null;
    switch (S.type) {
      case "custom": {
        switch (S.id) {
          case "MENU_PASTE":
            return /* @__PURE__ */ E.jsx(Kx, { children: /* @__PURE__ */ E.jsx(
              At,
              {
                className: "tlui-menu__button",
                "data-wd": `menu-item.${S.id}`,
                kbd: "$v",
                label: "action.paste",
                disabled: S.disabled,
                onClick: () => {
                  (!v.isSafari || v.isSafari && v.isIos) && navigator.clipboard.read().then((T) => {
                    s(T, v.inputs.currentPagePoint);
                  });
                },
                onMouseDown: () => {
                  v.isSafari && !v.isIos && navigator.clipboard.read().then((T) => {
                    s(T, v.inputs.currentPagePoint);
                  });
                }
              }
            ) }, S.id);
          case "MOVE_TO_PAGE_MENU":
            return /* @__PURE__ */ E.jsx(uue, {}, S.id);
        }
        break;
      }
      case "group":
        return /* @__PURE__ */ E.jsx(
          RP,
          {
            dir: "ltr",
            className: $n("tlui-menu__group", {
              "tlui-menu__group__small": x?.type === "submenu"
            }),
            "data-wd": `menu-item.${S.id}`,
            children: S.children.map((T) => y(v, T, S, _ + 1))
          },
          S.id
        );
      case "submenu":
        return /* @__PURE__ */ E.jsxs(o4, { onOpenChange: r, children: [
          /* @__PURE__ */ E.jsx(a4, { dir: "ltr", disabled: S.disabled, asChild: !0, children: /* @__PURE__ */ E.jsx(
            At,
            {
              className: "tlui-menu__button",
              label: S.label,
              "data-wd": `menu-item.${S.id}`,
              icon: "chevron-right"
            }
          ) }),
          /* @__PURE__ */ E.jsx(IP, { container: f, dir: "ltr", children: /* @__PURE__ */ E.jsx(s4, { className: "tlui-menu", sideOffset: -4, collisionPadding: 4, children: S.children.map((T) => y(v, T, S, _ + 1)) }) })
        ] }, S.id);
      case "item": {
        if (a && !S.readonlyOk)
          return null;
        const { id: T, checkbox: I, contextMenuLabel: D, label: N, onSelect: j, kbd: L, icon: z } = S.actionItem, F = D ?? N, K = F ? e(F) : void 0;
        return I ? /* @__PURE__ */ E.jsxs(
          Vse,
          {
            className: "tlui-button tlui-menu__button tlui-menu__checkbox-item",
            dir: "ltr",
            disabled: S.disabled,
            onSelect: (X) => {
              j(), Gn(X);
            },
            title: K || void 0,
            checked: S.checked,
            children: [
              /* @__PURE__ */ E.jsx(
                "div",
                {
                  className: "tlui-menu__checkbox-item__check",
                  style: {
                    transformOrigin: "75% center",
                    transform: `scale(${S.checked ? 1 : 0.5})`,
                    opacity: S.checked ? 1 : 0.5
                  },
                  children: /* @__PURE__ */ E.jsx(Wa, { small: !0, icon: S.checked ? "check" : "checkbox-empty" })
                }
              ),
              K && /* @__PURE__ */ E.jsx("span", { children: K }),
              L && /* @__PURE__ */ E.jsx(D1, { children: L })
            ]
          },
          T
        ) : /* @__PURE__ */ E.jsx(Kx, { dir: "ltr", asChild: !0, children: /* @__PURE__ */ E.jsx(
          At,
          {
            className: "tlui-menu__button",
            "data-wd": `menu-item.${T}`,
            kbd: L,
            label: F,
            disabled: S.disabled,
            iconLeft: c < 3 && _ > 2 ? z : void 0,
            onClick: () => {
              p ? g(!1) : j();
            }
          }
        ) }, T);
      }
    }
  }
  return /* @__PURE__ */ E.jsx(IP, { dir: "ltr", container: f, children: /* @__PURE__ */ E.jsx(
    Hse,
    {
      className: "tlui-menu scrollable",
      alignOffset: -4,
      collisionPadding: 4,
      onContextMenu: Gn,
      children: n.map((v) => y(t, v, null, 0))
    }
  ) });
}
let jN = 0;
function pue(t, e) {
  const n = Array(e), r = Math.floor(Math.sqrt(e));
  for (let a = 0; a < e; a++)
    jN++, n[a] = {
      id: t.createShapeId("box" + jN),
      type: "geo",
      x: a % r * 132,
      y: Math.floor(a / r) * 132
    };
  t.batch(() => {
    t.createShapes(n).setSelectedIds(n.map((a) => a.id));
  });
}
const hue = k.memo(function({
  renderDebugMenuItems: e
}) {
  return /* @__PURE__ */ E.jsxs("div", { className: "tlui-debug-panel", children: [
    /* @__PURE__ */ E.jsx(gue, {}),
    /* @__PURE__ */ E.jsx(mue, {}),
    /* @__PURE__ */ E.jsxs(of, { id: "debug", children: [
      /* @__PURE__ */ E.jsx($b, { children: /* @__PURE__ */ E.jsx(At, { icon: "dots-horizontal" }) }),
      /* @__PURE__ */ E.jsx(af, { side: "top", align: "end", alignOffset: 0, children: /* @__PURE__ */ E.jsx(vue, { renderDebugMenuItems: e }) })
    ] })
  ] });
}), gue = dn(function() {
  const e = Ge();
  return /* @__PURE__ */ E.jsx("div", { className: "tlui-debug-panel__current-state", children: e.root.path.value });
}), mue = dn(function() {
  const e = Ge();
  return /* @__PURE__ */ E.jsxs("div", { children: [
    e.renderingShapes.length,
    " Shapes"
  ] });
});
function vue({
  renderDebugMenuItems: t
}) {
  const e = Ge(), { addToast: n } = Hu(), { addDialog: r } = Vp(), [a, s] = k.useState(!1);
  return /* @__PURE__ */ E.jsxs(Lp, { children: [
    (() => {
      if (a)
        throw Error("oh no!");
    })(),
    /* @__PURE__ */ E.jsx(
      Ko,
      {
        onClick: () => {
          s(!0);
        },
        children: /* @__PURE__ */ E.jsx("span", { children: "Throw Error" })
      }
    ),
    /* @__PURE__ */ E.jsx(
      Ko,
      {
        onClick: () => {
          n({
            id: $i(),
            title: "Something happened",
            description: "Hey, attend to this thing over here. It might be important!"
            // icon?: string
            // title?: string
            // description?: string
            // actions?: TLToastAction[]
          });
        },
        children: /* @__PURE__ */ E.jsx("span", { children: "Show Toast" })
      }
    ),
    /* @__PURE__ */ E.jsx(
      Ko,
      {
        onClick: () => {
          r({
            component: ({ onClose: c }) => /* @__PURE__ */ E.jsx(
              yue,
              {
                onCancel: () => {
                  c();
                },
                onContinue: () => {
                  c();
                }
              }
            ),
            onClose: () => {
            }
          });
        },
        children: "Show Dialog"
      }
    ),
    /* @__PURE__ */ E.jsx(
      Ko,
      {
        onClick: () => {
          e.updateUserDocumentSettings({ isReadOnly: !e.isReadOnly });
        },
        children: /* @__PURE__ */ E.jsx("span", { children: "Toggle Read Only" })
      }
    ),
    /* @__PURE__ */ E.jsx(
      Ko,
      {
        onClick: () => {
          hs.peopleMenu.set(!hs.peopleMenu.value);
        },
        children: /* @__PURE__ */ E.jsx("span", { children: "Toggle People Menu" })
      }
    ),
    /* @__PURE__ */ E.jsx(
      Ko,
      {
        label: "debug-menu.hard-reset",
        onClick: () => {
          window.__tldraw__hardReset();
        }
      }
    ),
    /* @__PURE__ */ E.jsx(Ko, { label: "debug-menu.create-shapes", onClick: () => pue(e, 100) }),
    /* @__PURE__ */ E.jsx(
      Ko,
      {
        onClick: () => {
          function c({ children: v }) {
            let S = 0;
            if (!v.length)
              return 0;
            for (const x of [...v])
              S++, S += c(x);
            return S;
          }
          const { selectedShapes: f } = e, p = f.length === 0 ? e.renderingShapes : f, g = p.map(
            (v) => document.getElementById(v.id).parentElement
          );
          let y = g.length;
          for (const v of g)
            y += c(v);
          window.alert(`Shapes ${p.length}, DOM nodes:${y}`);
        },
        children: /* @__PURE__ */ E.jsx("span", { children: "Count Shapes and Nodes" })
      }
    ),
    t?.()
  ] });
}
function yue({ onCancel: t, onContinue: e }) {
  const [n, r] = k.useState(!1);
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsxs(N1, { children: [
      /* @__PURE__ */ E.jsx(L1, { children: "Hello" }),
      /* @__PURE__ */ E.jsx(j1, {})
    ] }),
    /* @__PURE__ */ E.jsx(cb, { style: { maxWidth: 350 }, children: "Hello Hello Hello" }),
    /* @__PURE__ */ E.jsxs(p2, { className: "tlui-dialog__footer__actions", children: [
      /* @__PURE__ */ E.jsx(
        At,
        {
          onClick: () => r(!n),
          iconLeft: n ? "checkbox-checked" : "checkbox-empty",
          style: { marginRight: "auto" },
          children: "Don't show again"
        }
      ),
      /* @__PURE__ */ E.jsx(At, { onClick: t, children: "Cancel" }),
      /* @__PURE__ */ E.jsx(
        At,
        {
          type: "primary",
          onClick: async () => {
            e();
          },
          children: "Continue"
        }
      )
    ] })
  ] });
}
dn(function() {
  const e = Ge(), n = k.useRef(null), r = e.camera, a = e.shapesArray;
  if (n.current) {
    const s = n.current, c = s.getContext("2d");
    c.resetTransform(), c.clearRect(0, 0, s.width, s.height);
    const f = new Path2D();
    c.translate(r.x, r.y);
    for (const p of a) {
      const g = e.getPageBounds(p);
      f.rect(g.minX, g.minY, g.width, g.height);
    }
    c.fillStyle = "#cccccc", c.fill(f);
    for (const p of a)
      c.save(), e.getPageCorners(p).forEach((y) => bue(c, y.x, y.y, "red")), c.restore();
  }
  return /* @__PURE__ */ E.jsx(
    "canvas",
    {
      ref: n,
      width: e.viewportScreenBounds.width,
      height: e.viewportScreenBounds.height,
      style: { width: "100%", height: "100%" }
    }
  );
});
function bue(t, e, n, r = "#000") {
  t.save(), t.beginPath(), t.ellipse(e, n, 4, 4, 0, 0, Math.PI * 2), t.fillStyle = r, t.fill(), t.restore();
}
function c5() {
  const t = Ge(), { languages: e, currentLanguage: n } = U4(), r = k.useCallback(
    (a) => {
      t.updateUser({ locale: a });
    },
    [t]
  );
  return /* @__PURE__ */ E.jsxs(g2, { id: "help menu language", children: [
    /* @__PURE__ */ E.jsx(m2, { label: "menu.language", "data-direction": "left" }),
    /* @__PURE__ */ E.jsx(v2, { sideOffset: -4, children: /* @__PURE__ */ E.jsx(Lp, { children: e.map(({ locale: a, label: s }) => /* @__PURE__ */ E.jsx(
      Mle,
      {
        title: a,
        checked: a === n,
        onSelect: () => r(a),
        children: /* @__PURE__ */ E.jsx("span", { children: s })
      },
      a
    )) }) })
  ] });
}
const Sue = k.memo(function() {
  const e = va(), n = Fn(), r = gm("help menu");
  return /* @__PURE__ */ E.jsx("div", { className: "tlui-help-menu", children: /* @__PURE__ */ E.jsxs(w4, { dir: "ltr", onOpenChange: r, modal: !1, children: [
    /* @__PURE__ */ E.jsx(
      ub,
      {
        className: "tlui-button tlui-help-menu__button",
        dir: "ltr",
        title: n("help-menu.title"),
        children: /* @__PURE__ */ E.jsx(Wa, { icon: "question-mark" })
      }
    ),
    /* @__PURE__ */ E.jsx(h2, { container: e, dir: "ltr", children: /* @__PURE__ */ E.jsx(
      x4,
      {
        className: "tlui-menu",
        side: "top",
        sideOffset: 8,
        align: "end",
        alignOffset: 0,
        collisionPadding: 4,
        children: /* @__PURE__ */ E.jsx(wue, {})
      }
    ) })
  ] }) });
});
function wue() {
  const t = zce(), e = Vu();
  function n(r) {
    if (e && !r.readonlyOk)
      return null;
    switch (r.type) {
      case "custom": {
        if (r.id === "LANGUAGE_MENU")
          return /* @__PURE__ */ E.jsx(c5, {}, "item");
        break;
      }
      case "group":
        return /* @__PURE__ */ E.jsx(Lp, { size: "small", children: r.children.map(n) }, r.id);
      case "submenu":
        return /* @__PURE__ */ E.jsxs(g2, { id: `help menu ${r.id}`, children: [
          /* @__PURE__ */ E.jsx(m2, { label: r.label }),
          /* @__PURE__ */ E.jsx(v2, { children: r.children.map(n) })
        ] }, r.id);
      case "item": {
        const { id: a, kbd: s, label: c, onSelect: f, icon: p } = r.actionItem;
        return /* @__PURE__ */ E.jsx(Ko, { kbd: s, label: c, onClick: f, iconLeft: p }, a);
      }
    }
  }
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: t.map(n) });
}
class Ky {
  constructor(e, n) {
    this.app = e, this.dpr = n;
  }
  colors = {
    shapeFill: "rgba(144, 144, 144, .1)",
    selectFill: "#2f80ed",
    viewportFill: "rgba(144, 144, 144, .1)"
  };
  id = $i();
  cvs = null;
  pageBounds = [];
  collaborators = [];
  canvasScreenBounds = new ot();
  canvasPageBounds = new ot();
  contentPageBounds = new ot();
  contentScreenBounds = new ot();
  originPagePoint = new O();
  originPageCenter = new O();
  isInViewport = !1;
  debug = !1;
  setDpr(e) {
    this.dpr = +e.toFixed(2);
  }
  updateContentScreenBounds = () => {
    const { contentScreenBounds: e, contentPageBounds: n, canvasScreenBounds: r } = this;
    let { x: a, y: s, w: c, h: f } = e;
    if (n.w > n.h) {
      const p = r.w / (n.w / n.h);
      p > r.h ? (a = (r.w - r.w * (r.h / p)) / 2, s = 0, c = r.w * (r.h / p), f = r.h) : (a = 0, s = (r.h - p) / 2, c = r.w, f = p);
    } else if (n.w < n.h) {
      const p = r.h / (n.h / n.w);
      a = (r.w - p) / 2, s = 0, c = p, f = r.h;
    } else
      a = r.h / 2, s = 0, c = r.h, f = r.h;
    e.set(a, s, c, f);
  };
  /**
   * Get the canvas's true bounds converted to page bounds.
   */
  updateCanvasPageBounds = () => {
    const { canvasPageBounds: e, canvasScreenBounds: n, contentPageBounds: r, contentScreenBounds: a } = this;
    e.set(
      0,
      0,
      r.width / (a.width / n.width),
      r.height / (a.height / n.height)
    ), e.center = r.center;
  };
  getScreenPoint = (e, n) => {
    const { canvasScreenBounds: r } = this, a = (e - r.minX) * this.dpr, s = (n - r.minY) * this.dpr;
    return { x: a, y: s };
  };
  getPagePoint = (e, n) => {
    const { contentPageBounds: r, contentScreenBounds: a, canvasPageBounds: s } = this, { x: c, y: f } = this.getScreenPoint(e, n);
    return {
      x: s.minX + c * r.width / a.width,
      y: s.minY + f * r.height / a.height,
      z: 1
    };
  };
  minimapScreenPointToPagePoint = (e, n, r = !1, a = !1) => {
    const { app: s } = this, { viewportPageBounds: c } = s;
    let { x: f, y: p } = this.getPagePoint(e, n);
    if (a) {
      const g = this.app.allShapesCommonBounds, y = c, v = (g?.minX ?? 0) - y.width / 2, S = (g?.maxX ?? 0) + y.width / 2, x = (g?.minY ?? 0) - y.height / 2, _ = (g?.maxY ?? 0) + y.height / 2, T = Math.max(0, v + y.width - f), I = Math.max(0, -(S - y.width - f)), D = Math.max(0, x + y.height - p), N = Math.max(0, -(_ - y.height - p)), j = Math.max(0, T - I), L = Math.max(0, I - T), z = Math.max(0, D - N), F = Math.max(0, N - D);
      j && j > L ? f += j / 2 : L && (f -= L / 2), z && z > F ? p += z / 2 : F && (p -= F / 2), f = $u(f, v, S), p = $u(p, x, _);
    }
    if (r) {
      const { originPagePoint: g } = this, y = Math.abs(f - g.x), v = Math.abs(p - g.y);
      y > v ? p = g.y : f = g.x;
    }
    return { x: f, y: p };
  };
  render = () => {
    const { cvs: e, pageBounds: n } = this;
    this.updateCanvasPageBounds();
    const { app: r, canvasScreenBounds: a, canvasPageBounds: s, contentPageBounds: c, contentScreenBounds: f } = this, { width: p, height: g } = a, { viewportPageBounds: y, selectedIds: v } = r;
    if (!e || !n)
      return;
    const S = e.getContext("2d");
    if (!S)
      throw new Error("Minimap (shapes): Could not get context");
    S.resetTransform(), S.globalAlpha = 1, S.clearRect(0, 0, p, g);
    const x = f.width / c.width, _ = f.height / c.height;
    S.translate((p - f.width) / 2, (g - f.height) / 2), S.scale(x, _), S.translate(-c.minX, -c.minY);
    const T = 8 / x, I = 8 / x, D = 1 / x, N = 1 / x, j = T / 4, L = I / 4, z = new Path2D(), F = new Path2D(), { shapeFill: K, selectFill: X, viewportFill: se } = this.colors;
    let ue;
    for (let le = 0, Re = n.length; le < Re; le++)
      ue = n[le], Ky.roundedRect(
        v.includes(ue.id) ? F : z,
        ue.minX,
        ue.minY,
        ue.width,
        ue.height,
        $u(T, D, ue.width / j),
        $u(I, N, ue.height / L)
      );
    if (S.fillStyle = K, S.fill(z), S.fillStyle = X, S.fill(F), this.debug) {
      const le = ot.Common(n), { minX: Re, minY: he, width: te, height: de } = le;
      S.strokeStyle = "green", S.lineWidth = 2 / x, S.strokeRect(Re + 1 / x, he + 1 / _, te - 2 / x, de - 2 / _);
    }
    {
      const { brush: le } = r;
      if (le) {
        const { x: Re, y: he, w: te, h: de } = le;
        S.beginPath(), Ky.sharpRect(S, Re, he, te, de), S.closePath(), S.fillStyle = se, S.fill();
      }
    }
    {
      const { minX: le, minY: Re, width: he, height: te } = y;
      S.beginPath();
      const de = 12 / x, W = 12 / x;
      Ky.roundedRect(
        S,
        le,
        Re,
        he,
        te,
        Math.min(he / 4, de),
        Math.min(te / 4, W)
      ), S.closePath(), S.fillStyle = se, S.fill(), this.debug && (S.strokeStyle = "orange", S.strokeRect(le + 1 / x, Re + 1 / _, he - 2 / x, te - 2 / _));
    }
    const pe = 2.5 / x, Pe = 2.5 / _, { currentPageId: ve } = r;
    let Y;
    for (let le = 0; le < this.collaborators.length; le++)
      Y = this.collaborators[le], (Y.lastUsedInstanceId ? r.store.get(Y.lastUsedInstanceId) : null)?.currentPageId === ve && (S.beginPath(), S.ellipse(
        $u(Y.cursor.x, s.minX + pe, s.maxX - pe),
        $u(Y.cursor.y, s.minY + Pe, s.maxY - Pe),
        5 / x,
        5 / _,
        0,
        0,
        Wr
      ), S.fillStyle = Y.color, S.fill());
    if (this.debug) {
      S.lineWidth = 2 / x;
      {
        const { minX: le, minY: Re, width: he, height: te } = c;
        S.strokeStyle = "red", S.strokeRect(le + 1 / x, Re + 1 / _, he - 2 / x, te - 2 / _);
      }
      {
        const { minX: le, minY: Re, width: he, height: te } = s;
        S.strokeStyle = "blue", S.strokeRect(le + 1 / x, Re + 1 / _, he - 2 / x, te - 2 / _);
      }
    }
  };
  static roundedRect(e, n, r, a, s, c, f) {
    if (c < 1 && f < 1) {
      e.rect(n, r, a, s);
      return;
    }
    e.moveTo(n + c, r), e.lineTo(n + a - c, r), e.quadraticCurveTo(n + a, r, n + a, r + f), e.lineTo(n + a, r + s - f), e.quadraticCurveTo(n + a, r + s, n + a - c, r + s), e.lineTo(n + c, r + s), e.quadraticCurveTo(n, r + s, n, r + s - f), e.lineTo(n, r + f), e.quadraticCurveTo(n, r, n + c, r);
  }
  static sharpRect(e, n, r, a, s, c, f) {
    e.rect(n, r, a, s);
  }
}
const xue = 1e4, Eue = () => {
  const t = Ge(), e = LL("time", Date.now());
  return k.useEffect(() => {
    const n = setInterval(() => e.set(Date.now()), 5e3);
    return () => clearInterval(n);
  }, [e]), k.useMemo(
    () => t.store.query.records("user_presence", () => ({
      lastActivityTimestamp: { gt: e.value - xue },
      userId: { neq: t.userId }
    })),
    [t, e]
  );
}, Cue = dn(function({
  shapeFill: e,
  selectFill: n,
  viewportFill: r
}) {
  const a = Ge(), s = k.useRef(null), c = va(), f = k.useRef(!1), p = k.useMemo(() => new Ky(a, a.devicePixelRatio), [a]), g = a.userDocumentSettings.isDarkMode;
  k.useEffect(() => {
    const I = requestAnimationFrame(() => {
      const D = getComputedStyle(c);
      p.colors = {
        shapeFill: D.getPropertyValue(e).trim(),
        selectFill: D.getPropertyValue(n).trim(),
        viewportFill: D.getPropertyValue(r).trim()
      }, p.render();
    });
    return () => {
      cancelAnimationFrame(I);
    };
  }, [c, n, e, r, p, g]);
  const y = k.useCallback(
    (I) => {
      if (!a.shapeIds.size)
        return;
      const { x: D, y: N } = p.minimapScreenPointToPagePoint(I.clientX, I.clientY, !1, !1), j = p.minimapScreenPointToPagePoint(I.clientX, I.clientY, !1, !0);
      p.originPagePoint.setTo(j), p.originPageCenter.setTo(a.viewportPageBounds.center), a.centerOnPoint(D, N, { duration: Au });
    },
    [a, p]
  ), v = k.useCallback(
    (I) => {
      if (I.currentTarget.setPointerCapture(I.pointerId), !a.shapeIds.size)
        return;
      f.current = !0, p.isInViewport = !1;
      const { x: D, y: N } = p.minimapScreenPointToPagePoint(I.clientX, I.clientY, !1, !1), j = p.minimapScreenPointToPagePoint(I.clientX, I.clientY, !1, !0), L = a.viewportPageBounds;
      p.originPagePoint.setTo(j), p.originPageCenter.setTo(L.center), p.isInViewport = L.containsPoint(j), p.isInViewport || a.centerOnPoint(D, N, { duration: Au });
    },
    [a, p]
  ), S = k.useCallback(
    (I) => {
      if (f.current) {
        const { x: L, y: z } = p.minimapScreenPointToPagePoint(
          I.clientX,
          I.clientY,
          I.shiftKey,
          !0
        );
        if (p.isInViewport) {
          const F = O.Sub({ x: L, y: z }, p.originPagePoint), K = O.Add(p.originPageCenter, F);
          a.centerOnPoint(K.x, K.y);
          return;
        }
        a.centerOnPoint(L, z);
      }
      const D = p.getPagePoint(I.clientX, I.clientY), N = a.pageToScreen(D.x, D.y), j = {
        type: "pointer",
        target: "canvas",
        name: "pointer_move",
        ..._ue(I),
        point: N,
        isPen: a.isPenMode
      };
      a.dispatch(j);
    },
    [a, p]
  ), x = k.useCallback((I) => {
    f.current = !1;
  }, []), _ = k.useCallback(
    (I) => {
      const D = dj(I);
      a.dispatch({
        type: "wheel",
        name: "wheel",
        delta: D,
        shiftKey: I.shiftKey,
        altKey: I.altKey,
        ctrlKey: I.metaKey || I.ctrlKey
      });
    },
    [a]
  );
  Ip(
    "update dpr",
    () => {
      const { devicePixelRatio: I } = a;
      p.setDpr(I);
      const D = s.current, N = D.getBoundingClientRect(), j = N.width * I, L = N.height * I;
      D.width = j, D.height = L, p.canvasScreenBounds.set(N.x, N.y, j, L), p.cvs = s.current;
    },
    [a, p]
  );
  const T = Eue();
  return Ip(
    "minimap render when pagebounds or collaborators changes",
    () => {
      const { devicePixelRatio: I, viewportPageBounds: D, allShapesCommonBounds: N } = a;
      p.contentPageBounds = N ? ot.Expand(N, D) : D, p.updateContentScreenBounds();
      const j = [];
      a.shapeIds.forEach((L) => {
        let z = a.getPageBoundsById(L);
        const F = a.getPageMaskById(L);
        if (F) {
          const K = lP(F, z.corners);
          if (!K)
            return;
          z = ot.FromPoints(K);
        }
        z && (z.id = L, j.push(z));
      }), p.pageBounds = j, p.collaborators = T.value, p.render();
    },
    [a, p]
  ), /* @__PURE__ */ E.jsx("div", { className: "tlui-minimap", children: /* @__PURE__ */ E.jsx(
    "canvas",
    {
      ref: s,
      className: "tlui-minimap__canvas",
      onDoubleClick: y,
      onPointerMove: S,
      onPointerDown: v,
      onPointerUp: x,
      onWheel: _
    }
  ) });
});
function _ue(t) {
  return t.isKilled = !0, {
    point: {
      x: t.clientX,
      y: t.clientY,
      z: t.pressure
    },
    shiftKey: t.shiftKey,
    altKey: t.altKey,
    ctrlKey: t.metaKey || t.ctrlKey,
    pointerId: t.pointerId,
    button: t.button,
    isPen: t.pointerType === "pen"
  };
}
const Dk = dn(function() {
  const e = Ge(), n = Fn(), r = qs(), a = e.zoomLevel, s = e.shapeIds.size > 0, c = e.selectedIds.length > 0, f = e.camera.z === 1, p = k.useCallback(() => {
    e.resetZoom(e.viewportScreenCenter, { duration: Au });
  }, [e]);
  return /* @__PURE__ */ E.jsxs(of, { id: "zoom", children: [
    /* @__PURE__ */ E.jsx($b, { children: /* @__PURE__ */ E.jsx(
      At,
      {
        title: `${n("navigation-zone.zoom")}`,
        "data-wd": "minimap.zoom-menu",
        className: r < 5 ? "tlui-zoom-menu__button" : "tlui-zoom-menu__button__pct",
        onDoubleClick: p,
        icon: r < 4 ? "zoom-in" : void 0,
        children: r < 4 ? null : /* @__PURE__ */ E.jsxs("span", { style: { flexGrow: 0, textAlign: "center" }, children: [
          Math.floor(a * 100),
          "%"
        ] })
      }
    ) }),
    /* @__PURE__ */ E.jsx(af, { side: "top", align: "start", alignOffset: 0, children: /* @__PURE__ */ E.jsxs(Lp, { children: [
      /* @__PURE__ */ E.jsx(Dy, { action: "zoom-in", "data-wd": "minimap.zoom-menu.zoom-in", noClose: !0 }),
      /* @__PURE__ */ E.jsx(Dy, { action: "zoom-out", "data-wd": "minimap.zoom-menu.zoom-out", noClose: !0 }),
      /* @__PURE__ */ E.jsx(
        Dy,
        {
          action: "zoom-to-100",
          "data-wd": "minimap.zoom-menu.zoom-to-100",
          noClose: !0,
          disabled: f
        }
      ),
      /* @__PURE__ */ E.jsx(
        Dy,
        {
          action: "zoom-to-fit",
          disabled: !s,
          "data-wd": "minimap.zoom-menu.zoom-to-fit",
          noClose: !0
        }
      ),
      /* @__PURE__ */ E.jsx(
        Dy,
        {
          action: "zoom-to-selection",
          disabled: !c,
          "data-wd": "minimap.zoom-menu.zoom-to-selection",
          noClose: !0
        }
      )
    ] }) })
  ] });
});
function Dy(t) {
  const { action: e, disabled: n = !1, noClose: r = !1 } = t, a = ba();
  return /* @__PURE__ */ E.jsx(
    Ko,
    {
      label: a[e].label,
      kbd: a[e].kbd,
      "data-wd": t["data-wd"],
      onClick: a[e].onSelect,
      noClose: r,
      disabled: n
    }
  );
}
const Tue = k.memo(function() {
  const e = ba(), n = Fn(), r = qs(), [a, s] = oue("minimap", !0), c = k.useCallback(() => {
    s((f) => !f);
  }, [s]);
  return r < 4 ? null : /* @__PURE__ */ E.jsxs("div", { className: "tlui-navigation-zone", children: [
    /* @__PURE__ */ E.jsx("div", { className: "tlui-navigation-zone__controls", children: r < 6 ? /* @__PURE__ */ E.jsx(Dk, {}) : a ? /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(Dk, {}),
      /* @__PURE__ */ E.jsx(
        At,
        {
          title: n("navigation-zone.toggle-minimap"),
          className: "tlui-navigation-zone__toggle",
          "data-wd": "minimap.toggle",
          onClick: c,
          icon: a ? "chevrons-ne" : "chevrons-sw"
        }
      )
    ] }) : /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(
        At,
        {
          icon: "minus",
          "data-wd": "minimap.zoom-out",
          title: `${n(e["zoom-out"].label)} ${Ic(e["zoom-out"].kbd)}`,
          onClick: e["zoom-out"].onSelect
        }
      ),
      /* @__PURE__ */ E.jsx(Dk, {}),
      /* @__PURE__ */ E.jsx(
        At,
        {
          icon: "plus",
          "data-wd": "minimap.zoom-in",
          title: `${n(e["zoom-in"].label)} ${Ic(e["zoom-in"].kbd)}`,
          onClick: e["zoom-in"].onSelect
        }
      ),
      /* @__PURE__ */ E.jsx(
        At,
        {
          title: n("navigation-zone.toggle-minimap"),
          className: "tlui-navigation-zone__toggle",
          onClick: c,
          icon: a ? "chevrons-ne" : "chevrons-sw"
        }
      )
    ] }) }),
    r >= 6 && !a && /* @__PURE__ */ E.jsx(
      Cue,
      {
        viewportFill: "--color-muted-1",
        selectFill: "--color-selected",
        shapeFill: "--color-text-3"
      }
    )
  ] });
}), kue = k.memo(function({
  "data-wd": e,
  label: n,
  labelA: r,
  labelB: a,
  itemsA: s,
  itemsB: c,
  styleTypeA: f,
  styleTypeB: p,
  valueA: g,
  valueB: y,
  onValueChange: v
}) {
  const S = Fn(), x = k.useMemo(
    () => s.find((D) => D.id === g)?.icon ?? "mixed",
    [s, g]
  ), _ = k.useMemo(
    () => c.find((D) => D.id === y)?.icon ?? "mixed",
    [c, y]
  );
  if (g === void 0 && y === void 0)
    return null;
  const T = `${e}.start`, I = `${e}.end`;
  return /* @__PURE__ */ E.jsxs("div", { className: "tlui-style-panel__double-select-picker", children: [
    /* @__PURE__ */ E.jsx("div", { title: S(n), className: "tlui-style-panel__double-select-picker-label", children: S(n) }),
    /* @__PURE__ */ E.jsxs(of, { id: `style panel ${f}`, children: [
      /* @__PURE__ */ E.jsx(ub, { asChild: !0, children: /* @__PURE__ */ E.jsx(
        At,
        {
          "data-wd": T,
          title: S(r) + " — " + S(g === null ? "style-panel.mixed" : `${f}-style.${g}`),
          icon: x,
          invertIcon: !0,
          smallIcon: !0
        }
      ) }),
      /* @__PURE__ */ E.jsx(af, { side: "bottom", align: "end", sideOffset: 0, alignOffset: -2, children: /* @__PURE__ */ E.jsx(
        "div",
        {
          className: $n("tlui-button-grid", {
            "tlui-button-grid__two": s.length < 4,
            "tlui-button-grid__four": s.length >= 4
          }),
          children: s.map((D) => /* @__PURE__ */ E.jsx(
            Ko,
            {
              className: "tlui-button-grid__button",
              title: S(r) + " — " + S(`${f}-style.${D.id}`),
              "data-wd": `${T}.${D.id}`,
              icon: D.icon,
              onClick: () => v(D, !1),
              invertIcon: !0
            },
            D.id
          ))
        }
      ) })
    ] }),
    /* @__PURE__ */ E.jsxs(of, { id: `style panel ${p}`, children: [
      /* @__PURE__ */ E.jsx(ub, { asChild: !0, children: /* @__PURE__ */ E.jsx(
        At,
        {
          "data-wd": I,
          title: S(a) + " — " + S(y === null ? "style-panel.mixed" : `${p}-style.${y}`),
          icon: _,
          smallIcon: !0
        }
      ) }),
      /* @__PURE__ */ E.jsx(af, { side: "bottom", align: "end", sideOffset: 0, alignOffset: -2, children: /* @__PURE__ */ E.jsx(
        "div",
        {
          className: $n("tlui-button-grid", {
            "tlui-button-grid__two": s.length < 4,
            "tlui-button-grid__four": s.length >= 4
          }),
          children: c.map((D) => /* @__PURE__ */ E.jsx(
            Ko,
            {
              className: "tlui-button-grid__button",
              title: S(a) + " — " + S(`${p}-style.${D.id}`),
              "data-wd": `${I}.${D.id}`,
              icon: D.icon,
              onClick: () => v(D, !1)
            },
            D.id
          ))
        }
      ) })
    ] })
  ] });
}), u5 = k.memo(function({
  id: e,
  items: n,
  styleType: r,
  label: a,
  value: s,
  onValueChange: c,
  "data-wd": f
}) {
  const p = Fn(), g = k.useMemo(() => n.find((y) => y.id === s)?.icon, [n, s]);
  return /* @__PURE__ */ E.jsxs(of, { id: `style panel ${e}`, children: [
    /* @__PURE__ */ E.jsx(ub, { asChild: !0, children: /* @__PURE__ */ E.jsx(
      At,
      {
        "data-wd": f,
        title: p(s === null ? "style-panel.mixed" : `${r}-style.${s}`),
        label: a,
        icon: g ?? "mixed"
      }
    ) }),
    /* @__PURE__ */ E.jsx(af, { side: "left", align: "center", alignOffset: 0, children: /* @__PURE__ */ E.jsx(
      "div",
      {
        className: $n("tlui-button-grid", {
          "tlui-button-grid__two": n.length < 4,
          "tlui-button-grid__four": n.length >= 4
        }),
        children: n.map((y) => /* @__PURE__ */ E.jsx(
          Ko,
          {
            className: "tlui-button-grid__button",
            "data-wd": `${f}.${y.id}`,
            title: p(`${r}-style.${y.id}`),
            icon: y.icon,
            onClick: () => c(y, !1)
          },
          y.id
        ))
      }
    ) })
  ] });
}), d5 = dn(function({ isMobile: e }) {
  const n = Ge(), r = n.props, a = k.useCallback(() => {
    e || (n.isChangingStyle = !1);
  }, [n, e]);
  if (!r)
    return null;
  const { geo: s, arrowheadEnd: c, arrowheadStart: f, spline: p, font: g } = r, y = s === void 0, v = c === void 0 && f === void 0, S = p === void 0, x = g === void 0;
  return /* @__PURE__ */ E.jsxs("div", { className: "tlui-style-panel", "data-ismobile": e, onPointerLeave: a, children: [
    /* @__PURE__ */ E.jsx(Pue, { props: r }),
    !x && /* @__PURE__ */ E.jsx(Iue, { props: r }),
    !(y && v && S) && /* @__PURE__ */ E.jsxs("div", { className: "tlui-style-panel__section", "aria-label": "style panel styles", children: [
      /* @__PURE__ */ E.jsx(Rue, { props: r }),
      /* @__PURE__ */ E.jsx(Mue, { props: r }),
      /* @__PURE__ */ E.jsx($ue, { props: r })
    ] })
  ] });
}), { styles: Ka } = en;
function Ab() {
  const t = Ge();
  return It.useCallback(
    (e, n) => {
      t.batch(() => {
        t.setProp(e.type, e.id, !1, n), t.isChangingStyle = !0;
      });
    },
    [t]
  );
}
function Pue({ props: t }) {
  const e = Ge(), n = Fn(), r = Ab(), a = It.useCallback(
    (S, x) => {
      const _ = Ka.opacity[S];
      e.setProp(_.type, _.id, x), e.isChangingStyle = !0;
    },
    [e]
  ), { color: s, fill: c, dash: f, size: p, opacity: g } = t;
  if (s === void 0 && c === void 0 && f === void 0 && p === void 0 && g === void 0)
    return null;
  const y = c || f || p, v = Ka.opacity.findIndex((S) => S.id === g);
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsxs("div", { className: "tlui-style-panel__section__common", "aria-label": "style panel styles", children: [
      s === void 0 ? null : /* @__PURE__ */ E.jsx(
        Yg,
        {
          title: n("style-panel.color"),
          styleType: "color",
          "data-wd": "style.color",
          items: Ka.color,
          value: s,
          onValueChange: r
        }
      ),
      g === void 0 ? null : /* @__PURE__ */ E.jsx(
        oce,
        {
          "data-wd": "style.opacity",
          value: v >= 0 ? v : Ka.opacity.length - 1,
          label: g ? `opacity-style.${g}` : "style-panel.mixed",
          onValueChange: a,
          steps: Ka.opacity.length - 1,
          title: n("style-panel.opacity")
        }
      )
    ] }),
    y && /* @__PURE__ */ E.jsxs("div", { className: "tlui-style-panel__section", "aria-label": "style panel styles", children: [
      c === void 0 ? null : /* @__PURE__ */ E.jsx(
        Yg,
        {
          title: n("style-panel.fill"),
          styleType: "fill",
          "data-wd": "style.fill",
          items: Ka.fill,
          value: c,
          onValueChange: r
        }
      ),
      f === void 0 ? null : /* @__PURE__ */ E.jsx(
        Yg,
        {
          title: n("style-panel.dash"),
          styleType: "dash",
          "data-wd": "style.dash",
          items: Ka.dash,
          value: f,
          onValueChange: r
        }
      ),
      p === void 0 ? null : /* @__PURE__ */ E.jsx(
        Yg,
        {
          title: n("style-panel.size"),
          styleType: "size",
          "data-wd": "style.size",
          items: Ka.size,
          value: p,
          onValueChange: r
        }
      )
    ] })
  ] });
}
function Iue({ props: t }) {
  const e = Fn(), n = Ab(), { font: r, align: a } = t;
  return r === void 0 && a === void 0 ? null : /* @__PURE__ */ E.jsxs("div", { className: "tlui-style-panel__section", "aria-label": "style panel text", children: [
    r === void 0 ? null : /* @__PURE__ */ E.jsx(
      Yg,
      {
        title: e("style-panel.font"),
        styleType: "font",
        "data-wd": "font",
        items: Ka.font,
        value: r,
        onValueChange: n
      }
    ),
    a === void 0 ? null : /* @__PURE__ */ E.jsx(
      Yg,
      {
        title: e("style-panel.align"),
        styleType: "align",
        "data-wd": "align",
        items: Ka.align,
        value: a,
        onValueChange: n
      }
    )
  ] });
}
function Rue({ props: t }) {
  const e = Ab(), { geo: n } = t;
  return n === void 0 ? null : /* @__PURE__ */ E.jsx(
    u5,
    {
      id: "geo",
      label: "style-panel.geo",
      styleType: "geo",
      "data-wd": "style-panel.geo",
      items: Ka.geo,
      value: n,
      onValueChange: e
    }
  );
}
function $ue({ props: t }) {
  const e = Ab(), { spline: n } = t;
  return n === void 0 ? null : /* @__PURE__ */ E.jsx(
    u5,
    {
      id: "spline",
      label: "style-panel.spline",
      styleType: "spline",
      "data-wd": "style.spline",
      items: Ka.spline,
      value: n,
      onValueChange: e
    }
  );
}
function Mue({ props: t }) {
  const e = Ab(), { arrowheadEnd: n, arrowheadStart: r } = t;
  return n === void 0 && r === void 0 ? null : /* @__PURE__ */ E.jsx(
    kue,
    {
      label: "style-panel.arrowheads",
      styleTypeA: "arrowheadStart",
      "data-wd": "style.arrowheads",
      itemsA: Ka.arrowheadStart,
      valueA: r,
      styleTypeB: "arrowheadEnd",
      itemsB: Ka.arrowheadEnd,
      valueB: n,
      onValueChange: e,
      labelA: "style-panel.arrowhead-start",
      labelB: "style-panel.arrowhead-end"
    }
  );
}
function Aue() {
  const t = Ge(), n = ba()["back-to-content"], [r, a] = k.useState(!1);
  return k.useEffect(() => {
    let s = !1;
    const c = setInterval(() => {
      const { renderingShapes: f } = t, g = f.filter((y) => y.isInViewport).length === 0 && t.shapesArray.length > 0;
      s !== g && (a(g), s = g);
    }, 1e3);
    return () => {
      clearInterval(c);
    };
  }, [t]), r ? /* @__PURE__ */ E.jsx(
    At,
    {
      iconLeft: n.icon,
      label: n.label,
      onClick: () => {
        n.onSelect(), a(!1);
      }
    }
  ) : null;
}
const Oue = ({ id: t, component: e, onClose: n }) => {
  const { removeDialog: r } = Vp(), a = va(), s = k.useCallback(
    (c) => {
      if (!c) {
        if (n)
          try {
            n();
          } catch (f) {
            console.warn(f);
          }
        r(t);
      }
    },
    [t, n, r]
  );
  return /* @__PURE__ */ E.jsx(ole, { onOpenChange: s, defaultOpen: !0, children: /* @__PURE__ */ E.jsx(ale, { container: a, children: /* @__PURE__ */ E.jsx(sle, { dir: "ltr", className: "tlui-dialog__overlay", children: /* @__PURE__ */ E.jsx(lle, { dir: "ltr", className: "tlui-dialog__content", children: /* @__PURE__ */ E.jsx(e, { onClose: () => s(!1) }) }) }) }) });
};
function Due() {
  const { dialogs: t } = Vp();
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: t.map((e) => /* @__PURE__ */ E.jsx(Oue, { ...e }, e.id)) });
}
const Nue = It.memo(Due), Lue = dn(function() {
  const n = Ge().isPenMode, r = ba();
  if (!n)
    return null;
  const a = r["exit-pen-mode"];
  return /* @__PURE__ */ E.jsx(At, { label: a.label, iconLeft: a.icon, onClick: a.onSelect });
}), f5 = "Popover", [p5, rhe] = Nc(f5, [
  R1
]), k2 = R1(), [jue, mm] = p5(f5), zue = (t) => {
  const { __scopePopover: e, children: n, open: r, defaultOpen: a, onOpenChange: s, modal: c = !1 } = t, f = k2(e), p = k.useRef(null), [g, y] = k.useState(!1), [v = !1, S] = ff({
    prop: r,
    defaultProp: a,
    onChange: s
  });
  return /* @__PURE__ */ k.createElement(i2, f, /* @__PURE__ */ k.createElement(jue, {
    scope: e,
    contentId: ju(),
    triggerRef: p,
    open: v,
    onOpenChange: S,
    onOpenToggle: k.useCallback(
      () => S(
        (x) => !x
      ),
      [
        S
      ]
    ),
    hasCustomAnchor: g,
    onCustomAnchorAdd: k.useCallback(
      () => y(!0),
      []
    ),
    onCustomAnchorRemove: k.useCallback(
      () => y(!1),
      []
    ),
    modal: c
  }, n));
}, Uue = "PopoverTrigger", Bue = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopePopover: n, ...r } = t, a = mm(Uue, n), s = k2(n), c = Rr(e, a.triggerRef), f = /* @__PURE__ */ k.createElement(pr.button, qe({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": a.open,
    "aria-controls": a.contentId,
    "data-state": m5(a.open)
  }, r, {
    ref: c,
    onClick: _t(t.onClick, a.onOpenToggle)
  }));
  return a.hasCustomAnchor ? f : /* @__PURE__ */ k.createElement(wz, qe({
    asChild: !0
  }, s), f);
}), h5 = "PopoverPortal", [Fue, Hue] = p5(h5, {
  forceMount: void 0
}), Vue = (t) => {
  const { __scopePopover: e, forceMount: n, children: r, container: a } = t, s = mm(h5, e);
  return /* @__PURE__ */ k.createElement(Fue, {
    scope: e,
    forceMount: n
  }, /* @__PURE__ */ k.createElement(Nl, {
    present: n || s.open
  }, /* @__PURE__ */ k.createElement(_1, {
    asChild: !0,
    container: a
  }, r)));
}, pb = "PopoverContent", Yue = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = Hue(pb, t.__scopePopover), { forceMount: r = n.forceMount, ...a } = t, s = mm(pb, t.__scopePopover);
  return /* @__PURE__ */ k.createElement(Nl, {
    present: r || s.open
  }, s.modal ? /* @__PURE__ */ k.createElement(Kue, qe({}, a, {
    ref: e
  })) : /* @__PURE__ */ k.createElement(Wue, qe({}, a, {
    ref: e
  })));
}), Kue = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = mm(pb, t.__scopePopover), r = k.useRef(null), a = Rr(e, r), s = k.useRef(!1);
  return k.useEffect(() => {
    const c = r.current;
    if (c)
      return a2(c);
  }, []), /* @__PURE__ */ k.createElement(s2, {
    as: Op,
    allowPinchZoom: !0
  }, /* @__PURE__ */ k.createElement(g5, qe({}, t, {
    ref: a,
    trapFocus: n.open,
    disableOutsidePointerEvents: !0,
    onCloseAutoFocus: _t(t.onCloseAutoFocus, (c) => {
      var f;
      c.preventDefault(), s.current || (f = n.triggerRef.current) === null || f === void 0 || f.focus();
    }),
    onPointerDownOutside: _t(t.onPointerDownOutside, (c) => {
      const f = c.detail.originalEvent, p = f.button === 0 && f.ctrlKey === !0, g = f.button === 2 || p;
      s.current = g;
    }, {
      checkForDefaultPrevented: !1
    }),
    onFocusOutside: _t(
      t.onFocusOutside,
      (c) => c.preventDefault(),
      {
        checkForDefaultPrevented: !1
      }
    )
  })));
}), Wue = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = mm(pb, t.__scopePopover), r = k.useRef(!1), a = k.useRef(!1);
  return /* @__PURE__ */ k.createElement(g5, qe({}, t, {
    ref: e,
    trapFocus: !1,
    disableOutsidePointerEvents: !1,
    onCloseAutoFocus: (s) => {
      var c;
      if ((c = t.onCloseAutoFocus) === null || c === void 0 || c.call(t, s), !s.defaultPrevented) {
        var f;
        r.current || (f = n.triggerRef.current) === null || f === void 0 || f.focus(), s.preventDefault();
      }
      r.current = !1, a.current = !1;
    },
    onInteractOutside: (s) => {
      var c, f;
      (c = t.onInteractOutside) === null || c === void 0 || c.call(t, s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (a.current = !0));
      const p = s.target;
      ((f = n.triggerRef.current) === null || f === void 0 ? void 0 : f.contains(p)) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && a.current && s.preventDefault();
    }
  }));
}), g5 = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopePopover: n, trapFocus: r, onOpenAutoFocus: a, onCloseAutoFocus: s, disableOutsidePointerEvents: c, onEscapeKeyDown: f, onPointerDownOutside: p, onFocusOutside: g, onInteractOutside: y, ...v } = t, S = mm(pb, n), x = k2(n);
  return e2(), /* @__PURE__ */ k.createElement(t2, {
    asChild: !0,
    loop: !0,
    trapped: r,
    onMountAutoFocus: a,
    onUnmountAutoFocus: s
  }, /* @__PURE__ */ k.createElement(C1, {
    asChild: !0,
    disableOutsidePointerEvents: c,
    onInteractOutside: y,
    onEscapeKeyDown: f,
    onPointerDownOutside: p,
    onFocusOutside: g,
    onDismiss: () => S.onOpenChange(!1)
  }, /* @__PURE__ */ k.createElement(xz, qe({
    "data-state": m5(S.open),
    role: "dialog",
    id: S.contentId
  }, x, v, {
    ref: e,
    style: {
      ...v.style,
      "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
      "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
      "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }))));
});
function m5(t) {
  return t ? "open" : "closed";
}
const Gue = zue, Xue = Bue, v5 = Vue, y5 = Yue, P2 = ({ id: t, open: e, children: n, onOpenChange: r }) => {
  const a = gm(t, r);
  return /* @__PURE__ */ E.jsx(Gue, { onOpenChange: a, open: e, children: /* @__PURE__ */ E.jsx("div", { className: "tlui-popover", children: n }) });
}, I2 = ({ children: t, disabled: e, "data-wd": n }) => /* @__PURE__ */ E.jsx(Xue, { "data-wd": n, disabled: e, asChild: !0, dir: "ltr", children: t }), b5 = ({ side: t, children: e, align: n = "center", sideOffset: r = 8, alignOffset: a = 0 }) => {
  const s = va();
  return /* @__PURE__ */ E.jsx(v5, { dir: "ltr", container: s, children: /* @__PURE__ */ E.jsx(
    y5,
    {
      className: "tlui-popover__content",
      side: t,
      sideOffset: r,
      align: n,
      alignOffset: a,
      dir: "ltr",
      children: e
    }
  ) });
}, S5 = k.memo(function() {
  const e = Fn(), n = va(), r = Mce(), a = Vu();
  function s(c) {
    if (a && !c.readonlyOk)
      return null;
    switch (c.type) {
      case "item": {
        const { id: f, icon: p, label: g, kbd: y, onSelect: v } = c.actionItem;
        return /* @__PURE__ */ E.jsx(
          At,
          {
            className: "tlui-button-grid__button",
            "data-wd": `menu-item.${c.id}`,
            icon: p,
            title: g ? y ? `${e(g)} ${Ic(y)}` : `${e(g)}` : y ? `${Ic(y)}` : "",
            onClick: v,
            disabled: c.disabled
          },
          f
        );
      }
    }
  }
  return /* @__PURE__ */ E.jsxs(P2, { id: "actions menu", children: [
    /* @__PURE__ */ E.jsx(I2, { children: /* @__PURE__ */ E.jsx(
      At,
      {
        className: "tlui-menu__trigger",
        "data-wd": "main.action-menu",
        icon: "dots-vertical",
        title: e("actions-menu.title"),
        smallIcon: !0
      }
    ) }),
    /* @__PURE__ */ E.jsx(v5, { dir: "ltr", container: n, children: /* @__PURE__ */ E.jsx(
      y5,
      {
        className: "tlui-popover__content",
        side: "bottom",
        dir: "ltr",
        sideOffset: 6,
        children: /* @__PURE__ */ E.jsx("div", { className: "tlui-actions-menu tlui-button-grid__four", children: r.map(s) })
      }
    ) })
  ] });
}), w5 = dn(function() {
  const e = Ge(), n = ba(), r = Fn(), a = n.duplicate, s = e.selectedIds.length <= 0;
  return /* @__PURE__ */ E.jsx(
    At,
    {
      icon: a.icon,
      onClick: a.onSelect,
      disabled: s,
      title: `${r(a.label)} ${Ic(a.kbd)}`,
      smallIcon: !0
    }
  );
}), que = k.memo(function() {
  const e = Fn();
  return /* @__PURE__ */ E.jsxs(of, { id: "main menu", children: [
    /* @__PURE__ */ E.jsx($b, { children: /* @__PURE__ */ E.jsx(
      At,
      {
        className: "tlui-menu__trigger",
        "data-wd": "main.menu",
        title: e("menu.title"),
        icon: "menu"
      }
    ) }),
    /* @__PURE__ */ E.jsx(af, { alignOffset: 0, sideOffset: 6, children: /* @__PURE__ */ E.jsx(Que, {}) })
  ] });
});
function Que() {
  const t = Ge(), e = Fn(), n = sue(), r = qs(), a = Vu(), { paste: s } = x2();
  function c(f, p, g, y) {
    switch (p.type) {
      case "custom":
        return a && !p.readonlyOk ? null : p.id === "LANGUAGE_MENU" ? /* @__PURE__ */ E.jsx(c5, {}, "item") : p.id === "MENU_PASTE" ? /* @__PURE__ */ E.jsx(
          Ko,
          {
            "data-wd": `menu-item.${p.id}`,
            kbd: "$v",
            label: "action.paste",
            disabled: p.disabled,
            onMouseDown: () => {
              f.isSafari && navigator.clipboard?.read && navigator.clipboard.read().then((v) => {
                s(v);
              });
            },
            onClick: () => {
              f.isSafari || navigator.clipboard?.read && navigator.clipboard.read().then((v) => {
                s(v);
              });
            },
            onPointerUp: Gn
          },
          p.id
        ) : null;
      case "group":
        return a && !p.readonlyOk ? null : /* @__PURE__ */ E.jsx(
          Lp,
          {
            size: y <= 1 ? "medium" : r < 3 || g?.type === "submenu" && y > 2 ? "tiny" : "medium",
            children: p.children.map((v) => c(f, v, p, y + 1))
          },
          p.id
        );
      case "submenu":
        return a && !p.readonlyOk ? null : /* @__PURE__ */ E.jsxs(g2, { id: `main menu ${g ? g.id + " " : ""}${p.id}`, children: [
          /* @__PURE__ */ E.jsx(m2, { label: p.label, "data-wd": `menu-item.${p.id}` }),
          /* @__PURE__ */ E.jsx(v2, { sideOffset: -4, alignOffset: -1, children: p.children.map((v) => c(f, v, p, y + 1)) })
        ] }, p.id);
      case "item": {
        if (a && !p.readonlyOk)
          return null;
        const { id: v, checkbox: S, menuLabel: x, label: _, onSelect: T, kbd: I } = p.actionItem, D = x ?? _, N = D ? e(D) : void 0;
        return S ? /* @__PURE__ */ E.jsxs(
          $le,
          {
            onSelect: T,
            title: N || "",
            checked: p.checked,
            disabled: p.disabled,
            children: [
              N && /* @__PURE__ */ E.jsx("span", { children: N }),
              I && /* @__PURE__ */ E.jsx(D1, { children: I })
            ]
          },
          v
        ) : /* @__PURE__ */ E.jsx(
          Ko,
          {
            "data-wd": `menu-item.${p.id}`,
            kbd: I,
            label: D,
            onClick: T,
            disabled: p.disabled
          },
          v
        );
      }
    }
  }
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: n.map((f) => c(t, f, null, 0)) });
}
const Zue = function({
  name: e,
  id: n,
  isCurrentPage: r
}) {
  const a = Ge(), s = k.useRef(null), c = k.useCallback(
    (p) => {
      a.renamePage(n, p || "New Page", !0);
    },
    [a, n]
  ), f = k.useCallback(
    (p) => {
      a.mark("rename page"), a.renamePage(n, p || "New Page", !1);
    },
    [a, n]
  );
  return /* @__PURE__ */ E.jsx(
    y2,
    {
      className: "tlui-page-menu__item__input",
      ref: (p) => s.current = p,
      defaultValue: e,
      onValueChange: c,
      onComplete: f,
      onCancel: f,
      shouldManuallyMaintainScrollPositionWhenFocused: !0,
      autofocus: r,
      autoselect: !0
    }
  );
}, NP = (t, e, n, r) => {
  let a;
  const s = t.pages, c = n > r ? s[r - 1] : s[r], f = n > r ? s[r] : s[r + 1];
  c && !f ? a = Mu(c.index) : !c && f ? a = LZ(s[0].index) : a = Hy(c.index, f.index), a !== s[n].index && (t.mark("moving page"), t.updatePage({
    id: e,
    index: a
  }));
}, zN = dn(function({
  index: e,
  listSize: n,
  item: r,
  onRename: a
}) {
  const s = Ge(), c = Fn(), f = s.pages, p = k.useCallback(() => {
    s.mark("creating page");
    const S = fr.createId();
    s.duplicatePage(r.id, S);
  }, [s, r]), g = k.useCallback(() => {
    NP(s, r.id, e, e - 1);
  }, [s, r, e]), y = k.useCallback(() => {
    NP(s, r.id, e, e + 1);
  }, [s, r, e]), v = k.useCallback(() => {
    s.mark("deleting page"), s.deletePage(r.id);
  }, [s, r]);
  return /* @__PURE__ */ E.jsxs(of, { id: "page item submenu", children: [
    /* @__PURE__ */ E.jsx($b, { children: /* @__PURE__ */ E.jsx(At, { title: c("page-menu.submenu.title"), icon: "dots-vertical" }) }),
    /* @__PURE__ */ E.jsxs(af, { alignOffset: 0, children: [
      /* @__PURE__ */ E.jsxs(Lp, { children: [
        a && /* @__PURE__ */ E.jsx(Ug, { dir: "ltr", onSelect: a, asChild: !0, children: /* @__PURE__ */ E.jsx(At, { className: "tlui-menu__button", label: "page-menu.submenu.rename" }) }),
        /* @__PURE__ */ E.jsx(
          Ug,
          {
            dir: "ltr",
            onSelect: p,
            disabled: f.length >= $x,
            asChild: !0,
            children: /* @__PURE__ */ E.jsx(At, { className: "tlui-menu__button", label: "page-menu.submenu.duplicate-page" })
          }
        ),
        e > 0 && /* @__PURE__ */ E.jsx(Ug, { dir: "ltr", onSelect: g, asChild: !0, children: /* @__PURE__ */ E.jsx(At, { className: "tlui-menu__button", label: "page-menu.submenu.move-up" }) }),
        e < n - 1 && /* @__PURE__ */ E.jsx(Ug, { dir: "ltr", onSelect: y, asChild: !0, children: /* @__PURE__ */ E.jsx(At, { className: "tlui-menu__button", label: "page-menu.submenu.move-down" }) })
      ] }),
      n > 1 && /* @__PURE__ */ E.jsx(Lp, { children: /* @__PURE__ */ E.jsx(Ug, { dir: "ltr", onSelect: v, asChild: !0, children: /* @__PURE__ */ E.jsx(At, { className: "tlui-menu__button", label: "page-menu.submenu.delete" }) }) })
    ] })
  ] });
}), Jue = dn(function() {
  const e = Ge(), n = Fn(), r = qs(), a = r < 5 ? 36 : 40, s = k.useRef(null), { pages: c, currentPage: f } = e, p = e.isReadOnly, g = e.pages.length >= $x, [y, v] = k.useState(!1), S = k.useCallback(() => {
    p || v((X) => !X);
  }, [p]), [x, _] = k.useState(!1), T = k.useCallback((X) => {
    _(X), v(!1);
  }, []), I = k.useRef({
    isPointing: !1,
    status: "idle",
    pointing: null,
    startY: 0,
    startIndex: 0,
    dragIndex: 0
  }), [D, N] = k.useState(
    Object.fromEntries(
      c.map((X, se) => [X.id, { y: se * a, offsetY: 0, isSelected: !1 }])
    )
  );
  k.useLayoutEffect(() => {
    N(
      Object.fromEntries(
        c.map((X, se) => [X.id, { y: se * a, offsetY: 0, isSelected: !1 }])
      )
    );
  }, [a, c]), k.useEffect(() => {
    x && requestAnimationFrame(() => {
      const X = document.querySelector(
        `[data-wd="page-menu-item-${f.id}"]`
      );
      if (X) {
        const se = s.current;
        if (!se)
          return;
        const ue = X.offsetTop, pe = se.scrollTop;
        ue < pe && se.scrollTo({ top: ue });
        const Pe = ue + a, ve = se.scrollTop + se.offsetHeight;
        Pe > ve && se.scrollTo({ top: Pe - se.offsetHeight });
      }
    });
  }, [a, f, x]);
  const j = k.useCallback(
    (X) => {
      const { clientY: se, currentTarget: ue } = X, {
        dataset: { id: pe, index: Pe }
      } = ue;
      if (!pe || !Pe)
        return;
      const ve = I.current;
      X.currentTarget.setPointerCapture(X.pointerId), ve.status = "pointing", ve.pointing = { id: pe, index: +Pe };
      const le = D[pe].y;
      ve.startY = se, ve.startIndex = Math.max(0, Math.min(Math.round(le / a), c.length - 1));
    },
    [a, c.length, D]
  ), L = k.useCallback(
    (X) => {
      const se = I.current;
      if (se.status === "pointing") {
        const { clientY: ue } = X, pe = ue - se.startY;
        Math.abs(pe) > 5 && (se.status = "dragging");
      }
      if (se.status === "dragging") {
        const { clientY: ue } = X, pe = ue - se.startY, Pe = D[se.pointing.id], { startIndex: ve, pointing: Y } = se, le = Pe.y + pe, Re = Math.max(0, Math.min(Math.round(le / a), c.length - 1)), he = { ...D };
        if (he[Y.id] = {
          y: Pe.y,
          offsetY: pe,
          isSelected: !0
        }, Re !== se.dragIndex) {
          se.dragIndex = Re;
          for (let te = 0; te < c.length; te++) {
            const de = c[te];
            if (de.id === se.pointing.id)
              continue;
            let { y: W } = he[de.id];
            Re === ve ? W = te * a : Re < ve ? Re <= te && te < ve ? W = (te + 1) * a : W = te * a : Re > ve && (Re >= te && te > ve ? W = (te - 1) * a : W = te * a), W !== he[de.id].y && (he[de.id] = { y: W, offsetY: 0, isSelected: !0 });
          }
        }
        N(he);
      }
    },
    [a, c, D]
  ), z = k.useCallback(
    (X) => {
      const se = I.current;
      if (se.status === "dragging") {
        const { id: ue, index: pe } = se.pointing;
        NP(e, ue, pe, se.dragIndex);
      }
      X.currentTarget.releasePointerCapture(X.pointerId), se.status = "idle";
    },
    [e]
  ), F = k.useCallback(
    (X) => {
      const se = I.current;
      X.key === "Escape" && (se.status === "dragging" && N(
        Object.fromEntries(
          c.map((ue, pe) => [
            ue.id,
            { y: pe * a, offsetY: 0, isSelected: !1 }
          ])
        )
      ), se.status = "idle");
    },
    [a, c]
  ), K = k.useCallback(() => {
    if (p)
      return;
    e.mark("creating page");
    const X = fr.createId();
    e.createPage(n("page-menu.new-page-initial-name"), X), v(!0);
  }, [e, n, p]);
  return /* @__PURE__ */ E.jsxs(P2, { id: "page menu", onOpenChange: T, open: x, children: [
    /* @__PURE__ */ E.jsx(I2, { children: /* @__PURE__ */ E.jsx(
      At,
      {
        className: "tlui-page-menu__trigger tlui-menu__trigger",
        "data-wd": "main.page-menu",
        icon: "chevron-down",
        title: f.name,
        children: /* @__PURE__ */ E.jsx("div", { className: "tlui-page-menu__name", children: f.name })
      }
    ) }),
    /* @__PURE__ */ E.jsx(b5, { side: "bottom", align: "start", sideOffset: 6, children: /* @__PURE__ */ E.jsxs("div", { className: "tlui-page-menu__wrapper", children: [
      /* @__PURE__ */ E.jsxs("div", { className: "tlui-page-menu__header", children: [
        /* @__PURE__ */ E.jsx("div", { className: "tlui-page-menu__header__title", children: n("page-menu.title") }),
        !p && /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
          /* @__PURE__ */ E.jsx(
            At,
            {
              "data-wd": "page-menu.edit",
              title: n(y ? "page-menu.edit-done" : "page-menu.edit-start"),
              icon: y ? "check" : "edit",
              onClick: S
            }
          ),
          /* @__PURE__ */ E.jsx(
            At,
            {
              "data-wd": "page-menu.create",
              icon: "plus",
              title: n(
                g ? "page-menu.max-page-count-reached" : "page-menu.create-new-page"
              ),
              disabled: g,
              onClick: K
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ E.jsx(
        "div",
        {
          className: "tlui-page-menu__list tlui-menu__group",
          style: { height: a * c.length + 4 },
          ref: s,
          children: c.map((X, se) => {
            const ue = D[X.id] ?? {
              position: se * 40,
              offsetY: 0
            };
            return y ? /* @__PURE__ */ E.jsxs(
              "div",
              {
                "data-wd": `page-menu-item-${X.id}`,
                className: "tlui-page_menu__item__sortable",
                style: {
                  zIndex: X.id === f.id ? 888 : se,
                  transform: `translate(0px, ${ue.y + ue.offsetY}px)`
                },
                children: [
                  /* @__PURE__ */ E.jsx(
                    At,
                    {
                      tabIndex: -1,
                      className: "tlui-page_menu__item__sortable__handle",
                      icon: "drag-handle-dots",
                      onPointerDown: j,
                      onPointerUp: z,
                      onPointerMove: L,
                      onKeyDown: F,
                      "data-id": X.id,
                      "data-index": se
                    }
                  ),
                  r < 5 && e.isCoarsePointer ? (
                    // sigh, this is a workaround for iOS Safari
                    // because the device and the radix popover seem
                    // to be fighting over scroll position. Nothing
                    // else seems to work!
                    /* @__PURE__ */ E.jsx(At, {
                      className: "tlui-page-menu__item__button",
                      onClick: () => {
                        const pe = window.prompt("Rename page", X.name);
                        pe && pe !== X.name && e.renamePage(X.id, pe);
                      },
                      onDoubleClick: S,
                      isChecked: X.id === f.id,
                      children: /* @__PURE__ */ E.jsx("span", { children: X.name })
                    })
                  ) : /* @__PURE__ */ E.jsx(
                    "div",
                    {
                      id: `page-menu-item-${X.id}`,
                      "data-wd": `page-menu-item-${X.id}`,
                      className: "tlui-page_menu__item__sortable__title",
                      style: { height: a },
                      children: /* @__PURE__ */ E.jsx(
                        Zue,
                        {
                          id: X.id,
                          name: X.name,
                          isCurrentPage: X.id === f.id
                        }
                      )
                    }
                  ),
                  !p && /* @__PURE__ */ E.jsx("div", { className: "tlui-page_menu__item__submenu", "data-isediting": y, children: /* @__PURE__ */ E.jsx(zN, { index: se, item: X, listSize: c.length }) })
                ]
              },
              X.id + "_editing"
            ) : /* @__PURE__ */ E.jsxs(
              "div",
              {
                "data-wd": `page-menu-item-${X.id}`,
                className: "tlui-page-menu__item",
                children: [
                  /* @__PURE__ */ E.jsxs(
                    At,
                    {
                      className: "tlui-page-menu__item__button tlui-page-menu__item__button__checkbox",
                      onClick: () => e.setCurrentPageId(X.id),
                      onDoubleClick: S,
                      isChecked: X.id === f.id,
                      children: [
                        /* @__PURE__ */ E.jsx("div", { className: "tlui-page-menu__item__button__check", children: X.id === f.id && /* @__PURE__ */ E.jsx(Wa, { icon: "check" }) }),
                        /* @__PURE__ */ E.jsx("span", { children: X.name })
                      ]
                    }
                  ),
                  !p && /* @__PURE__ */ E.jsx("div", { className: "tlui-page_menu__item__submenu", children: /* @__PURE__ */ E.jsx(
                    zN,
                    {
                      index: se,
                      item: X,
                      listSize: c.length,
                      onRename: () => {
                        if (e.isIos) {
                          const pe = window.prompt("Rename page", X.name);
                          pe && pe !== X.name && e.renamePage(X.id, pe);
                        } else
                          v(!0), e.setCurrentPageId(X.id);
                      }
                    }
                  ) })
                ]
              },
              X.id
            );
          })
        }
      )
    ] }) })
  ] });
}), x5 = k.memo(function() {
  const e = Fn(), n = G4(), a = ba().redo;
  return /* @__PURE__ */ E.jsx(
    At,
    {
      "data-wd": "main.redo",
      icon: a.icon,
      title: `${e(a.label)} ${Ic(a.kbd)}`,
      disabled: !n,
      onClick: a.onSelect,
      smallIcon: !0
    }
  );
}), E5 = dn(function() {
  const e = Ge(), n = ba(), r = Fn(), a = n.delete;
  if (Vu())
    return null;
  const c = e.selectedIds.length <= 0;
  return /* @__PURE__ */ E.jsx(
    At,
    {
      icon: a.icon,
      onClick: a.onSelect,
      disabled: c,
      title: `${r(a.label)} ${Ic(a.kbd)}`,
      smallIcon: !0
    }
  );
}), C5 = k.memo(function() {
  const e = Fn(), n = X4(), a = ba().undo;
  return /* @__PURE__ */ E.jsx(
    At,
    {
      "data-wd": "main.undo",
      icon: a.icon,
      title: `${e(a.label)} ${Ic(a.kbd)}`,
      disabled: !n,
      onClick: a.onSelect,
      smallIcon: !0
    }
  );
}), ede = dn(function() {
  const e = qs(), n = Vu();
  return /* @__PURE__ */ E.jsx("div", { className: "tlui-menu-zone", children: /* @__PURE__ */ E.jsxs("div", { className: "tlui-menu-zone__controls", children: [
    /* @__PURE__ */ E.jsx(que, {}),
    /* @__PURE__ */ E.jsx("div", { className: "tlui-menu-zone__divider" }),
    /* @__PURE__ */ E.jsx(Jue, {}),
    e >= 5 && !n && /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx("div", { className: "tlui-menu-zone__divider" }),
      /* @__PURE__ */ E.jsx(C5, {}),
      /* @__PURE__ */ E.jsx(x5, {}),
      /* @__PURE__ */ E.jsx(E5, {}),
      /* @__PURE__ */ E.jsx(w5, {}),
      /* @__PURE__ */ E.jsx(S5, {})
    ] })
  ] }) });
});
function tde({ toast: t }) {
  const { removeToast: e } = Hu(), n = Fn(), r = (s) => {
    s || e(t.id);
  }, a = t.actions && t.actions.length > 0;
  return /* @__PURE__ */ E.jsxs(
    foe,
    {
      onOpenChange: r,
      className: "tlui-toast__container",
      duration: t.keepOpen ? 1 / 0 : 5e3,
      children: [
        t.icon && /* @__PURE__ */ E.jsx("div", { className: "tlui-toast__icon", children: /* @__PURE__ */ E.jsx(Wa, { icon: t.icon }) }),
        /* @__PURE__ */ E.jsxs("div", { className: "tlui-toast__main", children: [
          /* @__PURE__ */ E.jsxs("div", { className: "tlui-toast__content", children: [
            /* @__PURE__ */ E.jsx(poe, { className: "tlui-toast__title", children: t.title }),
            /* @__PURE__ */ E.jsx(hoe, { className: "tlui-toast__description", children: t.description })
          ] }),
          t.actions && /* @__PURE__ */ E.jsxs("div", { className: "tlui-toast__actions", children: [
            t.actions.map((s, c) => /* @__PURE__ */ E.jsx(goe, { altText: s.label, asChild: !0, onClick: s.onClick, children: /* @__PURE__ */ E.jsx(
              At,
              {
                className: s.type === "warn" ? "tlui-button__warning" : "tlui-button__primary",
                children: s.label
              }
            ) }, c)),
            a && /* @__PURE__ */ E.jsx(iN, { asChild: !0, children: /* @__PURE__ */ E.jsx(At, { className: "tlui-toast__close", style: { marginLeft: "auto" }, children: t.closeLabel ?? n("toast.close") }) })
          ] })
        ] }),
        !a && /* @__PURE__ */ E.jsx(iN, { asChild: !0, children: /* @__PURE__ */ E.jsx(At, { className: "tlui-toast__close", children: t.closeLabel ?? n("toast.close") }) })
      ]
    }
  );
}
function nde() {
  const { toasts: t } = Hu();
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: t.map((e) => /* @__PURE__ */ E.jsx(tde, { toast: e }, e.id)) });
}
const rde = k.memo(nde);
function ide() {
  const { toasts: t } = Hu(), [e, n] = k.useState(!1);
  return k.useEffect(() => {
    let r = !1;
    return t.length ? n(!0) : setTimeout(() => {
      r || n(!1);
    }, 1e3), () => {
      r = !0;
    };
  }, [t.length, n]), e ? /* @__PURE__ */ E.jsx(Xie, { className: "tlui-toast__viewport" }) : null;
}
function ode() {
  const t = Ge(), e = un(
    "current color",
    () => {
      const { props: a } = t;
      return a ? a.color ? t.getCssColor(a.color) : null : "var(--color-muted-1)";
    },
    [t]
  ), n = un(
    "isHandOrEraserToolActive",
    () => t.currentToolId === "hand" || t.currentToolId === "eraser",
    [t]
  ), r = k.useCallback(
    (a) => {
      a || (t.isChangingStyle = !1);
    },
    [t]
  );
  return /* @__PURE__ */ E.jsxs(P2, { id: "style menu", onOpenChange: r, children: [
    /* @__PURE__ */ E.jsx(I2, { disabled: n, children: /* @__PURE__ */ E.jsx(
      At,
      {
        className: "tlui-toolbar__tools__button tlui-toolbar__styles__button tlui-popover__trigger",
        "data-wd": "mobile.styles",
        style: { color: e ?? "var(--color-text)" },
        children: /* @__PURE__ */ E.jsx(Wa, { icon: e ? "blob" : "mixed" })
      }
    ) }),
    /* @__PURE__ */ E.jsx(b5, { side: "top", align: "end", children: /* @__PURE__ */ E.jsx(d5, { isMobile: !0 }) })
  ] });
}
const ade = dn(function({
  activeToolId: e
}) {
  const n = Ge(), r = qs(), a = Fn(), {
    instanceState: { isToolLocked: s }
  } = n;
  return e === "select" || e === "hand" || e === "draw" || e === "eraser" || e === "text" ? null : /* @__PURE__ */ E.jsx(
    At,
    {
      title: a("action.toggle-tool-lock"),
      className: $n("tlui-toolbar__lock-button", {
        "tlui-toolbar__lock-button__mobile": r < 5
      }),
      icon: n.instanceState.isToolLocked ? "lock" : "unlock",
      onClick: () => n.updateInstanceState({ isToolLocked: !s }),
      smallIcon: !0
    }
  );
}), sde = dn(function() {
  const e = Ge(), n = Fn(), r = qs(), a = It.useRef(void 0), s = e.isReadOnly, c = cue(), f = e.currentToolId, p = e.props ? e.props.geo : void 0, g = (_) => _.label ? `${n(_.label)} ${_.kbd ? Ic(_.kbd) : ""}` : "", y = c.find((_) => Oy(_.toolItem, f, p)), { itemsInPanel: v, itemsInDropdown: S, dropdownFirstItem: x } = It.useMemo(() => {
    const _ = [], T = [];
    let I;
    const D = Math.min(8, 5 + r);
    for (let N = 4; N < c.length; N++) {
      const j = c[N];
      N < D ? _.push(j) : (j === y && (I = j), T.push(j));
    }
    return I || (a.current || (a.current = T[0]), I = a.current, T.includes(I) || (I = T[0])), a.current = I, T.length <= 2 && (_.push(...T), T.length = 0), { itemsInPanel: _, itemsInDropdown: T, dropdownFirstItem: I };
  }, [c, y, r]);
  return /* @__PURE__ */ E.jsx("div", { className: "tlui-toolbar", children: /* @__PURE__ */ E.jsxs("div", { className: "tlui-toolbar__inner", children: [
    /* @__PURE__ */ E.jsxs("div", { className: "tlui-toolbar__left", children: [
      !s && /* @__PURE__ */ E.jsxs("div", { className: "tlui-toolbar__extras", children: [
        r < 5 && /* @__PURE__ */ E.jsxs("div", { className: "tlui-toolbar__extras__controls", children: [
          /* @__PURE__ */ E.jsx(C5, {}),
          /* @__PURE__ */ E.jsx(x5, {}),
          /* @__PURE__ */ E.jsx(E5, {}),
          /* @__PURE__ */ E.jsx(w5, {}),
          /* @__PURE__ */ E.jsx(S5, {})
        ] }),
        /* @__PURE__ */ E.jsx(ade, { activeToolId: f })
      ] }),
      /* @__PURE__ */ E.jsxs(
        "div",
        {
          className: $n("tlui-toolbar__tools", {
            "tlui-toolbar__tools__mobile": r < 5
          }),
          children: [
            c.slice(0, 2).map(({ toolItem: _ }) => /* @__PURE__ */ E.jsx(
              tx,
              {
                item: _,
                title: g(_),
                isSelected: Oy(_, f, p)
              },
              _.id
            )),
            !s && /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
              /* @__PURE__ */ E.jsx("div", { className: "tlui-toolbar__divider" }),
              c.slice(2, 4).map(({ toolItem: _ }) => /* @__PURE__ */ E.jsx(
                tx,
                {
                  item: _,
                  title: g(_),
                  isSelected: Oy(_, f, p)
                },
                _.id
              )),
              /* @__PURE__ */ E.jsx("div", { className: "tlui-toolbar__divider" }),
              v.map(({ toolItem: _ }) => /* @__PURE__ */ E.jsx(
                tx,
                {
                  item: _,
                  title: g(_),
                  isSelected: Oy(_, f, p)
                },
                _.id
              )),
              S.length ? /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
                /* @__PURE__ */ E.jsx(
                  tx,
                  {
                    item: x.toolItem,
                    title: g(x.toolItem),
                    isSelected: Oy(
                      x.toolItem,
                      f,
                      p
                    )
                  },
                  x.toolItem.id
                ),
                /* @__PURE__ */ E.jsxs(of, { id: "toolbar overflow", modal: !1, children: [
                  /* @__PURE__ */ E.jsx($b, { children: /* @__PURE__ */ E.jsx(
                    At,
                    {
                      className: "tlui-toolbar__tools__button tlui-toolbar__overflow",
                      icon: "chevron-up",
                      "data-wd": "tools.more"
                    }
                  ) }),
                  /* @__PURE__ */ E.jsx(af, { side: "top", align: "center", children: /* @__PURE__ */ E.jsx(lde, { toolbarItems: S }) })
                ] })
              ] }) : null
            ] })
          ]
        }
      )
    ] }),
    r < 5 && !s && /* @__PURE__ */ E.jsx("div", { className: "tlui-toolbar__tools", children: /* @__PURE__ */ E.jsx(ode, {}) })
  ] }) });
}), lde = dn(function({
  toolbarItems: e
}) {
  const n = Fn();
  return /* @__PURE__ */ E.jsx("div", { className: "tlui-button-grid__four tlui-button-grid__reverse", children: e.map(({ toolItem: { id: r, meta: a, kbd: s, label: c, onSelect: f, icon: p } }) => /* @__PURE__ */ E.jsx(
    Ko,
    {
      className: "tlui-button-grid__button",
      "data-wd": `tools.${r}`,
      "data-tool": r,
      "data-geo": a?.geo ?? "",
      "aria-label": c,
      onClick: f,
      title: c ? `${n(c)} ${s ? Ic(s) : ""}` : "",
      icon: p
    },
    r
  )) });
});
function tx({
  item: t,
  title: e,
  isSelected: n
}) {
  return /* @__PURE__ */ E.jsx(
    At,
    {
      className: "tlui-toolbar__tools__button",
      "data-wd": `tools.${t.id}`,
      "data-tool": t.id,
      "data-geo": t.meta?.geo ?? "",
      "aria-label": t.label,
      title: e,
      icon: t.icon,
      "data-state": n ? "selected" : void 0,
      onClick: t.onSelect,
      onTouchStart: (r) => {
        r.preventDefault(), t.onSelect();
      }
    },
    t.id
  );
}
const _5 = [
  "align-bottom",
  "align-center-horizontal",
  "align-center-vertical",
  "align-left",
  "align-right",
  "align-top",
  "arrow-left",
  "arrowhead-arrow",
  "arrowhead-bar",
  "arrowhead-diamond",
  "arrowhead-dot",
  "arrowhead-none",
  "arrowhead-square",
  "arrowhead-triangle-inverted",
  "arrowhead-triangle",
  "aspect-ratio",
  "avatar",
  "blob",
  "bring-forward",
  "bring-to-front",
  "check",
  "checkbox-checked",
  "checkbox-empty",
  "chevron-down",
  "chevron-left",
  "chevron-right",
  "chevron-up",
  "chevrons-ne",
  "chevrons-sw",
  "clipboard-copy",
  "code",
  "collab",
  "color",
  "comment",
  "cross-2",
  "cross",
  "dash-dashed",
  "dash-dotted",
  "dash-draw",
  "dash-solid",
  "discord",
  "distribute-horizontal",
  "distribute-vertical",
  "dot",
  "dots-horizontal",
  "dots-vertical",
  "drag-handle-dots",
  "duplicate",
  "edit",
  "external-link",
  "file",
  "fill-none",
  "fill-pattern",
  "fill-semi",
  "fill-solid",
  "font-draw",
  "font-mono",
  "font-sans",
  "font-serif",
  "geo-arrow-down",
  "geo-arrow-left",
  "geo-arrow-right",
  "geo-arrow-up",
  "geo-diamond",
  "geo-ellipse",
  "geo-hexagon",
  "geo-octagon",
  "geo-oval",
  "geo-pentagon",
  "geo-rectangle",
  "geo-rhombus-2",
  "geo-rhombus",
  "geo-star",
  "geo-trapezoid",
  "geo-triangle",
  "geo-x-box",
  "github",
  "group",
  "hidden",
  "image",
  "info-circle",
  "link",
  "lock-small",
  "lock",
  "menu",
  "minus",
  "mixed",
  "pack",
  "page",
  "plus",
  "question-mark-circle",
  "question-mark",
  "redo",
  "reset-zoom",
  "rotate-ccw",
  "rotate-cw",
  "ruler",
  "search",
  "send-backward",
  "send-to-back",
  "settings-horizontal",
  "settings-vertical-1",
  "settings-vertical",
  "share-1",
  "share-2",
  "size-extra-large",
  "size-large",
  "size-medium",
  "size-small",
  "spline-cubic",
  "spline-line",
  "stack-horizontal",
  "stack-vertical",
  "stretch-horizontal",
  "stretch-vertical",
  "text-align-center",
  "text-align-justify",
  "text-align-left",
  "text-align-right",
  "tool-arrow",
  "tool-embed",
  "tool-eraser",
  "tool-frame",
  "tool-hand",
  "tool-highlighter",
  "tool-line",
  "tool-media",
  "tool-note",
  "tool-pencil",
  "tool-pointer",
  "tool-text",
  "trash",
  "triangle-down",
  "triangle-up",
  "twitter",
  "undo",
  "ungroup",
  "unlock-small",
  "unlock",
  "visible",
  "warning-triangle",
  "zoom-in",
  "zoom-out"
];
function cde() {
  const [t, e] = k.useState(!1), n = U1();
  return k.useEffect(() => {
    let r = !1;
    async function a() {
      await Promise.allSettled(
        _5.map((s) => {
          const c = new Image();
          return c.src = n.icons[s], c.decode();
        })
      ), !r && e(!0);
    }
    return a(), () => {
      r = !0;
    };
  }, [t, n]), t;
}
const ude = {
  ...Dj,
  icons: Object.fromEntries(
    _5.map((t) => [t, `/icons/icon/${t}.svg`])
  ),
  translations: Object.fromEntries(
    E2.map((t) => [t.locale, `/translations/${t.locale}.json`])
  ),
  embedIcons: Object.fromEntries(
    Jg.map((t) => [t.type, `/embed-icons/${t.type}.png`])
  )
};
function dde() {
  const { addToast: t, removeToast: e, clearToasts: n } = Hu(), { addDialog: r, clearDialogs: a, removeDialog: s, updateDialog: c } = Vp(), p = qs() < 5, g = Fn();
  return k.useMemo(
    () => ({
      addToast: t,
      removeToast: e,
      clearToasts: n,
      addDialog: r,
      clearDialogs: a,
      removeDialog: s,
      updateDialog: c,
      msg: g,
      isMobile: p
    }),
    [
      r,
      t,
      a,
      n,
      g,
      s,
      e,
      c,
      p
    ]
  );
}
function fde(t, e) {
  const n = {};
  for (const r of t)
    if (r.translations)
      for (const [a, s] of aL(r.translations)) {
        let c = n[a];
        c || (c = n[a] = {}), Object.assign(c, s);
      }
  return {
    actionsMenu: (r, a, s) => {
      for (const c of t)
        c.actionsMenu && (a = c.actionsMenu(r, a, { ...e, ...s }));
      return a;
    },
    actions: (r, a) => {
      for (const s of t)
        s.actions && (a = s.actions(r, a, e));
      return a;
    },
    contextMenu: (r, a, s) => {
      for (const c of t)
        c.contextMenu && (a = c.contextMenu(r, a, { ...e, ...s }));
      return a;
    },
    helpMenu: (r, a, s) => {
      for (const c of t)
        c.helpMenu && (a = c.helpMenu(r, a, { ...e, ...s }));
      return a;
    },
    menu: (r, a, s) => {
      for (const c of t)
        c.menu && (a = c.menu(r, a, { ...e, ...s }));
      return a;
    },
    toolbar: (r, a, s) => {
      for (const c of t)
        c.toolbar && (a = c.toolbar(r, a, { ...e, ...s }));
      return a;
    },
    keyboardShortcutsMenu: (r, a, s) => {
      for (const c of t)
        c.keyboardShortcutsMenu && (a = c.keyboardShortcutsMenu(r, a, { ...e, ...s }));
      return a;
    },
    tools: (r, a, s) => {
      for (const c of t)
        c.tools && (a = c.tools(r, a, { ...e, ...s }));
      return a;
    },
    translations: n
  };
}
function T5(t) {
  return k.useMemo(() => t, t);
}
function pde(t) {
  const e = T5(
    t == null ? [] : Array.isArray(t) ? t : [t]
  );
  return k.useMemo(() => {
    const n = {};
    for (const r of e)
      if (r.translations)
        for (const [a, s] of aL(r.translations)) {
          let c = n[a];
          c || (c = n[a] = {}), Object.assign(c, s);
        }
    return n;
  }, [e]);
}
function hde(t) {
  const e = dde(), n = T5(
    t == null ? [] : Array.isArray(t) ? t : [t]
  );
  return k.useMemo(
    () => fde(n, e),
    [n, e]
  );
}
function gde({
  overrides: t,
  assetUrls: e,
  children: n
}) {
  return /* @__PURE__ */ E.jsx(yce, { assetUrls: e ?? ude, children: /* @__PURE__ */ E.jsx(Sce, { overrides: pde(t), children: /* @__PURE__ */ E.jsx(gce, { children: /* @__PURE__ */ E.jsx(Cce, { children: /* @__PURE__ */ E.jsx(Rce, { children: /* @__PURE__ */ E.jsx(mde, { overrides: t, children: n }) }) }) }) }) });
}
function mde({
  overrides: t,
  children: e
}) {
  const n = hde(t);
  return /* @__PURE__ */ E.jsx(Pce, { overrides: n.actions, children: /* @__PURE__ */ E.jsx(eue, { overrides: n.tools, children: /* @__PURE__ */ E.jsx(lue, { overrides: n.toolbar, children: /* @__PURE__ */ E.jsx($ce, { overrides: n.actionsMenu, children: /* @__PURE__ */ E.jsx(rue, { overrides: n.keyboardShortcutsMenu, children: /* @__PURE__ */ E.jsx(Nce, { overrides: n.contextMenu, children: /* @__PURE__ */ E.jsx(jce, { overrides: n.helpMenu, children: /* @__PURE__ */ E.jsx(aue, { overrides: n.menu, children: e }) }) }) }) }) }) }) });
}
const vde = It.memo(function({
  shareZone: e,
  renderDebugMenuItems: n,
  children: r,
  ...a
}) {
  return /* @__PURE__ */ E.jsx(gde, { ...a, children: /* @__PURE__ */ E.jsx(yde, { shareZone: e, renderDebugMenuItems: n, children: r }) });
}), yde = It.memo(function({
  children: e,
  ...n
}) {
  return cde() ? /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    e,
    /* @__PURE__ */ E.jsx(bde, { ...n })
  ] }) : /* @__PURE__ */ E.jsx(pP, { children: "Loading assets..." });
}), bde = It.memo(function({
  shareZone: e,
  renderDebugMenuItems: n
}) {
  const r = Ge(), a = Fn(), s = qs(), c = un("isReadOnlyMode", () => r.isReadOnly, []), f = un("isFocusMode", () => r.instanceState.isFocusMode, []), p = un("isDebugMode", () => r.instanceState.isDebugMode, []);
  nue(), hce(), Ace();
  const { "toggle-focus-mode": g } = ba();
  return /* @__PURE__ */ E.jsx(qj, { children: /* @__PURE__ */ E.jsx(
    "main",
    {
      "data-wd": "desktop-ui",
      className: $n("tlui-layout", { "tlui-layout__mobile": s < 5 }),
      children: f ? /* @__PURE__ */ E.jsx("div", { className: "tlui-layout__top", children: /* @__PURE__ */ E.jsx(
        At,
        {
          className: "tlui-focus-button",
          title: `${a("focus-mode.toggle-focus-mode")}`,
          icon: "dot",
          onClick: g.onSelect
        }
      ) }) : /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
        /* @__PURE__ */ E.jsxs("div", { className: "tlui-layout__top", children: [
          /* @__PURE__ */ E.jsx(ede, {}),
          /* @__PURE__ */ E.jsx("div", { className: "tlui-spacer" }),
          /* @__PURE__ */ E.jsx("div", { className: "tlui-share-zone", draggable: !1, children: e })
        ] }),
        /* @__PURE__ */ E.jsxs(
          "div",
          {
            className: "tlui-layout__middle",
            "data-wd": "active-area",
            "data-tldraw-area": "active-drawing",
            children: [
              /* @__PURE__ */ E.jsxs("div", { className: "tlui-helper-buttons", children: [
                /* @__PURE__ */ E.jsx(Lue, {}),
                /* @__PURE__ */ E.jsx(Aue, {})
              ] }),
              s >= 5 && !c && /* @__PURE__ */ E.jsx("div", { className: "tlui-style-panel__wrapper", children: /* @__PURE__ */ E.jsx(d5, {}) })
            ]
          }
        ),
        /* @__PURE__ */ E.jsxs("div", { className: "tlui-layout__bottom", children: [
          /* @__PURE__ */ E.jsxs("div", { className: "tlui-layout__bottom__main", children: [
            /* @__PURE__ */ E.jsx(Tue, {}),
            /* @__PURE__ */ E.jsx(sde, {}),
            s >= 4 && /* @__PURE__ */ E.jsx(Sue, {})
          ] }),
          p && /* @__PURE__ */ E.jsx(hue, { renderDebugMenuItems: n ?? null })
        ] }),
        /* @__PURE__ */ E.jsx(rde, {}),
        /* @__PURE__ */ E.jsx(Nue, {}),
        /* @__PURE__ */ E.jsx(ide, {})
      ] })
    }
  ) });
});
const me = (t) => `modules/${Nu}/${t}`, Sde = () => ({
  fonts: {
    monospace: me("fonts/IBMPlexMono-Medium.woff2"),
    sansSerif: me("fonts/IBMPlexSans-Medium.woff2"),
    serif: me("fonts/IBMPlexSerif-Medium.woff2"),
    draw: me("fonts/Shantell_Sans-Normal-SemiBold.woff2")
  }
}), wde = () => ({
  icons: {
    "align-bottom-center": me("icons/align-bottom-center.svg"),
    "align-bottom-left": me("icons/align-bottom-left.svg"),
    "align-bottom-right": me("icons/align-bottom-right.svg"),
    "align-bottom": me("icons/align-bottom.svg"),
    "align-center-center": me("icons/align-center-center.svg"),
    "align-center-horizontal": me("icons/align-center-horizontal.svg"),
    "align-center-left": me("icons/align-center-left.svg"),
    "align-center-right": me("icons/align-center-right.svg"),
    "align-center-vertical": me("icons/align-center-vertical.svg"),
    "align-left": me("icons/align-left.svg"),
    "align-right": me("icons/align-right.svg"),
    "align-top-center": me("icons/align-top-center.svg"),
    "align-top-left": me("icons/align-top-left.svg"),
    "align-top-right": me("icons/align-top-right.svg"),
    "align-top": me("icons/align-top.svg"),
    "arrow-left": me("icons/arrow-left.svg"),
    "arrowhead-arrow": me("icons/arrowhead-arrow.svg"),
    "arrowhead-bar": me("icons/arrowhead-bar.svg"),
    "arrowhead-diamond": me("icons/arrowhead-diamond.svg"),
    "arrowhead-dot": me("icons/arrowhead-dot.svg"),
    "arrowhead-none": me("icons/arrowhead-none.svg"),
    "arrowhead-square": me("icons/arrowhead-square.svg"),
    "arrowhead-triangle-inverted": me("icons/arrowhead-triangle-inverted.svg"),
    "arrowhead-triangle": me("icons/arrowhead-triangle.svg"),
    "aspect-ratio": me("icons/aspect-ratio.svg"),
    avatar: me("icons/avatar.svg"),
    blob: me("icons/blob.svg"),
    "bring-forward": me("icons/bring-forward.svg"),
    "bring-to-front": me("icons/bring-to-front.svg"),
    check: me("icons/check.svg"),
    "checkbox-checked": me("icons/checkbox-checked.svg"),
    "checkbox-empty": me("icons/checkbox-empty.svg"),
    "chevron-down": me("icons/chevron-down.svg"),
    "chevron-left": me("icons/chevron-left.svg"),
    "chevron-right": me("icons/chevron-right.svg"),
    "chevron-up": me("icons/chevron-up.svg"),
    "chevrons-ne": me("icons/chevrons-ne.svg"),
    "chevrons-sw": me("icons/chevrons-sw.svg"),
    "clipboard-copied": me("icons/clipboard-copied.svg"),
    "clipboard-copy": me("icons/clipboard-copy.svg"),
    code: me("icons/code.svg"),
    collab: me("icons/collab.svg"),
    color: me("icons/color.svg"),
    comment: me("icons/comment.svg"),
    "cross-2": me("icons/cross-2.svg"),
    cross: me("icons/cross.svg"),
    "dash-dashed": me("icons/dash-dashed.svg"),
    "dash-dotted": me("icons/dash-dotted.svg"),
    "dash-draw": me("icons/dash-draw.svg"),
    "dash-solid": me("icons/dash-solid.svg"),
    discord: me("icons/discord.svg"),
    "distribute-horizontal": me("icons/distribute-horizontal.svg"),
    "distribute-vertical": me("icons/distribute-vertical.svg"),
    dot: me("icons/dot.svg"),
    "dots-horizontal": me("icons/dots-horizontal.svg"),
    "dots-vertical": me("icons/dots-vertical.svg"),
    "drag-handle-dots": me("icons/drag-handle-dots.svg"),
    duplicate: me("icons/duplicate.svg"),
    edit: me("icons/edit.svg"),
    "external-link": me("icons/external-link.svg"),
    file: me("icons/file.svg"),
    "fill-none": me("icons/fill-none.svg"),
    "fill-pattern": me("icons/fill-pattern.svg"),
    "fill-semi": me("icons/fill-semi.svg"),
    "fill-solid": me("icons/fill-solid.svg"),
    follow: me("icons/follow.svg"),
    following: me("icons/following.svg"),
    "font-draw": me("icons/font-draw.svg"),
    "font-mono": me("icons/font-mono.svg"),
    "font-sans": me("icons/font-sans.svg"),
    "font-serif": me("icons/font-serif.svg"),
    "geo-arrow-down": me("icons/geo-arrow-down.svg"),
    "geo-arrow-left": me("icons/geo-arrow-left.svg"),
    "geo-arrow-right": me("icons/geo-arrow-right.svg"),
    "geo-arrow-up": me("icons/geo-arrow-up.svg"),
    "geo-check-box": me("icons/geo-check-box.svg"),
    "geo-diamond": me("icons/geo-diamond.svg"),
    "geo-ellipse": me("icons/geo-ellipse.svg"),
    "geo-hexagon": me("icons/geo-hexagon.svg"),
    "geo-octagon": me("icons/geo-octagon.svg"),
    "geo-oval": me("icons/geo-oval.svg"),
    "geo-pentagon": me("icons/geo-pentagon.svg"),
    "geo-rectangle": me("icons/geo-rectangle.svg"),
    "geo-rhombus-2": me("icons/geo-rhombus-2.svg"),
    "geo-rhombus": me("icons/geo-rhombus.svg"),
    "geo-star": me("icons/geo-star.svg"),
    "geo-trapezoid": me("icons/geo-trapezoid.svg"),
    "geo-triangle": me("icons/geo-triangle.svg"),
    "geo-x-box": me("icons/geo-x-box.svg"),
    github: me("icons/github.svg"),
    group: me("icons/group.svg"),
    hidden: me("icons/hidden.svg"),
    image: me("icons/image.svg"),
    "info-circle": me("icons/info-circle.svg"),
    leading: me("icons/leading.svg"),
    link: me("icons/link.svg"),
    "lock-small": me("icons/lock-small.svg"),
    lock: me("icons/lock.svg"),
    menu: me("icons/menu.svg"),
    minus: me("icons/minus.svg"),
    mixed: me("icons/mixed.svg"),
    pack: me("icons/pack.svg"),
    page: me("icons/page.svg"),
    plus: me("icons/plus.svg"),
    "question-mark-circle": me("icons/question-mark-circle.svg"),
    "question-mark": me("icons/question-mark.svg"),
    redo: me("icons/redo.svg"),
    "reset-zoom": me("icons/reset-zoom.svg"),
    "rotate-ccw": me("icons/rotate-ccw.svg"),
    "rotate-cw": me("icons/rotate-cw.svg"),
    ruler: me("icons/ruler.svg"),
    search: me("icons/search.svg"),
    "send-backward": me("icons/send-backward.svg"),
    "send-to-back": me("icons/send-to-back.svg"),
    "settings-horizontal": me("icons/settings-horizontal.svg"),
    "settings-vertical-1": me("icons/settings-vertical-1.svg"),
    "settings-vertical": me("icons/settings-vertical.svg"),
    "share-1": me("icons/share-1.svg"),
    "share-2": me("icons/share-2.svg"),
    "size-extra-large": me("icons/size-extra-large.svg"),
    "size-large": me("icons/size-large.svg"),
    "size-medium": me("icons/size-medium.svg"),
    "size-small": me("icons/size-small.svg"),
    "spline-cubic": me("icons/spline-cubic.svg"),
    "spline-line": me("icons/spline-line.svg"),
    "stack-horizontal": me("icons/stack-horizontal.svg"),
    "stack-vertical": me("icons/stack-vertical.svg"),
    "stretch-horizontal": me("icons/stretch-horizontal.svg"),
    "stretch-vertical": me("icons/stretch-vertical.svg"),
    "text-align-center": me("icons/text-align-center.svg"),
    "text-align-justify": me("icons/text-align-justify.svg"),
    "text-align-left": me("icons/text-align-left.svg"),
    "text-align-right": me("icons/text-align-right.svg"),
    "tool-arrow": me("icons/tool-arrow.svg"),
    "tool-embed": me("icons/tool-embed.svg"),
    "tool-eraser": me("icons/tool-eraser.svg"),
    "tool-frame": me("icons/tool-frame.svg"),
    "tool-hand": me("icons/tool-hand.svg"),
    "tool-highlighter": me("icons/tool-highlighter.svg"),
    "tool-laser": me("icons/tool-laser.svg"),
    "tool-line": me("icons/tool-line.svg"),
    "tool-media": me("icons/tool-media.svg"),
    "tool-note": me("icons/tool-note.svg"),
    "tool-pencil": me("icons/tool-pencil.svg"),
    "tool-pointer": me("icons/tool-pointer.svg"),
    "tool-text": me("icons/tool-text.svg"),
    trash: me("icons/trash.svg"),
    "triangle-down": me("icons/triangle-down.svg"),
    "triangle-up": me("icons/triangle-up.svg"),
    twitter: me("icons/twitter.svg"),
    undo: me("icons/undo.svg"),
    ungroup: me("icons/ungroup.svg"),
    "unlock-small": me("icons/unlock-small.svg"),
    unlock: me("icons/unlock.svg"),
    "vertical-align-center": me("icons/vertical-align-center.svg"),
    "vertical-align-end": me("icons/vertical-align-end.svg"),
    "vertical-align-start": me("icons/vertical-align-start.svg"),
    visible: me("icons/visible.svg"),
    "warning-triangle": me("icons/warning-triangle.svg"),
    "zoom-in": me("icons/zoom-in.svg"),
    "zoom-out": me("icons/zoom-out.svg")
  },
  translations: {
    en: me("lang/tldraw-en.json")
  }
}), xde = async (t) => {
  const e = await (await fetch(t)).blob();
  return new File([e], t, {
    lastModified: (/* @__PURE__ */ new Date()).getTime(),
    type: e.type
  });
}, Ede = async (t) => {
  new FilePicker({
    type: "imagevideo",
    displayMode: "tiles",
    async callback(n) {
      g1(t, [await xde(n)], t.viewportPageBounds.center, !1);
    }
  }).render();
}, Cde = {
  contextMenu: (t, e, n) => (Tde(e), _de(e), kde(t, e, n), Pde(t, e), e),
  toolbar(t, e, n) {
    e.splice(
      e.findIndex((a) => a.id === "embed"),
      1
    );
    const r = e.findIndex((a) => a.id === "asset");
    return e[r] = {
      ...e[r],
      toolItem: {
        ...e[r].toolItem,
        onSelect: async () => {
          await Ede(t);
        }
      }
    }, e;
  }
};
function _de(t) {
  const e = t.find((n) => n.id === "modify");
  e && e.children.splice(
    e.children.findIndex((n) => n.id === "MOVE_TO_PAGE_MENU"),
    1
  );
}
function Tde(t) {
  t.splice(
    t.findIndex((e) => e.id === "conversions"),
    1
  );
}
function kde(t, e, n) {
  n.oneSelected || e.push({
    id: "preferences-group",
    type: "group",
    checkbox: !1,
    disabled: !1,
    readonlyOk: !0,
    children: [
      {
        id: "toggle-grid",
        type: "item",
        actionItem: {
          id: "action.toggle-grid",
          label: "action.toggle-grid.menu",
          kbd: "$'",
          readonlyOk: !0,
          onSelect: () => {
            t.setGridMode(!t.isGridMode);
          }
        },
        checked: !0,
        readonlyOk: !0,
        disabled: !1
      }
    ]
  });
}
function Pde(t, e, n) {
  const r = t.selectedShapes, a = r?.[0];
  if (!a || r.length !== 1)
    return;
  const s = t.getShapeUtil(a);
  s.getContextMenuItems && e.unshift(s.getContextMenuItems(a));
}
var LP = { exports: {} }, tr = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var UN;
function Ide() {
  if (UN)
    return tr;
  UN = 1;
  var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), c = Symbol.for("react.context"), f = Symbol.for("react.server_context"), p = Symbol.for("react.forward_ref"), g = Symbol.for("react.suspense"), y = Symbol.for("react.suspense_list"), v = Symbol.for("react.memo"), S = Symbol.for("react.lazy"), x = Symbol.for("react.offscreen"), _;
  _ = Symbol.for("react.module.reference");
  function T(I) {
    if (typeof I == "object" && I !== null) {
      var D = I.$$typeof;
      switch (D) {
        case t:
          switch (I = I.type, I) {
            case n:
            case a:
            case r:
            case g:
            case y:
              return I;
            default:
              switch (I = I && I.$$typeof, I) {
                case f:
                case c:
                case p:
                case S:
                case v:
                case s:
                  return I;
                default:
                  return D;
              }
          }
        case e:
          return D;
      }
    }
  }
  return tr.ContextConsumer = c, tr.ContextProvider = s, tr.Element = t, tr.ForwardRef = p, tr.Fragment = n, tr.Lazy = S, tr.Memo = v, tr.Portal = e, tr.Profiler = a, tr.StrictMode = r, tr.Suspense = g, tr.SuspenseList = y, tr.isAsyncMode = function() {
    return !1;
  }, tr.isConcurrentMode = function() {
    return !1;
  }, tr.isContextConsumer = function(I) {
    return T(I) === c;
  }, tr.isContextProvider = function(I) {
    return T(I) === s;
  }, tr.isElement = function(I) {
    return typeof I == "object" && I !== null && I.$$typeof === t;
  }, tr.isForwardRef = function(I) {
    return T(I) === p;
  }, tr.isFragment = function(I) {
    return T(I) === n;
  }, tr.isLazy = function(I) {
    return T(I) === S;
  }, tr.isMemo = function(I) {
    return T(I) === v;
  }, tr.isPortal = function(I) {
    return T(I) === e;
  }, tr.isProfiler = function(I) {
    return T(I) === a;
  }, tr.isStrictMode = function(I) {
    return T(I) === r;
  }, tr.isSuspense = function(I) {
    return T(I) === g;
  }, tr.isSuspenseList = function(I) {
    return T(I) === y;
  }, tr.isValidElementType = function(I) {
    return typeof I == "string" || typeof I == "function" || I === n || I === a || I === r || I === g || I === y || I === x || typeof I == "object" && I !== null && (I.$$typeof === S || I.$$typeof === v || I.$$typeof === s || I.$$typeof === c || I.$$typeof === p || I.$$typeof === _ || I.getModuleId !== void 0);
  }, tr.typeOf = T, tr;
}
var nr = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var BN;
function Rde() {
  return BN || (BN = 1, {}.NODE_ENV !== "production" && function() {
    var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), c = Symbol.for("react.context"), f = Symbol.for("react.server_context"), p = Symbol.for("react.forward_ref"), g = Symbol.for("react.suspense"), y = Symbol.for("react.suspense_list"), v = Symbol.for("react.memo"), S = Symbol.for("react.lazy"), x = Symbol.for("react.offscreen"), _ = !1, T = !1, I = !1, D = !1, N = !1, j;
    j = Symbol.for("react.module.reference");
    function L(Ke) {
      return !!(typeof Ke == "string" || typeof Ke == "function" || Ke === n || Ke === a || N || Ke === r || Ke === g || Ke === y || D || Ke === x || _ || T || I || typeof Ke == "object" && Ke !== null && (Ke.$$typeof === S || Ke.$$typeof === v || Ke.$$typeof === s || Ke.$$typeof === c || Ke.$$typeof === p || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Ke.$$typeof === j || Ke.getModuleId !== void 0));
    }
    function z(Ke) {
      if (typeof Ke == "object" && Ke !== null) {
        var yt = Ke.$$typeof;
        switch (yt) {
          case t:
            var Xt = Ke.type;
            switch (Xt) {
              case n:
              case a:
              case r:
              case g:
              case y:
                return Xt;
              default:
                var kt = Xt && Xt.$$typeof;
                switch (kt) {
                  case f:
                  case c:
                  case p:
                  case S:
                  case v:
                  case s:
                    return kt;
                  default:
                    return yt;
                }
            }
          case e:
            return yt;
        }
      }
    }
    var F = c, K = s, X = t, se = p, ue = n, pe = S, Pe = v, ve = e, Y = a, le = r, Re = g, he = y, te = !1, de = !1;
    function W(Ke) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function fe(Ke) {
      return de || (de = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function ce(Ke) {
      return z(Ke) === c;
    }
    function xe(Ke) {
      return z(Ke) === s;
    }
    function $e(Ke) {
      return typeof Ke == "object" && Ke !== null && Ke.$$typeof === t;
    }
    function Me(Ke) {
      return z(Ke) === p;
    }
    function re(Ke) {
      return z(Ke) === n;
    }
    function Qe(Ke) {
      return z(Ke) === S;
    }
    function ke(Ke) {
      return z(Ke) === v;
    }
    function rt(Ke) {
      return z(Ke) === e;
    }
    function St(Ke) {
      return z(Ke) === a;
    }
    function Tt(Ke) {
      return z(Ke) === r;
    }
    function Le(Ke) {
      return z(Ke) === g;
    }
    function Nt(Ke) {
      return z(Ke) === y;
    }
    nr.ContextConsumer = F, nr.ContextProvider = K, nr.Element = X, nr.ForwardRef = se, nr.Fragment = ue, nr.Lazy = pe, nr.Memo = Pe, nr.Portal = ve, nr.Profiler = Y, nr.StrictMode = le, nr.Suspense = Re, nr.SuspenseList = he, nr.isAsyncMode = W, nr.isConcurrentMode = fe, nr.isContextConsumer = ce, nr.isContextProvider = xe, nr.isElement = $e, nr.isForwardRef = Me, nr.isFragment = re, nr.isLazy = Qe, nr.isMemo = ke, nr.isPortal = rt, nr.isProfiler = St, nr.isStrictMode = Tt, nr.isSuspense = Le, nr.isSuspenseList = Nt, nr.isValidElementType = L, nr.typeOf = z;
  }()), nr;
}
({}).NODE_ENV === "production" ? LP.exports = Ide() : LP.exports = Rde();
var R2 = LP.exports;
function $de(t) {
  function e(ce, xe, $e, Me, re) {
    for (var Qe = 0, ke = 0, rt = 0, St = 0, Tt, Le, Nt = 0, Ke = 0, yt, Xt = yt = Tt = 0, kt = 0, yn = 0, Er = 0, tn = 0, Mr = $e.length, Ur = Mr - 1, Hn, xt = "", cn = "", ni = "", An = "", qn; kt < Mr; ) {
      if (Le = $e.charCodeAt(kt), kt === Ur && ke + St + rt + Qe !== 0 && (ke !== 0 && (Le = ke === 47 ? 10 : 47), St = rt = Qe = 0, Mr++, Ur++), ke + St + rt + Qe === 0) {
        if (kt === Ur && (0 < yn && (xt = xt.replace(S, "")), 0 < xt.trim().length)) {
          switch (Le) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;
            default:
              xt += $e.charAt(kt);
          }
          Le = 59;
        }
        switch (Le) {
          case 123:
            for (xt = xt.trim(), Tt = xt.charCodeAt(0), yt = 1, tn = ++kt; kt < Mr; ) {
              switch (Le = $e.charCodeAt(kt)) {
                case 123:
                  yt++;
                  break;
                case 125:
                  yt--;
                  break;
                case 47:
                  switch (Le = $e.charCodeAt(kt + 1)) {
                    case 42:
                    case 47:
                      e: {
                        for (Xt = kt + 1; Xt < Ur; ++Xt)
                          switch ($e.charCodeAt(Xt)) {
                            case 47:
                              if (Le === 42 && $e.charCodeAt(Xt - 1) === 42 && kt + 2 !== Xt) {
                                kt = Xt + 1;
                                break e;
                              }
                              break;
                            case 10:
                              if (Le === 47) {
                                kt = Xt + 1;
                                break e;
                              }
                          }
                        kt = Xt;
                      }
                  }
                  break;
                case 91:
                  Le++;
                case 40:
                  Le++;
                case 34:
                case 39:
                  for (; kt++ < Ur && $e.charCodeAt(kt) !== Le; )
                    ;
              }
              if (yt === 0)
                break;
              kt++;
            }
            switch (yt = $e.substring(tn, kt), Tt === 0 && (Tt = (xt = xt.replace(v, "").trim()).charCodeAt(0)), Tt) {
              case 64:
                switch (0 < yn && (xt = xt.replace(S, "")), Le = xt.charCodeAt(1), Le) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    yn = xe;
                    break;
                  default:
                    yn = Re;
                }
                if (yt = e(xe, yn, yt, Le, re + 1), tn = yt.length, 0 < te && (yn = n(Re, xt, Er), qn = f(3, yt, yn, xe, ve, Pe, tn, Le, re, Me), xt = yn.join(""), qn !== void 0 && (tn = (yt = qn.trim()).length) === 0 && (Le = 0, yt = "")), 0 < tn)
                  switch (Le) {
                    case 115:
                      xt = xt.replace(F, c);
                    case 100:
                    case 109:
                    case 45:
                      yt = xt + "{" + yt + "}";
                      break;
                    case 107:
                      xt = xt.replace(N, "$1 $2"), yt = xt + "{" + yt + "}", yt = le === 1 || le === 2 && s("@" + yt, 3) ? "@-webkit-" + yt + "@" + yt : "@" + yt;
                      break;
                    default:
                      yt = xt + yt, Me === 112 && (yt = (cn += yt, ""));
                  }
                else
                  yt = "";
                break;
              default:
                yt = e(xe, n(xe, xt, Er), yt, Me, re + 1);
            }
            ni += yt, yt = Er = yn = Xt = Tt = 0, xt = "", Le = $e.charCodeAt(++kt);
            break;
          case 125:
          case 59:
            if (xt = (0 < yn ? xt.replace(S, "") : xt).trim(), 1 < (tn = xt.length))
              switch (Xt === 0 && (Tt = xt.charCodeAt(0), Tt === 45 || 96 < Tt && 123 > Tt) && (tn = (xt = xt.replace(" ", ":")).length), 0 < te && (qn = f(1, xt, xe, ce, ve, Pe, cn.length, Me, re, Me)) !== void 0 && (tn = (xt = qn.trim()).length) === 0 && (xt = "\0\0"), Tt = xt.charCodeAt(0), Le = xt.charCodeAt(1), Tt) {
                case 0:
                  break;
                case 64:
                  if (Le === 105 || Le === 99) {
                    An += xt + $e.charAt(kt);
                    break;
                  }
                default:
                  xt.charCodeAt(tn - 1) !== 58 && (cn += a(xt, Tt, Le, xt.charCodeAt(2)));
              }
            Er = yn = Xt = Tt = 0, xt = "", Le = $e.charCodeAt(++kt);
        }
      }
      switch (Le) {
        case 13:
        case 10:
          ke === 47 ? ke = 0 : 1 + Tt === 0 && Me !== 107 && 0 < xt.length && (yn = 1, xt += "\0"), 0 < te * W && f(0, xt, xe, ce, ve, Pe, cn.length, Me, re, Me), Pe = 1, ve++;
          break;
        case 59:
        case 125:
          if (ke + St + rt + Qe === 0) {
            Pe++;
            break;
          }
        default:
          switch (Pe++, Hn = $e.charAt(kt), Le) {
            case 9:
            case 32:
              if (St + Qe + ke === 0)
                switch (Nt) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    Hn = "";
                    break;
                  default:
                    Le !== 32 && (Hn = " ");
                }
              break;
            case 0:
              Hn = "\\0";
              break;
            case 12:
              Hn = "\\f";
              break;
            case 11:
              Hn = "\\v";
              break;
            case 38:
              St + ke + Qe === 0 && (yn = Er = 1, Hn = "\f" + Hn);
              break;
            case 108:
              if (St + ke + Qe + Y === 0 && 0 < Xt)
                switch (kt - Xt) {
                  case 2:
                    Nt === 112 && $e.charCodeAt(kt - 3) === 58 && (Y = Nt);
                  case 8:
                    Ke === 111 && (Y = Ke);
                }
              break;
            case 58:
              St + ke + Qe === 0 && (Xt = kt);
              break;
            case 44:
              ke + rt + St + Qe === 0 && (yn = 1, Hn += "\r");
              break;
            case 34:
            case 39:
              ke === 0 && (St = St === Le ? 0 : St === 0 ? Le : St);
              break;
            case 91:
              St + ke + rt === 0 && Qe++;
              break;
            case 93:
              St + ke + rt === 0 && Qe--;
              break;
            case 41:
              St + ke + Qe === 0 && rt--;
              break;
            case 40:
              if (St + ke + Qe === 0) {
                if (Tt === 0)
                  switch (2 * Nt + 3 * Ke) {
                    case 533:
                      break;
                    default:
                      Tt = 1;
                  }
                rt++;
              }
              break;
            case 64:
              ke + rt + St + Qe + Xt + yt === 0 && (yt = 1);
              break;
            case 42:
            case 47:
              if (!(0 < St + Qe + rt))
                switch (ke) {
                  case 0:
                    switch (2 * Le + 3 * $e.charCodeAt(kt + 1)) {
                      case 235:
                        ke = 47;
                        break;
                      case 220:
                        tn = kt, ke = 42;
                    }
                    break;
                  case 42:
                    Le === 47 && Nt === 42 && tn + 2 !== kt && ($e.charCodeAt(tn + 2) === 33 && (cn += $e.substring(tn, kt + 1)), Hn = "", ke = 0);
                }
          }
          ke === 0 && (xt += Hn);
      }
      Ke = Nt, Nt = Le, kt++;
    }
    if (tn = cn.length, 0 < tn) {
      if (yn = xe, 0 < te && (qn = f(2, cn, yn, ce, ve, Pe, tn, Me, re, Me), qn !== void 0 && (cn = qn).length === 0))
        return An + cn + ni;
      if (cn = yn.join(",") + "{" + cn + "}", le * Y !== 0) {
        switch (le !== 2 || s(cn, 2) || (Y = 0), Y) {
          case 111:
            cn = cn.replace(L, ":-moz-$1") + cn;
            break;
          case 112:
            cn = cn.replace(j, "::-webkit-input-$1") + cn.replace(j, "::-moz-$1") + cn.replace(j, ":-ms-input-$1") + cn;
        }
        Y = 0;
      }
    }
    return An + cn + ni;
  }
  function n(ce, xe, $e) {
    var Me = xe.trim().split(I);
    xe = Me;
    var re = Me.length, Qe = ce.length;
    switch (Qe) {
      case 0:
      case 1:
        var ke = 0;
        for (ce = Qe === 0 ? "" : ce[0] + " "; ke < re; ++ke)
          xe[ke] = r(ce, xe[ke], $e).trim();
        break;
      default:
        var rt = ke = 0;
        for (xe = []; ke < re; ++ke)
          for (var St = 0; St < Qe; ++St)
            xe[rt++] = r(ce[St] + " ", Me[ke], $e).trim();
    }
    return xe;
  }
  function r(ce, xe, $e) {
    var Me = xe.charCodeAt(0);
    switch (33 > Me && (Me = (xe = xe.trim()).charCodeAt(0)), Me) {
      case 38:
        return xe.replace(D, "$1" + ce.trim());
      case 58:
        return ce.trim() + xe.replace(D, "$1" + ce.trim());
      default:
        if (0 < 1 * $e && 0 < xe.indexOf("\f"))
          return xe.replace(D, (ce.charCodeAt(0) === 58 ? "" : "$1") + ce.trim());
    }
    return ce + xe;
  }
  function a(ce, xe, $e, Me) {
    var re = ce + ";", Qe = 2 * xe + 3 * $e + 4 * Me;
    if (Qe === 944) {
      ce = re.indexOf(":", 9) + 1;
      var ke = re.substring(ce, re.length - 1).trim();
      return ke = re.substring(0, ce).trim() + ke + ";", le === 1 || le === 2 && s(ke, 1) ? "-webkit-" + ke + ke : ke;
    }
    if (le === 0 || le === 2 && !s(re, 1))
      return re;
    switch (Qe) {
      case 1015:
        return re.charCodeAt(10) === 97 ? "-webkit-" + re + re : re;
      case 951:
        return re.charCodeAt(3) === 116 ? "-webkit-" + re + re : re;
      case 963:
        return re.charCodeAt(5) === 110 ? "-webkit-" + re + re : re;
      case 1009:
        if (re.charCodeAt(4) !== 100)
          break;
      case 969:
      case 942:
        return "-webkit-" + re + re;
      case 978:
        return "-webkit-" + re + "-moz-" + re + re;
      case 1019:
      case 983:
        return "-webkit-" + re + "-moz-" + re + "-ms-" + re + re;
      case 883:
        if (re.charCodeAt(8) === 45)
          return "-webkit-" + re + re;
        if (0 < re.indexOf("image-set(", 11))
          return re.replace(pe, "$1-webkit-$2") + re;
        break;
      case 932:
        if (re.charCodeAt(4) === 45)
          switch (re.charCodeAt(5)) {
            case 103:
              return "-webkit-box-" + re.replace("-grow", "") + "-webkit-" + re + "-ms-" + re.replace("grow", "positive") + re;
            case 115:
              return "-webkit-" + re + "-ms-" + re.replace("shrink", "negative") + re;
            case 98:
              return "-webkit-" + re + "-ms-" + re.replace("basis", "preferred-size") + re;
          }
        return "-webkit-" + re + "-ms-" + re + re;
      case 964:
        return "-webkit-" + re + "-ms-flex-" + re + re;
      case 1023:
        if (re.charCodeAt(8) !== 99)
          break;
        return ke = re.substring(re.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify"), "-webkit-box-pack" + ke + "-webkit-" + re + "-ms-flex-pack" + ke + re;
      case 1005:
        return _.test(re) ? re.replace(x, ":-webkit-") + re.replace(x, ":-moz-") + re : re;
      case 1e3:
        switch (ke = re.substring(13).trim(), xe = ke.indexOf("-") + 1, ke.charCodeAt(0) + ke.charCodeAt(xe)) {
          case 226:
            ke = re.replace(z, "tb");
            break;
          case 232:
            ke = re.replace(z, "tb-rl");
            break;
          case 220:
            ke = re.replace(z, "lr");
            break;
          default:
            return re;
        }
        return "-webkit-" + re + "-ms-" + ke + re;
      case 1017:
        if (re.indexOf("sticky", 9) === -1)
          break;
      case 975:
        switch (xe = (re = ce).length - 10, ke = (re.charCodeAt(xe) === 33 ? re.substring(0, xe) : re).substring(ce.indexOf(":", 7) + 1).trim(), Qe = ke.charCodeAt(0) + (ke.charCodeAt(7) | 0)) {
          case 203:
            if (111 > ke.charCodeAt(8))
              break;
          case 115:
            re = re.replace(ke, "-webkit-" + ke) + ";" + re;
            break;
          case 207:
          case 102:
            re = re.replace(ke, "-webkit-" + (102 < Qe ? "inline-" : "") + "box") + ";" + re.replace(ke, "-webkit-" + ke) + ";" + re.replace(ke, "-ms-" + ke + "box") + ";" + re;
        }
        return re + ";";
      case 938:
        if (re.charCodeAt(5) === 45)
          switch (re.charCodeAt(6)) {
            case 105:
              return ke = re.replace("-items", ""), "-webkit-" + re + "-webkit-box-" + ke + "-ms-flex-" + ke + re;
            case 115:
              return "-webkit-" + re + "-ms-flex-item-" + re.replace(X, "") + re;
            default:
              return "-webkit-" + re + "-ms-flex-line-pack" + re.replace("align-content", "").replace(X, "") + re;
          }
        break;
      case 973:
      case 989:
        if (re.charCodeAt(3) !== 45 || re.charCodeAt(4) === 122)
          break;
      case 931:
      case 953:
        if (ue.test(ce) === !0)
          return (ke = ce.substring(ce.indexOf(":") + 1)).charCodeAt(0) === 115 ? a(ce.replace("stretch", "fill-available"), xe, $e, Me).replace(":fill-available", ":stretch") : re.replace(ke, "-webkit-" + ke) + re.replace(ke, "-moz-" + ke.replace("fill-", "")) + re;
        break;
      case 962:
        if (re = "-webkit-" + re + (re.charCodeAt(5) === 102 ? "-ms-" + re : "") + re, $e + Me === 211 && re.charCodeAt(13) === 105 && 0 < re.indexOf("transform", 10))
          return re.substring(0, re.indexOf(";", 27) + 1).replace(T, "$1-webkit-$2") + re;
    }
    return re;
  }
  function s(ce, xe) {
    var $e = ce.indexOf(xe === 1 ? ":" : "{"), Me = ce.substring(0, xe !== 3 ? $e : 10);
    return $e = ce.substring($e + 1, ce.length - 1), de(xe !== 2 ? Me : Me.replace(se, "$1"), $e, xe);
  }
  function c(ce, xe) {
    var $e = a(xe, xe.charCodeAt(0), xe.charCodeAt(1), xe.charCodeAt(2));
    return $e !== xe + ";" ? $e.replace(K, " or ($1)").substring(4) : "(" + xe + ")";
  }
  function f(ce, xe, $e, Me, re, Qe, ke, rt, St, Tt) {
    for (var Le = 0, Nt = xe, Ke; Le < te; ++Le)
      switch (Ke = he[Le].call(y, ce, Nt, $e, Me, re, Qe, ke, rt, St, Tt)) {
        case void 0:
        case !1:
        case !0:
        case null:
          break;
        default:
          Nt = Ke;
      }
    if (Nt !== xe)
      return Nt;
  }
  function p(ce) {
    switch (ce) {
      case void 0:
      case null:
        te = he.length = 0;
        break;
      default:
        if (typeof ce == "function")
          he[te++] = ce;
        else if (typeof ce == "object")
          for (var xe = 0, $e = ce.length; xe < $e; ++xe)
            p(ce[xe]);
        else
          W = !!ce | 0;
    }
    return p;
  }
  function g(ce) {
    return ce = ce.prefix, ce !== void 0 && (de = null, ce ? typeof ce != "function" ? le = 1 : (le = 2, de = ce) : le = 0), g;
  }
  function y(ce, xe) {
    var $e = ce;
    if (33 > $e.charCodeAt(0) && ($e = $e.trim()), fe = $e, $e = [fe], 0 < te) {
      var Me = f(-1, xe, $e, $e, ve, Pe, 0, 0, 0, 0);
      Me !== void 0 && typeof Me == "string" && (xe = Me);
    }
    var re = e(Re, $e, xe, 0, 0);
    return 0 < te && (Me = f(-2, re, $e, $e, ve, Pe, re.length, 0, 0, 0), Me !== void 0 && (re = Me)), fe = "", Y = 0, Pe = ve = 1, re;
  }
  var v = /^\0+/g, S = /[\0\r\f]/g, x = /: */g, _ = /zoo|gra/, T = /([,: ])(transform)/g, I = /,\r+?/g, D = /([\t\r\n ])*\f?&/g, N = /@(k\w+)\s*(\S*)\s*/, j = /::(place)/g, L = /:(read-only)/g, z = /[svh]\w+-[tblr]{2}/, F = /\(\s*(.*)\s*\)/g, K = /([\s\S]*?);/g, X = /-self|flex-/g, se = /[^]*?(:[rp][el]a[\w-]+)[^]*/, ue = /stretch|:\s*\w+\-(?:conte|avail)/, pe = /([^-])(image-set\()/, Pe = 1, ve = 1, Y = 0, le = 1, Re = [], he = [], te = 0, de = null, W = 0, fe = "";
  return y.use = p, y.set = g, t !== void 0 && g(t), y;
}
var Mde = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
function Ade(t) {
  var e = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return e[n] === void 0 && (e[n] = t(n)), e[n];
  };
}
var Ode = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, FN = /* @__PURE__ */ Ade(
  function(t) {
    return Ode.test(t) || t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && t.charCodeAt(2) < 91;
  }
  /* Z+1 */
), jP = { exports: {} }, rr = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var HN;
function Dde() {
  if (HN)
    return rr;
  HN = 1;
  var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, r = t ? Symbol.for("react.fragment") : 60107, a = t ? Symbol.for("react.strict_mode") : 60108, s = t ? Symbol.for("react.profiler") : 60114, c = t ? Symbol.for("react.provider") : 60109, f = t ? Symbol.for("react.context") : 60110, p = t ? Symbol.for("react.async_mode") : 60111, g = t ? Symbol.for("react.concurrent_mode") : 60111, y = t ? Symbol.for("react.forward_ref") : 60112, v = t ? Symbol.for("react.suspense") : 60113, S = t ? Symbol.for("react.suspense_list") : 60120, x = t ? Symbol.for("react.memo") : 60115, _ = t ? Symbol.for("react.lazy") : 60116, T = t ? Symbol.for("react.block") : 60121, I = t ? Symbol.for("react.fundamental") : 60117, D = t ? Symbol.for("react.responder") : 60118, N = t ? Symbol.for("react.scope") : 60119;
  function j(z) {
    if (typeof z == "object" && z !== null) {
      var F = z.$$typeof;
      switch (F) {
        case e:
          switch (z = z.type, z) {
            case p:
            case g:
            case r:
            case s:
            case a:
            case v:
              return z;
            default:
              switch (z = z && z.$$typeof, z) {
                case f:
                case y:
                case _:
                case x:
                case c:
                  return z;
                default:
                  return F;
              }
          }
        case n:
          return F;
      }
    }
  }
  function L(z) {
    return j(z) === g;
  }
  return rr.AsyncMode = p, rr.ConcurrentMode = g, rr.ContextConsumer = f, rr.ContextProvider = c, rr.Element = e, rr.ForwardRef = y, rr.Fragment = r, rr.Lazy = _, rr.Memo = x, rr.Portal = n, rr.Profiler = s, rr.StrictMode = a, rr.Suspense = v, rr.isAsyncMode = function(z) {
    return L(z) || j(z) === p;
  }, rr.isConcurrentMode = L, rr.isContextConsumer = function(z) {
    return j(z) === f;
  }, rr.isContextProvider = function(z) {
    return j(z) === c;
  }, rr.isElement = function(z) {
    return typeof z == "object" && z !== null && z.$$typeof === e;
  }, rr.isForwardRef = function(z) {
    return j(z) === y;
  }, rr.isFragment = function(z) {
    return j(z) === r;
  }, rr.isLazy = function(z) {
    return j(z) === _;
  }, rr.isMemo = function(z) {
    return j(z) === x;
  }, rr.isPortal = function(z) {
    return j(z) === n;
  }, rr.isProfiler = function(z) {
    return j(z) === s;
  }, rr.isStrictMode = function(z) {
    return j(z) === a;
  }, rr.isSuspense = function(z) {
    return j(z) === v;
  }, rr.isValidElementType = function(z) {
    return typeof z == "string" || typeof z == "function" || z === r || z === g || z === s || z === a || z === v || z === S || typeof z == "object" && z !== null && (z.$$typeof === _ || z.$$typeof === x || z.$$typeof === c || z.$$typeof === f || z.$$typeof === y || z.$$typeof === I || z.$$typeof === D || z.$$typeof === N || z.$$typeof === T);
  }, rr.typeOf = j, rr;
}
var ir = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VN;
function Nde() {
  return VN || (VN = 1, {}.NODE_ENV !== "production" && function() {
    var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, r = t ? Symbol.for("react.fragment") : 60107, a = t ? Symbol.for("react.strict_mode") : 60108, s = t ? Symbol.for("react.profiler") : 60114, c = t ? Symbol.for("react.provider") : 60109, f = t ? Symbol.for("react.context") : 60110, p = t ? Symbol.for("react.async_mode") : 60111, g = t ? Symbol.for("react.concurrent_mode") : 60111, y = t ? Symbol.for("react.forward_ref") : 60112, v = t ? Symbol.for("react.suspense") : 60113, S = t ? Symbol.for("react.suspense_list") : 60120, x = t ? Symbol.for("react.memo") : 60115, _ = t ? Symbol.for("react.lazy") : 60116, T = t ? Symbol.for("react.block") : 60121, I = t ? Symbol.for("react.fundamental") : 60117, D = t ? Symbol.for("react.responder") : 60118, N = t ? Symbol.for("react.scope") : 60119;
    function j(Le) {
      return typeof Le == "string" || typeof Le == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      Le === r || Le === g || Le === s || Le === a || Le === v || Le === S || typeof Le == "object" && Le !== null && (Le.$$typeof === _ || Le.$$typeof === x || Le.$$typeof === c || Le.$$typeof === f || Le.$$typeof === y || Le.$$typeof === I || Le.$$typeof === D || Le.$$typeof === N || Le.$$typeof === T);
    }
    function L(Le) {
      if (typeof Le == "object" && Le !== null) {
        var Nt = Le.$$typeof;
        switch (Nt) {
          case e:
            var Ke = Le.type;
            switch (Ke) {
              case p:
              case g:
              case r:
              case s:
              case a:
              case v:
                return Ke;
              default:
                var yt = Ke && Ke.$$typeof;
                switch (yt) {
                  case f:
                  case y:
                  case _:
                  case x:
                  case c:
                    return yt;
                  default:
                    return Nt;
                }
            }
          case n:
            return Nt;
        }
      }
    }
    var z = p, F = g, K = f, X = c, se = e, ue = y, pe = r, Pe = _, ve = x, Y = n, le = s, Re = a, he = v, te = !1;
    function de(Le) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), W(Le) || L(Le) === p;
    }
    function W(Le) {
      return L(Le) === g;
    }
    function fe(Le) {
      return L(Le) === f;
    }
    function ce(Le) {
      return L(Le) === c;
    }
    function xe(Le) {
      return typeof Le == "object" && Le !== null && Le.$$typeof === e;
    }
    function $e(Le) {
      return L(Le) === y;
    }
    function Me(Le) {
      return L(Le) === r;
    }
    function re(Le) {
      return L(Le) === _;
    }
    function Qe(Le) {
      return L(Le) === x;
    }
    function ke(Le) {
      return L(Le) === n;
    }
    function rt(Le) {
      return L(Le) === s;
    }
    function St(Le) {
      return L(Le) === a;
    }
    function Tt(Le) {
      return L(Le) === v;
    }
    ir.AsyncMode = z, ir.ConcurrentMode = F, ir.ContextConsumer = K, ir.ContextProvider = X, ir.Element = se, ir.ForwardRef = ue, ir.Fragment = pe, ir.Lazy = Pe, ir.Memo = ve, ir.Portal = Y, ir.Profiler = le, ir.StrictMode = Re, ir.Suspense = he, ir.isAsyncMode = de, ir.isConcurrentMode = W, ir.isContextConsumer = fe, ir.isContextProvider = ce, ir.isElement = xe, ir.isForwardRef = $e, ir.isFragment = Me, ir.isLazy = re, ir.isMemo = Qe, ir.isPortal = ke, ir.isProfiler = rt, ir.isStrictMode = St, ir.isSuspense = Tt, ir.isValidElementType = j, ir.typeOf = L;
  }()), ir;
}
({}).NODE_ENV === "production" ? jP.exports = Dde() : jP.exports = Nde();
var Lde = jP.exports, $2 = Lde, jde = {
  childContextTypes: !0,
  contextType: !0,
  contextTypes: !0,
  defaultProps: !0,
  displayName: !0,
  getDefaultProps: !0,
  getDerivedStateFromError: !0,
  getDerivedStateFromProps: !0,
  mixins: !0,
  propTypes: !0,
  type: !0
}, zde = {
  name: !0,
  length: !0,
  prototype: !0,
  caller: !0,
  callee: !0,
  arguments: !0,
  arity: !0
}, Ude = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, k5 = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, M2 = {};
M2[$2.ForwardRef] = Ude;
M2[$2.Memo] = k5;
function YN(t) {
  return $2.isMemo(t) ? k5 : M2[t.$$typeof] || jde;
}
var Bde = Object.defineProperty, Fde = Object.getOwnPropertyNames, KN = Object.getOwnPropertySymbols, Hde = Object.getOwnPropertyDescriptor, Vde = Object.getPrototypeOf, WN = Object.prototype;
function P5(t, e, n) {
  if (typeof e != "string") {
    if (WN) {
      var r = Vde(e);
      r && r !== WN && P5(t, r, n);
    }
    var a = Fde(e);
    KN && (a = a.concat(KN(e)));
    for (var s = YN(t), c = YN(e), f = 0; f < a.length; ++f) {
      var p = a[f];
      if (!zde[p] && !(n && n[p]) && !(c && c[p]) && !(s && s[p])) {
        var g = Hde(e, p);
        try {
          Bde(t, p, g);
        } catch {
        }
      }
    }
  }
  return t;
}
var Yde = P5;
const Kde = /* @__PURE__ */ jp(Yde);
function Du() {
  return (Du = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }).apply(this, arguments);
}
var GN = function(t, e) {
  for (var n = [t[0]], r = 0, a = e.length; r < a; r += 1)
    n.push(e[r], t[r + 1]);
  return n;
}, zP = function(t) {
  return t !== null && typeof t == "object" && (t.toString ? t.toString() : Object.prototype.toString.call(t)) === "[object Object]" && !R2.typeOf(t);
}, Xx = Object.freeze([]), Jd = Object.freeze({});
function hb(t) {
  return typeof t == "function";
}
function UP(t) {
  return {}.NODE_ENV !== "production" && typeof t == "string" && t || t.displayName || t.name || "Component";
}
function A2(t) {
  return t && typeof t.styledComponentId == "string";
}
var tm = typeof process < "u" && {} !== void 0 && ({}.REACT_APP_SC_ATTR || {}.SC_ATTR) || "data-styled", O2 = typeof window < "u" && "HTMLElement" in window, Wde = !!(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && {} !== void 0 && ({}.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && {}.REACT_APP_SC_DISABLE_SPEEDY !== "" ? {}.REACT_APP_SC_DISABLE_SPEEDY !== "false" && {}.REACT_APP_SC_DISABLE_SPEEDY : {}.SC_DISABLE_SPEEDY !== void 0 && {}.SC_DISABLE_SPEEDY !== "" ? {}.SC_DISABLE_SPEEDY !== "false" && {}.SC_DISABLE_SPEEDY : {}.NODE_ENV !== "production")), Gde = {}.NODE_ENV !== "production" ? { 1: `Cannot create styled-component for component: %s.

`, 2: `Can't collect styles once you've consumed a \`ServerStyleSheet\`'s styles! \`ServerStyleSheet\` is a one off instance for each server-side render cycle.

- Are you trying to reuse it across renders?
- Are you accidentally calling collectStyles twice?

`, 3: `Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.

`, 4: `The \`StyleSheetManager\` expects a valid target or sheet prop!

- Does this error occur on the client and is your target falsy?
- Does this error occur on the server and is the sheet falsy?

`, 5: `The clone method cannot be used on the client!

- Are you running in a client-like environment on the server?
- Are you trying to run SSR on the client?

`, 6: `Trying to insert a new style tag, but the given Node is unmounted!

- Are you using a custom target that isn't mounted?
- Does your document not have a valid head element?
- Have you accidentally removed a style tag manually?

`, 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: `ThemeProvider: Please make your "theme" prop an object.

`, 9: "Missing document `<head>`\n\n", 10: `Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021

`, 11: `_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.

`, 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: `%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.

`, 14: `ThemeProvider: "theme" prop is required.

`, 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: `Reached the limit of how many styled components may be created at group %s.
You may only create up to 1,073,741,824 components. If you're creating components dynamically,
as for instance in your render method then you may be running into this limitation.

`, 17: `CSSStyleSheet could not be found on HTMLStyleElement.
Has styled-components' style tag been unmounted or altered by another script?
` } : {};
function Xde() {
  for (var t = arguments.length <= 0 ? void 0 : arguments[0], e = [], n = 1, r = arguments.length; n < r; n += 1)
    e.push(n < 0 || arguments.length <= n ? void 0 : arguments[n]);
  return e.forEach(function(a) {
    t = t.replace(/%[a-z]/, a);
  }), t;
}
function vm(t) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    n[r - 1] = arguments[r];
  throw {}.NODE_ENV === "production" ? new Error("An error occurred. See https://git.io/JUIaE#" + t + " for more information." + (n.length > 0 ? " Args: " + n.join(", ") : "")) : new Error(Xde.apply(void 0, [Gde[t]].concat(n)).trim());
}
var qde = function() {
  function t(n) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = n;
  }
  var e = t.prototype;
  return e.indexOfGroup = function(n) {
    for (var r = 0, a = 0; a < n; a++)
      r += this.groupSizes[a];
    return r;
  }, e.insertRules = function(n, r) {
    if (n >= this.groupSizes.length) {
      for (var a = this.groupSizes, s = a.length, c = s; n >= c; )
        (c <<= 1) < 0 && vm(16, "" + n);
      this.groupSizes = new Uint32Array(c), this.groupSizes.set(a), this.length = c;
      for (var f = s; f < c; f++)
        this.groupSizes[f] = 0;
    }
    for (var p = this.indexOfGroup(n + 1), g = 0, y = r.length; g < y; g++)
      this.tag.insertRule(p, r[g]) && (this.groupSizes[n]++, p++);
  }, e.clearGroup = function(n) {
    if (n < this.length) {
      var r = this.groupSizes[n], a = this.indexOfGroup(n), s = a + r;
      this.groupSizes[n] = 0;
      for (var c = a; c < s; c++)
        this.tag.deleteRule(a);
    }
  }, e.getGroup = function(n) {
    var r = "";
    if (n >= this.length || this.groupSizes[n] === 0)
      return r;
    for (var a = this.groupSizes[n], s = this.indexOfGroup(n), c = s + a, f = s; f < c; f++)
      r += this.tag.getRule(f) + `/*!sc*/
`;
    return r;
  }, t;
}(), vx = /* @__PURE__ */ new Map(), qx = /* @__PURE__ */ new Map(), Wy = 1, nx = function(t) {
  if (vx.has(t))
    return vx.get(t);
  for (; qx.has(Wy); )
    Wy++;
  var e = Wy++;
  return {}.NODE_ENV !== "production" && ((0 | e) < 0 || e > 1 << 30) && vm(16, "" + e), vx.set(t, e), qx.set(e, t), e;
}, Qde = function(t) {
  return qx.get(t);
}, Zde = function(t, e) {
  e >= Wy && (Wy = e + 1), vx.set(t, e), qx.set(e, t);
}, Jde = "style[" + tm + '][data-styled-version="5.3.11"]', efe = new RegExp("^" + tm + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'), tfe = function(t, e, n) {
  for (var r, a = n.split(","), s = 0, c = a.length; s < c; s++)
    (r = a[s]) && t.registerName(e, r);
}, nfe = function(t, e) {
  for (var n = (e.textContent || "").split(`/*!sc*/
`), r = [], a = 0, s = n.length; a < s; a++) {
    var c = n[a].trim();
    if (c) {
      var f = c.match(efe);
      if (f) {
        var p = 0 | parseInt(f[1], 10), g = f[2];
        p !== 0 && (Zde(g, p), tfe(t, g, f[3]), t.getTag().insertRules(p, r)), r.length = 0;
      } else
        r.push(c);
    }
  }
}, rfe = function() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
}, I5 = function(t) {
  var e = document.head, n = t || e, r = document.createElement("style"), a = function(f) {
    for (var p = f.childNodes, g = p.length; g >= 0; g--) {
      var y = p[g];
      if (y && y.nodeType === 1 && y.hasAttribute(tm))
        return y;
    }
  }(n), s = a !== void 0 ? a.nextSibling : null;
  r.setAttribute(tm, "active"), r.setAttribute("data-styled-version", "5.3.11");
  var c = rfe();
  return c && r.setAttribute("nonce", c), n.insertBefore(r, s), r;
}, ife = function() {
  function t(n) {
    var r = this.element = I5(n);
    r.appendChild(document.createTextNode("")), this.sheet = function(a) {
      if (a.sheet)
        return a.sheet;
      for (var s = document.styleSheets, c = 0, f = s.length; c < f; c++) {
        var p = s[c];
        if (p.ownerNode === a)
          return p;
      }
      vm(17);
    }(r), this.length = 0;
  }
  var e = t.prototype;
  return e.insertRule = function(n, r) {
    try {
      return this.sheet.insertRule(r, n), this.length++, !0;
    } catch {
      return !1;
    }
  }, e.deleteRule = function(n) {
    this.sheet.deleteRule(n), this.length--;
  }, e.getRule = function(n) {
    var r = this.sheet.cssRules[n];
    return r !== void 0 && typeof r.cssText == "string" ? r.cssText : "";
  }, t;
}(), ofe = function() {
  function t(n) {
    var r = this.element = I5(n);
    this.nodes = r.childNodes, this.length = 0;
  }
  var e = t.prototype;
  return e.insertRule = function(n, r) {
    if (n <= this.length && n >= 0) {
      var a = document.createTextNode(r), s = this.nodes[n];
      return this.element.insertBefore(a, s || null), this.length++, !0;
    }
    return !1;
  }, e.deleteRule = function(n) {
    this.element.removeChild(this.nodes[n]), this.length--;
  }, e.getRule = function(n) {
    return n < this.length ? this.nodes[n].textContent : "";
  }, t;
}(), afe = function() {
  function t(n) {
    this.rules = [], this.length = 0;
  }
  var e = t.prototype;
  return e.insertRule = function(n, r) {
    return n <= this.length && (this.rules.splice(n, 0, r), this.length++, !0);
  }, e.deleteRule = function(n) {
    this.rules.splice(n, 1), this.length--;
  }, e.getRule = function(n) {
    return n < this.length ? this.rules[n] : "";
  }, t;
}(), XN = O2, sfe = { isServer: !O2, useCSSOMInjection: !Wde }, R5 = function() {
  function t(n, r, a) {
    n === void 0 && (n = Jd), r === void 0 && (r = {}), this.options = Du({}, sfe, {}, n), this.gs = r, this.names = new Map(a), this.server = !!n.isServer, !this.server && O2 && XN && (XN = !1, function(s) {
      for (var c = document.querySelectorAll(Jde), f = 0, p = c.length; f < p; f++) {
        var g = c[f];
        g && g.getAttribute(tm) !== "active" && (nfe(s, g), g.parentNode && g.parentNode.removeChild(g));
      }
    }(this));
  }
  t.registerId = function(n) {
    return nx(n);
  };
  var e = t.prototype;
  return e.reconstructWithOptions = function(n, r) {
    return r === void 0 && (r = !0), new t(Du({}, this.options, {}, n), this.gs, r && this.names || void 0);
  }, e.allocateGSInstance = function(n) {
    return this.gs[n] = (this.gs[n] || 0) + 1;
  }, e.getTag = function() {
    return this.tag || (this.tag = (a = (r = this.options).isServer, s = r.useCSSOMInjection, c = r.target, n = a ? new afe(c) : s ? new ife(c) : new ofe(c), new qde(n)));
    var n, r, a, s, c;
  }, e.hasNameForId = function(n, r) {
    return this.names.has(n) && this.names.get(n).has(r);
  }, e.registerName = function(n, r) {
    if (nx(n), this.names.has(n))
      this.names.get(n).add(r);
    else {
      var a = /* @__PURE__ */ new Set();
      a.add(r), this.names.set(n, a);
    }
  }, e.insertRules = function(n, r, a) {
    this.registerName(n, r), this.getTag().insertRules(nx(n), a);
  }, e.clearNames = function(n) {
    this.names.has(n) && this.names.get(n).clear();
  }, e.clearRules = function(n) {
    this.getTag().clearGroup(nx(n)), this.clearNames(n);
  }, e.clearTag = function() {
    this.tag = void 0;
  }, e.toString = function() {
    return function(n) {
      for (var r = n.getTag(), a = r.length, s = "", c = 0; c < a; c++) {
        var f = Qde(c);
        if (f !== void 0) {
          var p = n.names.get(f), g = r.getGroup(c);
          if (p && g && p.size) {
            var y = tm + ".g" + c + '[id="' + f + '"]', v = "";
            p !== void 0 && p.forEach(function(S) {
              S.length > 0 && (v += S + ",");
            }), s += "" + g + y + '{content:"' + v + `"}/*!sc*/
`;
          }
        }
      }
      return s;
    }(this);
  }, t;
}(), lfe = /(a)(d)/gi, qN = function(t) {
  return String.fromCharCode(t + (t > 25 ? 39 : 97));
};
function BP(t) {
  var e, n = "";
  for (e = Math.abs(t); e > 52; e = e / 52 | 0)
    n = qN(e % 52) + n;
  return (qN(e % 52) + n).replace(lfe, "$1-$2");
}
var Cp = function(t, e) {
  for (var n = e.length; n; )
    t = 33 * t ^ e.charCodeAt(--n);
  return t;
}, $5 = function(t) {
  return Cp(5381, t);
};
function cfe(t) {
  for (var e = 0; e < t.length; e += 1) {
    var n = t[e];
    if (hb(n) && !A2(n))
      return !1;
  }
  return !0;
}
var ufe = $5("5.3.11"), dfe = function() {
  function t(e, n, r) {
    this.rules = e, this.staticRulesId = "", this.isStatic = {}.NODE_ENV === "production" && (r === void 0 || r.isStatic) && cfe(e), this.componentId = n, this.baseHash = Cp(ufe, n), this.baseStyle = r, R5.registerId(n);
  }
  return t.prototype.generateAndInjectStyles = function(e, n, r) {
    var a = this.componentId, s = [];
    if (this.baseStyle && s.push(this.baseStyle.generateAndInjectStyles(e, n, r)), this.isStatic && !r.hash)
      if (this.staticRulesId && n.hasNameForId(a, this.staticRulesId))
        s.push(this.staticRulesId);
      else {
        var c = nm(this.rules, e, n, r).join(""), f = BP(Cp(this.baseHash, c) >>> 0);
        if (!n.hasNameForId(a, f)) {
          var p = r(c, "." + f, void 0, a);
          n.insertRules(a, f, p);
        }
        s.push(f), this.staticRulesId = f;
      }
    else {
      for (var g = this.rules.length, y = Cp(this.baseHash, r.hash), v = "", S = 0; S < g; S++) {
        var x = this.rules[S];
        if (typeof x == "string")
          v += x, {}.NODE_ENV !== "production" && (y = Cp(y, x + S));
        else if (x) {
          var _ = nm(x, e, n, r), T = Array.isArray(_) ? _.join("") : _;
          y = Cp(y, T + S), v += T;
        }
      }
      if (v) {
        var I = BP(y >>> 0);
        if (!n.hasNameForId(a, I)) {
          var D = r(v, "." + I, void 0, a);
          n.insertRules(a, I, D);
        }
        s.push(I);
      }
    }
    return s.join(" ");
  }, t;
}(), ffe = /^\s*\/\/.*$/gm, pfe = [":", "[", ".", "#"];
function hfe(t) {
  var e, n, r, a, s = t === void 0 ? Jd : t, c = s.options, f = c === void 0 ? Jd : c, p = s.plugins, g = p === void 0 ? Xx : p, y = new $de(f), v = [], S = function(T) {
    function I(D) {
      if (D)
        try {
          T(D + "}");
        } catch {
        }
    }
    return function(D, N, j, L, z, F, K, X, se, ue) {
      switch (D) {
        case 1:
          if (se === 0 && N.charCodeAt(0) === 64)
            return T(N + ";"), "";
          break;
        case 2:
          if (X === 0)
            return N + "/*|*/";
          break;
        case 3:
          switch (X) {
            case 102:
            case 112:
              return T(j[0] + N), "";
            default:
              return N + (ue === 0 ? "/*|*/" : "");
          }
        case -2:
          N.split("/*|*/}").forEach(I);
      }
    };
  }(function(T) {
    v.push(T);
  }), x = function(T, I, D) {
    return I === 0 && pfe.indexOf(D[n.length]) !== -1 || D.match(a) ? T : "." + e;
  };
  function _(T, I, D, N) {
    N === void 0 && (N = "&");
    var j = T.replace(ffe, ""), L = I && D ? D + " " + I + " { " + j + " }" : j;
    return e = N, n = I, r = new RegExp("\\" + n + "\\b", "g"), a = new RegExp("(\\" + n + "\\b){2,}"), y(D || !I ? "" : I, L);
  }
  return y.use([].concat(g, [function(T, I, D) {
    T === 2 && D.length && D[0].lastIndexOf(n) > 0 && (D[0] = D[0].replace(r, x));
  }, S, function(T) {
    if (T === -2) {
      var I = v;
      return v = [], I;
    }
  }])), _.hash = g.length ? g.reduce(function(T, I) {
    return I.name || vm(15), Cp(T, I.name);
  }, 5381).toString() : "", _;
}
var M5 = It.createContext();
M5.Consumer;
var A5 = It.createContext(), gfe = (A5.Consumer, new R5()), FP = hfe();
function mfe() {
  return k.useContext(M5) || gfe;
}
function vfe() {
  return k.useContext(A5) || FP;
}
var yfe = function() {
  function t(e, n) {
    var r = this;
    this.inject = function(a, s) {
      s === void 0 && (s = FP);
      var c = r.name + s.hash;
      a.hasNameForId(r.id, c) || a.insertRules(r.id, c, s(r.rules, c, "@keyframes"));
    }, this.toString = function() {
      return vm(12, String(r.name));
    }, this.name = e, this.id = "sc-keyframes-" + e, this.rules = n;
  }
  return t.prototype.getName = function(e) {
    return e === void 0 && (e = FP), this.name + e.hash;
  }, t;
}(), bfe = /([A-Z])/, Sfe = /([A-Z])/g, wfe = /^ms-/, xfe = function(t) {
  return "-" + t.toLowerCase();
};
function QN(t) {
  return bfe.test(t) ? t.replace(Sfe, xfe).replace(wfe, "-ms-") : t;
}
var ZN = function(t) {
  return t == null || t === !1 || t === "";
};
function nm(t, e, n, r) {
  if (Array.isArray(t)) {
    for (var a, s = [], c = 0, f = t.length; c < f; c += 1)
      (a = nm(t[c], e, n, r)) !== "" && (Array.isArray(a) ? s.push.apply(s, a) : s.push(a));
    return s;
  }
  if (ZN(t))
    return "";
  if (A2(t))
    return "." + t.styledComponentId;
  if (hb(t)) {
    if (typeof (g = t) != "function" || g.prototype && g.prototype.isReactComponent || !e)
      return t;
    var p = t(e);
    return {}.NODE_ENV !== "production" && R2.isElement(p) && console.warn(UP(t) + " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."), nm(p, e, n, r);
  }
  var g;
  return t instanceof yfe ? n ? (t.inject(n, r), t.getName(r)) : t : zP(t) ? function y(v, S) {
    var x, _, T = [];
    for (var I in v)
      v.hasOwnProperty(I) && !ZN(v[I]) && (Array.isArray(v[I]) && v[I].isCss || hb(v[I]) ? T.push(QN(I) + ":", v[I], ";") : zP(v[I]) ? T.push.apply(T, y(v[I], I)) : T.push(QN(I) + ": " + (x = I, (_ = v[I]) == null || typeof _ == "boolean" || _ === "" ? "" : typeof _ != "number" || _ === 0 || x in Mde || x.startsWith("--") ? String(_).trim() : _ + "px") + ";"));
    return S ? [S + " {"].concat(T, ["}"]) : T;
  }(t) : t.toString();
}
var JN = function(t) {
  return Array.isArray(t) && (t.isCss = !0), t;
};
function O5(t) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    n[r - 1] = arguments[r];
  return hb(t) || zP(t) ? JN(nm(GN(Xx, [t].concat(n)))) : n.length === 0 && t.length === 1 && typeof t[0] == "string" ? t : JN(nm(GN(t, n)));
}
var e3 = /invalid hook call/i, rx = /* @__PURE__ */ new Set(), Efe = function(t, e) {
  if ({}.NODE_ENV !== "production") {
    var n = "The component " + t + (e ? ' with the id of "' + e + '"' : "") + ` has been created dynamically.
You may see this warning because you've called styled inside another component.
To resolve this only create new StyledComponents outside of any render method and function component.`, r = console.error;
    try {
      var a = !0;
      console.error = function(s) {
        if (e3.test(s))
          a = !1, rx.delete(n);
        else {
          for (var c = arguments.length, f = new Array(c > 1 ? c - 1 : 0), p = 1; p < c; p++)
            f[p - 1] = arguments[p];
          r.apply(void 0, [s].concat(f));
        }
      }, k.useRef(), a && !rx.has(n) && (console.warn(n), rx.add(n));
    } catch (s) {
      e3.test(s.message) && rx.delete(n);
    } finally {
      console.error = r;
    }
  }
}, Cfe = function(t, e, n) {
  return n === void 0 && (n = Jd), t.theme !== n.theme && t.theme || e || n.theme;
}, _fe = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, Tfe = /(^-|-$)/g;
function Nk(t) {
  return t.replace(_fe, "-").replace(Tfe, "");
}
var kfe = function(t) {
  return BP($5(t) >>> 0);
};
function ix(t) {
  return typeof t == "string" && ({}.NODE_ENV === "production" || t.charAt(0) === t.charAt(0).toLowerCase());
}
var HP = function(t) {
  return typeof t == "function" || typeof t == "object" && t !== null && !Array.isArray(t);
}, Pfe = function(t) {
  return t !== "__proto__" && t !== "constructor" && t !== "prototype";
};
function Ife(t, e, n) {
  var r = t[n];
  HP(e) && HP(r) ? D5(r, e) : t[n] = e;
}
function D5(t) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    n[r - 1] = arguments[r];
  for (var a = 0, s = n; a < s.length; a++) {
    var c = s[a];
    if (HP(c))
      for (var f in c)
        Pfe(f) && Ife(t, c[f], f);
  }
  return t;
}
var N5 = It.createContext();
N5.Consumer;
var Lk = {};
function L5(t, e, n) {
  var r = A2(t), a = !ix(t), s = e.attrs, c = s === void 0 ? Xx : s, f = e.componentId, p = f === void 0 ? function(N, j) {
    var L = typeof N != "string" ? "sc" : Nk(N);
    Lk[L] = (Lk[L] || 0) + 1;
    var z = L + "-" + kfe("5.3.11" + L + Lk[L]);
    return j ? j + "-" + z : z;
  }(e.displayName, e.parentComponentId) : f, g = e.displayName, y = g === void 0 ? function(N) {
    return ix(N) ? "styled." + N : "Styled(" + UP(N) + ")";
  }(t) : g, v = e.displayName && e.componentId ? Nk(e.displayName) + "-" + e.componentId : e.componentId || p, S = r && t.attrs ? Array.prototype.concat(t.attrs, c).filter(Boolean) : c, x = e.shouldForwardProp;
  r && t.shouldForwardProp && (x = e.shouldForwardProp ? function(N, j, L) {
    return t.shouldForwardProp(N, j, L) && e.shouldForwardProp(N, j, L);
  } : t.shouldForwardProp);
  var _, T = new dfe(n, v, r ? t.componentStyle : void 0), I = T.isStatic && c.length === 0, D = function(N, j) {
    return function(L, z, F, K) {
      var X = L.attrs, se = L.componentStyle, ue = L.defaultProps, pe = L.foldedComponentIds, Pe = L.shouldForwardProp, ve = L.styledComponentId, Y = L.target, le = function(Me, re, Qe) {
        Me === void 0 && (Me = Jd);
        var ke = Du({}, re, { theme: Me }), rt = {};
        return Qe.forEach(function(St) {
          var Tt, Le, Nt, Ke = St;
          for (Tt in hb(Ke) && (Ke = Ke(ke)), Ke)
            ke[Tt] = rt[Tt] = Tt === "className" ? (Le = rt[Tt], Nt = Ke[Tt], Le && Nt ? Le + " " + Nt : Le || Nt) : Ke[Tt];
        }), [ke, rt];
      }(Cfe(z, k.useContext(N5), ue) || Jd, z, X), Re = le[0], he = le[1], te = function(Me, re, Qe, ke) {
        var rt = mfe(), St = vfe(), Tt = re ? Me.generateAndInjectStyles(Jd, rt, St) : Me.generateAndInjectStyles(Qe, rt, St);
        return {}.NODE_ENV !== "production" && !re && ke && ke(Tt), Tt;
      }(se, K, Re, {}.NODE_ENV !== "production" ? L.warnTooManyClasses : void 0), de = F, W = he.$as || z.$as || he.as || z.as || Y, fe = ix(W), ce = he !== z ? Du({}, z, {}, he) : z, xe = {};
      for (var $e in ce)
        $e[0] !== "$" && $e !== "as" && ($e === "forwardedAs" ? xe.as = ce[$e] : (Pe ? Pe($e, FN, W) : !fe || FN($e)) && (xe[$e] = ce[$e]));
      return z.style && he.style !== z.style && (xe.style = Du({}, z.style, {}, he.style)), xe.className = Array.prototype.concat(pe, ve, te !== ve ? te : null, z.className, he.className).filter(Boolean).join(" "), xe.ref = de, k.createElement(W, xe);
    }(_, N, j, I);
  };
  return D.displayName = y, (_ = It.forwardRef(D)).attrs = S, _.componentStyle = T, _.displayName = y, _.shouldForwardProp = x, _.foldedComponentIds = r ? Array.prototype.concat(t.foldedComponentIds, t.styledComponentId) : Xx, _.styledComponentId = v, _.target = r ? t.target : t, _.withComponent = function(N) {
    var j = e.componentId, L = function(F, K) {
      if (F == null)
        return {};
      var X, se, ue = {}, pe = Object.keys(F);
      for (se = 0; se < pe.length; se++)
        X = pe[se], K.indexOf(X) >= 0 || (ue[X] = F[X]);
      return ue;
    }(e, ["componentId"]), z = j && j + "-" + (ix(N) ? N : Nk(UP(N)));
    return L5(N, Du({}, L, { attrs: S, componentId: z }), n);
  }, Object.defineProperty(_, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(N) {
    this._foldedDefaultProps = r ? D5({}, t.defaultProps, N) : N;
  } }), {}.NODE_ENV !== "production" && (Efe(y, v), _.warnTooManyClasses = function(N, j) {
    var L = {}, z = !1;
    return function(F) {
      if (!z && (L[F] = !0, Object.keys(L).length >= 200)) {
        var K = j ? ' with the id of "' + j + '"' : "";
        console.warn("Over 200 classes were generated for component " + N + K + `.
Consider using the attrs method, together with a style object for frequently changed styles.
Example:
  const Component = styled.div.attrs(props => ({
    style: {
      background: props.background,
    },
  }))\`width: 100%;\`

  <Component />`), z = !0, L = {};
      }
    };
  }(y, v)), Object.defineProperty(_, "toString", { value: function() {
    return "." + _.styledComponentId;
  } }), a && Kde(_, t, { attrs: !0, componentStyle: !0, displayName: !0, foldedComponentIds: !0, shouldForwardProp: !0, styledComponentId: !0, target: !0, withComponent: !0 }), _;
}
var VP = function(t) {
  return function e(n, r, a) {
    if (a === void 0 && (a = Jd), !R2.isValidElementType(r))
      return vm(1, String(r));
    var s = function() {
      return n(r, a, O5.apply(void 0, arguments));
    };
    return s.withConfig = function(c) {
      return e(n, r, Du({}, a, {}, c));
    }, s.attrs = function(c) {
      return e(n, r, Du({}, a, { attrs: Array.prototype.concat(a.attrs, c).filter(Boolean) }));
    }, s;
  }(L5, t);
};
["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(t) {
  VP[t] = VP(t);
});
({}).NODE_ENV !== "production" && typeof navigator < "u" && navigator.product === "ReactNative" && console.warn(`It looks like you've imported 'styled-components' on React Native.
Perhaps you're looking to import 'styled-components/native'?
Read more about this at https://www.styled-components.com/docs/basics#react-native`), {}.NODE_ENV !== "production" && {}.NODE_ENV !== "test" && typeof window < "u" && (window["__styled-components-init__"] = window["__styled-components-init__"] || 0, window["__styled-components-init__"] === 1 && console.warn(`It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.

See https://s-c.sh/2BAXzed for more info.`), window["__styled-components-init__"] += 1);
const $r = VP, Rfe = {
  sheet: {
    cssClass: "",
    editable: !1,
    document: null,
    data: null,
    limited: !1,
    options: {
      baseApplication: null,
      width: 0,
      height: 0,
      top: 0,
      left: 0,
      scale: 0,
      popOut: !1,
      minimizable: !1,
      resizable: !1,
      id: "",
      classes: [],
      dragDrop: [],
      tabs: [],
      filters: [],
      title: "",
      template: "",
      scrollY: [],
      closeOnSubmit: !1,
      editable: !1,
      sheetConfig: !1,
      submitOnChange: !1,
      submitOnClose: !1,
      viewPermission: 0,
      secrets: [],
      viewClasses: [],
      includeTOC: !1
    },
    owner: !1,
    title: "",
    headingLevels: {},
    id: ""
  },
  update: async () => {
    throw new Error("Not Implemented");
  },
  useDropEffect() {
    throw new Error("Not Implemented");
  }
}, j5 = k.createContext(Rfe), $fe = () => k.useContext(j5), Mfe = 1e3, Afe = ({ sheet: t, form: e, children: n }) => {
  const r = k.useCallback(fI(async (s, c) => await t.document.update(s, c), Mfe), [t?.document]), a = (s, c) => k.useEffect(() => {
    if (t.editable)
      return $(e).on("drop", ({ originalEvent: f }) => {
        let p;
        try {
          p = JSON.parse(f?.dataTransfer?.getData("text/plain") ?? ""), s(p);
        } catch {
          zr.error("Not allowed: ", f?.dataTransfer?.getData("text/plain") ?? f);
        }
      }), () => {
        $(e).off("drop");
      };
  }, [e, t.editable, ...c]);
  return /* @__PURE__ */ E.jsx(j5.Provider, { value: { sheet: t, update: r, useDropEffect: a }, children: n });
};
class t3 {
  constructor() {
    this.stores = /* @__PURE__ */ new Map();
  }
  activateSocketListeners(e) {
    this.socket = e, this.socket.register("connectUser", this.handleConnectUser.bind(this)), this.socket.register("disconnectUser", this.handleDisconnectUser.bind(this)), this.socket.register("updateUsers", this.handleUpdateUsers.bind(this)), this.socket.register("getRemoteSnapshot", this.handleGetRemoteSnapshot.bind(this)), this.socket.register("events", this.handleEvents.bind(this));
  }
  registerStore(e, n) {
    this.stores.set(e, n);
  }
  getStore(e) {
    const n = this.stores.get(e);
    if (!n)
      throw new Error(`No store found for instance ${e}`);
    return n;
  }
  connectUser(e) {
    zr.log("connectUser", e), this.socket.executeForOthers("connectUser", e);
  }
  disconnectUser(e, n) {
    zr.log("disconnectUser", e), this.socket.executeForOthers("disconnectUser", e, n);
  }
  handleDisconnectUser(e, n) {
    let r;
    try {
      r = this.getStore(e);
    } catch {
      return;
    }
    zr.log("disconnecting user", e, n), r.mergeRemoteChanges(() => {
      r.remove([n]);
    });
  }
  handleConnectUser(e) {
    let n;
    try {
      n = this.getStore(e);
    } catch {
      return;
    }
    const r = n.serialize((a) => ["user", "user_presence"].includes(a.typeName));
    zr.log("sendinng user state", r), this.socket.executeForOthers("updateUsers", e, r);
  }
  handleUpdateUsers(e, n) {
    const r = this.getStore(e);
    zr.log("userState", n), r.mergeRemoteChanges(() => {
      r.put(Object.values(n));
    });
  }
  handleEvents(e) {
    let n;
    try {
      n = this.getStore(e.instanceId);
    } catch {
      return;
    }
    const r = dX(n.schema.serialize(), e.schema);
    if (r === -1) {
      zr.error("Schema mismatch. Can't apply changes.");
      return;
    } else
      r === 1 && zr.warn("Schema mismatch. Applying changes anyway.");
    n.mergeRemoteChanges(() => {
      n.applyDiff(e.changes);
    });
  }
  async restoreFromRemote(e) {
    zr.log("Restoring remote snapshot.", e);
    const n = await this.socket.executeAsGM(
      "getRemoteSnapshot",
      e
    );
    if (!n) {
      zr.log("No remote snapshot found.", n);
      return;
    }
    zr.log("Remote snapshot found.", n);
    const r = this.getStore(e), a = r.schema.migrateStoreSnapshot(n.store, n.schema);
    if (a.type === "error") {
      zr.error(`Failed to migrate snapshot: ${a.reason}`);
      return;
    }
    r.mergeRemoteChanges(() => {
      r.put(Object.values(a.value));
    }), zr.log("Remote snapshot restored.");
  }
  handleGetRemoteSnapshot(e) {
    const n = this.getStore(e), a = {
      store: n.serialize((s) => ![
        "instance",
        "camera",
        "instance_page_state",
        "instance_presence",
        "user_document"
      ].includes(s.typeName)),
      schema: n.schema.serialize()
    };
    return zr.log("Sending snapshot to remote", a), a;
  }
  getSnapshot(e) {
    const n = this.getStore(e);
    return {
      store: n.serialize((s) => ![
        "instance",
        "camera",
        "instance_page_state",
        "user",
        "instance_presence",
        "user_document",
        "user_presence"
      ].includes(s.typeName)),
      schema: n.schema.serialize()
    };
  }
  restoreSnapshot(e, n) {
    const r = this.getStore(e), a = r.schema.migrateStoreSnapshot(n.store, n.schema);
    if (a.type === "error") {
      zr.error(`Failed to migrate snapshot: ${a.reason}`);
      return;
    }
    r.deserialize(a.value);
  }
  put(e, n, r) {
    if (r !== "user")
      return;
    const a = this.getStore(e);
    this.socket.executeForEveryone("events", {
      instanceId: e,
      changes: n,
      schema: a.schema.serialize()
    });
  }
  listen(e, n) {
    return this.getStore(e).listen(n);
  }
  getConcurrentUsers(e) {
    const n = this.getStore(e), r = n.serialize((c) => ["user"].includes(c.typeName)), a = n.serialize((c) => ["user_presence"].includes(c.typeName)), s = {};
    for (const [c, f] of Object.entries(r)) {
      const p = Object.values(a).find((g) => g.userId === c);
      s[f.id] = {
        name: f.name,
        id: c,
        color: p?.color
      };
    }
    return Object.values(s);
  }
  isCollaborativeMode() {
    return game.modules.get("socketlib")?.active;
  }
}
let no;
const Ofe = {
  hooks: {
    init() {
      no || (no = new t3());
    },
    socketlib() {
      const t = socketlib.registerModule(Nu);
      no || (no = new t3()), no.activateSocketListeners(t);
    }
  }
}, Dfe = {
  app: null,
  setApp: (t) => null,
  save: () => null,
  concurrentUsers: []
}, z5 = k.createContext(Dfe), D2 = () => k.useContext(z5), Nfe = ({ instanceId: t, onSave: e, children: n }) => {
  const [r, a] = k.useState(null), s = k.useRef(), [c, f] = k.useState([]);
  return k.useEffect(() => {
    if (!(!r || !no.isCollaborativeMode()))
      return s.current = no.listen(t, () => {
        const p = no.getConcurrentUsers(t);
        foundry.utils.objectsEqual(c.map((g) => g.id), p.map((g) => g.id)) || f(p);
      }), () => {
        s.current();
      };
  }, [r?.store, c, f, no.isCollaborativeMode()]), /* @__PURE__ */ E.jsx(z5.Provider, { value: { app: r, setApp: a, save: e, concurrentUsers: c }, children: n });
}, Lfe = () => {
  const { concurrentUsers: t } = D2();
  return t.length < 2 ? null : /* @__PURE__ */ E.jsxs(jfe, { "data-tooltip": t.map((e) => e.name).join(", "), children: [
    /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-user-group" }),
    t.map((e) => /* @__PURE__ */ E.jsxs(zfe, { color: e.color, children: [
      " ",
      e.name?.[0],
      " "
    ] }, e.id))
  ] });
}, jfe = $r.li`
    justify-content: center;
    align-items: center;
    padding: 0 6px;
    background: #d9d8c8;
    border: 1px solid #ff6400;
    border-radius: 3px;
    box-shadow: 0 0 4px #ff6400;
    display: flex;
`, zfe = $r.span`
    background: ${(t) => t.color};
    border: 1px solid ${(t) => t.color};
    width: 14px;
    height: 15px;
    border-radius: 50%;
    margin-right: -3px;
    line-height: 0.75rem;
    font-size: 0.625rem;
    text-align: center;
    color: black;
    font-weight: 700;
`, Ufe = () => {
  const { app: t, save: e } = D2(), [n, r] = k.useState(t?.isGridMode), a = k.useCallback(() => {
    e();
  }, [t]), s = k.useCallback(() => {
    !t || t.currentToolId !== "select" || (t.setGridMode(!t.isGridMode), r(t.isGridMode));
  }, [t]), c = k.useCallback(() => {
    if (!t || t.currentToolId !== "select")
      return;
    const T = t.selectedIds, I = ot.Common(Gt(T.map((N) => t.getPageBoundsById(N)))), D = t.canMoveCamera ? {
      x: I.width + 10,
      y: 0
    } : {
      x: 16 / t.zoomLevel,
      y: 16 / t.zoomLevel
    };
    t.mark("duplicate shapes"), t.duplicateShapes(T, D);
  }, [t]), f = k.useCallback(() => {
    !t || t.currentToolId !== "select" || (t.mark("align left"), t.alignShapes("left", t.selectedIds));
  }, [t]), p = k.useCallback(() => {
    !t || t.currentToolId !== "select" || (t.mark("align center horizontal"), t.alignShapes("center-horizontal", t.selectedIds));
  }, [t]), g = k.useCallback(() => {
    !t || t.currentToolId !== "select" || (t.mark("align right"), t.alignShapes("right", t.selectedIds));
  }, [t]), y = k.useCallback(() => {
    !t || t.currentToolId !== "select" || (t.mark("align top"), t.alignShapes("top", t.selectedIds));
  }, [t]), v = k.useCallback(() => {
    !t || t.currentToolId !== "select" || (t.mark("align center vertical"), t.alignShapes("center-vertical", t.selectedIds));
  }, [t]), S = k.useCallback(() => {
    !t || t.currentToolId !== "select" || (t.mark("align bottom"), t.alignShapes("bottom", t.selectedIds));
  }, [t]), x = k.useCallback(() => {
    !t || t.currentToolId !== "select" || (t.mark("distribute horizontal"), t.distributeShapes("horizontal", t.selectedIds));
  }, [t]), _ = k.useCallback(() => {
    !t || t.currentToolId !== "select" || (t.mark("distribute vertical"), t.distributeShapes("vertical", t.selectedIds));
  }, [t]);
  return /* @__PURE__ */ E.jsxs(Bfe, { children: [
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Pl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("JW.ShowGrid"),
        onClick: s,
        active: n,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-grid" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Pl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("JW.AlignLeft"),
        onClick: f,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-objects-align-left" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Pl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("JW.AlignHorizontally"),
        onClick: p,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-objects-align-center-horizontal" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Pl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("JW.AlignRight"),
        onClick: g,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-objects-align-right" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Pl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("JW.AlignTop"),
        onClick: y,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-objects-align-top" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Pl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("JW.AlignVertically"),
        onClick: v,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-objects-align-center-vertical" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Pl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("JW.AlignBottom"),
        onClick: S,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-objects-align-bottom" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Pl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("JW.DistributeHorizontally"),
        onClick: x,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-distribute-spacing-horizontal" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Pl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("JW.DistributeVertically"),
        onClick: _,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-distribute-spacing-vertical" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Pl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("Duplicate"),
        onClick: c,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-clone" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Pl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("Save Changes"),
        onClick: a,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-save" })
      }
    ) }),
    /* @__PURE__ */ E.jsx(Lfe, {})
  ] });
}, Bfe = $r.menu`
    display: flex;
    margin: 0;
    padding: 2px 8px;
    background: rgba(0, 0, 0, 0.1);
    flex-wrap: wrap;
    flex: none;
    list-style: none;

    & > li {
        margin: 6px 2px;
    }
    /* height: 42px; */
`, Pl = $r.button`
    background: transparent;
    cursor: pointer;
    padding: 0 5px;
    margin: 0 1px;
    line-height: 26px;
    border: none;
    border-radius: 4px;
    font-size: 0.875rem;
    font-family: 'Signika', sans-serif;
    width: 100%;
    box-sizing: border-box;
    ${(t) => t.active && O5`
            box-shadow: none;
            background: #f0f0e0;
            color: black;
        `}

    &:hover {
        box-shadow: none;
        background: #f0f0e0;
        color: black;
    }

    i {
        margin: 0;
        font-size: 14px;
    }
`, F1 = [], Pu = (t) => {
  F1.push(t);
}, Ffe = () => F1.map((t) => t.shape), Hfe = () => F1.map((t) => t.tool), Vfe = (t) => F1.find((e) => e.dataTransferType === t)?.shape, Yfe = Sde(), Kfe = wde(), Wfe = ({
  store: t,
  config: e,
  onMount: n,
  userId: r,
  instanceId: a
}) => {
  const { sheet: s, update: c, useDropEffect: f } = $fe(), [p, g] = It.useState(s?.data?.title?.show), { app: y, setApp: v } = D2(), S = k.useCallback((x) => {
    v(x), n(x);
  }, [n]);
  return f((x) => {
    if (!y)
      return;
    const _ = Vfe(x?.type);
    if (zr.log("Dropping Foundry Document", x, _), !_)
      return;
    const T = y.createShapeId();
    y.createShapes([
      {
        id: T,
        type: _.type,
        x: y.viewportPageBounds.center.x,
        y: y.viewportPageBounds.center.y,
        props: {
          id: x.uuid,
          type: x.type
        }
      }
    ]), y.setSelectedIds([T]), y.setSelectedTool("select.idle");
  }, [y]), /* @__PURE__ */ E.jsxs(Gfe, { className: s.cssClass, children: [
    s?.editable && /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsxs("header", { className: "journal-header", children: [
        /* @__PURE__ */ E.jsx(
          "input",
          {
            className: "title",
            type: "text",
            defaultValue: s?.data?.name,
            onChange: (x) => {
              c({ name: x.target.value });
            },
            placeholder: "Page Name"
          },
          s.id
        ),
        /* @__PURE__ */ E.jsxs("aside", { className: "page-level flexcol", children: [
          /* @__PURE__ */ E.jsxs("div", { className: "heading-level flexrow", children: [
            /* @__PURE__ */ E.jsx("label", { className: "flex0", "data-tooltip": "Heading Level", children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-list-tree" }) }),
            /* @__PURE__ */ E.jsx(
              "select",
              {
                name: "title.level",
                onChange: ({ currentTarget: x }) => {
                  s.document.update(
                    { title: { level: x.value } },
                    { render: !1 }
                  );
                },
                value: s.data.title.level,
                children: Object.entries(s.headingLevels).map(([x, _]) => /* @__PURE__ */ E.jsx("option", { value: x, children: _ }, x))
              }
            )
          ] }),
          /* @__PURE__ */ E.jsx("div", { className: "show-title", children: /* @__PURE__ */ E.jsxs("label", { className: "checkbox", children: [
            "Display Page Title",
            /* @__PURE__ */ E.jsx(
              "input",
              {
                type: "checkbox",
                name: "title.show",
                checked: p,
                onChange: ({ currentTarget: x }) => {
                  s.document.update(
                    { title: { show: x.checked } },
                    { render: !1 }
                  ), g(x.checked);
                }
              }
            )
          ] }) })
        ] })
      ] }),
      /* @__PURE__ */ E.jsx(Ufe, {})
    ] }),
    p && !s?.editable && /* @__PURE__ */ E.jsx("header", { className: "journal-page-header", children: /* @__PURE__ */ E.jsx("h1", { children: s?.data?.name }) }),
    /* @__PURE__ */ E.jsx(
      nie,
      {
        assetUrls: Yfe,
        config: e,
        store: t,
        onMount: S,
        userId: r,
        instanceId: a,
        children: /* @__PURE__ */ E.jsx(vde, { assetUrls: Kfe, overrides: Cde, children: /* @__PURE__ */ E.jsx(due, { children: /* @__PURE__ */ E.jsx(Lj, {}) }) })
      }
    )
  ] });
}, Gfe = $r.div`
    display: flex;
    flex-direction: column;
    height: 100%;
`;
var YP, ox = pm;
if ({}.NODE_ENV === "production")
  YP = ox.createRoot, ox.hydrateRoot;
else {
  var n3 = ox.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  YP = function(t, e) {
    n3.usingClientEntryPoint = !0;
    try {
      return ox.createRoot(t, e);
    } finally {
      n3.usingClientEntryPoint = !1;
    }
  };
}
class Xfe extends JournalPageSheet {
  constructor() {
    super(...arguments), this.root = null;
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      submitOnClose: !1,
      submitOnChange: !1
    });
  }
  async _renderInner(e) {
    return this.createForm(), this.componentDidMount(e), this.createReactRoot(e), $(this.form);
  }
  createForm() {
    this.form || (this.form = document.createElement("form"), this.form.setAttribute("autocomplete", "off"));
  }
  createReactRoot(e) {
    this.root || (this.root = YP(this.form)), this.root.render(
      /* @__PURE__ */ E.jsx(Afe, { sheet: e, form: $(this.form), children: this.reactComponent() })
    );
  }
  async _render(e = !1, n = {}) {
    if (!e && this._state === Application.RENDER_STATES.RENDERED) {
      this.refreshWindowTitle();
      return;
    }
    await super._render(e, n);
  }
  refreshWindowTitle() {
    let e = this.element.find(".window-title")[0];
    e && (e.hasChildNodes() && (e = e.childNodes[0]), e.textContent = this.title);
  }
  async close() {
    return this.root?.unmount(), this.root = null, await super.close();
  }
  deactivateListeners(e) {
    e.find("img[data-edit]").off("click"), e.find("input,select,textarea").off("change"), e.find("button.file-picker").off("click");
  }
  activateListeners(e) {
    this.deactivateListeners(e), super.activateListeners(e);
  }
  _activateEditor(e) {
  }
  async saveEditor(e, n = {}) {
  }
}
class qfe extends Xfe {
  constructor() {
    super(...arguments), this.handleMount = async (e) => {
      if (this.tldrawApp = e, jk.theme === "dark" ? this.tldrawApp.setDarkMode(!0) : this.tldrawApp.setDarkMode(!1), !this.isEditable) {
        this.tldrawApp.enableReadOnlyMode();
        return;
      }
      await this.enableCollaborativeEditing(e), this.enableAutoSave(), e.updateUser(this.user), e.updateUserPresence({ color: game.user.color });
    };
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      width: 960,
      height: 800,
      classes: ["sheet", "journal-entry-page", "journal-sheet", "journal-whiteboard.whiteboard"]
    });
  }
  componentDidMount(e) {
    this.tldrawConfig = new kb({
      shapes: Ffe(),
      tools: Hfe(),
      allowUnknownShapes: !0
    }), this.userId = $p.createCustomId(game.user.id), this.user = $p.create({
      id: this.userId,
      name: game.user.name
    }), this.instanceId = Rp.createCustomId(this.object.id), this.pageId = fr.createCustomId(this.object.id), this.page = fr.create({ id: this.pageId, name: e.title, index: "a0" }), this.store = this.tldrawConfig.createStore({
      initialData: {
        [this.pageId]: this.page,
        [this.userId]: this.user
      },
      userId: this.userId,
      instanceId: this.instanceId
    }), no.registerStore(this.instanceId, this.store);
    const n = this.object.system?.whiteboard;
    n && no.restoreSnapshot(this.instanceId, n);
  }
  async enableCollaborativeEditing(e) {
    !no.isCollaborativeMode() || !this.rendered || (zr.log("Collaborative editing is enabled."), await no.restoreFromRemote(this.instanceId), zr.log("Listening for remote changes."), no.connectUser(this.instanceId), this.removeStoreListener = e.store.listen((n) => {
      no.put(this.instanceId, n.changes, n.source);
    }));
  }
  reactComponent() {
    return /* @__PURE__ */ E.jsx(Nfe, { instanceId: this.instanceId, onSave: this.saveSnapshot.bind(this), children: /* @__PURE__ */ E.jsx(
      Wfe,
      {
        store: this.store,
        config: this.tldrawConfig,
        onMount: this.handleMount,
        userId: this.userId,
        instanceId: this.instanceId
      }
    ) });
  }
  async enableAutoSave() {
    if (!this.rendered || !this.isEditable)
      return;
    const e = game.settings.get("core", "editorAutosaveSecs");
    zr.log("Autosave is enabled"), this.autoSaveInterval = setInterval(async () => {
      zr.log("Autosaving..."), await this.saveSnapshot();
    }, e * 1e3);
  }
  async saveSnapshot() {
    const e = no.getSnapshot(this.instanceId);
    await this.object.update(
      { ["system.whiteboard"]: e },
      { diff: !1, recursive: !0 }
    ), zr.log("Saved");
  }
  async close() {
    return this.isEditable && await this.saveSnapshot(), this?.removeStoreListener(), no && no.disconnectUser(this.instanceId, this.userId), await super.close();
  }
}
const Qfe = {
  hooks: {
    async init() {
      zr.log("registering whiteboard data model"), Object.assign(CONFIG.JournalEntryPage.dataModels, {
        [`${Nu}.whiteboard`]: V7
      }), zr.log("registering journal whiteboard type"), DocumentSheetConfig.registerSheet(
        JournalEntryPage,
        Nu,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        qfe,
        {
          types: [`${Nu}.whiteboard`],
          label: game.i18n.localize("TYPES.JournalEntryPage.journal-whiteboard.whiteboard"),
          makeDefault: !0
        }
      );
    }
  }
}, Zfe = gi({
  type: "actor",
  getShapeUtil: () => U5
});
class U5 extends ya {
  constructor() {
    super(...arguments), this.isAspectRatioLocked = (e) => !1, this.canResize = (e) => !0, this.canBind = (e) => !0, this.getContextMenuItems = (e) => ({
      id: "actor-context-menu",
      type: "group",
      checkbox: !1,
      disabled: !1,
      readonlyOk: !0,
      children: [
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "render-sheet",
            label: game.i18n.localize("Sheet"),
            readonlyOk: !0,
            onSelect: async (...n) => {
              (await fromUuid(e.props.id)).sheet.render(!0);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        }
      ]
    });
  }
  // Default props — used for shapes created with the tool
  defaultProps() {
    return {
      opacity: "1",
      w: 100,
      h: 100,
      id: ""
    };
  }
  // Render method — the React component that will be rendered for the shape
  render(e) {
    const [n, r] = k.useState({
      img: foundry.CONST.DEFAULT_TOKEN,
      name: "Actor"
    });
    return k.useEffect(() => {
      async function a() {
        const s = await fromUuid(e.props.id);
        r(s);
      }
      a();
    }, [e.props.id]), /* @__PURE__ */ E.jsx(
      ha,
      {
        id: e.id,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          pointerEvents: "all"
        },
        children: /* @__PURE__ */ E.jsx(Jfe, { src: n.img, "data-edit": "img", alt: n.name })
      }
    );
  }
  // Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: e.props.w, height: e.props.h });
  }
}
U5.type = "actor";
const Jfe = $r.img`
    width: 100px;
    height: 100px;
    border: none;
`;
class Qx extends Dc {
  constructor() {
    super(...arguments), this.shapeType = "actor";
  }
}
Qx.id = "actor";
Qx.initial = "idle";
const epe = "/icons/svg/item-bag.svg", Ob = "item", tpe = gi({
  type: Ob,
  getShapeUtil: () => B5
});
class B5 extends ya {
  constructor() {
    super(...arguments), this.isAspectRatioLocked = (e) => !1, this.canResize = (e) => !0, this.canBind = (e) => !0, this.getContextMenuItems = (e) => ({
      id: "item-context-menu",
      type: "group",
      checkbox: !1,
      disabled: !1,
      readonlyOk: !0,
      children: [
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "render-sheet",
            label: game.i18n.localize("Sheet"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id)).sheet.render(!0);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        }
      ]
    });
  }
  // Default props — used for shapes created with the tool
  defaultProps() {
    return {
      opacity: "1",
      w: 200,
      h: 48,
      id: ""
    };
  }
  // Render method — the React component that will be rendered for the shape
  render(e) {
    const [n, r] = k.useState({
      name: Ob,
      img: epe
    });
    return k.useEffect(() => {
      async function a() {
        const s = await fromUuid(e.props.id);
        r(s);
      }
      a();
    }, [e.props.id]), /* @__PURE__ */ E.jsxs(
      ha,
      {
        id: e.id,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "start",
          pointerEvents: "all"
        },
        children: [
          /* @__PURE__ */ E.jsx(rpe, { src: n.img }),
          /* @__PURE__ */ E.jsx(npe, { children: n.name })
        ]
      }
    );
  }
  // Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: e.props.w, height: e.props.h });
  }
}
B5.type = Ob;
const npe = $r.div`
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
`, rpe = $r.img`
    width: 36px;
    height: 36px;
    margin-left: 8px;
    margin-right: 8px;
    border: none;
`;
let F5 = class extends Dc {
  constructor() {
    super(...arguments), this.shapeType = Ob;
  }
};
F5.id = Ob;
F5.initial = "idle";
const H1 = "journal_entry", ipe = gi({
  type: H1,
  getShapeUtil: () => H5
});
class H5 extends ya {
  constructor() {
    super(...arguments), this.isAspectRatioLocked = (e) => !1, this.canResize = (e) => !0, this.canBind = (e) => !0, this.getContextMenuItems = (e) => ({
      id: "journal-entry-context-menu",
      type: "group",
      checkbox: !1,
      disabled: !1,
      readonlyOk: !0,
      children: [
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "render-sheet",
            label: game.i18n.localize("DOCUMENT.JournalEntry"),
            readonlyOk: !0,
            onSelect: async (...n) => {
              (await fromUuid(e.props.id)).sheet.render(!0);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        }
      ]
    });
  }
  // Default props — used for shapes created with the tool
  defaultProps() {
    return {
      opacity: "1",
      w: 200,
      h: 48,
      id: ""
    };
  }
  // Render method — the React component that will be rendered for the shape
  render(e) {
    const [n, r] = k.useState({
      name: "Journal Entry"
    });
    return k.useEffect(() => {
      async function a() {
        const s = await fromUuid(e.props.id);
        r(s);
      }
      a();
    }, [e.props.id]), /* @__PURE__ */ E.jsxs(
      ha,
      {
        id: e.id,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "start",
          pointerEvents: "all"
        },
        children: [
          /* @__PURE__ */ E.jsx(ape, { children: /* @__PURE__ */ E.jsx("i", { className: "fas fa-book-open" }) }),
          /* @__PURE__ */ E.jsx(ope, { children: n.name })
        ]
      }
    );
  }
  // Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: e.props.w, height: e.props.h });
  }
}
H5.type = H1;
const ope = $r.div`
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
`, ape = $r.div`
    font-size: 24px;
    padding: 8px;
    padding-left: 16px;
`;
class N2 extends Dc {
  constructor() {
    super(...arguments), this.shapeType = H1;
  }
}
N2.id = H1;
N2.initial = "idle";
const V1 = "journal_entry_page", spe = gi({
  type: V1,
  getShapeUtil: () => V5
}), lpe = 100;
class V5 extends ya {
  constructor() {
    super(...arguments), this.isAspectRatioLocked = (e) => !1, this.canResize = (e) => !0, this.canBind = (e) => !0, this.getContextMenuItems = (e) => ({
      id: "journal-entry-page-context-menu",
      type: "group",
      checkbox: !1,
      disabled: !1,
      readonlyOk: !0,
      children: [
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "render-sheet",
            label: game.i18n.localize("DOCUMENT.JournalEntryPage"),
            readonlyOk: !0,
            onSelect: async (...n) => {
              (await fromUuid(e.props.id)).sheet.render(!0);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        }
      ]
    });
  }
  // Default props — used for shapes created with the tool
  defaultProps() {
    return {
      opacity: "1",
      w: 200,
      h: 48,
      id: ""
    };
  }
  // Render method — the React component that will be rendered for the shape
  render(e) {
    const n = It.useRef(null), [r, a] = k.useState({
      name: "Journal Entry"
    }), [s, c] = k.useState("");
    k.useEffect(() => {
      async function p() {
        const g = await fromUuid(e.props.id);
        a(g);
        const y = await TextEditor.enrichHTML(g.text.content, {
          secrets: g.isOwner,
          relativeTo: g,
          async: !0
        });
        c(y);
      }
      p();
    }, [e.props.id]);
    const f = this.bounds(e);
    return /* @__PURE__ */ E.jsx(
      ha,
      {
        id: e.id,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "start",
          pointerEvents: "all"
        },
        children: f.h > lpe ? /* @__PURE__ */ E.jsxs(cpe, { children: [
          /* @__PURE__ */ E.jsx(upe, { children: r.name }),
          /* @__PURE__ */ E.jsx(dpe, { ref: n, dangerouslySetInnerHTML: { __html: s } })
        ] }) : /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
          /* @__PURE__ */ E.jsx(ppe, { children: /* @__PURE__ */ E.jsx("i", { className: "fas fa-book-open" }) }),
          /* @__PURE__ */ E.jsx(fpe, { children: r.name })
        ] })
      }
    );
  }
  // Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: e.props.w, height: e.props.h });
  }
}
V5.type = V1;
const cpe = $r.div`
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
    color: var(--color-text-dark-primary);
    background: url(../ui/parchment.jpg) repeat;
    border: 2px solid #000;
    width: 100%;
    height: 100%;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 8px;
`, upe = $r.h1`
    user-select: text;
    pointer-events: all;
    touch-action: auto;
    overscroll-behavior: none;
`, dpe = $r.section`
    user-select: text;
    pointer-events: all;
    touch-action: auto;
    overscroll-behavior: none;
`, fpe = $r.div`
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
`, ppe = $r.div`
    font-size: 24px;
    padding: 8px;
    padding-left: 16px;
`;
class L2 extends Dc {
  constructor() {
    super(...arguments), this.shapeType = V1;
  }
}
L2.id = V1;
L2.initial = "idle";
const hpe = "/icons/svg/dice-target.svg", gpe = gi({
  type: "macro",
  getShapeUtil: () => Y5
});
class Y5 extends ya {
  constructor() {
    super(...arguments), this.isAspectRatioLocked = (e) => !1, this.canResize = (e) => !0, this.canBind = (e) => !0, this.getContextMenuItems = (e) => ({
      id: "macro-context-menu",
      type: "group",
      checkbox: !1,
      disabled: !1,
      readonlyOk: !0,
      children: [
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "execute-macro",
            label: game.i18n.localize("Executar Macro"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id))?.execute();
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        },
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "render-sheet",
            label: game.i18n.localize("MACRO.Edit"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id)).sheet.render(!0);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        }
      ]
    });
  }
  // Default props — used for shapes created with the tool
  defaultProps() {
    return {
      opacity: "1",
      w: 200,
      h: 48,
      id: ""
    };
  }
  // Render method — the React component that will be rendered for the shape
  render(e) {
    const [n, r] = k.useState({
      name: "Macro",
      img: hpe
    });
    return k.useEffect(() => {
      async function a() {
        const s = await fromUuid(e.props.id);
        r(s);
      }
      a();
    }, [e.props.id]), /* @__PURE__ */ E.jsxs(
      ha,
      {
        id: e.id,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "start",
          pointerEvents: "all"
        },
        children: [
          /* @__PURE__ */ E.jsx(vpe, { src: n.img }),
          /* @__PURE__ */ E.jsx(mpe, { children: n.name })
        ]
      }
    );
  }
  // Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: e.props.w, height: e.props.h });
  }
}
Y5.type = "macro";
const mpe = $r.div`
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
`, vpe = $r.img`
    width: 36px;
    height: 36px;
    margin-left: 8px;
    margin-right: 8px;
    border: none;
`;
class j2 extends Dc {
  constructor() {
    super(...arguments), this.shapeType = "macro";
  }
}
j2.id = "macro";
j2.initial = "idle";
const Y1 = "playlist", ype = gi({
  type: Y1,
  getShapeUtil: () => K5
});
class K5 extends ya {
  constructor() {
    super(...arguments), this.isAspectRatioLocked = (e) => !1, this.canResize = (e) => !0, this.canBind = (e) => !0, this.getContextMenuItems = (e) => {
      const n = fromUuidSync(e.props.id), r = [
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "render-sheet",
            label: game.i18n.localize("Configure"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id)).sheet.render(!0);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        }
      ];
      return n.playing ? r.unshift(
        {
          id: "playlist-stop",
          type: "item",
          actionItem: {
            id: "playlist-stop",
            label: game.i18n.localize("PLAYLIST.SoundStop"),
            readonlyOk: !0,
            onSelect: async () => {
              n.stopAll();
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !1
        }
      ) : r.unshift(
        {
          id: "playlist-play",
          type: "item",
          actionItem: {
            id: "playlist-play",
            label: game.i18n.localize("PLAYLIST.SoundPlay"),
            readonlyOk: !0,
            onSelect: async () => {
              n.playAll();
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !1
        }
      ), {
        id: "playlist-context-menu",
        type: "group",
        checkbox: !1,
        disabled: !1,
        readonlyOk: !0,
        children: r
      };
    };
  }
  // Default props — used for shapes created with the tool
  defaultProps() {
    return {
      opacity: "1",
      w: 200,
      h: 48,
      id: ""
    };
  }
  // Render method — the React component that will be rendered for the shape
  render(e) {
    const [n, r] = k.useState({
      name: "Playlit Sound",
      playing: !1,
      sound: null
    });
    return k.useEffect(() => {
      async function a() {
        const s = await fromUuid(e.props.id);
        r(s);
        for (const c of s.sounds)
          c.sound.on("start", async () => {
            const f = await fromUuid(e.props.id);
            r((p) => ({ ...p, playing: f.playing }));
          }), c.sound.on("stop", async () => {
            const f = await fromUuid(e.props.id);
            r((p) => ({ ...p, playing: f.playing }));
          });
      }
      a();
    }, [e.props.id]), /* @__PURE__ */ E.jsxs(
      ha,
      {
        id: e.id,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "start",
          pointerEvents: "all"
        },
        children: [
          /* @__PURE__ */ E.jsx(Spe, { playing: n.playing, children: n.playing ? /* @__PURE__ */ E.jsx("i", { className: "fas fa-square" }) : /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-play" }) }),
          /* @__PURE__ */ E.jsx(bpe, { children: n.name })
        ]
      }
    );
  }
  // Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: e.props.w, height: e.props.h });
  }
}
K5.type = Y1;
const bpe = $r.div`
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
`, Spe = $r.div`
    font-size: 24px;
    padding: 8px;
    padding-left: 16px;
    color: ${(t) => t.playing ? "var(--color-text-hyperlink)" : "var(--color-text)"};
`;
class z2 extends Dc {
  constructor() {
    super(...arguments), this.shapeType = Y1;
  }
}
z2.id = Y1;
z2.initial = "idle";
const wpe = gi({
  type: "playlist_sound",
  getShapeUtil: () => W5
});
class W5 extends ya {
  constructor() {
    super(...arguments), this.isAspectRatioLocked = (e) => !1, this.canResize = (e) => !0, this.canBind = (e) => !0, this.getContextMenuItems = (e) => {
      const n = fromUuidSync(e.props.id), r = [
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "render-sheet",
            label: game.i18n.localize("Configure"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id)).sheet.render(!0);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        }
      ];
      return n.sound.playing ? r.unshift(
        {
          id: "playlist-sound-stop",
          type: "item",
          actionItem: {
            id: "playlist-sound-stop",
            label: game.i18n.localize("PLAYLIST.SoundStop"),
            readonlyOk: !0,
            onSelect: async () => {
              n.parent.stopSound(n);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !1
        },
        {
          id: "playlist-sound-pause",
          type: "item",
          actionItem: {
            id: "playlist-sound-pause",
            label: game.i18n.localize("PLAYLIST.SoundPause"),
            readonlyOk: !0,
            onSelect: async () => {
              n.update({ playing: !1, pausedTime: n.sound.currentTime });
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !1
        }
      ) : r.unshift(
        {
          id: "playlist-sound-play",
          type: "item",
          actionItem: {
            id: "playlist-sound-play",
            label: game.i18n.localize("PLAYLIST.SoundPlay"),
            readonlyOk: !0,
            onSelect: async () => {
              n.parent.playSound(n);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !1
        }
      ), {
        id: "playlist-sound-context-menu",
        type: "group",
        checkbox: !1,
        disabled: !1,
        readonlyOk: !0,
        children: r
      };
    };
  }
  // Default props — used for shapes created with the tool
  defaultProps() {
    return {
      opacity: "1",
      w: 200,
      h: 48,
      id: ""
    };
  }
  // Render method — the React component that will be rendered for the shape
  render(e) {
    const [n, r] = k.useState({
      name: "Playlit Sound",
      playing: !1,
      sound: null
    });
    return k.useEffect(() => {
      async function a() {
        const s = await fromUuid(e.props.id);
        r(s), s.sound.on("start", async () => {
          r((c) => ({ ...c, playing: !0 }));
        }), s.sound.on("stop", async () => {
          r((c) => ({ ...c, playing: !1 }));
        });
      }
      a();
    }, [e.props.id]), /* @__PURE__ */ E.jsxs(
      ha,
      {
        id: e.id,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "start",
          pointerEvents: "all"
        },
        children: [
          /* @__PURE__ */ E.jsx(Epe, { playing: n.playing, children: n.playing ? /* @__PURE__ */ E.jsx("i", { className: "fas fa-square" }) : /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-play" }) }),
          /* @__PURE__ */ E.jsx(xpe, { children: n.name })
        ]
      }
    );
  }
  // Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: e.props.w, height: e.props.h });
  }
}
W5.type = "playlist_sound";
const xpe = $r.div`
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
`, Epe = $r.div`
    font-size: 24px;
    padding: 8px;
    padding-left: 16px;
    color: ${(t) => t.playing ? "var(--color-text-hyperlink)" : "var(--color-text)"};
`;
class U2 extends Dc {
  constructor() {
    super(...arguments), this.shapeType = "playlist_sound";
  }
}
U2.id = "playlist_sound";
U2.initial = "idle";
const Cpe = "/icons/svg/dice-target.svg", Db = "rolltable", _pe = gi({
  type: Db,
  getShapeUtil: () => G5
});
class G5 extends ya {
  constructor() {
    super(...arguments), this.isAspectRatioLocked = (e) => !1, this.canResize = (e) => !0, this.canBind = (e) => !0, this.getContextMenuItems = (e) => ({
      id: "rolltable-context-menu",
      type: "group",
      checkbox: !1,
      disabled: !1,
      readonlyOk: !0,
      children: [
        {
          id: "draw",
          type: "item",
          actionItem: {
            id: "draw",
            label: game.i18n.localize("Roll"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id))?.draw();
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        },
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "render-sheet",
            label: game.i18n.localize("Configure"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id)).sheet.render(!0);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        }
      ]
    });
  }
  // Default props — used for shapes created with the tool
  defaultProps() {
    return {
      opacity: "1",
      w: 200,
      h: 48,
      id: ""
    };
  }
  // Render method — the React component that will be rendered for the shape
  render(e) {
    const [n, r] = k.useState({
      name: Db,
      img: Cpe
    });
    return k.useEffect(() => {
      async function a() {
        const s = await fromUuid(e.props.id);
        r(s);
      }
      a();
    }, [e.props.id]), /* @__PURE__ */ E.jsxs(
      ha,
      {
        id: e.id,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "start",
          pointerEvents: "all"
        },
        children: [
          /* @__PURE__ */ E.jsx(kpe, { src: n.img }),
          /* @__PURE__ */ E.jsx(Tpe, { children: n.name })
        ]
      }
    );
  }
  // Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: e.props.w, height: e.props.h });
  }
}
G5.type = Db;
const Tpe = $r.div`
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
`, kpe = $r.img`
    width: 36px;
    height: 36px;
    margin-left: 8px;
    margin-right: 8px;
    border: none;
`;
class B2 extends Dc {
  constructor() {
    super(...arguments), this.shapeType = Db;
  }
}
B2.id = Db;
B2.initial = "idle";
const Nb = "scene", Ppe = gi({
  type: Nb,
  getShapeUtil: () => X5
});
class X5 extends ya {
  constructor() {
    super(...arguments), this.isAspectRatioLocked = (e) => !1, this.canResize = (e) => !0, this.canBind = (e) => !0, this.getContextMenuItems = (e) => ({
      id: "rolltable-context-menu",
      type: "group",
      checkbox: !1,
      disabled: !1,
      readonlyOk: !0,
      children: [
        {
          id: "scene-activate",
          type: "item",
          actionItem: {
            id: "scene-activate",
            label: game.i18n.localize("Activate"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id)).activate();
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        },
        {
          id: "scene-view",
          type: "item",
          actionItem: {
            id: "scene-view",
            label: game.i18n.localize("SCENES.View"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id)).view();
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        },
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "render-sheet",
            label: game.i18n.localize("Configure"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id)).sheet.render(!0);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        }
      ]
    });
  }
  // Default props — used for shapes created with the tool
  defaultProps() {
    return {
      opacity: "1",
      w: 200,
      h: 48,
      id: ""
    };
  }
  // Render method — the React component that will be rendered for the shape
  render(e) {
    const [n, r] = k.useState({
      name: Nb,
      thumb: ""
    });
    k.useEffect(() => {
      async function s() {
        const c = await fromUuid(e.props.id);
        r(c);
      }
      s();
    }, [e.props.id]);
    const a = this.bounds(e);
    return /* @__PURE__ */ E.jsx(
      ha,
      {
        id: e.id,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "start",
          pointerEvents: "all"
        },
        children: a.h > 100 ? /* @__PURE__ */ E.jsx(Ipe, { backgroundImage: n.thumb, children: /* @__PURE__ */ E.jsx(r3, { children: n.name }) }) : /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
          /* @__PURE__ */ E.jsx(Rpe, { children: /* @__PURE__ */ E.jsx("i", { className: "fas fa-map" }) }),
          /* @__PURE__ */ E.jsx(r3, { children: n.name })
        ] })
      }
    );
  }
  // Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: e.props.w, height: e.props.h });
  }
}
X5.type = Nb;
const r3 = $r.div`
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
`, Ipe = $r.div`
    border: none;
    background-image: url(${(t) => t.backgroundImage});
    display: flex;
    justify-content: center;
    align-items: center;    font-size: 1.5em;
    font-weight: normal;
    text-shadow: 1px 1px 3px var(--color-shadow-dark);
    background-position: 50% 50%;
    background-size: cover;
    background-repeat: no-repeat;
    width: 100%;
    height: 100%;
    color: var(--color-text-light-highlight);
`, Rpe = $r.div`
    font-size: 24px;
    padding: 8px;
    padding-left: 16px;
`;
class F2 extends Dc {
  constructor() {
    super(...arguments), this.shapeType = Nb;
  }
}
F2.id = Nb;
F2.initial = "idle";
const $pe = {
  hooks: {
    init() {
      zr.log("registering custom components"), Pu({
        shape: Zfe,
        tool: Qx,
        dataTransferType: "Actor"
      }), Pu({
        shape: gpe,
        tool: j2,
        dataTransferType: "Macro"
      }), Pu({
        shape: ype,
        tool: z2,
        dataTransferType: "Playlist"
      }), Pu({
        shape: wpe,
        tool: U2,
        dataTransferType: "PlaylistSound"
      }), Pu({
        shape: _pe,
        tool: B2,
        dataTransferType: "RollTable"
      }), Pu({
        shape: Ppe,
        tool: F2,
        dataTransferType: "Scene"
      }), Pu({
        shape: tpe,
        tool: Qx,
        dataTransferType: "Item"
      }), Pu({
        shape: ipe,
        tool: N2,
        dataTransferType: "JournalEntry"
      }), Pu({
        shape: spe,
        tool: L2,
        dataTransferType: "JournalEntryPage"
      });
    }
  }
}, H2 = [z7, Ofe, H7, $pe, Qfe];
Hooks.on("init", async () => {
  for (const t of H2)
    t?.hooks?.init && await t.hooks.init();
});
Hooks.on("ready", async () => {
  for (const t of H2)
    t?.hooks?.ready && await t.hooks.ready();
});
Hooks.once("socketlib.ready", async () => {
  for (const t of H2)
    t?.hooks?.socketlib && await t.hooks.socketlib();
});
//# sourceMappingURL=journal-whiteboard.js.map
