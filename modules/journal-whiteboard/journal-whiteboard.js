function A7(t, e) {
  for (var n = 0; n < e.length; n++) {
    const r = e[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const a in r)
        if (a !== "default" && !(a in t)) {
          const s = Object.getOwnPropertyDescriptor(r, a);
          s && Object.defineProperty(t, a, s.get ? s : {
            enumerable: !0,
            get: () => r[a]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
const Tp = "journal-whiteboard", zy = "Journal Whiteboard", O7 = (t) => {
  const e = {};
  for (const [n, r] of Object.entries(t))
    e[n] = {
      get() {
        return game.i18n.localize(r);
      }
    };
  return Object.defineProperties(t, e);
}, D7 = O7({
  light: "JW.ThemeLight",
  dark: "JW.ThemeDark"
});
class N7 {
  registerSettings() {
    game.settings.register(Tp, "theme", {
      name: game.i18n.localize("JW.Theme"),
      hint: game.i18n.localize("JW.ThemeHint"),
      scope: "world",
      config: !0,
      default: "light",
      choices: D7,
      type: String
    });
  }
  get theme() {
    return game.settings.get(Tp, "theme");
  }
}
let Dk;
const L7 = {
  hooks: {
    init() {
      Dk = new N7(), Dk.registerSettings();
    }
  }
};
class j7 extends foundry.abstract.TypeDataModel {
  static defineSchema() {
    const e = foundry.data.fields;
    return {
      whiteboard: new e.JSONField()
    };
  }
}
var ca = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Np(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Nk = { exports: {} }, Ey = {}, Lk = { exports: {} }, Tn = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wA;
function z7() {
  if (wA)
    return Tn;
  wA = 1;
  var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), c = Symbol.for("react.context"), f = Symbol.for("react.forward_ref"), p = Symbol.for("react.suspense"), g = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), v = Symbol.iterator;
  function S(W) {
    return W === null || typeof W != "object" ? null : (W = v && W[v] || W["@@iterator"], typeof W == "function" ? W : null);
  }
  var x = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, _ = Object.assign, T = {};
  function I(W, fe, ce) {
    this.props = W, this.context = fe, this.refs = T, this.updater = ce || x;
  }
  I.prototype.isReactComponent = {}, I.prototype.setState = function(W, fe) {
    if (typeof W != "object" && typeof W != "function" && W != null)
      throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, W, fe, "setState");
  }, I.prototype.forceUpdate = function(W) {
    this.updater.enqueueForceUpdate(this, W, "forceUpdate");
  };
  function D() {
  }
  D.prototype = I.prototype;
  function N(W, fe, ce) {
    this.props = W, this.context = fe, this.refs = T, this.updater = ce || x;
  }
  var j = N.prototype = new D();
  j.constructor = N, _(j, I.prototype), j.isPureReactComponent = !0;
  var L = Array.isArray, z = Object.prototype.hasOwnProperty, F = { current: null }, K = { key: !0, ref: !0, __self: !0, __source: !0 };
  function X(W, fe, ce) {
    var xe, $e = {}, Me = null, re = null;
    if (fe != null)
      for (xe in fe.ref !== void 0 && (re = fe.ref), fe.key !== void 0 && (Me = "" + fe.key), fe)
        z.call(fe, xe) && !K.hasOwnProperty(xe) && ($e[xe] = fe[xe]);
    var Qe = arguments.length - 2;
    if (Qe === 1)
      $e.children = ce;
    else if (1 < Qe) {
      for (var ke = Array(Qe), rt = 0; rt < Qe; rt++)
        ke[rt] = arguments[rt + 2];
      $e.children = ke;
    }
    if (W && W.defaultProps)
      for (xe in Qe = W.defaultProps, Qe)
        $e[xe] === void 0 && ($e[xe] = Qe[xe]);
    return { $$typeof: t, type: W, key: Me, ref: re, props: $e, _owner: F.current };
  }
  function se(W, fe) {
    return { $$typeof: t, type: W.type, key: fe, ref: W.ref, props: W.props, _owner: W._owner };
  }
  function ue(W) {
    return typeof W == "object" && W !== null && W.$$typeof === t;
  }
  function pe(W) {
    var fe = { "=": "=0", ":": "=2" };
    return "$" + W.replace(/[=:]/g, function(ce) {
      return fe[ce];
    });
  }
  var Pe = /\/+/g;
  function ve(W, fe) {
    return typeof W == "object" && W !== null && W.key != null ? pe("" + W.key) : fe.toString(36);
  }
  function Y(W, fe, ce, xe, $e) {
    var Me = typeof W;
    (Me === "undefined" || Me === "boolean") && (W = null);
    var re = !1;
    if (W === null)
      re = !0;
    else
      switch (Me) {
        case "string":
        case "number":
          re = !0;
          break;
        case "object":
          switch (W.$$typeof) {
            case t:
            case e:
              re = !0;
          }
      }
    if (re)
      return re = W, $e = $e(re), W = xe === "" ? "." + ve(re, 0) : xe, L($e) ? (ce = "", W != null && (ce = W.replace(Pe, "$&/") + "/"), Y($e, fe, ce, "", function(rt) {
        return rt;
      })) : $e != null && (ue($e) && ($e = se($e, ce + (!$e.key || re && re.key === $e.key ? "" : ("" + $e.key).replace(Pe, "$&/") + "/") + W)), fe.push($e)), 1;
    if (re = 0, xe = xe === "" ? "." : xe + ":", L(W))
      for (var Qe = 0; Qe < W.length; Qe++) {
        Me = W[Qe];
        var ke = xe + ve(Me, Qe);
        re += Y(Me, fe, ce, ke, $e);
      }
    else if (ke = S(W), typeof ke == "function")
      for (W = ke.call(W), Qe = 0; !(Me = W.next()).done; )
        Me = Me.value, ke = xe + ve(Me, Qe++), re += Y(Me, fe, ce, ke, $e);
    else if (Me === "object")
      throw fe = String(W), Error("Objects are not valid as a React child (found: " + (fe === "[object Object]" ? "object with keys {" + Object.keys(W).join(", ") + "}" : fe) + "). If you meant to render a collection of children, use an array instead.");
    return re;
  }
  function le(W, fe, ce) {
    if (W == null)
      return W;
    var xe = [], $e = 0;
    return Y(W, xe, "", "", function(Me) {
      return fe.call(ce, Me, $e++);
    }), xe;
  }
  function Re(W) {
    if (W._status === -1) {
      var fe = W._result;
      fe = fe(), fe.then(function(ce) {
        (W._status === 0 || W._status === -1) && (W._status = 1, W._result = ce);
      }, function(ce) {
        (W._status === 0 || W._status === -1) && (W._status = 2, W._result = ce);
      }), W._status === -1 && (W._status = 0, W._result = fe);
    }
    if (W._status === 1)
      return W._result.default;
    throw W._result;
  }
  var he = { current: null }, te = { transition: null }, de = { ReactCurrentDispatcher: he, ReactCurrentBatchConfig: te, ReactCurrentOwner: F };
  return Tn.Children = { map: le, forEach: function(W, fe, ce) {
    le(W, function() {
      fe.apply(this, arguments);
    }, ce);
  }, count: function(W) {
    var fe = 0;
    return le(W, function() {
      fe++;
    }), fe;
  }, toArray: function(W) {
    return le(W, function(fe) {
      return fe;
    }) || [];
  }, only: function(W) {
    if (!ue(W))
      throw Error("React.Children.only expected to receive a single React element child.");
    return W;
  } }, Tn.Component = I, Tn.Fragment = n, Tn.Profiler = a, Tn.PureComponent = N, Tn.StrictMode = r, Tn.Suspense = p, Tn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = de, Tn.cloneElement = function(W, fe, ce) {
    if (W == null)
      throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + W + ".");
    var xe = _({}, W.props), $e = W.key, Me = W.ref, re = W._owner;
    if (fe != null) {
      if (fe.ref !== void 0 && (Me = fe.ref, re = F.current), fe.key !== void 0 && ($e = "" + fe.key), W.type && W.type.defaultProps)
        var Qe = W.type.defaultProps;
      for (ke in fe)
        z.call(fe, ke) && !K.hasOwnProperty(ke) && (xe[ke] = fe[ke] === void 0 && Qe !== void 0 ? Qe[ke] : fe[ke]);
    }
    var ke = arguments.length - 2;
    if (ke === 1)
      xe.children = ce;
    else if (1 < ke) {
      Qe = Array(ke);
      for (var rt = 0; rt < ke; rt++)
        Qe[rt] = arguments[rt + 2];
      xe.children = Qe;
    }
    return { $$typeof: t, type: W.type, key: $e, ref: Me, props: xe, _owner: re };
  }, Tn.createContext = function(W) {
    return W = { $$typeof: c, _currentValue: W, _currentValue2: W, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, W.Provider = { $$typeof: s, _context: W }, W.Consumer = W;
  }, Tn.createElement = X, Tn.createFactory = function(W) {
    var fe = X.bind(null, W);
    return fe.type = W, fe;
  }, Tn.createRef = function() {
    return { current: null };
  }, Tn.forwardRef = function(W) {
    return { $$typeof: f, render: W };
  }, Tn.isValidElement = ue, Tn.lazy = function(W) {
    return { $$typeof: y, _payload: { _status: -1, _result: W }, _init: Re };
  }, Tn.memo = function(W, fe) {
    return { $$typeof: g, type: W, compare: fe === void 0 ? null : fe };
  }, Tn.startTransition = function(W) {
    var fe = te.transition;
    te.transition = {};
    try {
      W();
    } finally {
      te.transition = fe;
    }
  }, Tn.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.");
  }, Tn.useCallback = function(W, fe) {
    return he.current.useCallback(W, fe);
  }, Tn.useContext = function(W) {
    return he.current.useContext(W);
  }, Tn.useDebugValue = function() {
  }, Tn.useDeferredValue = function(W) {
    return he.current.useDeferredValue(W);
  }, Tn.useEffect = function(W, fe) {
    return he.current.useEffect(W, fe);
  }, Tn.useId = function() {
    return he.current.useId();
  }, Tn.useImperativeHandle = function(W, fe, ce) {
    return he.current.useImperativeHandle(W, fe, ce);
  }, Tn.useInsertionEffect = function(W, fe) {
    return he.current.useInsertionEffect(W, fe);
  }, Tn.useLayoutEffect = function(W, fe) {
    return he.current.useLayoutEffect(W, fe);
  }, Tn.useMemo = function(W, fe) {
    return he.current.useMemo(W, fe);
  }, Tn.useReducer = function(W, fe, ce) {
    return he.current.useReducer(W, fe, ce);
  }, Tn.useRef = function(W) {
    return he.current.useRef(W);
  }, Tn.useState = function(W) {
    return he.current.useState(W);
  }, Tn.useSyncExternalStore = function(W, fe, ce) {
    return he.current.useSyncExternalStore(W, fe, ce);
  }, Tn.useTransition = function() {
    return he.current.useTransition();
  }, Tn.version = "18.2.0", Tn;
}
var Oy = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Oy.exports;
var xA;
function U7() {
  return xA || (xA = 1, function(t, e) {
    ({}).NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var n = "18.2.0", r = Symbol.for("react.element"), a = Symbol.for("react.portal"), s = Symbol.for("react.fragment"), c = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), p = Symbol.for("react.provider"), g = Symbol.for("react.context"), y = Symbol.for("react.forward_ref"), v = Symbol.for("react.suspense"), S = Symbol.for("react.suspense_list"), x = Symbol.for("react.memo"), _ = Symbol.for("react.lazy"), T = Symbol.for("react.offscreen"), I = Symbol.iterator, D = "@@iterator";
      function N(U) {
        if (U === null || typeof U != "object")
          return null;
        var Z = I && U[I] || U[D];
        return typeof Z == "function" ? Z : null;
      }
      var j = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, L = {
        transition: null
      }, z = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, F = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, K = {}, X = null;
      function se(U) {
        X = U;
      }
      K.setExtraStackFrame = function(U) {
        X = U;
      }, K.getCurrentStack = null, K.getStackAddendum = function() {
        var U = "";
        X && (U += X);
        var Z = K.getCurrentStack;
        return Z && (U += Z() || ""), U;
      };
      var ue = !1, pe = !1, Pe = !1, ve = !1, Y = !1, le = {
        ReactCurrentDispatcher: j,
        ReactCurrentBatchConfig: L,
        ReactCurrentOwner: F
      };
      le.ReactDebugCurrentFrame = K, le.ReactCurrentActQueue = z;
      function Re(U) {
        {
          for (var Z = arguments.length, ye = new Array(Z > 1 ? Z - 1 : 0), Ee = 1; Ee < Z; Ee++)
            ye[Ee - 1] = arguments[Ee];
          te("warn", U, ye);
        }
      }
      function he(U) {
        {
          for (var Z = arguments.length, ye = new Array(Z > 1 ? Z - 1 : 0), Ee = 1; Ee < Z; Ee++)
            ye[Ee - 1] = arguments[Ee];
          te("error", U, ye);
        }
      }
      function te(U, Z, ye) {
        {
          var Ee = le.ReactDebugCurrentFrame, Fe = Ee.getStackAddendum();
          Fe !== "" && (Z += "%s", ye = ye.concat([Fe]));
          var ht = ye.map(function(Ze) {
            return String(Ze);
          });
          ht.unshift("Warning: " + Z), Function.prototype.apply.call(console[U], console, ht);
        }
      }
      var de = {};
      function W(U, Z) {
        {
          var ye = U.constructor, Ee = ye && (ye.displayName || ye.name) || "ReactClass", Fe = Ee + "." + Z;
          if (de[Fe])
            return;
          he("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", Z, Ee), de[Fe] = !0;
        }
      }
      var fe = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(U) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(U, Z, ye) {
          W(U, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(U, Z, ye, Ee) {
          W(U, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(U, Z, ye, Ee) {
          W(U, "setState");
        }
      }, ce = Object.assign, xe = {};
      Object.freeze(xe);
      function $e(U, Z, ye) {
        this.props = U, this.context = Z, this.refs = xe, this.updater = ye || fe;
      }
      $e.prototype.isReactComponent = {}, $e.prototype.setState = function(U, Z) {
        if (typeof U != "object" && typeof U != "function" && U != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, U, Z, "setState");
      }, $e.prototype.forceUpdate = function(U) {
        this.updater.enqueueForceUpdate(this, U, "forceUpdate");
      };
      {
        var Me = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, re = function(U, Z) {
          Object.defineProperty($e.prototype, U, {
            get: function() {
              Re("%s(...) is deprecated in plain JavaScript React classes. %s", Z[0], Z[1]);
            }
          });
        };
        for (var Qe in Me)
          Me.hasOwnProperty(Qe) && re(Qe, Me[Qe]);
      }
      function ke() {
      }
      ke.prototype = $e.prototype;
      function rt(U, Z, ye) {
        this.props = U, this.context = Z, this.refs = xe, this.updater = ye || fe;
      }
      var St = rt.prototype = new ke();
      St.constructor = rt, ce(St, $e.prototype), St.isPureReactComponent = !0;
      function Tt() {
        var U = {
          current: null
        };
        return Object.seal(U), U;
      }
      var Le = Array.isArray;
      function Nt(U) {
        return Le(U);
      }
      function Ke(U) {
        {
          var Z = typeof Symbol == "function" && Symbol.toStringTag, ye = Z && U[Symbol.toStringTag] || U.constructor.name || "Object";
          return ye;
        }
      }
      function yt(U) {
        try {
          return Xt(U), !1;
        } catch {
          return !0;
        }
      }
      function Xt(U) {
        return "" + U;
      }
      function kt(U) {
        if (yt(U))
          return he("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ke(U)), Xt(U);
      }
      function yn(U, Z, ye) {
        var Ee = U.displayName;
        if (Ee)
          return Ee;
        var Fe = Z.displayName || Z.name || "";
        return Fe !== "" ? ye + "(" + Fe + ")" : ye;
      }
      function Er(U) {
        return U.displayName || "Context";
      }
      function tn(U) {
        if (U == null)
          return null;
        if (typeof U.tag == "number" && he("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof U == "function")
          return U.displayName || U.name || null;
        if (typeof U == "string")
          return U;
        switch (U) {
          case s:
            return "Fragment";
          case a:
            return "Portal";
          case f:
            return "Profiler";
          case c:
            return "StrictMode";
          case v:
            return "Suspense";
          case S:
            return "SuspenseList";
        }
        if (typeof U == "object")
          switch (U.$$typeof) {
            case g:
              var Z = U;
              return Er(Z) + ".Consumer";
            case p:
              var ye = U;
              return Er(ye._context) + ".Provider";
            case y:
              return yn(U, U.render, "ForwardRef");
            case x:
              var Ee = U.displayName || null;
              return Ee !== null ? Ee : tn(U.type) || "Memo";
            case _: {
              var Fe = U, ht = Fe._payload, Ze = Fe._init;
              try {
                return tn(Ze(ht));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var Mr = Object.prototype.hasOwnProperty, zr = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, Hn, xt, cn;
      cn = {};
      function ti(U) {
        if (Mr.call(U, "ref")) {
          var Z = Object.getOwnPropertyDescriptor(U, "ref").get;
          if (Z && Z.isReactWarning)
            return !1;
        }
        return U.ref !== void 0;
      }
      function An(U) {
        if (Mr.call(U, "key")) {
          var Z = Object.getOwnPropertyDescriptor(U, "key").get;
          if (Z && Z.isReactWarning)
            return !1;
        }
        return U.key !== void 0;
      }
      function qn(U, Z) {
        var ye = function() {
          Hn || (Hn = !0, he("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Z));
        };
        ye.isReactWarning = !0, Object.defineProperty(U, "key", {
          get: ye,
          configurable: !0
        });
      }
      function Ko(U, Z) {
        var ye = function() {
          xt || (xt = !0, he("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Z));
        };
        ye.isReactWarning = !0, Object.defineProperty(U, "ref", {
          get: ye,
          configurable: !0
        });
      }
      function Cr(U) {
        if (typeof U.ref == "string" && F.current && U.__self && F.current.stateNode !== U.__self) {
          var Z = tn(F.current.type);
          cn[Z] || (he('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Z, U.ref), cn[Z] = !0);
        }
      }
      var Je = function(U, Z, ye, Ee, Fe, ht, Ze) {
        var bt = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: r,
          // Built-in properties that belong on the element
          type: U,
          key: Z,
          ref: ye,
          props: Ze,
          // Record the component responsible for creating this element.
          _owner: ht
        };
        return bt._store = {}, Object.defineProperty(bt._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(bt, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Ee
        }), Object.defineProperty(bt, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Fe
        }), Object.freeze && (Object.freeze(bt.props), Object.freeze(bt)), bt;
      };
      function Et(U, Z, ye) {
        var Ee, Fe = {}, ht = null, Ze = null, bt = null, Yt = null;
        if (Z != null) {
          ti(Z) && (Ze = Z.ref, Cr(Z)), An(Z) && (kt(Z.key), ht = "" + Z.key), bt = Z.__self === void 0 ? null : Z.__self, Yt = Z.__source === void 0 ? null : Z.__source;
          for (Ee in Z)
            Mr.call(Z, Ee) && !zr.hasOwnProperty(Ee) && (Fe[Ee] = Z[Ee]);
        }
        var gn = arguments.length - 2;
        if (gn === 1)
          Fe.children = ye;
        else if (gn > 1) {
          for (var Ln = Array(gn), In = 0; In < gn; In++)
            Ln[In] = arguments[In + 2];
          Object.freeze && Object.freeze(Ln), Fe.children = Ln;
        }
        if (U && U.defaultProps) {
          var ar = U.defaultProps;
          for (Ee in ar)
            Fe[Ee] === void 0 && (Fe[Ee] = ar[Ee]);
        }
        if (ht || Ze) {
          var dr = typeof U == "function" ? U.displayName || U.name || "Unknown" : U;
          ht && qn(Fe, dr), Ze && Ko(Fe, dr);
        }
        return Je(U, ht, Ze, bt, Yt, F.current, Fe);
      }
      function nn(U, Z) {
        var ye = Je(U.type, Z, U.ref, U._self, U._source, U._owner, U.props);
        return ye;
      }
      function kn(U, Z, ye) {
        if (U == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + U + ".");
        var Ee, Fe = ce({}, U.props), ht = U.key, Ze = U.ref, bt = U._self, Yt = U._source, gn = U._owner;
        if (Z != null) {
          ti(Z) && (Ze = Z.ref, gn = F.current), An(Z) && (kt(Z.key), ht = "" + Z.key);
          var Ln;
          U.type && U.type.defaultProps && (Ln = U.type.defaultProps);
          for (Ee in Z)
            Mr.call(Z, Ee) && !zr.hasOwnProperty(Ee) && (Z[Ee] === void 0 && Ln !== void 0 ? Fe[Ee] = Ln[Ee] : Fe[Ee] = Z[Ee]);
        }
        var In = arguments.length - 2;
        if (In === 1)
          Fe.children = ye;
        else if (In > 1) {
          for (var ar = Array(In), dr = 0; dr < In; dr++)
            ar[dr] = arguments[dr + 2];
          Fe.children = ar;
        }
        return Je(U.type, ht, Ze, bt, Yt, gn, Fe);
      }
      function xn(U) {
        return typeof U == "object" && U !== null && U.$$typeof === r;
      }
      var _r = ".", ur = ":";
      function hi(U) {
        var Z = /[=:]/g, ye = {
          "=": "=0",
          ":": "=2"
        }, Ee = U.replace(Z, function(Fe) {
          return ye[Fe];
        });
        return "$" + Ee;
      }
      var pn = !1, gi = /\/+/g;
      function On(U) {
        return U.replace(gi, "$&/");
      }
      function Dn(U, Z) {
        return typeof U == "object" && U !== null && U.key != null ? (kt(U.key), hi("" + U.key)) : Z.toString(36);
      }
      function io(U, Z, ye, Ee, Fe) {
        var ht = typeof U;
        (ht === "undefined" || ht === "boolean") && (U = null);
        var Ze = !1;
        if (U === null)
          Ze = !0;
        else
          switch (ht) {
            case "string":
            case "number":
              Ze = !0;
              break;
            case "object":
              switch (U.$$typeof) {
                case r:
                case a:
                  Ze = !0;
              }
          }
        if (Ze) {
          var bt = U, Yt = Fe(bt), gn = Ee === "" ? _r + Dn(bt, 0) : Ee;
          if (Nt(Yt)) {
            var Ln = "";
            gn != null && (Ln = On(gn) + "/"), io(Yt, Z, Ln, "", function(vm) {
              return vm;
            });
          } else
            Yt != null && (xn(Yt) && (Yt.key && (!bt || bt.key !== Yt.key) && kt(Yt.key), Yt = nn(
              Yt,
              // Keep both the (mapped) and old keys if they differ, just as
              // traverseAllChildren used to do for objects as children
              ye + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
              (Yt.key && (!bt || bt.key !== Yt.key) ? (
                // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                // eslint-disable-next-line react-internal/safe-string-coercion
                On("" + Yt.key) + "/"
              ) : "") + gn
            )), Z.push(Yt));
          return 1;
        }
        var In, ar, dr = 0, Sn = Ee === "" ? _r : Ee + ur;
        if (Nt(U))
          for (var Js = 0; Js < U.length; Js++)
            In = U[Js], ar = Sn + Dn(In, Js), dr += io(In, Z, ye, ar, Fe);
        else {
          var Hu = N(U);
          if (typeof Hu == "function") {
            var pf = U;
            Hu === pf.entries && (pn || Re("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), pn = !0);
            for (var mm = Hu.call(pf), Za, hf = 0; !(Za = mm.next()).done; )
              In = Za.value, ar = Sn + Dn(In, hf++), dr += io(In, Z, ye, ar, Fe);
          } else if (ht === "object") {
            var gf = String(U);
            throw new Error("Objects are not valid as a React child (found: " + (gf === "[object Object]" ? "object with keys {" + Object.keys(U).join(", ") + "}" : gf) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return dr;
      }
      function mi(U, Z, ye) {
        if (U == null)
          return U;
        var Ee = [], Fe = 0;
        return io(U, Ee, "", "", function(ht) {
          return Z.call(ye, ht, Fe++);
        }), Ee;
      }
      function ya(U) {
        var Z = 0;
        return mi(U, function() {
          Z++;
        }), Z;
      }
      function Xa(U, Z, ye) {
        mi(U, function() {
          Z.apply(this, arguments);
        }, ye);
      }
      function gs(U) {
        return mi(U, function(Z) {
          return Z;
        }) || [];
      }
      function oo(U) {
        if (!xn(U))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return U;
      }
      function ms(U) {
        var Z = {
          $$typeof: g,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: U,
          _currentValue2: U,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        Z.Provider = {
          $$typeof: p,
          _context: Z
        };
        var ye = !1, Ee = !1, Fe = !1;
        {
          var ht = {
            $$typeof: g,
            _context: Z
          };
          Object.defineProperties(ht, {
            Provider: {
              get: function() {
                return Ee || (Ee = !0, he("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), Z.Provider;
              },
              set: function(Ze) {
                Z.Provider = Ze;
              }
            },
            _currentValue: {
              get: function() {
                return Z._currentValue;
              },
              set: function(Ze) {
                Z._currentValue = Ze;
              }
            },
            _currentValue2: {
              get: function() {
                return Z._currentValue2;
              },
              set: function(Ze) {
                Z._currentValue2 = Ze;
              }
            },
            _threadCount: {
              get: function() {
                return Z._threadCount;
              },
              set: function(Ze) {
                Z._threadCount = Ze;
              }
            },
            Consumer: {
              get: function() {
                return ye || (ye = !0, he("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), Z.Consumer;
              }
            },
            displayName: {
              get: function() {
                return Z.displayName;
              },
              set: function(Ze) {
                Fe || (Re("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", Ze), Fe = !0);
              }
            }
          }), Z.Consumer = ht;
        }
        return Z._currentRenderer = null, Z._currentRenderer2 = null, Z;
      }
      var ao = -1, ba = 0, so = 1, Sa = 2;
      function vi(U) {
        if (U._status === ao) {
          var Z = U._result, ye = Z();
          if (ye.then(function(ht) {
            if (U._status === ba || U._status === ao) {
              var Ze = U;
              Ze._status = so, Ze._result = ht;
            }
          }, function(ht) {
            if (U._status === ba || U._status === ao) {
              var Ze = U;
              Ze._status = Sa, Ze._result = ht;
            }
          }), U._status === ao) {
            var Ee = U;
            Ee._status = ba, Ee._result = ye;
          }
        }
        if (U._status === so) {
          var Fe = U._result;
          return Fe === void 0 && he(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, Fe), "default" in Fe || he(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, Fe), Fe.default;
        } else
          throw U._result;
      }
      function Ri(U) {
        var Z = {
          // We use these fields to store the result.
          _status: ao,
          _result: U
        }, ye = {
          $$typeof: _,
          _payload: Z,
          _init: vi
        };
        {
          var Ee, Fe;
          Object.defineProperties(ye, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return Ee;
              },
              set: function(ht) {
                he("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Ee = ht, Object.defineProperty(ye, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return Fe;
              },
              set: function(ht) {
                he("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Fe = ht, Object.defineProperty(ye, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return ye;
      }
      function yi(U) {
        U != null && U.$$typeof === x ? he("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof U != "function" ? he("forwardRef requires a render function but was given %s.", U === null ? "null" : typeof U) : U.length !== 0 && U.length !== 2 && he("forwardRef render functions accept exactly two parameters: props and ref. %s", U.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), U != null && (U.defaultProps != null || U.propTypes != null) && he("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var Z = {
          $$typeof: y,
          render: U
        };
        {
          var ye;
          Object.defineProperty(Z, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return ye;
            },
            set: function(Ee) {
              ye = Ee, !U.name && !U.displayName && (U.displayName = Ee);
            }
          });
        }
        return Z;
      }
      var J;
      J = Symbol.for("react.module.reference");
      function Be(U) {
        return !!(typeof U == "string" || typeof U == "function" || U === s || U === f || Y || U === c || U === v || U === S || ve || U === T || ue || pe || Pe || typeof U == "object" && U !== null && (U.$$typeof === _ || U.$$typeof === x || U.$$typeof === p || U.$$typeof === g || U.$$typeof === y || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        U.$$typeof === J || U.getModuleId !== void 0));
      }
      function et(U, Z) {
        Be(U) || he("memo: The first argument must be a component. Instead received: %s", U === null ? "null" : typeof U);
        var ye = {
          $$typeof: x,
          type: U,
          compare: Z === void 0 ? null : Z
        };
        {
          var Ee;
          Object.defineProperty(ye, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return Ee;
            },
            set: function(Fe) {
              Ee = Fe, !U.name && !U.displayName && (U.displayName = Fe);
            }
          });
        }
        return ye;
      }
      function st() {
        var U = j.current;
        return U === null && he(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), U;
      }
      function Kt(U) {
        var Z = st();
        if (U._context !== void 0) {
          var ye = U._context;
          ye.Consumer === U ? he("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : ye.Provider === U && he("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return Z.useContext(U);
      }
      function qt(U) {
        var Z = st();
        return Z.useState(U);
      }
      function Qt(U, Z, ye) {
        var Ee = st();
        return Ee.useReducer(U, Z, ye);
      }
      function Rt(U) {
        var Z = st();
        return Z.useRef(U);
      }
      function Ur(U, Z) {
        var ye = st();
        return ye.useEffect(U, Z);
      }
      function Qn(U, Z) {
        var ye = st();
        return ye.useInsertionEffect(U, Z);
      }
      function Zn(U, Z) {
        var ye = st();
        return ye.useLayoutEffect(U, Z);
      }
      function hr(U, Z) {
        var ye = st();
        return ye.useCallback(U, Z);
      }
      function wa(U, Z) {
        var ye = st();
        return ye.useMemo(U, Z);
      }
      function Nl(U, Z, ye) {
        var Ee = st();
        return Ee.useImperativeHandle(U, Z, ye);
      }
      function bn(U, Z) {
        {
          var ye = st();
          return ye.useDebugValue(U, Z);
        }
      }
      function df() {
        var U = st();
        return U.useTransition();
      }
      function Wo(U) {
        var Z = st();
        return Z.useDeferredValue(U);
      }
      function Jt() {
        var U = st();
        return U.useId();
      }
      function xa(U, Z, ye) {
        var Ee = st();
        return Ee.useSyncExternalStore(U, Z, ye);
      }
      var vs = 0, lo, ys, Ki, Nc, $i, Lc, jc;
      function Xs() {
      }
      Xs.__reactDisabledLog = !0;
      function Ll() {
        {
          if (vs === 0) {
            lo = console.log, ys = console.info, Ki = console.warn, Nc = console.error, $i = console.group, Lc = console.groupCollapsed, jc = console.groupEnd;
            var U = {
              configurable: !0,
              enumerable: !0,
              value: Xs,
              writable: !0
            };
            Object.defineProperties(console, {
              info: U,
              log: U,
              warn: U,
              error: U,
              group: U,
              groupCollapsed: U,
              groupEnd: U
            });
          }
          vs++;
        }
      }
      function To() {
        {
          if (vs--, vs === 0) {
            var U = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: ce({}, U, {
                value: lo
              }),
              info: ce({}, U, {
                value: ys
              }),
              warn: ce({}, U, {
                value: Ki
              }),
              error: ce({}, U, {
                value: Nc
              }),
              group: ce({}, U, {
                value: $i
              }),
              groupCollapsed: ce({}, U, {
                value: Lc
              }),
              groupEnd: ce({}, U, {
                value: jc
              })
            });
          }
          vs < 0 && he("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var ko = le.ReactCurrentDispatcher, bi;
      function bs(U, Z, ye) {
        {
          if (bi === void 0)
            try {
              throw Error();
            } catch (Fe) {
              var Ee = Fe.stack.trim().match(/\n( *(at )?)/);
              bi = Ee && Ee[1] || "";
            }
          return `
` + bi + U;
        }
      }
      var Ss = !1, ws;
      {
        var jl = typeof WeakMap == "function" ? WeakMap : Map;
        ws = new jl();
      }
      function qs(U, Z) {
        if (!U || Ss)
          return "";
        {
          var ye = ws.get(U);
          if (ye !== void 0)
            return ye;
        }
        var Ee;
        Ss = !0;
        var Fe = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var ht;
        ht = ko.current, ko.current = null, Ll();
        try {
          if (Z) {
            var Ze = function() {
              throw Error();
            };
            if (Object.defineProperty(Ze.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Ze, []);
              } catch (Sn) {
                Ee = Sn;
              }
              Reflect.construct(U, [], Ze);
            } else {
              try {
                Ze.call();
              } catch (Sn) {
                Ee = Sn;
              }
              U.call(Ze.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Sn) {
              Ee = Sn;
            }
            U();
          }
        } catch (Sn) {
          if (Sn && Ee && typeof Sn.stack == "string") {
            for (var bt = Sn.stack.split(`
`), Yt = Ee.stack.split(`
`), gn = bt.length - 1, Ln = Yt.length - 1; gn >= 1 && Ln >= 0 && bt[gn] !== Yt[Ln]; )
              Ln--;
            for (; gn >= 1 && Ln >= 0; gn--, Ln--)
              if (bt[gn] !== Yt[Ln]) {
                if (gn !== 1 || Ln !== 1)
                  do
                    if (gn--, Ln--, Ln < 0 || bt[gn] !== Yt[Ln]) {
                      var In = `
` + bt[gn].replace(" at new ", " at ");
                      return U.displayName && In.includes("<anonymous>") && (In = In.replace("<anonymous>", U.displayName)), typeof U == "function" && ws.set(U, In), In;
                    }
                  while (gn >= 1 && Ln >= 0);
                break;
              }
          }
        } finally {
          Ss = !1, ko.current = ht, To(), Error.prepareStackTrace = Fe;
        }
        var ar = U ? U.displayName || U.name : "", dr = ar ? bs(ar) : "";
        return typeof U == "function" && ws.set(U, dr), dr;
      }
      function qa(U, Z, ye) {
        return qs(U, !1);
      }
      function ff(U) {
        var Z = U.prototype;
        return !!(Z && Z.isReactComponent);
      }
      function Go(U, Z, ye) {
        if (U == null)
          return "";
        if (typeof U == "function")
          return qs(U, ff(U));
        if (typeof U == "string")
          return bs(U);
        switch (U) {
          case v:
            return bs("Suspense");
          case S:
            return bs("SuspenseList");
        }
        if (typeof U == "object")
          switch (U.$$typeof) {
            case y:
              return qa(U.render);
            case x:
              return Go(U.type, Z, ye);
            case _: {
              var Ee = U, Fe = Ee._payload, ht = Ee._init;
              try {
                return Go(ht(Fe), Z, ye);
              } catch {
              }
            }
          }
        return "";
      }
      var hn = {}, Xo = le.ReactDebugCurrentFrame;
      function Qs(U) {
        if (U) {
          var Z = U._owner, ye = Go(U.type, U._source, Z ? Z.type : null);
          Xo.setExtraStackFrame(ye);
        } else
          Xo.setExtraStackFrame(null);
      }
      function zl(U, Z, ye, Ee, Fe) {
        {
          var ht = Function.call.bind(Mr);
          for (var Ze in U)
            if (ht(U, Ze)) {
              var bt = void 0;
              try {
                if (typeof U[Ze] != "function") {
                  var Yt = Error((Ee || "React class") + ": " + ye + " type `" + Ze + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof U[Ze] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Yt.name = "Invariant Violation", Yt;
                }
                bt = U[Ze](Z, Ze, Ee, ye, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (gn) {
                bt = gn;
              }
              bt && !(bt instanceof Error) && (Qs(Fe), he("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ee || "React class", ye, Ze, typeof bt), Qs(null)), bt instanceof Error && !(bt.message in hn) && (hn[bt.message] = !0, Qs(Fe), he("Failed %s type: %s", ye, bt.message), Qs(null));
            }
        }
      }
      function rn(U) {
        if (U) {
          var Z = U._owner, ye = Go(U.type, U._source, Z ? Z.type : null);
          se(ye);
        } else
          se(null);
      }
      var Ul;
      Ul = !1;
      function Bl() {
        if (F.current) {
          var U = tn(F.current.type);
          if (U)
            return `

Check the render method of \`` + U + "`.";
        }
        return "";
      }
      function Ft(U) {
        if (U !== void 0) {
          var Z = U.fileName.replace(/^.*[\\\/]/, ""), ye = U.lineNumber;
          return `

Check your code at ` + Z + ":" + ye + ".";
        }
        return "";
      }
      function Zs(U) {
        return U != null ? Ft(U.__source) : "";
      }
      var gr = {};
      function Br(U) {
        var Z = Bl();
        if (!Z) {
          var ye = typeof U == "string" ? U : U.displayName || U.name;
          ye && (Z = `

Check the top-level render call using <` + ye + ">.");
        }
        return Z;
      }
      function Si(U, Z) {
        if (!(!U._store || U._store.validated || U.key != null)) {
          U._store.validated = !0;
          var ye = Br(Z);
          if (!gr[ye]) {
            gr[ye] = !0;
            var Ee = "";
            U && U._owner && U._owner !== F.current && (Ee = " It was passed a child from " + tn(U._owner.type) + "."), rn(U), he('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ye, Ee), rn(null);
          }
        }
      }
      function xs(U, Z) {
        if (typeof U == "object") {
          if (Nt(U))
            for (var ye = 0; ye < U.length; ye++) {
              var Ee = U[ye];
              xn(Ee) && Si(Ee, Z);
            }
          else if (xn(U))
            U._store && (U._store.validated = !0);
          else if (U) {
            var Fe = N(U);
            if (typeof Fe == "function" && Fe !== U.entries)
              for (var ht = Fe.call(U), Ze; !(Ze = ht.next()).done; )
                xn(Ze.value) && Si(Ze.value, Z);
          }
        }
      }
      function or(U) {
        {
          var Z = U.type;
          if (Z == null || typeof Z == "string")
            return;
          var ye;
          if (typeof Z == "function")
            ye = Z.propTypes;
          else if (typeof Z == "object" && (Z.$$typeof === y || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          Z.$$typeof === x))
            ye = Z.propTypes;
          else
            return;
          if (ye) {
            var Ee = tn(Z);
            zl(ye, U.props, "prop", Ee, U);
          } else if (Z.PropTypes !== void 0 && !Ul) {
            Ul = !0;
            var Fe = tn(Z);
            he("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Fe || "Unknown");
          }
          typeof Z.getDefaultProps == "function" && !Z.getDefaultProps.isReactClassApproved && he("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function Nn(U) {
        {
          for (var Z = Object.keys(U.props), ye = 0; ye < Z.length; ye++) {
            var Ee = Z[ye];
            if (Ee !== "children" && Ee !== "key") {
              rn(U), he("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ee), rn(null);
              break;
            }
          }
          U.ref !== null && (rn(U), he("Invalid attribute `ref` supplied to `React.Fragment`."), rn(null));
        }
      }
      function Fl(U, Z, ye) {
        var Ee = Be(U);
        if (!Ee) {
          var Fe = "";
          (U === void 0 || typeof U == "object" && U !== null && Object.keys(U).length === 0) && (Fe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var ht = Zs(Z);
          ht ? Fe += ht : Fe += Bl();
          var Ze;
          U === null ? Ze = "null" : Nt(U) ? Ze = "array" : U !== void 0 && U.$$typeof === r ? (Ze = "<" + (tn(U.type) || "Unknown") + " />", Fe = " Did you accidentally export a JSX literal instead of a component?") : Ze = typeof U, he("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ze, Fe);
        }
        var bt = Et.apply(this, arguments);
        if (bt == null)
          return bt;
        if (Ee)
          for (var Yt = 2; Yt < arguments.length; Yt++)
            xs(arguments[Yt], U);
        return U === s ? Nn(bt) : or(bt), bt;
      }
      var Wi = !1;
      function Wr(U) {
        var Z = Fl.bind(null, U);
        return Z.type = U, Wi || (Wi = !0, Re("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(Z, "type", {
          enumerable: !1,
          get: function() {
            return Re("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: U
            }), U;
          }
        }), Z;
      }
      function qo(U, Z, ye) {
        for (var Ee = kn.apply(this, arguments), Fe = 2; Fe < arguments.length; Fe++)
          xs(arguments[Fe], Ee.type);
        return or(Ee), Ee;
      }
      function zc(U, Z) {
        var ye = L.transition;
        L.transition = {};
        var Ee = L.transition;
        L.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          U();
        } finally {
          if (L.transition = ye, ye === null && Ee._updatedFibers) {
            var Fe = Ee._updatedFibers.size;
            Fe > 10 && Re("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), Ee._updatedFibers.clear();
          }
        }
      }
      var co = !1, Qa = null;
      function Fu(U) {
        if (Qa === null)
          try {
            var Z = ("require" + Math.random()).slice(0, 7), ye = t && t[Z];
            Qa = ye.call(t, "timers").setImmediate;
          } catch {
            Qa = function(Fe) {
              co === !1 && (co = !0, typeof MessageChannel > "u" && he("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var ht = new MessageChannel();
              ht.port1.onmessage = Fe, ht.port2.postMessage(void 0);
            };
          }
        return Qa(U);
      }
      var Po = 0, Es = !1;
      function q(U) {
        {
          var Z = Po;
          Po++, z.current === null && (z.current = []);
          var ye = z.isBatchingLegacy, Ee;
          try {
            if (z.isBatchingLegacy = !0, Ee = U(), !ye && z.didScheduleLegacyUpdate) {
              var Fe = z.current;
              Fe !== null && (z.didScheduleLegacyUpdate = !1, Pn(Fe));
            }
          } catch (ar) {
            throw ie(Z), ar;
          } finally {
            z.isBatchingLegacy = ye;
          }
          if (Ee !== null && typeof Ee == "object" && typeof Ee.then == "function") {
            var ht = Ee, Ze = !1, bt = {
              then: function(ar, dr) {
                Ze = !0, ht.then(function(Sn) {
                  ie(Z), Po === 0 ? Ue(Sn, ar, dr) : ar(Sn);
                }, function(Sn) {
                  ie(Z), dr(Sn);
                });
              }
            };
            return !Es && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              Ze || (Es = !0, he("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), bt;
          } else {
            var Yt = Ee;
            if (ie(Z), Po === 0) {
              var gn = z.current;
              gn !== null && (Pn(gn), z.current = null);
              var Ln = {
                then: function(ar, dr) {
                  z.current === null ? (z.current = [], Ue(Yt, ar, dr)) : ar(Yt);
                }
              };
              return Ln;
            } else {
              var In = {
                then: function(ar, dr) {
                  ar(Yt);
                }
              };
              return In;
            }
          }
        }
      }
      function ie(U) {
        U !== Po - 1 && he("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), Po = U;
      }
      function Ue(U, Z, ye) {
        {
          var Ee = z.current;
          if (Ee !== null)
            try {
              Pn(Ee), Fu(function() {
                Ee.length === 0 ? (z.current = null, Z(U)) : Ue(U, Z, ye);
              });
            } catch (Fe) {
              ye(Fe);
            }
          else
            Z(U);
        }
      }
      var it = !1;
      function Pn(U) {
        if (!it) {
          it = !0;
          var Z = 0;
          try {
            for (; Z < U.length; Z++) {
              var ye = U[Z];
              do
                ye = ye(!0);
              while (ye !== null);
            }
            U.length = 0;
          } catch (Ee) {
            throw U = U.slice(Z + 1), Ee;
          } finally {
            it = !1;
          }
        }
      }
      var Ut = Fl, Kn = qo, Tr = Wr, Wn = {
        map: mi,
        forEach: Xa,
        count: ya,
        toArray: gs,
        only: oo
      };
      e.Children = Wn, e.Component = $e, e.Fragment = s, e.Profiler = f, e.PureComponent = rt, e.StrictMode = c, e.Suspense = v, e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = le, e.cloneElement = Kn, e.createContext = ms, e.createElement = Ut, e.createFactory = Tr, e.createRef = Tt, e.forwardRef = yi, e.isValidElement = xn, e.lazy = Ri, e.memo = et, e.startTransition = zc, e.unstable_act = q, e.useCallback = hr, e.useContext = Kt, e.useDebugValue = bn, e.useDeferredValue = Wo, e.useEffect = Ur, e.useId = Jt, e.useImperativeHandle = Nl, e.useInsertionEffect = Qn, e.useLayoutEffect = Zn, e.useMemo = wa, e.useReducer = Qt, e.useRef = Rt, e.useState = qt, e.useSyncExternalStore = xa, e.useTransition = df, e.version = n, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(Oy, Oy.exports)), Oy.exports;
}
({}).NODE_ENV === "production" ? Lk.exports = z7() : Lk.exports = U7();
var k = Lk.exports;
const It = /* @__PURE__ */ Np(k), B7 = /* @__PURE__ */ A7({
  __proto__: null,
  default: It
}, [k]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var EA;
function F7() {
  if (EA)
    return Ey;
  EA = 1;
  var t = k, e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, a = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function c(f, p, g) {
    var y, v = {}, S = null, x = null;
    g !== void 0 && (S = "" + g), p.key !== void 0 && (S = "" + p.key), p.ref !== void 0 && (x = p.ref);
    for (y in p)
      r.call(p, y) && !s.hasOwnProperty(y) && (v[y] = p[y]);
    if (f && f.defaultProps)
      for (y in p = f.defaultProps, p)
        v[y] === void 0 && (v[y] = p[y]);
    return { $$typeof: e, type: f, key: S, ref: x, props: v, _owner: a.current };
  }
  return Ey.Fragment = n, Ey.jsx = c, Ey.jsxs = c, Ey;
}
var Cy = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var CA;
function H7() {
  return CA || (CA = 1, {}.NODE_ENV !== "production" && function() {
    var t = k, e = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), a = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), c = Symbol.for("react.provider"), f = Symbol.for("react.context"), p = Symbol.for("react.forward_ref"), g = Symbol.for("react.suspense"), y = Symbol.for("react.suspense_list"), v = Symbol.for("react.memo"), S = Symbol.for("react.lazy"), x = Symbol.for("react.offscreen"), _ = Symbol.iterator, T = "@@iterator";
    function I(J) {
      if (J === null || typeof J != "object")
        return null;
      var Be = _ && J[_] || J[T];
      return typeof Be == "function" ? Be : null;
    }
    var D = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function N(J) {
      {
        for (var Be = arguments.length, et = new Array(Be > 1 ? Be - 1 : 0), st = 1; st < Be; st++)
          et[st - 1] = arguments[st];
        j("error", J, et);
      }
    }
    function j(J, Be, et) {
      {
        var st = D.ReactDebugCurrentFrame, Kt = st.getStackAddendum();
        Kt !== "" && (Be += "%s", et = et.concat([Kt]));
        var qt = et.map(function(Qt) {
          return String(Qt);
        });
        qt.unshift("Warning: " + Be), Function.prototype.apply.call(console[J], console, qt);
      }
    }
    var L = !1, z = !1, F = !1, K = !1, X = !1, se;
    se = Symbol.for("react.module.reference");
    function ue(J) {
      return !!(typeof J == "string" || typeof J == "function" || J === r || J === s || X || J === a || J === g || J === y || K || J === x || L || z || F || typeof J == "object" && J !== null && (J.$$typeof === S || J.$$typeof === v || J.$$typeof === c || J.$$typeof === f || J.$$typeof === p || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      J.$$typeof === se || J.getModuleId !== void 0));
    }
    function pe(J, Be, et) {
      var st = J.displayName;
      if (st)
        return st;
      var Kt = Be.displayName || Be.name || "";
      return Kt !== "" ? et + "(" + Kt + ")" : et;
    }
    function Pe(J) {
      return J.displayName || "Context";
    }
    function ve(J) {
      if (J == null)
        return null;
      if (typeof J.tag == "number" && N("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof J == "function")
        return J.displayName || J.name || null;
      if (typeof J == "string")
        return J;
      switch (J) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case s:
          return "Profiler";
        case a:
          return "StrictMode";
        case g:
          return "Suspense";
        case y:
          return "SuspenseList";
      }
      if (typeof J == "object")
        switch (J.$$typeof) {
          case f:
            var Be = J;
            return Pe(Be) + ".Consumer";
          case c:
            var et = J;
            return Pe(et._context) + ".Provider";
          case p:
            return pe(J, J.render, "ForwardRef");
          case v:
            var st = J.displayName || null;
            return st !== null ? st : ve(J.type) || "Memo";
          case S: {
            var Kt = J, qt = Kt._payload, Qt = Kt._init;
            try {
              return ve(Qt(qt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Y = Object.assign, le = 0, Re, he, te, de, W, fe, ce;
    function xe() {
    }
    xe.__reactDisabledLog = !0;
    function $e() {
      {
        if (le === 0) {
          Re = console.log, he = console.info, te = console.warn, de = console.error, W = console.group, fe = console.groupCollapsed, ce = console.groupEnd;
          var J = {
            configurable: !0,
            enumerable: !0,
            value: xe,
            writable: !0
          };
          Object.defineProperties(console, {
            info: J,
            log: J,
            warn: J,
            error: J,
            group: J,
            groupCollapsed: J,
            groupEnd: J
          });
        }
        le++;
      }
    }
    function Me() {
      {
        if (le--, le === 0) {
          var J = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Y({}, J, {
              value: Re
            }),
            info: Y({}, J, {
              value: he
            }),
            warn: Y({}, J, {
              value: te
            }),
            error: Y({}, J, {
              value: de
            }),
            group: Y({}, J, {
              value: W
            }),
            groupCollapsed: Y({}, J, {
              value: fe
            }),
            groupEnd: Y({}, J, {
              value: ce
            })
          });
        }
        le < 0 && N("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var re = D.ReactCurrentDispatcher, Qe;
    function ke(J, Be, et) {
      {
        if (Qe === void 0)
          try {
            throw Error();
          } catch (Kt) {
            var st = Kt.stack.trim().match(/\n( *(at )?)/);
            Qe = st && st[1] || "";
          }
        return `
` + Qe + J;
      }
    }
    var rt = !1, St;
    {
      var Tt = typeof WeakMap == "function" ? WeakMap : Map;
      St = new Tt();
    }
    function Le(J, Be) {
      if (!J || rt)
        return "";
      {
        var et = St.get(J);
        if (et !== void 0)
          return et;
      }
      var st;
      rt = !0;
      var Kt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var qt;
      qt = re.current, re.current = null, $e();
      try {
        if (Be) {
          var Qt = function() {
            throw Error();
          };
          if (Object.defineProperty(Qt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Qt, []);
            } catch (bn) {
              st = bn;
            }
            Reflect.construct(J, [], Qt);
          } else {
            try {
              Qt.call();
            } catch (bn) {
              st = bn;
            }
            J.call(Qt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (bn) {
            st = bn;
          }
          J();
        }
      } catch (bn) {
        if (bn && st && typeof bn.stack == "string") {
          for (var Rt = bn.stack.split(`
`), Ur = st.stack.split(`
`), Qn = Rt.length - 1, Zn = Ur.length - 1; Qn >= 1 && Zn >= 0 && Rt[Qn] !== Ur[Zn]; )
            Zn--;
          for (; Qn >= 1 && Zn >= 0; Qn--, Zn--)
            if (Rt[Qn] !== Ur[Zn]) {
              if (Qn !== 1 || Zn !== 1)
                do
                  if (Qn--, Zn--, Zn < 0 || Rt[Qn] !== Ur[Zn]) {
                    var hr = `
` + Rt[Qn].replace(" at new ", " at ");
                    return J.displayName && hr.includes("<anonymous>") && (hr = hr.replace("<anonymous>", J.displayName)), typeof J == "function" && St.set(J, hr), hr;
                  }
                while (Qn >= 1 && Zn >= 0);
              break;
            }
        }
      } finally {
        rt = !1, re.current = qt, Me(), Error.prepareStackTrace = Kt;
      }
      var wa = J ? J.displayName || J.name : "", Nl = wa ? ke(wa) : "";
      return typeof J == "function" && St.set(J, Nl), Nl;
    }
    function Nt(J, Be, et) {
      return Le(J, !1);
    }
    function Ke(J) {
      var Be = J.prototype;
      return !!(Be && Be.isReactComponent);
    }
    function yt(J, Be, et) {
      if (J == null)
        return "";
      if (typeof J == "function")
        return Le(J, Ke(J));
      if (typeof J == "string")
        return ke(J);
      switch (J) {
        case g:
          return ke("Suspense");
        case y:
          return ke("SuspenseList");
      }
      if (typeof J == "object")
        switch (J.$$typeof) {
          case p:
            return Nt(J.render);
          case v:
            return yt(J.type, Be, et);
          case S: {
            var st = J, Kt = st._payload, qt = st._init;
            try {
              return yt(qt(Kt), Be, et);
            } catch {
            }
          }
        }
      return "";
    }
    var Xt = Object.prototype.hasOwnProperty, kt = {}, yn = D.ReactDebugCurrentFrame;
    function Er(J) {
      if (J) {
        var Be = J._owner, et = yt(J.type, J._source, Be ? Be.type : null);
        yn.setExtraStackFrame(et);
      } else
        yn.setExtraStackFrame(null);
    }
    function tn(J, Be, et, st, Kt) {
      {
        var qt = Function.call.bind(Xt);
        for (var Qt in J)
          if (qt(J, Qt)) {
            var Rt = void 0;
            try {
              if (typeof J[Qt] != "function") {
                var Ur = Error((st || "React class") + ": " + et + " type `" + Qt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof J[Qt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ur.name = "Invariant Violation", Ur;
              }
              Rt = J[Qt](Be, Qt, st, et, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Qn) {
              Rt = Qn;
            }
            Rt && !(Rt instanceof Error) && (Er(Kt), N("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", st || "React class", et, Qt, typeof Rt), Er(null)), Rt instanceof Error && !(Rt.message in kt) && (kt[Rt.message] = !0, Er(Kt), N("Failed %s type: %s", et, Rt.message), Er(null));
          }
      }
    }
    var Mr = Array.isArray;
    function zr(J) {
      return Mr(J);
    }
    function Hn(J) {
      {
        var Be = typeof Symbol == "function" && Symbol.toStringTag, et = Be && J[Symbol.toStringTag] || J.constructor.name || "Object";
        return et;
      }
    }
    function xt(J) {
      try {
        return cn(J), !1;
      } catch {
        return !0;
      }
    }
    function cn(J) {
      return "" + J;
    }
    function ti(J) {
      if (xt(J))
        return N("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Hn(J)), cn(J);
    }
    var An = D.ReactCurrentOwner, qn = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ko, Cr, Je;
    Je = {};
    function Et(J) {
      if (Xt.call(J, "ref")) {
        var Be = Object.getOwnPropertyDescriptor(J, "ref").get;
        if (Be && Be.isReactWarning)
          return !1;
      }
      return J.ref !== void 0;
    }
    function nn(J) {
      if (Xt.call(J, "key")) {
        var Be = Object.getOwnPropertyDescriptor(J, "key").get;
        if (Be && Be.isReactWarning)
          return !1;
      }
      return J.key !== void 0;
    }
    function kn(J, Be) {
      if (typeof J.ref == "string" && An.current && Be && An.current.stateNode !== Be) {
        var et = ve(An.current.type);
        Je[et] || (N('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', ve(An.current.type), J.ref), Je[et] = !0);
      }
    }
    function xn(J, Be) {
      {
        var et = function() {
          Ko || (Ko = !0, N("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Be));
        };
        et.isReactWarning = !0, Object.defineProperty(J, "key", {
          get: et,
          configurable: !0
        });
      }
    }
    function _r(J, Be) {
      {
        var et = function() {
          Cr || (Cr = !0, N("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Be));
        };
        et.isReactWarning = !0, Object.defineProperty(J, "ref", {
          get: et,
          configurable: !0
        });
      }
    }
    var ur = function(J, Be, et, st, Kt, qt, Qt) {
      var Rt = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: J,
        key: Be,
        ref: et,
        props: Qt,
        // Record the component responsible for creating this element.
        _owner: qt
      };
      return Rt._store = {}, Object.defineProperty(Rt._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Rt, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: st
      }), Object.defineProperty(Rt, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Kt
      }), Object.freeze && (Object.freeze(Rt.props), Object.freeze(Rt)), Rt;
    };
    function hi(J, Be, et, st, Kt) {
      {
        var qt, Qt = {}, Rt = null, Ur = null;
        et !== void 0 && (ti(et), Rt = "" + et), nn(Be) && (ti(Be.key), Rt = "" + Be.key), Et(Be) && (Ur = Be.ref, kn(Be, Kt));
        for (qt in Be)
          Xt.call(Be, qt) && !qn.hasOwnProperty(qt) && (Qt[qt] = Be[qt]);
        if (J && J.defaultProps) {
          var Qn = J.defaultProps;
          for (qt in Qn)
            Qt[qt] === void 0 && (Qt[qt] = Qn[qt]);
        }
        if (Rt || Ur) {
          var Zn = typeof J == "function" ? J.displayName || J.name || "Unknown" : J;
          Rt && xn(Qt, Zn), Ur && _r(Qt, Zn);
        }
        return ur(J, Rt, Ur, Kt, st, An.current, Qt);
      }
    }
    var pn = D.ReactCurrentOwner, gi = D.ReactDebugCurrentFrame;
    function On(J) {
      if (J) {
        var Be = J._owner, et = yt(J.type, J._source, Be ? Be.type : null);
        gi.setExtraStackFrame(et);
      } else
        gi.setExtraStackFrame(null);
    }
    var Dn;
    Dn = !1;
    function io(J) {
      return typeof J == "object" && J !== null && J.$$typeof === e;
    }
    function mi() {
      {
        if (pn.current) {
          var J = ve(pn.current.type);
          if (J)
            return `

Check the render method of \`` + J + "`.";
        }
        return "";
      }
    }
    function ya(J) {
      {
        if (J !== void 0) {
          var Be = J.fileName.replace(/^.*[\\\/]/, ""), et = J.lineNumber;
          return `

Check your code at ` + Be + ":" + et + ".";
        }
        return "";
      }
    }
    var Xa = {};
    function gs(J) {
      {
        var Be = mi();
        if (!Be) {
          var et = typeof J == "string" ? J : J.displayName || J.name;
          et && (Be = `

Check the top-level render call using <` + et + ">.");
        }
        return Be;
      }
    }
    function oo(J, Be) {
      {
        if (!J._store || J._store.validated || J.key != null)
          return;
        J._store.validated = !0;
        var et = gs(Be);
        if (Xa[et])
          return;
        Xa[et] = !0;
        var st = "";
        J && J._owner && J._owner !== pn.current && (st = " It was passed a child from " + ve(J._owner.type) + "."), On(J), N('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', et, st), On(null);
      }
    }
    function ms(J, Be) {
      {
        if (typeof J != "object")
          return;
        if (zr(J))
          for (var et = 0; et < J.length; et++) {
            var st = J[et];
            io(st) && oo(st, Be);
          }
        else if (io(J))
          J._store && (J._store.validated = !0);
        else if (J) {
          var Kt = I(J);
          if (typeof Kt == "function" && Kt !== J.entries)
            for (var qt = Kt.call(J), Qt; !(Qt = qt.next()).done; )
              io(Qt.value) && oo(Qt.value, Be);
        }
      }
    }
    function ao(J) {
      {
        var Be = J.type;
        if (Be == null || typeof Be == "string")
          return;
        var et;
        if (typeof Be == "function")
          et = Be.propTypes;
        else if (typeof Be == "object" && (Be.$$typeof === p || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Be.$$typeof === v))
          et = Be.propTypes;
        else
          return;
        if (et) {
          var st = ve(Be);
          tn(et, J.props, "prop", st, J);
        } else if (Be.PropTypes !== void 0 && !Dn) {
          Dn = !0;
          var Kt = ve(Be);
          N("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Kt || "Unknown");
        }
        typeof Be.getDefaultProps == "function" && !Be.getDefaultProps.isReactClassApproved && N("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ba(J) {
      {
        for (var Be = Object.keys(J.props), et = 0; et < Be.length; et++) {
          var st = Be[et];
          if (st !== "children" && st !== "key") {
            On(J), N("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", st), On(null);
            break;
          }
        }
        J.ref !== null && (On(J), N("Invalid attribute `ref` supplied to `React.Fragment`."), On(null));
      }
    }
    function so(J, Be, et, st, Kt, qt) {
      {
        var Qt = ue(J);
        if (!Qt) {
          var Rt = "";
          (J === void 0 || typeof J == "object" && J !== null && Object.keys(J).length === 0) && (Rt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ur = ya(Kt);
          Ur ? Rt += Ur : Rt += mi();
          var Qn;
          J === null ? Qn = "null" : zr(J) ? Qn = "array" : J !== void 0 && J.$$typeof === e ? (Qn = "<" + (ve(J.type) || "Unknown") + " />", Rt = " Did you accidentally export a JSX literal instead of a component?") : Qn = typeof J, N("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Qn, Rt);
        }
        var Zn = hi(J, Be, et, Kt, qt);
        if (Zn == null)
          return Zn;
        if (Qt) {
          var hr = Be.children;
          if (hr !== void 0)
            if (st)
              if (zr(hr)) {
                for (var wa = 0; wa < hr.length; wa++)
                  ms(hr[wa], J);
                Object.freeze && Object.freeze(hr);
              } else
                N("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ms(hr, J);
        }
        return J === r ? ba(Zn) : ao(Zn), Zn;
      }
    }
    function Sa(J, Be, et) {
      return so(J, Be, et, !0);
    }
    function vi(J, Be, et) {
      return so(J, Be, et, !1);
    }
    var Ri = vi, yi = Sa;
    Cy.Fragment = r, Cy.jsx = Ri, Cy.jsxs = yi;
  }()), Cy;
}
({}).NODE_ENV === "production" ? Nk.exports = F7() : Nk.exports = H7();
var E = Nk.exports, ww = function(t) {
  return t && t.Math == Math && t;
}, Wa = (
  // eslint-disable-next-line es/no-global-this -- safe
  ww(typeof globalThis == "object" && globalThis) || ww(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  ww(typeof self == "object" && self) || ww(typeof ca == "object" && ca) || // eslint-disable-next-line no-new-func -- fallback
  function() {
    return this;
  }() || ca || Function("return this")()
), HP = {}, pa = function(t) {
  try {
    return !!t();
  } catch {
    return !0;
  }
}, V7 = pa, rf = !V7(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
}), Y7 = pa, qx = !Y7(function() {
  var t = function() {
  }.bind();
  return typeof t != "function" || t.hasOwnProperty("prototype");
}), K7 = qx, xw = Function.prototype.call, of = K7 ? xw.bind(xw) : function() {
  return xw.apply(xw, arguments);
}, t3 = {}, n3 = {}.propertyIsEnumerable, r3 = Object.getOwnPropertyDescriptor, W7 = r3 && !n3.call({ 1: 2 }, 1);
t3.f = W7 ? function(e) {
  var n = r3(this, e);
  return !!n && n.enumerable;
} : n3;
var i3 = function(t, e) {
  return {
    enumerable: !(t & 1),
    configurable: !(t & 2),
    writable: !(t & 4),
    value: e
  };
}, o3 = qx, a3 = Function.prototype, jk = a3.call, G7 = o3 && a3.bind.bind(jk, jk), ro = o3 ? G7 : function(t) {
  return function() {
    return jk.apply(t, arguments);
  };
}, s3 = ro, X7 = s3({}.toString), q7 = s3("".slice), tm = function(t) {
  return q7(X7(t), 8, -1);
}, Q7 = ro, Z7 = pa, J7 = tm, gT = Object, e9 = Q7("".split), t9 = Z7(function() {
  return !gT("z").propertyIsEnumerable(0);
}) ? function(t) {
  return J7(t) == "String" ? e9(t, "") : gT(t);
} : gT, Qx = function(t) {
  return t == null;
}, n9 = Qx, r9 = TypeError, nm = function(t) {
  if (n9(t))
    throw r9("Can't call method on " + t);
  return t;
}, i9 = t9, o9 = nm, Zx = function(t) {
  return i9(o9(t));
}, zk = typeof document == "object" && document.all, a9 = typeof zk > "u" && zk !== void 0, l3 = {
  all: zk,
  IS_HTMLDDA: a9
}, c3 = l3, s9 = c3.all, ha = c3.IS_HTMLDDA ? function(t) {
  return typeof t == "function" || t === s9;
} : function(t) {
  return typeof t == "function";
}, _A = ha, u3 = l3, l9 = u3.all, Lp = u3.IS_HTMLDDA ? function(t) {
  return typeof t == "object" ? t !== null : _A(t) || t === l9;
} : function(t) {
  return typeof t == "object" ? t !== null : _A(t);
}, mT = Wa, c9 = ha, u9 = function(t) {
  return c9(t) ? t : void 0;
}, Jx = function(t, e) {
  return arguments.length < 2 ? u9(mT[t]) : mT[t] && mT[t][e];
}, d9 = ro, d3 = d9({}.isPrototypeOf), f9 = typeof navigator < "u" && String(navigator.userAgent) || "", f3 = Wa, vT = f9, TA = f3.process, kA = f3.Deno, PA = TA && TA.versions || kA && kA.version, IA = PA && PA.v8, Pl, mx;
IA && (Pl = IA.split("."), mx = Pl[0] > 0 && Pl[0] < 4 ? 1 : +(Pl[0] + Pl[1]));
!mx && vT && (Pl = vT.match(/Edge\/(\d+)/), (!Pl || Pl[1] >= 74) && (Pl = vT.match(/Chrome\/(\d+)/), Pl && (mx = +Pl[1])));
var p9 = mx, RA = p9, h9 = pa, g9 = Wa, m9 = g9.String, p3 = !!Object.getOwnPropertySymbols && !h9(function() {
  var t = Symbol();
  return !m9(t) || !(Object(t) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && RA && RA < 41;
}), v9 = p3, h3 = v9 && !Symbol.sham && typeof Symbol.iterator == "symbol", y9 = Jx, b9 = ha, S9 = d3, w9 = h3, x9 = Object, g3 = w9 ? function(t) {
  return typeof t == "symbol";
} : function(t) {
  var e = y9("Symbol");
  return b9(e) && S9(e.prototype, x9(t));
}, E9 = String, C9 = function(t) {
  try {
    return E9(t);
  } catch {
    return "Object";
  }
}, _9 = ha, T9 = C9, k9 = TypeError, VP = function(t) {
  if (_9(t))
    return t;
  throw k9(T9(t) + " is not a function");
}, P9 = VP, I9 = Qx, YP = function(t, e) {
  var n = t[e];
  return I9(n) ? void 0 : P9(n);
}, yT = of, bT = ha, ST = Lp, R9 = TypeError, $9 = function(t, e) {
  var n, r;
  if (e === "string" && bT(n = t.toString) && !ST(r = yT(n, t)) || bT(n = t.valueOf) && !ST(r = yT(n, t)) || e !== "string" && bT(n = t.toString) && !ST(r = yT(n, t)))
    return r;
  throw R9("Can't convert object to primitive value");
}, m3 = { exports: {} }, $A = Wa, M9 = Object.defineProperty, KP = function(t, e) {
  try {
    M9($A, t, { value: e, configurable: !0, writable: !0 });
  } catch {
    $A[t] = e;
  }
  return e;
}, A9 = Wa, O9 = KP, MA = "__core-js_shared__", D9 = A9[MA] || O9(MA, {}), WP = D9, AA = WP;
(m3.exports = function(t, e) {
  return AA[t] || (AA[t] = e !== void 0 ? e : {});
})("versions", []).push({
  version: "3.30.2",
  mode: "global",
  copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.30.2/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var GP = m3.exports, N9 = nm, L9 = Object, hb = function(t) {
  return L9(N9(t));
}, j9 = ro, z9 = hb, U9 = j9({}.hasOwnProperty), af = Object.hasOwn || function(e, n) {
  return U9(z9(e), n);
}, B9 = ro, F9 = 0, H9 = Math.random(), V9 = B9(1 .toString), v3 = function(t) {
  return "Symbol(" + (t === void 0 ? "" : t) + ")_" + V9(++F9 + H9, 36);
}, Y9 = Wa, K9 = GP, OA = af, W9 = v3, G9 = p3, X9 = h3, zg = Y9.Symbol, wT = K9("wks"), q9 = X9 ? zg.for || zg : zg && zg.withoutSetter || W9, ju = function(t) {
  return OA(wT, t) || (wT[t] = G9 && OA(zg, t) ? zg[t] : q9("Symbol." + t)), wT[t];
}, Q9 = of, DA = Lp, NA = g3, Z9 = YP, J9 = $9, eH = ju, tH = TypeError, nH = eH("toPrimitive"), rH = function(t, e) {
  if (!DA(t) || NA(t))
    return t;
  var n = Z9(t, nH), r;
  if (n) {
    if (e === void 0 && (e = "default"), r = Q9(n, t, e), !DA(r) || NA(r))
      return r;
    throw tH("Can't convert object to primitive value");
  }
  return e === void 0 && (e = "number"), J9(t, e);
}, iH = rH, oH = g3, y3 = function(t) {
  var e = iH(t, "string");
  return oH(e) ? e : e + "";
}, aH = Wa, LA = Lp, Uk = aH.document, sH = LA(Uk) && LA(Uk.createElement), b3 = function(t) {
  return sH ? Uk.createElement(t) : {};
}, lH = rf, cH = pa, uH = b3, S3 = !lH && !cH(function() {
  return Object.defineProperty(uH("div"), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
}), dH = rf, fH = of, pH = t3, hH = i3, gH = Zx, mH = y3, vH = af, yH = S3, jA = Object.getOwnPropertyDescriptor;
HP.f = dH ? jA : function(e, n) {
  if (e = gH(e), n = mH(n), yH)
    try {
      return jA(e, n);
    } catch {
    }
  if (vH(e, n))
    return hH(!fH(pH.f, e, n), e[n]);
};
var rm = {}, bH = rf, SH = pa, w3 = bH && SH(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: !1
  }).prototype != 42;
}), wH = Lp, xH = String, EH = TypeError, jp = function(t) {
  if (wH(t))
    return t;
  throw EH(xH(t) + " is not an object");
}, CH = rf, _H = S3, TH = w3, Ew = jp, zA = y3, kH = TypeError, xT = Object.defineProperty, PH = Object.getOwnPropertyDescriptor, ET = "enumerable", CT = "configurable", _T = "writable";
rm.f = CH ? TH ? function(e, n, r) {
  if (Ew(e), n = zA(n), Ew(r), typeof e == "function" && n === "prototype" && "value" in r && _T in r && !r[_T]) {
    var a = PH(e, n);
    a && a[_T] && (e[n] = r.value, r = {
      configurable: CT in r ? r[CT] : a[CT],
      enumerable: ET in r ? r[ET] : a[ET],
      writable: !1
    });
  }
  return xT(e, n, r);
} : xT : function(e, n, r) {
  if (Ew(e), n = zA(n), Ew(r), _H)
    try {
      return xT(e, n, r);
    } catch {
    }
  if ("get" in r || "set" in r)
    throw kH("Accessors not supported");
  return "value" in r && (e[n] = r.value), e;
};
var IH = rf, RH = rm, $H = i3, XP = IH ? function(t, e, n) {
  return RH.f(t, e, $H(1, n));
} : function(t, e, n) {
  return t[e] = n, t;
}, x3 = { exports: {} }, Bk = rf, MH = af, E3 = Function.prototype, AH = Bk && Object.getOwnPropertyDescriptor, qP = MH(E3, "name"), OH = qP && function() {
}.name === "something", DH = qP && (!Bk || Bk && AH(E3, "name").configurable), NH = {
  EXISTS: qP,
  PROPER: OH,
  CONFIGURABLE: DH
}, LH = ro, jH = ha, Fk = WP, zH = LH(Function.toString);
jH(Fk.inspectSource) || (Fk.inspectSource = function(t) {
  return zH(t);
});
var C3 = Fk.inspectSource, UH = Wa, BH = ha, UA = UH.WeakMap, FH = BH(UA) && /native code/.test(String(UA)), HH = GP, VH = v3, BA = HH("keys"), _3 = function(t) {
  return BA[t] || (BA[t] = VH(t));
}, QP = {}, YH = FH, T3 = Wa, KH = Lp, WH = XP, TT = af, kT = WP, GH = _3, XH = QP, FA = "Object already initialized", Hk = T3.TypeError, qH = T3.WeakMap, vx, Wy, yx, QH = function(t) {
  return yx(t) ? Wy(t) : vx(t, {});
}, ZH = function(t) {
  return function(e) {
    var n;
    if (!KH(e) || (n = Wy(e)).type !== t)
      throw Hk("Incompatible receiver, " + t + " required");
    return n;
  };
};
if (YH || kT.state) {
  var bc = kT.state || (kT.state = new qH());
  bc.get = bc.get, bc.has = bc.has, bc.set = bc.set, vx = function(t, e) {
    if (bc.has(t))
      throw Hk(FA);
    return e.facade = t, bc.set(t, e), e;
  }, Wy = function(t) {
    return bc.get(t) || {};
  }, yx = function(t) {
    return bc.has(t);
  };
} else {
  var _g = GH("state");
  XH[_g] = !0, vx = function(t, e) {
    if (TT(t, _g))
      throw Hk(FA);
    return e.facade = t, WH(t, _g, e), e;
  }, Wy = function(t) {
    return TT(t, _g) ? t[_g] : {};
  }, yx = function(t) {
    return TT(t, _g);
  };
}
var k3 = {
  set: vx,
  get: Wy,
  has: yx,
  enforce: QH,
  getterFor: ZH
}, ZP = ro, JH = pa, eV = ha, Cw = af, Vk = rf, tV = NH.CONFIGURABLE, nV = C3, P3 = k3, rV = P3.enforce, iV = P3.get, HA = String, ix = Object.defineProperty, oV = ZP("".slice), aV = ZP("".replace), sV = ZP([].join), lV = Vk && !JH(function() {
  return ix(function() {
  }, "length", { value: 8 }).length !== 8;
}), cV = String(String).split("String"), uV = x3.exports = function(t, e, n) {
  oV(HA(e), 0, 7) === "Symbol(" && (e = "[" + aV(HA(e), /^Symbol\(([^)]*)\)/, "$1") + "]"), n && n.getter && (e = "get " + e), n && n.setter && (e = "set " + e), (!Cw(t, "name") || tV && t.name !== e) && (Vk ? ix(t, "name", { value: e, configurable: !0 }) : t.name = e), lV && n && Cw(n, "arity") && t.length !== n.arity && ix(t, "length", { value: n.arity });
  try {
    n && Cw(n, "constructor") && n.constructor ? Vk && ix(t, "prototype", { writable: !1 }) : t.prototype && (t.prototype = void 0);
  } catch {
  }
  var r = rV(t);
  return Cw(r, "source") || (r.source = sV(cV, typeof e == "string" ? e : "")), t;
};
Function.prototype.toString = uV(function() {
  return eV(this) && iV(this).source || nV(this);
}, "toString");
var dV = x3.exports, fV = ha, pV = rm, hV = dV, gV = KP, I3 = function(t, e, n, r) {
  r || (r = {});
  var a = r.enumerable, s = r.name !== void 0 ? r.name : e;
  if (fV(n) && hV(n, s, r), r.global)
    a ? t[e] = n : gV(e, n);
  else {
    try {
      r.unsafe ? t[e] && (a = !0) : delete t[e];
    } catch {
    }
    a ? t[e] = n : pV.f(t, e, {
      value: n,
      enumerable: !1,
      configurable: !r.nonConfigurable,
      writable: !r.nonWritable
    });
  }
  return t;
}, R3 = {}, mV = Math.ceil, vV = Math.floor, yV = Math.trunc || function(e) {
  var n = +e;
  return (n > 0 ? vV : mV)(n);
}, bV = yV, zp = function(t) {
  var e = +t;
  return e !== e || e === 0 ? 0 : bV(e);
}, SV = zp, wV = Math.max, xV = Math.min, EV = function(t, e) {
  var n = SV(t);
  return n < 0 ? wV(n + e, 0) : xV(n, e);
}, CV = zp, _V = Math.min, $3 = function(t) {
  return t > 0 ? _V(CV(t), 9007199254740991) : 0;
}, TV = $3, gb = function(t) {
  return TV(t.length);
}, kV = Zx, PV = EV, IV = gb, VA = function(t) {
  return function(e, n, r) {
    var a = kV(e), s = IV(a), c = PV(r, s), f;
    if (t && n != n) {
      for (; s > c; )
        if (f = a[c++], f != f)
          return !0;
    } else
      for (; s > c; c++)
        if ((t || c in a) && a[c] === n)
          return t || c || 0;
    return !t && -1;
  };
}, RV = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: VA(!0),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: VA(!1)
}, $V = ro, PT = af, MV = Zx, AV = RV.indexOf, OV = QP, YA = $V([].push), M3 = function(t, e) {
  var n = MV(t), r = 0, a = [], s;
  for (s in n)
    !PT(OV, s) && PT(n, s) && YA(a, s);
  for (; e.length > r; )
    PT(n, s = e[r++]) && (~AV(a, s) || YA(a, s));
  return a;
}, JP = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
], DV = M3, NV = JP, LV = NV.concat("length", "prototype");
R3.f = Object.getOwnPropertyNames || function(e) {
  return DV(e, LV);
};
var A3 = {};
A3.f = Object.getOwnPropertySymbols;
var jV = Jx, zV = ro, UV = R3, BV = A3, FV = jp, HV = zV([].concat), VV = jV("Reflect", "ownKeys") || function(e) {
  var n = UV.f(FV(e)), r = BV.f;
  return r ? HV(n, r(e)) : n;
}, KA = af, YV = VV, KV = HP, WV = rm, GV = function(t, e, n) {
  for (var r = YV(e), a = WV.f, s = KV.f, c = 0; c < r.length; c++) {
    var f = r[c];
    !KA(t, f) && !(n && KA(n, f)) && a(t, f, s(e, f));
  }
}, XV = pa, qV = ha, QV = /#|\.prototype\./, mb = function(t, e) {
  var n = JV[ZV(t)];
  return n == tY ? !0 : n == eY ? !1 : qV(e) ? XV(e) : !!e;
}, ZV = mb.normalize = function(t) {
  return String(t).replace(QV, ".").toLowerCase();
}, JV = mb.data = {}, eY = mb.NATIVE = "N", tY = mb.POLYFILL = "P", nY = mb, IT = Wa, rY = HP.f, iY = XP, oY = I3, aY = KP, sY = GV, lY = nY, im = function(t, e) {
  var n = t.target, r = t.global, a = t.stat, s, c, f, p, g, y;
  if (r ? c = IT : a ? c = IT[n] || aY(n, {}) : c = (IT[n] || {}).prototype, c)
    for (f in e) {
      if (g = e[f], t.dontCallGetSet ? (y = rY(c, f), p = y && y.value) : p = c[f], s = lY(r ? f : n + (a ? "." : "#") + f, t.forced), !s && p !== void 0) {
        if (typeof g == typeof p)
          continue;
        sY(g, p);
      }
      (t.sham || p && p.sham) && iY(g, "sham", !0), oY(c, f, g, t);
    }
}, O3 = {}, cY = M3, uY = JP, dY = Object.keys || function(e) {
  return cY(e, uY);
}, fY = rf, pY = w3, hY = rm, gY = jp, mY = Zx, vY = dY;
O3.f = fY && !pY ? Object.defineProperties : function(e, n) {
  gY(e);
  for (var r = mY(n), a = vY(n), s = a.length, c = 0, f; s > c; )
    hY.f(e, f = a[c++], r[f]);
  return e;
};
var yY = Jx, bY = yY("document", "documentElement"), SY = jp, wY = O3, WA = JP, xY = QP, EY = bY, CY = b3, _Y = _3, GA = ">", XA = "<", Yk = "prototype", Kk = "script", D3 = _Y("IE_PROTO"), RT = function() {
}, N3 = function(t) {
  return XA + Kk + GA + t + XA + "/" + Kk + GA;
}, qA = function(t) {
  t.write(N3("")), t.close();
  var e = t.parentWindow.Object;
  return t = null, e;
}, TY = function() {
  var t = CY("iframe"), e = "java" + Kk + ":", n;
  return t.style.display = "none", EY.appendChild(t), t.src = String(e), n = t.contentWindow.document, n.open(), n.write(N3("document.F=Object")), n.close(), n.F;
}, _w, ox = function() {
  try {
    _w = new ActiveXObject("htmlfile");
  } catch {
  }
  ox = typeof document < "u" ? document.domain && _w ? qA(_w) : TY() : qA(_w);
  for (var t = WA.length; t--; )
    delete ox[Yk][WA[t]];
  return ox();
};
xY[D3] = !0;
var L3 = Object.create || function(e, n) {
  var r;
  return e !== null ? (RT[Yk] = SY(e), r = new RT(), RT[Yk] = null, r[D3] = e) : r = ox(), n === void 0 ? r : wY.f(r, n);
}, kY = ju, PY = L3, IY = rm.f, Wk = kY("unscopables"), Gk = Array.prototype;
Gk[Wk] == null && IY(Gk, Wk, {
  configurable: !0,
  value: PY(null)
});
var eI = function(t) {
  Gk[Wk][t] = !0;
}, RY = im, $Y = hb, MY = gb, AY = zp, OY = eI;
RY({ target: "Array", proto: !0 }, {
  at: function(e) {
    var n = $Y(this), r = MY(n), a = AY(e), s = a >= 0 ? a : r + a;
    return s < 0 || s >= r ? void 0 : n[s];
  }
});
OY("at");
var DY = Wa, NY = ro, vb = function(t, e) {
  return NY(DY[t].prototype[e]);
}, LY = vb;
LY("Array", "at");
var jY = tm, j3 = Array.isArray || function(e) {
  return jY(e) == "Array";
}, zY = TypeError, UY = 9007199254740991, BY = function(t) {
  if (t > UY)
    throw zY("Maximum allowed index exceeded");
  return t;
}, FY = tm, HY = ro, z3 = function(t) {
  if (FY(t) === "Function")
    return HY(t);
}, QA = z3, VY = VP, YY = qx, KY = QA(QA.bind), WY = function(t, e) {
  return VY(t), e === void 0 ? t : YY ? KY(t, e) : function() {
    return t.apply(e, arguments);
  };
}, GY = j3, XY = gb, qY = BY, QY = WY, U3 = function(t, e, n, r, a, s, c, f) {
  for (var p = a, g = 0, y = c ? QY(c, f) : !1, v, S; g < r; )
    g in n && (v = y ? y(n[g], g, e) : n[g], s > 0 && GY(v) ? (S = XY(v), p = U3(t, e, v, S, p, s - 1) - 1) : (qY(p + 1), t[p] = v), p++), g++;
  return p;
}, B3 = U3, ZY = ju, JY = ZY("toStringTag"), F3 = {};
F3[JY] = "z";
var eK = String(F3) === "[object z]", tK = eK, nK = ha, ax = tm, rK = ju, iK = rK("toStringTag"), oK = Object, aK = ax(function() {
  return arguments;
}()) == "Arguments", sK = function(t, e) {
  try {
    return t[e];
  } catch {
  }
}, H3 = tK ? ax : function(t) {
  var e, n, r;
  return t === void 0 ? "Undefined" : t === null ? "Null" : typeof (n = sK(e = oK(t), iK)) == "string" ? n : aK ? ax(e) : (r = ax(e)) == "Object" && nK(e.callee) ? "Arguments" : r;
}, lK = ro, cK = pa, V3 = ha, uK = H3, dK = Jx, fK = C3, Y3 = function() {
}, pK = [], K3 = dK("Reflect", "construct"), tI = /^\s*(?:class|function)\b/, hK = lK(tI.exec), gK = !tI.exec(Y3), _y = function(e) {
  if (!V3(e))
    return !1;
  try {
    return K3(Y3, pK, e), !0;
  } catch {
    return !1;
  }
}, W3 = function(e) {
  if (!V3(e))
    return !1;
  switch (uK(e)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return !1;
  }
  try {
    return gK || !!hK(tI, fK(e));
  } catch {
    return !0;
  }
};
W3.sham = !0;
var mK = !K3 || cK(function() {
  var t;
  return _y(_y.call) || !_y(Object) || !_y(function() {
    t = !0;
  }) || t;
}) ? W3 : _y, ZA = j3, vK = mK, yK = Lp, bK = ju, SK = bK("species"), JA = Array, wK = function(t) {
  var e;
  return ZA(t) && (e = t.constructor, vK(e) && (e === JA || ZA(e.prototype)) ? e = void 0 : yK(e) && (e = e[SK], e === null && (e = void 0))), e === void 0 ? JA : e;
}, xK = wK, G3 = function(t, e) {
  return new (xK(t))(e === 0 ? 0 : e);
}, EK = im, CK = B3, _K = hb, TK = gb, kK = zp, PK = G3;
EK({ target: "Array", proto: !0 }, {
  flat: function() {
    var e = arguments.length ? arguments[0] : void 0, n = _K(this), r = TK(n), a = PK(n, 0);
    return a.length = CK(a, n, n, r, 0, e === void 0 ? 1 : kK(e)), a;
  }
});
var IK = eI;
IK("flat");
var RK = vb;
RK("Array", "flat");
var $K = im, MK = B3, AK = VP, OK = hb, DK = gb, NK = G3;
$K({ target: "Array", proto: !0 }, {
  flatMap: function(e) {
    var n = OK(this), r = DK(n), a;
    return AK(e), a = NK(n, 0), a.length = MK(a, n, n, r, 0, 1, e, arguments.length > 1 ? arguments[1] : void 0), a;
  }
});
var LK = eI;
LK("flatMap");
var jK = vb;
jK("Array", "flatMap");
var zK = H3, UK = String, yb = function(t) {
  if (zK(t) === "Symbol")
    throw TypeError("Cannot convert a Symbol value to a string");
  return UK(t);
}, BK = im, FK = ro, HK = nm, VK = zp, YK = yb, KK = pa, WK = FK("".charAt), GK = KK(function() {
  return "𠮷".at(-2) !== "\uD842";
});
BK({ target: "String", proto: !0, forced: GK }, {
  at: function(e) {
    var n = YK(HK(this)), r = n.length, a = VK(e), s = a >= 0 ? a : r + a;
    return s < 0 || s >= r ? void 0 : WK(n, s);
  }
});
var XK = vb;
XK("String", "at");
var qK = jp, X3 = function() {
  var t = qK(this), e = "";
  return t.hasIndices && (e += "d"), t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.unicodeSets && (e += "v"), t.sticky && (e += "y"), e;
}, nI = pa, QK = Wa, rI = QK.RegExp, iI = nI(function() {
  var t = rI("a", "y");
  return t.lastIndex = 2, t.exec("abcd") != null;
}), ZK = iI || nI(function() {
  return !rI("a", "y").sticky;
}), JK = iI || nI(function() {
  var t = rI("^r", "gy");
  return t.lastIndex = 2, t.exec("str") != null;
}), eW = {
  BROKEN_CARET: JK,
  MISSED_STICKY: ZK,
  UNSUPPORTED_Y: iI
}, tW = pa, nW = Wa, rW = nW.RegExp, iW = tW(function() {
  var t = rW(".", "s");
  return !(t.dotAll && t.exec(`
`) && t.flags === "s");
}), oW = pa, aW = Wa, sW = aW.RegExp, lW = oW(function() {
  var t = sW("(?<a>b)", "g");
  return t.exec("b").groups.a !== "b" || "b".replace(t, "$<a>c") !== "bc";
}), Ug = of, e1 = ro, cW = yb, uW = X3, dW = eW, fW = GP, pW = L3, hW = k3.get, gW = iW, mW = lW, vW = fW("native-string-replace", String.prototype.replace), bx = RegExp.prototype.exec, Xk = bx, yW = e1("".charAt), bW = e1("".indexOf), SW = e1("".replace), $T = e1("".slice), qk = function() {
  var t = /a/, e = /b*/g;
  return Ug(bx, t, "a"), Ug(bx, e, "a"), t.lastIndex !== 0 || e.lastIndex !== 0;
}(), q3 = dW.BROKEN_CARET, Qk = /()??/.exec("")[1] !== void 0, wW = qk || Qk || q3 || gW || mW;
wW && (Xk = function(e) {
  var n = this, r = hW(n), a = cW(e), s = r.raw, c, f, p, g, y, v, S;
  if (s)
    return s.lastIndex = n.lastIndex, c = Ug(Xk, s, a), n.lastIndex = s.lastIndex, c;
  var x = r.groups, _ = q3 && n.sticky, T = Ug(uW, n), I = n.source, D = 0, N = a;
  if (_ && (T = SW(T, "y", ""), bW(T, "g") === -1 && (T += "g"), N = $T(a, n.lastIndex), n.lastIndex > 0 && (!n.multiline || n.multiline && yW(a, n.lastIndex - 1) !== `
`) && (I = "(?: " + I + ")", N = " " + N, D++), f = new RegExp("^(?:" + I + ")", T)), Qk && (f = new RegExp("^" + I + "$(?!\\s)", T)), qk && (p = n.lastIndex), g = Ug(bx, _ ? f : n, N), _ ? g ? (g.input = $T(g.input, D), g[0] = $T(g[0], D), g.index = n.lastIndex, n.lastIndex += g[0].length) : n.lastIndex = 0 : qk && g && (n.lastIndex = n.global ? g.index + g[0].length : p), Qk && g && g.length > 1 && Ug(vW, g[0], f, function() {
    for (y = 1; y < arguments.length - 2; y++)
      arguments[y] === void 0 && (g[y] = void 0);
  }), g && x)
    for (g.groups = v = pW(null), y = 0; y < x.length; y++)
      S = x[y], v[S[0]] = g[S[1]];
  return g;
});
var oI = Xk, xW = im, eO = oI;
xW({ target: "RegExp", proto: !0, forced: /./.exec !== eO }, {
  exec: eO
});
var EW = qx, Q3 = Function.prototype, tO = Q3.apply, nO = Q3.call, CW = typeof Reflect == "object" && Reflect.apply || (EW ? nO.bind(tO) : function() {
  return nO.apply(tO, arguments);
}), rO = z3, iO = I3, _W = oI, oO = pa, Z3 = ju, TW = XP, kW = Z3("species"), MT = RegExp.prototype, PW = function(t, e, n, r) {
  var a = Z3(t), s = !oO(function() {
    var g = {};
    return g[a] = function() {
      return 7;
    }, ""[t](g) != 7;
  }), c = s && !oO(function() {
    var g = !1, y = /a/;
    return t === "split" && (y = {}, y.constructor = {}, y.constructor[kW] = function() {
      return y;
    }, y.flags = "", y[a] = /./[a]), y.exec = function() {
      return g = !0, null;
    }, y[a](""), !g;
  });
  if (!s || !c || n) {
    var f = rO(/./[a]), p = e(a, ""[t], function(g, y, v, S, x) {
      var _ = rO(g), T = y.exec;
      return T === _W || T === MT.exec ? s && !x ? { done: !0, value: f(y, v, S) } : { done: !0, value: _(v, y, S) } : { done: !1 };
    });
    iO(String.prototype, t, p[0]), iO(MT, a, p[1]);
  }
  r && TW(MT[a], "sham", !0);
}, aI = ro, IW = zp, RW = yb, $W = nm, MW = aI("".charAt), aO = aI("".charCodeAt), AW = aI("".slice), sO = function(t) {
  return function(e, n) {
    var r = RW($W(e)), a = IW(n), s = r.length, c, f;
    return a < 0 || a >= s ? t ? "" : void 0 : (c = aO(r, a), c < 55296 || c > 56319 || a + 1 === s || (f = aO(r, a + 1)) < 56320 || f > 57343 ? t ? MW(r, a) : c : t ? AW(r, a, a + 2) : (c - 55296 << 10) + (f - 56320) + 65536);
  };
}, OW = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: sO(!1),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: sO(!0)
}, DW = OW.charAt, NW = function(t, e, n) {
  return e + (n ? DW(t, e).length : 1);
}, sI = ro, LW = hb, jW = Math.floor, AT = sI("".charAt), zW = sI("".replace), OT = sI("".slice), UW = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, BW = /\$([$&'`]|\d{1,2})/g, J3 = function(t, e, n, r, a, s) {
  var c = n + t.length, f = r.length, p = BW;
  return a !== void 0 && (a = LW(a), p = UW), zW(s, p, function(g, y) {
    var v;
    switch (AT(y, 0)) {
      case "$":
        return "$";
      case "&":
        return t;
      case "`":
        return OT(e, 0, n);
      case "'":
        return OT(e, c);
      case "<":
        v = a[OT(y, 1, -1)];
        break;
      default:
        var S = +y;
        if (S === 0)
          return g;
        if (S > f) {
          var x = jW(S / 10);
          return x === 0 ? g : x <= f ? r[x - 1] === void 0 ? AT(y, 1) : r[x - 1] + AT(y, 1) : g;
        }
        v = r[S - 1];
    }
    return v === void 0 ? "" : v;
  });
}, lO = of, FW = jp, HW = ha, VW = tm, YW = oI, KW = TypeError, WW = function(t, e) {
  var n = t.exec;
  if (HW(n)) {
    var r = lO(n, t, e);
    return r !== null && FW(r), r;
  }
  if (VW(t) === "RegExp")
    return lO(YW, t, e);
  throw KW("RegExp#exec called on incompatible receiver");
}, GW = CW, cO = of, t1 = ro, XW = PW, qW = pa, QW = jp, ZW = ha, JW = Qx, eG = zp, tG = $3, Tg = yb, nG = nm, rG = NW, iG = YP, oG = J3, aG = WW, sG = ju, Zk = sG("replace"), lG = Math.max, cG = Math.min, uG = t1([].concat), DT = t1([].push), uO = t1("".indexOf), dO = t1("".slice), dG = function(t) {
  return t === void 0 ? t : String(t);
}, fG = function() {
  return "a".replace(/./, "$0") === "$0";
}(), fO = function() {
  return /./[Zk] ? /./[Zk]("a", "$0") === "" : !1;
}(), pG = !qW(function() {
  var t = /./;
  return t.exec = function() {
    var e = [];
    return e.groups = { a: "7" }, e;
  }, "".replace(t, "$<a>") !== "7";
});
XW("replace", function(t, e, n) {
  var r = fO ? "$" : "$0";
  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function(s, c) {
      var f = nG(this), p = JW(s) ? void 0 : iG(s, Zk);
      return p ? cO(p, s, f, c) : cO(e, Tg(f), s, c);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function(a, s) {
      var c = QW(this), f = Tg(a);
      if (typeof s == "string" && uO(s, r) === -1 && uO(s, "$<") === -1) {
        var p = n(e, c, f, s);
        if (p.done)
          return p.value;
      }
      var g = ZW(s);
      g || (s = Tg(s));
      var y = c.global;
      if (y) {
        var v = c.unicode;
        c.lastIndex = 0;
      }
      for (var S = []; ; ) {
        var x = aG(c, f);
        if (x === null || (DT(S, x), !y))
          break;
        var _ = Tg(x[0]);
        _ === "" && (c.lastIndex = rG(f, tG(c.lastIndex), v));
      }
      for (var T = "", I = 0, D = 0; D < S.length; D++) {
        x = S[D];
        for (var N = Tg(x[0]), j = lG(cG(eG(x.index), f.length), 0), L = [], z = 1; z < x.length; z++)
          DT(L, dG(x[z]));
        var F = x.groups;
        if (g) {
          var K = uG([N], L, j, f);
          F !== void 0 && DT(K, F);
          var X = Tg(GW(s, void 0, K));
        } else
          X = oG(N, f, j, L, F, s);
        j >= I && (T += dO(f, I, j) + X, I = j + N.length);
      }
      return T + dO(f, I);
    }
  ];
}, !pG || !fG || fO);
var hG = Lp, gG = tm, mG = ju, vG = mG("match"), yG = function(t) {
  var e;
  return hG(t) && ((e = t[vG]) !== void 0 ? !!e : gG(t) == "RegExp");
}, bG = of, SG = af, wG = d3, xG = X3, pO = RegExp.prototype, EG = function(t) {
  var e = t.flags;
  return e === void 0 && !("flags" in pO) && !SG(t, "flags") && wG(pO, t) ? bG(xG, t) : e;
}, CG = im, _G = of, lI = ro, hO = nm, TG = ha, kG = Qx, PG = yG, Ty = yb, IG = YP, RG = EG, $G = J3, MG = ju, AG = MG("replace"), OG = TypeError, eL = lI("".indexOf);
lI("".replace);
var gO = lI("".slice), DG = Math.max, mO = function(t, e, n) {
  return n > t.length ? -1 : e === "" ? n : eL(t, e, n);
};
CG({ target: "String", proto: !0 }, {
  replaceAll: function(e, n) {
    var r = hO(this), a, s, c, f, p, g, y, v, S, x = 0, _ = 0, T = "";
    if (!kG(e)) {
      if (a = PG(e), a && (s = Ty(hO(RG(e))), !~eL(s, "g")))
        throw OG("`.replaceAll` does not allow non-global regexes");
      if (c = IG(e, AG), c)
        return _G(c, e, r, n);
    }
    for (f = Ty(r), p = Ty(e), g = TG(n), g || (n = Ty(n)), y = p.length, v = DG(1, y), x = mO(f, p, 0); x !== -1; )
      S = g ? Ty(n(p, x, f)) : $G(p, f, x, [], void 0, n), T += gO(f, _, x) + S, _ = x + y, x = mO(f, p, x + v);
    return _ < f.length && (T += gO(f, _)), T;
  }
});
var NG = vb;
NG("String", "replaceAll");
function Sx(t, e) {
  const n = [];
  e:
    for (const r of t) {
      for (const a of n)
        if (e ? e(r, a) : r === a)
          continue e;
      n.push(r);
    }
  return n;
}
function Gt(t) {
  return t.filter((e) => e != null);
}
function Bs(t) {
  return t[t.length - 1];
}
function LG(t, e) {
  let n, r = 1 / 0;
  for (const a of t) {
    const s = e(a);
    s < r && (n = a, r = s);
  }
  return n;
}
function jG(t, e) {
  const n = [], r = [];
  for (const a of t)
    e(a) ? n.push(a) : r.push(a);
  return [n, r];
}
function tL(t) {
  const e = (...n) => {
    try {
      return t(...n);
    } catch (r) {
      throw r instanceof Error && Error.captureStackTrace && Error.captureStackTrace(r, e), r;
    }
  };
  return e;
}
function zG(t, e) {
  const n = e && t && typeof t == "object" && e in t ? t[e] : t;
  throw new Error(`Unknown switch case ${n}`);
}
const nL = tL(
  (t, e) => {
    if (!t)
      throw new Error(e || "Assertion Error");
  }
), UG = tL((t, e) => {
  if (t == null)
    throw new Error(e ?? "value must be defined");
  return t;
});
function cI(t, e) {
  let n;
  const r = (...a) => (n || (n = {}, n.promise = new Promise((s, c) => {
    n.resolve = s, n.reject = c;
  })), clearTimeout(n.timeout), n.latestArgs = a, n.timeout = setTimeout(() => {
    const s = n;
    n = void 0;
    try {
      s.resolve(t(...s.latestArgs));
    } catch (c) {
      s.reject(c);
    }
  }, e), n.promise);
  return r.cancel = () => {
    n && clearTimeout(n.timeout);
  }, r;
}
const vO = /* @__PURE__ */ new WeakMap();
function uI(t, e) {
  if (typeof t != "object" || t === null)
    return;
  let n = vO.get(t);
  n || (n = { tags: {}, extras: {} }, vO.set(t, n)), e.tags && (n.tags = {
    ...n.tags,
    ...e.tags
  }), e.extras && (n.extras = {
    ...n.extras,
    ...e.extras
  });
}
function n1(t) {
  let e = 0;
  for (let n = 0; n < t.length; n++)
    e = (e << 5) - e + t.charCodeAt(n), e |= 0;
  return e + "";
}
function Uy(t = "") {
  let e = 0, n = 0, r = 0, a = 0;
  function s() {
    const c = e ^ e << 11;
    return e = n, n = r, r = a, a ^= (a >>> 19 ^ c ^ c >>> 8) >>> 0, a / 4294967296 * 2;
  }
  for (let c = 0; c < t.length + 64; c++)
    e ^= t.charCodeAt(c) | 0, s();
  return s;
}
function Jk(t, e, n, r = !1) {
  const [a, s] = e, [c, f] = n, p = c + (t - a) / (s - a) * (f - c);
  return r ? c < f ? Math.max(Math.min(p, f), c) : Math.max(Math.min(p, c), f) : p;
}
function dI(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function wx(t, e) {
  if (dI(t, e))
    return t[e];
}
function Cc(t) {
  if (!t)
    return t;
  if (Array.isArray(t)) {
    const e = [], n = t.length;
    for (let r = 0; r < n; r++)
      e.push(Cc(t[r]));
    return e;
  } else if (typeof t == "object") {
    const e = Object.keys(t), n = e.length, r = {};
    for (let a = 0; a < n; a++) {
      const s = e[a];
      r[s] = Cc(t[s]);
    }
    return r;
  }
  return t;
}
function yO(t) {
  return Object.values(t);
}
function rL(t) {
  return Object.entries(t);
}
function BG(t) {
  return t !== null;
}
function FG(t) {
  return t != null;
}
const Ou = typeof window < "u" && window.structuredClone ? window.structuredClone : (t) => t && JSON.parse(JSON.stringify(t));
class sx {
  constructor(e) {
    this.previousValue = e;
  }
  /**
   * The next value of the set.
   *
   * @internal
   */
  nextValue;
  /**
   * The diff of the set.
   *
   * @internal
   */
  diff;
  /**
   * Get the next value of the set.
   *
   * @public
   */
  get() {
    const e = this.diff?.removed?.size ?? 0, n = this.diff?.added?.size ?? 0;
    if (!(e === 0 && n === 0))
      return { value: this.nextValue, diff: this.diff };
  }
  /**
   * Add an item to the set.
   *
   * @param item - The item to add.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   *
   * @internal
   */
  _add(e, n) {
    this.nextValue ??= new Set(this.previousValue), this.nextValue.add(e), this.diff ??= {}, n ? this.diff.removed?.delete(e) : (this.diff.added ??= /* @__PURE__ */ new Set(), this.diff.added.add(e));
  }
  /**
   * Add an item to the set.
   *
   * @param item - The item to add.
   *
   * @public
   */
  add(e) {
    const n = this.previousValue.has(e);
    if (n)
      return this.diff?.removed?.has(e) ? this._add(e, n) : void 0;
    this.nextValue?.has(e) || this._add(e, n);
  }
  /**
   * Remove an item from the set.
   *
   * @param item - The item to remove.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   *
   * @internal
   */
  _remove(e, n) {
    this.nextValue ??= new Set(this.previousValue), this.nextValue.delete(e), this.diff ??= {}, n ? (this.diff.removed ??= /* @__PURE__ */ new Set(), this.diff.removed.add(e)) : this.diff.added?.delete(e);
  }
  /**
   * Remove an item from the set.
   *
   * @param item - The item to remove.
   *
   * @public
   */
  remove(e) {
    const n = this.previousValue.has(e);
    if (!n)
      return this.diff?.added?.has(e) ? this._remove(e, n) : void 0;
    this.diff?.removed?.has(e) || this._remove(e, n);
  }
}
let fI = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce((e, n) => (n &= 63, n < 36 ? e += n.toString(36) : n < 62 ? e += (n - 26).toString(36).toUpperCase() : n > 62 ? e += "-" : e += "_", e), "");
class pI {
  constructor(e, n) {
    this.typeName = e, this.createDefaultProperties = n.createDefaultProperties, this.migrations = n.migrations, this.validator = n.validator ?? { validate: (r) => r };
  }
  createDefaultProperties;
  migrations;
  validator;
  /**
   * Create a new record of this type.
   *
   * @param properties - The properties of the record.
   *
   * @returns The new record.
   */
  create(e) {
    const n = { ...this.createDefaultProperties(), id: this.createId() };
    for (const [r, a] of Object.entries(e))
      a !== void 0 && (n[r] = a);
    return n.typeName = this.typeName, n;
  }
  /**
   * Clone a record of this type.
   *
   * @param record - The record to clone.
   * @public
   * @returns The cloned record.
   */
  clone(e) {
    return { ...Ou(e), id: this.createId() };
  }
  /**
   * Create a new ID for this record type.
   *
   * @example
   * ```ts
   * const id = recordType.createId()
   * ```
   *
   * @public
   * @returns The new ID.
   */
  createId() {
    return this.typeName + ":" + fI();
  }
  /**
   * Create a new ID for this record type based on the given ID.
   *
   * @example
   * ```ts
   * const id = recordType.createCustomId("myId")
   * ```
   *
   * @param id - The ID to base the new ID on.
   * @returns The new ID.
   */
  createCustomId(e) {
    return this.typeName + ":" + e;
  }
  /**
   * Check whether a record is an instance of this record type.
   *
   * @example
   * ```ts
   * const result = recordType.isInstance(someRecord)
   * ```
   *
   * @param record - The record to check.
   * @returns Whether the record is an instance of this record type.
   */
  isInstance = (e) => e?.typeName === this.typeName;
  /**
   * Check whether an id is an id of this type.
   *
   * @example
   * ```ts
   * const result = recordType.isIn("someId")
   * ```
   *
   * @param id - The id to check.
   * @returns Whether the id is an id of this type.
   */
  isId(e) {
    if (!e)
      return !1;
    for (let n = 0; n < this.typeName.length; n++)
      if (e[n] !== this.typeName[n])
        return !1;
    return e[this.typeName.length] === ":";
  }
  /**
   * Create a new RecordType that has the same type name as this RecordType and includes the given default properties.
   *
   * @example
   * ```ts
   * const authorType = createRecordType('author', () => ({ living: true }))
   * const deadAuthorType = authorType.withDefaultProperties({ living: false })
   * ```
   *
   * @param fn - A function that returns the default properties of the new RecordType.
   *
   * @returns The new RecordType.
   */
  withDefaultProperties(e) {
    return new pI(this.typeName, {
      createDefaultProperties: e,
      migrations: this.migrations,
      validator: this.validator
    });
  }
  /**
   * Check that the passed in record passes the validations for this type.
   * Returns its input correctly typed if it does, but throws an error
   * otherwise.
   */
  validate(e) {
    return this.validator.validate(e);
  }
}
function Ic(t, e) {
  return new pI(t, {
    createDefaultProperties: () => ({}),
    migrations: e.migrations ?? { currentVersion: 0, firstVersion: 0, migrators: {} },
    validator: e.validator
  });
}
var bO = 8, iL = class {
  arraySize = 0;
  array = Array(bO);
  set = null;
  /**
   * Get whether this ArraySet has any elements.
   *
   * @returns True if this ArraySet has any elements, false otherwise.
   */
  get isEmpty() {
    if (this.array)
      return this.arraySize === 0;
    if (this.set)
      return this.set.size === 0;
    throw new Error("no set or array");
  }
  /**
   * Add an item to the ArraySet if it is not already present.
   *
   * @param elem - The element to add.
   */
  add(t) {
    if (this.array)
      return this.array.indexOf(t) !== -1 ? !1 : this.arraySize < bO ? (this.array[this.arraySize] = t, this.arraySize++, !0) : (this.set = new Set(this.array), this.array = null, this.set.add(t), !0);
    if (this.set)
      return this.set.has(t) ? !1 : (this.set.add(t), !0);
    throw new Error("no set or array");
  }
  /**
   * Remove an item from the ArraySet if it is present.
   *
   * @param elem - The element to remove
   */
  remove(t) {
    if (this.array) {
      const e = this.array.indexOf(t);
      return e === -1 ? !1 : (this.array[e] = void 0, this.arraySize--, e !== this.arraySize && (this.array[e] = this.array[this.arraySize], this.array[this.arraySize] = void 0), !0);
    }
    if (this.set)
      return this.set.has(t) ? (this.set.delete(t), !0) : !1;
    throw new Error("no set or array");
  }
  /**
   * Run a callback for each element in the ArraySet.
   *
   * @param visitor The callback to run for each element.
   */
  visit(t) {
    if (this.array) {
      for (let e = 0; e < this.arraySize; e++) {
        const n = this.array[e];
        typeof n < "u" && t(n);
      }
      return;
    }
    if (this.set) {
      this.set.forEach(t);
      return;
    }
    throw new Error("no set or array");
  }
};
function oL(t) {
  return t && typeof t == "object" && "parents" in t;
}
function aL(t) {
  for (let e = 0, n = t.parents.length; e < n; e++)
    if (t.parents[e].__unsafe__getWithoutCapture(), t.parents[e].lastChangedEpoch !== t.parentEpochs[e])
      return !0;
  return !1;
}
var xx = (t, e) => {
  if (t.children.remove(e) && t.children.isEmpty && oL(t))
    for (let n = 0, r = t.parents.length; n < r; n++)
      xx(t.parents[n], t);
}, hI = (t, e) => {
  if (t.children.add(e) && oL(t))
    for (let n = 0, r = t.parents.length; n < r; n++)
      hI(t.parents[n], t);
};
function sL(t, e) {
  return t === e || Object.is(t, e) || !!(t && e && typeof t.equals == "function" && t.equals(e));
}
var Ys = Object.freeze([]), SO = Symbol.for("__signia__"), wO = globalThis;
wO[SO] ? console.error(
  'Multiple versions of signia detected. This will cause unexpected behavior. Please add "resolutions" (yarn/pnpm) or "overrides" (npm) in your package.json to ensure only one version of signia is loaded.'
) : wO[SO] = !0;
var HG = class {
  constructor(t, e) {
    this.below = t, this.child = e;
  }
  offset = 0;
  numNewParents = 0;
  maybeRemoved;
}, Lr = null;
function lL(t) {
  Lr = new HG(Lr, t);
}
function cL() {
  const t = Lr;
  if (Lr = t.below, t.numNewParents > 0 || t.offset !== t.child.parents.length) {
    for (let n = t.offset; n < t.child.parents.length; n++) {
      const r = t.child.parents[n];
      t.child.parents.indexOf(r) >= t.offset && xx(r, t.child);
    }
    if (t.child.parents.length = t.offset, t.child.parentEpochs.length = t.offset, Lr?.maybeRemoved)
      for (let n = 0; n < Lr.maybeRemoved.length; n++) {
        const r = Lr.maybeRemoved[n];
        t.child.parents.indexOf(r) === -1 && xx(r, t.child);
      }
  }
}
function eP(t) {
  if (Lr) {
    const e = Lr.child.parents.indexOf(t);
    if (e < 0 && (Lr.numNewParents++, Lr.child.isActivelyListening && hI(t, Lr.child)), e < 0 || e >= Lr.offset) {
      if (e !== Lr.offset && e > 0) {
        const n = Lr.child.parents[Lr.offset];
        Lr.maybeRemoved ? Lr.maybeRemoved.indexOf(n) === -1 && Lr.maybeRemoved.push(n) : Lr.maybeRemoved = [n];
      }
      Lr.child.parents[Lr.offset] = t, Lr.child.parentEpochs[Lr.offset] = t.lastChangedEpoch, Lr.offset++;
    }
  }
}
var us = Symbol("RESET_VALUE"), uL = class {
  constructor(t) {
    this.capacity = t, this.buffer = new Array(t);
  }
  index = 0;
  // use a wrap around buffer to store the last N values
  buffer;
  /**
   * Add a diff to the history buffer.
   *
   * @param lastComputedEpoch The epoch when the diff was computed.
   * @param currentEpoch The current epoch.
   * @param diff (optional) The diff to add, or else a reset value.
   */
  pushEntry(t, e, n) {
    if (n !== void 0) {
      if (n === us) {
        this.clear();
        return;
      }
      this.buffer[this.index] = [t, e, n], this.index = (this.index + 1) % this.capacity;
    }
  }
  /**
   * Clear the history buffer.
   */
  clear() {
    this.index = 0, this.buffer.fill(void 0);
  }
  /**
   * Get the diffs since the given epoch.
   *
   * @param epoch The epoch to get diffs since.
   * @returns An array of diffs or a flag to reset the history buffer.
   */
  getChangesSince(t) {
    const { index: e, capacity: n, buffer: r } = this;
    for (let a = 0; a < n; a++) {
      const s = (e - 1 + n - a) % n, c = r[s];
      if (!c)
        return us;
      const [f, p] = c;
      if (a === 0 && t >= p)
        return [];
      if (f <= t && t < p) {
        const g = a + 1, y = new Array(g);
        for (let v = 0; v < g; v++)
          y[v] = r[(s + v) % n][2];
        return y;
      }
    }
    return us;
  }
}, xp = -1, xo = xp + 1, NT = !1;
function VG() {
  xo++;
}
var YG = class {
  constructor(t) {
    this.parent = t;
  }
  initialAtomValues = /* @__PURE__ */ new Map();
  /**
   * Get whether this transaction is a root (no parents).
   *
   * @public
   */
  get isRoot() {
    return this.parent === null;
  }
  /**
   * Commit the transaction's changes.
   *
   * @public
   */
  commit() {
    if (this.isRoot) {
      const t = this.initialAtomValues;
      this.initialAtomValues = /* @__PURE__ */ new Map(), dL(t.keys());
    } else
      this.initialAtomValues.forEach((t, e) => {
        this.parent.initialAtomValues.has(e) || this.parent.initialAtomValues.set(e, t);
      });
  }
  /**
   * Abort the transaction.
   *
   * @public
   */
  abort() {
    xo++, this.initialAtomValues.forEach((t, e) => {
      e.set(t), e.historyBuffer?.clear();
    }), this.commit();
  }
};
function dL(t) {
  if (NT)
    throw new Error("cannot change atoms during reaction cycle");
  try {
    NT = !0;
    const e = /* @__PURE__ */ new Set(), n = (r) => {
      r.lastTraversedEpoch !== xo && (r.lastTraversedEpoch = xo, "maybeScheduleEffect" in r ? e.add(r) : r.children.visit(n));
    };
    for (const r of t)
      r.children.visit(n);
    for (const r of e)
      r.maybeScheduleEffect();
  } finally {
    NT = !1;
  }
}
function KG(t, e) {
  Hd ? Hd.initialAtomValues.has(t) || Hd.initialAtomValues.set(t, e) : dL([t]);
}
var Hd = null;
function WG(t) {
  const e = new YG(Hd);
  Hd = e;
  try {
    let n = !1;
    const r = t(() => n = !0);
    return n ? e.abort() : e.commit(), r;
  } catch (n) {
    throw e.abort(), n;
  } finally {
    Hd = Hd.parent;
  }
}
function Pu(t) {
  return Hd ? t() : WG(t);
}
var GG = class {
  constructor(t, e, n) {
    this.name = t, this.current = e, this.isEqual = n?.isEqual ?? null, n && (n.historyLength && (this.historyBuffer = new uL(n.historyLength)), this.computeDiff = n.computeDiff);
  }
  isEqual;
  computeDiff;
  lastChangedEpoch = xo;
  children = new iL();
  historyBuffer;
  __unsafe__getWithoutCapture() {
    return this.current;
  }
  get value() {
    return eP(this), this.current;
  }
  set(t, e) {
    if (this.isEqual?.(this.current, t) ?? sL(this.current, t))
      return this.current;
    VG(), this.historyBuffer && this.historyBuffer.pushEntry(
      this.lastChangedEpoch,
      xo,
      e ?? this.computeDiff?.(this.current, t, this.lastChangedEpoch, xo) ?? us
    ), this.lastChangedEpoch = xo;
    const n = this.current;
    return this.current = t, KG(this, n), t;
  }
  update(t) {
    return this.set(t(this.current));
  }
  getDiffSince(t) {
    return eP(this), t >= this.lastChangedEpoch ? Ys : this.historyBuffer?.getChangesSince(t) ?? us;
  }
};
function fi(t, e, n) {
  return new GG(t, e, n);
}
var tP = Symbol("UNINITIALIZED"), Yg = (t) => t === tP, nP = class {
  constructor(t, e) {
    this.value = t, this.diff = e;
  }
};
function Dy(t, e) {
  return new nP(t, e);
}
var fL = class {
  constructor(t, e, n) {
    this.name = t, this.derive = e, n?.historyLength && (this.historyBuffer = new uL(n.historyLength)), this.computeDiff = n?.computeDiff, this.isEqual = n?.isEqual ?? sL;
  }
  lastChangedEpoch = xp;
  lastTraversedEpoch = xp;
  /**
   * The epoch when the reactor was last checked.
   */
  lastCheckedEpoch = xp;
  parents = [];
  parentEpochs = [];
  children = new iL();
  get isActivelyListening() {
    return !this.children.isEmpty;
  }
  historyBuffer;
  // The last-computed value of this signal.
  state = tP;
  computeDiff;
  isEqual;
  __unsafe__getWithoutCapture() {
    const t = this.lastChangedEpoch === xp;
    if (!t && (this.lastCheckedEpoch === xo || !aL(this)))
      return this.lastCheckedEpoch = xo, this.state;
    try {
      lL(this);
      const e = this.derive(this.state, this.lastCheckedEpoch), n = e instanceof nP ? e.value : e;
      if (this.state === tP || !this.isEqual(n, this.state)) {
        if (this.historyBuffer && !t) {
          const r = e instanceof nP ? e.diff : void 0;
          this.historyBuffer.pushEntry(
            this.lastChangedEpoch,
            xo,
            r ?? this.computeDiff?.(this.state, n, this.lastCheckedEpoch, xo) ?? us
          );
        }
        this.lastChangedEpoch = xo, this.state = n;
      }
      return this.lastCheckedEpoch = xo, this.state;
    } finally {
      cL();
    }
  }
  get value() {
    const t = this.__unsafe__getWithoutCapture();
    return eP(this), t;
  }
  getDiffSince(t) {
    return this.value, t >= this.lastChangedEpoch ? Ys : this.historyBuffer?.getChangesSince(t) ?? us;
  }
};
function xO(t = {}, e, n, r) {
  const a = r.get, s = Symbol.for("__signia__computed__" + n);
  return r.get = function() {
    let c = this[s];
    return c || (c = new fL(n, a.bind(this), t), Object.defineProperty(this, s, {
      enumerable: !1,
      configurable: !1,
      writable: !1,
      value: c
    })), c.value;
  }, r;
}
function pt() {
  if (arguments.length === 1) {
    const t = arguments[0];
    return (e, n, r) => xO(t, e, n, r);
  } else
    return typeof arguments[0] == "string" ? new fL(arguments[0], arguments[1], arguments[2]) : xO(void 0, arguments[0], arguments[1], arguments[2]);
}
var bb = class {
  constructor(t, e, n) {
    this.name = t, this.runEffect = e, this._scheduleEffect = n?.scheduleEffect;
  }
  _isActivelyListening = !1;
  /**
   * Whether this scheduler is attached and actively listening to its parents.
   * @public
   */
  get isActivelyListening() {
    return this._isActivelyListening;
  }
  /** @internal */
  lastTraversedEpoch = xp;
  lastReactedEpoch = xp;
  _scheduleCount = 0;
  /**
   * The number of times this effect has been scheduled.
   * @public
   */
  get scheduleCount() {
    return this._scheduleCount;
  }
  /** @internal */
  parentEpochs = [];
  /** @internal */
  parents = [];
  _scheduleEffect;
  /** @internal */
  maybeScheduleEffect() {
    if (this._isActivelyListening && this.lastReactedEpoch !== xo) {
      if (this.parents.length && !aL(this)) {
        this.lastReactedEpoch = xo;
        return;
      }
      this.scheduleEffect();
    }
  }
  /** @internal */
  scheduleEffect() {
    this._scheduleCount++, this._scheduleEffect ? this._scheduleEffect(this.maybeExecute) : this.execute();
  }
  maybeExecute = () => {
    this._isActivelyListening && this.execute();
  };
  /**
   * Makes this scheduler become 'actively listening' to its parents.
   * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.
   * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling [[EffectScheduler.execute]].
   * @public
   */
  attach() {
    this._isActivelyListening = !0;
    for (let t = 0, e = this.parents.length; t < e; t++)
      hI(this.parents[t], this);
  }
  /**
   * Makes this scheduler stop 'actively listening' to its parents.
   * It will no longer be eligible to receive 'maybeScheduleEffect' calls until [[EffectScheduler.attach]] is called again.
   */
  detach() {
    this._isActivelyListening = !1;
    for (let t = 0, e = this.parents.length; t < e; t++)
      xx(this.parents[t], this);
  }
  /**
   * Executes the effect immediately and returns the result.
   * @returns The result of the effect.
   */
  execute() {
    try {
      lL(this);
      const t = this.runEffect(this.lastReactedEpoch);
      return this.lastReactedEpoch = xo, t;
    } finally {
      cL();
    }
  }
};
function r1(t, e, n) {
  const r = new bb(t, e, n);
  return r.attach(), r.scheduleEffect(), () => {
    r.detach();
  };
}
function XG(t, e, n) {
  const r = new bb(t, e, n);
  return {
    scheduler: r,
    start: (a) => {
      const s = a?.force ?? !1;
      r.attach(), s ? r.scheduleEffect() : r.maybeScheduleEffect();
    },
    stop: () => {
      r.detach();
    }
  };
}
class EO {
  /** The map of items to their cached values. */
  items = /* @__PURE__ */ new WeakMap();
  /**
   * Get the cached value for a given record. If the record is not present in the map, the callback
   * will be used to create the value (with the result being stored in the cache for next time).
   *
   * @param item - The item to get.
   * @param cb - The callback to use to create the value when a cached value is not found.
   */
  get(e, n) {
    return this.items.has(e) || this.items.set(e, n(e)), this.items.get(e);
  }
}
function Ex(t) {
  if ({}.NODE_ENV === "production")
    return t;
  const e = Object.getPrototypeOf(t);
  if (e && !(e === Array.prototype || e === Object.prototype))
    throw console.error("cannot include non-js data in a record", t), new Error("cannot include non-js data in a record");
  const n = Object.getOwnPropertyNames(t);
  for (const r of n) {
    const a = t[r];
    a && typeof a == "object" && Ex(a);
  }
  return Object.freeze(t);
}
var Cx = { exports: {} };
Cx.exports;
(function(t, e) {
  var n = 200, r = "__lodash_hash_undefined__", a = 1, s = 2, c = 9007199254740991, f = "[object Arguments]", p = "[object Array]", g = "[object AsyncFunction]", y = "[object Boolean]", v = "[object Date]", S = "[object Error]", x = "[object Function]", _ = "[object GeneratorFunction]", T = "[object Map]", I = "[object Number]", D = "[object Null]", N = "[object Object]", j = "[object Promise]", L = "[object Proxy]", z = "[object RegExp]", F = "[object Set]", K = "[object String]", X = "[object Symbol]", se = "[object Undefined]", ue = "[object WeakMap]", pe = "[object ArrayBuffer]", Pe = "[object DataView]", ve = "[object Float32Array]", Y = "[object Float64Array]", le = "[object Int8Array]", Re = "[object Int16Array]", he = "[object Int32Array]", te = "[object Uint8Array]", de = "[object Uint8ClampedArray]", W = "[object Uint16Array]", fe = "[object Uint32Array]", ce = /[\\^$.*+?()[\]{}|]/g, xe = /^\[object .+?Constructor\]$/, $e = /^(?:0|[1-9]\d*)$/, Me = {};
  Me[ve] = Me[Y] = Me[le] = Me[Re] = Me[he] = Me[te] = Me[de] = Me[W] = Me[fe] = !0, Me[f] = Me[p] = Me[pe] = Me[y] = Me[Pe] = Me[v] = Me[S] = Me[x] = Me[T] = Me[I] = Me[N] = Me[z] = Me[F] = Me[K] = Me[ue] = !1;
  var re = typeof ca == "object" && ca && ca.Object === Object && ca, Qe = typeof self == "object" && self && self.Object === Object && self, ke = re || Qe || Function("return this")(), rt = e && !e.nodeType && e, St = rt && !0 && t && !t.nodeType && t, Tt = St && St.exports === rt, Le = Tt && re.process, Nt = function() {
    try {
      return Le && Le.binding && Le.binding("util");
    } catch {
    }
  }(), Ke = Nt && Nt.isTypedArray;
  function yt(q, ie) {
    for (var Ue = -1, it = q == null ? 0 : q.length, Pn = 0, Ut = []; ++Ue < it; ) {
      var Kn = q[Ue];
      ie(Kn, Ue, q) && (Ut[Pn++] = Kn);
    }
    return Ut;
  }
  function Xt(q, ie) {
    for (var Ue = -1, it = ie.length, Pn = q.length; ++Ue < it; )
      q[Pn + Ue] = ie[Ue];
    return q;
  }
  function kt(q, ie) {
    for (var Ue = -1, it = q == null ? 0 : q.length; ++Ue < it; )
      if (ie(q[Ue], Ue, q))
        return !0;
    return !1;
  }
  function yn(q, ie) {
    for (var Ue = -1, it = Array(q); ++Ue < q; )
      it[Ue] = ie(Ue);
    return it;
  }
  function Er(q) {
    return function(ie) {
      return q(ie);
    };
  }
  function tn(q, ie) {
    return q.has(ie);
  }
  function Mr(q, ie) {
    return q?.[ie];
  }
  function zr(q) {
    var ie = -1, Ue = Array(q.size);
    return q.forEach(function(it, Pn) {
      Ue[++ie] = [Pn, it];
    }), Ue;
  }
  function Hn(q, ie) {
    return function(Ue) {
      return q(ie(Ue));
    };
  }
  function xt(q) {
    var ie = -1, Ue = Array(q.size);
    return q.forEach(function(it) {
      Ue[++ie] = it;
    }), Ue;
  }
  var cn = Array.prototype, ti = Function.prototype, An = Object.prototype, qn = ke["__core-js_shared__"], Ko = ti.toString, Cr = An.hasOwnProperty, Je = function() {
    var q = /[^.]+$/.exec(qn && qn.keys && qn.keys.IE_PROTO || "");
    return q ? "Symbol(src)_1." + q : "";
  }(), Et = An.toString, nn = RegExp(
    "^" + Ko.call(Cr).replace(ce, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), kn = Tt ? ke.Buffer : void 0, xn = ke.Symbol, _r = ke.Uint8Array, ur = An.propertyIsEnumerable, hi = cn.splice, pn = xn ? xn.toStringTag : void 0, gi = Object.getOwnPropertySymbols, On = kn ? kn.isBuffer : void 0, Dn = Hn(Object.keys, Object), io = Xo(ke, "DataView"), mi = Xo(ke, "Map"), ya = Xo(ke, "Promise"), Xa = Xo(ke, "Set"), gs = Xo(ke, "WeakMap"), oo = Xo(Object, "create"), ms = Br(io), ao = Br(mi), ba = Br(ya), so = Br(Xa), Sa = Br(gs), vi = xn ? xn.prototype : void 0, Ri = vi ? vi.valueOf : void 0;
  function yi(q) {
    var ie = -1, Ue = q == null ? 0 : q.length;
    for (this.clear(); ++ie < Ue; ) {
      var it = q[ie];
      this.set(it[0], it[1]);
    }
  }
  function J() {
    this.__data__ = oo ? oo(null) : {}, this.size = 0;
  }
  function Be(q) {
    var ie = this.has(q) && delete this.__data__[q];
    return this.size -= ie ? 1 : 0, ie;
  }
  function et(q) {
    var ie = this.__data__;
    if (oo) {
      var Ue = ie[q];
      return Ue === r ? void 0 : Ue;
    }
    return Cr.call(ie, q) ? ie[q] : void 0;
  }
  function st(q) {
    var ie = this.__data__;
    return oo ? ie[q] !== void 0 : Cr.call(ie, q);
  }
  function Kt(q, ie) {
    var Ue = this.__data__;
    return this.size += this.has(q) ? 0 : 1, Ue[q] = oo && ie === void 0 ? r : ie, this;
  }
  yi.prototype.clear = J, yi.prototype.delete = Be, yi.prototype.get = et, yi.prototype.has = st, yi.prototype.set = Kt;
  function qt(q) {
    var ie = -1, Ue = q == null ? 0 : q.length;
    for (this.clear(); ++ie < Ue; ) {
      var it = q[ie];
      this.set(it[0], it[1]);
    }
  }
  function Qt() {
    this.__data__ = [], this.size = 0;
  }
  function Rt(q) {
    var ie = this.__data__, Ue = Xs(ie, q);
    if (Ue < 0)
      return !1;
    var it = ie.length - 1;
    return Ue == it ? ie.pop() : hi.call(ie, Ue, 1), --this.size, !0;
  }
  function Ur(q) {
    var ie = this.__data__, Ue = Xs(ie, q);
    return Ue < 0 ? void 0 : ie[Ue][1];
  }
  function Qn(q) {
    return Xs(this.__data__, q) > -1;
  }
  function Zn(q, ie) {
    var Ue = this.__data__, it = Xs(Ue, q);
    return it < 0 ? (++this.size, Ue.push([q, ie])) : Ue[it][1] = ie, this;
  }
  qt.prototype.clear = Qt, qt.prototype.delete = Rt, qt.prototype.get = Ur, qt.prototype.has = Qn, qt.prototype.set = Zn;
  function hr(q) {
    var ie = -1, Ue = q == null ? 0 : q.length;
    for (this.clear(); ++ie < Ue; ) {
      var it = q[ie];
      this.set(it[0], it[1]);
    }
  }
  function wa() {
    this.size = 0, this.__data__ = {
      hash: new yi(),
      map: new (mi || qt)(),
      string: new yi()
    };
  }
  function Nl(q) {
    var ie = hn(this, q).delete(q);
    return this.size -= ie ? 1 : 0, ie;
  }
  function bn(q) {
    return hn(this, q).get(q);
  }
  function df(q) {
    return hn(this, q).has(q);
  }
  function Wo(q, ie) {
    var Ue = hn(this, q), it = Ue.size;
    return Ue.set(q, ie), this.size += Ue.size == it ? 0 : 1, this;
  }
  hr.prototype.clear = wa, hr.prototype.delete = Nl, hr.prototype.get = bn, hr.prototype.has = df, hr.prototype.set = Wo;
  function Jt(q) {
    var ie = -1, Ue = q == null ? 0 : q.length;
    for (this.__data__ = new hr(); ++ie < Ue; )
      this.add(q[ie]);
  }
  function xa(q) {
    return this.__data__.set(q, r), this;
  }
  function vs(q) {
    return this.__data__.has(q);
  }
  Jt.prototype.add = Jt.prototype.push = xa, Jt.prototype.has = vs;
  function lo(q) {
    var ie = this.__data__ = new qt(q);
    this.size = ie.size;
  }
  function ys() {
    this.__data__ = new qt(), this.size = 0;
  }
  function Ki(q) {
    var ie = this.__data__, Ue = ie.delete(q);
    return this.size = ie.size, Ue;
  }
  function Nc(q) {
    return this.__data__.get(q);
  }
  function $i(q) {
    return this.__data__.has(q);
  }
  function Lc(q, ie) {
    var Ue = this.__data__;
    if (Ue instanceof qt) {
      var it = Ue.__data__;
      if (!mi || it.length < n - 1)
        return it.push([q, ie]), this.size = ++Ue.size, this;
      Ue = this.__data__ = new hr(it);
    }
    return Ue.set(q, ie), this.size = Ue.size, this;
  }
  lo.prototype.clear = ys, lo.prototype.delete = Ki, lo.prototype.get = Nc, lo.prototype.has = $i, lo.prototype.set = Lc;
  function jc(q, ie) {
    var Ue = or(q), it = !Ue && xs(q), Pn = !Ue && !it && Fl(q), Ut = !Ue && !it && !Pn && Qa(q), Kn = Ue || it || Pn || Ut, Tr = Kn ? yn(q.length, String) : [], Wn = Tr.length;
    for (var U in q)
      (ie || Cr.call(q, U)) && !(Kn && // Safari 9 has enumerable `arguments.length` in strict mode.
      (U == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      Pn && (U == "offset" || U == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Ut && (U == "buffer" || U == "byteLength" || U == "byteOffset") || // Skip index properties.
      Ul(U, Wn))) && Tr.push(U);
    return Tr;
  }
  function Xs(q, ie) {
    for (var Ue = q.length; Ue--; )
      if (Si(q[Ue][0], ie))
        return Ue;
    return -1;
  }
  function Ll(q, ie, Ue) {
    var it = ie(q);
    return or(q) ? it : Xt(it, Ue(q));
  }
  function To(q) {
    return q == null ? q === void 0 ? se : D : pn && pn in Object(q) ? Qs(q) : gr(q);
  }
  function ko(q) {
    return co(q) && To(q) == f;
  }
  function bi(q, ie, Ue, it, Pn) {
    return q === ie ? !0 : q == null || ie == null || !co(q) && !co(ie) ? q !== q && ie !== ie : bs(q, ie, Ue, it, bi, Pn);
  }
  function bs(q, ie, Ue, it, Pn, Ut) {
    var Kn = or(q), Tr = or(ie), Wn = Kn ? p : rn(q), U = Tr ? p : rn(ie);
    Wn = Wn == f ? N : Wn, U = U == f ? N : U;
    var Z = Wn == N, ye = U == N, Ee = Wn == U;
    if (Ee && Fl(q)) {
      if (!Fl(ie))
        return !1;
      Kn = !0, Z = !1;
    }
    if (Ee && !Z)
      return Ut || (Ut = new lo()), Kn || Qa(q) ? qs(q, ie, Ue, it, Pn, Ut) : qa(q, ie, Wn, Ue, it, Pn, Ut);
    if (!(Ue & a)) {
      var Fe = Z && Cr.call(q, "__wrapped__"), ht = ye && Cr.call(ie, "__wrapped__");
      if (Fe || ht) {
        var Ze = Fe ? q.value() : q, bt = ht ? ie.value() : ie;
        return Ut || (Ut = new lo()), Pn(Ze, bt, Ue, it, Ut);
      }
    }
    return Ee ? (Ut || (Ut = new lo()), ff(q, ie, Ue, it, Pn, Ut)) : !1;
  }
  function Ss(q) {
    if (!zc(q) || Ft(q))
      return !1;
    var ie = Wr(q) ? nn : xe;
    return ie.test(Br(q));
  }
  function ws(q) {
    return co(q) && qo(q.length) && !!Me[To(q)];
  }
  function jl(q) {
    if (!Zs(q))
      return Dn(q);
    var ie = [];
    for (var Ue in Object(q))
      Cr.call(q, Ue) && Ue != "constructor" && ie.push(Ue);
    return ie;
  }
  function qs(q, ie, Ue, it, Pn, Ut) {
    var Kn = Ue & a, Tr = q.length, Wn = ie.length;
    if (Tr != Wn && !(Kn && Wn > Tr))
      return !1;
    var U = Ut.get(q);
    if (U && Ut.get(ie))
      return U == ie;
    var Z = -1, ye = !0, Ee = Ue & s ? new Jt() : void 0;
    for (Ut.set(q, ie), Ut.set(ie, q); ++Z < Tr; ) {
      var Fe = q[Z], ht = ie[Z];
      if (it)
        var Ze = Kn ? it(ht, Fe, Z, ie, q, Ut) : it(Fe, ht, Z, q, ie, Ut);
      if (Ze !== void 0) {
        if (Ze)
          continue;
        ye = !1;
        break;
      }
      if (Ee) {
        if (!kt(ie, function(bt, Yt) {
          if (!tn(Ee, Yt) && (Fe === bt || Pn(Fe, bt, Ue, it, Ut)))
            return Ee.push(Yt);
        })) {
          ye = !1;
          break;
        }
      } else if (!(Fe === ht || Pn(Fe, ht, Ue, it, Ut))) {
        ye = !1;
        break;
      }
    }
    return Ut.delete(q), Ut.delete(ie), ye;
  }
  function qa(q, ie, Ue, it, Pn, Ut, Kn) {
    switch (Ue) {
      case Pe:
        if (q.byteLength != ie.byteLength || q.byteOffset != ie.byteOffset)
          return !1;
        q = q.buffer, ie = ie.buffer;
      case pe:
        return !(q.byteLength != ie.byteLength || !Ut(new _r(q), new _r(ie)));
      case y:
      case v:
      case I:
        return Si(+q, +ie);
      case S:
        return q.name == ie.name && q.message == ie.message;
      case z:
      case K:
        return q == ie + "";
      case T:
        var Tr = zr;
      case F:
        var Wn = it & a;
        if (Tr || (Tr = xt), q.size != ie.size && !Wn)
          return !1;
        var U = Kn.get(q);
        if (U)
          return U == ie;
        it |= s, Kn.set(q, ie);
        var Z = qs(Tr(q), Tr(ie), it, Pn, Ut, Kn);
        return Kn.delete(q), Z;
      case X:
        if (Ri)
          return Ri.call(q) == Ri.call(ie);
    }
    return !1;
  }
  function ff(q, ie, Ue, it, Pn, Ut) {
    var Kn = Ue & a, Tr = Go(q), Wn = Tr.length, U = Go(ie), Z = U.length;
    if (Wn != Z && !Kn)
      return !1;
    for (var ye = Wn; ye--; ) {
      var Ee = Tr[ye];
      if (!(Kn ? Ee in ie : Cr.call(ie, Ee)))
        return !1;
    }
    var Fe = Ut.get(q);
    if (Fe && Ut.get(ie))
      return Fe == ie;
    var ht = !0;
    Ut.set(q, ie), Ut.set(ie, q);
    for (var Ze = Kn; ++ye < Wn; ) {
      Ee = Tr[ye];
      var bt = q[Ee], Yt = ie[Ee];
      if (it)
        var gn = Kn ? it(Yt, bt, Ee, ie, q, Ut) : it(bt, Yt, Ee, q, ie, Ut);
      if (!(gn === void 0 ? bt === Yt || Pn(bt, Yt, Ue, it, Ut) : gn)) {
        ht = !1;
        break;
      }
      Ze || (Ze = Ee == "constructor");
    }
    if (ht && !Ze) {
      var Ln = q.constructor, In = ie.constructor;
      Ln != In && "constructor" in q && "constructor" in ie && !(typeof Ln == "function" && Ln instanceof Ln && typeof In == "function" && In instanceof In) && (ht = !1);
    }
    return Ut.delete(q), Ut.delete(ie), ht;
  }
  function Go(q) {
    return Ll(q, Fu, zl);
  }
  function hn(q, ie) {
    var Ue = q.__data__;
    return Bl(ie) ? Ue[typeof ie == "string" ? "string" : "hash"] : Ue.map;
  }
  function Xo(q, ie) {
    var Ue = Mr(q, ie);
    return Ss(Ue) ? Ue : void 0;
  }
  function Qs(q) {
    var ie = Cr.call(q, pn), Ue = q[pn];
    try {
      q[pn] = void 0;
      var it = !0;
    } catch {
    }
    var Pn = Et.call(q);
    return it && (ie ? q[pn] = Ue : delete q[pn]), Pn;
  }
  var zl = gi ? function(q) {
    return q == null ? [] : (q = Object(q), yt(gi(q), function(ie) {
      return ur.call(q, ie);
    }));
  } : Po, rn = To;
  (io && rn(new io(new ArrayBuffer(1))) != Pe || mi && rn(new mi()) != T || ya && rn(ya.resolve()) != j || Xa && rn(new Xa()) != F || gs && rn(new gs()) != ue) && (rn = function(q) {
    var ie = To(q), Ue = ie == N ? q.constructor : void 0, it = Ue ? Br(Ue) : "";
    if (it)
      switch (it) {
        case ms:
          return Pe;
        case ao:
          return T;
        case ba:
          return j;
        case so:
          return F;
        case Sa:
          return ue;
      }
    return ie;
  });
  function Ul(q, ie) {
    return ie = ie ?? c, !!ie && (typeof q == "number" || $e.test(q)) && q > -1 && q % 1 == 0 && q < ie;
  }
  function Bl(q) {
    var ie = typeof q;
    return ie == "string" || ie == "number" || ie == "symbol" || ie == "boolean" ? q !== "__proto__" : q === null;
  }
  function Ft(q) {
    return !!Je && Je in q;
  }
  function Zs(q) {
    var ie = q && q.constructor, Ue = typeof ie == "function" && ie.prototype || An;
    return q === Ue;
  }
  function gr(q) {
    return Et.call(q);
  }
  function Br(q) {
    if (q != null) {
      try {
        return Ko.call(q);
      } catch {
      }
      try {
        return q + "";
      } catch {
      }
    }
    return "";
  }
  function Si(q, ie) {
    return q === ie || q !== q && ie !== ie;
  }
  var xs = ko(function() {
    return arguments;
  }()) ? ko : function(q) {
    return co(q) && Cr.call(q, "callee") && !ur.call(q, "callee");
  }, or = Array.isArray;
  function Nn(q) {
    return q != null && qo(q.length) && !Wr(q);
  }
  var Fl = On || Es;
  function Wi(q, ie) {
    return bi(q, ie);
  }
  function Wr(q) {
    if (!zc(q))
      return !1;
    var ie = To(q);
    return ie == x || ie == _ || ie == g || ie == L;
  }
  function qo(q) {
    return typeof q == "number" && q > -1 && q % 1 == 0 && q <= c;
  }
  function zc(q) {
    var ie = typeof q;
    return q != null && (ie == "object" || ie == "function");
  }
  function co(q) {
    return q != null && typeof q == "object";
  }
  var Qa = Ke ? Er(Ke) : ws;
  function Fu(q) {
    return Nn(q) ? jc(q) : jl(q);
  }
  function Po() {
    return [];
  }
  function Es() {
    return !1;
  }
  t.exports = Wi;
})(Cx, Cx.exports);
var qG = Cx.exports;
const QG = /* @__PURE__ */ Np(qG);
function ZG(t) {
  if (t.length === 0)
    return /* @__PURE__ */ new Set();
  const e = t[0], n = t.slice(1), r = /* @__PURE__ */ new Set();
  for (const a of e)
    n.every((s) => s.has(a)) && r.add(a);
  return r;
}
function JG(t, e) {
  const n = {};
  for (const r of e)
    t.has(r) || (n.added ??= /* @__PURE__ */ new Set(), n.added.add(r));
  for (const r of t)
    e.has(r) || (n.removed ??= /* @__PURE__ */ new Set(), n.removed.add(r));
  return n.added || n.removed ? n : void 0;
}
function CO(t, e) {
  for (const [n, r] of Object.entries(t)) {
    const a = r, s = e[n];
    if ("eq" in a && s !== a.eq || "neq" in a && s === a.neq || "gt" in a && (typeof s != "number" || s <= a.gt))
      return !1;
  }
  return !0;
}
function _O(t, e, n) {
  const r = Object.fromEntries(Object.keys(n).map((a) => [a, /* @__PURE__ */ new Set()]));
  for (const [a, s] of Object.entries(n))
    if ("eq" in s) {
      const f = t.index(e, a).value.get(s.eq);
      if (f)
        for (const p of f)
          r[a].add(p);
    } else if ("neq" in s) {
      const c = t.index(e, a);
      for (const [f, p] of c.value)
        if (f !== s.neq)
          for (const g of p)
            r[a].add(g);
    } else if ("gt" in s) {
      const c = t.index(e, a);
      for (const [f, p] of c.value)
        if (f > s.gt)
          for (const g of p)
            r[a].add(g);
    }
  return ZG(Object.values(r));
}
class eX {
  constructor(e, n) {
    this.atoms = e, this.history = n;
  }
  /**
   * A cache of derivations (indexes).
   *
   * @internal
   */
  indexCache = /* @__PURE__ */ new Map();
  /**
   * A cache of derivations (filtered histories).
   *
   * @internal
   */
  historyCache = /* @__PURE__ */ new Map();
  /**
   * Create a derivation that contains the hisotry for a given type
   *
   * @param typeName - The name of the type to filter by.
   *
   * @returns A derivation that returns the ids of all records of the given type.
   * @public
   */
  filterHistory(e) {
    if (this.historyCache.has(e))
      return this.historyCache.get(e);
    const n = pt(
      "filterHistory:" + e,
      (r, a) => {
        if (Yg(r))
          return this.history.value;
        const s = this.history.getDiffSince(a);
        if (s === us)
          return this.history.value;
        const c = { added: {}, removed: {}, updated: {} };
        let f = 0, p = 0, g = 0;
        for (const y of s) {
          for (const v of Object.values(y.added))
            if (v.typeName === e)
              if (c.removed[v.id]) {
                const S = c.removed[v.id];
                delete c.removed[v.id], p--, S !== v && (c.updated[v.id] = [S, v], g++);
              } else
                c.added[v.id] = v, f++;
          for (const [v, S] of Object.values(y.updated))
            S.typeName === e && (c.added[S.id] ? c.added[S.id] = S : c.updated[S.id] ? c.updated[S.id] = [c.updated[S.id][0], S] : (c.updated[S.id] = [v, S], g++));
          for (const v of Object.values(y.removed))
            v.typeName === e && (c.added[v.id] ? (delete c.added[v.id], f--) : c.updated[v.id] ? (c.removed[v.id] = c.updated[v.id][0], delete c.updated[v.id], g--, p++) : (c.removed[v.id] = v, p++));
        }
        return f || p || g ? Dy(this.history.value, c) : r;
      },
      { historyLength: 100 }
    );
    return this.historyCache.set(e, n), n;
  }
  /**
   * Create a derivation that returns an index on a property for the given type.
   *
   * @param typeName - The name of the type.
   * @param property - The name of the property.
   *
   * @public
   */
  index(e, n) {
    const r = e + ":" + n;
    if (this.indexCache.has(r))
      return this.indexCache.get(r);
    const a = this.__uncached_createIndex(e, n);
    return this.indexCache.set(r, a), a;
  }
  /**
   * Create a derivation that returns an index on a property for the given type.
   *
   * @param typeName - The name of the type?.
   * @param property - The name of the property?.
   *
   * @internal
   */
  __uncached_createIndex(e, n) {
    const r = this.filterHistory(e), a = () => {
      r.value;
      const s = /* @__PURE__ */ new Map();
      for (const c of Object.values(this.atoms.value)) {
        const f = c.value;
        if (f.typeName === e) {
          const p = f[n];
          s.has(p) || s.set(p, /* @__PURE__ */ new Set()), s.get(p).add(f.id);
        }
      }
      return s;
    };
    return pt(
      "index:" + e + ":" + n,
      (s, c) => {
        if (Yg(s))
          return a();
        const f = r.getDiffSince(c);
        if (f === us)
          return a();
        const p = /* @__PURE__ */ new Map(), g = (x, _) => {
          let T = p.get(x);
          T || (T = new sx(s.get(x) ?? /* @__PURE__ */ new Set())), T.add(_), p.set(x, T);
        }, y = (x, _) => {
          let T = p.get(x);
          T || (T = new sx(s.get(x) ?? /* @__PURE__ */ new Set())), T.remove(_), p.set(x, T);
        };
        for (const x of f) {
          for (const _ of Object.values(x.added))
            if (_.typeName === e) {
              const T = _[n];
              g(T, _.id);
            }
          for (const [_, T] of Object.values(x.updated))
            if (T.typeName === e) {
              const I = _[n], D = T[n];
              I !== D && (y(I, T.id), g(D, T.id));
            }
          for (const _ of Object.values(x.removed))
            if (_.typeName === e) {
              const T = _[n];
              y(T, _.id);
            }
        }
        let v, S;
        for (const [x, _] of p) {
          const T = _.get();
          T && (v || (v = new Map(s)), S || (S = /* @__PURE__ */ new Map()), T.value.size === 0 ? v.delete(x) : v.set(x, T.value), S.set(x, T.diff));
        }
        return v && S ? Dy(v, S) : s;
      },
      { historyLength: 100 }
    );
  }
  /**
   * Create a derivation that will return a signle record matching the given query.
   *
   * It will return undefined if there is no matching record
   *
   * @param typeName - The name of the type?
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */
  record(e, n = () => ({}), r = "record:" + e + (n ? ":" + n.toString() : "")) {
    const a = this.ids(e, n, r);
    return pt(r, () => {
      for (const s of a.value)
        return this.atoms.value[s]?.value;
    });
  }
  /**
   * Create a derivation that will return an array of records matching the given query
   *
   * @param typeName - The name of the type?
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */
  records(e, n = () => ({}), r = "records:" + e + (n ? ":" + n.toString() : "")) {
    const a = this.ids(e, n, "ids:" + r);
    return pt(r, () => [...a.value].map((s) => {
      const c = this.atoms.value[s];
      if (!c)
        throw new Error("no atom found for record id: " + s);
      return c.value;
    }));
  }
  /**
   * Create a derivation that will return the ids of all records of the given type.
   *
   * @param typeName - The name of the type.
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */
  ids(e, n = () => ({}), r = "ids:" + e + (n ? ":" + n.toString() : "")) {
    const a = this.filterHistory(e), s = () => {
      a.value;
      const p = n();
      return Object.keys(p).length === 0 ? new Set(
        Object.values(this.atoms.value).flatMap((g) => {
          const y = g.value;
          return y.typeName === e ? y.id : [];
        })
      ) : _O(this, e, p);
    }, c = (p) => {
      const g = s(), y = JG(p, g);
      return y ? Dy(g, y) : p;
    }, f = pt("ids_query:" + r, n, {
      isEqual: QG
    });
    return pt(
      "query:" + r,
      (p, g) => {
        const y = f.value;
        if (Yg(p))
          return s();
        if (g < f.lastChangedEpoch)
          return c(p);
        const v = a.getDiffSince(g);
        if (v === us)
          return c(p);
        const S = new sx(
          p
        );
        for (const _ of v) {
          for (const T of Object.values(_.added))
            T.typeName === e && CO(y, T) && S.add(T.id);
          for (const [T, I] of Object.values(_.updated))
            I.typeName === e && (CO(y, I) ? S.add(I.id) : S.remove(I.id));
          for (const T of Object.values(_.removed))
            T.typeName === e && S.remove(T.id);
        }
        const x = S.get();
        return x ? Dy(x.value, x.diff) : p;
      },
      { historyLength: 50 }
    );
  }
  exec(e, n) {
    const r = _O(this, e, n);
    if (r.size === 0)
      return Ys;
    const a = this.atoms.value;
    return [...r].map((s) => a[s].value);
  }
}
class pL {
  /**
   * An atom containing the store's atoms.
   *
   * @internal
   * @readonly
   */
  atoms = fi("store_atoms", {});
  /**
   * An atom containing the store's history.
   *
   * @public
   * @readonly
   */
  history = fi("history", 0, {
    historyLength: 1e3
  });
  /**
   * A StoreQueries instance for this store.
   *
   * @public
   * @readonly
   */
  query = new eX(this.atoms, this.history);
  /**
   * A set containing listeners that have been added to this store.
   *
   * @internal
   */
  listeners = /* @__PURE__ */ new Set();
  /**
   * An array of history entries that have not yet been flushed.
   *
   * @internal
   */
  historyAccumulator = new nX();
  /**
   * A reactor that responds to changes to the history by squashing the
   * accumulated history and notifying listeners of the changes.
   *
   * @internal
   */
  historyReactor;
  schema;
  props;
  constructor(e) {
    const { initialData: n, schema: r } = e;
    this.schema = r, this.props = e.props, n && this.atoms.set(
      Object.fromEntries(
        Object.entries(n).map(([a, s]) => [
          a,
          fi("atom:" + a, this.schema.validateRecord(this, s, "initialize", null))
        ])
      )
    ), this.historyReactor = XG(
      "Store.historyReactor",
      () => {
        this.history.value, this._flushHistory();
      },
      { scheduleEffect: (a) => requestAnimationFrame(a) }
    );
  }
  _flushHistory() {
    if (this.historyAccumulator.hasChanges()) {
      const e = this.historyAccumulator.flush();
      for (const { changes: n, source: r } of e)
        this.listeners.forEach((a) => a({ changes: n, source: r }));
    }
  }
  /**
   * Update the history with a diff of changes.
   *
   * @param changes - The changes to add to the history.
   */
  updateHistory(e) {
    this.historyAccumulator.add({
      changes: e,
      source: this.isMergingRemoteChanges ? "remote" : "user"
    }), this.listeners.size === 0 && this.historyAccumulator.clear(), this.history.set(this.history.value + 1, e);
  }
  validate(e) {
    this.allRecords().forEach((n) => this.schema.validateRecord(this, n, e, null));
  }
  /**
   * A callback fired after a record is created. Use this to perform
   * related updates to other records in the store.
   *
   * @param record - The record to be created
   */
  onAfterCreate;
  /**
   * A callback fired after each record's change.
   *
   * @param prev - The previous value, if any.
   * @param next - The next value.
   */
  onAfterChange;
  /**
   * A callback fired before a record is deleted.
   *
   * @param prev - The record that will be deleted.
   */
  onBeforeDelete;
  /**
   * A callback fired after a record is deleted.
   *
   * @param prev - The record that will be deleted.
   */
  onAfterDelete;
  // used to avoid running callbacks when rolling back changes in sync client
  _runCallbacks = !0;
  /**
   * Add some records to the store. It's an error if they already exist.
   *
   * @param records - The records to add.
   * @public
   */
  put = (e, n) => {
    Pu(() => {
      const r = {}, a = {}, s = this.atoms.__unsafe__getWithoutCapture();
      let c = null, f, p = !1;
      for (let v = 0, S = e.length; v < S; v++) {
        f = e[v];
        const x = (c ?? s)[f.id];
        if (x) {
          const _ = x.__unsafe__getWithoutCapture();
          f = this.schema.validateRecord(
            this,
            f,
            n ?? "updateRecord",
            _
          ), x.set(Ex(f));
          const T = x.__unsafe__getWithoutCapture();
          _ !== T && (p = !0, r[f.id] = [_, T]);
        } else
          p = !0, f = this.schema.validateRecord(
            this,
            f,
            n ?? "createRecord",
            null
          ), a[f.id] = f, c || (c = { ...s }), c[f.id] = fi("atom:" + f.id, f);
      }
      if (c && this.atoms.set(c), !p)
        return;
      this.updateHistory({
        added: a,
        updated: r,
        removed: {}
      });
      const { onAfterCreate: g, onAfterChange: y } = this;
      g && this._runCallbacks && Object.values(a).forEach((v) => {
        g(v);
      }), y && this._runCallbacks && Object.values(r).forEach(([v, S]) => {
        y(v, S);
      });
    });
  };
  /**
   * Remove some records from the store via their ids.
   *
   * @param ids - The ids of the records to remove.
   * @public
   */
  remove = (e) => {
    Pu(() => {
      if (this.onBeforeDelete && this._runCallbacks)
        for (const r of e) {
          const a = this.atoms.__unsafe__getWithoutCapture()[r];
          a && this.onBeforeDelete(a.value);
        }
      let n;
      if (this.atoms.update((r) => {
        let a;
        for (const s of e)
          s in r && (a || (a = { ...r }), n || (n = {}), delete a[s], n[s] = r[s].value);
        return a ?? r;
      }), !!n && (this.updateHistory({ added: {}, updated: {}, removed: n }), this.onAfterDelete && this._runCallbacks))
        for (let r = 0, a = e.length; r < a; r++)
          this.onAfterDelete(n[e[r]]);
    });
  };
  /**
   * Get the value of a store record by its id.
   *
   * @param id - The id of the record to get.
   * @public
   */
  get = (e) => this.atoms.value[e]?.value;
  /**
   * Get the value of a store record by its id without updating its epoch.
   *
   * @param id - The id of the record to get.
   * @public
   */
  unsafeGetWithoutCapture = (e) => this.atoms.value[e]?.__unsafe__getWithoutCapture();
  /**
   * Opposite of `deserialize`. Creates a JSON payload from the record store.
   *
   * @param filter - A function to filter structs that do not satisfy the predicate.
   * @returns The record store snapshot as a JSON payload.
   */
  serialize = (e) => {
    const n = {};
    for (const [r, a] of Object.entries(this.atoms.value)) {
      const s = a.value;
      typeof e == "function" && !e(s) || (n[r] = s);
    }
    return n;
  };
  /**
   * Opposite of `serialize`. Replace the store's current records with records as defined by a simple JSON structure into the stores.
   *
   * @param snapshot - The JSON snapshot to deserialize.
   * @public
   */
  deserialize = (e) => {
    Pu(() => {
      this.clear(), this.put(Object.values(e));
    });
  };
  /**
   * Get an array of all values in the store.
   *
   * @public
   * @returns An array of all values in the store.
   */
  allRecords = () => Object.values(this.atoms.value).map((e) => e.value);
  /**
   * Removes all records from the store.
   *
   * @public
   */
  clear = () => {
    this.remove(Object.keys(this.atoms.value));
  };
  /**
   * Update a record. To update multiple records at once, use the `update` method of the `TypedStore` class.
   *
   * @param id - The id of the record to update.
   * @param updater - A function that updates the record.
   */
  update = (e, n) => {
    const r = this.atoms.value[e];
    if (!r) {
      console.error(`Record ${e} not found. This is probably an error`);
      return;
    }
    this.put([n(r.__unsafe__getWithoutCapture())]);
  };
  /**
   * Get whether the record store has a id.
   *
   * @param id - The id of the record to check.
   * @public
   */
  has = (e) => !!this.atoms.value[e];
  /**
   * Add a new listener to the store.
   *
   * @param listener - The listener to call when the store updates.
   * @returns A function to remove the listener.
   */
  listen = (e) => (this._flushHistory(), this.listeners.add(e), this.historyReactor.scheduler.isActivelyListening || this.historyReactor.start(), () => {
    this.listeners.delete(e), this.listeners.size === 0 && this.historyReactor.stop();
  });
  isMergingRemoteChanges = !1;
  /**
   * Merge changes from a remote source without triggering listeners.
   *
   * @param fn - A function that merges the external changes.
   * @public
   */
  mergeRemoteChanges = (e) => {
    if (this.isMergingRemoteChanges)
      return e();
    try {
      this.isMergingRemoteChanges = !0, Pu(e);
    } finally {
      this.isMergingRemoteChanges = !1;
    }
  };
  extractingChanges(e) {
    const n = [], r = this.historyAccumulator.intercepting((a) => n.push(a.changes));
    try {
      return Pu(e), hL(n);
    } finally {
      r();
    }
  }
  applyDiff(e, n = !0) {
    const r = this._runCallbacks;
    try {
      this._runCallbacks = n, Pu(() => {
        const a = Object.values(e.added).concat(
          Object.values(e.updated).map(([c, f]) => f)
        ), s = Object.keys(e.removed);
        a.length && this.put(a), s.length && this.remove(s);
      });
    } finally {
      this._runCallbacks = r;
    }
  }
  /**
   * Create a computed cache.
   *
   * @param name - The name of the derivation cache.
   * @param derive - A function used to derive the value of the cache.
   * @public
   */
  createComputedCache = (e, n) => {
    const r = new EO();
    return {
      get: (a) => {
        const s = this.atoms.value[a];
        if (s)
          return r.get(
            s,
            () => pt(e + ":" + a, () => n(s.value))
          ).value;
      }
    };
  };
  /**
   * Create a computed cache from a selector
   *
   * @param name - The name of the derivation cache.
   * @param selector - A function that returns a subset of the original shape
   * @param derive - A function used to derive the value of the cache.
   * @public
   */
  createSelectedComputedCache = (e, n, r) => {
    const a = new EO();
    return {
      get: (s) => {
        const c = this.atoms.value[s];
        if (!c)
          return;
        const f = pt(
          e + ":" + s + ":selector",
          () => n(c.value)
        );
        return a.get(
          c,
          () => pt(e + ":" + s, () => r(f.value))
        ).value;
      }
    };
  };
  /** @internal */
  ensureStoreIsUsable() {
    this.schema.ensureStoreIsUsable(this);
  }
  _isPossiblyCorrupted = !1;
  /** @internal */
  markAsPossiblyCorrupted() {
    this._isPossiblyCorrupted = !0;
  }
  /** @internal */
  isPossiblyCorrupted() {
    return this._isPossiblyCorrupted;
  }
}
function hL(t) {
  const e = { added: {}, removed: {}, updated: {} };
  for (const n of t) {
    for (const [r, a] of Object.entries(n.added))
      if (e.removed[r]) {
        const s = e.removed[r];
        delete e.removed[r], s !== a && (e.updated[r] = [s, a]);
      } else
        e.added[r] = a;
    for (const [r, [a, s]] of Object.entries(n.updated)) {
      if (e.added[r]) {
        e.added[r] = s, delete e.updated[r], delete e.removed[r];
        continue;
      }
      if (e.updated[r]) {
        e.updated[r][1] = s, delete e.removed[r];
        continue;
      }
      e.updated[r] = n.updated[r], delete e.removed[r];
    }
    for (const [r, a] of Object.entries(n.removed))
      e.added[r] ? delete e.added[r] : e.updated[r] ? (e.removed[r] = e.updated[r][0], delete e.updated[r]) : e.removed[r] = a;
  }
  return e;
}
function tX(t) {
  const e = [];
  let n = t[0], r;
  for (let a = 1, s = t.length; a < s; a++)
    r = t[a], n.source !== r.source ? (e.push(n), n = r) : n = {
      source: n.source,
      changes: hL([n.changes, r.changes])
    };
  return e.push(n), e;
}
class nX {
  _history = [];
  _inteceptors = /* @__PURE__ */ new Set();
  intercepting(e) {
    return this._inteceptors.add(e), () => {
      this._inteceptors.delete(e);
    };
  }
  add(e) {
    this._history.push(e);
    for (const n of this._inteceptors)
      n(e);
  }
  flush() {
    const e = tX(this._history);
    return this._history = [], e;
  }
  clear() {
    this._history = [];
  }
  hasChanges() {
    return this._history.length > 0;
  }
  /**
   * Ensure that the store is usable. A class that extends this store should override this method.
   *
   * @param config - The configuration object. This can be any object that allows the store to validate that it is usable; the extending class should specify the type.
   *
   * @public
   */
  ensureStoreIsUsable(e = {}) {
  }
}
function rX(t) {
  return typeof t == "object" && t !== null && "id" in t && "typeName" in t;
}
function xr({
  firstVersion: t,
  currentVersion: e,
  migrators: n,
  subTypeKey: r,
  subTypeMigrations: a
}) {
  return { currentVersion: e, firstVersion: t, migrators: n, subTypeKey: r, subTypeMigrations: a };
}
var Ny = /* @__PURE__ */ ((t) => (t.IncompatibleSubtype = "incompatible-subtype", t.UnknownType = "unknown-type", t.TargetVersionTooNew = "target-version-too-new", t.TargetVersionTooOld = "target-version-too-old", t.MigrationError = "migration-error", t.UnrecognizedSubtype = "unrecognized-subtype", t))(Ny || {});
function Tw({
  record: t,
  migrations: e,
  fromVersion: n,
  toVersion: r
}) {
  let a = n;
  if (!rX(t))
    throw new Error("[migrateRecord] object is not a record");
  const { typeName: s, id: c, ...f } = t;
  let p = f;
  for (; a < r; ) {
    const g = a + 1, y = e.migrators[g];
    if (!y)
      return {
        type: "error",
        reason: "target-version-too-new"
        /* TargetVersionTooNew */
      };
    p = y.up(p), a = g;
  }
  for (; a > r; ) {
    const g = a - 1, y = e.migrators[a];
    if (!y)
      return {
        type: "error",
        reason: "target-version-too-old"
        /* TargetVersionTooOld */
      };
    p = y.down(p), a = g;
  }
  return {
    type: "success",
    value: { ...p, id: c, typeName: s }
  };
}
function iX({
  value: t,
  migrations: e,
  fromVersion: n,
  toVersion: r
}) {
  let a = n;
  for (; a < r; ) {
    const s = a + 1, c = e.migrators[s];
    if (!c)
      return {
        type: "error",
        reason: "target-version-too-new"
        /* TargetVersionTooNew */
      };
    t = c.up(t), a = s;
  }
  for (; a > r; ) {
    const s = a - 1, c = e.migrators[a];
    if (!c)
      return {
        type: "error",
        reason: "target-version-too-old"
        /* TargetVersionTooOld */
      };
    t = c.down(t), a = s;
  }
  return {
    type: "success",
    value: t
  };
}
class gI {
  constructor(e, n) {
    this.types = e, this.options = n;
  }
  static create(e, n) {
    return new gI(e, n ?? {});
  }
  get currentStoreVersion() {
    return this.options.snapshotMigrations?.currentVersion ?? 0;
  }
  validateRecord(e, n, r, a) {
    try {
      const s = wx(this.types, n.typeName);
      if (!s)
        throw new Error(`Missing definition for record type ${n.typeName}`);
      return s.validate(n);
    } catch (s) {
      if (this.options.onValidationFailure)
        return this.options.onValidationFailure({
          store: e,
          record: n,
          phase: r,
          recordBefore: a,
          error: s
        });
      throw s;
    }
  }
  migratePersistedRecord(e, n, r = "up") {
    const a = wx(this.types, e.typeName), s = n.recordVersions[e.typeName];
    if (!s || !a)
      return { type: "error", reason: Ny.UnknownType };
    const c = a.migrations.currentVersion, f = s.version;
    if (c !== f) {
      const v = Tw(r === "up" ? {
        record: e,
        migrations: a.migrations,
        fromVersion: f,
        toVersion: c
      } : {
        record: e,
        migrations: a.migrations,
        fromVersion: c,
        toVersion: f
      });
      if (v.type === "error")
        return v;
      e = v.value;
    }
    if (!a.migrations.subTypeKey)
      return { type: "success", value: e };
    const p = a.migrations.subTypeMigrations?.[e[a.migrations.subTypeKey]], g = "subTypeVersions" in s ? s.subTypeVersions[e[a.migrations.subTypeKey]] : null;
    if (p === void 0)
      return { type: "error", reason: Ny.UnrecognizedSubtype };
    if (g == null)
      return { type: "error", reason: Ny.IncompatibleSubtype };
    const y = Tw(r === "up" ? {
      record: e,
      migrations: p,
      fromVersion: g,
      toVersion: p.currentVersion
    } : {
      record: e,
      migrations: p,
      fromVersion: p.currentVersion,
      toVersion: g
    });
    return y.type === "error" ? y : { type: "success", value: y.value };
  }
  migrateStoreSnapshot(e, n) {
    const r = this.options.snapshotMigrations;
    if (!r)
      return { type: "success", value: e };
    const a = r.currentVersion, s = n.storeVersion ?? 0;
    if (a < s)
      return { type: "error", reason: Ny.TargetVersionTooOld };
    if (a > s) {
      const f = iX({
        value: e,
        migrations: r,
        fromVersion: s,
        toVersion: a
      });
      if (f.type === "error")
        return f;
      e = f.value;
    }
    const c = [];
    for (const f of Object.values(e)) {
      const p = this.migratePersistedRecord(f, n);
      if (p.type === "error")
        return p;
      p.value && p.value !== f && c.push(p.value);
    }
    if (c.length) {
      e = { ...e };
      for (const f of c)
        e[f.id] = f;
    }
    return { type: "success", value: e };
  }
  /** @internal */
  ensureStoreIsUsable(e) {
    this.options.ensureStoreIsUsable?.(e);
  }
  serialize() {
    return {
      schemaVersion: 1,
      storeVersion: this.options.snapshotMigrations?.currentVersion ?? 0,
      recordVersions: Object.fromEntries(
        yO(this.types).map((e) => [
          e.typeName,
          e.migrations.subTypeKey && e.migrations.subTypeMigrations ? {
            version: e.migrations.currentVersion,
            subTypeKey: e.migrations.subTypeKey,
            subTypeVersions: e.migrations.subTypeMigrations ? Object.fromEntries(
              Object.entries(e.migrations.subTypeMigrations).map(([n, r]) => [
                n,
                r.currentVersion
              ])
            ) : void 0
          } : {
            version: e.migrations.currentVersion
          }
        ])
      )
    };
  }
  serializeEarliestVersion() {
    return {
      schemaVersion: 1,
      storeVersion: this.options.snapshotMigrations?.firstVersion ?? 0,
      recordVersions: Object.fromEntries(
        yO(this.types).map((e) => [
          e.typeName,
          e.migrations.subTypeKey && e.migrations.subTypeMigrations ? {
            version: e.migrations.firstVersion,
            subTypeKey: e.migrations.subTypeKey,
            subTypeVersions: e.migrations.subTypeMigrations ? Object.fromEntries(
              Object.entries(e.migrations.subTypeMigrations).map(([n, r]) => [
                n,
                r.firstVersion
              ])
            ) : void 0
          } : {
            version: e.migrations.firstVersion
          }
        ])
      )
    };
  }
}
const oX = (t, e) => {
  if (t.schemaVersion > e.schemaVersion)
    return 1;
  if (t.schemaVersion < e.schemaVersion)
    return -1;
  if (t.storeVersion > e.storeVersion)
    return 1;
  if (t.storeVersion < e.storeVersion)
    return -1;
  for (const n of Object.keys(t.recordVersions)) {
    const r = t.recordVersions[n], a = e.recordVersions[n];
    if (r.version > a.version)
      return 1;
    if (r.version < a.version)
      return -1;
    if ("subTypeVersions" in r && !("subTypeVersions" in a))
      return 1;
    if (!("subTypeVersions" in r) && "subTypeVersions" in a)
      return -1;
    if (!(!("subTypeVersions" in r) || !("subTypeVersions" in a)))
      for (const s of Object.keys(r.subTypeVersions)) {
        const c = r.subTypeVersions[s], f = a.subTypeVersions[s];
        if (c > f)
          return 1;
        if (c < f)
          return -1;
      }
  }
  return 0;
};
function aX(t) {
  if (!t.length)
    return null;
  let e = "";
  for (const n of t)
    typeof n == "number" ? e += `.${n}` : n.startsWith("(") ? e.endsWith(")") ? e = `${e.slice(0, -1)}, ${n.slice(1)}` : e += n : e += `.${n}`;
  return e.startsWith(".") ? e.slice(1) : e;
}
class ei extends Error {
  constructor(e, n = []) {
    const r = aX(n), a = e.split(`
`).map((s, c) => c === 0 ? s : `  ${s}`).join(`
`);
    super(n ? `At ${r}: ${a}` : a), this.rawMessage = e, this.path = n;
  }
  name = "ValidationError";
}
function om(t, e) {
  try {
    return e();
  } catch (n) {
    throw n instanceof ei ? new ei(n.rawMessage, [t, ...n.path]) : new ei(n.toString(), [t]);
  }
}
function qg(t) {
  if (t === null)
    return "null";
  if (Array.isArray(t))
    return "an array";
  const e = typeof t;
  switch (e) {
    case "bigint":
    case "boolean":
    case "function":
    case "number":
    case "string":
    case "symbol":
      return `a ${e}`;
    case "object":
      return `an ${e}`;
    case "undefined":
      return "undefined";
    default:
      zG(e);
  }
}
class ds {
  constructor(e) {
    this.validationFn = e;
  }
  /**
   * Asserts that the passed value is of the correct type and returns it. The
   * returned value is guaranteed to be referentially equal to the passed
   * value.
   */
  validate(e) {
    const n = this.validationFn(e);
    if ({}.NODE_ENV !== "production" && !Object.is(e, n))
      throw new ei("Validator functions must return the same value they were passed");
    return n;
  }
  /**
   * Returns a new validator that also accepts null or undefined. The
   * resulting value will always be null.
   */
  nullable() {
    return new ds((e) => e === null ? null : this.validate(e));
  }
  /**
   * Returns a new validator that also accepts null or undefined. The
   * resulting value will always be null.
   */
  optional() {
    return new ds((e) => {
      if (e !== void 0)
        return this.validate(e);
    });
  }
  /**
   * Refine this validation to a new type. The passed-in validation function
   * should throw an error if the value can't be converted to the new type, or
   * return the new type otherwise.
   */
  refine(e) {
    return new ds((n) => e(this.validate(n)));
  }
  check(e, n) {
    return typeof e == "string" ? this.refine((r) => (om(`(check ${e})`, () => n(r)), r)) : this.refine((r) => (e(r), r));
  }
}
class sX extends ds {
  constructor(e) {
    super((n) => {
      const r = cX.validate(n);
      for (let a = 0; a < r.length; a++)
        om(a, () => e.validate(r[a]));
      return r;
    }), this.itemValidator = e;
  }
  nonEmpty() {
    return this.check((e) => {
      if (e.length === 0)
        throw new ei("Expected a non-empty array");
    });
  }
  lengthGreaterThan1() {
    return this.check((e) => {
      if (e.length <= 1)
        throw new ei("Expected an array with length greater than 1");
    });
  }
}
class _x extends ds {
  constructor(e, n = !1) {
    super((r) => {
      if (typeof r != "object" || r === null)
        throw new ei(`Expected object, got ${qg(r)}`);
      for (const [a, s] of Object.entries(e))
        om(a, () => {
          s.validate(wx(r, a));
        });
      if (!n) {
        for (const a of Object.keys(r))
          if (!dI(e, a))
            throw new ei("Unexpected property", [a]);
      }
      return r;
    }), this.config = e, this.shouldAllowUnknownProperties = n;
  }
  allowUnknownProperties() {
    return new _x(this.config, !0);
  }
  /**
   * Extend an object validator by adding additional properties.
   *
   * @example
   * ```ts
   *  const animalValidator = T.object({
   *      name: T.string,
   *  })
   *  const catValidator = animalValidator.extend({
   *      meowVolume: T.number,
   *  })
   * ```
   */
  extend(e) {
    return new _x({ ...this.config, ...e });
  }
}
class mI extends ds {
  constructor(e, n, r) {
    super((a) => {
      if (typeof a != "object" || a === null)
        throw new ei(`Expected an object, got ${qg(a)}`, []);
      const s = wx(a, e);
      if (typeof s != "string")
        throw new ei(
          `Expected a string for key "${e}", got ${qg(s)}`
        );
      const c = dI(n, s) ? n[s] : void 0;
      return c === void 0 ? this.unknownValueValidation(a, s) : om(`(${e} = ${s})`, () => c.validate(a));
    }), this.key = e, this.config = n, this.unknownValueValidation = r;
  }
  validateUnknownVariants(e) {
    return new mI(this.key, this.config, e);
  }
}
class lX extends ds {
  constructor(e, n) {
    super((r) => {
      if (typeof r != "object" || r === null)
        throw new ei(`Expected object, got ${qg(r)}`);
      for (const [a, s] of Object.entries(r))
        om(a, () => {
          e.validate(a), n.validate(s);
        });
      return r;
    }), this.keyValidator = e, this.valueValidator = n;
  }
}
function vI(t) {
  return new ds((e) => {
    if (typeof e !== t)
      throw new ei(`Expected ${t}, got ${qg(e)}`);
    return e;
  });
}
const Bn = vI("string"), Xn = vI("number").check((t) => {
  if (Number.isNaN(t))
    throw new ei("Expected a number, got NaN");
  if (!Number.isFinite(t))
    throw new ei(`Expected a finite number, got ${t}`);
}), yI = Xn.check((t) => {
  if (t < 0)
    throw new ei(`Expected a positive number, got ${t}`);
}), Ka = Xn.check((t) => {
  if (t <= 0)
    throw new ei(`Expected a non-zero positive number, got ${t}`);
}), gL = Xn.check((t) => {
  if (!Number.isInteger(t))
    throw new ei(`Expected an integer, got ${t}`);
});
gL.check((t) => {
  if (t < 0)
    throw new ei(`Expected a positive integer, got ${t}`);
});
gL.check((t) => {
  if (t <= 0)
    throw new ei(`Expected a non-zero positive integer, got ${t}`);
});
const Zr = vI("boolean");
function da(t) {
  return new ds((e) => {
    if (e !== t)
      throw new ei(`Expected ${t}, got ${JSON.stringify(e)}`);
    return t;
  });
}
const cX = new ds((t) => {
  if (!Array.isArray(t))
    throw new ei(`Expected an array, got ${qg(t)}`);
  return t;
});
function Kg(t) {
  return new sX(t);
}
function Mn(t) {
  return new _x(t);
}
function mL(t, e) {
  return new lX(t, e);
}
function bI(t, e) {
  return new mI(t, e, (n, r) => {
    throw new ei(
      `Expected one of ${Object.keys(e).map((a) => JSON.stringify(a)).join(" or ")}, got ${JSON.stringify(r)}`,
      [t]
    );
  });
}
function Rc(t, e) {
  return new ds((n) => {
    const r = n && typeof n == "object" && "id" in n && typeof n.id == "string" ? `${t}(id = ${n.id})` : t;
    return om(r, () => e.validate(n));
  });
}
function _o(t) {
  return new ds((e) => {
    if (!t.has(e)) {
      const n = Array.from(t, (r) => JSON.stringify(r)).join(" or ");
      throw new ei(`Expected ${n}, got ${e}`);
    }
    return e;
  });
}
const i1 = Mn({
  x: Xn,
  y: Xn,
  z: Xn.optional()
}), TO = Mn({
  x: Xn,
  y: Xn,
  w: Xn,
  h: Xn
}), vL = /* @__PURE__ */ new Set([
  "color",
  "labelColor",
  "dash",
  "fill",
  "size",
  "opacity",
  "font",
  "align",
  "icon",
  "geo",
  "arrowheadStart",
  "arrowheadEnd",
  "spline"
]), uX = /* @__PURE__ */ new Set([
  "black",
  "grey",
  "light-violet",
  "violet",
  "blue",
  "light-blue",
  "yellow",
  "orange",
  "green",
  "light-green",
  "light-red",
  "red"
]), dX = /* @__PURE__ */ new Set(["draw", "solid", "dashed", "dotted"]), fX = /* @__PURE__ */ new Set(["none", "semi", "solid", "pattern"]), pX = /* @__PURE__ */ new Set(["s", "m", "l", "xl"]), hX = /* @__PURE__ */ new Set(["0.1", "0.25", "0.5", "0.75", "1"]), gX = /* @__PURE__ */ new Set(["draw", "sans", "serif", "mono"]), mX = /* @__PURE__ */ new Set(["start", "middle", "end", "justify"]), yL = /* @__PURE__ */ new Set([
  "rectangle",
  "ellipse",
  "triangle",
  "diamond",
  "pentagon",
  "hexagon",
  "octagon",
  "star",
  "rhombus",
  "rhombus-2",
  "oval",
  "trapezoid",
  "arrow-right",
  "arrow-left",
  "arrow-up",
  "arrow-down",
  "x-box"
]), vX = /* @__PURE__ */ new Set([
  "arrow",
  "triangle",
  "square",
  "dot",
  "pipe",
  "diamond",
  "inverted",
  "bar",
  "none"
]), yX = /* @__PURE__ */ new Set(["cubic", "line"]), bX = /* @__PURE__ */ new Set([
  "activity",
  "airplay",
  "alert-circle",
  "alert-octagon",
  "alert-triangle",
  "align-center",
  "align-justify",
  "align-left",
  "align-right",
  "anchor",
  "aperture",
  "archive",
  "arrow-down-circle",
  "arrow-down-left",
  "arrow-down-right",
  "arrow-down",
  "arrow-left-circle",
  "arrow-left",
  "arrow-right-circle",
  "arrow-right",
  "arrow-up-circle",
  "arrow-up-left",
  "arrow-up-right",
  "arrow-up",
  "at-sign",
  "award",
  "bar-chart-2",
  "bar-chart",
  "battery-charging",
  "battery",
  "bell-off",
  "bell",
  "bluetooth",
  "bold",
  "book-open",
  "book",
  "bookmark",
  "geo",
  "briefcase",
  "calendar",
  "camera-off",
  "camera",
  "cast",
  "check-circle",
  "check-square",
  "check",
  "chevron-down",
  "chevron-left",
  "chevron-right",
  "chevron-up",
  "chevrons-down",
  "chevrons-left",
  "chevrons-right",
  "chevrons-up",
  "chrome",
  "circle",
  "clipboard",
  "clock",
  "cloud-drizzle",
  "cloud-lightning",
  "cloud-off",
  "cloud-rain",
  "cloud-snow",
  "cloud",
  "codepen",
  "codesandbox",
  "coffee",
  "columns",
  "command",
  "compass",
  "copy",
  "corner-down-left",
  "corner-down-right",
  "corner-left-down",
  "corner-left-up",
  "corner-right-down",
  "corner-right-up",
  "corner-up-left",
  "corner-up-right",
  "cpu",
  "credit-card",
  "crop",
  "crosshair",
  "database",
  "delete",
  "disc",
  "divide-circle",
  "divide-square",
  "divide",
  "dollar-sign",
  "download-cloud",
  "download",
  "dribbble",
  "droplet",
  "edit-2",
  "edit-3",
  "edit",
  "external-link",
  "eye-off",
  "eye",
  "facebook",
  "fast-forward",
  "feather",
  "figma",
  "file-minus",
  "file-plus",
  "file-text",
  "file",
  "film",
  "filter",
  "flag",
  "folder-minus",
  "folder-plus",
  "folder",
  "framer",
  "frown",
  "gift",
  "git-branch",
  "git-commit",
  "git-merge",
  "git-pull-request",
  "github",
  "gitlab",
  "globe",
  "grid",
  "hard-drive",
  "hash",
  "headphones",
  "heart",
  "help-circle",
  "hexagon",
  "home",
  "image",
  "inbox",
  "info",
  "instagram",
  "italic",
  "key",
  "layers",
  "layout",
  "life-buoy",
  "link-2",
  "link",
  "linkedin",
  "list",
  "loader",
  "lock",
  "log-in",
  "log-out",
  "mail",
  "map-pin",
  "map",
  "maximize-2",
  "maximize",
  "meh",
  "menu",
  "message-circle",
  "message-square",
  "mic-off",
  "mic",
  "minimize-2",
  "minimize",
  "minus-circle",
  "minus-square",
  "minus",
  "monitor",
  "moon",
  "more-horizontal",
  "more-vertical",
  "mouse-pointer",
  "move",
  "music",
  "navigation-2",
  "navigation",
  "octagon",
  "package",
  "paperclip",
  "pause-circle",
  "pause",
  "pen-tool",
  "percent",
  "phone-call",
  "phone-forwarded",
  "phone-incoming",
  "phone-missed",
  "phone-off",
  "phone-outgoing",
  "phone",
  "pie-chart",
  "play-circle",
  "play",
  "plus-circle",
  "plus-square",
  "plus",
  "pocket",
  "power",
  "printer",
  "radio",
  "refresh-ccw",
  "refresh-cw",
  "repeat",
  "rewind",
  "rotate-ccw",
  "rotate-cw",
  "rss",
  "save",
  "scissors",
  "search",
  "send",
  "server",
  "settings",
  "share-2",
  "share",
  "shield-off",
  "shield",
  "shopping-bag",
  "shopping-cart",
  "shuffle",
  "sidebar",
  "skip-back",
  "skip-forward",
  "slack",
  "slash",
  "sliders",
  "smartphone",
  "smile",
  "speaker",
  "square",
  "star",
  "stop-circle",
  "sun",
  "sunrise",
  "sunset",
  "table",
  "tablet",
  "tag",
  "target",
  "terminal",
  "thermometer",
  "thumbs-down",
  "thumbs-up",
  "toggle-left",
  "toggle-right",
  "tool",
  "trash-2",
  "trash",
  "trello",
  "trending-down",
  "trending-up",
  "triangle",
  "truck",
  "tv",
  "twitch",
  "twitter",
  "type",
  "umbrella",
  "underline",
  "unlock",
  "upload-cloud",
  "upload",
  "user-check",
  "user-minus",
  "user-plus",
  "user-x",
  "user",
  "users",
  "video-off",
  "video",
  "voicemail",
  "volume-1",
  "volume-2",
  "volume-x",
  "volume",
  "watch",
  "wifi-off",
  "wifi",
  "wind",
  "x-circle",
  "x-octagon",
  "x-square",
  "x",
  "youtube",
  "zap-off",
  "zap",
  "zoom-in",
  "zoom-out"
]);
function $l(t) {
  return Bn.refine((e) => {
    if (!e.startsWith(`${t}:`))
      throw new Error(`${t} ID must start with "${t}:"`);
    return e;
  });
}
const o1 = $l("user"), a1 = $l("asset"), s1 = $l("page"), Ud = $l("shape"), SI = $l("instance"), SX = Bn.refine((t) => {
  if (!t.startsWith("page:") && !t.startsWith("shape:"))
    throw new Error('Parent ID must start with "page:" or "shape:"');
  return t;
}), Ml = _o(uX), am = _o(dX), l1 = _o(fX), bL = _o(yL), sf = _o(pX), Sb = _o(gX), c1 = _o(mX), Tx = _o(vX), Ga = _o(hX), SL = _o(bX), wL = _o(yX), wX = Rc(
  "camera",
  Mn({
    typeName: da("camera"),
    id: $l("camera"),
    x: Xn,
    y: Xn,
    z: Xn
  })
), kO = {
  Initial: 0
}, xX = xr({
  firstVersion: kO.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: kO.Initial,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {}
}), Gy = Ic("camera", {
  migrations: xX,
  validator: wX
}).withDefaultProperties(
  () => ({
    x: 0,
    y: 0,
    z: 1
  })
), EX = Rc(
  "document",
  Mn({
    typeName: da("document"),
    id: da("document:document"),
    gridSize: Xn
  })
), PO = {
  Initial: 0
}, CX = xr({
  firstVersion: PO.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: PO.Initial,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {}
}), wI = Ic("document", {
  migrations: CX,
  validator: EX
}).withDefaultProperties(
  () => ({
    gridSize: 10
  })
), kx = wI.createCustomId("document"), _X = /* @__PURE__ */ new Set([
  "accent",
  "white",
  "black",
  "selection-stroke",
  "selection-fill",
  "muted-1"
]), xL = _o(_X), TX = /* @__PURE__ */ new Set([
  "none",
  "default",
  "pointer",
  "cross",
  "grab",
  "rotate",
  "grabbing",
  "resize-edge",
  "resize-corner",
  "text",
  "move",
  "ew-resize",
  "ns-resize",
  "nesw-resize",
  "nwse-resize",
  "nesw-rotate",
  "nwse-rotate",
  "swne-rotate",
  "senw-rotate"
]), kX = _o(TX), PX = Mn({
  color: xL,
  type: kX,
  rotation: Xn
}), IX = /* @__PURE__ */ new Set(["starting", "paused", "active", "stopping"]), RX = Mn({
  points: Kg(i1),
  size: yI,
  color: xL,
  opacity: Xn,
  state: _o(IX)
}), $X = /* @__PURE__ */ new Set(["vertex", "virtual", "create"]), MX = Mn({
  id: Bn,
  type: _o($X),
  canBind: Zr.optional(),
  index: Bn,
  x: Xn,
  y: Xn
}), AX = Rc(
  "instance",
  Mn({
    typeName: da("instance"),
    id: $l("instance"),
    userId: o1,
    currentPageId: s1,
    brush: TO.nullable(),
    propsForNextShape: Mn({
      color: Ml,
      labelColor: Ml,
      dash: am,
      fill: l1,
      size: sf,
      opacity: Ga,
      font: Sb,
      align: c1,
      icon: SL,
      geo: bL,
      arrowheadStart: Tx,
      arrowheadEnd: Tx,
      spline: wL
    }),
    cursor: PX,
    scribble: RX.nullable(),
    isFocusMode: Zr,
    isDebugMode: Zr,
    isToolLocked: Zr,
    exportBackground: Zr,
    screenBounds: TO
  })
), pp = {
  Initial: 0,
  AddTransparentExportBgs: 1,
  RemoveDialog: 2,
  AddToolLockMode: 3,
  RemoveExtraPropsForNextShape: 4,
  AddLabelColor: 5
}, OX = xr({
  firstVersion: pp.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: pp.AddLabelColor,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {
    [pp.AddTransparentExportBgs]: {
      up: (t) => ({ ...t, exportBackground: !0 }),
      down: ({ exportBackground: t, ...e }) => e
    },
    [pp.RemoveDialog]: {
      up: ({ dialog: t, ...e }) => e,
      down: (t) => ({ ...t, dialog: null })
    },
    [pp.AddToolLockMode]: {
      up: (t) => ({ ...t, isToolLocked: !1 }),
      down: ({ isToolLocked: t, ...e }) => e
    },
    [pp.RemoveExtraPropsForNextShape]: {
      up: ({ propsForNextShape: t, ...e }) => ({
        ...e,
        propsForNextShape: Object.fromEntries(
          Object.entries(t).filter(
            ([n]) => vL.has(n)
          )
        )
      }),
      down: (t) => t
    },
    [pp.AddLabelColor]: {
      up: ({ propsForNextShape: t, ...e }) => ({
        ...e,
        propsForNextShape: {
          ...t,
          labelColor: "black"
        }
      }),
      down: (t) => {
        const { labelColor: e, ...n } = t.propsForNextShape;
        return {
          ...t,
          propsForNextShape: {
            ...n
          }
        };
      }
    }
  }
}), Pp = Ic("instance", {
  migrations: OX,
  validator: AX
}).withDefaultProperties(
  () => ({
    propsForNextShape: {
      opacity: "1",
      color: "black",
      labelColor: "black",
      dash: "draw",
      fill: "none",
      size: "m",
      icon: "file",
      font: "draw",
      align: "middle",
      geo: "rectangle",
      arrowheadStart: "none",
      arrowheadEnd: "arrow",
      spline: "line"
    },
    brush: null,
    scribble: null,
    cursor: {
      type: "default",
      color: "black",
      rotation: 0
    },
    isFocusMode: !1,
    exportBackground: !1,
    isDebugMode: {}.NODE_ENV === "development",
    isToolLocked: !1,
    screenBounds: { x: 0, y: 0, w: 1080, h: 720 }
  })
), DX = Rc(
  "instance_page_state",
  Mn({
    typeName: da("instance_page_state"),
    id: $l("instance_page_state"),
    instanceId: SI,
    pageId: s1,
    cameraId: $l("camera"),
    selectedIds: Kg(Ud),
    hintingIds: Kg(Ud),
    erasingIds: Kg(Ud),
    hoveredId: Ud.nullable(),
    editingId: Ud.nullable(),
    focusLayerId: Ud.nullable()
  })
), IO = {
  Initial: 0
}, NX = xr({
  currentVersion: IO.Initial,
  // STEP 2: Update the current version to point to your latest version
  firstVersion: IO.Initial,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {}
}), Xy = Ic("instance_page_state", {
  migrations: NX,
  validator: DX
}).withDefaultProperties(
  () => ({
    editingId: null,
    selectedIds: [],
    hoveredId: null,
    erasingIds: [],
    hintingIds: [],
    focusLayerId: null
  })
), LX = Rc(
  "page",
  Mn({
    typeName: da("page"),
    id: s1,
    name: Bn,
    index: Bn
  })
), RO = {
  Initial: 0
}, jX = xr({
  firstVersion: RO.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: RO.Initial,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {}
}), fr = Ic("page", {
  migrations: jX,
  validator: LX
}), zX = [
  { locale: "ar", label: "عربي" },
  { locale: "ca", label: "Català" },
  { locale: "da", label: "Danish" },
  { locale: "de", label: "Deutsch" },
  { locale: "en", label: "English" },
  { locale: "es", label: "Español" },
  { locale: "fa", label: "فارسی" },
  { locale: "fi", label: "Suomi" },
  { locale: "fr", label: "Français" },
  { locale: "gl", label: "Galego" },
  { locale: "he", label: "עברית" },
  { locale: "it", label: "Italiano" },
  { locale: "ja", label: "日本語" },
  { locale: "ko-kr", label: "한국어" },
  { locale: "ku", label: "کوردی" },
  { locale: "hi-in", label: "हिन्दी" },
  { locale: "hu", label: "Magyar" },
  { locale: "my", label: "မြန်မာစာ" },
  { locale: "ne", label: "नेपाली" },
  { locale: "no", label: "Norwegian" },
  { locale: "pl", label: "Polski" },
  { locale: "pt-br", label: "Português - Brasil" },
  { locale: "pt-pt", label: "Português - Europeu" },
  { locale: "ro", label: "Română" },
  { locale: "ru", label: "Russian" },
  { locale: "sv", label: "Svenska" },
  { locale: "te", label: "తెలుగు" },
  { locale: "th", label: "ภาษาไทย" },
  { locale: "tr", label: "Türkçe" },
  { locale: "uk", label: "Ukrainian" },
  { locale: "vi", label: "Tiếng Việt" },
  { locale: "zh-cn", label: "Chinese - Simplified" },
  { locale: "zh-tw", label: "繁體中文 (台灣)" }
], UX = Rc(
  "user",
  Mn({
    typeName: da("user"),
    id: o1,
    name: Bn,
    locale: Bn
  })
), $O = {
  Initial: 0
}, BX = xr({
  // STEP 2: Update the current version to point to your latest version
  currentVersion: $O.Initial,
  firstVersion: $O.Initial,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
  }
}), Ip = Ic("user", {
  migrations: BX,
  validator: UX
}).withDefaultProperties(() => {
  let t;
  if (typeof window < "u" && window.navigator) {
    const e = zX.map(({ locale: n }) => n);
    t = window.navigator.languages.find((n) => e.indexOf(n) > -1);
  }
  return {
    name: "New User",
    locale: t ?? "en"
  };
}), FX = Rc(
  "user_document",
  Mn({
    typeName: da("user_document"),
    id: $l("user_document"),
    userId: o1,
    isReadOnly: Zr,
    isPenMode: Zr,
    isGridMode: Zr,
    isDarkMode: Zr,
    isMobileMode: Zr,
    isSnapMode: Zr,
    lastUpdatedPageId: s1.nullable(),
    lastUsedTabId: SI.nullable()
  })
), kw = {
  Initial: 0,
  AddSnapMode: 1,
  AddMissingIsMobileMode: 2
}, HX = xr({
  firstVersion: kw.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: kw.AddMissingIsMobileMode,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {
    [kw.AddSnapMode]: {
      up: (t) => ({ ...t, isSnapMode: !1 }),
      down: ({ isSnapMode: t, ...e }) => e
    },
    [kw.AddMissingIsMobileMode]: {
      up: (t) => ({ ...t, isMobileMode: t.isMobileMode ?? !1 }),
      down: ({ isMobileMode: t, ...e }) => e
    }
  }
}), rP = Ic("user_document", {
  migrations: HX,
  validator: FX
}).withDefaultProperties(
  () => ({
    /* STEP 6: Add any new default values for properties here */
    isReadOnly: !1,
    isPenMode: !1,
    isGridMode: !1,
    isDarkMode: !1,
    isMobileMode: !1,
    isSnapMode: !1,
    lastUpdatedPageId: null,
    lastUsedTabId: null
  })
), VX = Rc(
  "user_presence",
  Mn({
    typeName: da("user_presence"),
    id: $l("user_presence"),
    userId: o1,
    lastUsedInstanceId: SI.nullable(),
    lastActivityTimestamp: Xn,
    cursor: i1,
    color: Bn
  })
), MO = {
  Initial: 0
}, YX = xr({
  // STEP 2: Update the current version to point to your latest version
  currentVersion: MO.Initial,
  firstVersion: MO.Initial,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
  }
}), iP = Ic("user_presence", {
  migrations: YX,
  validator: VX
}).withDefaultProperties(
  () => ({
    lastUsedInstanceId: null,
    lastActivityTimestamp: 0,
    cursor: { x: 0, y: 0 },
    color: "#000000"
  })
);
function KX(t, e) {
  return t.index < e.index ? -1 : t.index > e.index ? 1 : 0;
}
const AO = [
  "#FF802B",
  "#EC5E41",
  "#F2555A",
  "#F04F88",
  "#E34BA9",
  "#BD54C6",
  "#9D5BD2",
  "#7B66DC",
  "#02B1CC",
  "#11B3A3",
  "#39B178",
  "#55B467"
];
function OO(t) {
  t.typeName === "asset" && ("src" in t && (t.src = "<redacted>"), "src" in t.props && (t.props.src = "<redacted>"));
}
const WX = ({ error: t, phase: e, record: n, recordBefore: r }) => {
  throw uI(t, {
    tags: {
      origin: "store.validateRecord",
      storePhase: e,
      isExistingValidationIssue: (
        // if we're initializing the store for the first time, we should
        // allow invalid records so people can load old buggy data:
        e === "initialize"
      )
    },
    extras: {
      recordBefore: r ? OO(Ou(r)) : void 0,
      recordAfter: OO(Ou(n))
    }
  }), t;
};
function GX() {
  return AO[Math.floor(Math.random() * AO.length)];
}
function XX() {
  return [fr.create({ name: "Page 1", index: "a1" })];
}
function Sc(t) {
  const { userId: e, instanceId: n } = t.props;
  if (!t.has(kx))
    return t.put([wI.create({ id: kx })]), Sc(t);
  const r = t.allRecords(), a = r.filter(rP.isInstance).find((g) => g.userId === e);
  if (!a)
    return t.put([rP.create({ userId: e })]), Sc(t);
  const s = r.filter(fr.isInstance).sort(KX);
  if (s.length === 0)
    return t.put(XX()), Sc(t);
  const c = r.filter(Pp.isInstance).find((g) => g.id === n);
  if (!c) {
    const g = a.lastUsedTabId ? t.get(a.lastUsedTabId)?.propsForNextShape : void 0, y = a?.lastUpdatedPageId ?? s[0].id;
    return t.put([
      Pp.create({
        id: n,
        userId: e,
        currentPageId: y,
        propsForNextShape: g,
        exportBackground: !0
      })
    ]), Sc(t);
  }
  let f = c.currentPageId;
  if (!s.find((g) => g.id === f))
    return f = s[0].id, t.put([{ ...c, currentPageId: f }]), Sc(t);
  if (!r.find((g) => g.id === e))
    return t.put([Ip.create({ id: e })]), Sc(t);
  const p = r.filter(iP.isInstance).filter((g) => g.userId === e);
  if (p.length === 0)
    return t.put([iP.create({ userId: e, color: GX() })]), Sc(t);
  p.length > 1 && t.remove(p.slice(1).map((g) => g.id));
  for (const g of s) {
    const y = r.filter(Xy.isInstance).filter((S) => S.pageId === g.id && S.instanceId === n);
    if (y.length > 1)
      t.remove(y.slice(1).map((S) => S.id));
    else if (y.length === 0) {
      const S = Gy.create({});
      return t.put([
        S,
        Xy.create({ pageId: g.id, instanceId: n, cameraId: S.id })
      ]), Sc(t);
    }
    if (t.put([
      {
        ...y[0],
        erasingIds: [],
        hoveredId: null,
        editingId: null
      }
    ]), !t.get(y[0].cameraId))
      return t.put([Gy.create({ id: y[0].cameraId })]), Sc(t);
  }
}
function xI(t, e) {
  return Mn({
    id: a1,
    typeName: da("asset"),
    type: da(t),
    props: e
  });
}
const qX = xI(
  "bookmark",
  Mn({
    title: Bn,
    description: Bn,
    image: Bn,
    src: Bn.nullable()
  })
), DO = {
  Initial: 0
}, QX = xr({
  firstVersion: DO.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: DO.Initial,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {}
}), ZX = xI(
  "image",
  Mn({
    w: Xn,
    h: Xn,
    name: Bn,
    isAnimated: Zr,
    mimeType: Bn.nullable(),
    src: Bn.nullable()
  })
), Pw = {
  Initial: 0,
  AddIsAnimated: 1,
  RenameWidthHeight: 2
}, JX = xr({
  firstVersion: Pw.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: Pw.RenameWidthHeight,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {
    [Pw.AddIsAnimated]: {
      up: (t) => ({
        ...t,
        props: {
          ...t.props,
          isAnimated: !1
        }
      }),
      down: (t) => {
        const { isAnimated: e, ...n } = t.props;
        return {
          ...t,
          props: n
        };
      }
    },
    [Pw.RenameWidthHeight]: {
      up: (t) => {
        const { width: e, height: n, ...r } = t.props;
        return { ...t, props: { w: e, h: n, ...r } };
      },
      down: (t) => {
        const { w: e, h: n, ...r } = t.props;
        return { ...t, props: { width: e, height: n, ...r } };
      }
    }
  }
}), eq = xI(
  "video",
  Mn({
    w: Xn,
    h: Xn,
    name: Bn,
    isAnimated: Zr,
    mimeType: Bn.nullable(),
    src: Bn.nullable()
  })
), Iw = {
  Initial: 0,
  AddIsAnimated: 1,
  RenameWidthHeight: 2
}, tq = xr({
  firstVersion: Iw.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: Iw.RenameWidthHeight,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {
    [Iw.AddIsAnimated]: {
      up: (t) => ({
        ...t,
        props: {
          ...t.props,
          isAnimated: !1
        }
      }),
      down: (t) => {
        const { isAnimated: e, ...n } = t.props;
        return {
          ...t,
          props: n
        };
      }
    },
    [Iw.RenameWidthHeight]: {
      up: (t) => {
        const { width: e, height: n, ...r } = t.props;
        return { ...t, props: { w: e, h: n, ...r } };
      },
      down: (t) => {
        const { w: e, h: n, ...r } = t.props;
        return { ...t, props: { width: e, height: n, ...r } };
      }
    }
  }
});
function nq(t) {
  const e = Object.values(t);
  for (let n = 0; n < e.length; n++) {
    if (!e[n])
      continue;
    const { record: r } = rq(e[n]);
    r ? t[e[n].id] = r : delete t[e[n].id];
  }
  return t;
}
function rq(t) {
  const e = [];
  let n = JSON.parse(JSON.stringify(t));
  switch (n.typeName) {
    case "user_presence": {
      n.cursor || (e.push("no cursor"), n.cursor = { x: 0, y: 0 }), (n.cursor.x === void 0 || n.cursor.x === null) && (e.push("no cursor x"), n.cursor.x = 0), (n.cursor.y === void 0 || n.cursor.y === null) && (e.push("no cursor y"), n.cursor.y = 0);
      break;
    }
    case "asset": {
      switch (n.type) {
        case "image":
        case "video": {
          n.props || (e.push("no props in asset"), n.props = {
            w: 100,
            h: 100,
            name: "old_asset",
            isAnimated: !1,
            mimeType: null,
            src: null
          }), n.props.mimeType || (e.push("no mimeType in asset props"), n.props.mimeType = "image/png"), n.props.src || (e.push("no src in asset props"), n.props.src = ""), n.props.isAnimated == null && (e.push("no isAnimated in asset props"), n.props.isAnimated = !1), n.props.name === void 0 && (n.props.name = "asset"), "width" in n && (e.push("width in asset"), n.props.w = n.width, delete n.width), "width" in n.props && typeof n.props.width == "number" && n.props.width && (e.push("no w in asset props"), n.props.w = n.props.width, delete n.props.width), "height" in n && (e.push("height in asset"), n.props.h = n.height, delete n.height), "height" in n.props && typeof n.props.height == "number" && n.props.height && (e.push("no h in asset props"), n.props.h = n.props.height, delete n.props.height), n.props.w || (e.push("no w in asset props"), n.props.w = 100), n.props.h || (e.push("no h in asset props"), n.props.h = 100), "src" in n && (e.push("src in asset"), n.props.src = n.src, delete n.src), "name" in n && (e.push("name in asset"), delete n.name);
          break;
        }
        case "bookmark":
          n.props || (e.push("no asset props"), n.props = {
            title: "",
            description: "",
            image: "",
            src: "url" in n && typeof n.url == "string" ? n.url : ""
          }), n.props.title || (e.push("no title in bookmark asset props"), n.props.title = ""), n.props.description || (e.push("no description in bookmark asset props"), n.props.description = ""), n.props.image || (e.push("no image in bookmark asset props"), n.props.image = ""), "src" in n && (e.push("leftover src in bookmark asset"), delete n.src), "width" in n && (e.push("leftover width in bookmark asset"), delete n.width), "height" in n && (e.push("leftover height in bookmark asset"), delete n.height), "name" in n && (e.push("leftover name in bookmark asset"), delete n.name), "meta" in n && delete n.meta;
          break;
      }
      break;
    }
    case "camera": {
      (n.x === void 0 || n.x === null) && (e.push("no x in camera"), n.x = 0), (n.y === void 0 || n.y === null) && (e.push("no y in camera"), n.y = 0);
      break;
    }
    case "instance": {
      "props" in n && (e.push("leftover props in instance"), delete n.props), n.isToolLocked === void 0 && (e.push("no isToolLocked in instance"), n.isToolLocked = !1), n.propsForNextShape === void 0 && (e.push("no props in instance"), n.propsForNextShape = {
        opacity: "1",
        color: "black",
        dash: "draw",
        fill: "none",
        size: "m",
        icon: "file",
        font: "draw",
        align: "middle",
        geo: "rectangle",
        arrowheadStart: "none",
        arrowheadEnd: "arrow",
        spline: "line"
      }), "url" in n.propsForNextShape && (e.push("leftover url in instance.propsForNextShape"), delete n.propsForNextShape.url), "lang" in n.propsForNextShape && (e.push("leftover lang in instance.propsForNextShape"), delete n.propsForNextShape.lang), n.exportBackground === void 0 && (e.push(`no export background in ${n.typeName}`), n.exportBackground = !1), n.brush === void 0 && (e.push(`no brush in ${n.typeName}`), n.brush = null), n.scribble === void 0 && (e.push(`no scribble in ${n.typeName}`), n.scribble = null), n.dialog !== void 0 && (e.push(`no dialog in ${n.typeName}`), delete n.dialog), n.screenBounds === void 0 && (e.push(`no screen bounds in ${n.typeName}`), n.screenBounds = { x: 0, y: 0, w: 1080, h: 720 });
      break;
    }
    case "user": {
      n.name || (e.push("no name in user"), n.name = "User"), n.locale || (e.push("no locale in user"), n.locale = "en"), "cursor" in n && (e.push("leftover cursor in user"), delete n.cursor), "color" in n && (e.push("leftover color in user"), delete n.color), "brush" in n && (e.push("leftover brush in user"), delete n.brush), "selectedIds" in n && (e.push("leftover selectedIds in user"), delete n.selectedIds), "scribble" in n && (e.push("leftover scribble in user"), delete n.scribble), "currentPageId" in n && (e.push("leftover currentPageId in user"), delete n.currentPageId);
      break;
    }
    case "user_document": {
      n.isMobileMode === void 0 && (e.push("no ismobilemode in user document"), n.isMobileMode = !1), n.isSnapMode === void 0 && (e.push("no issnapmode in user document"), n.isSnapMode = !1);
      break;
    }
    case "shape": {
      if ("url" in n && delete n.url, (n.x === void 0 || n.x === null) && (e.push(`some bug in ${n.typeName} ${n.type}`), n.x = 0), (n.y === void 0 || n.y === null) && (e.push(`some bug in ${n.typeName} ${n.type}`), n.y = 0), n.type === "image" && (n.props.playing === void 0 && (e.push(`some bug in ${n.typeName} ${n.type}`), n.props.playing = !1), "loaded" in n.props && delete n.props.loaded), n.type === "arrow" && (n.props.start.type === "binding" ? ((n.props.start.normalizedAnchor.x === void 0 || n.props.start.normalizedAnchor.x === null) && (e.push(`some bug in ${n.typeName} ${n.type}`), n.props.start.normalizedAnchor.x = 0), (n.props.start.normalizedAnchor.y === void 0 || n.props.start.normalizedAnchor.y === null) && (e.push(`some bug in ${n.typeName} ${n.type}`), n.props.start.normalizedAnchor.y = 0)) : ((n.props.start.x === void 0 || n.props.start.x === null) && (e.push(`some bug in ${n.typeName} ${n.type}`), n.props.start.x = 0), (n.props.start.y === void 0 || n.props.start.y === null) && (e.push(`some bug in ${n.typeName} ${n.type}`), n.props.start.y = 0), "boundShapeId" in n.props.start && (e.push("leftover bound shape id in arrow"), delete n.props.start.boundShapeId), "normalizedAnchor" in n.props.start && (e.push("leftover normalize anchor in arrow"), delete n.props.start.normalizedAnchor), "isExact" in n.props.start && (e.push("leftover isExact in arrow"), delete n.props.start.isExact)), n.props.end.type === "binding" ? ((n.props.end.normalizedAnchor.x === void 0 || n.props.end.normalizedAnchor.x === null) && (e.push(`some bug in ${n.typeName}  ${n.type}`), n.props.end.normalizedAnchor.x = 0), (n.props.end.normalizedAnchor.y === void 0 || n.props.end.normalizedAnchor.y === null) && (e.push(`some bug in ${n.typeName} ${n.type}`), n.props.end.normalizedAnchor.y = 0)) : ((n.props.end.x === void 0 || n.props.end.x === null) && (e.push("no x in arrow end"), n.props.end.x = 0), (n.props.end.y === void 0 || n.props.end.y === null) && (e.push("no y in arrow end"), n.props.end.y = 0), "boundShapeId" in n.props.end && (e.push("leftover bound shape id in arrow"), delete n.props.end.boundShapeId), "normalizedAnchor" in n.props.end && (e.push("leftover normalize anchor in arrow"), delete n.props.end.normalizedAnchor), "isExact" in n.props.end && (e.push("leftover isExact in arrow"), delete n.props.end.isExact))), (n.type === "note" || n.type === "video" || n.type === "image" || n.type === "geo" || n.type === "bookmark") && n.props.url === void 0 && (e.push(`missing url prop in ${n.type} shape`), n.props.url = ""), n.type === "bookmark" && (n.props.assetId === void 0 && (e.push(`some bug in ${n.typeName}  ${n.type}`), n.props.assetId = null), "src" in n && (e.push("leftover src in bookmark"), delete n.src)), n.type === "geo" && ("width" in n.props && (e.push("leftover width in geo"), delete n.props.width), "height" in n.props && (e.push("leftover height in geo"), delete n.props.height)), n.type === "draw") {
        n.props.segments === void 0 && (e.push(`some bug in ${n.typeName}  ${n.type}`), n.props.segments = [
          {
            points: [
              { x: 0, y: 0, z: 0.5 },
              { x: 1, y: 1, z: 0.5 }
            ],
            type: "free"
          }
        ]);
        for (const r of n.props.segments)
          for (const a of r.points)
            (a.x === void 0 || a.y === null) && (e.push(`some bug in ${n.typeName}`), a.x = 0), (a.y === void 0 || a.y === null) && (e.push(`some bug in ${n.typeName}`), a.y = 0);
        "points" in n.props && delete n.props.points;
      }
      n.type === "bookmark" && "loaded" in n.props && (e.push("leftover loaded in bookmark"), delete n.props.loaded), n.type === "draw" && "points" in n.props && n.props.segments === void 0 && (n.props.segments = [{ type: "free", points: n.props.points }]), n.type === "image" && (n.props.w < 1 && (n.props.w = 1, e.push(`zero w image in ${n.typeName}`)), n.props.h < 1 && (n.props.h = 1, e.push(`zero h image in ${n.typeName}`))), n.type === "embed" && "loaded" in n.props && (e.push("leftover loaded in embed"), delete n.props.loaded);
      break;
    }
    case void 0:
      n = null;
  }
  return { record: n, issues: e };
}
const iq = Rc(
  "asset",
  bI("type", {
    image: ZX,
    video: eq,
    bookmark: qX
  })
), NO = {
  Initial: 0
}, oq = xr({
  firstVersion: NO.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: NO.Initial,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {},
  subTypeKey: "type",
  subTypeMigrations: {
    image: JX,
    video: tq,
    bookmark: QX
  }
}), sm = Ic("asset", {
  migrations: oq,
  validator: iq
}), LT = {
  Initial: 0,
  AddIsLocked: 1
}, jT = xr({
  // STEP 2: Update the current version to point to your latest version
  currentVersion: LT.AddIsLocked,
  firstVersion: LT.Initial,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
    [LT.AddIsLocked]: {
      up: (t) => ({
        ...t,
        isLocked: !1
      }),
      down: (t) => {
        const { isLocked: e, ...n } = t;
        return {
          ...n
        };
      }
    }
  }
});
function Ep(t) {
  return t ? t.typeName === "shape" : !1;
}
function Us(t) {
  return t ? t.startsWith("shape:") : !1;
}
function no() {
  return `shape:${fI()}`;
}
function aq(t) {
  return `shape:${t}`;
}
const zT = {
  Initial: 0,
  RemoveCodeAndIconShapeTypes: 1
}, sq = xr({
  // STEP 2: Update the current version to point to your latest version
  firstVersion: zT.Initial,
  currentVersion: zT.RemoveCodeAndIconShapeTypes,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
    [zT.RemoveCodeAndIconShapeTypes]: {
      up: (t) => Object.fromEntries(
        Object.entries(t).filter(
          ([e, n]) => n.typeName !== "shape" || n.type !== "icon" && n.type !== "code"
        )
      ),
      down: (t) => t
    }
  }
});
function hs(t, e) {
  return Mn({
    id: Ud,
    typeName: da("shape"),
    x: Xn,
    y: Xn,
    rotation: Xn,
    index: Bn,
    parentId: SX,
    type: da(t),
    isLocked: Zr,
    props: e
  });
}
const LO = bI("type", {
  binding: Mn({
    type: da("binding"),
    boundShapeId: Ud,
    normalizedAnchor: i1,
    isExact: Zr
  }),
  point: Mn({
    type: da("point"),
    x: Xn,
    y: Xn
  })
}), lq = hs(
  "arrow",
  Mn({
    labelColor: Ml,
    color: Ml,
    fill: l1,
    dash: am,
    size: sf,
    opacity: Ga,
    arrowheadStart: Tx,
    arrowheadEnd: Tx,
    font: Sb,
    start: LO,
    end: LO,
    bend: Xn,
    text: Bn
  })
), UT = {
  Initial: 0,
  AddLabelColor: 1
}, cq = xr({
  // STEP 2: Update the current version to point to your latest version
  currentVersion: UT.AddLabelColor,
  firstVersion: UT.Initial,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
    [UT.AddLabelColor]: {
      up: (t) => ({
        ...t,
        props: {
          ...t.props,
          labelColor: "black"
        }
      }),
      down: (t) => {
        const { labelColor: e, ...n } = t.props;
        return {
          ...t,
          props: n
        };
      }
    }
  }
}), uq = hs(
  "bookmark",
  Mn({
    opacity: Ga,
    w: Ka,
    h: Ka,
    assetId: a1.nullable(),
    url: Bn
  })
), BT = {
  Initial: 0,
  NullAssetId: 1
}, dq = xr({
  firstVersion: BT.Initial,
  // STEP 2: Update the current version to point to your latest version
  currentVersion: BT.NullAssetId,
  // STEP 3: Add an up+down migration for the new version here
  migrators: {
    [BT.NullAssetId]: {
      up: (t) => t.props.assetId === void 0 ? { ...t, props: { ...t.props, assetId: null } } : t,
      down: (t) => {
        if (t.props.assetId === null) {
          const { assetId: e, ...n } = t.props;
          return { ...t, props: n };
        }
        return t;
      }
    }
  }
}), fq = /* @__PURE__ */ new Set(["free", "straight"]), pq = hs(
  "draw",
  Mn({
    color: Ml,
    fill: l1,
    dash: am,
    size: sf,
    opacity: Ga,
    segments: Kg(
      Mn({
        type: _o(fq),
        points: Kg(i1)
      })
    ),
    isComplete: Zr,
    isClosed: Zr,
    isPen: Zr
  })
), FT = {
  Initial: 0,
  AddInPen: 1
}, hq = xr({
  // STEP 2: Update the current version to point to your latest version
  firstVersion: FT.Initial,
  currentVersion: FT.AddInPen,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
    [FT.AddInPen]: {
      up: (t) => {
        const { points: e } = t.props.segments[0];
        if (e.length === 0)
          return {
            ...t,
            props: {
              ...t.props,
              isPen: !1
            }
          };
        let n = !(e[0].z === 0 || e[0].z === 0.5);
        return e[1] && (n = n && !(e[1].z === 0 || e[1].z === 0.5)), {
          ...t,
          props: {
            ...t.props,
            isPen: n
          }
        };
      },
      down: (t) => {
        const { isPen: e, ...n } = t.props;
        return {
          ...t,
          props: {
            ...n
          }
        };
      }
    }
  }
}), EL = {
  // ========================================================================================
  // Disabled permissions
  // ========================================================================================
  // [MDN] Experimental: Allows for downloads to occur without a gesture from the user.
  // [REASON] Disabled because otherwise the <iframe/> trick the user on behalf of us to performing an action
  "allow-downloads-without-user-activation": !1,
  // [MDN] Allows for downloads to occur with a gesture from the user.
  // [REASON] Disabled because otherwise the <iframe/> trick the user on behalf of us to performing an action
  "allow-downloads": !1,
  // [MDN] Lets the resource open modal windows.
  // [REASON] The <iframe/> could 'window.prompt("Enter your tldraw password")'
  "allow-modals": !1,
  // [MDN] Lets the resource lock the screen orientation.
  // [REASON] Would interfer with tldraw interface
  "allow-orientation-lock": !1,
  // [MDN] Lets the resource use the Pointer Lock API.
  // [REASON] Maybe we should allow this for games embeds (scratch/codepen/codesandbox)
  "allow-pointer-lock": !1,
  // [MDN] Allows popups (such as window.open(), target="_blank", or showModalDialog()). If this keyword is not used, the popup will silently fail to open.
  // [REASON] We shouldn't allow popups as a embed could pretend to be us by opening a mocked version of tldraw. This is very unobvious when it is performed as an action within out app
  "allow-popups": !0,
  // [MDN] Lets the sandboxed document open new windows without those windows inheriting the sandboxing. For example, this can safely sandbox an advertisement without forcing the same restrictions upon the page the ad links to.
  // [REASON] We're alread disabling popups.
  "allow-popups-to-escape-sandbox": !1,
  // [MDN] Lets the resource start a presentation session.
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us
  "allow-presentation": !1,
  // [MDN] Experimental: Lets the resource request access to the parent's storage capabilities with the Storage Access API.
  // [REASON] We don't want anyone else to access our storage
  "allow-storage-access-by-user-activation": !1,
  // [MDN] Lets the resource navigate the top-level browsing context (the one named _top).
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us
  "allow-top-navigation": !1,
  // [MDN] Lets the resource navigate the top-level browsing context, but only if initiated by a user gesture.
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us
  "allow-top-navigation-by-user-activation": !1,
  // ========================================================================================
  // Enabled permissions
  // ========================================================================================
  // [MDN] Lets the resource run scripts (but not create popup windows).
  "allow-scripts": !0,
  // [MDN] If this token is not used, the resource is treated as being from a special origin that always fails the same-origin policy (potentially preventing access to data storage/cookies and some JavaScript APIs).
  "allow-same-origin": !0,
  // [MDN] Allows the resource to submit forms. If this keyword is not used, form submission is blocked.
  "allow-forms": !0
}, gq = hs(
  "embed",
  Mn({
    opacity: Ga,
    w: Ka,
    h: Ka,
    url: Bn,
    tmpOldUrl: Bn.optional(),
    doesResize: Zr,
    overridePermissions: mL(
      _o(
        new Set(Object.keys(EL))
      ),
      Zr.optional()
    ).optional()
  })
), jO = /(^\/r\/[^/]+\/?$)/, Ir = (t) => {
  try {
    return new URL(t);
  } catch {
    return;
  }
}, Qg = [
  {
    type: "tldraw",
    title: "tldraw",
    hostnames: ["beta.tldraw.com", "lite.tldraw.com"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(jO))
        return t;
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(jO))
        return t;
    }
  },
  {
    type: "codesandbox",
    title: "CodeSandbox",
    hostnames: ["codesandbox.io"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t), n = e && e.pathname.match(/\/s\/([^/]+)\/?/);
      if (n)
        return `https://codesandbox.io/embed/${n[1]}`;
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t), n = e && e.pathname.match(/\/embed\/([^/]+)\/?/);
      if (n)
        return `https://codesandbox.io/s/${n[1]}`;
    }
  },
  {
    type: "codepen",
    title: "Codepen",
    hostnames: ["codepen.io"],
    minWidth: 300,
    minHeight: 300,
    width: 520,
    height: 400,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = /https:\/\/codepen.io\/([^/]+)\/pen\/([^/]+)/, n = t.match(e);
      if (n) {
        const [r, a, s] = n;
        return `https://codepen.io/${a}/embed/${s}`;
      }
    },
    fromEmbedUrl: (t) => {
      const e = /https:\/\/codepen.io\/([^/]+)\/embed\/([^/]+)/, n = t.match(e);
      if (n) {
        const [r, a, s] = n;
        return `https://codepen.io/${a}/pen/${s}`;
      }
    }
  },
  {
    type: "scratch",
    title: "Scratch",
    hostnames: ["scratch.mit.edu"],
    width: 520,
    height: 400,
    doesResize: !1,
    toEmbedUrl: (t) => {
      const e = /https?:\/\/scratch.mit.edu\/projects\/([^/]+)/, n = t.match(e);
      if (n) {
        const [r, a] = n;
        return `https://scratch.mit.edu/projects/embed/${a}`;
      }
    },
    fromEmbedUrl: (t) => {
      const e = /https:\/\/scratch.mit.edu\/projects\/embed\/([^/]+)/, n = t.match(e);
      if (n) {
        const [r, a] = n;
        return `https://scratch.mit.edu/projects/${a}`;
      }
    }
  },
  {
    type: "youtube",
    title: "YouTube",
    hostnames: ["*.youtube.com", "youtube.com", "youtu.be"],
    width: 800,
    height: 450,
    doesResize: !0,
    overridePermissions: {
      "allow-presentation": !0
    },
    isAspectRatioLocked: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (!e)
        return;
      const n = e.hostname.replace(/^www./, "");
      if (n === "youtu.be")
        return `https://www.youtube.com/embed/${e.pathname.split("/").filter(Boolean)[0]}`;
      if ((n === "youtube.com" || n === "m.youtube.com") && e.pathname.match(/^\/watch/))
        return `https://www.youtube.com/embed/${e.searchParams.get("v")}`;
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (!e)
        return;
      if (e.hostname.replace(/^www./, "") === "youtube.com") {
        const r = e.pathname.match(/^\/embed\/([^/]+)\/?/);
        if (r)
          return `https://www.youtube.com/watch?v=${r[1]}`;
      }
    }
  },
  {
    type: "figma",
    title: "Figma",
    hostnames: ["figma.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      if (t.match(
        // eslint-disable-next-line no-useless-escape
        /https:\/\/([\w\.-]+\.)?figma.com\/(file|proto)\/([0-9a-zA-Z]{22,128})(?:\/.*)?$/
      ) && !t.includes("figma.com/embed"))
        return `https://www.figma.com/embed?embed_host=share&url=${t}`;
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/^\/embed\/?$/)) {
        const n = e.searchParams.get("url");
        if (n)
          return n;
      }
    }
  },
  {
    type: "google_maps",
    title: "Google Maps",
    hostnames: ["google.*"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      if (t.includes("/maps/")) {
        const e = t.match(/@(.*),(.*),(.*)z/);
        let n;
        if (e) {
          const [, r, a, s] = e;
          n = `https://${new URL(t).host.replace("www.", "")}/maps/embed/v1/view?key=${{}.NEXT_PUBLIC_GC_API_KEY}&center=${r},${a}&zoom=${s}`;
        } else
          n = "";
        return n;
      }
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (!e)
        return;
      if (e.pathname.match(/^\/maps\/embed\/v1\/view\/?$/) && e.searchParams.has("center") && e.searchParams.get("zoom")) {
        const r = e.searchParams.get("zoom"), [a, s] = e.searchParams.get("center").split(",");
        return `https://www.google.com/maps/@${a},${s},${r}z`;
      }
    }
  },
  {
    type: "google_calendar",
    title: "Google Calendar",
    hostnames: ["calendar.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: !0,
    instructionLink: "https://support.google.com/calendar/answer/41207?hl=en",
    toEmbedUrl: (t) => {
      const e = Ir(t), n = e?.searchParams.get("cid");
      if (e?.pathname.match(/\/calendar\/u\/0/) && n) {
        e.pathname = "/calendar/embed";
        const r = Array.from(e.searchParams.keys());
        for (const a of r)
          e.searchParams.delete(a);
        return e.searchParams.set("src", n), e.href;
      }
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t), n = e?.searchParams.get("src");
      if (e?.pathname.match(/\/calendar\/embed/) && n) {
        e.pathname = "/calendar/u/0";
        const r = Array.from(e.searchParams.keys());
        for (const a of r)
          e.searchParams.delete(a);
        return e.searchParams.set("cid", n), e.href;
      }
    }
  },
  {
    type: "google_slides",
    title: "Google Slides",
    hostnames: ["docs.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (e?.pathname.match(/^\/presentation/) && e?.pathname.match(/\/pub\/?$/)) {
        e.pathname = e.pathname.replace(/\/pub$/, "/embed");
        const n = Array.from(e.searchParams.keys());
        for (const r of n)
          e.searchParams.delete(r);
        return e.href;
      }
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e?.pathname.match(/^\/presentation/) && e?.pathname.match(/\/embed\/?$/)) {
        e.pathname = e.pathname.replace(/\/embed$/, "/pub");
        const n = Array.from(e.searchParams.keys());
        for (const r of n)
          e.searchParams.delete(r);
        return e.href;
      }
    }
  },
  {
    type: "github_gist",
    title: "GitHub Gist",
    hostnames: ["gist.github.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/\/([^/]+)\/([^/]+)/))
        return t;
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/\/([^/]+)\/([^/]+)/))
        return t;
    }
  },
  {
    type: "replit",
    title: "Replit",
    hostnames: ["replit.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/\/@([^/]+)\/([^/]+)/))
        return `${t}?embed=true`;
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/\/@([^/]+)\/([^/]+)/) && e.searchParams.has("embed"))
        return e.searchParams.delete("embed"), e.href;
    }
  },
  {
    type: "felt",
    title: "Felt",
    hostnames: ["felt.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/^\/map\//))
        return e.origin + "/embed" + e.pathname;
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/^\/embed\/map\//))
        return e.pathname = e.pathname.replace(/^\/embed/, ""), e.href;
    }
  },
  {
    type: "spotify",
    title: "Spotify",
    hostnames: ["open.spotify.com"],
    width: 720,
    height: 500,
    minHeight: 500,
    overrideOutlineRadius: 12,
    doesResize: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/^\/(artist|album)\//))
        return e.origin + "/embed" + e.pathname;
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/^\/embed\/(artist|album)\//))
        return e.origin + e.pathname.replace(/^\/embed/, "");
    }
  },
  {
    type: "vimeo",
    title: "Vimeo",
    hostnames: ["vimeo.com", "player.vimeo.com"],
    width: 640,
    height: 360,
    doesResize: !0,
    isAspectRatioLocked: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.hostname === "vimeo.com" && e.pathname.match(/^\/[0-9]+/))
        return "https://player.vimeo.com/video/" + e.pathname.split("/")[1] + "?title=0&byline=0";
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.hostname === "player.vimeo.com") {
        const n = e.pathname.match(/^\/video\/([^/]+)\/?$/);
        if (n)
          return "https://vimeo.com/" + n[1];
      }
    }
  },
  {
    type: "excalidraw",
    title: "Excalidraw",
    hostnames: ["excalidraw.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    isAspectRatioLocked: !0,
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.hash.match(/#room=/))
        return t;
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.hash.match(/#room=/))
        return t;
    }
  },
  {
    type: "observable",
    title: "Observable",
    hostnames: ["observablehq.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    isAspectRatioLocked: !1,
    backgroundColor: "#fff",
    toEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/^\/@([^/]+)\/([^/]+)\/?$/))
        return `${e.origin}/embed${e.pathname}?cell=*`;
      if (e && e.pathname.match(/^\/d\/([^/]+)\/?$/)) {
        const n = e.pathname.replace(/^\/d/, "");
        return `${e.origin}/embed${n}?cell=*`;
      }
    },
    fromEmbedUrl: (t) => {
      const e = Ir(t);
      if (e && e.pathname.match(/^\/embed\/@([^/]+)\/([^/]+)\/?$/))
        return `${e.origin}${e.pathname.replace("/embed", "")}#cell-*`;
      if (e && e.pathname.match(/^\/embed\/([^/]+)\/?$/))
        return `${e.origin}${e.pathname.replace("/embed", "/d")}#cell-*`;
    }
  }
], HT = {
  Initial: 0,
  GenOriginalUrlInEmbed: 1
}, mq = xr({
  // STEP 2: Update the current version to point to your latest version
  currentVersion: HT.GenOriginalUrlInEmbed,
  firstVersion: HT.Initial,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
    [HT.GenOriginalUrlInEmbed]: {
      // add tmpOldUrl property
      up: (t) => {
        const e = t.props.url, n = new URL(e).host.replace("www.", "");
        let r;
        for (const a of Qg)
          if (a.hostnames.includes(n))
            try {
              r = a.fromEmbedUrl(e);
            } catch (s) {
              console.warn(s);
            }
        return {
          ...t,
          props: {
            ...t.props,
            tmpOldUrl: t.props.url,
            url: r ?? ""
          }
        };
      },
      // remove tmpOldUrl property
      down: (t) => {
        let e = t.props.tmpOldUrl;
        if (!e || e === "") {
          const a = t.props.url, s = new URL(a).host.replace("www.", "");
          for (const c of Qg)
            if (c.hostnames.includes(s))
              try {
                e = c.toEmbedUrl(a);
              } catch (f) {
                console.warn(f);
              }
        }
        const { tmpOldUrl: n, ...r } = t.props;
        return {
          ...t,
          props: {
            ...r,
            url: e ?? ""
          }
        };
      }
    }
  }
}), vq = hs(
  "frame",
  Mn({
    opacity: Ga,
    w: Ka,
    h: Ka,
    name: Bn
  })
), zO = {
  Initial: 0
}, yq = xr({
  // STEP 2: Update the current version to point to your latest version
  currentVersion: zO.Initial,
  firstVersion: zO.Initial,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
  }
}), bq = hs(
  "geo",
  Mn({
    geo: bL,
    labelColor: Ml,
    color: Ml,
    fill: l1,
    dash: am,
    size: sf,
    opacity: Ga,
    font: Sb,
    align: c1,
    url: Bn,
    w: Ka,
    h: Ka,
    growY: yI,
    text: Bn
  })
), Rw = {
  Initial: 0,
  AddUrlProp: 1,
  AddLabelColor: 2
}, Sq = xr({
  // STEP 2: Update the current version to point to your latest version
  firstVersion: Rw.Initial,
  currentVersion: Rw.AddLabelColor,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
    [Rw.AddUrlProp]: {
      up: (t) => ({ ...t, props: { ...t.props, url: "" } }),
      down: (t) => {
        const { url: e, ...n } = t.props;
        return { ...t, props: n };
      }
    },
    [Rw.AddLabelColor]: {
      up: (t) => ({
        ...t,
        props: {
          ...t.props,
          labelColor: "black"
        }
      }),
      down: (t) => {
        const { labelColor: e, ...n } = t.props;
        return {
          ...t,
          props: n
        };
      }
    }
  }
}), wq = hs(
  "group",
  Mn({
    opacity: Ga
  })
), UO = {
  Initial: 0
}, xq = xr({
  // STEP 2: Update the current version to point to your latest version
  currentVersion: UO.Initial,
  firstVersion: UO.Initial,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
  }
});
hs(
  "icon",
  Mn({
    size: sf,
    icon: SL,
    dash: am,
    color: Ml,
    opacity: Ga,
    scale: Xn
  })
);
const Eq = hs(
  "image",
  Mn({
    opacity: Ga,
    w: Ka,
    h: Ka,
    playing: Zr,
    url: Bn,
    assetId: a1.nullable()
  })
), VT = {
  Initial: 0,
  AddUrlProp: 1
}, Cq = xr({
  // STEP 2: Update the current version to point to your latest version
  firstVersion: VT.Initial,
  currentVersion: VT.AddUrlProp,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
    [VT.AddUrlProp]: {
      up: (t) => ({ ...t, props: { ...t.props, url: "" } }),
      down: (t) => {
        const { url: e, ...n } = t.props;
        return { ...t, props: n };
      }
    }
  }
}), _q = hs(
  "line",
  Mn({
    color: Ml,
    dash: am,
    size: sf,
    opacity: Ga,
    spline: wL,
    handles: mL(Bn, MX)
  })
), BO = {
  Initial: 0
}, Tq = xr({
  // STEP 2: Update the current version to point to your latest version
  currentVersion: BO.Initial,
  firstVersion: BO.Initial,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
  }
}), kq = hs(
  "note",
  Mn({
    color: Ml,
    size: sf,
    font: Sb,
    align: c1,
    opacity: Ga,
    growY: yI,
    url: Bn,
    text: Bn
  })
), YT = {
  Initial: 0,
  AddUrlProp: 1
}, Pq = xr({
  // STEP 2: Update the current version to point to your latest version
  firstVersion: YT.Initial,
  currentVersion: YT.AddUrlProp,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
    [YT.AddUrlProp]: {
      up: (t) => ({ ...t, props: { ...t.props, url: "" } }),
      down: (t) => {
        const { url: e, ...n } = t.props;
        return { ...t, props: n };
      }
    }
  }
}), Iq = hs(
  "text",
  Mn({
    color: Ml,
    size: sf,
    font: Sb,
    align: c1,
    opacity: Ga,
    w: Ka,
    text: Bn,
    scale: Ka,
    autoSize: Zr
  })
), FO = {
  Initial: 0
}, Rq = xr({
  // STEP 2: Update the current version to point to your latest version
  firstVersion: FO.Initial,
  currentVersion: FO.Initial,
  migrators: {}
}), $q = hs(
  "video",
  Mn({
    opacity: Ga,
    w: Ka,
    h: Ka,
    time: Xn,
    playing: Zr,
    url: Bn,
    assetId: a1.nullable()
  })
), KT = {
  Initial: 0,
  AddUrlProp: 1
}, Mq = xr({
  // STEP 2: Update the current version to point to your latest version
  firstVersion: KT.Initial,
  currentVersion: KT.AddUrlProp,
  migrators: {
    // STEP 3: Add an up+down migration for the new version here
    [KT.AddUrlProp]: {
      up: (t) => ({ ...t, props: { ...t.props, url: "" } }),
      down: (t) => {
        const { url: e, ...n } = t.props;
        return { ...t, props: n };
      }
    }
  }
}), ua = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => t * (2 - t),
  easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => --t * t * t + 1,
  easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => 1 - --t * t * t * t,
  easeInOutQuart: (t) => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t,
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => 1 + --t * t * t * t * t,
  easeInOutQuint: (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t,
  easeInSine: (t) => 1 - Math.cos(t * Math.PI / 2),
  easeOutSine: (t) => Math.sin(t * Math.PI / 2),
  easeInOutSine: (t) => -(Math.cos(Math.PI * t) - 1) / 2,
  easeInExpo: (t) => t <= 0 ? 0 : Math.pow(2, 10 * t - 10),
  easeOutExpo: (t) => t >= 1 ? 1 : 1 - Math.pow(2, -10 * t),
  easeInOutExpo: (t) => t <= 0 ? 0 : t >= 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2
};
class O {
  constructor(e = 0, n = 0, r = 1) {
    this.x = e, this.y = n, this.z = r;
  }
  get pressure() {
    return this.z;
  }
  set(e = this.x, n = this.y, r = this.z) {
    return this.x = e, this.y = n, this.z = r, this;
  }
  setTo({ x: e = 0, y: n = 0, z: r = 1 }) {
    return this.x = e, this.y = n, this.z = r, this;
  }
  rot(e) {
    if (e === 0)
      return this;
    const { x: n, y: r } = this, a = Math.sin(e), s = Math.cos(e);
    return this.x = n * s - r * a, this.y = n * a + r * s, this;
  }
  rotWith(e, n) {
    if (n === 0)
      return this;
    const r = this.x - e.x, a = this.y - e.y, s = Math.sin(n), c = Math.cos(n);
    return this.x = e.x + (r * c - a * s), this.y = e.y + (r * s + a * c), this;
  }
  clone() {
    const { x: e, y: n, z: r } = this;
    return new O(e, n, r);
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subXY(e, n) {
    return this.x -= e, this.y -= n, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addXY(e, n) {
    return this.x += e, this.y += n, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  clamp(e, n) {
    return this.x = Math.min(Math.max(this.x, e), n ?? this.x), this.y = Math.min(Math.max(this.y, e), n ?? this.y), this;
  }
  div(e) {
    return this.x /= e, this.y /= e, this;
  }
  divV(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  mul(e) {
    return this.x *= e, this.y *= e, this;
  }
  mulV(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  abs() {
    return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this;
  }
  nudge(e, n) {
    const r = O.Tan(e, this);
    return this.add(r.mul(n));
  }
  neg() {
    return this.x *= -1, this.y *= -1, this;
  }
  cross(e) {
    return this.x = this.y * e.z - this.z * e.y, this.y = this.z * e.x - this.x * e.z, this;
  }
  dpr(e) {
    return O.Dpr(this, e);
  }
  cpr(e) {
    return O.Cpr(this, e);
  }
  len2() {
    return O.Len2(this);
  }
  len() {
    return O.Len(this);
  }
  pry(e) {
    return O.Pry(this, e);
  }
  per() {
    const { x: e, y: n } = this;
    return this.x = n, this.y = -e, this;
  }
  uni() {
    return O.Uni(this);
  }
  tan(e) {
    return O.Tan(this, e);
  }
  dist(e) {
    return O.Dist(this, e);
  }
  distanceToLineSegment(e, n) {
    return O.DistanceToLineSegment(e, n, this);
  }
  slope(e) {
    return O.Slope(this, e);
  }
  snapToGrid(e) {
    return this.x = Math.round(this.x / e) * e, this.y = Math.round(this.y / e) * e, this;
  }
  angle(e) {
    return O.Angle(this, e);
  }
  toAngle() {
    return O.ToAngle(this);
  }
  lrp(e, n) {
    return this.x = this.x + (e.x - this.x) * n, this.y = this.y + (e.y - this.y) * n, this;
  }
  equals(e) {
    return O.Equals(this, e);
  }
  equalsXY(e, n) {
    return O.EqualsXY(this, e, n);
  }
  norm() {
    const e = this.len();
    return this.x = e === 0 ? 0 : this.x / e, this.y = e === 0 ? 0 : this.y / e, this;
  }
  toFixed() {
    return O.ToFixed(this);
  }
  toString() {
    return O.ToString(O.ToFixed(this));
  }
  toJson() {
    return O.ToJson(this);
  }
  toArray() {
    return O.ToArray(this);
  }
  static Add(e, n) {
    return new O(e.x + n.x, e.y + n.y);
  }
  static AddXY(e, n, r) {
    return new O(e.x + n, e.y + r);
  }
  static Sub(e, n) {
    return new O(e.x - n.x, e.y - n.y);
  }
  static SubXY(e, n, r) {
    return new O(e.x - n, e.y - r);
  }
  static AddScalar(e, n) {
    return new O(e.x + n, e.y + n);
  }
  static SubScalar(e, n) {
    return new O(e.x - n, e.y - n);
  }
  static Div(e, n) {
    return new O(e.x / n, e.y / n);
  }
  static Mul(e, n) {
    return new O(e.x * n, e.y * n);
  }
  static DivV(e, n) {
    return new O(e.x / n.x, e.y / n.y);
  }
  static MulV(e, n) {
    return new O(e.x * n.x, e.y * n.y);
  }
  static Neg(e) {
    return new O(-e.x, -e.y);
  }
  static Per(e) {
    return new O(e.y, -e.x);
  }
  static Dist2(e, n) {
    return O.Sub(e, n).len2();
  }
  static Abs(e) {
    return new O(Math.abs(e.x), Math.abs(e.y));
  }
  static Dist(e, n) {
    return Math.hypot(e.y - n.y, e.x - n.x);
  }
  static Dpr(e, n) {
    return e.x * n.x + e.y * n.y;
  }
  static Cross(e, n) {
    return new O(
      e.y * n.z - e.z * n.y,
      e.z * n.x - e.x * n.z
      // A.z = A.x * V.y - A.y * V.x
    );
  }
  static Cpr(e, n) {
    return e.x * n.y - n.x * e.y;
  }
  static Len2(e) {
    return e.x * e.x + e.y * e.y;
  }
  static Len(e) {
    return Math.sqrt(O.Len2(e));
  }
  static Pry(e, n) {
    return O.Dpr(e, n) / O.Len(n);
  }
  static Uni(e) {
    return O.Div(e, O.Len(e));
  }
  static Tan(e, n) {
    return O.Uni(O.Sub(e, n));
  }
  static Min(e, n) {
    return new O(Math.min(e.x, n.x), Math.min(e.y, n.y));
  }
  static Max(e, n) {
    return new O(Math.max(e.x, n.x), Math.max(e.y, n.y));
  }
  static From({ x: e, y: n, z: r = 1 }) {
    return new O(e, n, r);
  }
  static FromArray(e) {
    return new O(e[0], e[1]);
  }
  static Rot(e, n = 0) {
    const r = Math.sin(n), a = Math.cos(n);
    return new O(e.x * a - e.y * r, e.x * r + e.y * a);
  }
  static RotWith(e, n, r) {
    const a = e.x - n.x, s = e.y - n.y, c = Math.sin(r), f = Math.cos(r);
    return new O(n.x + (a * f - s * c), n.y + (a * c + s * f));
  }
  /**
   * Get the nearest point on a line with a known unit vector that passes through point A
   *
   * ```ts
   * Vec.nearestPointOnLineThroughPoint(A, u, Point)
   * ```
   *
   * @param A - Any point on the line
   * @param u - The unit vector for the line.
   * @param P - A point not on the line to test.
   */
  static NearestPointOnLineThroughPoint(e, n, r) {
    return O.Mul(n, O.Sub(r, e).pry(n)).add(e);
  }
  static NearestPointOnLineSegment(e, n, r, a = !0) {
    const s = O.Tan(n, e), c = O.Add(e, O.Mul(s, O.Sub(r, e).pry(s)));
    if (a) {
      if (c.x < Math.min(e.x, n.x))
        return O.Cast(e.x < n.x ? e : n);
      if (c.x > Math.max(e.x, n.x))
        return O.Cast(e.x > n.x ? e : n);
      if (c.y < Math.min(e.y, n.y))
        return O.Cast(e.y < n.y ? e : n);
      if (c.y > Math.max(e.y, n.y))
        return O.Cast(e.y > n.y ? e : n);
    }
    return c;
  }
  static DistanceToLineThroughPoint(e, n, r) {
    return O.Dist(r, O.NearestPointOnLineThroughPoint(e, n, r));
  }
  static DistanceToLineSegment(e, n, r, a = !0) {
    return O.Dist(r, O.NearestPointOnLineSegment(e, n, r, a));
  }
  static Snap(e, n = 1) {
    return new O(Math.round(e.x / n) * n, Math.round(e.y / n) * n);
  }
  static Cast(e) {
    return e instanceof O ? e : O.From(e);
  }
  static Slope(e, n) {
    return e.x === n.y ? NaN : (e.y - n.y) / (e.x - n.x);
  }
  static Angle(e, n) {
    return Math.atan2(n.y - e.y, n.x - e.x);
  }
  static Lrp(e, n, r) {
    return O.Sub(n, e).mul(r).add(e);
  }
  static Med(e, n) {
    return new O((e.x + n.x) / 2, (e.y + n.y) / 2);
  }
  static Equals(e, n) {
    return Math.abs(e.x - n.x) < 1e-4 && Math.abs(e.y - n.y) < 1e-4;
  }
  static EqualsXY(e, n, r) {
    return e.x === n && e.y === r;
  }
  static Clockwise(e, n, r) {
    return (r.x - e.x) * (n.y - e.y) - (n.x - e.x) * (r.y - e.y) < 0;
  }
  static Rescale(e, n) {
    const r = O.Len(e);
    return new O(n * e.x / r, n * e.y / r);
  }
  static ScaleWithOrigin(e, n, r) {
    return O.Sub(e, r).mul(n).add(r);
  }
  static ToFixed(e, n = 2) {
    return new O(+e.x.toFixed(n), +e.y.toFixed(n), +e.z.toFixed(n));
  }
  static Nudge(e, n, r) {
    return O.Add(e, O.Tan(n, e).mul(r));
  }
  static ToString(e) {
    return `${e.x}, ${e.y}`;
  }
  static ToAngle(e) {
    let n = Math.atan2(e.y, e.x);
    return n < 0 && (n += Math.PI * 2), n;
  }
  static ToArray(e) {
    return [e.x, e.y, e.z];
  }
  static ToJson(e) {
    const { x: n, y: r, z: a } = e;
    return { x: n, y: r, z: a };
  }
  static Average(e) {
    const n = e.length, r = new O(0, 0);
    for (let a = 0; a < n; a++)
      r.add(e[a]);
    return r.div(n);
  }
  static Clamp(e, n, r) {
    return new O(
      Math.min(Math.max(e.x, n), r ?? e.x),
      Math.min(Math.max(e.y, n), r ?? e.y)
    );
  }
  /**
   * Get an array of points (with simulated pressure) between two points.
   *
   * @param A - The first point.
   * @param B - The second point.
   * @param steps - The number of points to return.
   */
  static PointsBetween(e, n, r = 6) {
    const a = [];
    for (let s = 0; s < r; s++) {
      const c = ua.easeInQuad(s / (r - 1)), f = O.Lrp(e, n, c);
      f.z = Math.min(1, 0.5 + Math.abs(0.5 - Aq(c)) * 0.65), a.push(f);
    }
    return a;
  }
  static SnapToGrid(e, n = 8) {
    return new O(Math.round(e.x / n) * n, Math.round(e.y / n) * n);
  }
}
const Aq = (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t, Yr = Math.PI, cr = Yr / 2, Kr = Yr * 2, HO = Math.PI / 180, Oq = Math.sin;
function Iu(t, e, n) {
  return Math.max(e, typeof n < "u" ? Math.min(t, n) : t);
}
function $w(t, e = 1e10) {
  return t ? Math.round(t * e) / e : 0;
}
function By(t, e, n = 1e-6) {
  return Math.abs(t - e) <= n;
}
function qy(t, e) {
  const n = Math.pow(t - e, 2) / Math.pow(t + e, 2);
  return Yr * (t + e) * (1 + 3 * n / (10 + Math.sqrt(4 - 3 * n)));
}
function EI(t) {
  return t = t % Kr, t < 0 ? t = t + Kr : t === 0 && (t = 0), t;
}
function Vd(t, e) {
  const n = (e - t) % Kr;
  return 2 * n % Kr - n;
}
function Dq(t, e) {
  return Kr - Vd(t, e);
}
function hp(t, e, n) {
  return t + Vd(t, e) * n;
}
function CL(t, e) {
  return Vd(t, e);
}
function Nq(t, e, n) {
  return CL(O.Angle(t, e), O.Angle(t, n));
}
function _L(t) {
  return (Kr + t) % Kr;
}
function Px(t, e) {
  const n = Kr / e;
  let r = Math.floor((_L(t) + n / 2) / n) * n % Kr;
  return r < Yr && (r += Kr), r > Yr && (r -= Kr), r;
}
function TL(t, e) {
  return t === e || By(t % (Math.PI / 2) - e % (Math.PI / 2), 0);
}
function Lq(t) {
  return t * Yr / 180;
}
function kL(t) {
  return t * 180 / Yr;
}
function Mw(t, e, n, r) {
  const a = Nq(t, n, r);
  return e * Kr * (a / Kr);
}
function vp(t, e, n, r) {
  return new O(t + n * Math.cos(r), e + n * Math.sin(r));
}
function WT(t, e, n) {
  const r = t / 2, a = e / 2, s = [];
  for (let c = 0; c < n; c++) {
    const f = Kr / n, p = -cr + c * f;
    s.push(new O(r + r * Math.cos(p), a + a * Math.sin(p)));
  }
  return s;
}
function ky(t, e, n, r) {
  return t < r && n < e;
}
function kl(t, e, n, r) {
  const a = Math.max(t, n), s = Math.min(e, r);
  return a <= s ? [a, s] : null;
}
const jq = (t, e, n) => {
  const r = Kr / t / 2, a = Math.floor(t / 4) * 2, s = t * 2 - a, c = 0, f = Math.floor(t / 2) * 2, p = Math.cos(-cr + a * r) * e / 2, g = Math.cos(-cr + s * r) * e / 2, y = Math.sin(-cr + c * r) * n / 2, v = Math.sin(-cr + f * r) * n / 2;
  return new ot(0, 0, p - g, v - y);
};
function VO(t, e, n) {
  return (e.x - t.x) * (n.y - t.y) - (n.x - t.x) * (e.y - t.y);
}
function Lu(t, e) {
  let n = 0, r, a;
  for (let s = 0; s < e.length; s++)
    r = e[s], a = e[(s + 1) % e.length], r.y <= t.y ? a.y > t.y && VO(r, a, t) > 0 && (n += 1) : a.y <= t.y && VO(r, a, t) < 0 && (n -= 1);
  return n !== 0;
}
function zq(t, e, n = 8) {
  const r = e.length;
  for (let a = 1; a < r; a++) {
    const s = e[a - 1], c = e[a];
    if (O.DistanceToLineSegment(s, c, t) < n)
      return !0;
  }
  return !1;
}
function ze(t) {
  return +t.toFixed(4);
}
class ot {
  constructor(e = 0, n = 0, r = 0, a = 0) {
    this.x = e, this.y = n, this.w = r, this.h = a;
  }
  x = 0;
  y = 0;
  w = 0;
  h = 0;
  get point() {
    return new O(this.x, this.y);
  }
  set point(e) {
    this.x = e.x, this.y = e.y;
  }
  get minX() {
    return this.x;
  }
  set minX(e) {
    this.x = e;
  }
  get midX() {
    return this.x + this.w / 2;
  }
  get maxX() {
    return this.x + this.w;
  }
  get minY() {
    return this.y;
  }
  set minY(e) {
    this.y = e;
  }
  get midY() {
    return this.y + this.h / 2;
  }
  get maxY() {
    return this.y + this.h;
  }
  get width() {
    return this.w;
  }
  set width(e) {
    this.w = e;
  }
  get height() {
    return this.h;
  }
  set height(e) {
    this.h = e;
  }
  get aspectRatio() {
    return this.width / this.height;
  }
  get center() {
    return new O(this.midX, this.midY);
  }
  set center(e) {
    this.minX = e.x - this.width / 2, this.minY = e.y - this.height / 2;
  }
  get corners() {
    return [
      new O(this.minX, this.minY),
      new O(this.maxX, this.minY),
      new O(this.maxX, this.maxY),
      new O(this.minX, this.maxY)
    ];
  }
  get snapPoints() {
    return [
      new O(this.minX, this.minY),
      new O(this.maxX, this.minY),
      new O(this.maxX, this.maxY),
      new O(this.minX, this.maxY),
      this.center
    ];
  }
  get sides() {
    const { corners: e } = this;
    return [
      [e[0], e[1]],
      [e[1], e[2]],
      [e[2], e[3]],
      [e[3], e[0]]
    ];
  }
  get size() {
    return new O(this.w, this.h);
  }
  toFixed() {
    return this.x = $w(this.x), this.y = $w(this.y), this.w = $w(this.w), this.h = $w(this.h), this;
  }
  setTo(e) {
    return this.x = e.x, this.y = e.y, this.w = e.w, this.h = e.h, this;
  }
  set(e = 0, n = 0, r = 0, a = 0) {
    return this.x = e, this.y = n, this.w = r, this.h = a, this;
  }
  expand(e) {
    const n = Math.min(this.minX, e.minX), r = Math.min(this.minY, e.minY), a = Math.max(this.maxX, e.maxX), s = Math.max(this.maxY, e.maxY);
    return this.x = n, this.y = r, this.w = a - n, this.h = s - r, this;
  }
  expandBy(e) {
    return this.x -= e, this.y -= e, this.w += e * 2, this.h += e * 2, this;
  }
  scale(e) {
    return this.x /= e, this.y /= e, this.w /= e, this.h /= e, this;
  }
  clone() {
    const { x: e, y: n, w: r, h: a } = this;
    return new ot(e, n, r, a);
  }
  translate(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  snapToGrid(e) {
    const n = Math.round(this.minX / e) * e, r = Math.round(this.minY / e) * e, a = Math.round(this.maxX / e) * e, s = Math.round(this.maxY / e) * e;
    this.minX = n, this.minY = r, this.width = Math.max(1, a - n), this.height = Math.max(1, s - r);
  }
  collides(e) {
    return ot.Collides(this, e);
  }
  contains(e) {
    return ot.Contains(this, e);
  }
  includes(e) {
    return ot.Includes(this, e);
  }
  containsPoint(e, n) {
    return ot.ContainsPoint(this, e, n);
  }
  getHandlePoint(e) {
    switch (e) {
      case "top_left":
        return new O(this.minX, this.minY);
      case "top_right":
        return new O(this.maxX, this.minY);
      case "bottom_left":
        return new O(this.minX, this.maxY);
      case "bottom_right":
        return new O(this.maxX, this.maxY);
      case "top":
        return new O(this.midX, this.minY);
      case "right":
        return new O(this.maxX, this.midY);
      case "bottom":
        return new O(this.midX, this.maxY);
      case "left":
        return new O(this.minX, this.midY);
    }
  }
  toJson() {
    return { x: this.minX, y: this.minY, w: this.w, h: this.h };
  }
  resize(e, n, r) {
    const { minX: a, minY: s, maxX: c, maxY: f } = this;
    let { minX: p, minY: g, maxX: y, maxY: v } = this;
    switch (e) {
      case "left":
      case "top_left":
      case "bottom_left": {
        p += n;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        y += n;
        break;
      }
    }
    switch (e) {
      case "top":
      case "top_left":
      case "top_right": {
        g += r;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        v += r;
        break;
      }
    }
    const S = (y - p) / (c - a), x = (v - g) / (f - s), _ = S < 0, T = x < 0;
    if (_) {
      const I = y;
      y = p, p = I;
    }
    if (T) {
      const I = v;
      v = g, g = I;
    }
    this.minX = p, this.minY = g, this.width = Math.abs(y - p), this.height = Math.abs(v - g);
  }
  static From(e) {
    return new ot(e.x, e.y, e.w, e.h);
  }
  static FromPoints(e) {
    if (e.length === 0)
      return new ot();
    let n = 1 / 0, r = 1 / 0, a = -1 / 0, s = -1 / 0, c;
    for (let f = 0, p = e.length; f < p; f++)
      c = e[f], n = Math.min(c.x, n), r = Math.min(c.y, r), a = Math.max(c.x, a), s = Math.max(c.y, s);
    return new ot(n, r, a - n, s - r);
  }
  static Expand(e, n) {
    const r = Math.min(n.minX, e.minX), a = Math.min(n.minY, e.minY), s = Math.max(n.maxX, e.maxX), c = Math.max(n.maxY, e.maxY);
    return new ot(r, a, s - r, c - a);
  }
  static ExpandBy(e, n) {
    return new ot(e.minX - n, e.minY - n, e.width + n * 2, e.height + n * 2);
  }
  static Collides = (e, n) => !(e.maxX < n.minX || e.minX > n.maxX || e.maxY < n.minY || e.minY > n.maxY);
  static Contains = (e, n) => e.minX < n.minX && e.minY < n.minY && e.maxY > n.maxY && e.maxX > n.maxX;
  static Includes = (e, n) => ot.Collides(e, n) || ot.Contains(e, n);
  static ContainsPoint = (e, n, r) => typeof n == "number" ? !(n < e.minX || r < e.minY || n > e.maxX || r > e.maxY) : !(n.x < e.minX || n.y < e.minY || n.x > e.maxX || n.y > e.maxY);
  static Common = (e) => {
    let n = 1 / 0, r = 1 / 0, a = -1 / 0, s = -1 / 0;
    for (let c = 0; c < e.length; c++) {
      const f = e[c];
      n = Math.min(n, f.minX), r = Math.min(r, f.minY), a = Math.max(a, f.maxX), s = Math.max(s, f.maxY);
    }
    return new ot(n, r, a - n, s - r);
  };
  static Sides = (e, n = 0) => {
    const { corners: r } = e;
    return [
      [r[0], r[1]],
      [r[1], r[2]],
      [r[2], r[3]],
      [r[3], r[0]]
    ];
  };
  static Resize(e, n, r, a, s = !1) {
    const { minX: c, minY: f, maxX: p, maxY: g } = e;
    let { minX: y, minY: v, maxX: S, maxY: x } = e;
    switch (n) {
      case "left":
      case "top_left":
      case "bottom_left": {
        y += r;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        S += r;
        break;
      }
    }
    switch (n) {
      case "top":
      case "top_left":
      case "top_right": {
        v += a;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        x += a;
        break;
      }
    }
    const _ = (S - y) / (p - c), T = (x - v) / (g - f), I = _ < 0, D = T < 0;
    if (s) {
      const j = (p - c) / (g - f), L = Math.abs(S - y), z = Math.abs(x - v), F = L * (T < 0 ? 1 : -1) * (1 / j), K = z * (_ < 0 ? 1 : -1) * j, X = j < L / z;
      switch (n) {
        case "top_left": {
          X ? v = x + F : y = S + K;
          break;
        }
        case "top_right": {
          X ? v = x + F : S = y - K;
          break;
        }
        case "bottom_right": {
          X ? x = v - F : S = y - K;
          break;
        }
        case "bottom_left": {
          X ? x = v - F : y = S + K;
          break;
        }
        case "bottom":
        case "top": {
          const se = (y + S) / 2, ue = z * j;
          y = se - ue / 2, S = se + ue / 2;
          break;
        }
        case "left":
        case "right": {
          const se = (v + x) / 2, ue = L / j;
          v = se - ue / 2, x = se + ue / 2;
          break;
        }
      }
    }
    if (I) {
      const j = S;
      S = y, y = j;
    }
    if (D) {
      const j = x;
      x = v, v = j;
    }
    const N = new ot(y, v, Math.abs(S - y), Math.abs(x - v));
    return {
      box: N,
      scaleX: +(N.width / e.width * (_ > 0 ? 1 : -1)).toFixed(5),
      scaleY: +(N.height / e.height * (T > 0 ? 1 : -1)).toFixed(5)
    };
  }
  equals(e) {
    return ot.Equals(this, e);
  }
  static Equals(e, n) {
    return n.x === e.x && n.y === e.y && n.w === e.w && n.h === e.h;
  }
}
function Uq(t) {
  switch (t) {
    case "top":
      return "bottom";
    case "bottom":
      return "top";
    case "top_left":
      return "bottom_left";
    case "top_right":
      return "bottom_right";
    case "bottom_left":
      return "top_left";
    case "bottom_right":
      return "top_right";
    default:
      return t;
  }
}
function Bq(t) {
  switch (t) {
    case "left":
      return "right";
    case "right":
      return "left";
    case "top_left":
      return "top_right";
    case "top_right":
      return "top_left";
    case "bottom_left":
      return "bottom_right";
    case "bottom_right":
      return "bottom_left";
    default:
      return t;
  }
}
function Fq(t) {
  return t === "top_left" || t === "top_right" || t === "bottom_right" || t === "bottom_left";
}
class PL {
  constructor(e) {
    this._values = e;
  }
  /**
   * The segment's values. Do not modify these directly. Instead, use the `values` setter or `update` method.
   *
   * @internal
   */
  _values;
  /**
   * A private set of cached values, used for lookups and computations. Changing any of the
   * segment's values will clear this object.
   *
   * @internal
   */
  _computed = {};
  /**
   * The values for the curve segment.
   *
   * @public
   */
  get values() {
    return this._values;
  }
  set values(e) {
    this._values = e, this._computed = {};
  }
  /**
   * The length of the curve segment.
   *
   * @public
   */
  get length() {
    if (this._computed.length !== void 0)
      return this._computed.length;
    const { lut: e } = this;
    let n = e[0], r = 0;
    for (let a = 1; a < e.length; a++) {
      const s = e[a];
      r += n.dist(s), n = s;
    }
    return this._computed.length = r, r;
  }
  /**
   * The bounding box containing the curve segment.
   *
   * @public
   */
  get bounds() {
    if (this._computed.bounds !== void 0)
      return this._computed.bounds;
    let e = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0;
    const { lut: s } = this;
    for (const f of s)
      e = Math.min(f.x, e), n = Math.min(f.y, n), r = Math.max(f.x, r), a = Math.max(f.y, a);
    const c = new ot(e, n, r - e, a - n);
    return this._computed.bounds = c, c;
  }
  /**
   * A lookup table consisting of values.p points along the segment. Used to compute lengths,
   * closest points, etc. This should only be _computed once (when first requested) per set of values.
   *
   * @public
   */
  get lut() {
    if (this._computed.lut)
      return this._computed.lut;
    const { p: e } = this.values, n = [];
    for (let r = 0; r < e + 1; r++)
      n.push(this.getPoint(r / e));
    return this._computed.lut = n, n;
  }
  /**
   * A point half-way along the length of the segment.
   *
   * @public
   */
  get midPoint() {
    if (this._computed.midPoint)
      return this._computed.midPoint;
    const e = this.getPoint(0.5);
    return this._computed.midPoint = e, e;
  }
  /**
   * An SVG path for the segment.
   *
   * @public
   */
  get path() {
    if (this._computed.path)
      return this._computed.path;
    const e = this.getPath();
    return this._computed.path = e, e;
  }
  /**
   * Evaluate a point at a length along the curve segment.
   *
   * @param length - The length to find the point value.
   * @public
   */
  getPointAtLength(e) {
    const n = Math.max(0, Math.min(1, e / this.length));
    return this.getPoint(n);
  }
  /**
   * Get the normal at distance t along the curve segment.
   *
   * @param t - The distance (0-1) to find the normal.
   * @public
   */
  getNormal(e) {
    return this.getPoint(e - 25e-4).tan(this.getPoint(e + 25e-4)).per().uni().toFixed();
  }
  /**
   * Get the normal at a length along the curve segment.
   *
   * @param length - The length to find the normal.
   * @public
   */
  getNormalAtLength(e) {
    return this.getNormal(e / this.length);
  }
  /**
   * Get the closest point on the segment to an arbitrary point.
   *
   * @param point - The arbitrary point.
   * @public
   */
  getClosestPointTo(e) {
    const { lut: n } = this;
    let r = 0, a = n[0], s = n[0].dist(e);
    for (let f = 1; f < n.length; f++) {
      const p = O.Dist(n[f], e);
      p < s && (s = p, a = n[f], r = f / n.length);
    }
    const c = 1 / this.values.p;
    for (let f = Math.max(0, r - c / 2); f < Math.min(1, r + c / 2); f += c / 10) {
      const p = this.getPoint(f), g = O.Dist(p, e);
      g < s && (s = g, a = p);
    }
    return { point: a, distance: s };
  }
  /**
   * Set one or more values. Updating the segment will clear cached values.
   *
   * @param values - A partial of the segment's values object.
   * @public
   */
  update(e) {
    this._computed = {}, this.values = { ...this.values, ...e };
  }
}
class Hq extends PL {
  constructor(e, n, r, a, s = 25) {
    super({ a: e, b: n, c: r, d: a, p: s });
  }
  [Symbol.iterator] = function* () {
    const { a: e, b: n, c: r, d: a } = this.values;
    yield* [e, n, r, a];
  };
  getPath(e = !0) {
    const { a: n, b: r, c: a, d: s } = this.values;
    return O.Equals(n, s) ? "" : `${e ? `M${n.x.toFixed(2)},${n.y.toFixed(2)}C` : ""}${r.x.toFixed(2)},${r.y.toFixed(
      2
    )} ${a.x.toFixed(2)},${a.y.toFixed(2)} ${s.x.toFixed(2)},${s.y.toFixed(2)}`;
  }
  getPoint(e) {
    const { a: n, b: r, c: a, d: s } = this.values;
    return new O(
      (1 - e) * (1 - e) * (1 - e) * n.x + 3 * ((1 - e) * (1 - e)) * e * r.x + 3 * (1 - e) * (e * e) * a.x + e * e * e * s.x,
      (1 - e) * (1 - e) * (1 - e) * n.y + 3 * ((1 - e) * (1 - e)) * e * r.y + 3 * (1 - e) * (e * e) * a.y + e * e * e * s.y
    );
  }
  getX(e) {
    const { a: n, b: r, c: a, d: s } = this.values;
    return (1 - e) * (1 - e) * (1 - e) * n.x + 3 * ((1 - e) * (1 - e)) * e * r.x + 3 * (1 - e) * (e * e) * a.x + e * e * e * s.x;
  }
  getY(e) {
    const { a: n, b: r, c: a, d: s } = this.values;
    return (1 - e) * (1 - e) * (1 - e) * n.y + 3 * ((1 - e) * (1 - e)) * e * r.y + 3 * (1 - e) * (e * e) * a.y + e * e * e * s.y;
  }
}
class IL {
  constructor(e, n = 50, r = 1) {
    this.points = e, this.p = n, this.k = r;
  }
  computed = {};
  get length() {
    if (this.computed.length !== void 0)
      return this.computed.length;
    const { segments: e } = this, n = e.reduce((r, a) => r + a.length, 0);
    return this.computed.length = n, n;
  }
  get bounds() {
    if (this.computed.bounds !== void 0)
      return this.computed.bounds;
    const { segments: e } = this, n = ot.Common(e.map((r) => r.bounds));
    return this.computed.bounds = n, n;
  }
  get head() {
    const { points: e } = this;
    return e[0];
  }
  get tail() {
    const { points: e } = this;
    return e[e.length - 1];
  }
  get path() {
    if (this.computed.path !== void 0)
      return this.computed.path;
    const e = this.segments.map((n) => n.path).filter((n) => n != null && n !== "").join(" ");
    return this.computed.path = e, e;
  }
  addPoint(e) {
    const { points: n, k: r, p: a } = this;
    return n.push(e), this.computed = {}, this.getSegmentsFromPoints(this.points, a, r), this;
  }
  removePoint(e) {
    const { points: n, k: r, p: a } = this, s = typeof e == "number" ? Math.floor(e) : n.indexOf(e);
    return s === -1 ? this : (n.splice(s, 1), this.computed = {}, this.getSegmentsFromPoints(this.points, a, r), this);
  }
  getPointAtLength(e) {
    const { segments: n } = this;
    let r = e;
    if (e <= 0)
      return n[0].getPoint(0);
    if (e >= this.length)
      return n[n.length - 1].getPoint(1);
    for (let a = 0; a < n.length; a++) {
      const s = n[a], { length: c } = s;
      if (r < c)
        return s.getPoint(r / c);
      r -= s.length;
    }
    return n[n.length - 1].getPoint(1);
  }
  getPoint(e) {
    return e <= 0 ? this.segments[0].getPoint(0) : e >= 1 ? this.segments[this.segments.length - 1].getPoint(1) : this.getPointAtLength(e * this.length);
  }
  getNormal(e) {
    const { length: n } = this;
    return this.getNormalAtLength(e * n);
  }
  getNormalAtLength(e) {
    const { segments: n } = this;
    if (e < 0)
      return new O(0, 0);
    let r = e;
    for (const a of n) {
      const s = a.length;
      if (r <= s)
        return a.getNormal(r / s);
      r -= s;
    }
    return new O(0, 0);
  }
  getClosestPointTo(e) {
    const { head: n, segments: r } = this;
    let a = n, s = O.Dist(e, n);
    for (const c of r) {
      const f = c.getClosestPointTo(e);
      f.distance < s && (s = f.distance, a = f.point);
    }
    return { point: a, distance: s };
  }
}
class CI extends IL {
  constructor(e, n = 1.2, r = 20) {
    super(e, n, r), this.segments = this.getSegmentsFromPoints(e, n, r);
  }
  segments;
  getSegmentsFromPoints(e, n = 1.25, r = 20) {
    const a = e.length, s = a - 2, c = [];
    for (let f = 0; f < a - 1; f++) {
      const p = f === 0 ? e[0] : e[f - 1], g = e[f], y = e[f + 1], v = f === s ? y : e[f + 2];
      c.push(
        new Hq(
          g,
          f === 0 ? p : new O(g.x + (y.x - p.x) / 6 * n, g.y + (y.y - p.y) / 6 * n),
          f === s ? y : new O(y.x - (v.x - g.x) / 6 * n, y.y - (v.y - g.y) / 6 * n),
          y,
          r
        )
      );
    }
    return c;
  }
  static FromPoints(e) {
    return new CI(e);
  }
}
class Vq extends PL {
  constructor(e, n, r = 2) {
    super({ a: e, b: n, p: r }), this.a = e, this.b = n, this.values.p = Math.max(10, Math.ceil(this.length / 20));
  }
  get length() {
    return O.Dist(this.a, this.b);
  }
  get tangent() {
    return O.Tan(this.a, this.b);
  }
  get angle() {
    return O.Angle(this.a, this.b);
  }
  get bounds() {
    return ot.FromPoints([this.a, this.b]);
  }
  getX(e) {
    const { a: n, b: r } = this.values;
    return n.x + (r.x - n.x) * e;
  }
  getY(e) {
    const { a: n, b: r } = this.values;
    return n.y + (r.y - n.y) * e;
  }
  getPoint(e) {
    const { a: n, b: r } = this.values;
    return O.Lrp(n, r, e);
  }
  getPath(e = !0) {
    const { a: n, b: r } = this.values;
    return O.Equals(n, r) ? "" : e ? `M${n.x},${n.y}L${r.x},${r.y}` : `${r.x},${r.y}`;
  }
  getNormal() {
    const { a: e, b: n } = this.values;
    return O.Sub(e, n).per().uni().toFixed();
  }
  /**
   * Get the closest point on the segment to an arbitrary point.
   *
   * @param point - The arbitrary point.
   * @public
   */
  getClosestPointTo(e) {
    const { a: n, b: r } = this.values, a = O.NearestPointOnLineSegment(n, r, e), s = a.dist(e);
    return { point: a, distance: s };
  }
  static Length(e) {
    return O.Dist(e.a, e.b);
  }
  static Tangent(e) {
    return O.Tan(e.a, e.b);
  }
  static Angle(e) {
    return O.Angle(e.a, e.b);
  }
}
class De {
  constructor(e, n, r, a, s, c) {
    this.a = e, this.b = n, this.c = r, this.d = a, this.e = s, this.f = c;
  }
  a = 1;
  b = 0;
  c = 0;
  d = 1;
  e = 0;
  f = 0;
  equals(e) {
    return this.a === e.a && this.b === e.b && this.c === e.c && this.d === e.d && this.e === e.e && this.f === e.f;
  }
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this;
  }
  multiply(e) {
    const n = e, { a: r, b: a, c: s, d: c, e: f, f: p } = this;
    return this.a = r * n.a + s * n.b, this.c = r * n.c + s * n.d, this.e = r * n.e + s * n.f + f, this.b = a * n.a + c * n.b, this.d = a * n.c + c * n.d, this.f = a * n.e + c * n.f + p, this;
  }
  rotate(e, n, r) {
    return e === 0 ? this : n === void 0 ? this.multiply(De.Rotate(e)) : this.translate(n, r).multiply(De.Rotate(e)).translate(-n, -r);
  }
  translate(e, n) {
    return this.multiply(De.Translate(e, n));
  }
  scale(e, n) {
    return this.multiply(De.Scale(e, n));
  }
  invert() {
    const { a: e, b: n, c: r, d: a, e: s, f: c } = this, f = e * a - n * r;
    return this.a = a / f, this.b = n / -f, this.c = r / -f, this.d = e / f, this.e = (a * s - r * c) / -f, this.f = (n * s - e * c) / f, this;
  }
  applyToPoint(e) {
    return De.applyToPoint(this, e);
  }
  applyToPoints(e) {
    return De.applyToPoints(this, e);
  }
  decomposed() {
    return De.Decompose(this);
  }
  toCssString() {
    return De.toCssString(this);
  }
  setTo(e) {
    return Object.assign(this, e), this;
  }
  decompose() {
    return De.Decompose(this);
  }
  clone() {
    return new De(this.a, this.b, this.c, this.d, this.e, this.f);
  }
  /* --------------------- Static --------------------- */
  static Identity() {
    return new De(1, 0, 0, 1, 0, 0);
  }
  static Translate(e, n) {
    return new De(1, 0, 0, 1, e, n);
  }
  static Rotate(e, n, r) {
    if (e === 0)
      return De.Identity();
    const a = Math.cos(e), s = Math.sin(e), c = new De(a, s, -s, a, 0, 0);
    return n === void 0 ? c : De.Compose(
      De.Translate(n, r),
      c,
      De.Translate(-n, -r)
    );
  }
  static Scale = (e, n, r, a) => {
    const s = new De(e, 0, 0, 0, n, 0);
    return r === void 0 ? s : De.Compose(
      De.Translate(r, a),
      s,
      De.Translate(-r, -a)
    );
  };
  static Multiply(e, n) {
    return {
      a: e.a * n.a + e.c * n.b,
      c: e.a * n.c + e.c * n.d,
      e: e.a * n.e + e.c * n.f + e.e,
      b: e.b * n.a + e.d * n.b,
      d: e.b * n.c + e.d * n.d,
      f: e.b * n.e + e.d * n.f + e.f
    };
  }
  static Inverse(e) {
    const n = e.a * e.d - e.b * e.c;
    return {
      a: e.d / n,
      b: e.b / -n,
      c: e.c / -n,
      d: e.a / n,
      e: (e.d * e.e - e.c * e.f) / -n,
      f: (e.b * e.e - e.a * e.f) / n
    };
  }
  static Absolute(e) {
    const n = e.a * e.d - e.b * e.c;
    return {
      a: e.d / n,
      b: e.b / -n,
      c: e.c / -n,
      d: e.a / n,
      e: (e.d * e.e - e.c * e.f) / n,
      f: (e.b * e.e - e.a * e.f) / -n
    };
  }
  static Compose(...e) {
    const n = De.Identity();
    for (let r = 0, a = e.length; r < a; r++)
      n.multiply(e[r]);
    return n;
  }
  static Decompose(e) {
    let n, r, a;
    if (e.a !== 0 || e.c !== 0) {
      const s = Math.hypot(e.a, e.c);
      n = s, r = (e.a * e.d - e.b * e.c) / s, a = Math.acos(e.a / s) * (e.c > 0 ? -1 : 1);
    } else if (e.b !== 0 || e.d !== 0) {
      const s = Math.hypot(e.b, e.d);
      n = (e.a * e.d - e.b * e.c) / s, r = s, a = cr + Math.acos(e.b / s) * (e.d > 0 ? -1 : 1);
    } else
      n = 0, r = 0, a = 0;
    return {
      x: e.e,
      y: e.f,
      scaleX: n,
      scaleY: r,
      rotation: _L(a)
    };
  }
  static Smooth(e, n = 1e10) {
    return e.a = Math.round(e.a * n) / n, e.b = Math.round(e.b * n) / n, e.c = Math.round(e.c * n) / n, e.d = Math.round(e.d * n) / n, e.e = Math.round(e.e * n) / n, e.f = Math.round(e.f * n) / n, e;
  }
  static toCssString(e) {
    return `matrix(${ze(e.a)}, ${ze(e.b)}, ${ze(
      e.c
    )}, ${ze(e.d)}, ${ze(e.e)}, ${ze(e.f)})`;
  }
  static applyToPoint(e, n) {
    return new O(
      e.a * n.x + e.c * n.y + e.e,
      e.b * n.x + e.d * n.y + e.f,
      n.z
    );
  }
  static applyToXY(e, n, r) {
    return [e.a * n + e.c * r + e.e, e.b * n + e.d * r + e.f];
  }
  static applyToPoints(e, n) {
    return n.map(
      (r) => new O(e.a * r.x + e.c * r.y + e.e, e.b * r.x + e.d * r.y + e.f, r.z)
    );
  }
  static applyToBounds(e, n) {
    return new ot(e.e + n.minX, e.f + n.minY, n.width, n.height);
  }
  static From(e) {
    return new De(e.a, e.b, e.c, e.d, e.e, e.f);
  }
}
class _I extends IL {
  constructor(e, n = 1.2, r = 20) {
    super(e, n, r), this.segments = this.getSegmentsFromPoints(e, r);
  }
  segments;
  getSegmentsFromPoints(e, n = 50) {
    const r = [];
    for (let a = 0; a < e.length - 1; a++)
      r.push(new Vq(e[a], e[a + 1], n));
    return r;
  }
  static FromPoints(e) {
    return new _I(e);
  }
}
const { PI: Yq } = Math, kg = Yq + 1e-4;
function Qy(t, e = {}) {
  const { size: n = 16, smoothing: r = 0.5, start: a = {}, end: s = {}, last: c = !1 } = e, { cap: f = !0 } = a, { cap: p = !0 } = s;
  if (t.length === 0 || n <= 0)
    return [];
  const g = t[0], y = t[t.length - 1], v = y.runningLength, S = a.taper === !1 ? 0 : a.taper === !0 ? Math.max(n, v) : a.taper, x = s.taper === !1 ? 0 : s.taper === !0 ? Math.max(n, v) : s.taper, _ = Math.pow(n * r, 2), T = [], I = [];
  let D = t[0].vector, N = t[0].point, j = N, L = N, z = j, F = !1, K;
  for (let ve = 0; ve < t.length; ve++) {
    K = t[ve];
    const { point: Y, vector: le } = t[ve], Re = K.vector.dpr(D), he = (ve < t.length - 1 ? t[ve + 1] : t[ve]).vector, te = ve < t.length - 1 ? he.dpr(K.vector) : 1, de = Re < 0 && !F, W = te !== null && te < 0.2;
    if (de || W) {
      if (te > -0.62 && v - K.runningLength > K.radius) {
        const ce = D.clone().mul(K.radius);
        D.clone().cpr(he) < 0 ? (L = O.Add(Y, ce), z = O.Sub(Y, ce)) : (L = O.Sub(Y, ce), z = O.Add(Y, ce)), T.push(L), I.push(z);
      } else {
        const ce = D.clone().mul(K.radius).per(), xe = O.Sub(K.input, ce);
        for (let $e = 1 / 13, Me = 0; Me < 1; Me += $e)
          L = O.RotWith(xe, K.input, kg * Me), T.push(L), z = O.RotWith(xe, K.input, kg + kg * -Me), I.push(z);
      }
      N = L, j = z, W && (F = !0);
      continue;
    }
    if (F = !1, K === g || K === y) {
      const ce = O.Per(le).mul(K.radius);
      T.push(O.Sub(Y, ce)), I.push(O.Add(Y, ce));
      continue;
    }
    const fe = O.Lrp(he, le, te).per().mul(K.radius);
    L = O.Sub(Y, fe), (ve <= 1 || O.Dist2(N, L) > _) && (T.push(L), N = L), z = O.Add(Y, fe), (ve <= 1 || O.Dist2(j, z) > _) && (I.push(z), j = z), D = le;
  }
  const X = g.point, se = t.length > 1 ? t[t.length - 1].point : O.AddXY(g.point, 1, 1);
  if (t.length === 1 && (!(S || x) || c)) {
    const ve = O.Add(
      X,
      O.Sub(X, se).uni().per().mul(-g.radius)
    ), Y = [];
    for (let le = 1 / 13, Re = le; Re <= 1; Re += le)
      Y.push(O.RotWith(ve, X, kg * 2 * Re));
    return Y;
  }
  const ue = [];
  if (!(S || x && t.length === 1))
    if (f)
      for (let ve = 1 / 8, Y = ve; Y <= 1; Y += ve) {
        const le = O.RotWith(I[0], X, kg * Y);
        ue.push(le);
      }
    else {
      const ve = O.Sub(T[0], I[0]), Y = O.Mul(ve, 0.5), le = O.Mul(ve, 0.51);
      ue.push(
        O.Sub(X, Y),
        O.Sub(X, le),
        O.Add(X, le),
        O.Add(X, Y)
      );
    }
  const pe = [], Pe = y.vector.clone().per().neg();
  if (x || S && t.length === 1)
    pe.push(se);
  else if (p) {
    const ve = O.Add(se, O.Mul(Pe, y.radius));
    for (let Y = 1 / 29, le = Y; le < 1; le += Y)
      pe.push(O.RotWith(ve, se, kg * 3 * le));
  } else
    pe.push(
      O.Add(se, O.Mul(Pe, y.radius)),
      O.Add(se, O.Mul(Pe, y.radius * 0.99)),
      O.Sub(se, O.Mul(Pe, y.radius * 0.99)),
      O.Sub(se, O.Mul(Pe, y.radius))
    );
  return T.concat(pe, I.reverse(), ue);
}
const Kq = 0.025, Wq = 0.01;
function _c(t, e = {}) {
  const { streamline: n = 0.5, size: r = 16, simulatePressure: a = !1 } = e;
  if (t.length === 0)
    return [];
  const s = 0.15 + (1 - n) * 0.85;
  let c = t.map(O.From), f = 0;
  if (!a) {
    let I = c[0];
    for (; I && !(I.z >= Kq); )
      c.shift(), I = c[0];
  }
  if (!a) {
    let I = c[c.length - 1];
    for (; I && !(I.z >= Wq); )
      c.pop(), I = c[c.length - 1];
  }
  if (c.length === 0)
    return [
      {
        point: O.From(t[0]),
        input: O.From(t[0]),
        pressure: a ? 0.5 : 0.15,
        vector: new O(1, 1),
        distance: 0,
        runningLength: 0,
        radius: 1
      }
    ];
  let p = c[1];
  for (; p && !(O.Dist(p, c[0]) > r / 3); )
    c[0].z = Math.max(c[0].z, p.z), c.splice(1, 1), p = c[1];
  const g = c.pop();
  for (p = c[c.length - 1]; p && !(O.Dist(p, g) > r / 3); )
    c.pop(), p = c[c.length - 1], f++;
  c.push(g);
  const y = e.last || !e.simulatePressure || c.length > 1 && O.Dist(c[c.length - 1], c[c.length - 2]) < r || f > 0;
  if (c.length === 2 && e.simulatePressure) {
    const I = c[1];
    c = c.slice(0, -1);
    for (let D = 1; D < 5; D++) {
      const N = O.Lrp(c[0], I, D / 4);
      N.z = (c[0].z + (I.z - c[0].z)) * D / 4, c.push(N);
    }
  }
  const v = [
    {
      point: c[0],
      input: c[0],
      pressure: a ? 0.5 : c[0].z,
      vector: new O(1, 1),
      distance: 0,
      runningLength: 0,
      radius: 1
    }
  ];
  let S = 0, x = v[0], _, T;
  y && n > 0 && c.push(c[c.length - 1].clone());
  for (let I = 1, D = c.length; I < D; I++)
    _ = !s || e.last && I === D - 1 ? c[I].clone() : c[I].clone().lrp(x.point, 1 - s), !x.point.equals(_) && (T = O.Dist(_, x.point), S += T, !(I < 4 && S < r) && (x = {
      input: c[I],
      // The adjusted point
      point: _,
      // The input pressure (or .5 if not specified)
      pressure: a ? 0.5 : c[I].z,
      // The vector from the current point to the previous point
      vector: O.Sub(x.point, _).uni(),
      // The distance between the current point and the previous point
      distance: T,
      // The total distance so far
      runningLength: S,
      // The stroke point's radius
      radius: 1
    }, v.push(x)));
  if (v[1]?.vector && (v[0].vector = v[1].vector.clone()), S < 1) {
    const I = Math.max(0.5, ...v.map((D) => D.pressure));
    v.forEach((D) => D.pressure = I);
  }
  return v;
}
const { min: Ld } = Math, GT = 0.275;
function Zy(t, e) {
  const {
    size: n = 16,
    thinning: r = 0.5,
    simulatePressure: a = !0,
    easing: s = (I) => I,
    start: c = {},
    end: f = {}
  } = e, { easing: p = ua.easeOutQuad } = c, { easing: g = ua.easeOutCubic } = f, y = t[t.length - 1].runningLength;
  let v, S = t[0].pressure, x;
  if (!a && y < n) {
    const I = t.reduce((D, N) => Math.max(D, N.pressure), 0.5);
    return t.forEach((D) => {
      D.pressure = I, D.radius = n * s(0.5 - r * (0.5 - D.pressure));
    }), t;
  } else {
    let I;
    for (let D = 0, N = t.length; D < N && (x = t[D], !(x.runningLength > n * 5)); D++) {
      const j = Ld(1, x.distance / n);
      if (a) {
        const L = Ld(1, 1 - j);
        I = Ld(1, S + (L - S) * (j * GT));
      } else
        I = Ld(1, S + (x.pressure - S) * 0.5);
      S = S + (I - S) * 0.5;
    }
    for (let D = 0; D < t.length; D++) {
      if (x = t[D], r) {
        let { pressure: N } = x;
        const j = Ld(1, x.distance / n);
        if (a) {
          const L = Ld(1, 1 - j);
          N = Ld(1, S + (L - S) * (j * GT));
        } else
          N = Ld(
            1,
            S + (N - S) * (j * GT)
          );
        x.radius = n * s(0.5 - r * (0.5 - N)), S = N;
      } else
        x.radius = n / 2;
      v === void 0 && (v = x.radius);
    }
  }
  const _ = c.taper === !1 ? 0 : c.taper === !0 ? Math.max(n, y) : c.taper, T = f.taper === !1 ? 0 : f.taper === !0 ? Math.max(n, y) : f.taper;
  if (_ || T)
    for (let I = 0; I < t.length; I++) {
      x = t[I];
      const { runningLength: D } = x, N = D < _ ? p(D / _) : 1, j = y - D < T ? g((y - D) / T) : 1;
      x.radius = Math.max(0.01, x.radius * Math.min(N, j));
    }
  return t;
}
function u1(t, e = {}) {
  return Qy(
    Zy(_c(t, e), e),
    e
  );
}
function TI(t, e, n, r) {
  const a = t.x - n.x, s = t.y - n.y, c = r.x - n.x, f = r.y - n.y, p = e.x - t.x, g = e.y - t.y, y = c * s - f * a, v = p * s - g * a, S = f * p - c * g;
  if (y === 0 || v === 0 || S === 0)
    return null;
  if (S !== 0) {
    const x = y / S, _ = v / S;
    if (0 <= x && x <= 1 && 0 <= _ && _ <= 1)
      return O.AddXY(t, x * p, x * g);
  }
  return null;
}
function RL(t, e, n, r) {
  const a = (e.x - t.x) * (e.x - t.x) + (e.y - t.y) * (e.y - t.y), s = 2 * ((e.x - t.x) * (t.x - n.x) + (e.y - t.y) * (t.y - n.y)), c = n.x * n.x + n.y * n.y + t.x * t.x + t.y * t.y - 2 * (n.x * t.x + n.y * t.y) - r * r, f = s * s - 4 * a * c;
  if (f < 0 || f === 0)
    return null;
  const p = Math.sqrt(f), g = (-s + p) / (2 * a), y = (-s - p) / (2 * a);
  if ((g < 0 || g > 1) && (y < 0 || y > 1))
    return null;
  const v = [];
  return 0 <= g && g <= 1 && v.push(O.Lrp(t, e, g)), 0 <= y && y <= 1 && v.push(O.Lrp(t, e, y)), v.length === 0 ? null : v;
}
function kI(t, e, n) {
  const r = [];
  let a;
  for (let s = 0, c = n.length - 1; s < c; s++)
    a = TI(t, e, n[s], n[s + 1]), a && r.push(a);
  return r.length === 0 ? null : r;
}
function Gq(t, e, n) {
  const r = [];
  let a;
  for (let s = 1, c = n.length; s < c + 1; s++)
    a = TI(
      t,
      e,
      n[s - 1],
      n[s % n.length]
    ), a && r.push(a);
  return r.length === 0 ? null : r;
}
function Xq(t, e, n, r) {
  let a = n.x - t.x, s = n.y - t.y;
  const c = Math.sqrt(a * a + s * s), f = (c * c - r * r + e * e) / (2 * c), p = Math.sqrt(e * e - f * f);
  return a /= c, s /= c, [
    new O(t.x + a * f - s * p, t.y + s * f + a * p),
    new O(t.x + a * f + s * p, t.y + s * f - a * p)
  ];
}
function YO(t, e, n) {
  const r = [];
  let a, s, c;
  for (let f = 0, p = n.length; f < p; f++)
    a = n[f], s = n[(f + 1) % n.length], c = RL(a, s, t, e), c && r.push(...c);
  return r.length === 0 ? null : r;
}
function KO(t, e, n) {
  const r = [];
  let a, s, c;
  for (let f = 1, p = n.length; f < p; f++)
    a = n[f - 1], s = n[f], c = RL(a, s, t, e), c && r.push(...c);
  return r.length === 0 ? null : r;
}
function Aw(t, e, n) {
  return (n.y - t.y) * (e.x - t.x) > (e.y - t.y) * (n.x - t.x);
}
function Qd(t, e, n, r) {
  return Aw(t, n, r) !== Aw(e, n, r) && Aw(t, e, n) !== Aw(t, e, r);
}
function oP(t, e) {
  const n = [];
  let r, a, s, c;
  for (let f = 0, p = t.length; f < p; f++)
    r = t[f], Lu(r, e) && n.push(r);
  for (let f = 0, p = e.length; f < p; f++)
    r = e[f], Lu(r, t) && n.push(r);
  for (let f = 0, p = t.length; f < p; f++) {
    r = t[f], a = t[(f + 1) % t.length];
    for (let g = 0, y = e.length; g < y; g++) {
      s = e[g], c = e[(g + 1) % e.length];
      const v = TI(r, a, s, c);
      v !== null && n.push(v);
    }
  }
  return n.length === 0 ? null : qq(n);
}
function qq(t) {
  const e = O.Average(t);
  return t.sort((n, r) => O.Angle(e, n) - O.Angle(e, r));
}
function Qq(t, e) {
  let n, r, a, s;
  for (let c = 0, f = t.length; c < f; c++) {
    n = t[c], r = t[(c + 1) % f];
    for (let p = 0, g = e.length; p < g; p++)
      if (a = e[p], s = e[(p + 1) % g], Qd(n, r, a, s))
        return !0;
  }
  return !1;
}
var $L = { exports: {} };
(function(t) {
  var e = Object.prototype.hasOwnProperty, n = "~";
  function r() {
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1));
  function a(p, g, y) {
    this.fn = p, this.context = g, this.once = y || !1;
  }
  function s(p, g, y, v, S) {
    if (typeof y != "function")
      throw new TypeError("The listener must be a function");
    var x = new a(y, v || p, S), _ = n ? n + g : g;
    return p._events[_] ? p._events[_].fn ? p._events[_] = [p._events[_], x] : p._events[_].push(x) : (p._events[_] = x, p._eventsCount++), p;
  }
  function c(p, g) {
    --p._eventsCount === 0 ? p._events = new r() : delete p._events[g];
  }
  function f() {
    this._events = new r(), this._eventsCount = 0;
  }
  f.prototype.eventNames = function() {
    var g = [], y, v;
    if (this._eventsCount === 0)
      return g;
    for (v in y = this._events)
      e.call(y, v) && g.push(n ? v.slice(1) : v);
    return Object.getOwnPropertySymbols ? g.concat(Object.getOwnPropertySymbols(y)) : g;
  }, f.prototype.listeners = function(g) {
    var y = n ? n + g : g, v = this._events[y];
    if (!v)
      return [];
    if (v.fn)
      return [v.fn];
    for (var S = 0, x = v.length, _ = new Array(x); S < x; S++)
      _[S] = v[S].fn;
    return _;
  }, f.prototype.listenerCount = function(g) {
    var y = n ? n + g : g, v = this._events[y];
    return v ? v.fn ? 1 : v.length : 0;
  }, f.prototype.emit = function(g, y, v, S, x, _) {
    var T = n ? n + g : g;
    if (!this._events[T])
      return !1;
    var I = this._events[T], D = arguments.length, N, j;
    if (I.fn) {
      switch (I.once && this.removeListener(g, I.fn, void 0, !0), D) {
        case 1:
          return I.fn.call(I.context), !0;
        case 2:
          return I.fn.call(I.context, y), !0;
        case 3:
          return I.fn.call(I.context, y, v), !0;
        case 4:
          return I.fn.call(I.context, y, v, S), !0;
        case 5:
          return I.fn.call(I.context, y, v, S, x), !0;
        case 6:
          return I.fn.call(I.context, y, v, S, x, _), !0;
      }
      for (j = 1, N = new Array(D - 1); j < D; j++)
        N[j - 1] = arguments[j];
      I.fn.apply(I.context, N);
    } else {
      var L = I.length, z;
      for (j = 0; j < L; j++)
        switch (I[j].once && this.removeListener(g, I[j].fn, void 0, !0), D) {
          case 1:
            I[j].fn.call(I[j].context);
            break;
          case 2:
            I[j].fn.call(I[j].context, y);
            break;
          case 3:
            I[j].fn.call(I[j].context, y, v);
            break;
          case 4:
            I[j].fn.call(I[j].context, y, v, S);
            break;
          default:
            if (!N)
              for (z = 1, N = new Array(D - 1); z < D; z++)
                N[z - 1] = arguments[z];
            I[j].fn.apply(I[j].context, N);
        }
    }
    return !0;
  }, f.prototype.on = function(g, y, v) {
    return s(this, g, y, v, !1);
  }, f.prototype.once = function(g, y, v) {
    return s(this, g, y, v, !0);
  }, f.prototype.removeListener = function(g, y, v, S) {
    var x = n ? n + g : g;
    if (!this._events[x])
      return this;
    if (!y)
      return c(this, x), this;
    var _ = this._events[x];
    if (_.fn)
      _.fn === y && (!S || _.once) && (!v || _.context === v) && c(this, x);
    else {
      for (var T = 0, I = [], D = _.length; T < D; T++)
        (_[T].fn !== y || S && !_[T].once || v && _[T].context !== v) && I.push(_[T]);
      I.length ? this._events[x] = I.length === 1 ? I[0] : I : c(this, x);
    }
    return this;
  }, f.prototype.removeAllListeners = function(g) {
    var y;
    return g ? (y = n ? n + g : g, this._events[y] && c(this, y)) : (this._events = new r(), this._eventsCount = 0), this;
  }, f.prototype.off = f.prototype.removeListener, f.prototype.addListener = f.prototype.on, f.prefixed = n, f.EventEmitter = f, t.exports = f;
})($L);
var Zq = $L.exports;
function Rp({ children: t, className: e = "", ...n }) {
  return /* @__PURE__ */ E.jsx("svg", { ...n, className: `rs-svg-container ${e}`, children: t });
}
function pi({
  type: t,
  getShapeUtil: e,
  validator: n,
  migrations: r = { currentVersion: 0, firstVersion: 0, migrators: {} }
}) {
  return !n && {}.NODE_ENV === "development" && console.warn(
    `No validator provided for shape type ${t}! Validators are highly recommended for use in production.`
  ), {
    type: t,
    createShapeUtils: (a) => {
      const s = e();
      return new s(a, t);
    },
    is: (a) => a.type === t,
    validator: n,
    migrations: r
  };
}
const yp = 2e3, Ix = 40, $u = 320, Pg = [0.1, 0.25, 0.5, 1, 2, 4, 8], Ow = 0.1, Cp = 8, Jq = 10, eQ = 1, tQ = 1e3, nQ = 1e3, rQ = 5, iQ = {
  left: { x: -1, y: 0 },
  right: { x: 1, y: 0 },
  up: { x: 0, y: -1 },
  down: { x: 0, y: 1 },
  upLeft: { x: -1, y: -1 },
  upRight: { x: 1, y: -1 },
  downLeft: { x: -1, y: 1 },
  downRight: { x: 1, y: 1 }
}, oQ = 450, aQ = 200, Jy = 4, sQ = 32, Rx = {};
for (let t = 1; t <= Math.ceil(Cp); t++)
  Rx[t + "_dark"] = `hash_pattern_zoom_${t}_dark`, Rx[t + "_light"] = `hash_pattern_zoom_${t}_light`;
const WO = {
  duration: 0,
  easing: ua.easeInOutCubic
}, lx = 0.09, _p = 48, $x = 10, lQ = 10, ML = 300, AL = 320, PI = [
  {
    offsetX: 0,
    offsetY: 2,
    blur: 4,
    spread: 0,
    color: "#00000029"
  },
  {
    offsetX: 0,
    offsetY: 3,
    blur: 6,
    spread: 0,
    color: "#0000001f"
  }
], GO = [
  { min: -1, mid: 0.15, step: 100 },
  { min: 0.05, mid: 0.375, step: 25 },
  { min: 0.15, mid: 1, step: 5 },
  { min: 0.7, mid: 2.5, step: 1 }
], Yi = {
  lineHeight: 1.35,
  fontWeight: "normal",
  fontVariant: "normal",
  fontStyle: "normal",
  padding: "0px",
  maxWidth: "auto"
}, Bg = {
  s: 18,
  m: 24,
  l: 36,
  xl: 44
}, Kd = {
  s: 18,
  m: 22,
  l: 26,
  xl: 32
}, Bd = {
  s: 18,
  m: 20,
  l: 24,
  xl: 28
}, Wd = {
  draw: "var(--rs-font-draw)",
  sans: "var(--rs-font-sans)",
  serif: "var(--rs-font-serif)",
  mono: "var(--rs-font-mono)"
}, Dw = {
  color: [
    { id: "black", type: "color", icon: "color" },
    { id: "grey", type: "color", icon: "color" },
    { id: "light-violet", type: "color", icon: "color" },
    { id: "violet", type: "color", icon: "color" },
    { id: "blue", type: "color", icon: "color" },
    { id: "light-blue", type: "color", icon: "color" },
    { id: "yellow", type: "color", icon: "color" },
    { id: "orange", type: "color", icon: "color" },
    { id: "green", type: "color", icon: "color" },
    { id: "light-green", type: "color", icon: "color" },
    { id: "light-red", type: "color", icon: "color" },
    { id: "red", type: "color", icon: "color" }
  ],
  fill: [
    { id: "none", type: "fill", icon: "fill-none" },
    { id: "semi", type: "fill", icon: "fill-semi" },
    { id: "solid", type: "fill", icon: "fill-solid" },
    { id: "pattern", type: "fill", icon: "fill-pattern" }
  ],
  dash: [
    { id: "draw", type: "dash", icon: "dash-draw" },
    { id: "dashed", type: "dash", icon: "dash-dashed" },
    { id: "dotted", type: "dash", icon: "dash-dotted" },
    { id: "solid", type: "dash", icon: "dash-solid" }
  ],
  size: [
    { id: "s", type: "size", icon: "size-small" },
    { id: "m", type: "size", icon: "size-medium" },
    { id: "l", type: "size", icon: "size-large" },
    { id: "xl", type: "size", icon: "size-extra-large" }
  ],
  opacity: [
    { id: "0.1", type: "opacity", icon: "color" },
    { id: "0.25", type: "opacity", icon: "color" },
    { id: "0.5", type: "opacity", icon: "color" },
    { id: "0.75", type: "opacity", icon: "color" },
    { id: "1", type: "opacity", icon: "color" }
  ],
  font: [
    { id: "draw", type: "font", icon: "font-draw" },
    { id: "sans", type: "font", icon: "font-sans" },
    { id: "serif", type: "font", icon: "font-serif" },
    { id: "mono", type: "font", icon: "font-mono" }
  ],
  align: [
    { id: "start", type: "align", icon: "text-align-left" },
    { id: "middle", type: "align", icon: "text-align-center" },
    { id: "end", type: "align", icon: "text-align-right" },
    { id: "justify", type: "align", icon: "text-align-justify" }
  ],
  geo: [
    { id: "rectangle", type: "geo", icon: "geo-rectangle" },
    { id: "ellipse", type: "geo", icon: "geo-ellipse" },
    { id: "triangle", type: "geo", icon: "geo-triangle" },
    { id: "diamond", type: "geo", icon: "geo-diamond" },
    { id: "pentagon", type: "geo", icon: "geo-pentagon" },
    { id: "hexagon", type: "geo", icon: "geo-hexagon" },
    { id: "octagon", type: "geo", icon: "geo-octagon" },
    { id: "star", type: "geo", icon: "geo-star" },
    { id: "rhombus", type: "geo", icon: "geo-rhombus" },
    { id: "rhombus-2", type: "geo", icon: "geo-rhombus-2" },
    { id: "oval", type: "geo", icon: "geo-oval" },
    { id: "trapezoid", type: "geo", icon: "geo-trapezoid" },
    { id: "arrow-right", type: "geo", icon: "geo-arrow-right" },
    { id: "arrow-left", type: "geo", icon: "geo-arrow-left" },
    { id: "arrow-up", type: "geo", icon: "geo-arrow-up" },
    { id: "arrow-down", type: "geo", icon: "geo-arrow-down" },
    { id: "x-box", type: "geo", icon: "geo-x-box" }
  ],
  arrowheadStart: [
    { id: "none", type: "arrowheadStart", icon: "arrowhead-none" },
    { id: "arrow", type: "arrowheadStart", icon: "arrowhead-arrow" },
    { id: "triangle", type: "arrowheadStart", icon: "arrowhead-triangle" },
    { id: "square", type: "arrowheadStart", icon: "arrowhead-square" },
    { id: "dot", type: "arrowheadStart", icon: "arrowhead-dot" },
    { id: "diamond", type: "arrowheadStart", icon: "arrowhead-diamond" },
    { id: "inverted", type: "arrowheadStart", icon: "arrowhead-triangle-inverted" },
    { id: "bar", type: "arrowheadStart", icon: "arrowhead-bar" }
  ],
  arrowheadEnd: [
    { id: "none", type: "arrowheadEnd", icon: "arrowhead-none" },
    { id: "arrow", type: "arrowheadEnd", icon: "arrowhead-arrow" },
    { id: "triangle", type: "arrowheadEnd", icon: "arrowhead-triangle" },
    { id: "square", type: "arrowheadEnd", icon: "arrowhead-square" },
    { id: "dot", type: "arrowheadEnd", icon: "arrowhead-dot" },
    { id: "diamond", type: "arrowheadEnd", icon: "arrowhead-diamond" },
    { id: "inverted", type: "arrowheadEnd", icon: "arrowhead-triangle-inverted" },
    { id: "bar", type: "arrowheadEnd", icon: "arrowhead-bar" }
  ],
  spline: [
    { id: "line", type: "spline", icon: "spline-line" },
    { id: "cubic", type: "spline", icon: "spline-cubic" }
  ]
};
function II(t, e) {
  const n = It.useRef(e);
  n.current = e;
  const [r, a, s] = It.useMemo(() => {
    let c = null;
    const f = (y) => (c = y, () => {
      c = null;
    }), p = new bb(
      `useStateTracking(${t})`,
      // this is what `scheduler.execute()` will call
      () => n.current?.(),
      // this is what will be invoked when signia detects a change in an upstream reactive value
      {
        scheduleEffect() {
          c?.();
        }
      }
    );
    return [p, f, () => p.scheduleCount];
  }, [t]);
  return It.useSyncExternalStore(a, s, s), It.useEffect(() => (r.attach(), r.maybeScheduleEffect(), () => {
    r.detach();
  }), [r]), r.execute();
}
var XO = {
  /**
   * This is a function call trap for functional components. When this is called, we know it means
   * React did run 'Component()', that means we can use any hooks here to setup our effect and
   * store.
   *
   * With the native Proxy, all other calls such as access/setting to/of properties will be
   * forwarded to the target Component, so we don't need to copy the Component's own or inherited
   * properties.
   *
   * @see https://github.com/facebook/react/blob/2d80a0cd690bb5650b6c8a6c079a87b5dc42bd15/packages/react-reconciler/src/ReactFiberHooks.old.js#L460
   */
  apply(t, e, n) {
    return II(
      t.displayName ?? t.name ?? "tracked(???)",
      () => t.apply(e, n)
    );
  }
}, cQ = Symbol.for("react.memo"), uQ = Symbol.for("react.forward_ref");
function dn(t) {
  let e = null;
  const n = t.$$typeof;
  return n === cQ && (t = t.type, e = t.compare), n === uQ ? k.memo(k.forwardRef(new Proxy(t.render, XO))) : k.memo(new Proxy(t, XO), e);
}
function OL(t, e, n) {
  return k.useMemo(() => {
    const r = typeof e == "function" ? e() : e;
    return fi(`useAtom(${t})`, r, n);
  }, []);
}
function un() {
  const t = arguments, e = t.length === 3 ? t[2] : [t[0]], n = t.length === 3 ? t[0] : `useValue(${t[0].name})`, r = k.useRef(!0);
  r.current = !0;
  const a = k.useMemo(() => t.length === 1 ? t[0] : pt(n, () => {
    if (r.current)
      return t[1]();
    try {
      return t[1]();
    } catch {
      return {};
    }
  }), e);
  try {
    const { subscribe: s, getSnapshot: c } = k.useMemo(() => ({
      subscribe: (f) => r1(`useValue(${n})`, () => {
        a.value, f();
      }),
      getSnapshot: () => a.value
    }), [a]);
    return k.useSyncExternalStore(s, c, c);
  } finally {
    r.current = !1;
  }
}
const RI = It.createContext({}), Ge = () => It.useContext(RI);
class lm {
  items = /* @__PURE__ */ new WeakMap();
  get(e, n) {
    return this.items.has(e) || this.items.set(e, n(e)), this.items.get(e);
  }
  access(e) {
    return this.items.get(e);
  }
  set(e, n) {
    this.items.set(e, n);
  }
  has(e) {
    return this.items.has(e);
  }
  invalidate(e) {
    this.items.delete(e);
  }
  bust() {
    this.items = /* @__PURE__ */ new WeakMap();
  }
}
var dQ = 200, $I = "__lodash_hash_undefined__", fQ = 1 / 0, pQ = "[object Function]", hQ = "[object GeneratorFunction]", gQ = /[\\^$.*+?()[\]{}|]/g, mQ = /^\[object .+?Constructor\]$/, vQ = typeof ca == "object" && ca && ca.Object === Object && ca, yQ = typeof self == "object" && self && self.Object === Object && self, MI = vQ || yQ || Function("return this")();
function bQ(t, e) {
  var n = t ? t.length : 0;
  return !!n && xQ(t, e, 0) > -1;
}
function SQ(t, e, n) {
  for (var r = -1, a = t ? t.length : 0; ++r < a; )
    if (n(e, t[r]))
      return !0;
  return !1;
}
function wQ(t, e, n, r) {
  for (var a = t.length, s = n + (r ? 1 : -1); r ? s-- : ++s < a; )
    if (e(t[s], s, t))
      return s;
  return -1;
}
function xQ(t, e, n) {
  if (e !== e)
    return wQ(t, EQ, n);
  for (var r = n - 1, a = t.length; ++r < a; )
    if (t[r] === e)
      return r;
  return -1;
}
function EQ(t) {
  return t !== t;
}
function CQ(t, e) {
  return t.has(e);
}
function _Q(t, e) {
  return t?.[e];
}
function TQ(t) {
  var e = !1;
  if (t != null && typeof t.toString != "function")
    try {
      e = !!(t + "");
    } catch {
    }
  return e;
}
function DL(t) {
  var e = -1, n = Array(t.size);
  return t.forEach(function(r) {
    n[++e] = r;
  }), n;
}
var kQ = Array.prototype, PQ = Function.prototype, NL = Object.prototype, XT = MI["__core-js_shared__"], qO = function() {
  var t = /[^.]+$/.exec(XT && XT.keys && XT.keys.IE_PROTO || "");
  return t ? "Symbol(src)_1." + t : "";
}(), LL = PQ.toString, AI = NL.hasOwnProperty, IQ = NL.toString, RQ = RegExp(
  "^" + LL.call(AI).replace(gQ, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
), $Q = kQ.splice, MQ = OI(MI, "Map"), qT = OI(MI, "Set"), eb = OI(Object, "create");
function $p(t) {
  var e = -1, n = t ? t.length : 0;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
function AQ() {
  this.__data__ = eb ? eb(null) : {};
}
function OQ(t) {
  return this.has(t) && delete this.__data__[t];
}
function DQ(t) {
  var e = this.__data__;
  if (eb) {
    var n = e[t];
    return n === $I ? void 0 : n;
  }
  return AI.call(e, t) ? e[t] : void 0;
}
function NQ(t) {
  var e = this.__data__;
  return eb ? e[t] !== void 0 : AI.call(e, t);
}
function LQ(t, e) {
  var n = this.__data__;
  return n[t] = eb && e === void 0 ? $I : e, this;
}
$p.prototype.clear = AQ;
$p.prototype.delete = OQ;
$p.prototype.get = DQ;
$p.prototype.has = NQ;
$p.prototype.set = LQ;
function cm(t) {
  var e = -1, n = t ? t.length : 0;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
function jQ() {
  this.__data__ = [];
}
function zQ(t) {
  var e = this.__data__, n = d1(e, t);
  if (n < 0)
    return !1;
  var r = e.length - 1;
  return n == r ? e.pop() : $Q.call(e, n, 1), !0;
}
function UQ(t) {
  var e = this.__data__, n = d1(e, t);
  return n < 0 ? void 0 : e[n][1];
}
function BQ(t) {
  return d1(this.__data__, t) > -1;
}
function FQ(t, e) {
  var n = this.__data__, r = d1(n, t);
  return r < 0 ? n.push([t, e]) : n[r][1] = e, this;
}
cm.prototype.clear = jQ;
cm.prototype.delete = zQ;
cm.prototype.get = UQ;
cm.prototype.has = BQ;
cm.prototype.set = FQ;
function um(t) {
  var e = -1, n = t ? t.length : 0;
  for (this.clear(); ++e < n; ) {
    var r = t[e];
    this.set(r[0], r[1]);
  }
}
function HQ() {
  this.__data__ = {
    hash: new $p(),
    map: new (MQ || cm)(),
    string: new $p()
  };
}
function VQ(t) {
  return f1(this, t).delete(t);
}
function YQ(t) {
  return f1(this, t).get(t);
}
function KQ(t) {
  return f1(this, t).has(t);
}
function WQ(t, e) {
  return f1(this, t).set(t, e), this;
}
um.prototype.clear = HQ;
um.prototype.delete = VQ;
um.prototype.get = YQ;
um.prototype.has = KQ;
um.prototype.set = WQ;
function Mx(t) {
  var e = -1, n = t ? t.length : 0;
  for (this.__data__ = new um(); ++e < n; )
    this.add(t[e]);
}
function GQ(t) {
  return this.__data__.set(t, $I), this;
}
function XQ(t) {
  return this.__data__.has(t);
}
Mx.prototype.add = Mx.prototype.push = GQ;
Mx.prototype.has = XQ;
function d1(t, e) {
  for (var n = t.length; n--; )
    if (rZ(t[n][0], e))
      return n;
  return -1;
}
function qQ(t) {
  if (!jL(t) || eZ(t))
    return !1;
  var e = iZ(t) || TQ(t) ? RQ : mQ;
  return e.test(tZ(t));
}
function QQ(t, e, n) {
  var r = -1, a = bQ, s = t.length, c = !0, f = [], p = f;
  if (n)
    c = !1, a = SQ;
  else if (s >= dQ) {
    var g = e ? null : ZQ(t);
    if (g)
      return DL(g);
    c = !1, a = CQ, p = new Mx();
  } else
    p = e ? [] : f;
  e:
    for (; ++r < s; ) {
      var y = t[r], v = e ? e(y) : y;
      if (y = n || y !== 0 ? y : 0, c && v === v) {
        for (var S = p.length; S--; )
          if (p[S] === v)
            continue e;
        e && p.push(v), f.push(y);
      } else
        a(p, v, n) || (p !== f && p.push(v), f.push(y));
    }
  return f;
}
var ZQ = qT && 1 / DL(new qT([, -0]))[1] == fQ ? function(t) {
  return new qT(t);
} : oZ;
function f1(t, e) {
  var n = t.__data__;
  return JQ(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
}
function OI(t, e) {
  var n = _Q(t, e);
  return qQ(n) ? n : void 0;
}
function JQ(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null;
}
function eZ(t) {
  return !!qO && qO in t;
}
function tZ(t) {
  if (t != null) {
    try {
      return LL.call(t);
    } catch {
    }
    try {
      return t + "";
    } catch {
    }
  }
  return "";
}
function nZ(t) {
  return t && t.length ? QQ(t) : [];
}
function rZ(t, e) {
  return t === e || t !== t && e !== e;
}
function iZ(t) {
  var e = jL(t) ? IQ.call(t) : "";
  return e == pQ || e == hQ;
}
function jL(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function");
}
function oZ() {
}
var aZ = nZ;
const sZ = /* @__PURE__ */ Np(aZ), fs = {
  preventDefaultLogging: jd("tldrawPreventDefaultLogging", !1),
  pointerCaptureLogging: jd("tldrawPointerCaptureLogging", !1),
  pointerCaptureTracking: jd("tldrawPointerCaptureTracking", !1),
  pointerCaptureTrackingObject: jd(
    "tldrawPointerCaptureTrackingObject",
    // ideally we wouldn't store this mutable value in an atom but it's not
    // a big deal for debug values
    /* @__PURE__ */ new Map(),
    !1
  ),
  elementRemovalLogging: jd("tldrawElementRemovalLogging", !1),
  debugSvg: jd("tldrawDebugSvg", !1),
  throwToBlob: jd("tldrawThrowToBlob", !1),
  peopleMenu: jd("tldrawPeopleMenu", !1)
};
if (typeof Element < "u") {
  const t = Element.prototype.removeChild;
  r1("element removal logging", () => {
    fs.elementRemovalLogging.value ? Element.prototype.removeChild = function(e) {
      return console.warn("[tldraw] removing child:", e), t.call(this, e);
    } : Element.prototype.removeChild = t;
  });
}
function jd(t, e, n = !0) {
  if (typeof window > "u")
    return fi(`debug:${t}`, e);
  const r = n ? lZ(t) : null, a = fi(`debug:${t}`, r ?? e);
  return n && r1(`debug:${t}`, () => {
    const s = a.value;
    try {
      s === e ? window.sessionStorage.removeItem(`debug:${t}`) : window.sessionStorage.setItem(`debug:${t}`, JSON.stringify(s));
    } catch {
    }
  }), Object.defineProperty(window, t, {
    get() {
      return a.value;
    },
    set(s) {
      a.set(s);
    },
    configurable: !0
  }), a;
}
function lZ(t) {
  try {
    return JSON.parse(window.sessionStorage.getItem(`debug:${t}`) ?? "null");
  } catch {
    return null;
  }
}
function zL(t) {
  const e = t.cloneNode(!0);
  return t.setAttribute("width", +t.getAttribute("width") + ""), t.setAttribute("height", +t.getAttribute("height") + ""), new XMLSerializer().serializeToString(e).replaceAll("&#10;      ", "").replaceAll(/((\s|")[0-9]*\.[0-9]{2})([0-9]*)(\b|"|\))/g, "$1");
}
async function UL(t, e) {
  const { type: n, quality: r, scale: a } = e, s = +t.getAttribute("width"), c = +t.getAttribute("height"), f = await BL(t), p = await new Promise((y) => {
    const v = new Image();
    v.crossOrigin = "anonymous", v.onload = async () => {
      await new Promise((_) => setTimeout(_, 250));
      const S = document.createElement("canvas"), x = S.getContext("2d");
      S.width = s * a, S.height = c * a, x.imageSmoothingEnabled = !0, x.imageSmoothingQuality = "high", x.drawImage(v, 0, 0, s * a, c * a), URL.revokeObjectURL(f), y(S);
    }, v.onerror = () => {
      y(null);
    }, v.src = f;
  });
  return p ? await new Promise(
    (y) => p.toBlob(
      (v) => {
        (!v || fs.throwToBlob.value) && y(null), y(v);
      },
      "image/" + n,
      r
    )
  ) : null;
}
async function BL(t) {
  const e = t.cloneNode(!0);
  e.setAttribute("encoding", 'UTF-8"');
  const n = new FileReader(), r = Array.from(e.querySelectorAll("image"));
  for (const a of r) {
    const s = a.getAttribute("xlink:href");
    if (s && !s.startsWith("data:")) {
      const c = await (await fetch(s)).blob(), f = await new Promise((p, g) => {
        n.onload = () => p(n.result), n.onerror = () => g(n.error), n.readAsDataURL(c);
      });
      a.setAttribute("xlink:href", f);
    }
  }
  return FL(e);
}
function FL(t) {
  const e = new XMLSerializer().serializeToString(t);
  return `data:image/svg+xml;base64,${window.btoa(unescape(encodeURIComponent(e)))}`;
}
function QT(t, e) {
  const n = document.createElement("a");
  n.href = t, n.download = e, n.click();
}
function QO(t, e) {
  let n = 0;
  for (; t[e + n]; )
    n += t[e + n] + 1;
  return n + 1;
}
function cZ(t) {
  return new TextDecoder("ascii").decode(t.slice(0, 3)) === "GIF";
}
function uZ(t) {
  const e = new Uint8Array(t);
  let n, r, a = 0, s = 0;
  if (!cZ(t))
    return !1;
  for (n = e[10] & 128, r = e[10] & 7, a += 6, a += 7, a += n ? 3 * Math.pow(2, r + 1) : 0; s < 2 && a < e.length; )
    switch (e[a]) {
      case 44:
        s += 1, n = e[a + 9] & 128, r = e[a + 9] & 7, a += 10, a += n ? 3 * Math.pow(2, r + 1) : 0, a += QO(e, a + 1) + 1;
        break;
      case 33:
        a += 2, a += QO(e, a);
        break;
      case 59:
        a = e.length;
        break;
      default:
        a = e.length;
        break;
    }
  return s > 1;
}
const DI = ["image/jpeg", "image/png", "image/gif", "image/svg+xml", "image/webp"], HL = ["video/mp4", "video/quicktime", "video/webm"], dZ = DI.concat(HL).join(", "), VL = (t) => DI.includes(t);
async function fZ(t) {
  return await new Promise((e, n) => {
    const r = document.createElement("video");
    r.onloadeddata = () => e({ w: r.videoWidth, h: r.videoHeight }), r.onerror = (a) => {
      console.error(a), n(new Error("Could not get video size"));
    }, r.crossOrigin = "anonymous", r.src = t;
  });
}
async function pZ(t) {
  return await new Promise((e, n) => {
    const r = new Image();
    r.onload = () => e({ w: r.width, h: r.height }), r.onerror = (a) => {
      console.error(a), n(new Error("Could not get image size"));
    }, r.crossOrigin = "anonymous", r.src = t;
  });
}
async function hZ(t, e, n) {
  return await new Promise((r) => {
    const a = new Image();
    a.onload = () => {
      const s = document.createElement("canvas"), c = s.getContext("2d");
      if (!c)
        return;
      s.width = e * 2, s.height = n * 2, c.drawImage(a, 0, 0, s.width, s.height);
      const f = s.toDataURL();
      r(f);
    }, a.crossOrigin = "anonymous", a.src = t;
  });
}
async function gZ(t) {
  return await new Promise((e, n) => {
    const r = new FileReader();
    r.onerror = () => n(r.error), r.onload = async () => {
      let a = r.result;
      const s = VL(t.type), c = s ? pZ : fZ;
      t.type === "video/quicktime" && a.includes("video/quicktime") && (a = a.replace("video/quicktime", "video/mp4"));
      const f = await c(a), p = vZ(f, { w: tQ, h: nQ });
      p !== f && (t.type === "image/jpeg" || t.type === "image/png") && (a = await hZ(a, p.w, p.h));
      const g = sm.createCustomId(n1(a)), y = await mZ(t), v = {
        id: g,
        type: s ? "image" : "video",
        typeName: "asset",
        props: {
          name: t.name,
          src: a,
          w: p.w,
          h: p.h,
          mimeType: t.type,
          isAnimated: y.isAnimated
        }
      };
      e(v);
    }, r.readAsDataURL(t);
  });
}
async function mZ(t) {
  return t.type === "image/gif" ? await new Promise((e, n) => {
    const r = new FileReader();
    r.onerror = () => n(r.error), r.onload = () => {
      e({
        isAnimated: r.result ? uZ(r.result) : !1
      });
    }, r.readAsArrayBuffer(t);
  }) : {
    isAnimated: !VL(t.type)
  };
}
function vZ(t, e) {
  const n = t.w / e.w, r = t.h / e.h;
  return n <= 1 && r <= 1 ? t : n > r ? {
    w: t.w / n,
    h: t.h / n
  } : {
    w: t.w / r,
    h: t.h / r
  };
}
async function p1(t, e, n, r = !1) {
  const a = new O(n.x, n.y), s = /* @__PURE__ */ new Map(), c = await Promise.all(
    e.map(async (x, _) => {
      if (!x.type)
        throw new Error("No mime type");
      if (!DI.concat(HL).includes(x.type))
        return console.warn(`${x.name} not loaded - Extension not allowed.`), null;
      try {
        const T = await t.onCreateAssetFromFile(x);
        if (T.type === "bookmark")
          return;
        if (!T)
          throw Error("Could not create an asset");
        return s.set(x, T), {
          id: no(),
          type: T.type,
          x: a.x + _,
          y: a.y,
          props: {
            w: T.props.w,
            h: T.props.h,
            opacity: "1"
          }
        };
      } catch (T) {
        return console.error(T), null;
      }
    })
  ), f = Gt(c).sort((x, _) => x.x - _.x);
  if (f.length === 0)
    return;
  for (let x = 0; x < f.length; x++) {
    const _ = f[x];
    if (x === 0)
      _.x -= _.props.w / 2, _.y -= _.props.h / 2;
    else {
      const T = f[x - 1];
      _.x = T.x + T.props.w, _.y = T.y;
    }
  }
  const g = (await Promise.all(
    e.map(async (x, _) => {
      const T = f[_];
      if (!T)
        return;
      const I = s.get(x);
      if (!I)
        return;
      let D = t.getAssetById(I.id);
      return D ? (s.delete(x), T.props && (T.props.assetId = D.id), T) : (D = t.getAssetBySrc(I.props.src), D ? (T.props && (T.props.assetId = D.id), T) : (T.props && (T.props.assetId = I.id), T));
    })
  )).filter(FG);
  t.createAssets(Gt([...s.values()])), t.createShapes(g), t.setSelectedIds(g.map((x) => x.id));
  const { selectedIds: y, viewportPageBounds: v } = t, S = ot.Common(Gt(y.map((x) => t.getPageBoundsById(x))));
  S && !v.contains(S) && t.zoomToSelection();
}
function YL(t, e, n, r) {
  t.createShapes(
    [
      {
        id: no(),
        type: "embed",
        x: n.x - (r.width || 450) / 2,
        y: n.y - (r.height || 450) / 2,
        props: {
          w: r.width,
          h: r.height,
          doesResize: r.doesResize,
          url: e,
          opacity: "1"
        }
      }
    ],
    !0
  );
}
async function yZ(t, e, n) {
  const r = sm.createCustomId(n1(e)), a = t.getAssetById(r);
  if (a) {
    t.createShapes([
      {
        id: t.createShapeId(),
        type: "bookmark",
        x: n.x - 150,
        y: n.y - 160,
        props: {
          assetId: a.id,
          url: a.props.src,
          opacity: "1"
        }
      }
    ]);
    return;
  }
  t.batch(async () => {
    const s = no();
    t.createShapes(
      [
        {
          id: s,
          type: "bookmark",
          x: n.x,
          y: n.y,
          props: {
            url: e,
            opacity: "1"
          }
        }
      ],
      !0
    );
    const c = await t.onCreateBookmarkFromUrl(e);
    c && (t.createAssets([
      {
        id: r,
        typeName: "asset",
        type: "bookmark",
        props: {
          src: e,
          description: c.description,
          image: c.image,
          title: c.title
        }
      }
    ]), t.updateShapes([
      {
        id: s,
        type: "bookmark",
        props: {
          assetId: r,
          opacity: "1"
        }
      }
    ]));
  });
}
function bZ(t, e, n) {
  const r = new DOMParser().parseFromString(e, "image/svg+xml").querySelector("svg");
  if (!r)
    throw new Error("No <svg/> element present");
  const a = FL(r);
  let s = parseFloat(r.getAttribute("width") || "0"), c = parseFloat(r.getAttribute("height") || "0");
  if (!(s && c)) {
    document.body.appendChild(r);
    const p = r.getBoundingClientRect();
    document.body.removeChild(r), s = p.width, c = p.height;
  }
  const f = sm.createCustomId(n1(a));
  t.batch(() => {
    t.createAssets([
      {
        id: f,
        typeName: "asset",
        type: "image",
        props: {
          src: a,
          w: s,
          h: c,
          name: "svg",
          isAnimated: !0,
          mimeType: "image/svg+xml"
        }
      }
    ]), t.createShapes(
      [
        {
          id: no(),
          type: "image",
          x: n.x - s / 2,
          y: n.y - c / 2,
          props: {
            assetId: f,
            w: s,
            h: c,
            opacity: "1"
          }
        }
      ],
      !0
    );
  });
}
const SZ = (t) => {
  try {
    const e = new URL(t);
    return e.protocol === "http:" || e.protocol === "https:";
  } catch {
    return !1;
  }
}, wZ = (t) => {
  const e = t.split(/[\n\s]/);
  for (const n of e)
    try {
      const r = new URL(n);
      if (!(r.protocol === "http:" || r.protocol === "https:"))
        return;
    } catch {
      return;
    }
  return sZ(e);
}, xZ = (t) => /^<svg/.test(t);
function EZ(t, e, n) {
  return fetch(t).then(function(r) {
    return r.arrayBuffer();
  }).then(function(r) {
    return new File([r], e, { type: n });
  });
}
function Ii() {
  return fI();
}
function CZ(t, e) {
  let n = t;
  const r = new Set(e);
  for (; r.has(n); )
    n = /^.*(\d+)$/.exec(n)?.[1] ? n.replace(/(\d+)(?=\D?)$/, (a) => (+a + 1).toString()) : `${n} 1`;
  return n;
}
function Ax(t) {
  if (t instanceof HTMLElement)
    return t;
  if (t.parentElement)
    return Ax(t.parentElement);
  throw Error("Could not find a parent element of an HTML type!");
}
function Gn(t) {
  t.preventDefault(), fs.preventDefaultLogging.value && console.warn("preventDefault called on event:", t);
}
function wb(t, e) {
  if (t.setPointerCapture(e.pointerId), fs.pointerCaptureTracking.value) {
    const n = fs.pointerCaptureTrackingObject.value;
    n.set(t, (n.get(t) ?? 0) + 1);
  }
  fs.pointerCaptureLogging.value && console.warn("setPointerCapture called on element:", t, e);
}
function xb(t, e) {
  if (t.hasPointerCapture(e.pointerId)) {
    if (t.releasePointerCapture(e.pointerId), fs.pointerCaptureTracking.value) {
      const n = fs.pointerCaptureTrackingObject.value;
      n.get(t) === 1 ? n.delete(t) : n.has(t) ? n.set(t, n.get(t) - 1) : console.warn("Release without capture");
    }
    fs.pointerCaptureLogging.value && console.warn("releasePointerCapture called on element:", t, e);
  }
}
function NI(t, e) {
  return e.map((r) => {
    const { offsetX: a, offsetY: s, blur: c, spread: f, color: p } = r, g = new O(a, s), { x: y, y: v } = g.rot(-t);
    return `${y}px ${v}px ${c}px ${f}px ${p}`;
  }).join(", ");
}
function KL() {
  const [t, e] = k.useState(!1);
  return k.useEffect(() => {
    const n = window.matchMedia("(prefers-reduced-motion: reduce)"), r = () => {
      e(n.matches);
    };
    return r(), n.addEventListener("change", r), () => n.removeEventListener("change", r);
  }, []), t;
}
const ZT = (t, e) => t.length <= e ? t : t.substring(0, e - 3) + "...";
function _Z(t) {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function TZ(t) {
  const e = new URL(t).host.replace("www.", "");
  for (const n of Qg)
    if (WL(n.hostnames, e)) {
      const r = n.fromEmbedUrl(t);
      if (r)
        return {
          definition: n,
          url: r,
          embedUrl: t
        };
    }
}
const kZ = (t) => t.split("*").map((e) => _Z(e)).join(".+"), WL = (t, e) => !!t.find((n) => {
  const r = new RegExp(kZ(n));
  return e.match(r);
});
function PZ(t) {
  const e = new URL(t).host.replace("www.", "");
  for (const n of Qg)
    if (WL(n.hostnames, e)) {
      const r = n.toEmbedUrl(t);
      if (r)
        return {
          definition: n,
          embedUrl: r,
          url: t
        };
    }
}
function GL(t) {
  return PZ(t) ?? TZ(t);
}
function Yd(t) {
  try {
    return GL(t);
  } catch (e) {
    console.error(e);
  }
}
function ZO(t, e) {
  let n = null;
  for (const [r, a] of Object.entries(e))
    vL.has(r) && (n || (n = { ...t }), n[r] = a);
  return n ?? t;
}
const ls = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", IZ = "a0", XL = "A00000000000000000000000000";
function qL(t) {
  if (t >= "a" && t <= "z")
    return t.charCodeAt(0) - "a".charCodeAt(0) + 2;
  if (t >= "A" && t <= "Z")
    return "Z".charCodeAt(0) - t.charCodeAt(0) + 2;
  throw new Error("Invalid index key head: " + t);
}
function QL(t) {
  if (t.length !== qL(t.charAt(0)))
    throw new Error("invalid integer part of index key: " + t);
}
function JO(t) {
  if (t === void 0)
    throw Error("n is undefined");
}
function eD(t) {
  QL(t);
  const [e, ...n] = t.split("");
  let r = !0;
  for (let a = n.length - 1; r && a >= 0; a--) {
    const s = ls.indexOf(n[a]) + 1;
    s === ls.length ? n[a] = "0" : (n[a] = ls.charAt(s), r = !1);
  }
  if (r) {
    if (e === "Z")
      return "a0";
    if (e === "z")
      return;
    const a = String.fromCharCode(e.charCodeAt(0) + 1);
    return a > "a" ? n.push("0") : n.pop(), a + n.join("");
  } else
    return e + n.join("");
}
function RZ(t) {
  QL(t);
  const [e, ...n] = t.split("");
  let r = !0;
  for (let a = n.length - 1; r && a >= 0; a--) {
    const s = ls.indexOf(n[a]) - 1;
    s === -1 ? n[a] = ls.slice(-1) : (n[a] = ls.charAt(s), r = !1);
  }
  if (r) {
    if (e === "a")
      return "Z" + ls.slice(-1);
    if (e === "A")
      return;
    const a = String.fromCharCode(e.charCodeAt(0) - 1);
    return a < "Z" ? n.push(ls.slice(-1)) : n.pop(), a + n.join("");
  } else
    return e + n.join("");
}
function Fg(t, e) {
  if (e !== void 0 && t >= e)
    throw new Error(t + " >= " + e);
  if (t.slice(-1) === "0" || e && e.slice(-1) === "0")
    throw new Error("trailing zero");
  if (e) {
    let a = 0;
    for (; (t.charAt(a) || "0") === e.charAt(a); )
      a++;
    if (a > 0)
      return e.slice(0, a) + Fg(t.slice(a), e.slice(a));
  }
  const n = t ? ls.indexOf(t.charAt(0)) : 0, r = e !== void 0 ? ls.indexOf(e.charAt(0)) : ls.length;
  if (r - n > 1) {
    const a = Math.round(0.5 * (n + r));
    return ls.charAt(a);
  } else
    return e && e.length > 1 ? e.slice(0, 1) : ls.charAt(n) + Fg(t.slice(1), void 0);
}
function Ly(t) {
  const e = qL(t.charAt(0));
  if (e > t.length)
    throw new Error("invalid index: " + t);
  return t.slice(0, e);
}
function tD(t) {
  if (t === XL)
    throw new Error("invalid index: " + t);
  const e = Ly(t);
  if (t.slice(e.length).slice(-1) === "0")
    throw new Error("invalid index: " + t);
}
function Ig(t, e) {
  if (t !== void 0 && tD(t), e !== void 0 && tD(e), t !== void 0 && e !== void 0 && t >= e)
    throw new Error(t + " >= " + e);
  if (t === void 0 && e === void 0)
    return IZ;
  if (t === void 0) {
    if (e === void 0)
      throw Error("b is undefined");
    const f = Ly(e), p = e.slice(f.length);
    if (f === XL)
      return f + Fg("", p);
    if (f < e)
      return f;
    const g = RZ(f);
    return JO(g), g;
  }
  if (e === void 0) {
    const f = Ly(t), p = t.slice(f.length), g = eD(f);
    return g === void 0 ? f + Fg(p, void 0) : g;
  }
  const n = Ly(t), r = t.slice(n.length), a = Ly(e), s = e.slice(a.length);
  if (n === a)
    return n + Fg(r, s);
  const c = eD(n);
  return JO(c), c < e ? c : n + Fg(r, void 0);
}
function Zd(t, e, n) {
  if (n === 0)
    return [];
  if (n === 1)
    return [Ig(t, e)];
  if (e === void 0) {
    let s = Ig(t, e);
    const c = [s];
    for (let f = 0; f < n - 1; f++)
      s = Ig(s, e), c.push(s);
    return c;
  }
  if (t === void 0) {
    let s = Ig(t, e);
    const c = [s];
    for (let f = 0; f < n - 1; f++)
      s = Ig(t, s), c.push(s);
    return c.reverse(), c;
  }
  const r = Math.floor(n / 2), a = Ig(t, e);
  return [...Zd(t, a, r), a, ...Zd(a, e, n - r - 1)];
}
function Rg(t, e, n) {
  return Zd(t, e, n);
}
function JT(t, e) {
  return Zd(t, void 0, e);
}
function Fy(t, e) {
  return Zd(t, e, 1)[0];
}
function Ru(t) {
  return Zd(t, void 0, 1)[0];
}
function $Z(t) {
  return Zd(void 0, t, 1)[0];
}
function ZL(t) {
  return ["a1", ...Zd("a1", void 0, t)];
}
function Ha(t, e) {
  return t.index < e.index ? -1 : t.index > e.index ? 1 : 0;
}
function MZ(t, e) {
  return t.id < e.id ? -1 : t.id > e.id ? 1 : 0;
}
function JL({ app: t }) {
  const {
    selectionRotation: e,
    selectionPageCenter: n,
    inputs: { originPagePoint: r },
    selectedShapes: a
  } = t;
  return {
    selectionPageCenter: n,
    initialCursorAngle: n.angle(r),
    initialSelectionRotation: e,
    shapeSnapshots: a.map((s) => ({
      shape: Ou(s),
      initialPagePoint: t.getPagePointById(s.id)
    }))
  };
}
function cx({
  delta: t,
  app: e,
  snapshot: n,
  stage: r
}) {
  const { selectionPageCenter: a, shapeSnapshots: s } = n;
  e.updateShapes(
    s.map(({ shape: f, initialPagePoint: p }) => {
      const g = Us(f.parentId) ? e.getPageTransformById(f.parentId) : De.Identity(), y = O.RotWith(p, a, t), v = De.applyToPoint(
        // use the current parent transform in case it has moved/resized since the start
        // (e.g. if rotating a shape at the edge of a group)
        De.Inverse(g),
        y
      ), S = EI(f.rotation + t);
      return {
        id: f.id,
        type: f.type,
        x: v.x,
        y: v.y,
        rotation: S
      };
    })
  );
  const c = [];
  s.forEach(({ shape: f }) => {
    const p = e.getShapeById(f.id);
    if (!p)
      return;
    const g = e.getShapeUtil(f);
    if (r === "start" || r === "one-off") {
      const v = g.onRotateStart?.(f);
      v && c.push(v);
    }
    const y = g.onRotate?.(f, p);
    if (y && c.push(y), r === "end" || r === "one-off") {
      const v = g.onRotateEnd?.(f, p);
      v && c.push(v);
    }
  }), c.length > 0 && e.updateShapes(c);
}
const AZ = {
  openWindow: (t, e) => window.open(t, e, "noopener noreferrer")
};
function ej(t, e) {
  return t.match(/^\s*$/) ? e : t;
}
function OZ(t) {
  return t.replace(/\s(\s+)/g, (e, n) => {
    let r = " ";
    for (let a = 0; a < n.length; a++)
      r += " ";
    return r;
  });
}
function Vi(t, e) {
  t.isKilled = !0;
  const { top: n, left: r } = e.getBoundingClientRect();
  return {
    point: {
      x: t.clientX - r,
      y: t.clientY - n,
      z: t.pressure
    },
    shiftKey: t.shiftKey,
    altKey: t.altKey,
    ctrlKey: t.metaKey || t.ctrlKey,
    pointerId: t.pointerId,
    button: t.button,
    isPen: t.pointerType === "pen"
  };
}
function Fs(t) {
  return `${ze(t.x)},${ze(t.y)} `;
}
function Hs(t, e) {
  return `${ze((t.x + e.x) / 2)},${ze((t.y + e.y) / 2)} `;
}
function Jd(t, e = !0) {
  const n = t.length;
  if (n < 2)
    return "";
  let r = t[0], a = t[1];
  if (n === 2)
    return `M${Fs(r)}L${Fs(a)}`;
  let s = "";
  for (let c = 2, f = n - 1; c < f; c++)
    r = t[c], a = t[c + 1], s += Hs(r, a);
  return e ? `M${Hs(t[0], t[1])}Q${Fs(t[1])}${Hs(
    t[1],
    t[2]
  )}T${s}${Hs(t[n - 1], t[0])}${Hs(t[0], t[1])}Z` : `M${Fs(t[0])}Q${Fs(t[1])}${Hs(t[1], t[2])}${t.length > 3 ? "T" : ""}${s}L${Fs(t[n - 1])}`;
}
function Gd(t, e = !1) {
  const n = t.length;
  if (n < 2)
    return "";
  let r = t[0].point, a = t[1].point;
  if (n === 2)
    return `M${Fs(r)}L${Fs(a)}`;
  let s = "";
  for (let c = 2, f = n - 1; c < f; c++)
    r = t[c].point, a = t[c + 1].point, s += Hs(r, a);
  return e ? `M${Hs(t[0].point, t[1].point)}Q${Fs(t[1].point)}${Hs(
    t[1].point,
    t[2].point
  )}T${s}${Hs(t[n - 1].point, t[0].point)}${Hs(
    t[0].point,
    t[1].point
  )}Z` : `M${Fs(t[0].point)}Q${Fs(t[1].point)}${Hs(
    t[1].point,
    t[2].point
  )}${t.length > 3 ? "T" : ""}${s}L${Fs(t[n - 1].point)}`;
}
function DZ(t, e = "_blank") {
  AZ.openWindow(t, e);
}
function NZ() {
  const t = Ge();
  return k.useMemo(
    function() {
      let r, a;
      function s(_) {
        _.isKilled || _.button !== 0 && _.button !== 1 && _.button !== 5 || (wb(_.currentTarget, _), t.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_down",
          ...Vi(_, t.getContainer())
        }));
      }
      function c(_) {
        _.isKilled || _.clientX === r && _.clientY === a || (r = _.clientX, a = _.clientY, t.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_move",
          ...Vi(_, t.getContainer())
        }));
      }
      function f(_) {
        _.isKilled || _.button !== 0 && _.button !== 1 && _.button !== 5 || (r = _.clientX, a = _.clientY, xb(_.currentTarget, _), t.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_up",
          ...Vi(_, t.getContainer())
        }));
      }
      function p(_) {
        _.isKilled || t.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_enter",
          ...Vi(_, t.getContainer())
        });
      }
      function g(_) {
        _.isKilled || t.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_leave",
          ...Vi(_, t.getContainer())
        });
      }
      function y(_) {
        _.isKilled = !0, document.body.click(), Gn(_);
      }
      function v(_) {
        _.isKilled = !0, _.target.tagName !== "A" && _.target.tagName !== "TEXTAREA" && Gn(_);
      }
      function S(_) {
        Gn(_);
      }
      async function x(_) {
        if (Gn(_), !_.dataTransfer?.files?.length)
          return;
        const T = Array.from(_.dataTransfer.files).filter(
          (I) => !I.name.endsWith(".tldr")
        );
        await p1(t, T, t.screenToPage(_.clientX, _.clientY), !1);
      }
      return {
        onPointerDown: s,
        onPointerMove: c,
        onPointerUp: f,
        onPointerEnter: p,
        onPointerLeave: g,
        onDragOver: S,
        onDrop: x,
        onTouchStart: y,
        onTouchEnd: v
      };
    },
    [t]
  );
}
function LZ() {
  const t = Ge();
  k.useEffect(() => {
    const e = window.matchMedia("(pointer: coarse)"), n = () => {
      t.isCoarsePointer = e.matches;
    };
    return n(), e.addEventListener("change", n), () => e.removeEventListener("change", n);
  }, [t]);
}
const tj = k.createContext(null);
function jZ({
  container: t,
  children: e
}) {
  return /* @__PURE__ */ E.jsx(tj.Provider, { value: t, children: e });
}
function ga() {
  return UG(k.useContext(tj), "useContainer used outside of <Tldraw />");
}
function kp(t, e, n = Ys) {
  k.useEffect(() => {
    const r = new bb(t, e);
    return r.attach(), r.execute(), () => {
      r.detach();
    };
  }, n);
}
const ek = "<path d='m19.7432 17.0869-4.072 4.068 2.829 2.828-8.473-.013-.013-8.47 2.841 2.842 4.075-4.068 1.414-1.415-2.844-2.842h8.486v8.484l-2.83-2.827z' fill='%23fff'/><path d='m18.6826 16.7334-4.427 4.424 1.828 1.828-5.056-.016-.014-5.054 1.842 1.841 4.428-4.422 2.474-2.475-1.844-1.843h5.073v5.071l-1.83-1.828z' fill='%23000'/>", tk = "<path d='m9 17.9907v.005l5.997 5.996.001-3.999h1.999 2.02v4l5.98-6.001-5.98-5.999.001 4.019-2.021.002h-2l.001-4.022zm1.411.003 3.587-3.588-.001 2.587h3.5 2.521v-2.585l3.565 3.586-3.564 3.585-.001-2.585h-2.521l-3.499-.001-.001 2.586z' fill='%23fff'/><path d='m17.4971 18.9932h2.521v2.586l3.565-3.586-3.565-3.585v2.605h-2.521-3.5v-2.607l-3.586 3.587 3.586 3.586v-2.587z' fill='%23000'/>", Py = '<g><path d="M22.4789 9.45728L25.9935 12.9942L22.4789 16.5283V14.1032C18.126 14.1502 14.6071 17.6737 14.5675 22.0283H17.05L13.513 25.543L9.97889 22.0283H12.5674C12.6071 16.5691 17.0214 12.1503 22.4789 12.1031L22.4789 9.45728Z" fill="black"/><path fill-rule="evenodd" clip-rule="evenodd" d="M21.4789 7.03223L27.4035 12.9945L21.4789 18.9521V15.1868C18.4798 15.6549 16.1113 18.0273 15.649 21.0284H19.475L13.5128 26.953L7.55519 21.0284H11.6189C12.1243 15.8155 16.2679 11.6677 21.4789 11.1559L21.4789 7.03223ZM22.4789 12.1031C17.0214 12.1503 12.6071 16.5691 12.5674 22.0284H9.97889L13.513 25.543L17.05 22.0284H14.5675C14.5705 21.6896 14.5947 21.3558 14.6386 21.0284C15.1157 17.4741 17.9266 14.6592 21.4789 14.1761C21.8063 14.1316 22.1401 14.1069 22.4789 14.1032V16.5284L25.9935 12.9942L22.4789 9.45729L22.4789 12.1031Z" fill="white"/></g>', zZ = `<path fill="currentcolor" d='m6.94 2v-1c-1.35866267-.08246172-2.66601117.53165299-3.47 1.63-.80398883-1.09834701-2.11133733-1.71246172-3.47-1.63v1c1.30781678-.16635468 2.55544738.59885876 3 1.84v5.1h-1v1h1v4.16c-.4476345 1.2386337-1.69302129 2.002471-3 1.84v1c1.35687108.0731933 2.6600216-.5389494 3.47-1.63.8099784 1.0910506 2.11312892 1.7031933 3.47 1.63v-1c-1.28590589.133063-2.49760499-.6252793-2.94-1.84v-4.18h1v-1h-1v-5.08c.43943906-1.21710975 1.65323743-1.97676587 2.94-1.84z' transform='translate(14 9)'/>`, UZ = "<path d='m13.5732 12.0361c.48-.178 1.427-.069 1.677.473.213.462.396 1.241.406 1.075.024-.369-.024-1.167.137-1.584.117-.304.347-.59.686-.691.285-.086.62-.116.916-.055.313.064.642.287.765.499.362.623.368 1.899.385 1.831.064-.272.07-1.229.283-1.584.141-.235.497-.445.687-.479.294-.052.656-.068.964-.008.249.049.586.344.677.487.219.344.342 1.316.379 1.658.016.141.074-.393.293-.736.406-.639 1.844-.763 1.898.639.026.654.02.624.02 1.064 0 .516-.012.828-.04 1.202-.03.399-.116 1.304-.241 1.742-.086.301-.371.978-.653 1.384 0 0-1.074 1.25-1.191 1.812-.117.563-.078.567-.102.965-.023.399.121.923.121.923s-.801.104-1.234.034c-.391-.062-.875-.84-1-1.078-.172-.328-.539-.265-.682-.023-.224.383-.709 1.07-1.05 1.113-.669.084-2.055.03-3.14.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.283-.36-1.002-.929-1.243-1.985-.213-.936-.192-1.395.037-1.77.232-.381.67-.589.854-.625.208-.042.692-.039.875.062.223.123.313.159.488.391.23.307.312.456.213.121-.076-.262-.322-.595-.434-.97-.109-.361-.401-.943-.38-1.526.008-.221.103-.771.832-1.042' fill='%23fff'/><g stroke='%23000' stroke-width='.75'><path d='m13.5732 12.0361c.48-.178 1.427-.069 1.677.473.213.462.396 1.241.406 1.075.024-.369-.024-1.167.137-1.584.117-.304.347-.59.686-.691.285-.086.62-.116.916-.055.313.064.642.287.765.499.362.623.368 1.899.385 1.831.064-.272.07-1.229.283-1.584.141-.235.497-.445.687-.479.294-.052.656-.068.964-.008.249.049.586.344.677.487.219.344.342 1.316.379 1.658.016.141.074-.393.293-.736.406-.639 1.844-.763 1.898.639.026.654.02.624.02 1.064 0 .516-.012.828-.04 1.202-.03.399-.116 1.304-.241 1.742-.086.301-.371.978-.653 1.384 0 0-1.074 1.25-1.191 1.812-.117.563-.078.567-.102.965-.023.399.121.923.121.923s-.801.104-1.234.034c-.391-.062-.875-.84-1-1.078-.172-.328-.539-.265-.682-.023-.224.383-.709 1.07-1.05 1.113-.669.084-2.055.03-3.14.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.283-.36-1.002-.929-1.243-1.985-.213-.936-.192-1.395.037-1.77.232-.381.67-.589.854-.625.208-.042.692-.039.875.062.223.123.313.159.488.391.23.307.312.456.213.121-.076-.262-.322-.595-.434-.97-.109-.361-.401-.943-.38-1.526.008-.221.103-.771.832-1.042z' stroke-linejoin='round'/><path d='m20.5664 19.7344v-3.459' stroke-linecap='round'/><path d='m18.5508 19.7461-.016-3.473' stroke-linecap='round'/><path d='m16.5547 16.3047.021 3.426' stroke-linecap='round'/></g>", BZ = '<path d="m13.5557 17.5742c-.098-.375-.196-.847-.406-1.552-.167-.557-.342-.859-.47-1.233-.155-.455-.303-.721-.496-1.181-.139-.329-.364-1.048-.457-1.44-.119-.509.033-.924.244-1.206.253-.339.962-.49 1.357-.351.371.13.744.512.916.788.288.46.357.632.717 1.542.393.992.564 1.918.611 2.231l.085.452c-.001-.04-.043-1.122-.044-1.162-.035-1.029-.06-1.823-.038-2.939.002-.126.064-.587.084-.715.078-.5.305-.8.673-.979.412-.201.926-.215 1.401-.017.423.173.626.55.687 1.022.014.109.094.987.093 1.107-.013 1.025.006 1.641.015 2.174.004.231.003 1.625.017 1.469.061-.656.094-3.189.344-3.942.144-.433.405-.746.794-.929.431-.203 1.113-.07 1.404.243.285.305.446.692.482 1.153.032.405-.019.897-.02 1.245 0 .867-.021 1.324-.037 2.121-.001.038-.015.298.023.182.094-.28.188-.542.266-.745.049-.125.241-.614.359-.859.114-.234.211-.369.415-.688.2-.313.415-.448.668-.561.54-.235 1.109.112 1.301.591.086.215.009.713-.028 1.105-.061.647-.254 1.306-.352 1.648-.128.447-.274 1.235-.34 1.601-.072.394-.234 1.382-.359 1.82-.086.301-.371.978-.652 1.384 0 0-1.074 1.25-1.192 1.812-.117.563-.078.567-.101.965-.024.399.121.923.121.923s-.802.104-1.234.034c-.391-.062-.875-.841-1-1.078-.172-.328-.539-.265-.682-.023-.225.383-.709 1.07-1.051 1.113-.668.084-2.054.03-3.139.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.284-.36-.629-1.093-1.243-1.985-.348-.504-1.027-1.085-1.284-1.579-.223-.425-.331-.954-.19-1.325.225-.594.675-.897 1.362-.832.519.05.848.206 1.238.537.225.19.573.534.75.748.163.195.203.276.377.509.23.307.302.459.214.121" fill="%23fff"/><g stroke="%23000" stroke-linecap="round" stroke-width=".75"><path d="m13.5557 17.5742c-.098-.375-.196-.847-.406-1.552-.167-.557-.342-.859-.47-1.233-.155-.455-.303-.721-.496-1.181-.139-.329-.364-1.048-.457-1.44-.119-.509.033-.924.244-1.206.253-.339.962-.49 1.357-.351.371.13.744.512.916.788.288.46.357.632.717 1.542.393.992.564 1.918.611 2.231l.085.452c-.001-.04-.043-1.122-.044-1.162-.035-1.029-.06-1.823-.038-2.939.002-.126.064-.587.084-.715.078-.5.305-.8.673-.979.412-.201.926-.215 1.401-.017.423.173.626.55.687 1.022.014.109.094.987.093 1.107-.013 1.025.006 1.641.015 2.174.004.231.003 1.625.017 1.469.061-.656.094-3.189.344-3.942.144-.433.405-.746.794-.929.431-.203 1.113-.07 1.404.243.285.305.446.692.482 1.153.032.405-.019.897-.02 1.245 0 .867-.021 1.324-.037 2.121-.001.038-.015.298.023.182.094-.28.188-.542.266-.745.049-.125.241-.614.359-.859.114-.234.211-.369.415-.688.2-.313.415-.448.668-.561.54-.235 1.109.112 1.301.591.086.215.009.713-.028 1.105-.061.647-.254 1.306-.352 1.648-.128.447-.274 1.235-.34 1.601-.072.394-.234 1.382-.359 1.82-.086.301-.371.978-.652 1.384 0 0-1.074 1.25-1.192 1.812-.117.563-.078.567-.101.965-.024.399.121.923.121.923s-.802.104-1.234.034c-.391-.062-.875-.841-1-1.078-.172-.328-.539-.265-.682-.023-.225.383-.709 1.07-1.051 1.113-.668.084-2.054.03-3.139.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.284-.36-.629-1.093-1.243-1.985-.348-.504-1.027-1.085-1.284-1.579-.223-.425-.331-.954-.19-1.325.225-.594.675-.897 1.362-.832.519.05.848.206 1.238.537.225.19.573.534.75.748.163.195.203.276.377.509.23.307.302.459.214.121" stroke-linejoin="round"/><path d="m20.5664 21.7344v-3.459"/><path d="m18.5508 21.7461-.016-3.473"/><path d="m16.5547 18.3047.021 3.426"/></g>';
function Ua(t, e, n, r, a) {
  const s = (-n - e) * (Yr / 180), c = Math.sin(s), f = Math.cos(s), p = 1 * f - 1 * c, g = 1 * c + 1 * f;
  return `url("data:image/svg+xml,<svg height='32' width='32' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' style='color: ${a};'><defs><filter id='shadow' color-interpolation-filters='sRGB'><feDropShadow dx='${p}' dy='${g}' stdDeviation='1.2' flood-opacity='.5'/></filter></defs><g fill='none' transform='rotate(${e + n} 16 16)${r ? " scale(-1,-1) translate(0, -32)" : ""}' filter='url(%23shadow)'>` + t.replaceAll('"', "'") + '</g></svg>") 16 16, pointer';
}
const FZ = {
  none: () => "none",
  default: () => "default",
  pointer: () => "pointer",
  cross: () => "crosshair",
  move: () => "move",
  grab: (t, e, n) => Ua(BZ, t, 0, e, n),
  grabbing: (t, e, n) => Ua(UZ, t, 0, e, n),
  text: (t, e, n) => Ua(zZ, t, 0, e, n),
  "resize-edge": (t, e, n) => Ua(tk, t, 0, e, n),
  "resize-corner": (t, e, n) => Ua(ek, t, 0, e, n),
  "ew-resize": (t, e, n) => Ua(tk, t, 0, e, n),
  "ns-resize": (t, e, n) => Ua(tk, t, 90, e, n),
  "nesw-resize": (t, e, n) => Ua(ek, t, 0, e, n),
  "nwse-resize": (t, e, n) => Ua(ek, t, 90, e, n),
  rotate: (t, e, n) => Ua(Py, t, 45, e, n),
  "nwse-rotate": (t, e, n) => Ua(Py, t, 0, e, n),
  "nesw-rotate": (t, e, n) => Ua(Py, t, 90, e, n),
  "senw-rotate": (t, e, n) => Ua(Py, t, 180, e, n),
  "swne-rotate": (t, e, n) => Ua(Py, t, 270, e, n)
};
function ss(t, e = 0, n = "black") {
  return FZ[t](kL(e), !1, n);
}
function HZ() {
  const t = Ge(), e = ga();
  kp(
    "useCursor",
    () => {
      const { type: n, rotation: r, color: a } = t.cursor;
      e.style.setProperty("--rs-cursor", ss(n, r, a));
    },
    [t, e]
  );
}
function VZ() {
  const t = Ge(), e = ga(), n = un("isDarkMode", () => t.userDocumentSettings.isDarkMode, [t]);
  It.useEffect(() => {
    n ? (e.setAttribute("data-color-mode", "dark"), e.classList.remove("rs-theme__light"), e.classList.add("rs-theme__dark"), t.setCursor({
      color: "white"
    })) : (e.setAttribute("data-color-mode", "light"), e.classList.remove("rs-theme__dark"), e.classList.add("rs-theme__light"), t.setCursor({
      color: "black"
    }));
  }, [t, e, n]);
}
function YZ() {
  const t = Ge(), e = ga();
  k.useEffect(() => {
    const n = (p) => {
      if (p.altKey && !t.root.path.value.endsWith(".idle") && !Iy() && p.preventDefault(), p.isKilled)
        return;
      switch (p.isKilled = !0, p.key) {
        case "=": {
          if (p.metaKey || p.ctrlKey) {
            Gn(p);
            return;
          }
          break;
        }
        case "-": {
          if (p.metaKey || p.ctrlKey) {
            Gn(p);
            return;
          }
          break;
        }
        case "0": {
          if (p.metaKey || p.ctrlKey) {
            Gn(p);
            return;
          }
          break;
        }
        case "Tab": {
          if (Iy() || t.isMenuOpen)
            return;
          break;
        }
        case ",": {
          if (!Iy() && (Gn(p), !t.inputs.keys.has(","))) {
            const { x: y, y: v, z: S } = t.inputs.currentScreenPoint, {
              pageState: { hoveredId: x }
            } = t;
            t.inputs.keys.add(",");
            const _ = {
              type: "pointer",
              name: "pointer_down",
              point: { x: y, y: v, z: S },
              shiftKey: p.shiftKey,
              altKey: p.altKey,
              ctrlKey: p.metaKey || p.ctrlKey,
              pointerId: 0,
              button: 0,
              isPen: t.isPenMode,
              ...x ? {
                target: "shape",
                shape: t.getShapeById(x)
              } : {
                target: "canvas"
              }
            };
            t.dispatch(_);
            return;
          }
          break;
        }
        case "Escape": {
          t.inputs.keys.has("Escape") || (t.inputs.keys.add("Escape"), t.cancel());
          return;
        }
        default:
          if (Iy() || t.isMenuOpen)
            return;
      }
      const g = {
        type: "keyboard",
        name: "key_down",
        key: p.key,
        shiftKey: p.shiftKey,
        altKey: p.altKey,
        ctrlKey: p.metaKey || p.ctrlKey
      };
      t.dispatch(g);
    }, r = (p) => {
      if (p.isKilled || (p.isKilled = !0, Iy() || t.isMenuOpen))
        return;
      if (p.key === "," && (document.activeElement?.ELEMENT_NODE && Gn(p), t.inputs.keys.has(","))) {
        const { x: y, y: v, z: S } = t.inputs.currentScreenPoint, {
          pageState: { hoveredId: x }
        } = t;
        t.inputs.keys.delete(",");
        const _ = {
          type: "pointer",
          name: "pointer_up",
          point: { x: y, y: v, z: S },
          shiftKey: p.shiftKey,
          altKey: p.altKey,
          ctrlKey: p.metaKey || p.ctrlKey,
          pointerId: 0,
          button: 0,
          isPen: t.isPenMode,
          ...x ? {
            target: "shape",
            shape: t.getShapeById(x)
          } : {
            target: "canvas"
          }
        };
        t.dispatch(_);
        return;
      }
      const g = {
        type: "keyboard",
        name: "key_up",
        key: p.key,
        shiftKey: p.shiftKey,
        altKey: p.altKey,
        ctrlKey: p.metaKey || p.ctrlKey
      };
      t.dispatch(g);
    };
    function a(p) {
      if (e.contains(p.target)) {
        const g = p.touches[0].pageX, y = p.touches[0].radiusX || 0;
        (g - y < 10 || g + y > t.viewportScreenBounds.width - 10) && (p.target?.tagName === "BUTTON" && p.target?.click(), Gn(p));
      }
    }
    const s = (p) => {
      e.contains(p.target) && (p.ctrlKey || p.metaKey) && Gn(p);
    };
    function c() {
      t.blur();
    }
    function f() {
      t.updateViewportScreenBounds();
    }
    return e.addEventListener("touchstart", a, { passive: !1 }), e.addEventListener("wheel", s, { passive: !1 }), e.addEventListener("gesturestart", Gn), e.addEventListener("gesturechange", Gn), e.addEventListener("gestureend", Gn), e.addEventListener("keydown", n), e.addEventListener("keyup", r), e.addEventListener("blur", c), e.addEventListener("focus", f), () => {
      e.removeEventListener("touchstart", a), e.removeEventListener("wheel", s), e.removeEventListener("gesturestart", Gn), e.removeEventListener("gesturechange", Gn), e.removeEventListener("gestureend", Gn), e.removeEventListener("keydown", n), e.removeEventListener("keyup", r), e.removeEventListener("blur", c), e.removeEventListener("focus", c);
    };
  }, [t, e]);
}
const KZ = ["input", "select", "button", "textarea"];
function Iy() {
  const { activeElement: t } = document;
  return !!(t && (t.getAttribute("contenteditble") || KZ.indexOf(t.tagName.toLowerCase()) > -1));
}
function WZ(t) {
  const e = k.useRef();
  return k.useLayoutEffect(() => {
    e.current = t;
  }), k.useDebugValue(t), k.useCallback((...n) => {
    const r = e.current;
    return nL(r, "fn does not exist"), r(...n);
  }, []);
}
const GZ = ["textarea", "input"];
function XZ(t) {
  const e = Ge();
  k.useEffect(() => {
    const n = t.current;
    if (!n)
      return;
    const r = (a) => {
      if (a instanceof PointerEvent && a.pointerType === "pen") {
        a.isKilled = !0;
        const { target: s } = a;
        if (GZ.includes(s.tagName?.toLocaleLowerCase()) || e.isIn("select.editing_shape"))
          return;
        Gn(a);
      }
    };
    return n.addEventListener("touchstart", r), n.addEventListener("touchend", r), () => {
      n.removeEventListener("touchstart", r), n.addEventListener("touchend", r);
    };
  }, [e, t]);
}
function qZ() {
  const [t, e] = k.useState(0);
  k.useEffect(() => e((n) => n + 1), []);
}
function QZ(t, e, n) {
  return Math.max(e, Math.min(t, n));
}
const Eo = {
  toVector(t, e) {
    return t === void 0 && (t = e), Array.isArray(t) ? t : [t, t];
  },
  add(t, e) {
    return [t[0] + e[0], t[1] + e[1]];
  },
  sub(t, e) {
    return [t[0] - e[0], t[1] - e[1]];
  },
  addTo(t, e) {
    t[0] += e[0], t[1] += e[1];
  },
  subTo(t, e) {
    t[0] -= e[0], t[1] -= e[1];
  }
};
function nD(t, e, n) {
  return e === 0 || Math.abs(e) === 1 / 0 ? Math.pow(t, n * 5) : t * e * n / (e + n * t);
}
function rD(t, e, n, r = 0.15) {
  return r === 0 ? QZ(t, e, n) : t < e ? -nD(e - t, n - e, r) + e : t > n ? +nD(t - n, n - e, r) + n : t;
}
function ZZ(t, [e, n], [r, a]) {
  const [[s, c], [f, p]] = t;
  return [rD(e, s, c, r), rD(n, f, p, a)];
}
function JZ(t, e) {
  if (typeof t != "object" || t === null)
    return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (typeof r != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function eJ(t) {
  var e = JZ(t, "string");
  return typeof e == "symbol" ? e : String(e);
}
function Ho(t, e, n) {
  return e = eJ(e), e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function iD(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(a) {
      return Object.getOwnPropertyDescriptor(t, a).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Jr(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? iD(Object(n), !0).forEach(function(r) {
      Ho(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : iD(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
const nj = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function oD(t) {
  return t ? t[0].toUpperCase() + t.slice(1) : "";
}
const tJ = ["enter", "leave"];
function nJ(t = !1, e) {
  return t && !tJ.includes(e);
}
function rJ(t, e = "", n = !1) {
  const r = nj[t], a = r && r[e] || e;
  return "on" + oD(t) + oD(a) + (nJ(n, a) ? "Capture" : "");
}
const iJ = ["gotpointercapture", "lostpointercapture"];
function oJ(t) {
  let e = t.substring(2).toLowerCase();
  const n = !!~e.indexOf("passive");
  n && (e = e.replace("passive", ""));
  const r = iJ.includes(e) ? "capturecapture" : "capture", a = !!~e.indexOf(r);
  return a && (e = e.replace("capture", "")), {
    device: e,
    capture: a,
    passive: n
  };
}
function aJ(t, e = "") {
  const n = nj[t], r = n && n[e] || e;
  return t + r;
}
function rj(t) {
  return "touches" in t;
}
function sJ(t) {
  return rj(t) ? "touch" : "pointerType" in t ? t.pointerType : "mouse";
}
function lJ(t) {
  return Array.from(t.touches).filter((e) => {
    var n, r;
    return e.target === t.currentTarget || ((n = t.currentTarget) === null || n === void 0 || (r = n.contains) === null || r === void 0 ? void 0 : r.call(n, e.target));
  });
}
function aP(t, e) {
  try {
    const n = e.clientX - t.clientX, r = e.clientY - t.clientY, a = (e.clientX + t.clientX) / 2, s = (e.clientY + t.clientY) / 2, c = Math.hypot(n, r);
    return {
      angle: -(Math.atan2(n, r) * 180) / Math.PI,
      distance: c,
      origin: [a, s]
    };
  } catch {
  }
  return null;
}
function cJ(t) {
  return lJ(t).map((e) => e.identifier);
}
function aD(t, e) {
  const [n, r] = Array.from(t.touches).filter((a) => e.includes(a.identifier));
  return aP(n, r);
}
const sD = 40, lD = 800;
function ij(t) {
  let {
    deltaX: e,
    deltaY: n,
    deltaMode: r
  } = t;
  return r === 1 ? (e *= sD, n *= sD) : r === 2 && (e *= lD, n *= lD), [e, n];
}
function uJ(t) {
  const e = {};
  if ("buttons" in t && (e.buttons = t.buttons), "shiftKey" in t) {
    const {
      shiftKey: n,
      altKey: r,
      metaKey: a,
      ctrlKey: s
    } = t;
    Object.assign(e, {
      shiftKey: n,
      altKey: r,
      metaKey: a,
      ctrlKey: s
    });
  }
  return e;
}
function Ox(t, ...e) {
  return typeof t == "function" ? t(...e) : t;
}
function dJ() {
}
function fJ(...t) {
  return t.length === 0 ? dJ : t.length === 1 ? t[0] : function() {
    let e;
    for (const n of t)
      e = n.apply(this, arguments) || e;
    return e;
  };
}
function cD(t, e) {
  return Object.assign({}, e, t || {});
}
const pJ = 32;
class oj {
  constructor(e, n, r) {
    this.ctrl = e, this.args = n, this.key = r, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset());
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(e) {
    this.ctrl.state[this.key] = e;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state: e,
      shared: n,
      ingKey: r,
      args: a
    } = this;
    n[r] = e._active = e.active = e._blocked = e._force = !1, e._step = [!1, !1], e.intentional = !1, e._movement = [0, 0], e._distance = [0, 0], e._direction = [0, 0], e._delta = [0, 0], e._bounds = [[-1 / 0, 1 / 0], [-1 / 0, 1 / 0]], e.args = a, e.axis = void 0, e.memo = void 0, e.elapsedTime = e.timeDelta = 0, e.direction = [0, 0], e.distance = [0, 0], e.overflow = [0, 0], e._movementBound = [!1, !1], e.velocity = [0, 0], e.movement = [0, 0], e.delta = [0, 0], e.timeStamp = 0;
  }
  start(e) {
    const n = this.state, r = this.config;
    n._active || (this.reset(), this.computeInitial(), n._active = !0, n.target = e.target, n.currentTarget = e.currentTarget, n.lastOffset = r.from ? Ox(r.from, n) : n.offset, n.offset = n.lastOffset, n.startTime = n.timeStamp = e.timeStamp);
  }
  computeValues(e) {
    const n = this.state;
    n._values = e, n.values = this.config.transform(e);
  }
  computeInitial() {
    const e = this.state;
    e._initial = e._values, e.initial = e.values;
  }
  compute(e) {
    const {
      state: n,
      config: r,
      shared: a
    } = this;
    n.args = this.args;
    let s = 0;
    if (e && (n.event = e, r.preventDefault && e.cancelable && n.event.preventDefault(), n.type = e.type, a.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, a.locked = !!document.pointerLockElement, Object.assign(a, uJ(e)), a.down = a.pressed = a.buttons % 2 === 1 || a.touches > 0, s = e.timeStamp - n.timeStamp, n.timeStamp = e.timeStamp, n.elapsedTime = n.timeStamp - n.startTime), n._active) {
      const F = n._delta.map(Math.abs);
      Eo.addTo(n._distance, F);
    }
    this.axisIntent && this.axisIntent(e);
    const [c, f] = n._movement, [p, g] = r.threshold, {
      _step: y,
      values: v
    } = n;
    if (r.hasCustomTransform ? (y[0] === !1 && (y[0] = Math.abs(c) >= p && v[0]), y[1] === !1 && (y[1] = Math.abs(f) >= g && v[1])) : (y[0] === !1 && (y[0] = Math.abs(c) >= p && Math.sign(c) * p), y[1] === !1 && (y[1] = Math.abs(f) >= g && Math.sign(f) * g)), n.intentional = y[0] !== !1 || y[1] !== !1, !n.intentional)
      return;
    const S = [0, 0];
    if (r.hasCustomTransform) {
      const [F, K] = v;
      S[0] = y[0] !== !1 ? F - y[0] : 0, S[1] = y[1] !== !1 ? K - y[1] : 0;
    } else
      S[0] = y[0] !== !1 ? c - y[0] : 0, S[1] = y[1] !== !1 ? f - y[1] : 0;
    this.restrictToAxis && !n._blocked && this.restrictToAxis(S);
    const x = n.offset, _ = n._active && !n._blocked || n.active;
    _ && (n.first = n._active && !n.active, n.last = !n._active && n.active, n.active = a[this.ingKey] = n._active, e && (n.first && ("bounds" in r && (n._bounds = Ox(r.bounds, n)), this.setup && this.setup()), n.movement = S, this.computeOffset()));
    const [T, I] = n.offset, [[D, N], [j, L]] = n._bounds;
    n.overflow = [T < D ? -1 : T > N ? 1 : 0, I < j ? -1 : I > L ? 1 : 0], n._movementBound[0] = n.overflow[0] ? n._movementBound[0] === !1 ? n._movement[0] : n._movementBound[0] : !1, n._movementBound[1] = n.overflow[1] ? n._movementBound[1] === !1 ? n._movement[1] : n._movementBound[1] : !1;
    const z = n._active ? r.rubberband || [0, 0] : [0, 0];
    if (n.offset = ZZ(n._bounds, n.offset, z), n.delta = Eo.sub(n.offset, x), this.computeMovement(), _ && (!n.last || s > pJ)) {
      n.delta = Eo.sub(n.offset, x);
      const F = n.delta.map(Math.abs);
      Eo.addTo(n.distance, F), n.direction = n.delta.map(Math.sign), n._direction = n._delta.map(Math.sign), !n.first && s > 0 && (n.velocity = [F[0] / s, F[1] / s], n.timeDelta = s);
    }
  }
  emit() {
    const e = this.state, n = this.shared, r = this.config;
    if (e._active || this.clean(), (e._blocked || !e.intentional) && !e._force && !r.triggerAllEvents)
      return;
    const a = this.handler(Jr(Jr(Jr({}, n), e), {}, {
      [this.aliasKey]: e.values
    }));
    a !== void 0 && (e.memo = a);
  }
  clean() {
    this.eventStore.clean(), this.timeoutStore.clean();
  }
}
function hJ([t, e], n) {
  const r = Math.abs(t), a = Math.abs(e);
  if (r > a && r > n)
    return "x";
  if (a > r && a > n)
    return "y";
}
class gJ extends oj {
  constructor(...e) {
    super(...e), Ho(this, "aliasKey", "xy");
  }
  reset() {
    super.reset(), this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0], this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = Eo.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = Eo.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(e) {
    const n = this.state, r = this.config;
    if (!n.axis && e) {
      const a = typeof r.axisThreshold == "object" ? r.axisThreshold[sJ(e)] : r.axisThreshold;
      n.axis = hJ(n._movement, a);
    }
    n._blocked = (r.lockDirection || !!r.axis) && !n.axis || !!r.axis && r.axis !== n.axis;
  }
  restrictToAxis(e) {
    if (this.config.axis || this.config.lockDirection)
      switch (this.state.axis) {
        case "x":
          e[1] = 0;
          break;
        case "y":
          e[0] = 0;
          break;
      }
  }
}
const uD = (t) => t, dD = 0.15, LI = {
  enabled(t = !0) {
    return t;
  },
  eventOptions(t, e, n) {
    return Jr(Jr({}, n.shared.eventOptions), t);
  },
  preventDefault(t = !1) {
    return t;
  },
  triggerAllEvents(t = !1) {
    return t;
  },
  rubberband(t = 0) {
    switch (t) {
      case !0:
        return [dD, dD];
      case !1:
        return [0, 0];
      default:
        return Eo.toVector(t);
    }
  },
  from(t) {
    if (typeof t == "function")
      return t;
    if (t != null)
      return Eo.toVector(t);
  },
  transform(t, e, n) {
    const r = t || n.shared.transform;
    if (this.hasCustomTransform = !!r, {}.NODE_ENV === "development") {
      const a = r || uD;
      return (s) => {
        const c = a(s);
        return (!isFinite(c[0]) || !isFinite(c[1])) && console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${c[0]},${[1]}]`), c;
      };
    }
    return r || uD;
  },
  threshold(t) {
    return Eo.toVector(t, 0);
  }
};
({}).NODE_ENV === "development" && Object.assign(LI, {
  domTarget(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
    return NaN;
  },
  lockDirection(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `lockDirection` option has been merged with `axis`. Use it as in `{ axis: 'lock' }`");
    return NaN;
  },
  initial(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `initial` option has been renamed to `from`.");
    return NaN;
  }
});
const mJ = 0, Eb = Jr(Jr({}, LI), {}, {
  axis(t, e, {
    axis: n
  }) {
    if (this.lockDirection = n === "lock", !this.lockDirection)
      return n;
  },
  axisThreshold(t = mJ) {
    return t;
  },
  bounds(t = {}) {
    if (typeof t == "function")
      return (s) => Eb.bounds(t(s));
    if ("current" in t)
      return () => t.current;
    if (typeof HTMLElement == "function" && t instanceof HTMLElement)
      return t;
    const {
      left: e = -1 / 0,
      right: n = 1 / 0,
      top: r = -1 / 0,
      bottom: a = 1 / 0
    } = t;
    return [[e, n], [r, a]];
  }
}), Cb = typeof window < "u" && window.document && window.document.createElement;
function vJ() {
  return Cb && "ontouchstart" in window;
}
function fD() {
  return vJ() || Cb && window.navigator.maxTouchPoints > 1;
}
function yJ() {
  return Cb && "onpointerdown" in window;
}
function bJ() {
  return Cb && "exitPointerLock" in window.document;
}
function SJ() {
  try {
    return "constructor" in GestureEvent;
  } catch {
    return !1;
  }
}
const Vs = {
  isBrowser: Cb,
  gesture: SJ(),
  touch: fD(),
  touchscreen: fD(),
  pointer: yJ(),
  pointerLock: bJ()
}, wJ = 250, xJ = 180, EJ = 0.5, CJ = 50, _J = 250, TJ = 10, pD = {
  mouse: 0,
  touch: 0,
  pen: 8
}, kJ = Jr(Jr({}, Eb), {}, {
  device(t, e, {
    pointer: {
      touch: n = !1,
      lock: r = !1,
      mouse: a = !1
    } = {}
  }) {
    return this.pointerLock = r && Vs.pointerLock, Vs.touch && n ? "touch" : this.pointerLock ? "mouse" : Vs.pointer && !a ? "pointer" : Vs.touch ? "touch" : "mouse";
  },
  preventScrollAxis(t, e, {
    preventScroll: n
  }) {
    if (this.preventScrollDelay = typeof n == "number" ? n : n || n === void 0 && t ? wJ : void 0, !(!Vs.touchscreen || n === !1))
      return t || (n !== void 0 ? "y" : void 0);
  },
  pointerCapture(t, e, {
    pointer: {
      capture: n = !0,
      buttons: r = 1,
      keys: a = !0
    } = {}
  }) {
    return this.pointerButtons = r, this.keys = a, !this.pointerLock && this.device === "pointer" && n;
  },
  threshold(t, e, {
    filterTaps: n = !1,
    tapsThreshold: r = 3,
    axis: a = void 0
  }) {
    const s = Eo.toVector(t, n ? r : a ? 1 : 0);
    return this.filterTaps = n, this.tapsThreshold = r, s;
  },
  swipe({
    velocity: t = EJ,
    distance: e = CJ,
    duration: n = _J
  } = {}) {
    return {
      velocity: this.transform(Eo.toVector(t)),
      distance: this.transform(Eo.toVector(e)),
      duration: n
    };
  },
  delay(t = 0) {
    switch (t) {
      case !0:
        return xJ;
      case !1:
        return 0;
      default:
        return t;
    }
  },
  axisThreshold(t) {
    return t ? Jr(Jr({}, pD), t) : pD;
  },
  keyboardDisplacement(t = TJ) {
    return t;
  }
});
({}).NODE_ENV === "development" && Object.assign(kJ, {
  useTouch(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `useTouch` option has been renamed to `pointer.touch`. Use it as in `{ pointer: { touch: true } }`.");
    return NaN;
  },
  experimental_preventWindowScrollY(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `experimental_preventWindowScrollY` option has been renamed to `preventScroll`.");
    return NaN;
  },
  swipeVelocity(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeVelocity` option has been renamed to `swipe.velocity`. Use it as in `{ swipe: { velocity: 0.5 } }`.");
    return NaN;
  },
  swipeDistance(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeDistance` option has been renamed to `swipe.distance`. Use it as in `{ swipe: { distance: 50 } }`.");
    return NaN;
  },
  swipeDuration(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeDuration` option has been renamed to `swipe.duration`. Use it as in `{ swipe: { duration: 250 } }`.");
    return NaN;
  }
});
function aj(t) {
  const [e, n] = t.overflow, [r, a] = t._delta, [s, c] = t._direction;
  (e < 0 && r > 0 && s < 0 || e > 0 && r < 0 && s > 0) && (t._movement[0] = t._movementBound[0]), (n < 0 && a > 0 && c < 0 || n > 0 && a < 0 && c > 0) && (t._movement[1] = t._movementBound[1]);
}
const PJ = 30, IJ = 100;
class RJ extends oj {
  constructor(...e) {
    super(...e), Ho(this, "ingKey", "pinching"), Ho(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0], this.state.lastOffset = [1, 0], this.state._pointerEvents = /* @__PURE__ */ new Map();
  }
  reset() {
    super.reset();
    const e = this.state;
    e._touchIds = [], e.canceled = !1, e.cancel = this.cancel.bind(this), e.turns = 0;
  }
  computeOffset() {
    const {
      type: e,
      movement: n,
      lastOffset: r
    } = this.state;
    e === "wheel" ? this.state.offset = Eo.add(n, r) : this.state.offset = [(1 + n[0]) * r[0], n[1] + r[1]];
  }
  computeMovement() {
    const {
      offset: e,
      lastOffset: n
    } = this.state;
    this.state.movement = [e[0] / n[0], e[1] - n[1]];
  }
  axisIntent() {
    const e = this.state, [n, r] = e._movement;
    if (!e.axis) {
      const a = Math.abs(n) * PJ - Math.abs(r);
      a < 0 ? e.axis = "angle" : a > 0 && (e.axis = "scale");
    }
  }
  restrictToAxis(e) {
    this.config.lockDirection && (this.state.axis === "scale" ? e[1] = 0 : this.state.axis === "angle" && (e[0] = 0));
  }
  cancel() {
    const e = this.state;
    e.canceled || setTimeout(() => {
      e.canceled = !0, e._active = !1, this.compute(), this.emit();
    }, 0);
  }
  touchStart(e) {
    this.ctrl.setEventIds(e);
    const n = this.state, r = this.ctrl.touchIds;
    if (n._active && n._touchIds.every((s) => r.has(s)) || r.size < 2)
      return;
    this.start(e), n._touchIds = Array.from(r).slice(0, 2);
    const a = aD(e, n._touchIds);
    a && this.pinchStart(e, a);
  }
  pointerStart(e) {
    if (e.buttons != null && e.buttons % 2 !== 1)
      return;
    this.ctrl.setEventIds(e), e.target.setPointerCapture(e.pointerId);
    const n = this.state, r = n._pointerEvents, a = this.ctrl.pointerIds;
    if (n._active && Array.from(r.keys()).every((c) => a.has(c)) || (r.size < 2 && r.set(e.pointerId, e), n._pointerEvents.size < 2))
      return;
    this.start(e);
    const s = aP(...Array.from(r.values()));
    s && this.pinchStart(e, s);
  }
  pinchStart(e, n) {
    const r = this.state;
    r.origin = n.origin, this.computeValues([n.distance, n.angle]), this.computeInitial(), this.compute(e), this.emit();
  }
  touchMove(e) {
    if (!this.state._active)
      return;
    const n = aD(e, this.state._touchIds);
    n && this.pinchMove(e, n);
  }
  pointerMove(e) {
    const n = this.state._pointerEvents;
    if (n.has(e.pointerId) && n.set(e.pointerId, e), !this.state._active)
      return;
    const r = aP(...Array.from(n.values()));
    r && this.pinchMove(e, r);
  }
  pinchMove(e, n) {
    const r = this.state, a = r._values[1], s = n.angle - a;
    let c = 0;
    Math.abs(s) > 270 && (c += Math.sign(s)), this.computeValues([n.distance, n.angle - 360 * c]), r.origin = n.origin, r.turns = c, r._movement = [r._values[0] / r._initial[0] - 1, r._values[1] - r._initial[1]], this.compute(e), this.emit();
  }
  touchEnd(e) {
    this.ctrl.setEventIds(e), this.state._active && this.state._touchIds.some((n) => !this.ctrl.touchIds.has(n)) && (this.state._active = !1, this.compute(e), this.emit());
  }
  pointerEnd(e) {
    const n = this.state;
    this.ctrl.setEventIds(e);
    try {
      e.target.releasePointerCapture(e.pointerId);
    } catch {
    }
    n._pointerEvents.has(e.pointerId) && n._pointerEvents.delete(e.pointerId), n._active && n._pointerEvents.size < 2 && (n._active = !1, this.compute(e), this.emit());
  }
  gestureStart(e) {
    e.cancelable && e.preventDefault();
    const n = this.state;
    n._active || (this.start(e), this.computeValues([e.scale, e.rotation]), n.origin = [e.clientX, e.clientY], this.compute(e), this.emit());
  }
  gestureMove(e) {
    if (e.cancelable && e.preventDefault(), !this.state._active)
      return;
    const n = this.state;
    this.computeValues([e.scale, e.rotation]), n.origin = [e.clientX, e.clientY];
    const r = n._movement;
    n._movement = [e.scale - 1, e.rotation], n._delta = Eo.sub(n._movement, r), this.compute(e), this.emit();
  }
  gestureEnd(e) {
    this.state._active && (this.state._active = !1, this.compute(e), this.emit());
  }
  wheel(e) {
    const n = this.config.modifierKey;
    n && !e[n] || (this.state._active ? this.wheelChange(e) : this.wheelStart(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this)));
  }
  wheelStart(e) {
    this.start(e), this.wheelChange(e);
  }
  wheelChange(e) {
    "uv" in e || (e.cancelable && e.preventDefault(), {}.NODE_ENV === "development" && !e.defaultPrevented && console.warn("[@use-gesture]: To properly support zoom on trackpads, try using the `target` option.\n\nThis message will only appear in development mode."));
    const r = this.state;
    r._delta = [-ij(e)[1] / IJ * r.offset[0], 0], Eo.addTo(r._movement, r._delta), aj(r), this.state.origin = [e.clientX, e.clientY], this.compute(e), this.emit();
  }
  wheelEnd() {
    this.state._active && (this.state._active = !1, this.compute(), this.emit());
  }
  bind(e) {
    const n = this.config.device;
    n && (e(n, "start", this[n + "Start"].bind(this)), e(n, "change", this[n + "Move"].bind(this)), e(n, "end", this[n + "End"].bind(this)), e(n, "cancel", this[n + "End"].bind(this)), e("lostPointerCapture", "", this[n + "End"].bind(this))), this.config.pinchOnWheel && e("wheel", "", this.wheel.bind(this), {
      passive: !1
    });
  }
}
const $J = Jr(Jr({}, LI), {}, {
  device(t, e, {
    shared: n,
    pointer: {
      touch: r = !1
    } = {}
  }) {
    if (n.target && !Vs.touch && Vs.gesture)
      return "gesture";
    if (Vs.touch && r)
      return "touch";
    if (Vs.touchscreen) {
      if (Vs.pointer)
        return "pointer";
      if (Vs.touch)
        return "touch";
    }
  },
  bounds(t, e, {
    scaleBounds: n = {},
    angleBounds: r = {}
  }) {
    const a = (c) => {
      const f = cD(Ox(n, c), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [f.min, f.max];
    }, s = (c) => {
      const f = cD(Ox(r, c), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [f.min, f.max];
    };
    return typeof n != "function" && typeof r != "function" ? [a(), s()] : (c) => [a(c), s(c)];
  },
  threshold(t, e, n) {
    return this.lockDirection = n.axis === "lock", Eo.toVector(t, this.lockDirection ? [0.1, 3] : 0);
  },
  modifierKey(t) {
    return t === void 0 ? "ctrlKey" : t;
  },
  pinchOnWheel(t = !0) {
    return t;
  }
});
Jr(Jr({}, Eb), {}, {
  mouseOnly: (t = !0) => t
});
class MJ extends gJ {
  constructor(...e) {
    super(...e), Ho(this, "ingKey", "wheeling");
  }
  wheel(e) {
    this.state._active || this.start(e), this.wheelChange(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(e) {
    const n = this.state;
    n._delta = ij(e), Eo.addTo(n._movement, n._delta), aj(n), this.compute(e), this.emit();
  }
  wheelEnd() {
    this.state._active && (this.state._active = !1, this.compute(), this.emit());
  }
  bind(e) {
    e("wheel", "", this.wheel.bind(this));
  }
}
const AJ = Eb;
Jr(Jr({}, Eb), {}, {
  mouseOnly: (t = !0) => t
});
const jI = /* @__PURE__ */ new Map(), sP = /* @__PURE__ */ new Map();
function OJ(t) {
  jI.set(t.key, t.engine), sP.set(t.key, t.resolver);
}
const DJ = {
  key: "pinch",
  engine: RJ,
  resolver: $J
}, NJ = {
  key: "wheel",
  engine: MJ,
  resolver: AJ
};
function LJ(t, e) {
  if (t == null)
    return {};
  var n = {}, r = Object.keys(t), a, s;
  for (s = 0; s < r.length; s++)
    a = r[s], !(e.indexOf(a) >= 0) && (n[a] = t[a]);
  return n;
}
function jJ(t, e) {
  if (t == null)
    return {};
  var n = LJ(t, e), r, a;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(t);
    for (a = 0; a < s.length; a++)
      r = s[a], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]);
  }
  return n;
}
const zJ = {
  target(t) {
    if (t)
      return () => "current" in t ? t.current : t;
  },
  enabled(t = !0) {
    return t;
  },
  window(t = Vs.isBrowser ? window : void 0) {
    return t;
  },
  eventOptions({
    passive: t = !0,
    capture: e = !1
  } = {}) {
    return {
      passive: t,
      capture: e
    };
  },
  transform(t) {
    return t;
  }
}, UJ = ["target", "eventOptions", "window", "enabled", "transform"];
function ux(t = {}, e) {
  const n = {};
  for (const [r, a] of Object.entries(e))
    switch (typeof a) {
      case "function":
        if ({}.NODE_ENV === "development") {
          const s = a.call(n, t[r], r, t);
          Number.isNaN(s) || (n[r] = s);
        } else
          n[r] = a.call(n, t[r], r, t);
        break;
      case "object":
        n[r] = ux(t[r], a);
        break;
      case "boolean":
        a && (n[r] = t[r]);
        break;
    }
  return n;
}
function BJ(t, e, n = {}) {
  const r = t, {
    target: a,
    eventOptions: s,
    window: c,
    enabled: f,
    transform: p
  } = r, g = jJ(r, UJ);
  if (n.shared = ux({
    target: a,
    eventOptions: s,
    window: c,
    enabled: f,
    transform: p
  }, zJ), e) {
    const y = sP.get(e);
    n[e] = ux(Jr({
      shared: n.shared
    }, g), y);
  } else
    for (const y in g) {
      const v = sP.get(y);
      if (v)
        n[y] = ux(Jr({
          shared: n.shared
        }, g[y]), v);
      else if ({}.NODE_ENV === "development" && !["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(y)) {
        if (y === "domTarget")
          throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
        console.warn(`[@use-gesture]: Unknown config key \`${y}\` was used. Please read the documentation for further information.`);
      }
    }
  return n;
}
class sj {
  constructor(e, n) {
    Ho(this, "_listeners", /* @__PURE__ */ new Set()), this._ctrl = e, this._gestureKey = n;
  }
  add(e, n, r, a, s) {
    const c = this._listeners, f = aJ(n, r), p = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}, g = Jr(Jr({}, p), s);
    e.addEventListener(f, a, g);
    const y = () => {
      e.removeEventListener(f, a, g), c.delete(y);
    };
    return c.add(y), y;
  }
  clean() {
    this._listeners.forEach((e) => e()), this._listeners.clear();
  }
}
class FJ {
  constructor() {
    Ho(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(e, n, r = 140, ...a) {
    this.remove(e), this._timeouts.set(e, window.setTimeout(n, r, ...a));
  }
  remove(e) {
    const n = this._timeouts.get(e);
    n && window.clearTimeout(n);
  }
  clean() {
    this._timeouts.forEach((e) => void window.clearTimeout(e)), this._timeouts.clear();
  }
}
class HJ {
  constructor(e) {
    Ho(this, "gestures", /* @__PURE__ */ new Set()), Ho(this, "_targetEventStore", new sj(this)), Ho(this, "gestureEventStores", {}), Ho(this, "gestureTimeoutStores", {}), Ho(this, "handlers", {}), Ho(this, "config", {}), Ho(this, "pointerIds", /* @__PURE__ */ new Set()), Ho(this, "touchIds", /* @__PURE__ */ new Set()), Ho(this, "state", {
      shared: {
        shiftKey: !1,
        metaKey: !1,
        ctrlKey: !1,
        altKey: !1
      }
    }), VJ(this, e);
  }
  setEventIds(e) {
    if (rj(e))
      return this.touchIds = new Set(cJ(e)), this.touchIds;
    if ("pointerId" in e)
      return e.type === "pointerup" || e.type === "pointercancel" ? this.pointerIds.delete(e.pointerId) : e.type === "pointerdown" && this.pointerIds.add(e.pointerId), this.pointerIds;
  }
  applyHandlers(e, n) {
    this.handlers = e, this.nativeHandlers = n;
  }
  applyConfig(e, n) {
    this.config = BJ(e, n, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const e of this.gestures)
      this.gestureEventStores[e].clean(), this.gestureTimeoutStores[e].clean();
  }
  effect() {
    return this.config.shared.target && this.bind(), () => this._targetEventStore.clean();
  }
  bind(...e) {
    const n = this.config.shared, r = {};
    let a;
    if (!(n.target && (a = n.target(), !a))) {
      if (n.enabled) {
        for (const c of this.gestures) {
          const f = this.config[c], p = hD(r, f.eventOptions, !!a);
          if (f.enabled) {
            const g = jI.get(c);
            new g(this, e, c).bind(p);
          }
        }
        const s = hD(r, n.eventOptions, !!a);
        for (const c in this.nativeHandlers)
          s(c, "", (f) => this.nativeHandlers[c](Jr(Jr({}, this.state.shared), {}, {
            event: f,
            args: e
          })), void 0, !0);
      }
      for (const s in r)
        r[s] = fJ(...r[s]);
      if (!a)
        return r;
      for (const s in r) {
        const {
          device: c,
          capture: f,
          passive: p
        } = oJ(s);
        this._targetEventStore.add(a, c, "", r[s], {
          capture: f,
          passive: p
        });
      }
    }
  }
}
function $g(t, e) {
  t.gestures.add(e), t.gestureEventStores[e] = new sj(t, e), t.gestureTimeoutStores[e] = new FJ();
}
function VJ(t, e) {
  e.drag && $g(t, "drag"), e.wheel && $g(t, "wheel"), e.scroll && $g(t, "scroll"), e.move && $g(t, "move"), e.pinch && $g(t, "pinch"), e.hover && $g(t, "hover");
}
const hD = (t, e, n) => (r, a, s, c = {}, f = !1) => {
  var p, g;
  const y = (p = c.capture) !== null && p !== void 0 ? p : e.capture, v = (g = c.passive) !== null && g !== void 0 ? g : e.passive;
  let S = f ? r : rJ(r, a, y);
  n && v && (S += "Passive"), t[S] = t[S] || [], t[S].push(s);
}, YJ = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function KJ(t) {
  const e = {}, n = {}, r = /* @__PURE__ */ new Set();
  for (let a in t)
    YJ.test(a) ? (r.add(RegExp.lastMatch), n[a] = t[a]) : e[a] = t[a];
  return [n, e, r];
}
function Mg(t, e, n, r, a, s) {
  if (!t.has(n))
    return;
  if (!jI.has(r)) {
    ({}).NODE_ENV === "development" && console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${r}\` gesture but isn't properly configured.

Please add \`${r}Action\` when creating your handler.`);
    return;
  }
  const c = n + "Start", f = n + "End", p = (g) => {
    let y;
    return g.first && c in e && e[c](g), n in e && (y = e[n](g)), g.last && f in e && e[f](g), y;
  };
  a[r] = p, s[r] = s[r] || {};
}
function WJ(t, e) {
  const [n, r, a] = KJ(t), s = {};
  return Mg(a, n, "onDrag", "drag", s, e), Mg(a, n, "onWheel", "wheel", s, e), Mg(a, n, "onScroll", "scroll", s, e), Mg(a, n, "onPinch", "pinch", s, e), Mg(a, n, "onMove", "move", s, e), Mg(a, n, "onHover", "hover", s, e), {
    handlers: s,
    config: e,
    nativeHandlers: r
  };
}
function GJ(t, e = {}, n, r) {
  const a = It.useMemo(() => new HJ(t), []);
  if (a.applyHandlers(t, r), a.applyConfig(e, n), It.useEffect(a.effect.bind(a)), It.useEffect(() => a.clean.bind(a), []), e.target === void 0)
    return a.bind.bind(a);
}
function XJ(t) {
  return t.forEach(OJ), function(n, r) {
    const {
      handlers: a,
      nativeHandlers: s,
      config: c
    } = WJ(n, r || {});
    return GJ(a, c, void 0, s);
  };
}
const gD = 10, qJ = /Mac|iPod|iPhone|iPad/.test(
  typeof window > "u" ? "node" : window.navigator.platform
);
function lj(t) {
  let { deltaY: e, deltaX: n } = t, r = 0;
  if (t.ctrlKey || t.altKey || t.metaKey) {
    const a = Math.sign(t.deltaY), s = Math.abs(t.deltaY);
    let c = e;
    s > gD && (c = gD * a), r = c / 100;
  } else
    t.shiftKey && !qJ && (n = e, e = 0);
  return { x: -n, y: -e, z: -r };
}
const QJ = XJ([NJ, DJ]);
let Ag;
const ZJ = (t) => Ag === void 0 ? (Ag = t, !1) : t - Ag > 120 && t - Ag < 160 ? (Ag = t, !0) : (Ag = t, !1);
function JJ(t) {
  const e = Ge(), n = k.useMemo(() => {
    const r = ({ event: p }) => {
      if (ZJ(Date.now()))
        return;
      if (e.editingId) {
        const v = e.getShapeById(e.editingId);
        if (v && e.getShapeUtil(v).canScroll(v) && e.getPageBoundsById(e.editingId)?.containsPoint(e.inputs.currentPagePoint))
          return;
      }
      Gn(p);
      const g = lj(p);
      if (g.x === 0 && g.y === 0)
        return;
      const y = {
        type: "wheel",
        name: "wheel",
        delta: g,
        shiftKey: p.shiftKey,
        altKey: p.altKey,
        ctrlKey: p.metaKey || p.ctrlKey
      };
      e.dispatch(y);
    }, a = new O();
    return {
      onWheel: r,
      onPinchStart: (p) => {
        const g = t.current, { event: y, origin: v } = p;
        y instanceof WheelEvent || (y.target === g || g?.contains(y.target)) && (a.x = v[0], a.y = v[1], e.dispatch({
          type: "pinch",
          name: "pinch_start",
          point: { x: v[0], y: v[1], z: e.camera.z },
          delta: { x: 0, y: 0 },
          shiftKey: y.shiftKey,
          altKey: y.altKey,
          ctrlKey: y.metaKey || y.ctrlKey
        }));
      },
      onPinchEnd: (p) => {
        const g = t.current, { event: y, origin: v, offset: S } = p;
        if (y instanceof WheelEvent || !(y.target === g || g?.contains(y.target)))
          return;
        const x = S[0];
        requestAnimationFrame(() => {
          e.dispatch({
            type: "pinch",
            name: "pinch_end",
            point: { x: v[0], y: v[1], z: x },
            delta: { x: v[0], y: v[1] },
            shiftKey: y.shiftKey,
            altKey: y.altKey,
            ctrlKey: y.metaKey || y.ctrlKey
          });
        });
      },
      onPinch: (p) => {
        const g = t.current, { event: y, origin: v, offset: S } = p, x = S[0];
        if (y instanceof WheelEvent || !(y.target === g || g?.contains(y.target)))
          return;
        const _ = v[0] - a.x, T = v[1] - a.y;
        a.x = v[0], a.y = v[1], e.dispatch({
          type: "pinch",
          name: "pinch",
          point: { x: v[0], y: v[1], z: x },
          delta: { x: _, y: T },
          shiftKey: y.shiftKey,
          altKey: y.altKey,
          ctrlKey: y.metaKey || y.ctrlKey
        });
      }
    };
  }, [e, t]);
  QJ(n, {
    target: t,
    eventOptions: { passive: !1 },
    pinch: {
      from: () => [e.camera.z, 0],
      // Return the camera z to use when pinch starts
      scaleBounds: () => ({ from: e.camera.z, max: 8, min: 0.05 })
    }
  });
}
function Ry(t, e, n) {
  const r = t.getShapeById(e), s = t.getShapeUtil(r).handles(r);
  return { shape: r, handle: s.find((c) => c.id === n) };
}
function eee(t, e) {
  const n = Ge();
  return k.useMemo(() => {
    const r = (y) => {
      if (y.isKilled)
        return;
      const v = Ax(y.currentTarget);
      wb(v, y);
      const { shape: S, handle: x } = Ry(n, t, e);
      x && n.dispatch({
        type: "pointer",
        target: "handle",
        handle: x,
        shape: S,
        name: "pointer_down",
        ...Vi(y, n.getContainer())
      });
    };
    let a, s;
    return {
      onPointerDown: r,
      onPointerMove: (y) => {
        if (y.isKilled || y.clientX === a && y.clientY === s)
          return;
        a = y.clientX, s = y.clientY;
        const { shape: v, handle: S } = Ry(n, t, e);
        S && n.dispatch({
          type: "pointer",
          target: "handle",
          handle: S,
          shape: v,
          name: "pointer_move",
          ...Vi(y, n.getContainer())
        });
      },
      onPointerUp: (y) => {
        if (y.isKilled)
          return;
        const v = Ax(y.currentTarget);
        xb(v, y);
        const { shape: S, handle: x } = Ry(n, t, e);
        x && n.dispatch({
          type: "pointer",
          target: "handle",
          handle: x,
          shape: S,
          name: "pointer_up",
          ...Vi(y, n.getContainer())
        });
      },
      onPointerEnter: (y) => {
        if (y.isKilled)
          return;
        const { shape: v, handle: S } = Ry(n, t, e);
        S && n.dispatch({
          type: "pointer",
          target: "handle",
          handle: S,
          shape: v,
          name: "pointer_enter",
          ...Vi(y, n.getContainer())
        });
      },
      onPointerLeave: (y) => {
        if (y.isKilled)
          return;
        const { shape: v, handle: S } = Ry(n, t, e);
        S && n.dispatch({
          type: "pointer",
          target: "handle",
          handle: S,
          shape: v,
          name: "pointer_leave",
          ...Vi(y, n.getContainer())
        });
      }
    };
  }, [n, t, e]);
}
function zI(t) {
  const e = Ge();
  return un("isEditing", () => e.editingId === t, [e, t]);
}
const jy = 8, mD = (t, e, n) => new Promise((r, a) => {
  const s = jy * e * t, c = document.createElement("canvas");
  c.width = s, c.height = s;
  const f = c.getContext("2d");
  if (!f)
    throw new Error("No canvas");
  f.fillStyle = n ? "#212529" : "#f8f9fa", f.fillRect(0, 0, s, s), f.globalCompositeOperation = "destination-out", f.lineCap = "round", f.lineWidth = 1.25 * e * t;
  const p = 8 / 12, g = (y) => y * e * t;
  f.beginPath(), f.moveTo(g(p * 1), g(p * 3)), f.lineTo(g(p * 3), g(p * 1)), f.moveTo(g(p * 5), g(p * 7)), f.lineTo(g(p * 7), g(p * 5)), f.moveTo(g(p * 9), g(p * 11)), f.lineTo(g(p * 11), g(p * 9)), f.stroke(), c.toBlob((y) => {
    !y || fs.throwToBlob.value ? a() : r(y);
  });
}), vD = (t, e) => {
  const n = document.createElement("canvas");
  return n.width = t[0], n.height = t[1], e(n.getContext("2d")), n.toDataURL();
}, tee = () => {
  const t = [];
  for (let e = 1; e <= Math.ceil(Cp); e++) {
    const n = vD([1, 1], (a) => {
      a.fillStyle = "#e8e8e8", a.fillRect(0, 0, 1, 1);
    }), r = vD([1, 1], (a) => {
      a.fillStyle = "#2c3036", a.fillRect(0, 0, 1, 1);
    });
    t.push({
      zoom: e,
      url: n,
      darkMode: !1
    }), t.push({
      zoom: e,
      url: r,
      darkMode: !0
    });
  }
  return t;
}, nee = function() {
  const n = Ge().devicePixelRatio, [r, a] = k.useState(!1), s = k.useMemo(() => tee(), []), [c, f] = k.useState(s);
  return k.useEffect(() => {
    const g = [];
    for (let v = 1; v <= Math.ceil(Cp); v++)
      g.push(
        mD(n, v, !1).then((S) => ({
          zoom: v,
          url: URL.createObjectURL(S),
          darkMode: !1
        }))
      ), g.push(
        mD(n, v, !0).then((S) => ({
          zoom: v,
          url: URL.createObjectURL(S),
          darkMode: !0
        }))
      );
    let y = !1;
    return Promise.all(g).then((v) => {
      y || (f(v), a(!0));
    }), () => {
      y = !0, a(!1);
    };
  }, [n]), { context: /* @__PURE__ */ E.jsx("defs", { children: c.map((g) => {
    const y = g.zoom + (g.darkMode ? "_dark" : "_light");
    return /* @__PURE__ */ E.jsx(
      "pattern",
      {
        id: Rx[y],
        width: jy,
        height: jy,
        patternUnits: "userSpaceOnUse",
        children: /* @__PURE__ */ E.jsx("image", { href: g.url, width: jy, height: jy })
      },
      y
    );
  }) }), isReady: r };
}, js = 8 / 12;
function ree() {
  const t = document.createElement("div");
  return t.innerHTML = `
		<svg>
			<defs>
				<g>
					<pattern
						id="hash_pattern"
						width="8"
						height="8"
						patternUnits="userSpaceOnUse"
						strokeLinecap="round"
						stroke="white"
					>
						<line x1="${js * 1}" y1="${js * 3}" x2="${js * 3}" y2="${js * 1}" />
						<line x1="${js * 5}" y1="${js * 7}" x2="${js * 7}" y2="${js * 5}" />
						<line x1="${js * 9}" y1="${js * 11}" x2="${js * 11}" y2="${js * 9}" />
					</pattern>
					<mask id="hash_mask">
						<rect x="-100%" y="-100%" width="200%" height="200%" fill="url(#hash_pattern)" />
					</mask>
				</g>
			</defs>
		</svg>
	`, t.querySelectorAll("defs > *");
}
var cj = "Expected a function", yD = 0 / 0, iee = "[object Symbol]", oee = /^\s+|\s+$/g, aee = /^[-+]0x[0-9a-f]+$/i, see = /^0b[01]+$/i, lee = /^0o[0-7]+$/i, cee = parseInt, uee = typeof ca == "object" && ca && ca.Object === Object && ca, dee = typeof self == "object" && self && self.Object === Object && self, fee = uee || dee || Function("return this")(), pee = Object.prototype, hee = pee.toString, gee = Math.max, mee = Math.min, nk = function() {
  return fee.Date.now();
};
function vee(t, e, n) {
  var r, a, s, c, f, p, g = 0, y = !1, v = !1, S = !0;
  if (typeof t != "function")
    throw new TypeError(cj);
  e = bD(e) || 0, Dx(n) && (y = !!n.leading, v = "maxWait" in n, s = v ? gee(bD(n.maxWait) || 0, e) : s, S = "trailing" in n ? !!n.trailing : S);
  function x(F) {
    var K = r, X = a;
    return r = a = void 0, g = F, c = t.apply(X, K), c;
  }
  function _(F) {
    return g = F, f = setTimeout(D, e), y ? x(F) : c;
  }
  function T(F) {
    var K = F - p, X = F - g, se = e - K;
    return v ? mee(se, s - X) : se;
  }
  function I(F) {
    var K = F - p, X = F - g;
    return p === void 0 || K >= e || K < 0 || v && X >= s;
  }
  function D() {
    var F = nk();
    if (I(F))
      return N(F);
    f = setTimeout(D, T(F));
  }
  function N(F) {
    return f = void 0, S && r ? x(F) : (r = a = void 0, c);
  }
  function j() {
    f !== void 0 && clearTimeout(f), g = 0, r = p = a = f = void 0;
  }
  function L() {
    return f === void 0 ? c : N(nk());
  }
  function z() {
    var F = nk(), K = I(F);
    if (r = arguments, a = this, p = F, K) {
      if (f === void 0)
        return _(p);
      if (v)
        return f = setTimeout(D, e), x(p);
    }
    return f === void 0 && (f = setTimeout(D, e)), c;
  }
  return z.cancel = j, z.flush = L, z;
}
function yee(t, e, n) {
  var r = !0, a = !0;
  if (typeof t != "function")
    throw new TypeError(cj);
  return Dx(n) && (r = "leading" in n ? !!n.leading : r, a = "trailing" in n ? !!n.trailing : a), vee(t, e, {
    leading: r,
    maxWait: e,
    trailing: a
  });
}
function Dx(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function");
}
function bee(t) {
  return !!t && typeof t == "object";
}
function See(t) {
  return typeof t == "symbol" || bee(t) && hee.call(t) == iee;
}
function bD(t) {
  if (typeof t == "number")
    return t;
  if (See(t))
    return yD;
  if (Dx(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Dx(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = t.replace(oee, "");
  var n = see.test(t);
  return n || lee.test(t) ? cee(t.slice(2), n ? 2 : 8) : aee.test(t) ? yD : +t;
}
var wee = yee;
const xee = /* @__PURE__ */ Np(wee);
function Eee() {
  const t = Ge(), e = ga();
  k.useLayoutEffect(() => {
    const n = xee(
      () => {
        t.updateViewportScreenBounds();
      },
      200,
      { trailing: !0 }
    ), r = new ResizeObserver((a) => {
      a[0].contentRect && n();
    });
    return e && r.observe(e), n(), () => {
      r.disconnect();
    };
  }, [t, e]);
}
const $y = (t, e, n) => (r) => {
  if (t.pageState.editingId === e && (r.isKilled = !0), r.isKilled)
    return;
  switch (n) {
    case "pointer_down": {
      if (r.button !== 0 && r.button !== 2)
        return;
      wb(r.currentTarget, r);
      break;
    }
    case "pointer_up": {
      xb(r.currentTarget, r);
      break;
    }
  }
  const a = t.getShapeById(e);
  if (!a) {
    console.error("Shape not found", e);
    return;
  }
  t.dispatch({
    type: "pointer",
    target: "shape",
    shape: a,
    name: n,
    ...Vi(r, t.getContainer())
  });
};
function Cee(t) {
  const e = Ge();
  return It.useMemo(() => {
    function n(p) {
      p.isKilled = !0, Gn(p);
    }
    function r(p) {
      p.isKilled = !0, Gn(p);
    }
    const a = $y(e, t, "pointer_move");
    let s, c;
    function f(p) {
      if (!p.isKilled && !(p.clientX === s && p.clientY === c))
        return s = p.clientX, c = p.clientY, a(p);
    }
    return {
      onPointerDown: $y(e, t, "pointer_down"),
      onPointerUp: $y(e, t, "pointer_up"),
      onPointerEnter: $y(e, t, "pointer_enter"),
      onPointerLeave: $y(e, t, "pointer_leave"),
      onPointerMove: f,
      onTouchStart: n,
      onTouchEnd: r
    };
  }, [e, t]);
}
function _ee() {
  const t = Ge(), e = ga();
  k.useEffect(() => {
    const n = (s) => e.style.setProperty("--rs-zoom", s.toString()), r = cI(n, 100), a = new bb("useZoomCss", () => {
      t.shapeIds.size < 300 ? n(t.zoomLevel) : r(t.zoomLevel);
    });
    return a.attach(), a.execute(), () => {
      a.detach();
    };
  }, [t, e]);
}
const ps = k.memo(function({ d: e, color: n, fill: r }) {
  switch (r) {
    case "none":
      return /* @__PURE__ */ E.jsx("path", { className: "rs-hitarea-stroke", fill: "none", d: e });
    case "solid":
      return /* @__PURE__ */ E.jsx("path", { className: "rs-hitarea-fill-solid", fill: `var(--palette-${n}-semi)`, d: e });
    case "semi":
      return /* @__PURE__ */ E.jsx("path", { className: "rs-hitarea-fill-solid", fill: "var(--palette-solid)", d: e });
    case "pattern":
      return /* @__PURE__ */ E.jsx(Tee, { color: n, fill: r, d: e });
  }
}), Tee = dn(function({ d: e, color: n }) {
  const r = Ge(), a = Math.ceil(r.zoomLevel), s = r.zoomLevel <= 0.18, c = r.userDocumentSettings.isDarkMode;
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx("path", { className: "rs-hitarea-fill-solid", fill: `var(--palette-${n}-pattern)`, d: e }),
    /* @__PURE__ */ E.jsx(
      "path",
      {
        fill: s ? `var(--palette-${n}-semi)` : `url(#${Rx[a + (c ? "_dark" : "_light")]})`,
        d: e
      }
    )
  ] });
});
function $c({
  d: t,
  color: e,
  fill: n,
  colors: r
}) {
  if (n === "none")
    return;
  if (n === "pattern") {
    const s = document.createElementNS("http://www.w3.org/2000/svg", "g"), c = document.createElementNS("http://www.w3.org/2000/svg", "path");
    c.setAttribute("d", t), c.setAttribute("fill", r.background);
    const f = document.createElementNS("http://www.w3.org/2000/svg", "path");
    return f.setAttribute("d", t), f.setAttribute("mask", "url(#hash_mask)"), f.setAttribute("fill", r.pattern[e]), s.appendChild(c), s.appendChild(f), s;
  }
  const a = document.createElementNS("http://www.w3.org/2000/svg", "path");
  switch (a.setAttribute("d", t), n) {
    case "semi": {
      a.setAttribute("fill", r.solid);
      break;
    }
    case "solid": {
      a.setAttribute("fill", r.semi[e]);
      break;
    }
  }
  return a;
}
function lf(t, e) {
  if (e) {
    const n = document.createElementNS("http://www.w3.org/2000/svg", "g");
    return n.appendChild(e), n.appendChild(t), n;
  } else
    return t;
}
function Ks(t, e, n = {}) {
  const {
    closed: r = !1,
    snap: a = 1,
    start: s = "outset",
    end: c = "outset",
    lengthRatio: f = 2,
    style: p = "dashed"
  } = n;
  let g = 0, y = 0, v = 1, S = 0, x = 0;
  switch (p) {
    case "dashed": {
      v = 1, g = Math.min(e * f, t / 4);
      break;
    }
    case "dotted": {
      v = 100, g = e / v;
      break;
    }
    default:
      return {
        strokeDasharray: "none",
        strokeDashoffset: "none"
      };
  }
  return r || (s === "outset" ? (t += g / 2, x += g / 2) : s === "skip" && (t -= g, x -= g), c === "outset" ? t += g / 2 : c === "skip" && (t -= g)), y = Math.floor(t / g / (2 * v)), y -= y % a, y < 3 && p === "dashed" ? t / e < 5 ? (g = t, y = 1, S = 0) : (g = t * 0.333, S = t * 0.333) : (y = Math.max(y, 3), g = t / y / (2 * v), r ? (x = g / 2, S = (t - y * g) / y) : S = (t - y * g) / Math.max(1, y - 1)), {
    strokeDasharray: [g, S].join(" "),
    strokeDashoffset: x.toString()
  };
}
const Tc = (t) => t.stopPropagation();
function h1(t, e) {
  const { padding: n = 0 } = e, r = document.createElementNS("http://www.w3.org/2000/svg", "text");
  r.setAttribute("font-size", e.fontSize + "px"), r.setAttribute("font-family", e.fontFamily), r.setAttribute("font-style", e.fontStyle), r.setAttribute("font-weight", e.fontWeight), r.setAttribute("line-height", e.lineHeight * e.fontSize + "px"), r.setAttribute("dominant-baseline", "mathematical"), r.setAttribute("alignment-baseline", "mathematical");
  const a = e.lines.map((g) => g.trim()), s = [], c = a.length * (e.lineHeight * e.fontSize), f = (Math.ceil(e.height) - c) / 2, p = n;
  for (let g = 0; g < a.length; g++) {
    const y = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    y.setAttribute("alignment-baseline", "mathematical"), y.textContent = OZ(a[g]), a.length > 1 && g < a.length - 1 && (y.textContent += `
`), y.setAttribute(
      "y",
      f + e.fontSize / 2 + e.lineHeight * e.fontSize * g + "px"
    ), r.appendChild(y), s.push(y);
  }
  switch (e.stroke && e.strokeWidth && (r.setAttribute("stroke", e.stroke), r.setAttribute("stroke-width", e.strokeWidth + "px")), e.fill && r.setAttribute("fill", e.fill), e.textAlign) {
    case "middle": {
      r.setAttribute("text-align", "center"), r.setAttribute("text-anchor", "start"), s.forEach((g, y) => {
        const v = t.textMeasure.measureText({
          ...Yi,
          text: a[y].trim(),
          fontFamily: e.fontFamily,
          fontSize: e.fontSize,
          width: "fit-content",
          padding: `${n}px`
        }).w;
        g.setAttribute("x", p + (e.width - v) / 2 + "");
      });
      break;
    }
    case "end": {
      r.setAttribute("text-align", "right"), r.setAttribute("text-anchor", "start"), s.forEach((g, y) => {
        const v = t.textMeasure.measureText({
          ...Yi,
          text: a[y].trim(),
          fontFamily: e.fontFamily,
          fontSize: e.fontSize,
          width: "fit-content",
          padding: `${n}px`
        }).w;
        g.setAttribute("x", p + e.width - v + "");
      });
      break;
    }
    default:
      r.setAttribute("text-align", "left"), r.setAttribute("text-anchor", "start"), s.forEach((g) => g.setAttribute("x", p + ""));
  }
  return r;
}
var kee = Object.defineProperty, Pee = Object.getOwnPropertyDescriptor, UI = (t, e, n, r) => {
  for (var a = r > 1 ? void 0 : r ? Pee(e, n) : e, s = t.length - 1, c; s >= 0; s--)
    (c = t[s]) && (a = (r ? c(e, n, a) : c(a)) || a);
  return r && a && kee(e, n, a), a;
};
const Iee = new lm(), Ree = new lm();
class Mc {
  constructor(e, n) {
    this.app = e, this.type = n;
  }
  is(e) {
    return e.type === this.type;
  }
  /**
   * Whether the shape can be scrolled while editing.
   *
   * @public
   */
  canScroll = () => !1;
  /**
   * Whether the shape can be bound to by an arrow.
   *
   * @public
   */
  canUnmount = () => !0;
  /**
   * Whether the shape can be bound to by an arrow.
   *
   * @param _otherShape - The other shape attempting to bind to this shape.
   * @public
   */
  canBind = (e, n) => !0;
  /**
   * Whether the shape can be double clicked to edit.
   *
   * @public
   */
  canEdit = () => !1;
  /**
   * Whether the shape can be resized.
   *
   * @public
   */
  canResize = () => !0;
  /**
   * Bounds of the shape to edit.
   *
   * Note: this could be a text area within a shape for example arrow labels.
   *
   * @public
   */
  getEditingBounds = (e) => this.bounds(e);
  /**
   * Whether the shape's outline is closed.
   *
   * @public
   */
  isClosed = () => !0;
  /**
   * Whether the shape should hide its resize handles when selected.
   *
   * @public
   */
  hideResizeHandles = () => !1;
  /**
   * Whether the shape should hide its resize handles when selected.
   *
   * @public
   */
  hideRotateHandle = () => !1;
  /**
   * Whether the shape should hide its selection bounds background when selected.
   *
   * @public
   */
  hideSelectionBoundsBg = () => !1;
  /**
   * Whether the shape should hide its selection bounds foreground when selected.
   *
   * @public
   */
  hideSelectionBoundsFg = () => !1;
  /**
   * Whether the shape's aspect ratio is locked.
   *
   * @public
   */
  isAspectRatioLocked = () => !1;
  get handlesCache() {
    return this.app.store.createComputedCache("handles:" + this.type, (e) => this.getHandles(e));
  }
  /**
   * Get the cached handles (this should not be overridden!)
   *
   * @param shape - The shape.
   * @public
   */
  handles(e) {
    return this.getHandles ? this.handlesCache.get(e.id) ?? Ys : Ys;
  }
  get boundsCache() {
    return this.app.store.createComputedCache("bounds:" + this.type, (e) => this.getBounds(e));
  }
  /**
   * Get the cached bounds for the shape.
   *
   * @param shape - The shape.
   * @public
   */
  bounds(e) {
    const n = this.boundsCache.get(e.id) ?? new ot();
    return n.width === 0 || n.height === 0 ? new ot(n.x, n.y, Math.max(n.width, 1), Math.max(n.height, 1)) : n;
  }
  /**
   * Get the cached transform. Do not override this method!
   *
   * @param shape - The shape.
   * @public
   */
  transform(e) {
    return Ree.get(
      e,
      (n) => De.Compose(De.Translate(n.x, n.y), De.Rotate(n.rotation))
    );
  }
  /**
   * Get the cached point. Do not override this method!
   *
   * @param shape - The shape.
   * @public
   */
  point(e) {
    return Iee.get(e, (n) => ({ x: n.x, y: n.y }));
  }
  get outlineCache() {
    return this.app.store.createComputedCache("outline:" + this.type, (e) => this.getOutline(e));
  }
  /**
   * Get the shape's outline. Do not override this method!
   *
   * @param shape - The shape.
   * @public
   */
  outline(e) {
    return this.outlineCache.get(e.id) ?? Ys;
  }
  /**
   * Get the shape's snap points.
   *
   * @param shape - The shape.
   * @public
   */
  snapPoints(e) {
    return this.bounds(e).snapPoints;
  }
  /**
   * Get the shape's cached center.
   *
   * @param shape - The shape.
   * @public
   */
  center(e) {
    return this.getCenter(e);
  }
  /**
   * Get whether the shape can receive children of a given type.
   *
   * @param type - The shape type.
   * @public
   */
  canReceiveNewChildrenOfType(e) {
    return !1;
  }
  /**
   * Get whether the shape can receive children of a given type.
   *
   * @param shape - The shape type.
   * @param shapes - The shapes that are being dropped.
   * @public
   */
  canDropShapes(e, n) {
    return !1;
  }
  /**
   * Get whether a point intersects the shape.
   *
   * @param shape - The shape.
   * @param point - The point to test.
   *
   * @public
   * @returns Whether the point intersects the shape.
   */
  hitTestPoint(e, n) {
    return this.bounds(e).containsPoint(n);
  }
  /**
   * Get whether a point intersects the shape.
   *
   * @param shape - The shape.
   * @param A - The line segment's first point.
   * @param B - The line segment's second point.
   *
   * @public
   * @returns Whether the line segment intersects the shape.
   */
  hitTestLineSegment(e, n, r) {
    const a = this.outline(e);
    for (let s = 0; s < a.length; s++) {
      const c = a[s], f = a[(s + 1) % a.length];
      if (Qd(n, r, c, f))
        return !0;
    }
    return !1;
  }
  //  Events
  /**
   * A callback called just before a shape is created. This method
   * provides a last chance to modify the created shape.
   *
   * @example
   * ```ts
   * onBeforeUpdate = (prev, next) => {
   *   if (prev.x === next.x) {
   *   return { ...next, x: next.x + 1 }
   * }
   * ```
   *
   * @param prev - The previous shape.
   * @param next - The next shape.
   *
   * @returns The next shape or void.
   * @public
   */
  onBeforeCreate;
  /**
   * A callback called just before a shape is updated. This method
   * provides a last chance to modify the updated shape.
   *
   * @example
   * ```ts
   * onBeforeUpdate = (prev, next) => {
   *   if (prev.x === next.x) {
   *   return { ...next, x: next.x + 1 }
   * }
   * ```
   *
   * @param prev - The previous shape.
   * @param next - The next shape.
   *
   * @returns The next shape or void.
   * @public
   */
  onBeforeUpdate;
  onDragShapesOver;
  onDragShapesOut;
  onDropShapesOver;
  onResizeStart;
  onResize;
  onResizeEnd;
  onTranslateStart;
  onTranslate;
  onTranslateEnd;
  onRotateStart;
  onRotateEnd;
  onRotate;
  onHandleChange;
  onBindingChange;
  onChildrenChange;
  onDoubleClickHandle;
  onDoubleClickEdge;
  onDoubleClick;
  onClick;
  onEditEnd;
}
UI([
  pt
], Mc.prototype, "handlesCache", 1);
UI([
  pt
], Mc.prototype, "boundsCache", 1);
UI([
  pt
], Mc.prototype, "outlineCache", 1);
function $ee(t, e, n) {
  const r = e === "end" ? t.end.point : t.start.point, a = e === "end" ? t.start.point : t.end.point, s = t.isStraight ? O.Dist(a, r) : Math.abs(t.bodyArc.length), c = Math.max(Math.min(s / 5, n * 3), n);
  let f;
  if (t.isStraight)
    f = O.Nudge(r, a, c);
  else {
    const p = Xq(r, c, t.handleArc.center, t.handleArc.radius);
    f = e === "end" ? t.handleArc.sweepFlag ? p[0] : p[1] : t.handleArc.sweepFlag ? p[1] : p[0];
  }
  return {
    point: r,
    int: f
  };
}
function Mee({ point: t, int: e }) {
  const n = O.RotWith(e, t, Yr / 6), r = O.RotWith(e, t, -Yr / 6);
  return `M ${n.x} ${n.y} L ${t.x} ${t.y} L ${r.x} ${r.y}`;
}
function Aee({ point: t, int: e }) {
  const n = O.RotWith(e, t, Yr / 6), r = O.RotWith(e, t, -Yr / 6);
  return `M ${n.x} ${n.y} L ${t.x} ${t.y} L ${r.x} ${r.y} Z`;
}
function Oee({ point: t, int: e }) {
  const n = O.Sub(e, t).div(2), r = O.Add(t, O.Rot(n, cr)), a = O.Sub(t, O.Rot(n, cr));
  return `M ${r.x} ${r.y} L ${e.x} ${e.y} L ${a.x} ${a.y} Z`;
}
function Dee({ point: t, int: e }) {
  const n = O.Lrp(t, e, 0.45), r = O.Dist(n, t);
  return `M ${n.x - r},${n.y}
  a ${r},${r} 0 1,0 ${r * 2},0
  a ${r},${r} 0 1,0 -${r * 2},0 `;
}
function Nee({ point: t, int: e }) {
  const n = O.Lrp(t, e, 0.75), r = O.RotWith(n, t, Yr / 4), a = O.RotWith(n, t, -Yr / 4), s = O.Lrp(r, a, 0.5);
  return s.add(O.Sub(s, t)), `M ${s.x} ${s.y} L ${r.x} ${r.y} ${t.x} ${t.y} L ${a.x} ${a.y} Z`;
}
function Lee({ int: t, point: e }) {
  const n = O.Lrp(e, t, 0.85), r = O.Sub(n, e).div(2), a = O.Add(e, O.Rot(r, cr)), s = O.Sub(e, O.Rot(r, cr)), c = O.Add(n, O.Rot(r, cr)), f = O.Sub(n, O.Rot(r, cr));
  return `M ${a.x} ${a.y} L ${c.x} ${c.y} L ${f.x} ${f.y} L ${s.x} ${s.y} Z`;
}
function jee({ int: t, point: e }) {
  const n = O.Sub(t, e).div(2), r = O.Add(e, O.Rot(n, cr)), a = O.Sub(e, O.Rot(n, cr));
  return `M ${r.x} ${r.y} L ${a.x} ${a.y}`;
}
function Og(t, e, n) {
  const r = e === "end" ? t.end.arrowhead : t.start.arrowhead;
  if (r === "none")
    return;
  const a = $ee(t, e, n);
  if (a) {
    switch (r) {
      case "bar":
        return jee(a);
      case "square":
        return Lee(a);
      case "diamond":
        return Nee(a);
      case "dot":
        return Dee(a);
      case "inverted":
        return Oee(a);
      case "arrow":
        return Mee(a);
      case "triangle":
        return Aee(a);
    }
    return "";
  }
}
function zee(t) {
  return Math.abs(t.props.bend) < 8;
}
function Nx(t, e) {
  if (e.type === "point")
    return;
  const n = t.getShapeById(e.boundShapeId), r = t.getShapeUtil(n), a = t.getPageTransform(n);
  return {
    shape: n,
    util: r,
    transform: a,
    isExact: e.isExact,
    didIntersect: !1
  };
}
function SD(t, e, n) {
  if (n.type === "point")
    return O.From(n);
  const r = t.getShapeById(n.boundShapeId);
  if (r) {
    const { point: a, size: s } = t.getBounds(r), c = O.Add(a, O.MulV(n.normalizedAnchor, s)), f = De.applyToPoint(t.getPageTransform(r), c);
    return De.applyToPoint(De.Inverse(e), f);
  } else
    return console.error("Expected a bound shape!"), new O(0, 0);
}
function Mu(t, e) {
  const n = t.getPageTransform(e), r = SD(t, n, e.props.start), a = SD(t, n, e.props.end);
  return { start: r, end: a };
}
function uj(t, e) {
  const { start: n, end: r, arrowheadStart: a, arrowheadEnd: s } = e.props, c = Mu(t, e), f = c.start.clone(), p = c.end.clone(), g = O.Med(f, p), y = O.Sub(p, f).uni(), v = Nx(t, n), S = Nx(t, r), x = t.getPageTransform(e);
  wD(
    p,
    // <-- will be mutated
    c.start,
    x,
    S
  ), wD(
    f,
    // <-- will be mutated
    c.end,
    x,
    v
  );
  let _ = _p;
  const T = v && S && v.shape === S.shape;
  v && S && !T && !v.isExact && !S.isExact && (S.didIntersect && !v.didIntersect ? v.util.isClosed(v.shape) && f.setTo(O.Nudge(p, f, _)) : S.didIntersect || S.util.isClosed(S.shape) && p.setTo(O.Nudge(f, p, _)));
  const I = O.Sub(p, f).uni(), D = !O.Equals(I, y);
  if (!T) {
    if (v && a !== "none" && !v.isExact) {
      const j = $x + t.getStrokeWidth(e.props.size) / 2 + ("size" in v.shape.props ? t.getStrokeWidth(v.shape.props.size) / 2 : 0);
      _ -= j, f.nudge(p, j * (D ? -1 : 1));
    }
    if (S && s !== "none" && !S.isExact) {
      const j = $x + t.getStrokeWidth(e.props.size) / 2 + ("size" in S.shape.props ? t.getStrokeWidth(S.shape.props.size) / 2 : 0);
      _ -= j, p.nudge(f, j * (D ? -1 : 1));
    }
  }
  v && S && (D ? p.setTo(O.Add(f, I.mul(-_))) : O.Dist(f, p) < _p / 2 && p.setTo(O.Add(f, I.mul(_p / 2)))), D ? g.setTo(O.Med(c.start, c.end)) : g.setTo(O.Med(f, p));
  const N = O.Dist(f, p);
  return {
    isStraight: !0,
    start: {
      handle: c.start,
      point: f,
      arrowhead: e.props.arrowheadStart
    },
    end: {
      handle: c.end,
      point: p,
      arrowhead: e.props.arrowheadEnd
    },
    middle: g,
    isValid: N > 0,
    length: N
  };
}
function wD(t, e, n, r) {
  if (r === void 0 || r.isExact)
    return;
  const a = De.applyToPoint(n, e), s = De.applyToPoint(n, t), c = De.applyToPoint(De.Inverse(r.transform), a), f = De.applyToPoint(De.Inverse(r.transform), s), p = r.util.isClosed(r.shape), y = (p ? Gq : kI)(c, f, r.util.outline(r.shape));
  let v;
  if (y !== null && (v = y.sort((_, T) => O.Dist(_, c) - O.Dist(T, c))[0] ?? (p ? void 0 : f)), v === void 0)
    return;
  const S = De.applyToPoint(r.transform, v), x = De.applyToPoint(De.Inverse(n), S);
  t.setTo(x), r.didIntersect = !0;
}
function Uee(t) {
  return dj(t.start.handle, t.end.handle);
}
function rk(t) {
  return dj(t.start.point, t.end.point);
}
function dj(t, e) {
  return `M${t.x},${t.y}L${e.x},${e.y}`;
}
function Bee(t, e, n = 0) {
  const { arrowheadEnd: r, arrowheadStart: a } = e.props, s = e.props.bend + n;
  if (Math.abs(s) > Math.abs(e.props.bend * lQ))
    return uj(t, e);
  const c = Mu(t, e), f = O.Med(c.start, c.end), p = O.Sub(c.end, c.start).uni(), g = O.Add(f, p.per().mul(-s)), y = Nx(t, e.props.start), v = Nx(t, e.props.end), S = c.start.clone(), x = c.end.clone(), _ = g.clone(), T = xD(S, x, _), I = t.getPageTransform(e);
  if (y && !y.isExact) {
    const z = De.applyToPoint(I, S), F = De.applyToPoint(I, x), K = De.applyToPoint(I, T.center), X = De.Inverse(y.transform), se = De.applyToPoint(X, z), ue = De.applyToPoint(X, F), pe = De.applyToPoint(X, K), Pe = y.util.isClosed(y.shape), ve = Pe ? YO : KO;
    let Y, le = ve(
      pe,
      T.radius,
      y.util.outline(y.shape)
    );
    if (le) {
      le = le.filter(
        (de) => +O.Clockwise(se, de, ue) === T.sweepFlag
      );
      const Re = O.Angle(T.center, g), he = O.Angle(T.center, c.start), te = hp(Re, he, 0.5);
      le.sort(
        (de, W) => Math.abs(Vd(te, pe.angle(de))) - Math.abs(Vd(te, pe.angle(W)))
      ), Y = le[0] ?? (Pe ? void 0 : se);
    } else
      Y = Pe ? void 0 : se;
    if (Y && (S.setTo(
      t.getPointInShapeSpace(e, De.applyToPoint(y.transform, Y))
    ), y.didIntersect = !0, a !== "none")) {
      const Re = $x + t.getStrokeWidth(e.props.size) / 2 + ("size" in y.shape.props ? t.getStrokeWidth(y.shape.props.size) / 2 : 0);
      S.setTo(
        vp(
          T.center.x,
          T.center.y,
          T.radius,
          hp(
            O.Angle(T.center, S),
            O.Angle(T.center, g),
            Re / Math.abs(Mw(T.center, T.radius, S, g))
          )
        )
      );
    }
  }
  if (v && !v.isExact) {
    const z = De.applyToPoint(I, S), F = De.applyToPoint(I, x), K = De.applyToPoint(I, T.center), X = De.Inverse(v.transform), se = De.applyToPoint(X, z), ue = De.applyToPoint(X, F), pe = De.applyToPoint(X, K), Pe = v.util.isClosed(v.shape), ve = Pe ? YO : KO, Y = O.Angle(T.center, g), le = O.Angle(T.center, c.end), Re = hp(Y, le, 0.5);
    let he, te = ve(
      pe,
      T.radius,
      v.util.outline(v.shape)
    );
    if (te ? (te = te.filter(
      (de) => +O.Clockwise(se, de, ue) === T.sweepFlag
    ), te.sort(
      (de, W) => Math.abs(Vd(Re, pe.angle(de))) - Math.abs(Vd(Re, pe.angle(W)))
    ), he = te[0] ?? (Pe ? void 0 : ue)) : he = Pe ? void 0 : ue, he && (x.setTo(t.getPointInShapeSpace(e, De.applyToPoint(v.transform, he))), v.didIntersect = !0, r !== "none")) {
      let de = $x + t.getStrokeWidth(e.props.size) / 2 + ("size" in v.shape.props ? t.getStrokeWidth(v.shape.props.size) / 2 : 0);
      O.Dist(S, x) < _p && (de *= -2), x.setTo(
        vp(
          T.center.x,
          T.center.y,
          T.radius,
          hp(
            O.Angle(T.center, x),
            O.Angle(T.center, g),
            de / Math.abs(Mw(T.center, T.radius, x, g))
          )
        )
      );
    }
  }
  if (Math.abs(Mw(T.center, T.radius, S, x)) < _p / 2 && (S.setTo(c.start), x.setTo(c.end)), y && v && y.shape !== v.shape && !y.isExact && !v.isExact) {
    const z = O.Angle(T.center, S), F = O.Angle(T.center, x), K = T.sweepFlag ? _p : -_p, X = Mw(T.center, T.radius, x, S), {
      center: { x: se, y: ue },
      radius: pe
    } = T;
    y && !y.didIntersect && S.setTo(vp(se, ue, pe, hp(z, F, K / X))), v && !v.didIntersect && x.setTo(vp(se, ue, pe, hp(z, F, -K / X)));
  }
  let N = hp(O.Angle(T.center, S), O.Angle(T.center, x), 0.5), j = vp(
    T.center.x,
    T.center.y,
    T.radius,
    N
  );
  +O.Clockwise(S, j, x) !== T.sweepFlag && (N += Yr, j = vp(T.center.x, T.center.y, T.radius, N)), _.setTo(j);
  const L = xD(S, x, _);
  return {
    isStraight: !1,
    start: {
      point: S,
      handle: c.start,
      arrowhead: e.props.arrowheadStart
    },
    end: {
      point: x,
      handle: c.end,
      arrowhead: e.props.arrowheadEnd
    },
    middle: _,
    handleArc: T,
    bodyArc: L,
    isValid: L.length !== 0 && isFinite(L.center.x) && isFinite(L.center.y)
  };
}
function Fee(t) {
  const {
    start: e,
    end: n,
    handleArc: { radius: r, largeArcFlag: a, sweepFlag: s }
  } = t;
  return `M${e.handle.x},${e.handle.y} A${r} ${r} 0 ${a} ${s} ${n.handle.x},${n.handle.y}`;
}
function ik(t) {
  const {
    start: e,
    end: n,
    bodyArc: { radius: r, largeArcFlag: a, sweepFlag: s }
  } = t;
  return `M${e.point.x},${e.point.y} A${r} ${r} 0 ${a} ${s} ${n.point.x},${n.point.y}`;
}
function xD(t, e, n) {
  const r = -2 * (t.x * (e.y - n.y) - t.y * (e.x - n.x) + e.x * n.y - n.x * e.y), a = {
    x: ((t.x * t.x + t.y * t.y) * (n.y - e.y) + (e.x * e.x + e.y * e.y) * (t.y - n.y) + (n.x * n.x + n.y * n.y) * (e.y - t.y)) / r,
    y: ((t.x * t.x + t.y * t.y) * (e.x - n.x) + (e.x * e.x + e.y * e.y) * (n.x - t.x) + (n.x * n.x + n.y * n.y) * (t.x - e.x)) / r
  }, s = O.Dist(a, t), c = +O.Clockwise(t, n, e), f = Math.hypot(t.y - e.y, t.x - e.x), p = Math.hypot(e.y - n.y, e.x - n.x), g = Math.hypot(n.y - t.y, n.x - t.x), y = Math.acos((p * p + g * g - f * f) / (2 * p * g)) * 2, v = +(Yr > y), S = (Kr - y) * (c ? 1 : -1), x = S * s;
  return {
    center: a,
    radius: s,
    size: S,
    length: x,
    largeArcFlag: v,
    sweepFlag: c
  };
}
class Qr {
  static insertTextFirefox(e, n) {
    e.setRangeText(
      n,
      e.selectionStart || 0,
      e.selectionEnd || 0,
      "end"
      // Without this, the cursor is either at the beginning or text remains selected
    ), e.dispatchEvent(
      new InputEvent("input", {
        data: n,
        inputType: "insertText",
        isComposing: !1
        // TODO: fix @types/jsdom, this shouldn't be required
      })
    );
  }
  /**
   * Inserts text at the cursor’s position, replacing any selection, with **undo** support and by
   * firing the input event.
   */
  static insert(e, n) {
    const r = e.ownerDocument, a = r.activeElement;
    a !== e && e.focus(), r.execCommand("insertText", !1, n) || Qr.insertTextFirefox(e, n), a === r.body ? e.blur() : a instanceof HTMLElement && a !== e && a.focus();
  }
  /**
   * Replaces the entire content, equivalent to field.value = text but with **undo** support and by
   * firing the input event.
   */
  static set(e, n) {
    e.select(), Qr.insert(e, n);
  }
  /** Get the selected text in a field or an empty string if nothing is selected. */
  static getSelection(e) {
    const { selectionStart: n, selectionEnd: r } = e;
    return e.value.slice(
      n || void 0,
      r || void 0
    );
  }
  /**
   * Adds the wrappingText before and after field’s selection (or cursor). If endWrappingText is
   * provided, it will be used instead of wrappingText at on the right.
   */
  static wrapSelection(e, n, r) {
    const { selectionStart: a, selectionEnd: s } = e, c = Qr.getSelection(e);
    Qr.insert(e, n + c + (r ?? n)), e.selectionStart = (a || 0) + n.length, e.selectionEnd = (s || 0) + n.length;
  }
  /** Finds and replaces strings and regex in the field’s value. */
  static replace(e, n, r) {
    let a = 0;
    e.value.replace(n, (...s) => {
      const c = a + s[s.length - 2], f = s[0].length;
      e.selectionStart = c, e.selectionEnd = c + f;
      const p = typeof r == "string" ? r : r(...s);
      return Qr.insert(e, p), e.selectionStart = c, a += p.length - f, p;
    });
  }
  static findLineEnd(e, n) {
    const r = e.lastIndexOf(`
`, n - 1) + 1;
    return e.charAt(r) !== "	" ? n : r + 1;
  }
  static indent(e) {
    const { selectionStart: n, selectionEnd: r, value: a } = e, s = a.slice(n, r), c = /\n/g.exec(s)?.length;
    if (c && c > 0) {
      const f = a.lastIndexOf(`
`, n - 1) + 1, p = e.value.slice(f, r - 1), g = p.replace(
        /^|\n/g,
        // Match all line starts
        `$&${Qr.INDENT}`
      ), y = g.length - p.length;
      e.setSelectionRange(f, r - 1), Qr.insert(e, g), e.setSelectionRange(n + 1, r + y);
    } else
      Qr.insert(e, Qr.INDENT);
  }
  // The first line should always be unindented
  // The last line should only be unindented if the selection includes any characters after \n
  static unindent(e) {
    const { selectionStart: n, selectionEnd: r, value: a } = e, s = a.lastIndexOf(`
`, n - 1) + 1, c = Qr.findLineEnd(a, r), f = e.value.slice(s, c), p = f.replace(/(^|\n)(\t| {1,2})/g, "$1"), g = f.length - p.length;
    e.setSelectionRange(s, c), Qr.insert(e, p);
    const y = /\t| {1,2}/.exec(a.slice(s, n)), v = y ? y[0].length : 0, S = n - v;
    e.setSelectionRange(
      n - v,
      Math.max(S, r - g)
    );
  }
  static indentCE(e) {
    const n = window.getSelection(), r = e.innerText, a = Nw(e) ?? 0, s = Nw(e) ?? 0, c = r.slice(a, s), f = /\n/g.exec(c)?.length;
    if (f && f > 0) {
      const p = r.lastIndexOf(`
`, a - 1) + 1, g = r.slice(p, s - 1), v = g.replace(
        /^|\n/g,
        // Match all line starts
        `$&${Qr.INDENT}`
      ).length - g.length;
      n && n.setBaseAndExtent(
        e,
        a + 1,
        e,
        s + v
      );
    } else {
      const p = window.getSelection();
      e.innerText = r.slice(0, a) + Qr.INDENT + r.slice(a), p?.setBaseAndExtent(e, a + 1, e, a + 2);
    }
  }
  static unindentCE(e) {
    const n = window.getSelection(), r = e.innerText, a = Nw(e) ?? 0, s = Nw(e) ?? 0, c = r.lastIndexOf(`
`, a - 1) + 1, f = Qr.findLineEnd(r, s), p = r.slice(c, f), g = p.replace(/(^|\n)(\t| {1,2})/g, "$1"), y = p.length - g.length;
    if (n) {
      n.setBaseAndExtent(e, c, e, f);
      const v = /\t| {1,2}/.exec(r.slice(c, a)), S = v ? v[0].length : 0, x = a - S;
      n.setBaseAndExtent(
        e,
        a - S,
        e,
        Math.max(x, s - y)
      );
    }
  }
  static fixNewLines = /\r?\n|\r/g;
  static INDENT = "  ";
  static normalizeText(e) {
    return e.replace(Qr.fixNewLines, `
`);
  }
  static normalizeTextForDom(e) {
    return e.replace(Qr.fixNewLines, `
`).split(`
`).map((n) => n || " ").join(`
`);
  }
}
function Nw(t) {
  if (typeof window.getSelection > "u")
    return;
  const e = window.getSelection();
  if (!e)
    return;
  let n = 0;
  if (e.rangeCount !== 0) {
    const r = e.getRangeAt(0), a = r.cloneRange();
    a.selectNodeContents(t), a.setEnd(r.endContainer, r.endOffset), n = a.toString().length;
  }
  return n;
}
function BI(t, e, n) {
  const r = Ge(), a = k.useRef(null), s = un("isEditing", () => r.pageState.editingId === t, [r, t]), c = k.useRef(!1), f = k.useRef(), p = un(
    "is editable hovering",
    () => {
      if (e === "text" && r.isIn("text") && r.hoveredId === t)
        return !0;
      if (r.isIn("select.editing_shape")) {
        const { editingShape: _ } = r;
        return _ ? (
          // The shape must be hovered
          // and this shape must be capable of being editing in its current form
          r.hoveredId === t && // the editing shape must be the same type as this shape
          _.type === e && r.getShapeUtil(_).canEdit(_)
        ) : !1;
      }
      return !1;
    },
    [e, t]
  ), g = k.useCallback(() => {
    p || requestAnimationFrame(() => {
      const _ = a.current;
      if (!_)
        return;
      const T = r.getShapeById(t);
      T && (_.value = T.props.text, _.value.length && !c.current && _.select(), c.current = !1);
    });
  }, [r, t, p]), y = k.useCallback(() => {
    const _ = f.current;
    requestAnimationFrame(() => {
      const T = a.current;
      if (r.isIn("select.editing_shape") && T)
        if (_)
          if (!_.length)
            T.focus();
          else {
            c.current = !0, T.focus();
            const I = window.getSelection();
            I && _.forEach((D) => I.addRange(D));
          }
        else
          T.focus();
      else
        window.getSelection()?.removeAllRanges(), r.complete();
    });
  }, [r]), v = k.useCallback(
    (_) => {
      switch ((_.ctrlKey || _.metaKey) && Tc(_), _.key) {
        case "Enter": {
          (_.ctrlKey || _.metaKey) && r.complete();
          break;
        }
        case "Tab": {
          Gn(_), _.shiftKey ? Qr.unindent(_.currentTarget) : Qr.indent(_.currentTarget);
          break;
        }
      }
    },
    [r]
  ), S = k.useCallback(
    (_) => {
      const T = Qr.normalizeText(_.currentTarget.value);
      r.updateShapes([{ id: t, type: e, props: { text: T } }]);
    },
    [r, t, e]
  ), x = n.trim().length === 0;
  return k.useEffect(() => {
    if (a.current) {
      let T = function() {
        const I = window.getSelection?.();
        if (I && I.type !== "None") {
          const D = [];
          if (I)
            for (let N = 0; N < I.rangeCount; N++)
              D.push(I.getRangeAt?.(N));
          f.current = D;
        }
      };
      return document.addEventListener("selectionchange", T), () => {
        document.removeEventListener("selectionchange", T);
      };
    }
  }), {
    rInput: a,
    isEditing: s,
    isEditableFromHover: p,
    handleFocus: g,
    handleBlur: y,
    handleKeyDown: v,
    handleChange: S,
    isEmpty: x
  };
}
const Hee = k.memo(function({
  id: e,
  text: n,
  size: r,
  font: a,
  position: s,
  width: c,
  labelColor: f
}) {
  const { rInput: p, isEditing: g, handleFocus: y, handleBlur: v, handleKeyDown: S, handleChange: x, isEmpty: _ } = BI(e, "arrow", n);
  return !g && _ ? null : /* @__PURE__ */ E.jsx(
    "div",
    {
      className: "rs-arrow-label",
      "data-font": a,
      "data-align": "center",
      "data-hastext": !_,
      "data-isediting": g,
      style: {
        textAlign: "center",
        fontSize: Bd[r],
        lineHeight: Bd[r] * Yi.lineHeight + "px",
        transform: `translate(${s.x}px, ${s.y}px)`,
        color: f
      },
      children: /* @__PURE__ */ E.jsxs("div", { className: "rs-arrow-label__inner", children: [
        /* @__PURE__ */ E.jsx("p", { style: { width: c || "9px" }, children: n ? Qr.normalizeTextForDom(n) : " " }),
        g && // Consider replacing with content-editable
        /* @__PURE__ */ E.jsx(
          "textarea",
          {
            ref: p,
            className: "rs-text rs-text-input",
            name: "text",
            tabIndex: -1,
            autoComplete: "false",
            autoCapitalize: "false",
            autoCorrect: "false",
            autoSave: "false",
            autoFocus: !0,
            placeholder: "",
            spellCheck: "true",
            wrap: "off",
            dir: "auto",
            datatype: "wysiwyg",
            defaultValue: n,
            onFocus: y,
            onChange: x,
            onKeyDown: S,
            onBlur: v,
            onContextMenu: Tc
          }
        )
      ] })
    }
  );
});
var Vee = Object.defineProperty, Yee = Object.getOwnPropertyDescriptor, fj = (t, e, n, r) => {
  for (var a = r > 1 ? void 0 : r ? Yee(e, n) : e, s = t.length - 1, c; s >= 0; s--)
    (c = t[s]) && (a = (r ? c(e, n, a) : c(a)) || a);
  return r && a && Vee(e, n, a), a;
};
let Kee = 0;
class FI extends Mc {
  static type = "arrow";
  canEdit = () => !0;
  canBind = () => !1;
  isClosed = () => !1;
  hideResizeHandles = () => !0;
  hideRotateHandle = () => !0;
  hideSelectionBoundsFg = () => !0;
  hideSelectionBoundsBg = () => !0;
  defaultProps() {
    return {
      opacity: "1",
      dash: "draw",
      size: "m",
      fill: "none",
      color: "black",
      labelColor: "black",
      bend: 0,
      start: { type: "point", x: 0, y: 0 },
      end: { type: "point", x: 0, y: 0 },
      arrowheadStart: "none",
      arrowheadEnd: "arrow",
      text: "",
      font: "draw"
    };
  }
  getCenter(e) {
    return this.bounds(e).center;
  }
  getBounds(e) {
    return ot.FromPoints(this.getOutlineWithoutLabel(e));
  }
  getOutlineWithoutLabel(e) {
    const n = this.getArrowInfo(e);
    if (!n)
      return [];
    if (n.isStraight)
      return n.isValid ? [n.start.point, n.end.point] : [new O(0, 0), new O(1, 1)];
    if (!n.isValid)
      return [new O(0, 0), new O(1, 1)];
    const r = Math.max(5, Math.ceil(Math.abs(n.bodyArc.length) / 16));
    if (r <= 0 && !isFinite(r))
      return [new O(0, 0), new O(1, 1)];
    const a = Array(r), s = O.Angle(n.bodyArc.center, n.start.point), c = O.Angle(n.bodyArc.center, n.end.point), f = n.bodyArc.sweepFlag ? c : s, p = n.bodyArc.sweepFlag ? s : c, g = n.bodyArc.largeArcFlag ? -Dq(f, p) : Vd(f, p), y = Math.max(1, n.bodyArc.radius);
    for (let v = 0; v < r; v++) {
      const S = v / (r - 1), x = f + g * S, _ = vp(n.bodyArc.center.x, n.bodyArc.center.y, y, x);
      a[v] = _;
    }
    return a;
  }
  getOutline(e) {
    const n = this.getOutlineWithoutLabel(e), r = this.getLabelBounds(e);
    if (!r)
      return n;
    const a = r.sides, s = [0, 1, 2, 3];
    let c = n[0], f = !1;
    const p = [c];
    for (let g = 1; g < n.length; g++) {
      const y = n[g];
      if (!f) {
        const v = LG(
          s.filter(
            (S) => Qd(a[S][0], a[S][1], c, y)
          ),
          (S) => O.DistanceToLineSegment(a[S][0], a[S][1], c)
        );
        if (v !== void 0) {
          const S = O.NearestPointOnLineSegment(
            a[v][0],
            a[v][1],
            c
          );
          p.push(S);
          for (let x = 0; x < 4; x++) {
            const _ = (v + x) % 4;
            p.push(a[_][1]);
          }
          p.push(S), f = !0;
        }
      }
      p.push(y), c = y;
    }
    return p;
  }
  snapPoints(e) {
    return Ys;
  }
  get infoCache() {
    return this.app.store.createComputedCache(
      "arrow infoCache",
      (e) => zee(e) ? uj(this.app, e) : Bee(this.app, e)
    );
  }
  getArrowInfo(e) {
    return this.infoCache.get(e.id);
  }
  getHandles(e) {
    const n = this.infoCache.get(e.id);
    return [
      {
        id: "start",
        type: "vertex",
        index: "a0",
        x: n.start.handle.x,
        y: n.start.handle.y,
        canBind: !0
      },
      {
        id: "middle",
        type: "vertex",
        index: "a2",
        x: n.middle.x,
        y: n.middle.y,
        canBind: !1
      },
      {
        id: "end",
        type: "vertex",
        index: "a3",
        x: n.end.handle.x,
        y: n.end.handle.y,
        canBind: !0
      }
    ];
  }
  onHandleChange = (e, { handle: n, isPrecise: r }) => {
    const a = Cc(e);
    switch (n.id) {
      case "start":
      case "end": {
        const s = this.app.getPageTransformById(a.id), c = De.applyToPoint(s, n), f = this.app.inputs.ctrlKey ? void 0 : Bs(
          this.app.getShapesAtPoint(c).filter((p) => {
            if (p.id === e.id)
              return;
            const g = this.app.getShapeUtil(p);
            return g.canBind(a) && g.hitTestPoint(
              p,
              this.app.getPointInShapeSpace(p, c)
            );
          })
        );
        if (f) {
          const p = this.app.getBounds(f), g = this.app.getPointInShapeSpace(f, c), y = a.props[n.id], v = a.props.start.type === "binding" && a.props.start.boundShapeId, S = a.props.end.type === "binding" && a.props.end.boundShapeId;
          let x = (
            // If externally precise, then always precise
            // If the other shape is not closed, then precise
            r || // If the other handle is bound to the same shape, then precise
            (v || S) && v === S || !this.app.getShapeUtil(f).isClosed(a)
          );
          // If we're switching to a new bound shape, then precise only if moving slowly
          (y.type === "point" || y.type === "binding" && f.id !== y.boundShapeId) && (x = this.app.inputs.pointerVelocity.len() < 0.5), x && (x = O.Dist(g, p.center) > Math.max(4, Math.min(Math.min(p.width, p.height) * 0.15, 16)) / this.app.zoomLevel), a.props[n.id] = {
            type: "binding",
            boundShapeId: f.id,
            normalizedAnchor: x ? {
              x: (g.x - p.minX) / p.width,
              y: (g.y - p.minY) / p.height
            } : { x: 0.5, y: 0.5 },
            isExact: this.app.inputs.altKey
          };
        } else
          a.props[n.id] = {
            type: "point",
            x: n.x,
            y: n.y
          };
        break;
      }
      case "middle": {
        const { start: s, end: c } = Mu(this.app, a), f = O.Sub(c, s), p = O.Per(f), g = O.Med(c, s), y = O.Sub(g, p), v = O.Add(g, p), S = O.NearestPointOnLineSegment(y, v, n, !1);
        let x = O.Dist(S, g);
        O.Clockwise(S, c, g) && (x *= -1), a.props.bend = x;
        break;
      }
    }
    return a;
  };
  onTranslateStart = (e) => {
    let n = e.props.start.type === "binding" ? e.props.start.boundShapeId : null, r = e.props.end.type === "binding" ? e.props.end.boundShapeId : null;
    if (n && this.app.isWithinSelection(n) || r && this.app.isWithinSelection(r))
      return;
    n = null, r = null;
    const { start: a, end: s } = Mu(this.app, e);
    return {
      id: e.id,
      type: e.type,
      props: {
        ...e.props,
        start: {
          type: "point",
          x: a.x,
          y: a.y
        },
        end: {
          type: "point",
          x: s.x,
          y: s.y
        }
      }
    };
  };
  onResize = (e, n) => {
    const { scaleX: r, scaleY: a } = n, s = Mu(this.app, e);
    let { start: c, end: f } = e.props;
    if (c.type === "point") {
      const y = s.start.x * r, v = s.start.y * a;
      c = { ...c, x: y, y: v };
    }
    if (f.type === "point") {
      const y = s.end.x * r, v = s.end.y * a;
      f = { ...f, x: y, y: v };
    }
    let p = e.props.bend;
    if (p !== 0) {
      const y = Math.abs(r), v = Math.abs(a);
      r < 0 && a >= 0 || r >= 0 && a < 0 ? (p *= -1, p *= Math.max(y, v)) : (r >= 0 && a >= 0 || r < 0 && a < 0) && (p *= Math.max(y, v));
    }
    return {
      props: {
        start: c,
        end: f,
        bend: p
      }
    };
  };
  onDoubleClickHandle = (e, n) => {
    switch (n.id) {
      case "start":
        return {
          id: e.id,
          type: e.type,
          props: {
            ...e.props,
            arrowheadStart: e.props.arrowheadStart === "none" ? "arrow" : "none"
          }
        };
      case "end":
        return {
          id: e.id,
          type: e.type,
          props: {
            ...e.props,
            arrowheadEnd: e.props.arrowheadEnd === "none" ? "arrow" : "none"
          }
        };
    }
  };
  hitTestPoint(e, n) {
    const r = this.outline(e);
    for (let a = 0; a < r.length - 1; a++) {
      const s = r[a], c = r[a + 1];
      if (O.DistanceToLineSegment(s, c, n) < 4)
        return !0;
    }
    return !1;
  }
  hitTestLineSegment(e, n, r) {
    const a = this.outline(e);
    for (let s = 0; s < a.length - 1; s++) {
      const c = a[s], f = a[s + 1];
      if (Qd(n, r, c, f))
        return !0;
    }
    return !1;
  }
  render(e) {
    const n = this.app.onlySelectedShape, r = this.app.isInAny(
      "select.idle",
      "select.pointing_handle",
      "select.dragging_handle",
      "arrow.dragging"
    ) && !this.app.isReadOnly, a = this.getArrowInfo(e), s = this.bounds(e), c = this.getLabelBounds(e), f = k.useMemo(() => this.app.isSafari ? Kee += 1 : 0, [e]);
    if (!a?.isValid)
      return null;
    const p = this.app.getStrokeWidth(e.props.size), g = a.start.arrowhead && Og(a, "start", p), y = a.end.arrowhead && Og(a, "end", p), v = a.isStraight ? rk(a) : ik(a);
    let S = null;
    if (n === e && r) {
      const { strokeDasharray: L, strokeDashoffset: z } = Ks(
        a.isStraight ? O.Dist(a.start.handle, a.end.handle) : Math.abs(a.handleArc.length),
        2,
        {
          end: "skip",
          start: "skip",
          lengthRatio: 2.5
        }
      );
      S = e.props.start.type === "binding" || e.props.end.type === "binding" ? /* @__PURE__ */ E.jsx(
        "path",
        {
          className: "rs-arrow-hint",
          d: a.isStraight ? Uee(a) : Fee(a),
          strokeDasharray: L,
          strokeDashoffset: z,
          strokeWidth: 2,
          markerStart: e.props.start.type === "binding" ? e.props.start.isExact ? "" : _D(e.props.start.normalizedAnchor) ? "url(#arrowhead-cross)" : "url(#arrowhead-dot)" : "",
          markerEnd: e.props.end.type === "binding" ? e.props.end.isExact ? "" : _D(e.props.end.normalizedAnchor) ? "url(#arrowhead-cross)" : "url(#arrowhead-dot)" : "",
          opacity: 0.16
        }
      ) : null;
    }
    const { strokeDasharray: x, strokeDashoffset: _ } = Ks(
      a.isStraight ? a.length : Math.abs(a.bodyArc.length),
      p,
      {
        style: e.props.dash
      }
    ), T = !(a.start.arrowhead === "none" || a.start.arrowhead === "arrow"), I = !(a.end.arrowhead === "none" || a.end.arrowhead === "arrow"), D = T || I || c, N = (e.id + "_clip_" + f).replace(":", "_");
    return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsxs(Rp, { id: e.id, style: { minWidth: 50, minHeight: 50 }, children: [
        D && /* @__PURE__ */ E.jsx("defs", { children: /* @__PURE__ */ E.jsxs("mask", { id: N, children: [
          /* @__PURE__ */ E.jsx(
            "rect",
            {
              x: ze(-100 + s.minX),
              y: ze(-100 + s.minY),
              width: ze(s.width + 200),
              height: ze(s.height + 200),
              fill: "white"
            }
          ),
          c && /* @__PURE__ */ E.jsx(
            "rect",
            {
              x: ze(c.x),
              y: ze(c.y),
              width: ze(c.w),
              height: ze(c.h),
              fill: "black",
              rx: 4,
              ry: 4
            }
          ),
          g && T && /* @__PURE__ */ E.jsx(
            "path",
            {
              d: g,
              fill: a.start.arrowhead === "arrow" ? "none" : "black",
              stroke: "none"
            }
          ),
          y && I && /* @__PURE__ */ E.jsx(
            "path",
            {
              d: y,
              fill: a.end.arrowhead === "arrow" ? "none" : "black",
              stroke: "none"
            }
          )
        ] }) }),
        /* @__PURE__ */ E.jsxs(
          "g",
          {
            fill: "none",
            stroke: "currentColor",
            strokeWidth: p,
            strokeLinejoin: "round",
            strokeLinecap: "round",
            pointerEvents: "none",
            children: [
              S,
              /* @__PURE__ */ E.jsxs("g", { ...D ? { mask: `url(#${N})` } : void 0, children: [
                D && /* @__PURE__ */ E.jsx(
                  "rect",
                  {
                    x: ze(s.minX - 100),
                    y: ze(s.minY - 100),
                    width: ze(s.width + 200),
                    height: ze(s.height + 200),
                    opacity: 0
                  }
                ),
                /* @__PURE__ */ E.jsx(
                  "path",
                  {
                    d: v,
                    strokeDasharray: x,
                    strokeDashoffset: _
                  }
                )
              ] }),
              g && T && e.props.fill !== "none" && /* @__PURE__ */ E.jsx(ps, { d: g, color: e.props.color, fill: e.props.fill }),
              y && I && e.props.fill !== "none" && /* @__PURE__ */ E.jsx(ps, { d: y, color: e.props.color, fill: e.props.fill }),
              g && /* @__PURE__ */ E.jsx("path", { d: g }),
              y && /* @__PURE__ */ E.jsx("path", { d: y })
            ]
          }
        ),
        /* @__PURE__ */ E.jsx("path", { d: v, className: "rs-hitarea-stroke" })
      ] }),
      /* @__PURE__ */ E.jsx(
        Hee,
        {
          id: e.id,
          text: e.props.text,
          font: e.props.font,
          size: e.props.size,
          position: a.middle,
          width: c?.w ?? 0,
          labelColor: this.app.getCssColor(e.props.labelColor)
        }
      )
    ] });
  }
  indicator(e) {
    const { start: n, end: r } = Mu(this.app, e), a = this.getArrowInfo(e), s = this.bounds(e), c = this.getLabelBounds(e);
    if (!a || O.Equals(n, r))
      return null;
    const f = this.app.getStrokeWidth(e.props.size), p = a.start.arrowhead && Og(a, "start", f), g = a.end.arrowhead && Og(a, "end", f), y = a.isStraight ? rk(a) : ik(a), v = p && a.start.arrowhead !== "arrow" || g && a.end.arrowhead !== "arrow" || c !== null, S = (e.id + "_clip").replace(":", "_");
    return /* @__PURE__ */ E.jsxs("g", { children: [
      v && /* @__PURE__ */ E.jsx("defs", { children: /* @__PURE__ */ E.jsxs("mask", { id: S, children: [
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            x: s.minX - 100,
            y: s.minY - 100,
            width: s.w + 200,
            height: s.h + 200,
            fill: "white"
          }
        ),
        c && /* @__PURE__ */ E.jsx(
          "rect",
          {
            x: c.x,
            y: c.y,
            width: c.w,
            height: c.h,
            fill: "black",
            rx: 4,
            ry: 4
          }
        ),
        p && /* @__PURE__ */ E.jsx(
          "path",
          {
            d: p,
            fill: a.start.arrowhead === "arrow" ? "none" : "black",
            stroke: "none"
          }
        ),
        g && /* @__PURE__ */ E.jsx(
          "path",
          {
            d: g,
            fill: a.end.arrowhead === "arrow" ? "none" : "black",
            stroke: "none"
          }
        )
      ] }) }),
      /* @__PURE__ */ E.jsxs("g", { ...v ? { mask: `url(#${S})` } : void 0, children: [
        v && /* @__PURE__ */ E.jsx(
          "rect",
          {
            x: s.minX - 100,
            y: s.minY - 100,
            width: s.width + 200,
            height: s.height + 200,
            opacity: 0
          }
        ),
        /* @__PURE__ */ E.jsx("path", { d: y })
      ] }),
      p && /* @__PURE__ */ E.jsx("path", { d: p }),
      g && /* @__PURE__ */ E.jsx("path", { d: g }),
      c && /* @__PURE__ */ E.jsx(
        "rect",
        {
          x: c.x,
          y: c.y,
          width: c.w,
          height: c.h,
          rx: 4,
          ry: 4
        }
      )
    ] });
  }
  get labelBoundsCache() {
    return this.app.store.createComputedCache("labelBoundsCache", (e) => {
      const n = this.getArrowInfo(e), r = this.bounds(e), { text: a, font: s, size: c } = e.props;
      if (!n || !a.trim())
        return null;
      const { w: f, h: p } = this.app.textMeasure.measureText({
        ...Yi,
        text: a,
        fontFamily: Wd[s],
        fontSize: Bd[c],
        width: "fit-content"
      });
      let g = f, y = p;
      if (r.width > r.height) {
        g = Math.max(Math.min(f, 64), Math.min(r.width - 64, f));
        const { w: v, h: S } = this.app.textMeasure.measureText({
          ...Yi,
          text: a,
          fontFamily: Wd[s],
          fontSize: Bd[c],
          width: g + "px"
        });
        g = v, y = S;
      }
      if (g > 16 * Bd[c]) {
        g = 16 * Bd[c];
        const { w: v, h: S } = this.app.textMeasure.measureText({
          ...Yi,
          text: a,
          fontFamily: Wd[s],
          fontSize: Bd[c],
          width: g + "px"
        });
        g = v, y = S;
      }
      return new ot(
        n.middle.x - (g + 8) / 2,
        n.middle.y - (y + 8) / 2,
        g + 8,
        y + 8
      );
    });
  }
  getLabelBounds(e) {
    return this.labelBoundsCache.get(e.id) || null;
  }
  getEditingBounds = (e) => this.getLabelBounds(e) ?? new ot();
  onEditEnd = (e) => {
    const {
      id: n,
      type: r,
      props: { text: a }
    } = e;
    a.trim() !== e.props.text && this.app.updateShapes([
      {
        id: n,
        type: r,
        props: {
          text: a.trim()
        }
      }
    ]);
  };
  toSvg(e, n, r) {
    const a = r.fill[e.props.color], s = this.getArrowInfo(e), c = this.app.getStrokeWidth(e.props.size), f = document.createElementNS("http://www.w3.org/2000/svg", "g");
    if (!s)
      return f;
    const p = s.start.arrowhead && Og(s, "start", c), g = s.end.arrowhead && Og(s, "end", c), y = this.bounds(e), v = this.getLabelBounds(e), S = (e.id + "_clip").replace(":", "_");
    if (p || g) {
      const N = document.createElementNS("http://www.w3.org/2000/svg", "defs"), j = document.createElementNS("http://www.w3.org/2000/svg", "mask");
      j.id = S;
      const L = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      if (L.setAttribute("x", y.minX - 100 + ""), L.setAttribute("y", y.minY - 100 + ""), L.setAttribute("width", y.width + 200 + ""), L.setAttribute("height", y.height + 200 + ""), L.setAttribute("fill", "white"), j.appendChild(L), p && j.appendChild(ED(p, s.start.arrowhead)), g && j.appendChild(ED(g, s.end.arrowhead)), v) {
        const z = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        z.setAttribute("x", v.x + ""), z.setAttribute("y", v.y + ""), z.setAttribute("width", v.w + ""), z.setAttribute("height", v.h + ""), z.setAttribute("fill", "black"), j.appendChild(z);
      }
      N.appendChild(j), f.appendChild(N);
    }
    const x = document.createElementNS("http://www.w3.org/2000/svg", "g");
    x.setAttribute("mask", `url(#${S})`), f.appendChild(x);
    const _ = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    _.setAttribute("x", "-100"), _.setAttribute("y", "-100"), _.setAttribute("width", y.width + 200 + ""), _.setAttribute("height", y.height + 200 + ""), _.setAttribute("fill", "transparent"), _.setAttribute("stroke", "none"), x.appendChild(_);
    const T = Wee(
      s.isStraight ? rk(s) : ik(s),
      a,
      c
    ), { strokeDasharray: I, strokeDashoffset: D } = Ks(
      s.isStraight ? s.length : Math.abs(s.bodyArc.length),
      c,
      {
        style: e.props.dash
      }
    );
    if (T.setAttribute("stroke-dasharray", I), T.setAttribute("stroke-dashoffset", D), x.appendChild(T), p && f.appendChild(
      CD(
        p,
        e.props.color,
        c,
        e.props.arrowheadStart === "arrow" ? "none" : e.props.fill,
        r
      )
    ), g && f.appendChild(
      CD(
        g,
        e.props.color,
        c,
        e.props.arrowheadEnd === "arrow" ? "none" : e.props.fill,
        r
      )
    ), v) {
      const N = {
        fontSize: Bd[e.props.size],
        lineHeight: Yi.lineHeight,
        fontFamily: n,
        padding: 0,
        textAlign: "middle",
        width: v.w,
        height: v.h,
        fontStyle: "normal",
        fontWeight: "normal"
      }, j = this.app.textMeasure.getTextLines({
        text: e.props.text,
        wrap: !0,
        ...N,
        width: v.w - 8
      }), L = h1(this.app, {
        lines: j,
        ...N,
        width: v.w - 8
      });
      L.setAttribute("fill", r.fill[e.props.labelColor]), Array.from(L.children).forEach((F) => {
        const K = parseFloat(F.getAttribute("x") || "0"), X = parseFloat(F.getAttribute("y") || "0");
        F.setAttribute("x", K + 4 + v.x + "px"), F.setAttribute("y", X + v.y + "px");
      }), f.appendChild(L);
    }
    return f;
  }
}
fj([
  pt
], FI.prototype, "infoCache", 1);
fj([
  pt
], FI.prototype, "labelBoundsCache", 1);
function ED(t, e) {
  const n = document.createElementNS("http://www.w3.org/2000/svg", "path");
  return n.setAttribute("d", t), n.setAttribute("fill", e === "arrow" ? "none" : "black"), n.setAttribute("stroke", "none"), n;
}
function Wee(t, e, n) {
  const r = document.createElementNS("http://www.w3.org/2000/svg", "path");
  return r.setAttribute("d", t), r.setAttribute("fill", "none"), r.setAttribute("stroke", e), r.setAttribute("stroke-width", n + ""), r;
}
function CD(t, e, n, r, a) {
  const s = document.createElementNS("http://www.w3.org/2000/svg", "path");
  s.setAttribute("d", t), s.setAttribute("fill", "none"), s.setAttribute("stroke", a.fill[e]), s.setAttribute("stroke-width", n + "");
  const c = $c({
    d: t,
    fill: r,
    color: e,
    colors: a
  });
  if (c) {
    const f = document.createElementNS("http://www.w3.org/2000/svg", "g");
    return f.appendChild(c), f.appendChild(s), f;
  } else
    return s;
}
function _D(t) {
  return t.x !== 0.5 || t.y !== 0.5;
}
const to = pi({
  type: "arrow",
  getShapeUtil: () => FI,
  validator: lq,
  migrations: cq
});
function fa({ children: t, className: e = "", ...n }) {
  return /* @__PURE__ */ E.jsx("div", { ...n, className: `rs-html-container ${e}`, children: t });
}
const TD = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E";
function _b({ url: t }) {
  const {
    camera: { z: e }
  } = Ge();
  return /* @__PURE__ */ E.jsx(
    "a",
    {
      className: `rs-hyperlink-button ${e < 0.5 ? "hidden" : ""}`,
      href: t,
      target: "_blank",
      rel: "noopener noreferrer",
      onPointerDown: Tc,
      onPointerUp: Tc,
      title: t,
      draggable: !1,
      children: /* @__PURE__ */ E.jsx(
        "div",
        {
          className: "rs-hyperlink-button__icon",
          style: {
            mask: `url("${TD}") center 100% / 100% no-repeat`,
            WebkitMask: `url("${TD}") center 100% / 100% no-repeat`
          }
        }
      )
    }
  );
}
const pj = (t, e, n = {}) => {
  const { newPoint: r, handle: a, scaleX: s, scaleY: c } = e, { minWidth: f = 1, maxWidth: p = 1 / 0, minHeight: g = 1, maxHeight: y = 1 / 0 } = n;
  let v = t.props.w * s, S = t.props.h * c;
  const x = new O(0, 0);
  if (v > 0) {
    if (v < f) {
      switch (a) {
        case "top_left":
        case "left":
        case "bottom_left": {
          x.x = v - f;
          break;
        }
        case "top":
        case "bottom": {
          x.x = (v - f) / 2;
          break;
        }
        default:
          x.x = 0;
      }
      v = f;
    }
  } else if (x.x = v, v = -v, v < f) {
    switch (a) {
      case "top_left":
      case "left":
      case "bottom_left": {
        x.x = -v;
        break;
      }
      default:
        x.x = -f;
    }
    v = f;
  }
  if (S > 0) {
    if (S < g) {
      switch (a) {
        case "top_left":
        case "top":
        case "top_right": {
          x.y = S - g;
          break;
        }
        case "right":
        case "left": {
          x.y = (S - g) / 2;
          break;
        }
        default:
          x.y = 0;
      }
      S = g;
    }
  } else if (x.y = S, S = -S, S < g) {
    switch (a) {
      case "top_left":
      case "top":
      case "top_right": {
        x.y = -S;
        break;
      }
      default:
        x.y = -g;
    }
    S = g;
  }
  const { x: _, y: T } = x.rot(t.rotation).add(r);
  return {
    x: _,
    y: T,
    props: {
      w: Math.min(p, v),
      h: Math.min(y, S)
    }
  };
};
class ma extends Mc {
  getBounds(e) {
    return new ot(0, 0, e.props.w, e.props.h);
  }
  getCenter(e) {
    return new O(e.props.w / 2, e.props.h / 2);
  }
  getOutline(e) {
    return this.bounds(e).corners;
  }
  hitTestPoint(e, n) {
    return Lu(n, this.outline(e));
  }
  hitTestLineSegment(e, n, r) {
    const a = this.outline(e);
    for (let s = 0; s < a.length; s++) {
      const c = a[s], f = a[(s + 1) % a.length];
      if (Qd(n, r, c, f))
        return !0;
    }
    return !1;
  }
  onResize = (e, n) => pj(e, n);
}
class Gee extends ma {
  static type = "bookmark";
  canResize = () => !1;
  hideSelectionBoundsBg = () => !0;
  hideSelectionBoundsFg = () => !0;
  defaultProps() {
    return {
      opacity: "1",
      url: "",
      w: ML,
      h: AL,
      assetId: null
    };
  }
  render(e) {
    const n = e.props.assetId ? this.app.getAssetById(e.props.assetId) : null, r = this.app.getPageRotation(e), a = this.getHumanReadableAddress(e);
    return /* @__PURE__ */ E.jsx(fa, { children: /* @__PURE__ */ E.jsxs(
      "div",
      {
        className: "rs-bookmark__container rs-hitarea-stroke",
        style: {
          boxShadow: NI(r, PI)
        },
        children: [
          /* @__PURE__ */ E.jsxs("div", { className: "rs-bookmark__image_container", children: [
            n?.props.image ? /* @__PURE__ */ E.jsx(
              "img",
              {
                className: "rs-bookmark__image",
                draggable: !1,
                src: n?.props.image,
                alt: n?.props.title || ""
              }
            ) : /* @__PURE__ */ E.jsx("div", { className: "rs-bookmark__placeholder" }),
            /* @__PURE__ */ E.jsx(_b, { url: e.props.url })
          ] }),
          /* @__PURE__ */ E.jsxs("div", { className: "rs-bookmark__copy_container", children: [
            n?.props.title && /* @__PURE__ */ E.jsx("h2", { className: "rs-bookmark__heading", children: ZT(n?.props.title || "", 54) }),
            n?.props.description && /* @__PURE__ */ E.jsx("p", { className: "rs-bookmark__description", children: ZT(n?.props.description || "", 128) }),
            /* @__PURE__ */ E.jsx(
              "a",
              {
                className: "rs-bookmark__link",
                href: e.props.url || "",
                target: "_blank",
                rel: "noopener noreferrer",
                onPointerDown: Tc,
                onPointerUp: Tc,
                onClick: Tc,
                children: ZT(a, 45)
              }
            )
          ] })
        ]
      }
    ) });
  }
  indicator(e) {
    return /* @__PURE__ */ E.jsx(
      "rect",
      {
        width: ze(e.props.w),
        height: ze(e.props.h),
        rx: "8",
        ry: "8"
      }
    );
  }
  onBeforeCreate = (e) => {
    this.updateBookmarkAsset(e);
  };
  onBeforeUpdate = (e, n) => {
    e.props.url !== n.props.url && this.updateBookmarkAsset(n);
  };
  getHumanReadableAddress(e) {
    try {
      const n = new URL(e.props.url), r = n.pathname.replace(/\/*$/, "");
      return `${n.hostname}${r}`;
    } catch {
      return e.props.url;
    }
  }
  updateBookmarkAsset = cI((e) => {
    const { url: n } = e.props, r = sm.createCustomId(n1(n)), a = this.app.getAssetById(r);
    a ? e.props.assetId !== a.id && this.app.updateShapes([
      {
        id: e.id,
        type: e.type,
        props: { assetId: r }
      }
    ]) : this.app.onCreateBookmarkFromUrl && this.app.onCreateBookmarkFromUrl(n).then((s) => {
      if (!s) {
        this.app.updateShapes([
          {
            id: e.id,
            type: e.type,
            props: { assetId: void 0 }
          }
        ]);
        return;
      }
      this.app.batch(() => {
        this.app.createAssets([
          {
            id: r,
            typeName: "asset",
            type: "bookmark",
            props: {
              src: n,
              description: s.description,
              image: s.image,
              title: s.title
            }
          }
        ]).updateShapes([
          {
            id: e.id,
            type: e.type,
            props: { assetId: r }
          }
        ]);
      });
    });
  }, 500);
}
const g1 = pi({
  type: "bookmark",
  getShapeUtil: () => Gee,
  validator: uq,
  migrations: dq
}), Xee = (t) => t * 0.65 + Oq(t * Yr / 2) * 0.35, qee = (t) => ({
  size: 1 + t,
  thinning: 0.5,
  streamline: 0.62 + (1 + t) / 8 * 0.06,
  smoothing: 0.62,
  easing: ua.easeOutSine,
  simulatePressure: !0
}), Qee = (t) => ({
  size: 1 + t * 1.2,
  thinning: 0.62,
  streamline: 0.62,
  smoothing: 0.62,
  simulatePressure: !1,
  easing: Xee
}), kD = (t) => ({
  size: 1 + t,
  thinning: 0,
  streamline: 0.62 + (1 + t) / 8 * 0.06,
  smoothing: 0.62,
  simulatePressure: !1,
  easing: ua.linear
});
function ok(t, e, n, r) {
  return {
    ...r ? kD(e) : t.props.dash === "draw" ? t.props.isPen ? Qee(e) : qee(e) : kD(e),
    last: t.props.isComplete || n
  };
}
function Lw(t) {
  const e = [];
  for (const n of t)
    if (n.type === "free" || n.points.length < 2)
      e.push(...n.points.map(O.Cast));
    else {
      const r = Math.max(
        4,
        Math.floor(O.Dist(n.points[0], n.points[1]) / 16)
      );
      e.push(...O.PointsBetween(n.points[0], n.points[1], r));
    }
  return e;
}
function PD(t, e) {
  return {
    draw: "none",
    solid: "none",
    dotted: `0.1 ${e * 2}`,
    dashed: `${e * 2} ${e * 2}`
  }[t.props.dash];
}
class Zee extends Mc {
  static type = "draw";
  hideResizeHandles = (e) => this.getIsDot(e);
  hideRotateHandle = (e) => this.getIsDot(e);
  hideSelectionBoundsBg = (e) => this.getIsDot(e);
  hideSelectionBoundsFg = (e) => this.getIsDot(e);
  defaultProps() {
    return {
      segments: [],
      color: "black",
      fill: "none",
      dash: "draw",
      size: "m",
      opacity: "1",
      isComplete: !1,
      isClosed: !1,
      isPen: !1
    };
  }
  isClosed = (e) => e.props.isClosed;
  getIsDot(e) {
    return e.props.segments.length === 1 && e.props.segments[0].points.length < 2;
  }
  getBounds(e) {
    return ot.FromPoints(this.outline(e));
  }
  getOutline(e) {
    return Lw(e.props.segments);
  }
  getCenter(e) {
    return this.bounds(e).center;
  }
  hitTestPoint(e, n) {
    const r = this.outline(e), a = this.app.zoomLevel, s = this.app.getStrokeWidth(e.props.size) / a;
    if (e.props.segments.length === 1 && e.props.segments[0].points.length < 4 && e.props.segments[0].points.some((c) => O.Dist(n, c) < s * 1.5))
      return !0;
    if (this.isClosed(e))
      return Lu(n, r);
    for (let c = 0; c < r.length; c++) {
      const f = r[c], p = r[(c + 1) % r.length];
      if (O.DistanceToLineSegment(f, p, n) < s)
        return !0;
    }
    return !1;
  }
  hitTestLineSegment(e, n, r) {
    const a = this.outline(e);
    if (e.props.segments.length === 1 && e.props.segments[0].points.length < 4) {
      const s = this.app.zoomLevel, c = this.app.getStrokeWidth(e.props.size) / s;
      if (e.props.segments[0].points.some(
        (f) => O.DistanceToLineSegment(n, r, f) < c * 1.5
      ))
        return !0;
    }
    if (this.isClosed(e))
      for (let s = 0; s < a.length; s++) {
        const c = a[s], f = a[(s + 1) % a.length];
        if (Qd(n, r, c, f))
          return !0;
      }
    else
      for (let s = 0; s < a.length - 1; s++) {
        const c = a[s], f = a[s + 1];
        if (Qd(n, r, c, f))
          return !0;
      }
    return !1;
  }
  render(e) {
    const n = un("zoom", () => this.app.zoomLevel < 0.35, []), r = this.app.getStrokeWidth(e.props.size), a = Lw(e.props.segments), s = e.props.isComplete || Bs(e.props.segments)?.type === "straight";
    let c = r;
    !e.props.isPen && e.props.dash === "draw" && a.length === 1 && (c += Uy(e.id)() * (r / 6));
    const f = ok(e, c, s, n), p = _c(a, f), g = p.length > 1 ? Gd(p, e.props.isClosed) : ak(a[0], c);
    if (!n && e.props.dash === "draw" || p.length < 2) {
      Zy(p, f);
      const y = Qy(p, f);
      return /* @__PURE__ */ E.jsxs(Rp, { id: e.id, children: [
        /* @__PURE__ */ E.jsx(
          ps,
          {
            fill: e.props.isClosed ? e.props.fill : "none",
            color: e.props.color,
            d: g
          }
        ),
        /* @__PURE__ */ E.jsx(
          "path",
          {
            d: Jd(y, !0),
            strokeLinecap: "round",
            fill: "currentColor"
          }
        )
      ] });
    }
    return /* @__PURE__ */ E.jsxs(Rp, { id: e.id, children: [
      /* @__PURE__ */ E.jsx(
        ps,
        {
          color: e.props.color,
          fill: e.props.isClosed ? e.props.fill : "none",
          d: g
        }
      ),
      /* @__PURE__ */ E.jsx(
        "path",
        {
          d: g,
          strokeLinecap: "round",
          fill: "none",
          stroke: "currentColor",
          strokeWidth: r,
          strokeDasharray: PD(e, r),
          strokeDashoffset: "0"
        }
      )
    ] });
  }
  indicator(e) {
    const n = this.app.getStrokeWidth(e.props.size), r = Lw(e.props.segments);
    let a = n;
    !e.props.isPen && e.props.dash === "draw" && r.length === 1 && (a += Uy(e.id)() * (n / 6));
    const s = e.props.isComplete || Bs(e.props.segments)?.type === "straight", c = ok(e, a, s, !0), f = _c(r, c), p = f.length > 1 ? Gd(f, e.props.isClosed) : ak(r[0], a);
    return /* @__PURE__ */ E.jsx("path", { d: p });
  }
  toSvg(e, n, r) {
    const { color: a } = e.props, s = this.app.getStrokeWidth(e.props.size), c = Lw(e.props.segments), f = e.props.isComplete || Bs(e.props.segments)?.type === "straight";
    let p = s;
    !e.props.isPen && e.props.dash === "draw" && c.length === 1 && (p += Uy(e.id)() * (s / 6));
    const g = ok(e, p, f, !1), y = _c(c, g), v = y.length > 1 ? Gd(y, e.props.isClosed) : ak(c[0], p);
    let S;
    if (e.props.dash === "draw" || y.length < 2) {
      Zy(y, g);
      const _ = Qy(y, g), T = document.createElementNS("http://www.w3.org/2000/svg", "path");
      T.setAttribute("d", Jd(_, !0)), T.setAttribute("fill", r.fill[a]), T.setAttribute("stroke-linecap", "round"), S = T;
    } else {
      const _ = document.createElementNS("http://www.w3.org/2000/svg", "path");
      _.setAttribute("d", v), _.setAttribute("stroke", r.fill[a]), _.setAttribute("fill", "none"), _.setAttribute("stroke-linecap", "round"), _.setAttribute("stroke-width", s.toString()), _.setAttribute("stroke-dasharray", PD(e, s)), _.setAttribute("stroke-dashoffset", "0"), S = _;
    }
    const x = $c({
      fill: e.props.isClosed ? e.props.fill : "none",
      d: v,
      color: e.props.color,
      colors: r
    });
    if (x) {
      const _ = document.createElementNS("http://www.w3.org/2000/svg", "g");
      return _.appendChild(x), _.appendChild(S), _;
    }
    return S;
  }
  onResize = (e, n) => {
    const { scaleX: r, scaleY: a } = n, s = [];
    for (const c of e.props.segments)
      s.push({
        ...c,
        points: c.points.map(({ x: f, y: p, z: g }) => ({
          x: r * f,
          y: a * p,
          z: g
        }))
      });
    return {
      props: {
        segments: s
      }
    };
  };
}
const hj = pi({
  type: "draw",
  getShapeUtil: () => Zee,
  migrations: hq,
  validator: pq
});
function ak(t, e) {
  const n = (e + 1) * 0.5;
  return `M ${t.x} ${t.y} m -${n}, 0 a ${n},${n} 0 1,0 ${n * 2},0 a ${n},${n} 0 1,0 -${n * 2},0`;
}
function m1(t) {
  return /* @__PURE__ */ E.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", ...t, children: /* @__PURE__ */ E.jsxs("g", { strokeWidth: 2, fill: "none", fillRule: "evenodd", children: [
    /* @__PURE__ */ E.jsx("circle", { strokeOpacity: 0.25, cx: 8, cy: 8, r: 7, stroke: "black" }),
    /* @__PURE__ */ E.jsx("path", { strokeLinecap: "round", d: "M15 8c0-4.5-4.5-7-7-7", stroke: "black", children: /* @__PURE__ */ E.jsx(
      "animateTransform",
      {
        attributeName: "transform",
        type: "rotate",
        from: "0 8 8",
        to: "360 8 8",
        dur: "1s",
        repeatCount: "indefinite"
      }
    ) })
  ] }) });
}
const Jee = (t) => Object.entries(t).filter(([e, n]) => n).map(([e]) => e).join(" ");
class ete extends ma {
  static type = "embed";
  canUnmount = () => !1;
  canResize = (e) => !!Yd(e.props.url)?.definition?.doesResize;
  hideSelectionBoundsBg = (e) => !this.canResize(e);
  hideSelectionBoundsFg = (e) => !this.canResize(e);
  canEdit = () => !0;
  defaultProps() {
    return {
      opacity: "1",
      w: 300,
      h: 300,
      url: "",
      doesResize: !0
    };
  }
  isAspectRatioLocked = (e) => Yd(e.props.url)?.definition.isAspectRatioLocked ?? !1;
  onResize = (e, n) => {
    const r = this.isAspectRatioLocked(e), a = Yd(e.props.url);
    let s = a?.definition.minWidth ?? 200, c = a?.definition.minHeight ?? 200;
    if (r) {
      const f = e.props.w / e.props.h;
      f > 1 ? s *= f : c /= f;
    }
    return pj(e, n, { minWidth: s, minHeight: c });
  };
  render(e) {
    const { w: n, h: r, url: a } = e.props, s = zI(e.id), c = k.useMemo(() => GL(a), [a]), f = un(
      "is hovering",
      () => {
        const { editingId: v, hoveredId: S } = this.app.pageState;
        if (v && S !== v) {
          const x = this.app.getShapeById(v);
          if (x && x.type === "embed")
            return !0;
        }
        return !1;
      },
      []
    ), p = this.app.getPageRotation(e), g = s || f;
    if (c?.definition.type === "github_gist") {
      const v = c.url.split("/").pop();
      if (v)
        return /* @__PURE__ */ E.jsx(fa, { className: "rs-embed-container", id: e.id, children: /* @__PURE__ */ E.jsx(
          tte,
          {
            id: v,
            width: ze(n),
            height: ze(r),
            isInteractive: g,
            pageRotation: p
          }
        ) });
    }
    const y = Jee({
      ...EL,
      ...c?.definition.overridePermissions ?? {}
    });
    return /* @__PURE__ */ E.jsx(fa, { className: "rs-embed-container", id: e.id, children: c?.definition ? /* @__PURE__ */ E.jsx(
      "iframe",
      {
        className: `rs-embed rs-embed-${e.id}`,
        sandbox: y,
        src: c.embedUrl,
        width: ze(n),
        height: ze(r),
        draggable: !1,
        frameBorder: "0",
        referrerPolicy: "no-referrer-when-downgrade",
        style: {
          border: 0,
          pointerEvents: g ? "auto" : "none",
          // Fix for safari <https://stackoverflow.com/a/49150908>
          zIndex: g ? "" : "-1",
          boxShadow: NI(p, PI),
          borderRadius: c?.definition.overrideOutlineRadius ?? 8,
          background: c?.definition.backgroundColor
        }
      }
    ) : /* @__PURE__ */ E.jsx(m1, { x: (n - 38) / 2, y: (r - 38) / 2 }) });
  }
  indicator(e) {
    const n = k.useMemo(() => Yd(e.props.url), [e.props.url]);
    return /* @__PURE__ */ E.jsx(
      "rect",
      {
        width: ze(e.props.w),
        height: ze(e.props.h),
        rx: n?.definition.overrideOutlineRadius ?? 8,
        ry: n?.definition.overrideOutlineRadius ?? 8
      }
    );
  }
}
function tte({
  id: t,
  file: e,
  isInteractive: n,
  width: r,
  height: a,
  style: s,
  pageRotation: c
}) {
  const f = k.useRef(null), p = e ? `?file=${e}` : "", g = `https://gist.github.com/${t}.js${p}`;
  return /* @__PURE__ */ E.jsx(
    "iframe",
    {
      ref: f,
      className: "rs-embed",
      draggable: !1,
      width: ze(r),
      height: ze(a),
      frameBorder: "0",
      scrolling: "no",
      seamless: !0,
      referrerPolicy: "no-referrer-when-downgrade",
      style: {
        ...s,
        pointerEvents: n ? "all" : "none",
        // Fix for safari <https://stackoverflow.com/a/49150908>
        zIndex: n ? "" : "-1",
        boxShadow: NI(c, PI)
      },
      srcDoc: `
			<html>
				<head>
					<base target="_blank">
				</head>
				<body>
					<script src=${g}><\/script>
					<style type="text/css">
						* { margin: 0px; }
						table { height: 100%; background-color: red; }
						.gist { background-color: none; height: 100%;  }
						.gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }
					</style>
				</body>
			</html>`
    }
  );
}
const tb = pi({
  type: "embed",
  getShapeUtil: () => ete,
  validator: gq,
  migrations: mq
}), nte = k.forwardRef(({ id: t, name: e, isEditing: n }, r) => {
  const a = Ge(), s = k.useCallback(
    (p) => {
      p.key === "Enter" && (p.stopPropagation(), p.currentTarget.blur(), a.setEditingId(null));
    },
    [a]
  ), c = k.useCallback(
    (p) => {
      const g = a.getShapeById(t);
      if (!g)
        return;
      const y = g.props.name, v = p.currentTarget.value.trim();
      y !== v && a.updateShapes(
        [
          {
            id: t,
            type: "frame",
            props: { name: v }
          }
        ],
        !0
      );
    },
    [t, a]
  ), f = k.useCallback(
    (p) => {
      const g = a.getShapeById(t);
      if (!g)
        return;
      const y = g.props.name, v = p.currentTarget.value;
      y !== v && a.updateShapes(
        [
          {
            id: t,
            type: "frame",
            props: { name: v }
          }
        ],
        !0
      );
    },
    [t, a]
  );
  return /* @__PURE__ */ E.jsxs("div", { className: `rs-frame-label ${n ? "rs-frame-label__editing" : ""}`, children: [
    /* @__PURE__ */ E.jsx(
      "input",
      {
        className: "rs-frame-name-input",
        ref: r,
        style: { display: n ? void 0 : "none" },
        value: e,
        autoFocus: !0,
        onKeyDown: s,
        onBlur: c,
        onChange: f
      }
    ),
    ej(e, "Frame") + String.fromCharCode(8203)
  ] });
}), rte = dn(function({
  id: e,
  name: n,
  width: r,
  height: a
}) {
  const s = Ge(), c = EI(s.getPageRotationById(e)), f = zI(e), p = k.useRef(null);
  k.useEffect(() => {
    const x = p.current;
    x && f && (x.focus(), x.select(), requestAnimationFrame(() => {
      document.activeElement !== x && (x.focus(), x.select());
    }));
  }, [p, f]);
  const y = ((c + Math.PI / 4) * (2 / Math.PI) + 4) % 4, v = ["top", "left", "bottom", "right"][Math.floor(y)];
  let S;
  switch (v) {
    case "top":
      S = "";
      break;
    case "right":
      S = `translate(${ze(r)}px, 0px) rotate(90deg)`;
      break;
    case "bottom":
      S = `translate(${ze(r)}px, ${ze(
        a
      )}px) rotate(180deg)`;
      break;
    case "left":
      S = `translate(0px, ${ze(a)}px) rotate(270deg)`;
      break;
  }
  return /* @__PURE__ */ E.jsx(
    "div",
    {
      className: "rs-frame-heading",
      style: {
        overflow: f ? "visible" : "hidden",
        maxWidth: `calc(var(--rs-zoom) * ${Math.ceil(v === "top" || v === "bottom" ? r : a)}px + var(--space-5))`,
        bottom: Math.ceil(a),
        transform: `${S} scale(var(--rs-scale)) translateX(calc(-1 * var(--space-3))`
      },
      children: /* @__PURE__ */ E.jsx("div", { className: "rs-frame-heading-hit-area", children: /* @__PURE__ */ E.jsx(nte, { ref: p, id: e, name: n, isEditing: f }) })
    }
  );
});
class ite extends ma {
  static type = "frame";
  canBind = () => !0;
  canEdit = () => !0;
  defaultProps() {
    return { opacity: "1", w: 160 * 2, h: 90 * 2, name: "" };
  }
  render(e) {
    const n = this.bounds(e);
    return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsxs(Rp, { children: [
        /* @__PURE__ */ E.jsx("rect", { className: "rs-hitarea-stroke", width: n.width, height: n.height }),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            className: "rs-frame__body",
            width: n.width,
            height: n.height,
            fill: "none"
          }
        )
      ] }),
      /* @__PURE__ */ E.jsx(
        rte,
        {
          id: e.id,
          name: e.props.name,
          width: n.width,
          height: n.height
        }
      )
    ] });
  }
  toSvg(e, n, r) {
    const a = document.createElementNS("http://www.w3.org/2000/svg", "g"), s = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    s.setAttribute("width", e.props.w.toString()), s.setAttribute("height", e.props.h.toString()), s.setAttribute("fill", r.solid), s.setAttribute("opacity", e.props.opacity), s.setAttribute("stroke", r.fill.black), s.setAttribute("stroke-width", "1"), s.setAttribute("rx", "4"), s.setAttribute("ry", "4"), a.appendChild(s);
    const p = ((EI(this.app.getPageRotationById(e.id)) + Math.PI / 4) * (2 / Math.PI) + 4) % 4, g = ["top", "left", "bottom", "right"][Math.floor(p)];
    let y;
    switch (g) {
      case "top":
        y = "";
        break;
      case "right":
        y = `translate(${ze(e.props.w)}px, 0px) rotate(90deg)`;
        break;
      case "bottom":
        y = `translate(${ze(e.props.w)}px, ${ze(
          e.props.h
        )}px) rotate(180deg)`;
        break;
      case "left":
        y = `translate(0px, ${ze(e.props.h)}px) rotate(270deg)`;
        break;
      default:
        y = "";
    }
    const v = {
      fontSize: 12,
      fontFamily: "Inter, sans-serif",
      textAlign: "start",
      width: e.props.w + 16,
      height: 30,
      padding: 8,
      lineHeight: 1,
      fontStyle: "normal",
      fontWeight: "normal"
    };
    let S = ej(e.props.name, "Frame") + String.fromCharCode(8203);
    const x = this.app.textMeasure.getTextLines({
      text: S,
      wrap: !0,
      ...v
    });
    S = x.length > 1 ? x[0] + "…" : x[0];
    const _ = this.app.textMeasure.measureText({
      fontSize: 12,
      fontFamily: "Inter, sans-serif",
      lineHeight: 1,
      fontStyle: "normal",
      fontWeight: "normal",
      text: S,
      width: "fit-content",
      maxWidth: "unset",
      padding: "0px"
    }), T = document.createElementNS("http://www.w3.org/2000/svg", "text");
    T.setAttribute("x", "0"), T.setAttribute("y", -(8 + _.h / 2) + "px"), T.setAttribute("font-family", '"Inter", sans-serif'), T.setAttribute("font-size", "12px"), T.setAttribute("font-weight", "400"), T.style.setProperty("transform", y), T.textContent = S;
    const I = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    return I.setAttribute("x", " -4px"), I.setAttribute("y", -(16 + _.h) + "px"), I.setAttribute("width", _.w + 8 + "px"), I.setAttribute("height", _.h + 8 + "px"), I.setAttribute("rx", "4px"), I.setAttribute("ry", "4px"), I.setAttribute("fill", r.background), a.appendChild(I), a.appendChild(T), a;
  }
  indicator(e) {
    const n = this.bounds(e);
    return /* @__PURE__ */ E.jsx(
      "rect",
      {
        width: ze(n.width),
        height: ze(n.height),
        className: "rs-frame-indicator"
      }
    );
  }
  canReceiveNewChildrenOfType = (e) => !0;
  canDropShapes = (e, n) => !0;
  onDragShapesOver = (e, n) => n.every((r) => r.parentId === e.id) ? { shouldHint: !1 } : (this.app.reparentShapesById(
    n.map((r) => r.id),
    e.id
  ), { shouldHint: !0 });
  onDragShapesOut = (e, n) => {
    const r = this.app.getShapeById(e.parentId);
    r?.type === "group" ? this.app.reparentShapesById(
      n.map((s) => s.id),
      r.id
    ) : this.app.reparentShapesById(
      n.map((s) => s.id),
      this.app.currentPageId
    );
  };
  onResizeEnd = (e) => {
    const n = this.app.getPageBounds(e), r = this.app.getSortedChildIds(e.id), a = [];
    for (const s of r) {
      const c = this.app.getPageBoundsById(s);
      n.includes(c) || a.push(s);
    }
    a.length > 0 && this.app.reparentShapesById(a, this.app.currentPageId);
  };
}
const dx = pi({
  type: "frame",
  getShapeUtil: () => ite,
  validator: vq,
  migrations: yq
}), gj = It.memo(function({
  id: e,
  type: n,
  text: r,
  size: a,
  labelColor: s,
  font: c,
  align: f,
  wrap: p
}) {
  const {
    rInput: g,
    isEmpty: y,
    isEditing: v,
    isEditableFromHover: S,
    handleFocus: x,
    handleChange: _,
    handleKeyDown: T,
    handleBlur: I
  } = BI(e, n, r), D = v || S;
  return /* @__PURE__ */ E.jsx(
    "div",
    {
      className: "rs-text-label",
      "data-font": c,
      "data-align": f,
      "data-hastext": !y,
      "data-isediting": v,
      "data-textwrap": !!p,
      children: /* @__PURE__ */ E.jsxs(
        "div",
        {
          className: "rs-text-label__inner",
          style: {
            fontSize: Kd[a],
            lineHeight: Kd[a] * Yi.lineHeight + "px",
            minHeight: y ? Kd[a] * Yi.lineHeight + 32 : 0,
            minWidth: y ? 33 : 0,
            color: s
          },
          children: [
            /* @__PURE__ */ E.jsx("div", { className: "rs-text rs-text-content", dir: "ltr", children: Qr.normalizeTextForDom(r) }),
            D ? (
              // Consider replacing with content-editable
              /* @__PURE__ */ E.jsx("textarea", {
                ref: g,
                className: "rs-text rs-text-input",
                name: "text",
                tabIndex: -1,
                autoComplete: "false",
                autoCapitalize: "false",
                autoCorrect: "false",
                autoSave: "false",
                autoFocus: v,
                placeholder: "",
                spellCheck: "true",
                wrap: "off",
                dir: "auto",
                datatype: "wysiwyg",
                defaultValue: r,
                onFocus: x,
                onChange: _,
                onKeyDown: T,
                onBlur: I,
                onContextMenu: Tc
              })
            ) : null
          ]
        }
      )
    }
  );
}), ote = k.memo(function({
  w: e,
  h: n,
  strokeWidth: r,
  dash: a,
  color: s,
  fill: c
}) {
  const f = e / 2, p = n / 2, g = Math.max(0, f - r / 2), y = Math.max(0, p - r / 2), v = qy(g, y), { strokeDasharray: S, strokeDashoffset: x } = Ks(
    v < 64 ? v * 2 : v,
    r,
    {
      style: a,
      snap: 4,
      closed: !0
    }
  ), _ = `M${f - g},${p}a${g},${y},0,1,1,${g * 2},0a${g},${y},0,1,1,-${g * 2},0`;
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(ps, { d: _, color: s, fill: c }),
    /* @__PURE__ */ E.jsx(
      "path",
      {
        d: _,
        strokeWidth: r,
        width: ze(e),
        height: ze(n),
        fill: "none",
        stroke: "currentColor",
        strokeDasharray: S,
        strokeDashoffset: x,
        pointerEvents: "all"
      }
    )
  ] });
});
function ate({
  w: t,
  h: e,
  strokeWidth: n,
  dash: r,
  color: a,
  colors: s,
  fill: c
}) {
  const f = t / 2, p = e / 2, g = Math.max(0, f - n / 2), y = Math.max(0, p - n / 2), v = qy(g, y), { strokeDasharray: S, strokeDashoffset: x } = Ks(
    v < 64 ? v * 2 : v,
    n,
    {
      style: r,
      snap: 4,
      closed: !0
    }
  ), _ = `M${f - g},${p}a${g},${y},0,1,1,${g * 2},0a${g},${y},0,1,1,-${g * 2},0`, T = document.createElementNS("http://www.w3.org/2000/svg", "path");
  T.setAttribute("d", _), T.setAttribute("stroke-width", n.toString()), T.setAttribute("width", t.toString()), T.setAttribute("height", e.toString()), T.setAttribute("fill", "none"), T.setAttribute("stroke", s.fill[a]), T.setAttribute("stroke-dasharray", S), T.setAttribute("stroke-dashoffset", x);
  const I = $c({
    d: _,
    fill: c,
    color: a,
    colors: s
  });
  return lf(T, I);
}
function mj(t, e) {
  if (e > t) {
    const r = t / 2;
    return `
    M0,${r}
    a${r},${r},0,1,1,${r * 2},0
    L${t},${e - r}
    a${r},${r},0,1,1,-${r * 2},0
    Z`;
  }
  const n = e / 2;
  return `
    M${n},0
    L${t - n},0
    a${n},${n},0,1,1,0,${n * 2}
    L${n},${e}
    a${n},${n},0,1,1,0,${-n * 2}
    Z`;
}
function vj(t, e) {
  if (t > e) {
    const r = e / 2;
    return qy(r, r) + (t - r * 2) * 2;
  }
  const n = t / 2;
  return qy(n, n) + (e - n * 2) * 2;
}
const ste = k.memo(function({
  w: e,
  h: n,
  strokeWidth: r,
  dash: a,
  color: s,
  fill: c
}) {
  const f = mj(e, n), p = vj(e, n), { strokeDasharray: g, strokeDashoffset: y } = Ks(
    p < 64 ? p * 2 : p,
    r,
    {
      style: a,
      snap: 4,
      start: "outset",
      end: "outset",
      closed: !0
    }
  );
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(ps, { d: f, color: s, fill: c }),
    /* @__PURE__ */ E.jsx(
      "path",
      {
        d: f,
        strokeWidth: r,
        width: ze(e),
        height: ze(n),
        fill: "none",
        stroke: "currentColor",
        strokeDasharray: g,
        strokeDashoffset: y,
        pointerEvents: "all"
      }
    )
  ] });
});
function ID({
  w: t,
  h: e,
  strokeWidth: n,
  dash: r,
  color: a,
  colors: s,
  fill: c
}) {
  const f = mj(t, e), p = vj(t, e), { strokeDasharray: g, strokeDashoffset: y } = Ks(
    p < 64 ? p * 2 : p,
    n,
    {
      style: r,
      snap: 4,
      closed: !0
    }
  ), v = document.createElementNS("http://www.w3.org/2000/svg", "path");
  v.setAttribute("d", f), v.setAttribute("stroke-width", n.toString()), v.setAttribute("width", t.toString()), v.setAttribute("height", e.toString()), v.setAttribute("fill", "none"), v.setAttribute("stroke", s.fill[a]), v.setAttribute("stroke-dasharray", g), v.setAttribute("stroke-dashoffset", y);
  const S = $c({
    d: f,
    fill: c,
    color: a,
    colors: s
  });
  return lf(v, S);
}
const lte = k.memo(function({
  dash: e,
  fill: n,
  color: r,
  strokeWidth: a,
  outline: s,
  bgOutline: c
}) {
  const f = c ? "M" + c[0] + "L" + c.slice(1) + "Z" : "M" + s[0] + "L" + s.slice(1) + "Z";
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(ps, { d: f, fill: n, color: r }),
    /* @__PURE__ */ E.jsx("g", { strokeWidth: a, stroke: "currentColor", fill: "none", pointerEvents: "all", children: Array.from(Array(s.length)).map((p, g) => {
      const y = s[g], v = s[(g + 1) % s.length], S = O.Dist(y, v), { strokeDasharray: x, strokeDashoffset: _ } = Ks(S, a, {
        style: e,
        start: "outset",
        end: "outset"
      });
      return /* @__PURE__ */ E.jsx(
        "line",
        {
          x1: y.x,
          y1: y.y,
          x2: v.x,
          y2: v.y,
          strokeDasharray: x,
          strokeDashoffset: _
        },
        g
      );
    }) })
  ] });
});
function cte({
  dash: t,
  fill: e,
  color: n,
  colors: r,
  strokeWidth: a,
  outline: s,
  bgOutline: c
}) {
  const f = document.createElementNS("http://www.w3.org/2000/svg", "g");
  f.setAttribute("stroke-width", a.toString()), f.setAttribute("stroke", r.fill[n]), f.setAttribute("fill", "none"), Array.from(Array(s.length)).forEach((g, y) => {
    const v = s[y], S = s[(y + 1) % s.length], x = O.Dist(v, S), { strokeDasharray: _, strokeDashoffset: T } = Ks(x, a, {
      style: t
    }), I = document.createElementNS("http://www.w3.org/2000/svg", "line");
    I.setAttribute("x1", v.x.toString()), I.setAttribute("y1", v.y.toString()), I.setAttribute("x2", S.x.toString()), I.setAttribute("y2", S.y.toString()), I.setAttribute("stroke-dasharray", _.toString()), I.setAttribute("stroke-dashoffset", T.toString()), f.appendChild(I);
  });
  const p = $c({
    d: c ? "M" + c[0] + "L" + c.slice(1) + "Z" : "M" + s[0] + "L" + s.slice(1) + "Z",
    fill: e,
    color: n,
    colors: r
  });
  return lf(f, p);
}
const ute = k.memo(function({
  id: e,
  w: n,
  h: r,
  strokeWidth: a,
  fill: s,
  color: c
}) {
  const f = HI(e, n, r, a), p = Sj(e, n, r, a);
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(ps, { d: f, color: c, fill: s }),
    /* @__PURE__ */ E.jsx("path", { d: p, fill: "currentColor", strokeWidth: 0, pointerEvents: "all" })
  ] });
});
function dte({
  id: t,
  w: e,
  h: n,
  strokeWidth: r,
  fill: a,
  color: s,
  colors: c
}) {
  const f = document.createElementNS("http://www.w3.org/2000/svg", "path");
  f.setAttribute("d", Sj(t, e, n, r)), f.setAttribute("fill", c.fill[s]);
  const p = $c({
    d: HI(t, e, n, r),
    fill: a,
    color: s,
    colors: c
  });
  return lf(f, p);
}
function yj(t) {
  return {
    size: 1 + t,
    thinning: 0.25,
    end: { taper: t },
    start: { taper: t },
    streamline: 0,
    smoothing: 1,
    simulatePressure: !1
  };
}
function bj(t, e, n, r) {
  const a = Uy(t), s = e / 2, c = n / 2, f = qy(s, c), p = [], g = Kr * a(), y = Kr + cr / 2 + Math.abs(a()) * cr, v = Math.max(16, f / 10);
  for (let S = 0; S < v; S++) {
    const x = S / (v - 1), _ = g + x * y, T = Math.cos(_), I = Math.sin(_);
    p.push(
      new O(
        s * T + e * 0.5 + 0.05 * a(),
        c * I + n / 2 + 0.05 * a(),
        Math.min(
          1,
          0.5 + Math.abs(0.5 - (a() > 0 ? ua.easeInOutSine(x) : ua.easeInExpo(x))) / 2
        )
      )
    );
  }
  return _c(p, yj(r));
}
function Sj(t, e, n, r) {
  const a = yj(r);
  return Jd(
    Qy(
      Zy(bj(t, e, n, r), a),
      a
    )
  );
}
function HI(t, e, n, r) {
  return Gd(bj(t, e, n, r));
}
const fte = k.memo(function({
  id: e,
  bgOutline: n,
  outline: r,
  fill: a,
  color: s,
  strokeWidth: c
}) {
  const f = nb(e, r, c), p = VI(c), g = _c(f, p), y = Gd(
    n ? _c(nb(e, n, c), p) : g,
    !1
  ), v = Jd(u1(f, p));
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(ps, { d: y, fill: a, color: s }),
    /* @__PURE__ */ E.jsx("path", { d: v, fill: "currentColor", pointerEvents: "all" })
  ] });
});
function pte({
  id: t,
  outline: e,
  bgOutline: n,
  fill: r,
  color: a,
  colors: s,
  strokeWidth: c
}) {
  const f = nb(t, e, c), p = VI(c), g = document.createElementNS("http://www.w3.org/2000/svg", "path");
  g.setAttribute("d", Jd(u1(f, p), !0)), g.setAttribute("fill", s.fill[a]);
  const y = $c({
    d: Gd(
      _c(
        n ? nb(t, n, c) : f,
        p
      ),
      !1
    ),
    fill: r,
    color: a,
    colors: s
  });
  return lf(g, y);
}
function nb(t, e, n) {
  const r = [], a = Uy(t), s = Math.round(Math.abs(a()) * e.length), c = e.map(
    (p) => O.AddXY(p, a() * n / 4, a() * n / 4)
  ), f = c.length;
  for (let p = 0, g = f + 1; p < g; p++) {
    const y = c[(s + p) % f], v = c[(s + p + 1) % f], S = Math.min(O.Dist(y, v) / 2, n / 2), x = O.Nudge(y, v, S), _ = O.Med(y, v);
    if (p === 0)
      v.z = 0.7, r.push(new O(_.x, _.y, 0.7), v);
    else if (p === e.length) {
      const T = O.PointsBetween(x, _, 4);
      T.forEach((I) => I.z = 0.7), r.push(...T);
    } else
      r.push(...O.PointsBetween(x, v, 6));
  }
  return r;
}
function hte(t, e, n) {
  const r = nb(t, e, n), a = VI(n), s = _c(r, a);
  return Gd(s, !0);
}
function VI(t) {
  return {
    size: 1 + t * 0.618,
    last: !0,
    simulatePressure: !1,
    streamline: 0.25,
    thinning: 0.9
  };
}
const RD = k.memo(function({
  w: e,
  h: n,
  strokeWidth: r,
  fill: a,
  color: s
}) {
  const c = e / 2, f = n / 2, p = Math.max(0, c), g = Math.max(0, f), y = `M${c - p},${f}a${p},${g},0,1,1,${p * 2},0a${p},${g},0,1,1,-${p * 2},0`;
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(ps, { d: y, color: s, fill: a }),
    /* @__PURE__ */ E.jsx("path", { d: y, stroke: `var(--palette-${s})`, strokeWidth: r, fill: "none" })
  ] });
});
function gte({
  w: t,
  h: e,
  strokeWidth: n,
  fill: r,
  color: a,
  colors: s
}) {
  const c = t / 2, f = e / 2, p = Math.max(0, c), g = Math.max(0, f), y = `M${c - p},${f}a${p},${g},0,1,1,${p * 2},0a${p},${g},0,1,1,-${p * 2},0`, v = document.createElementNS("http://www.w3.org/2000/svg", "path");
  v.setAttribute("d", y), v.setAttribute("stroke-width", n.toString()), v.setAttribute("width", t.toString()), v.setAttribute("height", e.toString()), v.setAttribute("fill", "none"), v.setAttribute("stroke", s.fill[a]);
  const S = $c({
    d: y,
    fill: r,
    color: a,
    colors: s
  });
  return lf(v, S);
}
const mte = k.memo(function({
  w: e,
  h: n,
  strokeWidth: r,
  fill: a,
  color: s
}) {
  const c = YI(e, n);
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(ps, { d: c, color: s, fill: a }),
    /* @__PURE__ */ E.jsx("path", { d: c, stroke: `var(--palette-${s})`, strokeWidth: r, fill: "none" })
  ] });
});
function vte({
  w: t,
  h: e,
  strokeWidth: n,
  fill: r,
  color: a,
  colors: s
}) {
  const c = YI(t, e), f = document.createElementNS("http://www.w3.org/2000/svg", "path");
  f.setAttribute("d", c), f.setAttribute("stroke-width", n.toString()), f.setAttribute("width", t.toString()), f.setAttribute("height", e.toString()), f.setAttribute("fill", "none"), f.setAttribute("stroke", s.fill[a]);
  const p = $c({
    d: c,
    fill: r,
    color: a,
    colors: s
  });
  return lf(f, p);
}
function YI(t, e) {
  let n;
  if (e > t) {
    const r = t / 2;
    n = `
    M0,${r}
    a${r},${r},0,1,1,${r * 2},0
    L${t},${e - r}
    a${r},${r},0,1,1,-${r * 2},0
    Z`;
  } else {
    const r = e / 2;
    n = `
    M${r},0
    L${t - r},0
    a${r},${r},0,1,1,0,${r * 2}
    L${r},${e}
    a${r},${r},0,1,1,0,${-r * 2}
    Z`;
  }
  return n;
}
const $D = k.memo(function({
  outline: e,
  bgOutline: n,
  fill: r,
  color: a,
  strokeWidth: s
}) {
  const c = "M" + e[0] + "L" + e.slice(1) + "Z";
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(
      ps,
      {
        d: n ? "M" + n[0] + "L" + n.slice(1) + "Z" : c,
        fill: r,
        color: a
      }
    ),
    /* @__PURE__ */ E.jsx("path", { d: c, stroke: `var(--palette-${a}`, strokeWidth: s, fill: "none" })
  ] });
});
function yte({
  outline: t,
  bgOutline: e,
  fill: n,
  color: r,
  strokeWidth: a,
  colors: s
}) {
  const c = "M" + t[0] + "L" + t.slice(1) + "Z", f = document.createElementNS("http://www.w3.org/2000/svg", "path");
  f.setAttribute("d", c), f.setAttribute("stroke-width", a.toString()), f.setAttribute("stroke", s.fill[r]), f.setAttribute("fill", "none");
  const p = e ? "M" + e[0] + "L" + e.slice(1) + "Z" : c, g = $c({
    d: p,
    fill: n,
    color: r,
    colors: s
  });
  return lf(f, g);
}
const sk = 16, zs = 17 * 3;
class bte extends ma {
  static type = "geo";
  canEdit = () => !0;
  defaultProps() {
    return {
      w: 100,
      h: 100,
      geo: "rectangle",
      color: "black",
      labelColor: "black",
      fill: "none",
      dash: "draw",
      size: "m",
      opacity: "1",
      font: "draw",
      text: "",
      align: "middle",
      growY: 0,
      url: ""
    };
  }
  hitTestLineSegment(e, n, r) {
    let a = this.outline(e);
    e.props.geo === "x-box" && (a = zw(
      Math.max(1, e.props.w),
      Math.max(1, e.props.h + e.props.growY)
    ));
    for (let s = 0; s < a.length; s++) {
      const c = a[s], f = a[(s + 1) % a.length];
      if (Qd(n, r, c, f))
        return !0;
    }
    return !1;
  }
  getBounds(e) {
    return new ot(0, 0, e.props.w, e.props.h + e.props.growY);
  }
  getCenter(e) {
    return new O(e.props.w / 2, (e.props.h + e.props.growY) / 2);
  }
  getOutline(e) {
    const n = Math.max(1, e.props.w), r = Math.max(1, e.props.h + e.props.growY), a = n / 2, s = r / 2;
    switch (e.props.geo) {
      case "triangle":
        return [new O(a, 0), new O(n, r), new O(0, r)];
      case "diamond":
        return [new O(a, 0), new O(n, s), new O(a, r), new O(0, s)];
      case "pentagon":
        return WT(n, r, 5);
      case "hexagon":
        return WT(n, r, 6);
      case "octagon":
        return WT(n, r, 8);
      case "ellipse": {
        const c = Math.pow(a - s, 2) / Math.pow(a + s, 2), f = Yr * (a + s) * (1 + 3 * c / (10 + Math.sqrt(4 - 3 * c)));
        let p = Math.max(4, Math.ceil(f / 10));
        p = Math.ceil(p / 4) * 4;
        const g = Kr / p, y = Math.cos(g), v = Math.sin(g);
        let S = 0, x = 1, _ = 0, T = 1;
        const I = Array(p);
        for (let D = 0; D < p; D++)
          I[D] = new O(a + a * x, s + s * S), _ = v * x + y * S, T = y * x - v * S, S = _, x = T;
        return I;
      }
      case "oval": {
        const f = Array(20);
        if (r > n)
          for (let p = 0; p < 10; p++) {
            const g = -Yr + Yr * p / 8, y = Yr * p / (10 - 2);
            f[p] = new O(a + a * Math.cos(g), a + a * Math.sin(g)), f[p + 10] = new O(a + a * Math.cos(y), r - a + a * Math.sin(y));
          }
        else
          for (let p = 0; p < 10; p++) {
            const g = -cr + Yr * p / 8, y = cr + Yr * -p / (10 - 2);
            f[p] = new O(n - s + s * Math.cos(g), r - s + s * Math.sin(g)), f[p + 10] = new O(s - s * Math.cos(y), r - s + s * Math.sin(y));
          }
        return f;
      }
      case "star": {
        const f = Kr / 5 / 2, p = Math.floor(5 / 4) * 2, g = 5 * 2 - p, y = 0, v = Math.floor(5 / 2) * 2, S = Math.cos(-cr + p * f) * n / 2, x = Math.cos(-cr + g * f) * n / 2, _ = Math.sin(-cr + y * f) * r / 2, T = Math.sin(-cr + v * f) * r / 2, I = n - Math.abs(S - x), D = r - Math.abs(T - _), N = n / 2 + x - (n / 2 - S), j = r / 2 + _ - (r / 2 - T), L = 1, z = (n - N) / 2, F = (r - j) / 2, K = (n + I) / 2, X = (r + D) / 2, se = K * L / 2, ue = X * L / 2;
        return Array.from(Array(5 * 2)).map((pe, Pe) => {
          const ve = -cr + Pe * f;
          return new O(
            z + (Pe % 2 ? se : K) * Math.cos(ve),
            F + (Pe % 2 ? ue : X) * Math.sin(ve)
          );
        });
      }
      case "rhombus": {
        const c = Math.min(n * 0.38, r * 0.38);
        return [new O(c, 0), new O(n, 0), new O(n - c, r), new O(0, r)];
      }
      case "rhombus-2": {
        const c = Math.min(n * 0.38, r * 0.38);
        return [new O(0, 0), new O(n - c, 0), new O(n, r), new O(c, r)];
      }
      case "trapezoid": {
        const c = Math.min(n * 0.38, r * 0.38);
        return [new O(c, 0), new O(n - c, 0), new O(n, r), new O(0, r)];
      }
      case "arrow-right": {
        const c = Math.min(n, r) * 0.38, f = r * 0.16;
        return [
          new O(0, f),
          new O(n - c, f),
          new O(n - c, 0),
          new O(n, r / 2),
          new O(n - c, r),
          new O(n - c, r - f),
          new O(0, r - f)
        ];
      }
      case "arrow-left": {
        const c = Math.min(n, r) * 0.38, f = r * 0.16;
        return [
          new O(c, 0),
          new O(c, f),
          new O(n, f),
          new O(n, r - f),
          new O(c, r - f),
          new O(c, r),
          new O(0, r / 2)
        ];
      }
      case "arrow-up": {
        const c = n * 0.16, f = Math.min(n, r) * 0.38;
        return [
          new O(n / 2, 0),
          new O(n, f),
          new O(n - c, f),
          new O(n - c, r),
          new O(c, r),
          new O(c, f),
          new O(0, f)
        ];
      }
      case "arrow-down": {
        const c = n * 0.16, f = Math.min(n, r) * 0.38;
        return [
          new O(c, 0),
          new O(n - c, 0),
          new O(n - c, r - f),
          new O(n, r - f),
          new O(n / 2, r),
          new O(0, r - f),
          new O(c, r - f)
        ];
      }
      case "x-box":
      case "rectangle":
        return [new O(0, 0), new O(n, 0), new O(n, r), new O(0, r)];
    }
  }
  onEditEnd = (e) => {
    const {
      id: n,
      type: r,
      props: { text: a }
    } = e;
    a.trim() !== e.props.text && this.app.updateShapes([
      {
        id: n,
        type: r,
        props: {
          text: a.trim()
        }
      }
    ]);
  };
  render(e) {
    const { id: n, type: r, props: a } = e, s = un("zoom", () => this.app.zoomLevel < 0.35, []), c = this.app.getStrokeWidth(a.size), { w: f, color: p, labelColor: g, fill: y, dash: v, growY: S, font: x, align: _, size: T, text: I } = a, D = () => {
      const N = a.h + S;
      switch (a.geo) {
        case "ellipse":
          return v === "draw" ? s ? /* @__PURE__ */ E.jsx(RD, { strokeWidth: c, w: f, h: N, color: p, fill: y }) : /* @__PURE__ */ E.jsx(
            ute,
            {
              id: n,
              w: f,
              h: N,
              color: p,
              fill: y,
              strokeWidth: c
            }
          ) : v === "solid" ? /* @__PURE__ */ E.jsx(RD, { strokeWidth: c, w: f, h: N, color: p, fill: y }) : /* @__PURE__ */ E.jsx(
            ote,
            {
              id: n,
              strokeWidth: c,
              w: f,
              h: N,
              dash: v,
              color: p,
              fill: y
            }
          );
        case "oval":
          return v === "draw" || v === "solid" ? /* @__PURE__ */ E.jsx(mte, { strokeWidth: c, w: f, h: N, color: p, fill: y }) : /* @__PURE__ */ E.jsx(
            ste,
            {
              id: n,
              strokeWidth: c,
              w: f,
              h: N,
              dash: v,
              color: p,
              fill: y
            }
          );
        default: {
          let j = this.outline(e), L;
          return e.props.geo === "x-box" && (L = j, j = zw(
            Math.max(1, e.props.w),
            Math.max(1, e.props.h + e.props.growY)
          )), v === "draw" ? s ? /* @__PURE__ */ E.jsx(
            $D,
            {
              fill: y,
              color: p,
              strokeWidth: c,
              outline: j,
              bgOutline: L
            }
          ) : /* @__PURE__ */ E.jsx(
            fte,
            {
              id: n,
              fill: y,
              color: p,
              strokeWidth: c,
              outline: j,
              bgOutline: L
            }
          ) : v === "solid" ? /* @__PURE__ */ E.jsx(
            $D,
            {
              fill: y,
              color: p,
              strokeWidth: c,
              outline: j,
              bgOutline: L
            }
          ) : /* @__PURE__ */ E.jsx(
            lte,
            {
              dash: v,
              fill: y,
              color: p,
              strokeWidth: c,
              outline: j,
              bgOutline: L
            }
          );
        }
      }
    };
    return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(Rp, { id: n, children: D() }),
      /* @__PURE__ */ E.jsx(
        gj,
        {
          id: n,
          type: r,
          font: x,
          fill: y,
          size: T,
          align: _,
          text: I,
          labelColor: this.app.getCssColor(g),
          wrap: !0
        }
      ),
      "url" in e.props && e.props.url && /* @__PURE__ */ E.jsx(_b, { url: e.props.url })
    ] });
  }
  indicator(e) {
    const { id: n, props: r } = e, { w: a, h: s, growY: c, size: f } = r, p = this.app.getStrokeWidth(f);
    switch (r.geo) {
      case "ellipse":
        return r.dash === "draw" ? /* @__PURE__ */ E.jsx("path", { d: HI(n, a, s + c, p) }) : /* @__PURE__ */ E.jsx("ellipse", { cx: a / 2, cy: (s + c) / 2, rx: a / 2, ry: (s + c) / 2 });
      case "oval":
        return /* @__PURE__ */ E.jsx("path", { d: YI(a, s + c) });
      default: {
        let g = this.outline(e);
        return e.props.geo === "x-box" && (g = zw(
          Math.max(1, e.props.w),
          Math.max(1, e.props.h + e.props.growY)
        )), r.dash === "draw" ? /* @__PURE__ */ E.jsx("path", { d: hte(n, g, p) }) : /* @__PURE__ */ E.jsx("path", { d: `M${g[0]}L${g.slice(1)}Z` });
      }
    }
  }
  toSvg(e, n, r) {
    const { id: a, props: s } = e, c = this.app.getStrokeWidth(s.size);
    let f;
    switch (s.geo) {
      case "ellipse": {
        switch (s.dash) {
          case "draw":
            f = dte({
              id: a,
              w: s.w,
              h: s.h,
              color: s.color,
              fill: s.fill,
              strokeWidth: c,
              colors: r
            });
            break;
          case "solid":
            f = gte({
              strokeWidth: c,
              w: s.w,
              h: s.h,
              color: s.color,
              fill: s.fill,
              colors: r
            });
            break;
          default:
            f = ate({
              id: a,
              strokeWidth: c,
              w: s.w,
              h: s.h,
              dash: s.dash,
              color: s.color,
              fill: s.fill,
              colors: r
            });
            break;
        }
        break;
      }
      case "oval": {
        switch (s.dash) {
          case "draw":
            f = ID({
              id: a,
              strokeWidth: c,
              w: s.w,
              h: s.h,
              dash: s.dash,
              color: s.color,
              fill: s.fill,
              colors: r
            });
            break;
          case "solid":
            f = vte({
              strokeWidth: c,
              w: s.w,
              h: s.h,
              color: s.color,
              fill: s.fill,
              colors: r
            });
            break;
          default:
            f = ID({
              id: a,
              strokeWidth: c,
              w: s.w,
              h: s.h,
              dash: s.dash,
              color: s.color,
              fill: s.fill,
              colors: r
            });
        }
        break;
      }
      default: {
        let p = this.outline(e), g;
        switch (s.geo === "x-box" && (g = p, p = zw(
          Math.max(1, e.props.w),
          Math.max(1, e.props.h + e.props.growY)
        )), s.dash) {
          case "draw":
            f = pte({
              id: a,
              fill: s.fill,
              color: s.color,
              strokeWidth: c,
              outline: p,
              bgOutline: g,
              colors: r
            });
            break;
          case "solid":
            f = yte({
              fill: s.fill,
              color: s.color,
              strokeWidth: c,
              outline: p,
              bgOutline: g,
              colors: r
            });
            break;
          default:
            f = cte({
              dash: s.dash,
              fill: s.fill,
              color: s.color,
              strokeWidth: c,
              outline: p,
              bgOutline: g,
              colors: r
            });
            break;
        }
        break;
      }
    }
    if (s.text) {
      const p = this.bounds(e), g = {
        fontSize: Kd[e.props.size],
        fontFamily: n,
        textAlign: e.props.align,
        padding: 16,
        lineHeight: Yi.lineHeight,
        fontStyle: "normal",
        fontWeight: "normal",
        width: Math.ceil(p.width),
        height: Math.ceil(p.height)
      }, y = this.app.textMeasure.getTextLines({
        text: s.text,
        wrap: !0,
        ...g
      }), v = document.createElementNS("http://www.w3.org/2000/svg", "g"), S = jw(this.app, e), x = h1(this.app, {
        ...g,
        lines: y,
        strokeWidth: 2,
        stroke: r.background,
        fill: r.background,
        width: S.w
      });
      x.setAttribute("transform", `translate(${(p.width - S.w) / 2}, 0)`);
      const _ = x.cloneNode(!0);
      if (_.setAttribute("fill", r.fill[e.props.labelColor]), _.setAttribute("stroke", "none"), v.append(x), v.append(_), f.nodeName === "g")
        return f.appendChild(v), f;
      {
        const T = document.createElementNS("http://www.w3.org/2000/svg", "g");
        return T.appendChild(f), T.appendChild(v), T;
      }
    }
    return f;
  }
  onResize = (e, { initialBounds: n, handle: r, newPoint: a, scaleX: s, scaleY: c }) => {
    let f = n.width * s, p = n.height * c, g = 0, y = 0;
    if (e.props.text.trim()) {
      let _ = Math.max(Math.abs(f), zs), T = Math.max(Math.abs(p), zs);
      _ < zs && T === zs && (_ = zs), _ === zs && T < zs && (T = zs);
      const I = jw(this.app, {
        ...e,
        props: {
          ...e.props,
          w: _,
          h: T
        }
      }), D = Math.max(Math.abs(f), I.w) * Math.sign(f), N = Math.max(Math.abs(p), I.h) * Math.sign(p);
      g = Math.abs(D) - Math.abs(f), y = Math.abs(N) - Math.abs(p), f = D, p = N;
    }
    const v = new O(0, 0);
    s < 0 && (v.x += f), (r === "left" || r === "top_left" || r === "bottom_left") && (v.x += s < 0 ? g : -g), c < 0 && (v.y += p), (r === "top" || r === "top_left" || r === "top_right") && (v.y += c < 0 ? y : -y);
    const { x: S, y: x } = v.rot(e.rotation).add(a);
    return {
      x: S,
      y: x,
      props: {
        w: Math.max(Math.abs(f), 1),
        h: Math.max(Math.abs(p), 1),
        growY: 0
      }
    };
  };
  onBeforeCreate = (e) => {
    if (!e.props.text)
      return e.props.growY ? {
        ...e,
        props: {
          ...e.props,
          growY: 0
        }
      } : void 0;
    const n = e.props.h, r = jw(this.app, e).h;
    let a = null;
    if (r > n ? a = r - n : e.props.growY && (a = 0), a !== null)
      return {
        ...e,
        props: {
          ...e.props,
          growY: a
        }
      };
  };
  onBeforeUpdate = (e, n) => {
    const r = e.props.text.trim(), a = n.props.text.trim();
    if (r === a && e.props.font === n.props.font && e.props.size === n.props.size)
      return;
    if (r && !a)
      return {
        ...n,
        props: {
          ...n.props,
          growY: 0
        }
      };
    const s = e.props.w, c = e.props.h, f = jw(this.app, n), p = f.w, g = f.h;
    if (!r && a && a.length === 1) {
      let v = Math.max(s, p), S = Math.max(c, g);
      return e.props.w < zs && e.props.h < zs && (v = Math.max(v, zs), S = Math.max(S, zs), v = Math.max(v, S), S = Math.max(v, S)), {
        ...n,
        props: {
          ...n.props,
          w: v,
          h: S,
          growY: 0
        }
      };
    }
    let y = null;
    if (g > c ? y = g - c : e.props.growY && (y = 0), y !== null)
      return {
        ...n,
        props: {
          ...n.props,
          growY: y,
          w: p
        }
      };
    if (p > e.props.w)
      return {
        ...n,
        props: {
          ...n.props,
          w: p
        }
      };
  };
}
function jw(t, e) {
  const n = e.props.text.trim();
  if (!n)
    return { w: 0, h: 0 };
  const r = t.textMeasure.measureText({
    ...Yi,
    text: "w",
    fontFamily: Wd[e.props.font],
    fontSize: Kd[e.props.size],
    width: "fit-content",
    maxWidth: "100px"
  }), a = {
    s: 2,
    m: 3.5,
    l: 5,
    xl: 10
  }, s = t.textMeasure.measureText({
    ...Yi,
    text: n,
    fontFamily: Wd[e.props.font],
    fontSize: Kd[e.props.size],
    width: "fit-content",
    minWidth: r.w + "px",
    maxWidth: Math.max(
      // Guard because a DOM nodes can't be less 0
      0,
      // A 'w' width that we're setting as the min-width
      Math.ceil(r.w + a[e.props.size]),
      // The actual text size
      Math.ceil(e.props.w - sk * 2)
    ) + "px"
  });
  return {
    w: s.w + sk * 2,
    h: s.h + sk * 2
  };
}
function zw(t, e) {
  return [
    new O(0, 0),
    new O(t, 0),
    new O(t, e),
    new O(0, e),
    new O(0, 0),
    new O(t * 0.5, e * 0.5),
    new O(t, e),
    new O(t, 0),
    new O(t * 0.5, e * 0.5),
    new O(0, e)
  ];
}
const wj = pi({
  type: "geo",
  getShapeUtil: () => bte,
  validator: bq,
  migrations: Sq
});
class Ste extends Mc {
  static type = "group";
  hideSelectionBoundsBg = () => !1;
  hideSelectionBoundsFg = () => !0;
  canBind = () => !1;
  defaultProps() {
    return { opacity: "1" };
  }
  getBounds(e) {
    const n = this.app.getSortedChildIds(e.id);
    if (n.length === 0)
      return new ot();
    const r = n.flatMap((a) => {
      const s = this.app.getShapeById(a);
      return this.app.getOutlineById(a).map((c) => De.applyToPoint(this.app.getTransform(s), c));
    });
    return ot.FromPoints(r);
  }
  getCenter(e) {
    return this.bounds(e).center;
  }
  getOutline(e) {
    return this.bounds(e).corners;
  }
  render(e) {
    const {
      erasingIdsSet: n,
      pageState: { hintingIds: r, focusLayerId: a },
      zoomLevel: s
    } = this.app, c = n.has(e.id), f = r.length > 0 && r.some((g) => g !== e.id && this.app.getShapeById(g)?.type === "group");
    if (
      // always show the outline while we're erasing the group
      !c && // show the outline while the group is focused unless something outside of the group is being hinted
      // this happens dropping shapes from a group onto some outside group
      (e.id !== a || f)
    )
      return null;
    const p = this.bounds(e);
    return /* @__PURE__ */ E.jsx(Rp, { id: e.id, children: /* @__PURE__ */ E.jsx(MD, { className: "rs-group", bounds: p, zoomLevel: s }) });
  }
  indicator(e) {
    const {
      camera: { z: n }
    } = this.app, r = this.bounds(e);
    return /* @__PURE__ */ E.jsx(MD, { className: "", bounds: r, zoomLevel: n });
  }
  onChildrenChange = (e) => {
    const n = this.app.getSortedChildIds(e.id);
    if (n.length === 0) {
      this.app.pageState.focusLayerId === e.id && this.app.popFocusLayer(), this.app.deleteShapes([e.id]);
      return;
    } else if (n.length === 1) {
      this.app.pageState.focusLayerId === e.id && this.app.popFocusLayer(), this.app.reparentShapesById(n, e.parentId), this.app.deleteShapes([e.id]);
      return;
    }
  };
}
const xj = pi({
  type: "group",
  getShapeUtil: () => Ste,
  validator: wq,
  migrations: xq
});
function MD({
  bounds: t,
  zoomLevel: e,
  className: n
}) {
  return /* @__PURE__ */ E.jsx("g", { className: n, pointerEvents: "none", strokeLinecap: "round", strokeLinejoin: "round", children: t.sides.map((r, a) => {
    const { strokeDasharray: s, strokeDashoffset: c } = Ks(
      r[0].dist(r[1]),
      1 / e,
      {
        style: "dashed",
        lengthRatio: 4
      }
    );
    return /* @__PURE__ */ E.jsx(
      "line",
      {
        x1: r[0].x,
        y1: r[0].y,
        x2: r[1].x,
        y2: r[1].y,
        strokeDasharray: s,
        strokeDashoffset: c
      },
      a
    );
  }) });
}
const wte = async (t) => new Promise((e, n) => {
  const r = new Image();
  r.onload = () => e(r), r.onerror = () => n(new Error("Failed to load image")), r.crossOrigin = "anonymous", r.src = t;
}), xte = async (t) => {
  const e = await wte(t), n = document.createElement("canvas");
  n.width = e.width, n.height = e.height;
  const r = n.getContext("2d");
  if (r)
    return r.drawImage(e, 0, 0), n.toDataURL();
};
async function Ete(t) {
  const n = await (await fetch(t)).blob();
  return new Promise((r, a) => {
    const s = new FileReader();
    s.onloadend = () => r(s.result), s.onerror = a, s.readAsDataURL(n);
  });
}
class Cte extends ma {
  static type = "image";
  isAspectRatioLocked = () => !0;
  defaultProps() {
    return {
      opacity: "1",
      w: 100,
      h: 100,
      assetId: null,
      playing: !0,
      url: ""
    };
  }
  render(e) {
    const [n, r] = k.useState(""), a = KL(), s = e.props.assetId ? this.app.getAssetById(e.props.assetId) : void 0, { w: c, h: f } = e.props;
    if (k.useEffect(() => {
      if (s?.props.src && "mimeType" in s.props && s?.props.mimeType === "image/gif") {
        let g = !1;
        return (async () => {
          const v = await xte(s.props.src);
          g || v && r(v);
        })(), () => {
          g = !0;
        };
      }
    }, [a, s?.props]), s?.type === "bookmark")
      throw Error("Bookmark assets can't be rendered as images");
    const p = a && (s?.props.mimeType?.includes("video") || s?.props.mimeType?.includes("gif"));
    return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(fa, { id: e.id, children: /* @__PURE__ */ E.jsxs("div", { className: "rs-image-container", children: [
        s?.props.src ? /* @__PURE__ */ E.jsx(
          "div",
          {
            className: `rs-image rs-image-${e.id}`,
            style: {
              backgroundImage: `url(${!e.props.playing || p ? n : s.props.src}`
            },
            draggable: !1
          }
        ) : /* @__PURE__ */ E.jsx(m1, { x: (c - 38) / 2, y: (f - 38) / 2 }),
        s?.props.isAnimated && !e.props.playing && /* @__PURE__ */ E.jsx("div", { className: "rs-image__meda-tag", children: "GIF" })
      ] }) }),
      "url" in e.props && e.props.url && /* @__PURE__ */ E.jsx(_b, { url: e.props.url })
    ] });
  }
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: ze(e.props.w), height: ze(e.props.h) });
  }
  async toSvg(e) {
    const n = document.createElementNS("http://www.w3.org/2000/svg", "g");
    let a = (e.props.assetId ? this.app.getAssetById(e.props.assetId) : null)?.props.src || "";
    a && a.startsWith("http") && (a = await Ete(a) || "");
    const s = document.createElementNS("http://www.w3.org/2000/svg", "image");
    return s.setAttributeNS("http://www.w3.org/1999/xlink", "href", a), s.setAttribute("width", e.props.w.toString()), s.setAttribute("height", e.props.h.toString()), n.appendChild(s), n;
  }
  onDoubleClick = (e) => {
    const n = e.props.assetId ? this.app.getAssetById(e.props.assetId) : void 0;
    !n || !(n.props.src && "mimeType" in n.props && n.props.mimeType === "image/gif") || this.app.updateShapes([
      {
        type: "image",
        id: e.id,
        props: {
          playing: !e.props.playing
        }
      }
    ]);
  };
}
const _te = pi({
  type: "image",
  getShapeUtil: () => Cte,
  validator: Eq,
  migrations: Cq
});
function Ej(t) {
  const { segments: e } = t, n = [];
  for (let r = 0, a = e.length; r < a; r++) {
    const c = e[r].lut, f = c.length - 1;
    r > 0 ? n.push(O.Lrp(c[0], c[1], 0.25)) : n.push(c[0]);
    for (let p = 1; p < f; p++)
      n.push(c[p]);
    r < a - 1 ? n.push(O.Lrp(c[f - 1], c[f], 0.75)) : n.push(c[f]);
  }
  return n;
}
function Cj(t) {
  return {
    size: t * 1.25,
    thinning: 0.4,
    streamline: 0,
    smoothing: 0.5,
    simulatePressure: !0,
    last: !0
  };
}
function _j(t, e, n) {
  const r = Ej(e), a = Cj(n);
  return _c(r, a);
}
function Tte(t, e, n) {
  const r = Cj(n);
  return Qy(
    Zy(_j(t, e, n), r),
    r
  );
}
function Tj(t, e, n) {
  const r = Tte(t, e, n);
  return Jd(r);
}
function kte(t, e, n) {
  if (t.props.dash === "draw") {
    const r = _j(t, e, n);
    return Gd(r);
  }
  return e.path;
}
function Pte({
  shape: t,
  strokeWidth: e,
  spline: n,
  color: r
}) {
  const a = Tj(t, n, e), s = document.createElementNS("http://www.w3.org/2000/svg", "path");
  return s.setAttribute("stroke-width", "0"), s.setAttribute("stroke", "none"), s.setAttribute("fill", r), s.setAttribute("d", a), s;
}
function Ite({
  dash: t,
  strokeWidth: e,
  spline: n,
  color: r
}) {
  const { segments: a } = n, s = document.createElementNS("http://www.w3.org/2000/svg", "g");
  return s.setAttribute("stroke", r), s.setAttribute("stroke-width", e.toString()), a.forEach((c, f) => {
    const p = document.createElementNS("http://www.w3.org/2000/svg", "path"), { strokeDasharray: g, strokeDashoffset: y } = Ks(c.length, e, {
      style: t,
      start: f > 0 ? "outset" : "none",
      end: f < a.length - 1 ? "outset" : "none"
    });
    p.setAttribute("stroke-dasharray", g.toString()), p.setAttribute("stroke-dashoffset", y.toString()), p.setAttribute("d", c.path), p.setAttribute("fill", "none"), s.appendChild(p);
  }), s;
}
function Rte({
  strokeWidth: t,
  spline: e,
  color: n
}) {
  const { path: r } = e, a = document.createElementNS("http://www.w3.org/2000/svg", "path");
  return a.setAttribute("stroke-width", t.toString()), a.setAttribute("stroke", n), a.setAttribute("fill", "none"), a.setAttribute("d", r), a;
}
function $te(t, e, n, r) {
  switch (t.props.dash) {
    case "draw":
      return Pte({
        shape: t,
        strokeWidth: r,
        spline: e,
        color: n
      });
    case "solid":
      return Rte({
        strokeWidth: r,
        spline: e,
        color: n
      });
    default:
      return Ite({
        strokeWidth: r,
        spline: e,
        dash: t.props.dash,
        color: n
      });
  }
}
const Mte = new lm(), Ate = new lm();
class Ote extends Mc {
  static type = "line";
  hideResizeHandles = () => !0;
  hideRotateHandle = () => !0;
  hideSelectionBoundsBg = () => !0;
  hideSelectionBoundsFg = () => !0;
  isClosed = () => !1;
  defaultProps() {
    return {
      opacity: "1",
      dash: "draw",
      size: "m",
      color: "black",
      spline: "line",
      handles: {
        start: {
          id: "start",
          type: "vertex",
          canBind: !1,
          index: "a1",
          x: 0,
          y: 0
        },
        end: {
          id: "end",
          type: "vertex",
          canBind: !1,
          index: "a2",
          x: 0,
          y: 0
        }
      }
    };
  }
  getBounds(e) {
    return bp(e).bounds;
  }
  getCenter(e) {
    return this.bounds(e).center;
  }
  getHandles(e) {
    return Ate.get(e.props, () => {
      const n = e.props.handles, r = bp(e), a = Object.values(n).sort(Ha), s = a.slice();
      for (let c = 0; c < r.segments.length; c++) {
        const p = r.segments[c].getPoint(0.5), g = Fy(a[c].index, a[c + 1].index);
        s.push({
          id: `mid-${c}`,
          type: "create",
          index: g,
          x: p.x,
          y: p.y
        });
      }
      return s.sort(Ha);
    });
  }
  getOutline(e) {
    return Ej(bp(e));
  }
  //   Events
  onResize = (e, n) => {
    const { scaleX: r, scaleY: a } = n, s = Cc(e.props.handles);
    return Object.values(e.props.handles).forEach(({ id: c, x: f, y: p }) => {
      s[c].x = f * r, s[c].y = p * a;
    }), {
      props: {
        handles: s
      }
    };
  };
  onHandleChange = (e, { handle: n }) => {
    const r = Cc(e);
    switch (n.id) {
      case "start":
      case "end": {
        r.props.handles[n.id] = {
          ...r.props.handles[n.id],
          x: n.x,
          y: n.y
        };
        break;
      }
      default: {
        const a = "handle:" + n.index, s = e.props.handles[a];
        s ? r.props.handles[a] = {
          ...s,
          x: n.x,
          y: n.y
        } : r.props.handles[a] = {
          id: a,
          type: "vertex",
          canBind: !1,
          index: n.index,
          x: n.x,
          y: n.y
        };
        break;
      }
    }
    return r;
  };
  hitTestPoint(e, n) {
    return zq(n, this.outline(e));
  }
  hitTestLineSegment(e, n, r) {
    return kI(n, r, this.outline(e)) !== null;
  }
  render(e) {
    const n = bp(e), r = un("zoom", () => this.app.zoomLevel < 0.35, []), a = this.app.getStrokeWidth(e.props.size), s = n.path, { dash: c, color: f } = e.props;
    return /* @__PURE__ */ E.jsxs(Rp, { id: e.id, children: [
      /* @__PURE__ */ E.jsx(ps, { d: s, fill: "none", color: f }),
      c === "draw" && !r ? /* @__PURE__ */ E.jsx(
        "path",
        {
          d: Tj(e, n, a),
          strokeWidth: 1,
          stroke: "currentColor",
          fill: "currentColor"
        }
      ) : c === "solid" ? /* @__PURE__ */ E.jsx("path", { strokeWidth: a, stroke: "currentColor", fill: "none", d: s }) : /* @__PURE__ */ E.jsx("g", { stroke: "currentColor", strokeWidth: a, children: n.segments.map((p, g) => {
        const { strokeDasharray: y, strokeDashoffset: v } = Ks(
          p.length,
          a,
          {
            style: c,
            start: g > 0 ? "outset" : "none",
            end: g < n.segments.length - 1 ? "outset" : "none"
          }
        );
        return /* @__PURE__ */ E.jsx(
          "path",
          {
            strokeDasharray: y,
            strokeDashoffset: v,
            d: p.path,
            fill: "none"
          },
          g
        );
      }) })
    ] });
  }
  indicator(e) {
    const n = this.app.getStrokeWidth(e.props.size), r = kte(e, bp(e), n);
    return /* @__PURE__ */ E.jsx("path", { d: r });
  }
  toSvg(e, n, r) {
    const { color: a, size: s } = e.props, c = r.fill[a], f = bp(e);
    return $te(e, f, c, this.app.getStrokeWidth(s));
  }
}
const kj = pi({
  type: "line",
  getShapeUtil: () => Ote,
  validator: _q,
  migrations: Tq
});
function bp(t) {
  return Mte.get(t.props, () => {
    const { spline: e, handles: n } = t.props, r = Object.values(n).sort(Ha).map(O.From);
    switch (e) {
      case "cubic":
        return new CI(r, r.length === 2 ? 2 : 1.2, 20);
      case "line":
        return new _I(r);
    }
  });
}
const xc = 200;
class Dte extends Mc {
  static type = "note";
  canEdit = () => !0;
  hideResizeHandles = () => !0;
  hideSelectionBoundsBg = () => !0;
  hideSelectionBoundsFg = () => !0;
  defaultProps() {
    return {
      opacity: "1",
      color: "black",
      size: "m",
      text: "",
      font: "draw",
      align: "middle",
      growY: 0,
      url: ""
    };
  }
  getHeight(e) {
    return xc + e.props.growY;
  }
  getBounds(e) {
    const n = this.getHeight(e);
    return new ot(0, 0, xc, n);
  }
  getOutline(e) {
    return this.bounds(e).corners;
  }
  getCenter(e) {
    return new O(xc / 2, this.getHeight(e) / 2);
  }
  render(e) {
    const {
      id: n,
      type: r,
      props: { color: a, font: s, size: c, align: f, text: p }
    } = e, g = a === "black" ? "yellow" : a;
    return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(
        "div",
        {
          style: {
            position: "absolute",
            width: xc,
            height: this.getHeight(e)
          },
          children: /* @__PURE__ */ E.jsxs(
            "div",
            {
              className: "rs-note__container rs-hitarea-fill",
              style: {
                color: `var(--palette-${g})`,
                backgroundColor: `var(--palette-${g})`
              },
              children: [
                /* @__PURE__ */ E.jsx("div", { className: "rs-note__scrim" }),
                /* @__PURE__ */ E.jsx(
                  gj,
                  {
                    id: n,
                    type: r,
                    font: s,
                    size: c,
                    align: f,
                    text: p,
                    labelColor: "inherit",
                    wrap: !0
                  }
                )
              ]
            }
          )
        }
      ),
      "url" in e.props && e.props.url && /* @__PURE__ */ E.jsx(_b, { url: e.props.url })
    ] });
  }
  indicator(e) {
    return /* @__PURE__ */ E.jsx(
      "rect",
      {
        rx: "7",
        width: ze(xc),
        height: ze(this.getHeight(e))
      }
    );
  }
  toSvg(e, n, r) {
    const a = this.bounds(e), s = document.createElementNS("http://www.w3.org/2000/svg", "g"), c = e.props.color === "black" ? "yellow" : e.props.color, f = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    f.setAttribute("rx", "10"), f.setAttribute("width", xc.toString()), f.setAttribute("height", a.height.toString()), f.setAttribute("fill", r.fill[c]), f.setAttribute("stroke", r.fill[c]), f.setAttribute("stroke-width", "1"), s.appendChild(f);
    const p = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    p.setAttribute("rx", "10"), p.setAttribute("width", xc.toString()), p.setAttribute("height", a.height.toString()), p.setAttribute("fill", r.background), p.setAttribute("opacity", ".28"), s.appendChild(p);
    const g = 17, y = {
      fontSize: Kd[e.props.size],
      fontFamily: n,
      textAlign: e.props.align,
      width: a.width - g * 2,
      height: a.height - g * 2,
      padding: 0,
      lineHeight: Yi.lineHeight,
      fontStyle: "normal",
      fontWeight: "normal"
    }, v = this.app.textMeasure.getTextLines({
      text: e.props.text,
      wrap: !0,
      ...y
    }), S = h1(this.app, {
      lines: v,
      ...y
    });
    return S.setAttribute("fill", r.text), S.setAttribute("transform", `translate(${g} ${g})`), s.appendChild(S), s;
  }
  onBeforeCreate = (e) => AD(this.app, e, e.props.growY);
  onBeforeUpdate = (e, n) => {
    if (!(e.props.text === n.props.text && e.props.font === n.props.font && e.props.size === n.props.size))
      return AD(this.app, n, e.props.growY);
  };
  onEditEnd = (e) => {
    const {
      id: n,
      type: r,
      props: { text: a }
    } = e;
    a.trim() !== e.props.text && this.app.updateShapes([
      {
        id: n,
        type: r,
        props: {
          text: a.trim()
        }
      }
    ]);
  };
}
const lP = pi({
  getShapeUtil: () => Dte,
  type: "note",
  validator: kq,
  migrations: Pq
});
function AD(t, e, n = 0) {
  const s = t.textMeasure.measureText({
    ...Yi,
    text: e.props.text,
    fontFamily: Wd[e.props.font],
    fontSize: Kd[e.props.size],
    width: xc - 34 + "px"
  }).h + 17 * 2;
  let c = null;
  if (s > xc ? c = s - xc : n && (c = 0), c !== null)
    return {
      ...e,
      props: {
        ...e.props,
        growY: c
      }
    };
}
function Nte(t, {
  initialBounds: e,
  scaleX: n,
  scaleY: r,
  newPoint: a
}) {
  const s = Math.max(0.01, Math.min(Math.abs(n), Math.abs(r))), c = new O(0, 0);
  n < 0 && (c.x = -(e.width * s)), r < 0 && (c.y = -(e.height * s));
  const { x: f, y: p } = O.Add(a, c.rot(t.rotation));
  return {
    x: f,
    y: p,
    props: {
      scale: s * t.props.scale
    }
  };
}
const Lte = new lm();
class jte extends Mc {
  static type = "text";
  canEdit = () => !0;
  isAspectRatioLocked = () => !0;
  defaultProps() {
    return {
      opacity: "1",
      color: "black",
      size: "m",
      w: 8,
      text: "",
      font: "draw",
      align: "middle",
      autoSize: !0,
      scale: 1
    };
  }
  // @computed
  // private get minDimensionsCache() {
  // 	return this.app.store.createSelectedComputedCache<
  // 		TLTextShape['props'],
  // 		{ width: number; height: number },
  // 		TLTextShape
  // 	>(
  // 		'text measure cache',
  // 		(shape) => {
  // 			return shape.props
  // 		},
  // 		(props) => getTextSize(this.app, props)
  // 	)
  // }
  getMinDimensions(e) {
    return Lte.get(e.props, (n) => OD(this.app, n));
  }
  getBounds(e) {
    const { scale: n } = e.props, { width: r, height: a } = this.getMinDimensions(e);
    return new ot(0, 0, r * n, a * n);
  }
  getOutline(e) {
    const n = this.bounds(e);
    return [
      new O(0, 0),
      new O(n.width, 0),
      new O(n.width, n.height),
      new O(0, n.height)
    ];
  }
  getCenter(e) {
    const n = this.bounds(e);
    return new O(n.width / 2, n.height / 2);
  }
  render(e) {
    const {
      id: n,
      type: r,
      props: { text: a }
    } = e, { width: s, height: c } = this.getMinDimensions(e), {
      rInput: f,
      isEmpty: p,
      isEditing: g,
      isEditableFromHover: y,
      handleFocus: v,
      handleChange: S,
      handleKeyDown: x,
      handleBlur: _
    } = BI(n, r, a);
    return /* @__PURE__ */ E.jsx(fa, { id: e.id, children: /* @__PURE__ */ E.jsxs(
      "div",
      {
        className: "rs-text-shape__wrapper rs-text-shadow",
        "data-font": e.props.font,
        "data-align": e.props.align,
        "data-hastext": !p,
        "data-isediting": g || y,
        "data-textwrap": !0,
        style: {
          fontSize: Bg[e.props.size],
          lineHeight: Bg[e.props.size] * Yi.lineHeight + "px",
          transform: `scale(${e.props.scale})`,
          transformOrigin: "top left",
          width: Math.max(1, s),
          height: Math.max(Bg[e.props.size] * Yi.lineHeight, c)
        },
        children: [
          /* @__PURE__ */ E.jsx("div", { className: "rs-text rs-text-content", dir: "ltr", children: a }),
          g || y ? /* @__PURE__ */ E.jsx(
            "textarea",
            {
              ref: f,
              className: "rs-text rs-text-input",
              name: "text",
              tabIndex: -1,
              autoComplete: "false",
              autoCapitalize: "false",
              autoCorrect: "false",
              autoSave: "false",
              autoFocus: g,
              placeholder: "",
              spellCheck: "true",
              wrap: "off",
              dir: "ltr",
              datatype: "wysiwyg",
              defaultValue: a,
              onFocus: v,
              onChange: S,
              onKeyDown: x,
              onBlur: _,
              onTouchEnd: Tc,
              onContextMenu: Tc
            }
          ) : null
        ]
      }
    ) });
  }
  indicator(e) {
    const n = this.bounds(e);
    return /* @__PURE__ */ E.jsx("rect", { width: ze(n.width), height: ze(n.height) });
  }
  toSvg(e, n, r) {
    const a = this.bounds(e), s = e.props.text, c = a.width / (e.props.scale ?? 1), f = a.height / (e.props.scale ?? 1), p = {
      fontSize: Bg[e.props.size],
      fontFamily: n,
      textAlign: e.props.align,
      width: c,
      height: f,
      padding: 0,
      // no padding?
      lineHeight: Yi.lineHeight,
      fontStyle: "normal",
      fontWeight: "normal"
    }, g = this.app.textMeasure.getTextLines({
      text: s,
      wrap: !0,
      ...p
    }), y = r.fill[e.props.color], v = document.createElementNS("http://www.w3.org/2000/svg", "g"), S = h1(this.app, {
      lines: g,
      ...p,
      stroke: r.background,
      strokeWidth: 2,
      fill: r.background,
      padding: 0
    }), x = S.cloneNode(!0);
    return x.setAttribute("fill", y), x.setAttribute("stroke", "none"), v.append(S), v.append(x), v;
  }
  onResize = (e, n) => {
    const { initialBounds: r, initialShape: a, scaleX: s, handle: c } = n;
    if (n.mode === "scale_shape" || c !== "right" && c !== "left")
      return Nte(e, n);
    {
      const f = r.width;
      let p = f * s;
      const g = new O(0, 0);
      p = Math.max(1, Math.abs(p)), c === "left" ? (g.x = f - p, s < 0 && (g.x += p)) : s < 0 && (g.x -= p);
      const { x: y, y: v } = g.rot(e.rotation).add(a);
      return {
        x: y,
        y: v,
        props: {
          w: p / a.props.scale,
          autoSize: !1
        }
      };
    }
  };
  onBeforeCreate = (e) => {
    if (!e.props.autoSize || e.props.text.trim())
      return;
    const n = this.getMinDimensions(e);
    return {
      ...e,
      x: e.x - n.width / 2,
      y: e.y - n.height / 2
    };
  };
  onEditEnd = (e) => {
    const {
      id: n,
      type: r,
      props: { text: a }
    } = e, s = e.props.text.trim();
    s.length === 0 ? this.app.deleteShapes([e.id]) : s !== e.props.text && this.app.updateShapes([
      {
        id: n,
        type: r,
        props: {
          text: a.trim()
        }
      }
    ]);
  };
  onBeforeUpdate = (e, n) => {
    if (!n.props.autoSize)
      return;
    const r = e.props.size !== n.props.size || e.props.align !== n.props.align || e.props.font !== n.props.font || e.props.scale !== 1 && n.props.scale === 1, a = e.props.text !== n.props.text;
    if (!r && !a)
      return;
    const s = this.getMinDimensions(e), c = OD(this.app, n.props), f = s.width * e.props.scale, p = s.height * e.props.scale, g = c.width * n.props.scale, y = c.height * n.props.scale;
    let v;
    switch (n.props.align) {
      case "middle": {
        v = new O((g - f) / 2, a ? 0 : (y - p) / 2);
        break;
      }
      case "end": {
        v = new O(g - f, a ? 0 : (y - p) / 2);
        break;
      }
      default: {
        if (a)
          break;
        v = new O(0, (y - p) / 2);
        break;
      }
    }
    if (v) {
      v.rot(n.rotation);
      const { x: S, y: x } = n;
      return {
        ...n,
        x: S - v.x,
        y: x - v.y,
        props: { ...n.props, w: g }
      };
    } else
      return {
        ...n,
        props: { ...n.props, w: g }
      };
  };
  onDoubleClickEdge = (e) => {
    if (!e.props.autoSize)
      return {
        id: e.id,
        type: e.type,
        props: {
          autoSize: !0
        }
      };
    if (e.props.scale !== 1)
      return {
        id: e.id,
        type: e.type,
        props: {
          scale: 1
        }
      };
  };
}
const v1 = pi({
  type: "text",
  getShapeUtil: () => jte,
  validator: Iq,
  migrations: Rq
});
function OD(t, e) {
  const { font: n, text: r, autoSize: a, size: s, w: c } = e, f = 16, p = Bg[s], g = a ? "fit-content" : (
    // `measureText` floors the number so we need to do the same here to avoid issues.
    Math.floor(Math.max(f, c)) + "px"
  ), y = t.textMeasure.measureText({
    ...Yi,
    text: r,
    fontFamily: Wd[n],
    fontSize: p,
    width: g
  });
  return a && (y.w += 1), {
    width: Math.max(f, y.w),
    height: Math.max(p, y.h)
  };
}
class zte extends ma {
  static type = "video";
  canEdit = () => !0;
  isAspectRatioLocked = () => !0;
  defaultProps() {
    return {
      opacity: "1",
      w: 100,
      h: 100,
      assetId: null,
      time: 0,
      playing: !0,
      url: ""
    };
  }
  render(e) {
    return /* @__PURE__ */ E.jsx(Fte, { shape: e, videoUtil: this });
  }
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: ze(e.props.w), height: ze(e.props.h) });
  }
  toSvg(e) {
    const n = document.createElementNS("http://www.w3.org/2000/svg", "g"), r = document.createElementNS("http://www.w3.org/2000/svg", "image");
    return r.setAttributeNS("http://www.w3.org/1999/xlink", "href", Bte(e.id)), r.setAttribute("width", e.props.w.toString()), r.setAttribute("height", e.props.h.toString()), n.appendChild(r), n;
  }
}
const Ute = pi({
  type: "video",
  getShapeUtil: () => zte,
  validator: $q,
  migrations: Mq
});
function Bte(t) {
  const e = t.split(":")[1], n = document.querySelector(`.rs-video-shape-${e}`);
  if (n) {
    const r = document.createElement("canvas");
    return r.width = n.videoWidth, r.height = n.videoHeight, r.getContext("2d").drawImage(n, 0, 0), r.toDataURL("image/png");
  } else
    throw new Error("Video with id " + e + " not found");
}
const Fte = dn(function(e) {
  const { shape: n, videoUtil: r } = e, a = r.app.getBounds(n).w * r.app.zoomLevel >= 110, s = n.props.assetId ? r.app.getAssetById(n.props.assetId) : null, { w: c, h: f, time: p, playing: g } = n.props, y = zI(n.id), v = KL(), S = k.useRef(null), x = k.useCallback(
    (j) => {
      const L = j.currentTarget;
      r.app.updateShapes([
        {
          type: "video",
          id: n.id,
          props: {
            playing: !0,
            time: L.currentTime
          }
        }
      ]);
    },
    [n.id, r.app]
  ), _ = k.useCallback(
    (j) => {
      const L = j.currentTarget;
      r.app.updateShapes([
        {
          type: "video",
          id: n.id,
          props: {
            playing: !1,
            time: L.currentTime
          }
        }
      ]);
    },
    [n.id, r.app]
  ), T = k.useCallback(
    (j) => {
      const L = j.currentTarget;
      y && r.app.updateShapes([
        {
          type: "video",
          id: n.id,
          props: {
            time: L.currentTime
          }
        }
      ]);
    },
    [y, n.id, r.app]
  ), [I, D] = k.useState(!1), N = k.useCallback(
    (j) => {
      const L = j.currentTarget;
      p !== L.currentTime && (L.currentTime = p), g || L.pause(), D(!0);
    },
    [g, p]
  );
  return k.useEffect(() => {
    const j = S.current;
    j && I && !y && p !== j.currentTime && (j.currentTime = p);
  }, [y, I, p]), k.useEffect(() => {
    if (v) {
      const j = S.current;
      j.pause(), j.currentTime = 0;
    }
  }, [S, v]), /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsx(fa, { id: n.id, children: /* @__PURE__ */ E.jsx("div", { className: "rs-counter-scaled", children: s?.props.src ? /* @__PURE__ */ E.jsx(
      "video",
      {
        ref: S,
        className: `rs-video rs-video-shape-${n.id.split(":")[1]} rs-hitarea-stroke`,
        width: "100%",
        height: "100%",
        draggable: !1,
        playsInline: !0,
        autoPlay: !0,
        muted: !0,
        loop: !0,
        disableRemotePlayback: !0,
        disablePictureInPicture: !0,
        controls: y && a,
        onPlay: x,
        onPause: _,
        onTimeUpdate: T,
        onLoadedData: N,
        hidden: !I,
        children: /* @__PURE__ */ E.jsx("source", { src: s.props.src })
      }
    ) : /* @__PURE__ */ E.jsx(
      m1,
      {
        x: (c - 38) / 2,
        y: (f - 38) / 2
      }
    ) }) }),
    "url" in n.props && n.props.url && /* @__PURE__ */ E.jsx(_b, { url: n.props.url })
  ] });
}), Hte = () => [
  hj,
  v1,
  kj,
  to,
  _te,
  Ute,
  wj,
  lP,
  xj,
  g1,
  tb,
  dx
];
class Tb {
  static default = new Tb({});
  storeSchema;
  shapes;
  TLShape;
  tools;
  constructor({
    shapes: e = [],
    tools: n = [],
    allowUnknownShapes: r = !1
  }) {
    this.tools = n;
    const a = [...Hte(), ...e];
    this.shapes = a;
    const s = /* @__PURE__ */ new Set();
    for (const g of a) {
      if (s.has(g.type))
        throw new Error(`Shape type ${g.type} is already defined`);
      s.add(g.type);
    }
    const c = xr({
      currentVersion: jT.currentVersion,
      firstVersion: jT.firstVersion,
      migrators: jT.migrators,
      subTypeKey: "type",
      subTypeMigrations: Object.fromEntries(a.map((g) => [g.type, g.migrations]))
    });
    let f = bI("type", {
      ...Object.fromEntries(a.map((g) => [g.type, g.validator]))
    });
    r && (f = f.validateUnknownVariants((g) => g));
    const p = Ic("shape", {
      migrations: c,
      validator: Rc("shape", f)
    }).withDefaultProperties(() => ({ x: 0, y: 0, rotation: 0, isLocked: !1 }));
    this.TLShape = p, this.storeSchema = gI.create(
      {
        asset: sm,
        camera: Gy,
        document: wI,
        instance: Pp,
        instance_page_state: Xy,
        page: fr,
        shape: p,
        user: Ip,
        user_document: rP,
        user_presence: iP
      },
      {
        snapshotMigrations: sq,
        onValidationFailure: WX,
        ensureStoreIsUsable: Sc
      }
    );
  }
  createStore(e) {
    let n = e.initialData;
    return n && (n = nq(n)), new pL({
      schema: this.storeSchema,
      initialData: n,
      props: {
        userId: e?.userId ?? Ip.createId(),
        instanceId: e?.instanceId ?? Pp.createId(),
        documentId: kx
      }
    });
  }
}
const Vte = (t) => {
  const e = t.query.filterHistory("shape"), n = t.query.records("shape", () => ({ type: { eq: "arrow" } }));
  function r() {
    const a = n.value, s = {};
    for (const c of a) {
      const { start: f, end: p } = c.props;
      if (f.type === "binding") {
        const g = s[f.boundShapeId];
        g ? g.push({ arrowId: c.id, handleId: "start" }) : s[f.boundShapeId] = [{ arrowId: c.id, handleId: "start" }];
      }
      if (p.type === "binding") {
        const g = s[p.boundShapeId];
        g ? g.push({ arrowId: c.id, handleId: "end" }) : s[p.boundShapeId] = [{ arrowId: c.id, handleId: "end" }];
      }
    }
    return s;
  }
  return pt("arrowBindingsIndex", (a, s) => {
    if (Yg(a))
      return r();
    const c = a, f = e.getDiffSince(s);
    if (f === us)
      return r();
    let p;
    function g(S) {
      p || (p = { ...c }), p[S] ? p[S] === c[S] && (p[S] = [...p[S]]) : p[S] = [];
    }
    function y(S, x, _) {
      g(S), p[S] = p[S].filter(
        (T) => T.arrowId !== x || T.handleId !== _
      ), p[S].length === 0 && delete p[S];
    }
    function v(S, x, _) {
      g(S), p[S].push({ arrowId: x, handleId: _ });
    }
    for (const S of f) {
      for (const x of Object.values(S.added))
        if (to.is(x)) {
          const { start: _, end: T } = x.props;
          _.type === "binding" && v(_.boundShapeId, x.id, "start"), T.type === "binding" && v(T.boundShapeId, x.id, "end");
        }
      for (const [x, _] of Object.values(S.updated))
        if (!(!to.is(x) || !to.is(_)))
          for (const T of ["start", "end"]) {
            const I = x.props[T], D = _.props[T];
            I.type === "binding" && D.type === "point" ? y(I.boundShapeId, x.id, T) : I.type === "point" && D.type === "binding" ? v(D.boundShapeId, _.id, T) : I.type === "binding" && D.type === "binding" && I.boundShapeId !== D.boundShapeId && (y(I.boundShapeId, x.id, T), v(D.boundShapeId, _.id, T));
          }
      for (const x of Object.values(S.removed))
        if (to.is(x)) {
          const { start: _, end: T } = x.props;
          _.type === "binding" && y(_.boundShapeId, x.id, "start"), T.type === "binding" && y(T.boundShapeId, x.id, "end");
        }
    }
    return p ?? c;
  });
}, Yte = (t) => {
  const e = t.query.ids("shape");
  function n() {
    const r = {};
    return e.value.forEach((a) => {
      const s = t.get(a);
      r[s.parentId] || (r[s.parentId] = []), r[s.parentId].push([a, s.index]);
    }), Object.values(r).forEach((a) => a.sort((s, c) => s[1] < c[1] ? -1 : 1)), r;
  }
  return pt(
    "parentsToChildrenWithIndexes",
    (r, a) => {
      if (Yg(r))
        return n();
      const s = t.history.getDiffSince(a);
      if (s === us)
        return n();
      if (s.length === 0)
        return r;
      let c = null;
      const f = (y) => {
        c || (c = { ...r }), c[y] ? c[y] === r[y] && (c[y] = [...c[y]]) : c[y] = [];
      }, p = /* @__PURE__ */ new Set();
      let g;
      for (let y = 0, v = s.length; y < v; y++) {
        g = s[y];
        for (const S of Object.values(g.added))
          Ep(S) && (f(S.parentId), c[S.parentId].push([S.id, S.index]), p.add(c[S.parentId]));
        for (const [S, x] of Object.values(g.updated))
          if (Ep(x) && Ep(S)) {
            if (S.parentId !== x.parentId)
              f(S.parentId), f(x.parentId), c[S.parentId].splice(
                c[S.parentId].findIndex((_) => _[0] === x.id),
                1
              ), c[x.parentId].push([x.id, x.index]), p.add(c[x.parentId]);
            else if (S.index !== x.index) {
              f(x.parentId);
              const _ = c[x.parentId].findIndex((T) => T[0] === x.id);
              c[x.parentId][_] = [x.id, x.index], p.add(c[x.parentId]);
            }
          }
        for (const S of Object.values(g.removed))
          Ep(S) && (f(S.parentId), c[S.parentId].splice(
            c[S.parentId].findIndex((x) => x[0] === S.id),
            1
          ));
      }
      for (const y of p)
        y.sort((v, S) => v[1] < S[1] ? -1 : 1);
      return c ?? r;
    }
  );
}, lk = (t, e, n) => {
  for (; !fr.isId(n.parentId); ) {
    const r = t.get(n.parentId);
    if (!r)
      return !1;
    n = r;
  }
  return n.parentId === e;
}, Kte = (t, e) => {
  const n = t.query.ids("shape");
  let r = null;
  function a() {
    const s = e();
    return r = s, new Set(
      [...n.value].filter((c) => lk(t, s, t.get(c)))
    );
  }
  return pt("_shapeIdsInCurrentPage", (s, c) => {
    if (Yg(s))
      return a();
    const f = e();
    if (f !== r)
      return a();
    const p = t.history.getDiffSince(c);
    if (p === us)
      return a();
    const g = new sx(
      s
    );
    for (const v of p) {
      for (const S of Object.values(v.added))
        Ep(S) && lk(t, f, S) && g.add(S.id);
      for (const [S, x] of Object.values(v.updated))
        Ep(x) && (lk(t, f, x) ? g.add(x.id) : g.remove(x.id));
      for (const S of Object.keys(v.removed))
        Us(S) && g.remove(S);
    }
    const y = g.get();
    return y ? Dy(y.value, y.diff) : s;
  });
}, Pj = {
  top: 10,
  left: 10,
  bottom: 10,
  right: 10
};
function Ij(t) {
  const e = t.getContainer(), n = e.querySelector('*[data-tldraw-area="active-drawing"]'), r = {
    ...Pj,
    width: 0,
    height: 0
  };
  if (n && e) {
    const a = e.getBoundingClientRect(), s = n.getBoundingClientRect();
    r.top = s.top, r.left = s.left, r.bottom = a.height - s.bottom, r.right = a.width - s.right;
  }
  return r.width = t.viewportScreenBounds.width - r.left - r.right, r.height = t.viewportScreenBounds.height - r.top - r.bottom, r;
}
function Wte(t) {
  const e = Ij(t), n = t.camera.z;
  return e.left /= n, e.right /= n, e.top /= n, e.bottom /= n, e.width /= n, e.height /= n, e;
}
class Gte {
  constructor(e) {
    this.app = e, window.addEventListener("resize", this.updateOffsets), this.app.disposables.add(this.dispose);
  }
  offsets = fi("activeAreaOffsets", Pj);
  updateOffsets = () => {
    const e = Wte(this.app);
    this.offsets.set(e);
  };
  // Clear the listener
  dispose = () => {
    window.addEventListener("resize", this.updateOffsets);
  };
}
const Xte = 12;
class qte {
  constructor(e) {
    this.app = e;
  }
  state = fi("camera state", "idle");
  timeoutRemaining = 0;
  decay = (e) => {
    this.timeoutRemaining -= e, this.timeoutRemaining <= 0 && (this.state.set("idle"), this.app.off("tick", this.decay), this.app.updateCullingBounds());
  };
  tick = () => {
    this.timeoutRemaining = Xte, this.state.__unsafe__getWithoutCapture() === "idle" && (this.state.set("moving"), this.app.on("tick", this.decay));
  };
}
const Qte = 40;
class Zte {
  constructor(e) {
    this.app = e;
  }
  _clickId = "";
  _clickTimeout;
  _clickScreenPoint;
  _previousScreenPoint;
  _getClickTimeout = (e, n = Ii()) => {
    this._clickId = n, clearTimeout(this._clickTimeout), this._clickTimeout = setTimeout(
      () => {
        if (this._clickState === e && this._clickId === n) {
          switch (this._clickState) {
            case "pendingTriple": {
              this.app.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "double_click",
                phase: "settle"
              });
              break;
            }
            case "pendingQuadruple": {
              this.app.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "triple_click",
                phase: "settle"
              });
              break;
            }
            case "pendingOverflow": {
              this.app.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "quadruple_click",
                phase: "settle"
              });
              break;
            }
          }
          this._clickState = "idle";
        }
      },
      e === "idle" || e === "pendingDouble" ? oQ : aQ
    );
  };
  /**
   * The current click state.
   *
   * @internal
   */
  _clickState = "idle";
  /**
   * The current click state.
   *
   * @public
   */
  get clickState() {
    return this._clickState;
  }
  lastPointerInfo = {};
  /**
   * Start the double click timeout.
   *
   * @param info - The event info.
   */
  transformPointerDownEvent = (e) => {
    if (!this._clickState)
      return e;
    switch (this._clickScreenPoint = O.From(e.point), this._previousScreenPoint && this._previousScreenPoint.dist(this._clickScreenPoint) > Qte && (this._clickState = "idle"), this._previousScreenPoint = this._clickScreenPoint, this.lastPointerInfo = e, this._clickState) {
      case "idle":
        return this._clickState = "pendingDouble", this._clickTimeout = this._getClickTimeout(this._clickState), e;
      case "pendingDouble":
        return this._clickState = "pendingTriple", this._clickTimeout = this._getClickTimeout(this._clickState), {
          ...e,
          type: "click",
          name: "double_click",
          phase: "down"
        };
      case "pendingTriple":
        return this._clickState = "pendingQuadruple", this._clickTimeout = this._getClickTimeout(this._clickState), {
          ...e,
          type: "click",
          name: "triple_click",
          phase: "down"
        };
      case "pendingQuadruple":
        return this._clickState = "pendingOverflow", this._clickTimeout = this._getClickTimeout(this._clickState), {
          ...e,
          type: "click",
          name: "quadruple_click",
          phase: "down"
        };
      case "pendingOverflow":
        return this._clickState = "overflow", this._clickTimeout = this._getClickTimeout(this._clickState), e;
      default:
        return this._clickTimeout = this._getClickTimeout(this._clickState), e;
    }
  };
  /**
   * Emit click_up events on pointer up.
   *
   * @param info - The event info.
   */
  transformPointerUpEvent = (e) => {
    if (!this._clickState)
      return e;
    switch (this._clickScreenPoint = O.From(e.point), this._clickState) {
      case "pendingTriple":
        return {
          ...this.lastPointerInfo,
          type: "click",
          name: "double_click",
          phase: "up"
        };
      case "pendingQuadruple":
        return {
          ...this.lastPointerInfo,
          type: "click",
          name: "triple_click",
          phase: "up"
        };
      case "pendingOverflow":
        return {
          ...this.lastPointerInfo,
          type: "click",
          name: "quadruple_click",
          phase: "up"
        };
      default:
        return e;
    }
  };
  /**
   * Cancel the double click timeout.
   *
   * @internal
   */
  cancelDoubleClickTimeout = () => {
    this._clickTimeout = clearTimeout(this._clickTimeout), this._clickState = "idle";
  };
  /**
   * Handle a move event, possibly cancelling the click timeout.
   *
   * @internal
   */
  handleMove = () => {
    this._clickState !== "idle" && this._clickScreenPoint && this._clickScreenPoint.dist(this.app.inputs.currentScreenPoint) > Jy && this.cancelDoubleClickTimeout();
  };
}
class Jte {
  constructor(e) {
    this.app = e, this.rebind(), this.app.disposables.add(this.dispose);
  }
  _currentMM;
  // Set a listener to update the dpr when the device pixel ratio changes
  rebind() {
    this.dispose(), this._currentMM = this.getMedia(), this._currentMM?.addEventListener("change", this.updateDevicePixelRatio);
  }
  dpr = fi(
    "devicePixelRatio",
    typeof window > "u" ? 1 : window.devicePixelRatio
  );
  // Get the media query list for the device pixel ratio
  getMedia() {
    if (window.matchMedia)
      return matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
  }
  // Update the device pixel ratio atom
  updateDevicePixelRatio = () => {
    this.dpr.set(window.devicePixelRatio), this.rebind();
  };
  // Clear the listener
  dispose = () => {
    this._currentMM?.removeEventListener("change", this.updateDevicePixelRatio);
  };
}
const DD = 100;
class ene {
  constructor(e) {
    this.app = e, e.disposables.add(this.dispose);
  }
  prevDroppingShapeId = null;
  currDroppingShapeId = null;
  droppingNodeTimer = null;
  updateDroppingNode(e, n) {
    if (this.droppingNodeTimer === null) {
      const { currentPagePoint: r } = this.app.inputs;
      this.currDroppingShapeId = this.app.getDroppingShape(r, e)?.id ?? null, this.setDragTimer(e, DD * 10, n);
    } else
      this.app.inputs.pointerVelocity.len() > 0.5 && (clearInterval(this.droppingNodeTimer), this.setDragTimer(e, DD, n));
  }
  setDragTimer(e, n, r) {
    this.droppingNodeTimer = setTimeout(() => {
      this.app.batch(() => {
        this.handleDrag(e, r);
      }), this.droppingNodeTimer = null;
    }, n);
  }
  handleDrag(e, n) {
    const { currentPagePoint: r } = this.app.inputs;
    e = Gt(e.map((p) => this.app.getShapeById(p.id)));
    const a = this.app.getDroppingShape(r, e)?.id ?? null;
    a !== this.currDroppingShapeId && (this.prevDroppingShapeId = this.currDroppingShapeId, this.currDroppingShapeId = a);
    const { prevDroppingShapeId: s } = this;
    if (a === s)
      return;
    const c = s && this.app.getShapeById(s), f = a && this.app.getShapeById(a);
    if (this.prevDroppingShapeId = this.currDroppingShapeId, c && this.app.getShapeUtil(c).onDragShapesOut?.(c, e), f) {
      const p = this.app.getShapeUtil(f).onDragShapesOver?.(f, e);
      p && p.shouldHint && this.app.setHintingIds([f.id]);
    } else
      this.app.setHintingIds([]);
    n?.();
  }
  dropShapes(e) {
    const { currDroppingShapeId: n } = this;
    if (this.handleDrag(e), n) {
      const r = this.app.getShapeById(n);
      if (!r)
        return;
      this.app.getShapeUtil(r).onDropShapesOver?.(r, e);
    }
  }
  clear() {
    this.prevDroppingShapeId = null, this.currDroppingShapeId = null, this.droppingNodeTimer !== null && clearInterval(this.droppingNodeTimer), this.droppingNodeTimer = null, this.app.setHintingIds([]);
  }
  dispose = () => {
    this.clear();
  };
}
function gp(t) {
  if (t) {
    let e = ND;
    for (; t.length; )
      e = e.push(t.pop());
    return e;
  }
  return ND;
}
class tne {
  length = 0;
  head = null;
  tail = this;
  push(e) {
    return new KI(e, this);
  }
  toArray() {
    return Ys;
  }
  [Symbol.iterator]() {
    return {
      next() {
        return { value: void 0, done: !0 };
      }
    };
  }
}
const ND = new tne();
class KI {
  constructor(e, n) {
    this.head = e, this.tail = n, this.length = n.length + 1;
  }
  length;
  push(e) {
    return new KI(e, this);
  }
  toArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e = this;
    return {
      next() {
        if (e.length) {
          const n = e.head;
          return e = e.tail, { value: n, done: !1 };
        } else
          return { value: void 0, done: !0 };
      }
    };
  }
}
class nne {
  // A flag for whether the user is in a batch operation
  constructor(e, n, r) {
    this.ctx = e, this.onBatchComplete = n, this.annotateError = r;
  }
  _undos = fi("HistoryManager.undos", gp());
  // Updated by each action that includes and undo
  _redos = fi("HistoryManager.redos", gp());
  // Updated when a user undoes
  _batchDepth = 0;
  _commands = {};
  get numUndos() {
    return this._undos.value.length;
  }
  get numRedos() {
    return this._redos.value.length;
  }
  createCommand = (e, n, r) => {
    if (this._commands[e])
      throw new Error(`Duplicate command: ${e}`);
    this._commands[e] = r;
    const a = (...s) => {
      if (!this._batchDepth)
        return this.batch(() => a(...s)), this.ctx;
      const c = n(...s);
      if (!c)
        return this.ctx;
      const { data: f, ephemeral: p, squashing: g, preservesRedoStack: y } = c;
      if (this.ignoringUpdates((v, S) => (r.do(f), { undos: v, redos: S })), !p) {
        const v = this._undos.value.head;
        g && v && v.type === "command" && v.name === e && v.preservesRedoStack === y ? this._undos.update(
          (S) => S.tail.push({
            ...v,
            id: Ii(),
            data: Ex(r.squash(v.data, f))
          })
        ) : this._undos.update(
          (S) => S.push({
            type: "command",
            name: e,
            data: Ex(f),
            id: Ii(),
            preservesRedoStack: y
          })
        ), c.preservesRedoStack || this._redos.set(gp()), this.ctx.emit("change-history");
      }
      return this.ctx;
    };
    return a;
  };
  batch = (e) => {
    try {
      this._batchDepth++, this._batchDepth === 1 ? Pu(() => {
        const n = this._undos.value.head?.id;
        e(), n !== this._undos.value.head?.id && this.onBatchComplete();
      }) : e();
    } catch (n) {
      throw this.annotateError(n), n;
    } finally {
      this._batchDepth--;
    }
    return this;
  };
  ignoringUpdates = (e) => {
    let n = this._undos.value, r = this._redos.value;
    this._undos.set(gp()), this._redos.set(gp());
    try {
      ({ undos: n, redos: r } = Pu(() => e(n, r)));
    } finally {
      this._undos.set(n), this._redos.set(r);
    }
  };
  // History
  _undo = ({
    pushToRedoStack: e,
    toMark: n = void 0
  }) => (this.ignoringUpdates((r, a) => {
    if (r.length === 0)
      return this.ctx.emit("change-history"), { undos: r, redos: a };
    for (; r.head?.type === "STOP"; ) {
      const s = r.head;
      if (r = r.tail, e && (a = a.push(s)), s.id === n)
        return this.ctx.emit("change-history"), { undos: r, redos: a };
    }
    if (r.length === 0)
      return this.ctx.emit("change-history"), { undos: r, redos: a };
    for (; r.head; ) {
      const s = r.head;
      if (r = r.tail, e && (a = a.push(s)), s.type === "STOP") {
        if (s.onUndo && (!n || s.id === n))
          return this.ctx.emit("change-history"), { undos: r, redos: a };
      } else
        this._commands[s.name].undo(s.data);
    }
    return this.ctx.emit("change-history"), { undos: r, redos: a };
  }), this);
  undo = () => (this._undo({ pushToRedoStack: !0 }), this);
  redo = () => (this.ignoringUpdates((e, n) => {
    if (n.length === 0)
      return this.ctx.emit("change-history"), { undos: e, redos: n };
    for (; n.head?.type === "STOP"; )
      e = e.push(n.head), n = n.tail;
    if (n.length === 0)
      return this.ctx.emit("change-history"), { undos: e, redos: n };
    for (; n.head; ) {
      const r = n.head;
      if (e = e.push(n.head), n = n.tail, r.type === "STOP") {
        if (r.onRedo)
          break;
      } else {
        const a = this._commands[r.name];
        a.redo ? a.redo(r.data) : a.do(r.data);
      }
    }
    return this.ctx.emit("change-history"), { undos: e, redos: n };
  }), this);
  bail = () => (this._undo({ pushToRedoStack: !1 }), this);
  bailToMark = (e) => (this._undo({ pushToRedoStack: !1, toMark: e }), this);
  mark = (e = Ii(), n = !0, r = !0) => {
    const a = this._undos.value.head;
    return a && a.type === "STOP" && a.id === e && a.onUndo === n && a.onRedo === r ? a.id : (this._undos.update((s) => s.push({ type: "STOP", id: e, onUndo: n, onRedo: r })), e);
  };
  clear() {
    this._undos.set(gp()), this._redos.set(gp());
  }
}
class Rj {
  // Scribble properties
  state;
  points;
  size;
  color;
  opacity;
  // Callbacks
  onUpdate;
  onComplete;
  // Internal state
  prev = null;
  next = null;
  constructor(e) {
    const { size: n = 20, color: r = "accent", opacity: a = 0.8, onComplete: s, onUpdate: c } = e;
    this.onUpdate = c, this.onComplete = s, this.size = n, this.color = r, this.opacity = a, this.points = [], this.state = "starting", this.prev = null, this.next = null, this.resume();
  }
  resume = () => {
    this.state = "active";
  };
  pause = () => {
    this.state = "starting";
  };
  /**
   * Start stopping the scribble. The scribble won't be removed
   * until its last point is cleared.
   *
   * @public
   */
  stop = () => {
    this.state = "stopping";
  };
  /**
   * Set the scribble's next point.
   *
   * @param point - The point to add.
   * @public
   */
  addPoint = (e, n) => {
    const { prev: r } = this, a = { x: e, y: n, z: 0.5 };
    r && O.Dist(r, a) < 1 || (this.next = a);
  };
  /**
   * Get the current TLScribble object from the scribble manager.
   *
   * @public
   */
  getScribble() {
    return {
      state: this.state,
      size: this.size,
      color: this.color,
      opacity: this.opacity,
      points: [...this.points]
    };
  }
  updateScribble() {
    this.onUpdate(this.getScribble());
  }
  timeoutMs = 0;
  tick = (e) => {
    this.timeoutMs += e, this.timeoutMs >= 16 && (this.timeoutMs = 0);
    const { timeoutMs: n, state: r, prev: a, next: s, points: c } = this;
    switch (r) {
      case "active": {
        s && s !== a ? (this.prev = s, c.push(s), c.length > 8 && c.shift(), this.updateScribble()) : n === 0 && c.length > 1 && (c.shift(), this.updateScribble());
        break;
      }
      case "stopping": {
        if (n === 0) {
          if (c.length === 1) {
            this.state = "paused", this.onComplete();
            return;
          }
          this.size *= 0.9, c.shift(), this.updateScribble();
        }
        break;
      }
    }
  };
}
var rne = Object.defineProperty, ine = Object.getOwnPropertyDescriptor, y1 = (t, e, n, r) => {
  for (var a = r > 1 ? void 0 : r ? ine(e, n) : e, s = t.length - 1, c; s >= 0; s--)
    (c = t[s]) && (a = (r ? c(e, n, a) : c(a)) || a);
  return r && a && rne(e, n, a), a;
};
const zt = (t) => Math.round(t * 10 ** 8) / 10 ** 8;
function ku(t, e, n, r, a) {
  const s = t.filter(
    (f) => (r === "forward" ? f.startNode.id === e : f.endNode.id === e) && zt(f.length) === zt(n) && kl(
      f.breadthIntersection[0],
      f.breadthIntersection[1],
      a[0],
      a[1]
    )
  );
  if (s.length === 0)
    return [];
  const c = /* @__PURE__ */ new Set();
  for (const f of s) {
    const p = r === "forward" ? f.endNode.id : f.startNode.id;
    c.has(p) || (c.add(p), s.push(
      ...ku(
        t,
        p,
        n,
        r,
        kl(
          f.breadthIntersection[0],
          f.breadthIntersection[1],
          a[0],
          a[1]
        )
      )
    ));
  }
  return s;
}
function one(t) {
  t.sort((e, n) => n.gaps.length - e.gaps.length);
  for (let e = t.length - 1; e > 0; e--) {
    const n = t[e];
    for (let r = e - 1; r >= 0; r--) {
      const a = t[r];
      if (a.direction === n.direction && n.gaps.every(
        (s) => a.gaps.some(
          (c) => zt(s.startEdge[0].x) === zt(c.startEdge[0].x) && zt(s.startEdge[0].y) === zt(c.startEdge[0].y) && zt(s.startEdge[1].x) === zt(c.startEdge[1].x) && zt(s.startEdge[1].y) === zt(c.startEdge[1].y)
        ) && a.gaps.some(
          (c) => zt(s.endEdge[0].x) === zt(c.endEdge[0].x) && zt(s.endEdge[0].y) === zt(c.endEdge[0].y) && zt(s.endEdge[1].x) === zt(c.endEdge[1].x) && zt(s.endEdge[1].y) === zt(c.endEdge[1].y)
        )
      )) {
        t.splice(e, 1);
        break;
      }
    }
  }
}
class kb {
  constructor(e) {
    this.app = e;
  }
  _snapLines = fi("snapLines", void 0);
  get lines() {
    return this._snapLines.value ?? Ys;
  }
  clear() {
    this.lines.length && this._snapLines.set(void 0);
  }
  setLines(e) {
    this._snapLines.set(e);
  }
  get snapPointsCache() {
    return this.app.store.createComputedCache("snapPoints", (e) => {
      const n = this.app.getPageTransformById(e.id);
      return n ? this.app.getShapeUtil(e).snapPoints(e).map((s, c) => {
        const { x: f, y: p } = De.applyToPoint(n, s);
        return { x: f, y: p, id: `${e.id}:${c}` };
      }) : void 0;
    });
  }
  get snapThreshold() {
    return 8 / this.app.camera.z;
  }
  get visibleShapesNotInSelection() {
    const e = this.app.selectedIds, n = /* @__PURE__ */ new Set(), r = (s) => {
      const c = this.app.getSortedChildIds(s);
      for (const f of c) {
        const p = this.app.getShapeById(f);
        if (p && p.type !== "arrow" && !e.includes(f) && this.app.isShapeInViewport(p.id)) {
          if (p.type === "group") {
            r(f);
            continue;
          }
          n.add({ id: p.id, pageBounds: this.app.getPageBoundsById(p.id) }), p.type !== "frame" && r(f);
        }
      }
    }, a = this.app.findCommonAncestor(
      Gt(e.map((s) => this.app.getShapeById(s))),
      (s) => s.type === "frame"
    );
    return r(a ?? this.app.currentPageId), n;
  }
  get visibleSnapPointsNotInSelection() {
    const e = [];
    for (const n of this.visibleShapesNotInSelection) {
      const r = this.snapPointsCache.get(n.id);
      r && e.push(...r);
    }
    return e;
  }
  get visibleGaps() {
    const e = [], n = [], r = [...this.visibleShapesNotInSelection].sort((s, c) => s.pageBounds.minX - c.pageBounds.minX);
    for (let s = 0; s < r.length; s++) {
      const c = r[s];
      for (let f = s + 1; f < r.length; f++) {
        const p = r[f];
        // is there space between the boxes
        c.pageBounds.maxX < p.pageBounds.minX && // and they overlap in the y axis
        ky(
          c.pageBounds.minY,
          c.pageBounds.maxY,
          p.pageBounds.minY,
          p.pageBounds.maxY
        ) && e.push({
          startNode: c,
          endNode: p,
          startEdge: [
            new O(c.pageBounds.maxX, c.pageBounds.minY),
            new O(c.pageBounds.maxX, c.pageBounds.maxY)
          ],
          endEdge: [
            new O(p.pageBounds.minX, p.pageBounds.minY),
            new O(p.pageBounds.minX, p.pageBounds.maxY)
          ],
          length: p.pageBounds.minX - c.pageBounds.maxX,
          breadthIntersection: kl(
            c.pageBounds.minY,
            c.pageBounds.maxY,
            p.pageBounds.minY,
            p.pageBounds.maxY
          )
        });
      }
    }
    const a = r.slice(0).sort((s, c) => s.pageBounds.minY - c.pageBounds.minY);
    for (let s = 0; s < a.length; s++) {
      const c = a[s];
      for (let f = s + 1; f < a.length; f++) {
        const p = a[f];
        // is there space between the boxes
        c.pageBounds.maxY < p.pageBounds.minY && // do they overlap in the x axis
        ky(
          c.pageBounds.minX,
          c.pageBounds.maxX,
          p.pageBounds.minX,
          p.pageBounds.maxX
        ) && n.push({
          startNode: c,
          endNode: p,
          startEdge: [
            new O(c.pageBounds.minX, c.pageBounds.maxY),
            new O(c.pageBounds.maxX, c.pageBounds.maxY)
          ],
          endEdge: [
            new O(p.pageBounds.minX, p.pageBounds.minY),
            new O(p.pageBounds.maxX, p.pageBounds.minY)
          ],
          length: p.pageBounds.minY - c.pageBounds.maxY,
          breadthIntersection: kl(
            c.pageBounds.minX,
            c.pageBounds.maxX,
            p.pageBounds.minX,
            p.pageBounds.maxX
          )
        });
      }
    }
    return { horizontal: e, vertical: n };
  }
  snapTranslate({
    lockedAxis: e,
    initialSelectionPageBounds: n,
    initialSelectionSnapPoints: r,
    dragDelta: a
  }) {
    const s = e === "x", c = e === "y", f = n.clone().translate(a), p = r.map(({ x: I, y: D }, N) => ({
      id: "selection:" + N,
      x: I + a.x,
      y: D + a.y
    })), g = this.visibleSnapPointsNotInSelection, y = [], v = [], S = new O(this.snapThreshold, this.snapThreshold);
    this.findPointSnaps({
      minOffset: S,
      nearestSnapsX: y,
      nearestSnapsY: v,
      otherNodeSnapPoints: g,
      selectionSnapPoints: p
    }), this.findGapSnaps({ selectionPageBounds: f, nearestSnapsX: y, nearestSnapsY: v, minOffset: S });
    const x = new O(
      s ? 0 : y[0]?.nudge ?? 0,
      c ? 0 : v[0]?.nudge ?? 0
    );
    S.x = 0, S.y = 0, y.length = 0, v.length = 0, p.forEach((I) => {
      I.x += x.x, I.y += x.y;
    }), f.translate(x), this.findPointSnaps({
      minOffset: S,
      nearestSnapsX: y,
      nearestSnapsY: v,
      otherNodeSnapPoints: g,
      selectionSnapPoints: p
    }), this.findGapSnaps({
      selectionPageBounds: f,
      nearestSnapsX: y,
      nearestSnapsY: v,
      minOffset: S
    });
    const _ = this.getPointSnapLines({
      nearestSnapsX: y,
      nearestSnapsY: v
    }), T = this.getGapSnapLines({
      selectionPageBounds: f,
      nearestSnapsX: y,
      nearestSnapsY: v
    });
    return this._snapLines.set([...T, ..._]), { nudge: x };
  }
  // for a handle of a line:
  // - find the nearest snap point
  // - return the nudge vector to snap to that point
  // note: this happens within page space
  snapLineHandleTranslate({
    lineId: e,
    handleId: n,
    handlePoint: r
  }) {
    const a = this.app.getShapeById(e);
    if (!a)
      return { nudge: new O(0, 0) };
    const c = this.app.getShapeUtilByDef(kj).handles(a).sort(Ha);
    if (c.length < 3)
      return { nudge: new O(0, 0) };
    const f = c.findIndex((T) => T.id === n), g = c[f].type === "vertex" ? f / 2 : (f + 1) / 2, y = bp(a), v = 1, S = this.app.getPageTransform(a), x = y.segments.slice(0, Math.max(0, g - v)).map((T) => De.applyToPoints(S, T.lut)), _ = y.segments.slice(g + v).map((T) => De.applyToPoints(S, T.lut));
    return this.snapHandleTranslate({
      handlePoint: r,
      additionalOutlines: [...x, ..._]
    });
  }
  // for a handle:
  // - find the nearest snap point from all non-selected shapes
  // - return the nudge vector to snap to that point
  // note: this happens within page space
  snapHandleTranslate({
    handlePoint: e,
    additionalOutlines: n = []
  }) {
    const r = this.visibleShapesNotInSelection, a = [];
    for (const f of r) {
      const p = this.app.getShapeById(f.id);
      if (p.type === "text" || p.type === "icon")
        continue;
      const g = Cc(this.app.getOutlineById(f.id));
      this.app.getShapeUtil(p).isClosed?.(p) && g.push(g[0]), a.push(De.applyToPoints(this.app.getPageTransformById(p.id), g));
    }
    let s = this.snapThreshold, c = null;
    for (const f of [...a, ...n])
      for (let p = 0; p < f.length - 1; p++) {
        const g = f[p], y = f[p + 1], v = O.DistanceToLineSegment(g, y, e);
        isNaN(v) || v < s && (s = v, c = O.NearestPointOnLineSegment(g, y, e));
      }
    if (c) {
      const f = [];
      return f.push({
        id: Ii(),
        type: "points",
        points: [c]
      }), this._snapLines.set(f), {
        nudge: O.Sub(c, e)
      };
    }
    return { nudge: new O(0, 0) };
  }
  snapResize({
    initialSelectionPageBounds: e,
    dragDelta: n,
    handle: r,
    isAspectRatioLocked: a,
    isResizingFromCenter: s
  }) {
    const {
      box: c,
      scaleX: f,
      scaleY: p
    } = ot.Resize(
      e,
      r,
      s ? n.x * 2 : n.x,
      s ? n.y * 2 : n.y,
      a
    );
    let g = r;
    f < 0 && (g = Bq(g)), p < 0 && (g = Uq(g)), s && (c.center = e.center);
    const y = g === "top" || g === "bottom", v = g === "left" || g === "right", S = LD(g, c), x = this.visibleSnapPointsNotInSelection, _ = [], T = [], I = new O(this.snapThreshold, this.snapThreshold);
    this.findPointSnaps({
      minOffset: I,
      nearestSnapsX: _,
      nearestSnapsY: T,
      otherNodeSnapPoints: x,
      selectionSnapPoints: S
    });
    const D = new O(
      y ? 0 : _[0]?.nudge ?? 0,
      v ? 0 : T[0]?.nudge ?? 0
    );
    if (a && Fq(g) && D.len() !== 0) {
      const F = _.length && T.length ? Math.abs(D.x) < Math.abs(D.y) ? "x" : "y" : _.length ? "x" : "y", K = e.aspectRatio;
      F === "x" ? (T.length = 0, D.y = D.x / K, (g === "bottom_left" || g === "top_right") && (D.y = -D.y)) : (_.length = 0, D.x = D.y * K, (g === "bottom_left" || g === "top_right") && (D.x = -D.x));
    }
    const N = O.Add(n, D), { box: j } = ot.Resize(
      e,
      r,
      s ? N.x * 2 : N.x,
      s ? N.y * 2 : N.y,
      a
    );
    s && (j.center = e.center);
    const L = LD("any", j);
    _.length = 0, T.length = 0, I.x = 0, I.y = 0, this.findPointSnaps({
      minOffset: I,
      nearestSnapsX: _,
      nearestSnapsY: T,
      otherNodeSnapPoints: x,
      selectionSnapPoints: L
    });
    const z = this.getPointSnapLines({
      nearestSnapsX: _,
      nearestSnapsY: T
    });
    return this._snapLines.set([...z]), { nudge: D };
  }
  findPointSnaps({
    selectionSnapPoints: e,
    otherNodeSnapPoints: n,
    minOffset: r,
    nearestSnapsX: a,
    nearestSnapsY: s
  }) {
    for (const c of e)
      for (const f of n) {
        const p = O.Sub(c, f), g = Math.abs(p.x), y = Math.abs(p.y);
        zt(g) <= zt(r.x) && (zt(g) < zt(r.x) && (a.length = 0), a.push({
          type: "points",
          points: { thisPoint: c, otherPoint: f },
          nudge: f.x - c.x
        }), r.x = g), zt(y) <= zt(r.y) && (zt(y) < zt(r.y) && (s.length = 0), s.push({
          type: "points",
          points: { thisPoint: c, otherPoint: f },
          nudge: f.y - c.y
        }), r.y = y);
      }
  }
  findGapSnaps({
    selectionPageBounds: e,
    minOffset: n,
    nearestSnapsX: r,
    nearestSnapsY: a
  }) {
    for (const s of this.visibleGaps.horizontal) {
      if (!ky(
        s.breadthIntersection[0],
        s.breadthIntersection[1],
        e.minY,
        e.maxY
      ))
        continue;
      const f = s.startEdge[0].x + s.length / 2 - e.center.x;
      if (s.length > e.width && zt(Math.abs(f)) <= zt(n.x)) {
        zt(Math.abs(f)) < zt(n.x) && (r.length = 0), n.x = Math.abs(f);
        const T = {
          type: "gap_center",
          gap: s,
          nudge: f
        }, I = r.find(({ type: N }) => N === "gap_center"), D = I && kl(
          s.breadthIntersection[0],
          s.breadthIntersection[1],
          I.gap.breadthIntersection[0],
          I.gap.breadthIntersection[1]
        );
        I && I.gap.length > s.length && D ? r[r.indexOf(I)] = T : (!I || !D) && r.push(T);
      }
      const g = s.startNode.pageBounds.minX - s.length, y = e.maxX, v = g - y;
      zt(Math.abs(v)) <= zt(n.x) && (zt(Math.abs(v)) < zt(n.x) && (r.length = 0), n.x = Math.abs(v), r.push({
        type: "gap_duplicate",
        gap: s,
        protrusionDirection: "left",
        nudge: v
      }));
      const S = s.endNode.pageBounds.maxX + s.length, x = e.minX, _ = S - x;
      zt(Math.abs(_)) <= zt(n.x) && (zt(Math.abs(_)) < zt(n.x) && (r.length = 0), n.x = Math.abs(_), r.push({
        type: "gap_duplicate",
        gap: s,
        protrusionDirection: "right",
        nudge: _
      }));
    }
    for (const s of this.visibleGaps.vertical) {
      if (!ky(
        s.breadthIntersection[0],
        s.breadthIntersection[1],
        e.minX,
        e.maxX
      ))
        continue;
      const f = s.startEdge[0].y + s.length / 2 - e.center.y;
      if (s.length > e.height && zt(Math.abs(f)) <= zt(n.y)) {
        zt(Math.abs(f)) < zt(n.y) && (a.length = 0), n.y = Math.abs(f);
        const T = {
          type: "gap_center",
          gap: s,
          nudge: f
        }, I = a.find(({ type: N }) => N === "gap_center"), D = I && ky(
          I.gap.breadthIntersection[0],
          I.gap.breadthIntersection[1],
          s.breadthIntersection[0],
          s.breadthIntersection[1]
        );
        I && I.gap.length > s.length && D ? a[a.indexOf(I)] = T : (!I || !D) && a.push(T);
        continue;
      }
      const g = s.startNode.pageBounds.minY - s.length, y = e.maxY, v = g - y;
      zt(Math.abs(v)) <= zt(n.y) && (zt(Math.abs(v)) < zt(n.y) && (a.length = 0), n.y = Math.abs(v), a.push({
        type: "gap_duplicate",
        gap: s,
        protrusionDirection: "top",
        nudge: v
      }));
      const S = s.endNode.pageBounds.maxY + s.length, x = e.minY, _ = S - x;
      zt(Math.abs(_)) <= zt(n.y) && (zt(Math.abs(_)) < zt(n.y) && (a.length = 0), n.y = Math.abs(_), a.push({
        type: "gap_duplicate",
        gap: s,
        protrusionDirection: "bottom",
        nudge: _
      }));
    }
  }
  getPointSnapLines({
    nearestSnapsX: e,
    nearestSnapsY: n
  }) {
    const r = {}, a = {}, s = [];
    if (e.length > 0) {
      for (const c of e)
        if (c.type === "points") {
          const f = zt(c.points.otherPoint.x);
          r[f] || (r[f] = []), r[f].push(c.points);
        }
    }
    if (n.length > 0) {
      for (const c of n)
        if (c.type === "points") {
          const f = zt(c.points.otherPoint.y);
          a[f] || (a[f] = []), a[f].push(c.points);
        }
    }
    for (const [c, f] of Object.entries(r).concat(Object.entries(a)))
      s.push({
        id: Ii(),
        type: "points",
        points: Sx(
          f.map((p) => O.From(p.otherPoint)).concat(f.map((p) => O.From(p.thisPoint))),
          (p, g) => p.equals(g)
        )
      });
    return s;
  }
  getGapSnapLines({
    selectionPageBounds: e,
    nearestSnapsX: n,
    nearestSnapsY: r
  }) {
    const a = {
      top: e.sides[0],
      right: e.sides[1],
      // need bottom and left to be sorted asc, which .sides is not.
      bottom: [e.corners[3], e.corners[2]],
      left: [e.corners[0], e.corners[3]]
    }, s = [];
    if (n.length > 0)
      for (const c of n) {
        if (c.type === "gap_center") {
          const f = (c.gap.length - e.width) / 2, p = kl(
            c.gap.breadthIntersection[0],
            c.gap.breadthIntersection[1],
            e.minY,
            e.maxY
          );
          s.push({
            type: "gaps",
            direction: "horizontal",
            id: Ii(),
            gaps: [
              ...ku(
                this.visibleGaps.horizontal,
                c.gap.startNode.id,
                f,
                "backward",
                p
              ),
              {
                startEdge: c.gap.startEdge,
                endEdge: a.left
              },
              {
                startEdge: a.right,
                endEdge: c.gap.endEdge
              },
              ...ku(
                this.visibleGaps.horizontal,
                c.gap.endNode.id,
                f,
                "forward",
                p
              )
            ]
          });
        }
        if (c.type === "gap_duplicate") {
          const f = kl(
            c.gap.breadthIntersection[0],
            c.gap.breadthIntersection[1],
            e.minY,
            e.maxY
          );
          s.push({
            type: "gaps",
            direction: "horizontal",
            id: Ii(),
            gaps: c.protrusionDirection === "left" ? [
              {
                startEdge: a.right,
                endEdge: [
                  O.Add(c.gap.startEdge[0], {
                    x: -c.gap.startNode.pageBounds.width,
                    y: 0
                  }),
                  O.Add(c.gap.startEdge[1], {
                    x: -c.gap.startNode.pageBounds.width,
                    y: 0
                  })
                ]
              },
              {
                startEdge: c.gap.startEdge,
                endEdge: c.gap.endEdge
              },
              ...ku(
                this.visibleGaps.horizontal,
                c.gap.endNode.id,
                c.gap.length,
                "forward",
                f
              )
            ] : [
              ...ku(
                this.visibleGaps.horizontal,
                c.gap.startNode.id,
                c.gap.length,
                "backward",
                f
              ),
              {
                startEdge: c.gap.startEdge,
                endEdge: c.gap.endEdge
              },
              {
                startEdge: [
                  O.Add(c.gap.endEdge[0], {
                    x: c.gap.endNode.pageBounds.width,
                    y: 0
                  }),
                  O.Add(c.gap.endEdge[1], {
                    x: c.gap.endNode.pageBounds.width,
                    y: 0
                  })
                ],
                endEdge: a.left
              }
            ]
          });
        }
      }
    if (r.length > 0)
      for (const c of r) {
        if (c.type === "gap_center") {
          const f = (c.gap.length - e.height) / 2, p = kl(
            c.gap.breadthIntersection[0],
            c.gap.breadthIntersection[1],
            e.minX,
            e.maxX
          );
          s.push({
            type: "gaps",
            direction: "vertical",
            id: Ii(),
            gaps: [
              ...ku(
                this.visibleGaps.vertical,
                c.gap.startNode.id,
                f,
                "backward",
                p
              ),
              {
                startEdge: c.gap.startEdge,
                endEdge: a.top
              },
              {
                startEdge: a.bottom,
                endEdge: c.gap.endEdge
              },
              ...ku(
                this.visibleGaps.vertical,
                c.gap.endNode.id,
                f,
                "forward",
                p
              )
            ]
          });
        }
        if (c.type === "gap_duplicate") {
          const f = kl(
            c.gap.breadthIntersection[0],
            c.gap.breadthIntersection[1],
            e.minX,
            e.maxX
          );
          s.push({
            type: "gaps",
            direction: "vertical",
            id: Ii(),
            gaps: c.protrusionDirection === "top" ? [
              {
                startEdge: a.bottom,
                endEdge: [
                  O.Add(c.gap.startEdge[0], {
                    x: 0,
                    y: -c.gap.startNode.pageBounds.height
                  }),
                  O.Add(c.gap.startEdge[1], {
                    x: 0,
                    y: -c.gap.startNode.pageBounds.height
                  })
                ]
              },
              {
                startEdge: c.gap.startEdge,
                endEdge: c.gap.endEdge
              },
              ...ku(
                this.visibleGaps.vertical,
                c.gap.endNode.id,
                c.gap.length,
                "forward",
                f
              )
            ] : [
              ...ku(
                this.visibleGaps.vertical,
                c.gap.startNode.id,
                c.gap.length,
                "backward",
                f
              ),
              {
                startEdge: c.gap.startEdge,
                endEdge: c.gap.endEdge
              },
              {
                startEdge: [
                  O.Add(c.gap.endEdge[0], {
                    x: 0,
                    y: c.gap.endNode.pageBounds.height
                  }),
                  O.Add(c.gap.endEdge[1], {
                    x: 0,
                    y: c.gap.endNode.pageBounds.height
                  })
                ],
                endEdge: a.top
              }
            ]
          });
        }
      }
    return one(s), s;
  }
}
y1([
  pt
], kb.prototype, "snapPointsCache", 1);
y1([
  pt
], kb.prototype, "visibleShapesNotInSelection", 1);
y1([
  pt
], kb.prototype, "visibleSnapPointsNotInSelection", 1);
y1([
  pt
], kb.prototype, "visibleGaps", 1);
function LD(t, e) {
  const { minX: n, maxX: r, minY: a, maxY: s } = e, c = [];
  switch (t) {
    case "top":
    case "left":
    case "top_left":
    case "any":
      c.push({
        id: "top_left",
        handle: "top_left",
        x: n,
        y: a
      });
  }
  switch (t) {
    case "top":
    case "right":
    case "top_right":
    case "any":
      c.push({
        id: "top_right",
        handle: "top_right",
        x: r,
        y: a
      });
  }
  switch (t) {
    case "bottom":
    case "right":
    case "bottom_right":
    case "any":
      c.push({
        id: "bottom_right",
        handle: "bottom_right",
        x: r,
        y: s
      });
  }
  switch (t) {
    case "bottom":
    case "left":
    case "bottom_left":
    case "any":
      c.push({
        id: "bottom_left",
        handle: "bottom_left",
        x: n,
        y: s
      });
  }
  return c;
}
const jD = new RegExp(
  `${[32, 160, 4961, 65792, 65793, 4153, 4241].map((t) => String.fromCodePoint(t)).join("|")}`
), ane = {
  start: "left",
  middle: "center",
  end: "right",
  justify: "justify"
};
class sne {
  constructor(e) {
    this.app = e;
  }
  getTextElement() {
    const e = document.createElement("div");
    return this.app.getContainer().appendChild(e), e.id = `__textMeasure_${Ii()}`, e.classList.add("rs-text"), e.classList.add("rs-text-measure"), e.tabIndex = -1, e;
  }
  measureText = (e) => {
    const n = this.getTextElement();
    n.setAttribute("dir", "ltr"), n.style.setProperty("font-family", e.fontFamily), n.style.setProperty("font-style", e.fontStyle), n.style.setProperty("font-weight", e.fontWeight), n.style.setProperty("font-size", e.fontSize + "px"), n.style.setProperty("line-height", e.lineHeight * e.fontSize + "px"), n.style.setProperty("width", e.width), n.style.setProperty("min-width", e.minWidth ?? null), n.style.setProperty("max-width", e.maxWidth), n.style.setProperty("padding", e.padding), n.textContent = Qr.normalizeTextForDom(e.text);
    const r = n.getBoundingClientRect();
    return n.remove(), {
      x: 0,
      y: 0,
      w: r.width,
      h: r.height
    };
  };
  getTextLines(e) {
    const n = this.getTextElement();
    n.style.setProperty("width", e.width - e.padding * 2 + "px"), n.style.setProperty("height", "min-content"), n.style.setProperty("dir", "ltr"), n.style.setProperty("font-size", e.fontSize + "px"), n.style.setProperty("font-family", e.fontFamily), n.style.setProperty("font-weight", e.fontWeight), n.style.setProperty("line-height", e.lineHeight * e.fontSize + "px"), n.style.setProperty("text-align", ane[e.textAlign]);
    const r = [];
    e.text.split(jD).flatMap(
      (v) => v.split(`
`).map((S) => S.trim()).join(`
`)
    );
    for (const v of e.text.split(jD))
      if (v.includes(`
`)) {
        const S = v.split(`
`);
        for (let x = 0; x < S.length; x++)
          S[x] = S[x].trim(), S[x] && r.push(S[x]), x < S.length - 1 && r.push(`
`);
      } else
        r.push(v);
    const a = [];
    for (let v = 0; v < r.length; v++) {
      const S = r[v];
      a.push(S), S === `
` && r[v + 1] === "" && v++;
    }
    let s = a.length - 1;
    for (; a[s] === "" && (a.pop(), s !== 0); )
      s--;
    let c = [];
    const f = [];
    n.textContent = "";
    let p = n.offsetHeight, g = n.textContent;
    for (let v = 0; v < a.length; v++) {
      const S = a[v], x = S === `
` ? S : `${S} `;
      if (n.textContent += x, n.offsetHeight <= p)
        c.push(c.length ? " " + S.trim() : S.trim());
      else if (!e.wrap || S === `
`)
        c = [], f.push(c);
      else {
        const T = n.textContent;
        n.textContent = g, n.textContent += `
`;
        const I = [...S];
        n.textContent += I[0], p = n.offsetHeight;
        let D = [I[0]];
        const N = [D];
        for (let L = 1; L < I.length; L++) {
          const z = I[L];
          n.textContent += z;
          const F = n.offsetHeight;
          F > p ? (D = [z], N.push(D), p = F) : D.push(z);
        }
        const j = N.map((L) => [L.join("")]);
        f.push(...j), c = f[f.length - 1], n.textContent = T, p = n.offsetHeight;
      }
      g = n.textContent;
    }
    const y = f.map((v) => v.join("").trim());
    return n.remove(), y;
  }
}
class lne {
  constructor(e) {
    this.app = e, this.app.disposables.add(this.dispose), this.start();
  }
  raf;
  isPaused = !0;
  last = 0;
  t = 0;
  start = () => {
    this.isPaused = !1, cancelAnimationFrame(this.raf), this.raf = requestAnimationFrame(this.tick), this.last = Date.now();
  };
  tick = () => {
    if (this.isPaused)
      return;
    const e = Date.now(), n = e - this.last;
    if (this.last = e, this.t += n, this.t < 16) {
      this.raf = requestAnimationFrame(this.tick);
      return;
    }
    this.t -= 16, this.updatePointerVelocity(n), this.app.emit("tick", n), this.raf = requestAnimationFrame(this.tick);
  };
  // Clear the listener
  dispose = () => {
    this.isPaused = !0, cancelAnimationFrame(this.raf);
  };
  prevPoint = new O();
  updatePointerVelocity = (e) => {
    const {
      prevPoint: n,
      app: {
        inputs: { currentScreenPoint: r, pointerVelocity: a }
      }
    } = this;
    if (e === 0)
      return;
    const s = O.Sub(r, n);
    this.prevPoint = r.clone();
    const c = s.len(), f = c ? s.div(c) : new O(0, 0), p = a.clone().lrp(f.mul(c / e), 0.5);
    Math.abs(p.x) < 0.01 && (p.x = 0), Math.abs(p.y) < 0.01 && (p.y = 0), a.equals(p) || (this.app.inputs.pointerVelocity = p);
  };
}
const cne = {
  wheel: "onWheel",
  pointer_enter: "onPointerEnter",
  pointer_leave: "onPointerLeave",
  pointer_down: "onPointerDown",
  pointer_move: "onPointerMove",
  pointer_up: "onPointerUp",
  right_click: "onRightClick",
  middle_click: "onMiddleClick",
  blur: "onBlur",
  key_down: "onKeyDown",
  key_up: "onKeyUp",
  cancel: "onCancel",
  complete: "onComplete",
  interrupt: "onInterrupt",
  double_click: "onDoubleClick",
  triple_click: "onTripleClick",
  quadruple_click: "onQuadrupleClick"
};
class sn {
  constructor(e, n) {
    this.app = e;
    const { id: r, children: a, initial: s } = this.constructor;
    this.id = r, this.current = fi("toolState" + this.id, void 0), this.path = pt("toolPath" + this.id, () => {
      const c = this.current.value;
      return this.id + (c ? `.${c.path.value}` : "");
    }), this.parent = n ?? {}, this.parent ? a && s ? (this.type = "branch", this.initial = s, this.children = Object.fromEntries(
      a().map((c) => [c.id, new c(this.app, this)])
    ), this.current.set(this.children[this.initial])) : this.type = "leaf" : (this.type = "root", a && s && (this.initial = s, this.children = Object.fromEntries(
      a().map((c) => [c.id, new c(this.app, this)])
    ), this.current.set(this.children[this.initial])));
  }
  path;
  static id;
  static initial;
  static children;
  id;
  current;
  type;
  styles = [];
  initial;
  children;
  parent;
  isActive = !1;
  transition(e, n) {
    const r = e.split(".");
    let a = this;
    for (let s = 0; s < r.length; s++) {
      const c = r[s], f = a.current.value, p = a.children?.[c];
      if (!p)
        throw Error(`${a.id} - no child state exists with the id ${c}.`);
      if (f?.id !== p.id && (f?.exit(n, c), a.current.set(p), p.enter(n, f?.id || "initial"), !p.isActive))
        break;
      a = p;
    }
    return this;
  }
  handleEvent(e) {
    const n = cne[e.name], r = this.current.value;
    this[n]?.(e), this.current.value === r && this.isActive && r?.handleEvent(e);
  }
  enter(e, n) {
    if (this.isActive = !0, this.onEnter?.(e, n), this.children && this.initial && this.isActive) {
      const r = this.children[this.initial];
      this.current.set(r), r.enter(e, n);
    }
  }
  exit(e, n) {
    this.isActive = !1, this.onExit?.(e, n), this.isActive || this.current.value?.exit(e, n);
  }
  onWheel;
  onPointerEnter;
  onPointerLeave;
  onPointerDown;
  onPointerMove;
  onPointerUp;
  onDoubleClick;
  onTripleClick;
  onQuadrupleClick;
  onRightClick;
  onMiddleClick;
  onKeyDown;
  onKeyUp;
  onCancel;
  onComplete;
  onInterrupt;
  onBlur;
  onEnter;
  onExit;
}
let une = class extends sn {
  static id = "idle";
  onPointerDown = (e) => {
    this.parent.transition("pointing", e);
  };
  onEnter = () => {
    this.app.setCursor({ type: "cross" });
  };
  onCancel = () => {
    this.app.setSelectedTool("select");
  };
}, dne = class extends sn {
  static id = "pointing";
  shapeType = "";
  shape;
  preciseTimeout = -1;
  didTimeout = !1;
  startPreciseTimeout() {
    this.preciseTimeout = window.setTimeout(() => {
      this.isActive && this.shape && (this.didTimeout = !0);
    }, 300);
  }
  clearPreciseTimeout() {
    clearTimeout(this.preciseTimeout);
  }
  onEnter = () => {
    const {
      inputs: { currentPagePoint: e }
    } = this.app;
    this.didTimeout = !1, this.shapeType = this.parent.shapeType, this.app.mark("creating");
    const n = no();
    this.app.createShapes([
      {
        id: n,
        type: this.shapeType,
        x: e.x,
        y: e.y
      }
    ]);
    const r = this.app.getShapeUtilByDef(to), a = this.app.getShapeById(n);
    if (!a)
      return;
    const s = r.handles?.(a);
    if (s) {
      const c = this.app.getPointInShapeSpace(a, e), f = r.onHandleChange?.(a, {
        handle: { ...s[0], x: c.x, y: c.y },
        isPrecise: !0
      });
      if (f) {
        const p = f.props?.start;
        p?.type === "binding" && this.app.setHintingIds([p.boundShapeId]), this.app.updateShapes([f], !0);
      }
    }
    this.app.select(n), this.shape = this.app.getShapeById(n), this.startPreciseTimeout();
  };
  onExit = () => {
    this.clearPreciseTimeout();
  };
  onPointerMove = () => {
    if (this.shape && this.app.inputs.isDragging) {
      const n = this.app.getShapeUtil(this.shape).handles?.(this.shape);
      if (!n)
        throw this.app.bailToMark("creating"), Error("No handles found");
      if (!this.didTimeout) {
        const r = this.app.getShapeUtilByDef(to), a = this.app.getShapeById(this.shape.id);
        if (!a)
          return;
        const s = r.handles(a);
        if (s) {
          const { x: c, y: f } = this.app.getPointInShapeSpace(a, this.app.inputs.originPagePoint), p = r.onHandleChange?.(a, {
            handle: {
              ...s[0],
              x: c,
              y: f
            },
            isPrecise: !1
          });
          p && this.app.updateShapes([p], !0);
        }
      }
      this.app.setSelectedTool("select.dragging_handle", {
        shape: this.shape,
        handle: n.find((r) => r.id === "end"),
        isCreating: !0,
        onInteractionEnd: "arrow"
      });
    }
  };
  onPointerUp = () => {
    this.cancel();
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.cancel();
  };
  onInterrupt = () => {
    this.cancel();
  };
  cancel() {
    this.app.bailToMark("creating"), this.app.setHintingIds([]), this.parent.transition("idle", {});
  }
};
class fne extends sn {
  static id = "arrow";
  static initial = "idle";
  static children = () => [une, dne];
  shapeType = "arrow";
  styles = [
    "color",
    "opacity",
    "dash",
    "size",
    "arrowheadStart",
    "arrowheadEnd",
    "font",
    "fill"
  ];
}
class pne extends sn {
  static id = "drawing";
  info = {};
  initialShape;
  util = this.app.getShapeUtilByDef(hj);
  isPen = !1;
  segmentMode = "free";
  didJustShiftClickToExtendPreviousShapeLine = !1;
  pagePointWhereCurrentSegmentChanged = {};
  pagePointWhereNextSegmentChanged = null;
  lastRecordedPoint = {};
  mergeNextPoint = !1;
  canDraw = !1;
  onEnter = (e) => {
    this.info = e, this.canDraw = !this.app.isMenuOpen, this.lastRecordedPoint = this.app.inputs.currentPagePoint.clone(), this.canDraw && this.startShape();
  };
  onPointerMove = () => {
    const {
      app: { inputs: e }
    } = this;
    this.isPen !== e.isPen && this.cancel(), !this.canDraw && e.isDragging && (this.startShape(), this.canDraw = !0), this.canDraw && (e.isPen ? O.Dist(e.currentPagePoint, this.lastRecordedPoint) >= 1 / this.app.camera.z ? (this.lastRecordedPoint = e.currentPagePoint.clone(), this.mergeNextPoint = !1) : this.mergeNextPoint = !0 : this.mergeNextPoint = !1, this.updateShapes());
  };
  onKeyDown = (e) => {
    if (e.key === "Shift")
      switch (this.segmentMode) {
        case "free": {
          this.segmentMode = "starting_straight", this.pagePointWhereNextSegmentChanged = this.app.inputs.currentPagePoint.clone();
          break;
        }
        case "starting_free":
          this.segmentMode = "starting_straight";
      }
    this.updateShapes();
  };
  onKeyUp = (e) => {
    if (e.key === "Shift")
      switch (this.app.snaps.clear(), this.segmentMode) {
        case "straight": {
          this.segmentMode = "starting_free", this.pagePointWhereNextSegmentChanged = this.app.inputs.currentPagePoint.clone();
          break;
        }
        case "starting_straight": {
          this.pagePointWhereNextSegmentChanged = null, this.segmentMode = "free";
          break;
        }
      }
    this.updateShapes();
  };
  onExit = () => {
    this.app.snaps.clear(), this.pagePointWhereCurrentSegmentChanged = this.app.inputs.currentPagePoint.clone();
  };
  getIsClosed(e, n) {
    const r = e[0].points[0], a = e[e.length - 1], s = a.points[a.points.length - 1];
    return (
      /*points.length > 3 &&*/
      O.Dist(r, s) < this.app.getStrokeWidth(n) * 2
    );
  }
  startShape() {
    const {
      inputs: { originPagePoint: e, isPen: n }
    } = this.app;
    this.app.mark("draw create start"), this.isPen = n;
    const r = this.isPen ? this.info.point.z * 1.25 : 0.5;
    if (this.segmentMode = this.app.inputs.shiftKey ? "straight" : "free", this.didJustShiftClickToExtendPreviousShapeLine = !1, this.lastRecordedPoint = e.clone(), this.initialShape) {
      const s = this.app.getShapeById(this.initialShape.id);
      if (s && this.segmentMode === "straight") {
        this.didJustShiftClickToExtendPreviousShapeLine = !0;
        const c = Bs(s.props.segments);
        if (!c)
          throw Error("Expected a previous segment!");
        const f = Bs(c.points);
        if (!f)
          throw Error("Expected a previous point!");
        const { x: p, y: g } = this.app.getPointInShapeSpace(s, e).toFixed(), y = this.isPen ? this.info.point.z * 1.25 : 0.5, v = {
          type: this.segmentMode,
          points: [
            {
              x: f.x,
              y: f.y,
              z: +y.toFixed(2)
            },
            {
              x: p,
              y: g,
              z: +y.toFixed(2)
            }
          ]
        }, S = De.applyToPoint(
          this.app.getPageTransformById(s.id),
          f
        );
        this.pagePointWhereCurrentSegmentChanged = S, this.pagePointWhereNextSegmentChanged = null;
        const x = [...s.props.segments, v];
        this.app.updateShapes([
          {
            id: s.id,
            type: "draw",
            props: {
              segments: x,
              isClosed: this.getIsClosed(x, s.props.size)
            }
          }
        ]);
        return;
      }
    }
    this.pagePointWhereCurrentSegmentChanged = e.clone();
    const a = no();
    this.app.createShapes([
      {
        id: a,
        type: "draw",
        x: e.x,
        y: e.y,
        props: {
          isPen: this.isPen,
          segments: [
            {
              type: this.segmentMode,
              points: [
                {
                  x: 0,
                  y: 0,
                  z: +r.toFixed(2)
                }
              ]
            }
          ]
        }
      }
    ]), this.initialShape = this.app.getShapeById(a);
  }
  updateShapes() {
    const { inputs: e } = this.app, { initialShape: n } = this;
    if (!n)
      return;
    const {
      id: r,
      props: { size: a }
    } = n, s = this.app.getShapeById(r);
    if (!s)
      return;
    const { segments: c } = s.props, { x: f, y: p, z: g } = this.app.getPointInShapeSpace(s, e.currentPagePoint).toFixed(), y = { x: f, y: p, z: this.isPen ? +(g * 1.25).toFixed(2) : 0.5 };
    switch (this.segmentMode) {
      case "starting_straight": {
        const { pagePointWhereNextSegmentChanged: v } = this;
        if (v === null)
          throw Error("We should have a point where the segment changed");
        if (O.Dist(v, e.currentPagePoint) > Jy) {
          this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone(), this.pagePointWhereNextSegmentChanged = null, this.segmentMode = "straight";
          const x = Bs(c);
          if (!x)
            throw Error("Expected a previous segment!");
          const _ = Bs(x.points);
          if (!_)
            throw Error("Expected a previous last point!");
          let T;
          if (x.type === "straight") {
            T = {
              type: "straight",
              points: [
                { ..._ },
                this.app.getPointInShapeSpace(s, this.pagePointWhereCurrentSegmentChanged).toFixed().toJson()
              ]
            };
            const I = this.app.getPageTransform(s);
            this.pagePointWhereCurrentSegmentChanged = De.applyToPoint(
              I,
              _
            );
          } else
            T = {
              type: "straight",
              points: [
                this.app.getPointInShapeSpace(s, this.pagePointWhereCurrentSegmentChanged).toFixed().toJson(),
                y
              ]
            };
          this.app.updateShapes(
            [
              {
                id: r,
                type: "draw",
                props: {
                  segments: [...c, T],
                  isClosed: this.getIsClosed(c, a)
                }
              }
            ],
            !0
          );
        }
        break;
      }
      case "starting_free": {
        const { pagePointWhereNextSegmentChanged: v } = this;
        if (v === null)
          throw Error("We should have a point where the segment changed");
        if (O.Dist(v, e.currentPagePoint) > Jy) {
          this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone(), this.pagePointWhereNextSegmentChanged = null, this.segmentMode = "free";
          const x = c.slice(), _ = x[x.length - 1], T = Bs(_.points);
          if (!T)
            throw Error("No previous point!");
          const I = {
            type: "free",
            points: [
              ...O.PointsBetween(T, y, 6).map((D) => D.toFixed().toJson())
            ]
          };
          this.app.updateShapes(
            [
              {
                id: r,
                type: "draw",
                props: {
                  segments: [...x, I],
                  isClosed: this.getIsClosed(c, a)
                }
              }
            ],
            !0
          );
        }
        break;
      }
      case "straight": {
        const v = c.slice(), S = v[v.length - 1], { pagePointWhereCurrentSegmentChanged: x } = this, { currentPagePoint: _, ctrlKey: T } = this.app.inputs;
        if (!x)
          throw Error("We should have a point where the segment changed");
        let I, D = !1;
        this.didJustShiftClickToExtendPreviousShapeLine ? this.app.inputs.isDragging && (D = !T, this.didJustShiftClickToExtendPreviousShapeLine = !1) : D = !T;
        let N = this.app.getPointInShapeSpace(s, _).toFixed().toJson(), j = !1, L;
        if ((this.app.userDocumentSettings.isSnapMode ? !T : T) && v.length > 2) {
          let F, K = 8 / this.app.camera.z;
          for (let X = 0, se = c.length - 2; X < se; X++) {
            const ue = c[X];
            if (!ue)
              break;
            if (ue.type === "free")
              continue;
            const pe = ue.points[0], Pe = Bs(ue.points);
            if (!(pe && Pe))
              continue;
            const ve = O.NearestPointOnLineSegment(
              pe,
              Pe,
              N
            ), Y = O.Dist(ve, N);
            if (Y < K) {
              F = ve.toFixed().toJson(), K = Y, L = ue;
              break;
            }
          }
          F && (j = !0, N = F);
        }
        if (j && L) {
          const F = this.app.getPageTransform(s), K = L.points[0], X = Bs(L.points);
          if (!X)
            throw Error("Expected a last point!");
          const se = De.applyToPoint(F, K), ue = De.applyToPoint(F, X), pe = De.applyToPoint(F, N);
          this.app.snaps.setLines([
            {
              id: Ii(),
              type: "points",
              points: [se, pe, ue]
            }
          ]);
        } else {
          if (this.app.snaps.clear(), D) {
            const F = O.Angle(x, _), X = Px(F, 24) - F;
            I = O.RotWith(
              _,
              x,
              X
            );
          } else
            I = _;
          N = this.app.getPointInShapeSpace(s, I).toFixed().toJson();
        }
        v[v.length - 1] = {
          ...S,
          type: "straight",
          points: [S.points[0], N]
        }, this.app.updateShapes(
          [
            {
              id: r,
              type: "draw",
              props: {
                segments: v,
                isClosed: this.getIsClosed(c, a)
              }
            }
          ],
          !0
        );
        break;
      }
      case "free": {
        const v = c.slice(), S = v[v.length - 1], x = [...S.points];
        if (x.length && this.mergeNextPoint) {
          const { z: _ } = x[x.length - 1];
          x[x.length - 1] = {
            x: y.x,
            y: y.y,
            z: _ ? Math.max(_, y.z) : y.z
          };
        } else
          x.push(y);
        if (v[v.length - 1] = {
          ...S,
          points: x
        }, this.app.updateShapes(
          [
            {
              id: r,
              type: "draw",
              props: {
                segments: v,
                isClosed: this.getIsClosed(c, a)
              }
            }
          ],
          !0
        ), x.length > 500) {
          this.app.updateShapes([{ id: r, type: "draw", props: { isComplete: !0 } }]);
          const { currentPagePoint: _ } = this.app.inputs, T = this.app.createShapeId();
          this.app.createShapes([
            {
              id: T,
              type: "draw",
              x: _.x,
              y: _.y,
              props: {
                isPen: this.isPen,
                segments: [
                  {
                    type: "free",
                    points: [{ x: 0, y: 0, z: this.isPen ? +(g * 1.25).toFixed() : 0.5 }]
                  }
                ]
              }
            }
          ]), this.initialShape = Ou(this.app.getShapeById(T)), this.mergeNextPoint = !1, this.lastRecordedPoint = this.app.inputs.currentPagePoint.clone();
        }
        break;
      }
    }
  }
  onPointerUp = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.complete();
  };
  onInterrupt = () => {
    this.app.inputs.isDragging || (this.app.bail(), this.cancel());
  };
  complete() {
    if (!this.canDraw) {
      this.cancel();
      return;
    }
    const { initialShape: e } = this;
    e && (this.app.updateShapes([
      { id: e.id, type: e.type, props: { isComplete: !0 } }
    ]), this.parent.transition("idle", {}));
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
}
let hne = class extends sn {
  static id = "idle";
  onPointerDown = (e) => {
    this.parent.transition("drawing", e);
  };
  onEnter = () => {
    this.app.setCursor({ type: "cross" });
  };
  onCancel = () => {
    this.app.setSelectedTool("select");
  };
};
class gne extends sn {
  static id = "draw";
  static initial = "idle";
  static children = () => [hne, pne];
  styles = ["color", "opacity", "dash", "fill", "size"];
  onExit = () => {
    const e = this.children.drawing;
    e.initialShape = void 0;
  };
}
class mne extends sn {
  static id = "erasing";
  info = {};
  scribble = {};
  markId = "";
  excludedShapeIds = /* @__PURE__ */ new Set();
  onEnter = (e) => {
    this.markId = this.app.mark("erase scribble begin"), this.info = e;
    const { originPagePoint: n } = this.app.inputs;
    this.excludedShapeIds = new Set(
      this.app.shapesArray.filter(
        (r) => (r.type === "frame" || r.type === "group") && this.app.isPointInShape(n, r)
      ).map((r) => r.id)
    ), this.startScribble(), this.update();
  };
  startScribble = () => {
    this.scribble = new Rj({
      onUpdate: this.onScribbleUpdate,
      onComplete: this.onScribbleComplete,
      color: "muted-1",
      size: 12
    }), this.app.on("tick", this.scribble.tick);
  };
  pushPointToScribble = () => {
    const { x: e, y: n } = this.app.inputs.currentPagePoint;
    this.scribble.addPoint(e, n);
  };
  onScribbleUpdate = (e) => {
    this.app.setScribble(e);
  };
  onScribbleComplete = () => {
    this.app.off("tick", this.scribble.tick), this.app.setScribble(null);
  };
  onExit = () => {
    this.scribble.stop();
  };
  onPointerMove = () => {
    this.update();
  };
  onPointerUp = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.complete();
  };
  update() {
    const {
      shapesArray: e,
      erasingIdsSet: n,
      inputs: { currentPagePoint: r, previousPagePoint: a }
    } = this.app, { excludedShapeIds: s } = this;
    this.pushPointToScribble();
    const c = new Set(n);
    for (const f of e) {
      if (f.type === "group")
        continue;
      const p = this.app.getPageMaskById(f.id);
      if (p && !Lu(r, p))
        continue;
      const g = this.app.getShapeUtil(f), y = this.app.getPointInShapeSpace(f, a), v = this.app.getPointInShapeSpace(f, r);
      g.hitTestLineSegment(f, y, v) && c.add(this.app.getOutermostSelectableShape(f).id);
    }
    this.app.setErasingIds([...c].filter((f) => !s.has(f)));
  }
  complete() {
    this.app.deleteShapes(this.app.pageState.erasingIds), this.app.setErasingIds([]), this.parent.transition("idle", {});
  }
  cancel() {
    this.app.setErasingIds([]), this.app.bailToMark(this.markId), this.parent.transition("idle", this.info);
  }
}
let vne = class extends sn {
  static id = "idle";
  onPointerDown = (e) => {
    this.parent.transition("pointing", e);
  };
}, yne = class extends sn {
  static id = "pointing";
  onEnter = () => {
    const { inputs: e } = this.app, n = /* @__PURE__ */ new Set(), r = n.size;
    for (const a of [...this.app.sortedShapesArray].reverse())
      if (this.app.isPointInShape(e.currentPagePoint, a)) {
        if (a.type === "group")
          continue;
        const s = this.app.getOutermostSelectableShape(a);
        if (s.type === "frame" && n.size > r)
          break;
        n.add(s.id);
      }
    this.app.setErasingIds([...n]);
  };
  onPointerMove = (e) => {
    this.app.inputs.isDragging && this.parent.transition("erasing", e);
  };
  onPointerUp = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.complete();
  };
  onInterrupt = () => {
    this.cancel();
  };
  complete() {
    const { erasingIds: e } = this.app;
    e.length && (this.app.mark("erase end"), this.app.deleteShapes(e)), this.app.setErasingIds([]), this.parent.transition("idle", {});
  }
  cancel() {
    this.app.setErasingIds([]), this.parent.transition("idle", {});
  }
};
class bne extends sn {
  static id = "eraser";
  static initial = "idle";
  static children = () => [vne, yne, mne];
  onEnter = () => {
    this.app.setCursor({ type: "cross" });
  };
}
let Sne = class extends sn {
  static id = "idle";
  onPointerDown = (e) => {
    this.parent.transition("pointing", e);
  };
  onEnter = () => {
    this.app.setCursor({ type: "cross" });
  };
  onCancel = () => {
    this.app.setSelectedTool("select");
  };
}, wne = class extends sn {
  static id = "pointing";
  markId = "creating";
  wasFocusedOnEnter = !1;
  onEnter = () => {
    const { isMenuOpen: e } = this.app;
    this.wasFocusedOnEnter = !e;
  };
  onPointerMove = (e) => {
    if (this.app.inputs.isDragging) {
      const { originPagePoint: n } = this.app.inputs, r = this.parent.shapeType, a = no();
      this.app.mark(this.markId), this.app.createShapes([
        {
          id: a,
          type: r,
          x: n.x,
          y: n.y,
          props: {
            w: 1,
            h: 1
          }
        }
      ]), this.app.setSelectedIds([a]), this.app.setSelectedTool("select.resizing", {
        ...e,
        target: "selection",
        handle: "bottom_right",
        isCreating: !0,
        creationCursorOffset: { x: 1, y: 1 },
        onInteractionEnd: this.parent.id
      });
    }
  };
  onPointerUp = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.complete();
  };
  onInterrupt = () => {
    this.cancel();
  };
  complete() {
    const { originPagePoint: e } = this.app.inputs;
    if (!this.wasFocusedOnEnter)
      return;
    this.app.mark(this.markId);
    const n = this.parent.shapeType, r = no();
    this.app.mark(this.markId), this.app.createShapes([
      {
        id: r,
        type: n,
        x: e.x,
        y: e.y
      }
    ]);
    const a = this.app.getShapeById(r), { w: s, h: c } = this.app.getShapeUtil(a).defaultProps(), f = this.app.getDeltaInParentSpace(a, new O(s / 2, c / 2));
    this.app.updateShapes([
      {
        id: r,
        type: n,
        x: a.x - f.x,
        y: a.y - f.y
      }
    ]), this.app.setSelectedIds([r]), this.app.instanceState.isToolLocked ? this.parent.transition("idle", {}) : this.app.setSelectedTool("select.idle");
  }
  cancel() {
    this.parent.transition("idle", {});
  }
};
class Ac extends sn {
  static id = "box";
  static initial = "idle";
  static children = () => [Sne, wne];
  styles = ["opacity"];
}
class xne extends Ac {
  static id = "frame";
  static initial = "idle";
  shapeType = "frame";
  styles = ["opacity"];
}
let Ene = class extends sn {
  static id = "idle";
  onPointerDown = (e) => {
    this.parent.transition("pointing", e);
  };
  onEnter = () => {
    this.app.setCursor({ type: "cross" });
  };
  onKeyUp = (e) => {
    if (e.key === "Enter") {
      const n = this.app.onlySelectedShape;
      n && n.type === "geo" && (this.app.mark("editing shape"), this.app.setEditingId(n.id), this.app.setSelectedTool("select.editing_shape", {
        ...e,
        target: "shape",
        shape: n
      }));
    }
  };
  onCancel = () => {
    this.app.setSelectedTool("select");
  };
}, Cne = class extends sn {
  static id = "pointing";
  onPointerMove = (e) => {
    if (this.app.inputs.isDragging) {
      const { originPagePoint: n } = this.app.inputs, r = no();
      this.app.mark("creating"), this.app.createShapes([
        {
          id: r,
          type: "geo",
          x: n.x,
          y: n.y,
          props: {
            w: 1,
            h: 1,
            geo: this.app.instanceState.propsForNextShape.geo
          }
        }
      ]), this.app.select(r), this.app.setSelectedTool("select.resizing", {
        ...e,
        target: "selection",
        handle: "bottom_right",
        isCreating: !0,
        creationCursorOffset: { x: 1, y: 1 },
        onInteractionEnd: "geo"
      });
    }
  };
  onPointerUp = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.complete();
  };
  onInterrupt = () => {
    this.cancel();
  };
  complete() {
    const { originPagePoint: e } = this.app.inputs, n = no();
    this.app.mark("creating"), this.app.createShapes([
      {
        id: n,
        type: "geo",
        x: e.x,
        y: e.y,
        props: {
          geo: this.app.instanceState.propsForNextShape.geo,
          w: 1,
          h: 1
        }
      }
    ]);
    const r = this.app.getShapeById(n);
    if (!r)
      return;
    const a = r.props.geo === "star" ? jq(5, 200, 200) : new ot(0, 0, 200, 200), s = this.app.getDeltaInParentSpace(r, a.center);
    this.app.select(n), this.app.updateShapes([
      {
        id: r.id,
        type: "geo",
        x: r.x - s.x,
        y: r.y - s.y,
        props: {
          geo: this.app.instanceState.propsForNextShape.geo,
          w: a.width,
          h: a.height
        }
      }
    ]), this.app.instanceState.isToolLocked ? this.parent.transition("idle", {}) : this.app.setSelectedTool("select", {});
  }
  cancel() {
    this.parent.transition("idle", {});
  }
};
class _ne extends sn {
  static id = "geo";
  static initial = "idle";
  static children = () => [Ene, Cne];
  styles = ["color", "opacity", "dash", "fill", "size", "geo", "font", "align"];
}
class Tne extends sn {
  static id = "dragging";
  onEnter = () => {
    this.update();
  };
  onPointerMove = () => {
    this.update();
  };
  onPointerUp = () => {
    this.complete();
  };
  onCancel = () => {
    this.complete();
  };
  onComplete = () => {
    this.complete();
  };
  update() {
    const { currentScreenPoint: e, previousScreenPoint: n } = this.app.inputs, r = O.Sub(e, n);
    (Math.abs(r.x) > 0 || Math.abs(r.y) > 0) && this.app.pan(r.x, r.y);
  }
  complete() {
    this.app.slideCamera({
      speed: Math.min(2, this.app.inputs.pointerVelocity.len()),
      direction: this.app.inputs.pointerVelocity,
      friction: lx
    }), this.parent.transition("idle", {});
  }
}
let kne = class extends sn {
  static id = "idle";
  onEnter = () => {
    this.app.setCursor({ type: "grab" });
  };
  onPointerDown = (e) => {
    this.parent.transition("pointing", e);
  };
  onCancel = () => {
    this.app.setSelectedTool("select");
  };
}, Pne = class extends sn {
  static id = "pointing";
  onEnter = () => {
    this.app.stopCameraAnimation(), this.app.setCursor({ type: "grabbing" });
  };
  onPointerMove = (e) => {
    this.app.inputs.isDragging && this.parent.transition("dragging", e);
  };
  onPointerUp = () => {
    this.complete();
  };
  onCancel = () => {
    this.complete();
  };
  onComplete = () => {
    this.complete();
  };
  onInterrupt = () => {
    this.complete();
  };
  complete() {
    this.parent.transition("idle", {});
  }
};
class Ine extends sn {
  static id = "hand";
  static initial = "idle";
  static children = () => [kne, Pne, Tne];
  styles = [];
  onDoubleClick = (e) => {
    if (e.phase === "settle") {
      const { currentScreenPoint: n } = this.app.inputs;
      this.app.zoomIn(n, { duration: 220, easing: ua.easeOutQuint });
    }
  };
  onTripleClick = (e) => {
    if (e.phase === "settle") {
      const { currentScreenPoint: n } = this.app.inputs;
      this.app.zoomOut(n, { duration: 320, easing: ua.easeOutQuint });
    }
  };
  onQuadrupleClick = (e) => {
    if (e.phase === "settle") {
      const {
        zoomLevel: n,
        inputs: { currentScreenPoint: r }
      } = this.app;
      n === 1 ? this.app.zoomToFit({ duration: 400, easing: ua.easeOutQuint }) : this.app.resetZoom(r, { duration: 320, easing: ua.easeOutQuint });
    }
  };
}
let Rne = class extends sn {
  static id = "idle";
  shapeId = "";
  onEnter = (e) => {
    this.shapeId = e.shapeId, this.app.setCursor({ type: "cross" });
  };
  onPointerDown = () => {
    this.parent.transition("pointing", { shapeId: this.shapeId });
  };
  onCancel = () => {
    this.app.setSelectedTool("select");
  };
}, $ne = class extends sn {
  static id = "pointing";
  shapeType = "";
  shape = {};
  markPointId = "";
  onEnter = (e) => {
    const { inputs: n } = this.app, { currentPagePoint: r } = n;
    this.shapeType = this.parent.shapeType, this.markPointId = this.app.mark("creating");
    let a = !1;
    if (e.shapeId) {
      const s = this.app.getShapeById(e.shapeId);
      s && (a = !0, this.shape = s);
    }
    if (n.shiftKey && a) {
      const c = this.app.getShapeUtil(this.shape).handles(this.shape).filter((x) => x.type === "vertex").sort(Ha), f = c[c.length - 1], p = De.applyToPoint(
        this.app.getParentTransform(this.shape),
        new O(this.shape.x, this.shape.y)
      );
      let g, y, v;
      c.length === 2 && c[1].x === 1 && c[1].y === 1 ? (g = c[1].index, y = c[1].id, v = {
        ...c[1],
        x: r.x - p.x,
        y: r.y - p.y
      }) : (g = Ru(f.index), y = "handle:" + g, v = {
        x: r.x - p.x,
        y: r.y - p.y,
        index: g,
        canBind: !1,
        type: "vertex",
        id: y
      });
      const S = Ou(this.shape.props.handles);
      S[v.id] = v, this.app.updateShapes([
        {
          id: this.shape.id,
          type: this.shape.type,
          props: {
            handles: S
          }
        }
      ]);
    } else {
      const s = no();
      this.app.createShapes([
        {
          id: s,
          type: this.shapeType,
          x: r.x,
          y: r.y
        }
      ]), this.app.select(s), this.shape = this.app.getShapeById(s);
    }
  };
  onPointerMove = () => {
    if (this.shape && this.app.inputs.isDragging) {
      const n = this.app.getShapeUtil(this.shape).handles?.(this.shape);
      if (!n)
        throw this.app.bailToMark("creating"), Error("No handles found");
      this.app.setSelectedTool("select.dragging_handle", {
        shape: this.shape,
        isCreating: !0,
        handle: Bs(n),
        onInteractionEnd: "line"
      });
    }
  };
  onPointerUp = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.complete();
  };
  onInterrupt = () => {
    this.parent.transition("idle", {}), this.app.bailToMark("creating"), this.app.snaps.clear();
  };
  complete() {
    this.parent.transition("idle", { shapeId: this.shape.id }), this.app.snaps.clear();
  }
  cancel() {
    this.app.bailToMark(this.markPointId), this.parent.transition("idle", { shapeId: this.shape.id }), this.app.snaps.clear();
  }
};
class Mne extends sn {
  static id = "line";
  static initial = "idle";
  static children = () => [Rne, $ne];
  shapeType = "line";
  styles = ["color", "opacity", "dash", "size", "spline"];
}
let Ane = class extends sn {
  static id = "idle";
  onPointerDown = (e) => {
    this.parent.transition("pointing", e);
  };
  onEnter = () => {
    this.app.setCursor({ type: "cross" });
  };
  onCancel = () => {
    this.app.setSelectedTool("select");
  };
}, One = class extends sn {
  static id = "pointing";
  dragged = !1;
  info = {};
  wasFocusedOnEnter = !1;
  markPointId = "creating";
  onEnter = () => {
    this.wasFocusedOnEnter = !this.app.isMenuOpen;
  };
  onPointerMove = (e) => {
    if (this.app.inputs.isDragging) {
      this.app.mark(this.markPointId);
      const n = this.createShape();
      if (!n)
        return;
      this.app.setSelectedTool("select.translating", {
        ...e,
        target: "shape",
        shape: n,
        isCreating: !0,
        editAfterComplete: !0,
        onInteractionEnd: "note"
      });
    }
  };
  onPointerUp = () => {
    this.complete();
  };
  onInterrupt = () => {
    this.cancel();
  };
  onComplete = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  complete() {
    if (!this.wasFocusedOnEnter)
      return;
    this.app.mark(this.markPointId);
    const e = this.createShape();
    if (this.app.instanceState.isToolLocked)
      this.parent.transition("idle", {});
    else {
      if (!e)
        return;
      this.app.setEditingId(e.id), this.app.setSelectedTool("select.editing_shape", {
        ...this.info,
        target: "shape",
        shape: e
      });
    }
  }
  cancel() {
    this.app.bailToMark(this.markPointId), this.parent.transition("idle", this.info);
  }
  createShape() {
    const {
      inputs: { originPagePoint: e }
    } = this.app, n = this.app.createShapeId();
    this.app.createShapes(
      [
        {
          id: n,
          type: "note",
          x: e.x,
          y: e.y
        }
      ],
      !0
    );
    const r = this.app.getShapeUtilByDef(lP), a = this.app.getShapeById(n);
    nL(lP.is(a));
    const s = r.bounds(a);
    return this.app.updateShapes([
      {
        id: n,
        type: "note",
        x: a.x - s.width / 2,
        y: a.y - s.height / 2
      }
    ]), this.app.getShapeById(n);
  }
};
class Dne extends sn {
  static id = "note";
  static initial = "idle";
  static children = () => [Ane, One];
  styles = ["color", "opacity", "size", "align", "font"];
}
class Nne extends sn {
  static id = "translating";
  info = {};
  selectionSnapshot = {};
  snapshot = {};
  markId = "";
  isCloning = !1;
  isCreating = !1;
  editAfterComplete = !1;
  dragAndDropManager = new ene(this.app);
  onEnter = (e) => {
    const { isCreating: n = !1, editAfterComplete: r = !1 } = e;
    this.info = e, this.isCreating = n, this.editAfterComplete = r, this.markId = n ? "creating" : this.app.mark("translating"), this.handleEnter(e), this.app.on("tick", this.updateParent);
  };
  updateParent = () => {
    const { snapshot: e } = this;
    this.dragAndDropManager.updateDroppingNode(e.movingShapes, this.updateParentTransforms);
  };
  onExit = () => {
    this.app.off("tick", this.updateParent), this.selectionSnapshot = {}, this.snapshot = {}, this.app.snaps.clear(), this.app.setCursor({ type: "default" }), this.dragAndDropManager.clear();
  };
  onPointerMove = () => {
    this.updateShapes();
  };
  onKeyDown = () => {
    if (this.app.inputs.altKey && !this.isCloning) {
      this.startCloning();
      return;
    }
    this.updateShapes();
  };
  onKeyUp = () => {
    if (!this.app.inputs.altKey && this.isCloning) {
      this.stopCloning();
      return;
    }
    this.updateShapes();
  };
  onPointerUp = () => {
    this.complete();
  };
  onComplete = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  reset() {
    this.app.bailToMark(this.markId);
  }
  startCloning() {
    this.isCreating || (this.isCloning = !0, this.reset(), this.markId = this.app.mark("translating"), this.app.duplicateShapes(), this.snapshot = zD(this.app), this.handleStart(), this.updateShapes());
  }
  stopCloning() {
    this.isCloning = !1, this.snapshot = this.selectionSnapshot, this.reset(), this.markId = this.app.mark("translating"), this.updateShapes();
  }
  complete() {
    if (this.updateShapes(), this.dragAndDropManager.dropShapes(this.snapshot.movingShapes), this.handleEnd(), this.app.instanceState.isToolLocked && this.info.onInteractionEnd)
      this.app.setSelectedTool(this.info.onInteractionEnd);
    else if (this.editAfterComplete) {
      const e = this.app.onlySelectedShape;
      e && (this.app.setEditingId(e.id), this.app.setSelectedTool("select"), this.app.root.current.value.transition("editing_shape", {}));
    } else
      this.parent.transition("idle", {});
  }
  cancel() {
    this.reset(), this.info.onInteractionEnd ? this.app.setSelectedTool(this.info.onInteractionEnd) : this.parent.transition("idle", this.info);
  }
  handleEnter(e) {
    if (this.isCloning = !1, this.info = e, this.app.setCursor({ type: "move" }), this.selectionSnapshot = zD(this.app), !this.isCreating && this.app.inputs.altKey) {
      this.startCloning();
      return;
    }
    this.snapshot = this.selectionSnapshot, this.handleStart(), this.updateShapes();
  }
  handleStart() {
    const { movingShapes: e } = this.snapshot, n = [];
    e.forEach((r) => {
      const s = this.app.getShapeUtil(r).onTranslateStart?.(r);
      s && n.push(s);
    }), n.length > 0 && this.app.updateShapes(n);
  }
  handleEnd() {
    const { movingShapes: e } = this.snapshot, n = [];
    e.forEach((r) => {
      const a = this.app.getShapeById(r.id), c = this.app.getShapeUtil(r).onTranslateEnd?.(r, a);
      c && n.push(c);
    }), n.length > 0 && this.app.updateShapes(n);
  }
  handleChange() {
    const { movingShapes: e } = this.snapshot, n = [];
    e.forEach((r) => {
      const a = this.app.getShapeById(r.id), c = this.app.getShapeUtil(r).onTranslate?.(r, a);
      c && n.push(c);
    }), n.length > 0 && this.app.updateShapes(n);
  }
  updateShapes() {
    const { snapshot: e } = this;
    this.dragAndDropManager.updateDroppingNode(e.movingShapes, this.updateParentTransforms), Lne({
      app: this.app,
      shapeSnapshots: e.shapeSnapshots,
      averagePagePoint: e.averagePagePoint,
      initialSelectionPageBounds: e.initialPageBounds,
      initialSelectionSnapPoints: e.initialSnapPoints
    }), this.handleChange();
  }
  updateParentTransforms = () => {
    const {
      app: e,
      snapshot: { shapeSnapshots: n }
    } = this;
    n.forEach((r) => {
      const a = e.getShapeById(r.shape.id);
      if (!a)
        return null;
      const s = fr.isId(a.parentId) ? null : De.Inverse(e.getPageTransformById(a.parentId));
      r.parentTransform = s;
    });
  };
}
function zD(t) {
  const e = [], n = [], r = Gt(
    t.selectedIds.map((a) => {
      const s = t.getShapeById(a);
      if (!s)
        return null;
      e.push(s);
      const c = t.getPagePointById(a);
      if (!c)
        return null;
      n.push(c);
      const f = fr.isId(s.parentId) ? null : De.Inverse(t.getPageTransformById(s.parentId));
      return {
        shape: s,
        pagePoint: c,
        parentTransform: f
      };
    })
  );
  return {
    averagePagePoint: O.Average(n),
    movingShapes: e,
    shapeSnapshots: r,
    initialPageBounds: t.selectedPageBounds,
    initialSnapPoints: t.selectedIds.length === 1 ? t.snaps.snapPointsCache.get(t.selectedIds[0]) : t.selectedPageBounds ? t.selectedPageBounds.snapPoints.map((a, s) => ({
      id: "selection:" + s,
      x: a.x,
      y: a.y
    })) : []
  };
}
function Lne({
  app: t,
  shapeSnapshots: e,
  averagePagePoint: n,
  initialSelectionPageBounds: r,
  initialSelectionSnapPoints: a
}) {
  const { inputs: s, isGridMode: c, gridSize: f } = t, p = O.Sub(s.currentPagePoint, s.originPagePoint), g = t.inputs.shiftKey ? Math.abs(p.x) < Math.abs(p.y) ? "x" : "y" : null;
  if (g === "x" ? p.x = 0 : g === "y" && (p.y = 0), t.snaps.clear(), (t.userDocumentSettings.isSnapMode ? !s.ctrlKey : s.ctrlKey) && t.inputs.pointerVelocity.len() < 0.5) {
    const { nudge: x } = t.snaps.snapTranslate({
      dragDelta: p,
      initialSelectionPageBounds: r,
      lockedAxis: g,
      initialSelectionSnapPoints: a
    });
    p.add(x);
  }
  const v = O.Add(n, p);
  c && !s.ctrlKey && v.snapToGrid(f);
  const S = O.Sub(v, n);
  t.updateShapes(
    Gt(
      e.map(({ shape: x, pagePoint: _, parentTransform: T }) => {
        const I = O.Add(_, S), D = T ? De.applyToPoint(T, I) : I;
        return {
          id: x.id,
          type: x.type,
          x: D.x,
          y: D.y
        };
      })
    ),
    !0
  );
}
class jne extends sn {
  static id = "brushing";
  info = {};
  brush = new ot();
  initialSelectedIds = [];
  // The shape that the brush started on
  initialStartShape = null;
  onEnter = (e) => {
    const { altKey: n, currentPagePoint: r } = this.app.inputs;
    if (n) {
      this.parent.transition("scribble_brushing", e);
      return;
    }
    this.info = e, this.initialSelectedIds = this.app.selectedIds.slice(), this.initialStartShape = this.app.getShapesAtPoint(r)[0], this.onPointerMove();
  };
  onExit = () => {
    this.initialSelectedIds = [], this.app.setBrush(null);
  };
  onPointerMove = () => {
    this.hitTestShapes();
  };
  onPointerUp = () => {
    this.complete();
  };
  onComplete = () => {
    this.complete();
  };
  onCancel = (e) => {
    this.app.setSelectedIds(this.initialSelectedIds, !0), this.parent.transition("idle", e);
  };
  onKeyDown = (e) => {
    this.app.inputs.altKey ? this.parent.transition("scribble_brushing", e) : this.hitTestShapes();
  };
  onKeyUp = () => {
    this.hitTestShapes();
  };
  complete() {
    this.parent.transition("idle", {});
  }
  hitTestShapes() {
    const {
      currentPageId: e,
      shapesArray: n,
      inputs: { originPagePoint: r, currentPagePoint: a, shiftKey: s, ctrlKey: c }
    } = this.app;
    this.brush.setTo(ot.FromPoints([r, a]));
    const f = new Set(s ? this.initialSelectedIds : []);
    let p, g, y, v, S, x, _;
    const { corners: T } = this.brush;
    e:
      for (let I = 0, D = n.length; I < D; I++) {
        if (y = n[I], y.type === "group" || f.has(y.id) || (S = this.app.getPageBounds(y), !S))
          continue e;
        if (this.brush.contains(S)) {
          this.handleHit(y, a, e, f, T);
          continue e;
        }
        if (c || y.type === "frame")
          continue e;
        if (this.brush.collides(S)) {
          if (v = this.app.getShapeUtil(y), x = this.app.getPageTransform(y), !x)
            continue e;
          _ = De.applyToPoints(De.Inverse(x), T);
          t:
            for (let N = 0; N < _.length; N++)
              if (p = _[N], g = _[(N + 1) % _.length], v.hitTestLineSegment(y, p, g)) {
                this.handleHit(y, a, e, f, T);
                break t;
              }
        }
      }
    this.app.setBrush({ ...this.brush.toJson() }), this.app.setSelectedIds(Array.from(f), !0);
  }
  onInterrupt = () => {
    this.app.setBrush(null);
  };
  handleHit(e, n, r, a, s) {
    if (e.parentId === r) {
      a.add(e.id);
      return;
    }
    const c = this.app.getOutermostSelectableShape(e), f = this.app.getPageMaskById(c.id);
    f && Qq(f, s) !== null && !Lu(n, f) || a.add(c.id);
  }
}
class zne extends sn {
  static id = "dragging_handle";
  shapeId = "";
  initialHandle = {};
  initialAdjacentHandle = null;
  markId = "";
  initialPageTransform;
  initialPageRotation;
  info = {};
  isPrecise = !1;
  isPreciseId = null;
  pointingId = null;
  onEnter = (e) => {
    const { shape: n, isCreating: r, handle: a } = e;
    this.info = e, this.shapeId = n.id, this.markId = r ? "creating" : this.app.mark("dragging handle"), this.initialHandle = Cc(a), this.initialPageTransform = this.app.getPageTransform(n), this.initialPageRotation = this.app.getPageRotation(n), this.app.setCursor({ type: r ? "cross" : "grabbing", rotation: 0 });
    const s = this.app.getShapeUtil(n).handles(n).sort(Ha), c = s.findIndex((p) => p.id === e.handle.id);
    this.initialAdjacentHandle = null;
    for (let p = c + 1; p < s.length; p++) {
      const g = s[p];
      if (g.type === "vertex" && g.id !== "middle" && g.id !== e.handle.id) {
        this.initialAdjacentHandle = g;
        break;
      }
    }
    if (!this.initialAdjacentHandle)
      for (let p = s.length - 1; p >= 0; p--) {
        const g = s[p];
        if (g.type === "vertex" && g.id !== "middle" && g.id !== e.handle.id) {
          this.initialAdjacentHandle = g;
          break;
        }
      }
    const f = n.props[e.handle.id];
    this.isPrecise = !1, f?.type === "binding" && (this.app.setHintingIds([f.boundShapeId]), this.isPrecise = !O.Equals(f.normalizedAnchor, { x: 0.5, y: 0.5 }), this.isPrecise ? this.isPreciseId = f.boundShapeId : this.resetExactTimeout()), this.update();
  };
  exactTimeout = -1;
  resetExactTimeout() {
    this.exactTimeout !== -1 && this.clearExactTimeout(), this.exactTimeout = setTimeout(() => {
      this.isActive && !this.isPrecise && (this.isPrecise = !0, this.isPreciseId = this.pointingId, this.update()), this.exactTimeout = -1;
    }, 750);
  }
  clearExactTimeout() {
    this.exactTimeout !== -1 && (clearTimeout(this.exactTimeout), this.exactTimeout = -1);
  }
  onPointerMove = () => {
    this.update();
  };
  onKeyDown = () => {
    this.update();
  };
  onKeyUp = () => {
    this.update();
  };
  onPointerUp = () => {
    this.complete();
  };
  onComplete = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  onExit = () => {
    this.app.setHintingIds([]), this.app.snaps.clear(), this.app.setCursor({ type: "default" });
  };
  complete() {
    this.app.snaps.clear();
    const { onInteractionEnd: e } = this.info;
    if (this.app.instanceState.isToolLocked && e) {
      this.app.setSelectedTool(e, { shapeId: this.shapeId });
      return;
    }
    this.parent.transition("idle", {});
  }
  cancel() {
    this.app.bailToMark(this.markId), this.app.snaps.clear();
    const { onInteractionEnd: e } = this.info;
    if (e) {
      this.app.setSelectedTool(e, { shapeId: this.shapeId });
      return;
    }
    this.parent.transition("idle", {});
  }
  update() {
    const { currentPagePoint: e, originPagePoint: n, shiftKey: r } = this.app.inputs, a = this.app.getShapeById(this.shapeId);
    if (!a)
      return;
    let s = O.Add(
      O.Rot(O.Sub(e, n), -this.initialPageRotation),
      this.initialHandle
    );
    if (r && this.initialHandle.id !== "middle") {
      const { initialAdjacentHandle: v } = this;
      if (v) {
        const S = O.Angle(v, s), _ = Px(S, 24) - S;
        s = O.RotWith(s, v, _);
      }
    }
    this.app.snaps.clear();
    const { ctrlKey: c } = this.app.inputs;
    if ((this.app.userDocumentSettings.isSnapMode ? !c : c) && a.type === "line") {
      const v = De.applyToPoint(this.app.getPageTransformById(a.id), s), S = this.app.snaps.snapLineHandleTranslate({
        lineId: a.id,
        handleId: this.initialHandle.id,
        handlePoint: v
      }), { nudge: x } = S;
      if (x.x || x.y) {
        const _ = this.app.getDeltaInShapeSpace(a, x);
        s = O.Add(s, _);
      }
    }
    const g = this.app.getShapeUtil(a).onHandleChange?.(a, {
      handle: {
        ...this.initialHandle,
        x: s.x,
        y: s.y
      },
      isPrecise: this.isPrecise || this.app.inputs.altKey
    }), y = { ...a, ...g };
    if (this.initialHandle.canBind) {
      const v = y.props[this.initialHandle.id];
      v?.type === "binding" ? this.app.hintingIds[0] !== v.boundShapeId && (this.app.setHintingIds([v.boundShapeId]), this.pointingId = v.boundShapeId, this.isPrecise = this.app.inputs.pointerVelocity.len() < 0.5 || this.app.inputs.altKey, this.isPreciseId = this.isPrecise ? v.boundShapeId : null, this.resetExactTimeout()) : this.app.hintingIds.length > 0 && (this.app.setHintingIds([]), this.pointingId = null, this.isPrecise = !1, this.isPreciseId = null, this.resetExactTimeout());
    }
    g && this.app.updateShapes([y], !0);
  }
}
class Une extends sn {
  static id = "editing_shape";
  onPointerEnter = (e) => {
    switch (e.target) {
      case "shape": {
        const { selectedIds: n, focusLayerId: r } = this.app, a = this.app.getOutermostSelectableShape(
          e.shape,
          (s) => !n.includes(s.id)
        );
        a.id !== r && this.app.setHoveredId(a.id);
        break;
      }
    }
  };
  onPointerLeave = (e) => {
    switch (e.target) {
      case "shape": {
        this.app.setHoveredId(null);
        break;
      }
    }
  };
  onExit = () => {
    if (!this.app.pageState.editingId)
      return;
    const { editingId: e } = this.app.pageState;
    if (!e)
      return;
    this.app.setEditingId(null);
    const n = this.app.getShapeById(e);
    this.app.getShapeUtil(n).onEditEnd?.(n);
  };
  onPointerDown = (e) => {
    switch (e.target) {
      case "shape": {
        const { shape: n } = e, { editingId: r } = this.app.pageState;
        if (r) {
          if (n.id === r)
            return;
          const a = this.app.getShapeById(r);
          if (a) {
            const s = this.app.getShapeUtil(n);
            if (n.type === a.type && s.canEdit?.(n)) {
              this.app.setEditingId(n.id), this.app.setHoveredId(n.id), this.app.setSelectedIds([n.id]);
              return;
            }
          }
        }
      }
    }
    this.parent.transition("idle", e), this.parent.current.value?.onPointerDown?.(e);
  };
  onComplete = (e) => {
    this.parent.transition("idle", e);
  };
  onCancel = (e) => {
    this.parent.transition("idle", e);
  };
  onBlur = (e) => {
    this.parent.transition("idle", e);
  };
}
let Bne = class extends sn {
  static id = "idle";
  onPointerEnter = (e) => {
    switch (e.target) {
      case "canvas":
        break;
      case "shape": {
        const { selectedIds: n, focusLayerId: r } = this.app, a = this.app.getOutermostSelectableShape(
          e.shape,
          (s) => !n.includes(s.id)
        );
        a.id !== r && this.app.setHoveredId(a.id);
        break;
      }
    }
  };
  onPointerLeave = (e) => {
    switch (e.target) {
      case "shape": {
        this.app.setHoveredId(null);
        break;
      }
    }
  };
  onPointerDown = (e) => {
    if (!this.app.isMenuOpen) {
      if (e.ctrlKey) {
        this.parent.transition("brushing", e);
        return;
      }
      switch (e.target) {
        case "canvas": {
          this.parent.transition("pointing_canvas", e);
          break;
        }
        case "shape": {
          this.parent.transition("pointing_shape", e);
          break;
        }
        case "handle": {
          if (this.app.isReadOnly)
            break;
          this.parent.transition("pointing_handle", e);
          break;
        }
        case "selection": {
          switch (e.handle) {
            case "mobile_rotate":
            case "top_left_rotate":
            case "top_right_rotate":
            case "bottom_left_rotate":
            case "bottom_right_rotate": {
              this.parent.transition("pointing_rotate_handle", e);
              break;
            }
            case "top":
            case "right":
            case "bottom":
            case "left": {
              this.parent.transition("pointing_resize_handle", e);
              break;
            }
            case "top_left":
            case "top_right":
            case "bottom_left":
            case "bottom_right": {
              this.parent.transition("pointing_resize_handle", e);
              break;
            }
            default:
              this.parent.transition("pointing_selection", e);
          }
          break;
        }
      }
    }
  };
  onDoubleClick = (e) => {
    switch (e.target) {
      case "canvas": {
        this.createTextShapeAtPoint(e);
        break;
      }
      case "selection": {
        if (this.app.isReadOnly)
          break;
        const { onlySelectedShape: n } = this.app;
        if (n) {
          const r = this.app.getShapeUtil(n);
          if (e.handle === "right" || e.handle === "left" || e.handle === "top" || e.handle === "bottom") {
            const a = r.onDoubleClickEdge?.(n);
            if (a) {
              this.app.mark("double click edge"), this.app.updateShapes([a]);
              return;
            }
          }
          r.canEdit(n) && this.startEditingShape(n, e);
        }
        break;
      }
      case "shape": {
        const { shape: n } = e, r = this.app.getShapeUtil(n);
        if (n.type !== "video" && this.app.isReadOnly)
          break;
        if (r.onDoubleClick) {
          const a = r.onDoubleClick?.(n);
          a && this.app.updateShapes([a]);
        } else
          r.canEdit(n) ? this.startEditingShape(n, e) : this.createTextShapeAtPoint(e);
        break;
      }
      case "handle": {
        if (this.app.isReadOnly)
          break;
        const { shape: n, handle: r } = e, a = this.app.getShapeUtil(n), s = a.onDoubleClickHandle?.(n, r);
        s ? this.app.updateShapes([s]) : a.canEdit(n) && this.startEditingShape(n, e);
      }
    }
  };
  onRightClick = (e) => {
    switch (e.target) {
      case "canvas": {
        this.app.selectNone();
        break;
      }
      case "shape": {
        const { selectedIds: n } = this.app.pageState, { shape: r } = e, a = this.app.getOutermostSelectableShape(
          r,
          (s) => !this.app.isSelected(s.id)
        );
        n.includes(a.id) || (this.app.mark("selecting shape"), this.app.setSelectedIds([a.id]));
        break;
      }
    }
  };
  onEnter = () => {
    this.app.setHoveredId(null), this.app.setCursor({ type: "default" });
  };
  onCancel = () => {
    // if there are no selected shapes
    this.app.selectedIds.length === 0 || // or if the only selected shape is a group and the focus layer is not the page
    this.app.selectedIds.length === 1 && this.app.getShapeById(this.app.selectedIds[0])?.type === "group" && this.app.focusLayerId !== this.app.currentPageId ? this.app.popFocusLayer() : (this.app.mark("clearing selection"), this.app.selectNone());
  };
  onKeyUp = (e) => {
    if (!this.app.isReadOnly)
      switch (e.key) {
        case "Enter": {
          const { selectedShapes: n } = this.app;
          if (n.every((a) => a.type === "group")) {
            this.app.setSelectedIds(
              n.flatMap((a) => this.app.getSortedChildIds(a.id))
            );
            return;
          }
          const { onlySelectedShape: r } = this.app;
          if (r && this.app.getShapeUtil(r).canEdit(r)) {
            this.startEditingShape(r, {
              ...e,
              target: "shape",
              shape: r
            });
            return;
          }
          break;
        }
      }
  };
  startEditingShape(e, n) {
    this.app.mark("editing shape"), this.app.setEditingId(e.id), this.parent.transition("editing_shape", n);
  }
  createTextShapeAtPoint(e) {
    this.app.mark("creating text shape");
    const n = no(), { x: r, y: a } = this.app.inputs.currentPagePoint;
    this.app.createShapes([
      {
        id: n,
        type: "text",
        x: r,
        y: a,
        props: {
          text: "",
          autoSize: !0
        }
      }
    ]);
    const s = this.app.getShapeById(n);
    if (!s)
      return;
    const c = this.app.getBounds(s);
    this.app.updateShapes([
      {
        id: n,
        type: "text",
        x: s.x - c.width / 2,
        y: s.y - c.height / 2
      }
    ]), this.app.setEditingId(n), this.app.select(n), this.parent.transition("editing_shape", e);
  }
};
class Fne extends sn {
  static id = "pointing_canvas";
  onEnter = () => {
    const { inputs: e } = this.app;
    e.shiftKey || this.app.selectedIds.length > 0 && (this.app.mark("selecting none"), this.app.selectNone());
  };
  _clickWasInsideFocusedGroup() {
    const { focusLayerId: e, inputs: n } = this.app;
    if (!Us(e))
      return !1;
    const r = this.app.getShapeById(e);
    if (!r)
      return !1;
    const a = this.app.getPointInShapeSpace(r, n.currentPagePoint);
    return this.app.getShapeUtil(r).hitTestPoint(r, a);
  }
  onPointerMove = (e) => {
    this.app.inputs.isDragging && this.parent.transition("brushing", e);
  };
  onPointerUp = () => {
    this.complete();
  };
  onComplete = () => {
    this.complete();
  };
  onInterrupt = () => {
    this.parent.transition("idle", {});
  };
  complete() {
    const { shiftKey: e } = this.app.inputs;
    e || (this.app.selectNone(), this._clickWasInsideFocusedGroup() || this.app.setFocusLayer(null)), this.parent.transition("idle", {});
  }
}
class Hne extends sn {
  static id = "pointing_handle";
  info = {};
  onEnter = (e) => {
    this.info = e;
    const n = e.shape.props[e.handle.id];
    n?.type === "binding" && this.app.setHintingIds([n.boundShapeId]), this.app.setCursor({ type: "grabbing" });
  };
  onExit = () => {
    this.app.setHintingIds([]), this.app.setCursor({ type: "default" });
  };
  onPointerUp = () => {
    this.parent.transition("idle", this.info);
  };
  onPointerMove = () => {
    this.app.inputs.isDragging && this.parent.transition("dragging_handle", this.info);
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.cancel();
  };
  onInterrupt = () => {
    this.cancel();
  };
  cancel() {
    this.parent.transition("idle", {});
  }
}
const Lx = {
  bottom: "ns-resize",
  top: "ns-resize",
  left: "ew-resize",
  right: "ew-resize",
  bottom_left: "nesw-resize",
  bottom_right: "nwse-resize",
  top_left: "nwse-resize",
  top_right: "nesw-resize",
  bottom_left_rotate: "swne-rotate",
  bottom_right_rotate: "senw-rotate",
  top_left_rotate: "nwse-rotate",
  top_right_rotate: "nesw-rotate",
  mobile_rotate: "grabbing"
};
class Vne extends sn {
  static id = "pointing_resize_handle";
  info = {};
  updateCursor() {
    const e = this.app.selectedShapes, n = Lx[this.info.handle];
    this.app.setCursor({
      type: n,
      rotation: e.length === 1 ? e[0].rotation : 0
    });
  }
  onEnter = (e) => {
    this.info = e, this.updateCursor();
  };
  onPointerMove = () => {
    this.app.inputs.isDragging && this.parent.transition("resizing", this.info);
  };
  onPointerUp = () => {
    this.parent.transition("idle", {});
  };
  // override onPinchStart: TLEventHandlers['onPinchStart'] = (info) => {
  // 	this.parent.transition('pinching', info)
  // }
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.cancel();
  };
  onInterrupt = () => {
    this.cancel();
  };
  cancel() {
    this.parent.transition("idle", {});
  }
}
class Yne extends sn {
  static id = "pointing_rotate_handle";
  info = {};
  updateCursor() {
    const { selectionRotation: e } = this.app;
    this.app.setCursor({
      type: Lx[this.info.handle],
      rotation: e
    });
  }
  onEnter = (e) => {
    this.info = e, this.updateCursor();
  };
  onPointerMove = () => {
    const { isDragging: e } = this.app.inputs;
    e && this.parent.transition("rotating", this.info);
  };
  onPointerUp = () => {
    this.parent.transition("idle", this.info);
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.cancel();
  };
  onInterrupt = () => {
    this.cancel();
  };
  cancel() {
    this.parent.transition("idle", {});
  }
}
class Kne extends sn {
  static id = "pointing_selection";
  info = {};
  onEnter = (e) => {
    this.info = e;
  };
  onPointerUp = (e) => {
    this.app.selectNone(), this.parent.transition("idle", e);
  };
  onPointerMove = (e) => {
    if (this.app.inputs.isDragging) {
      if (this.app.isReadOnly)
        return;
      this.parent.transition("translating", e);
    }
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.cancel();
  };
  onInterrupt = () => {
    this.cancel();
  };
  cancel() {
    this.parent.transition("idle", {});
  }
}
class Wne extends sn {
  static id = "pointing_shape";
  eventTargetShape = {};
  selectingShape = {};
  didSelectOnEnter = !1;
  onEnter = (e) => {
    const { shape: n } = e;
    if (n && this.app.getShapeUtil(n).onClick !== void 0)
      return;
    if (this.eventTargetShape = e.shape, this.selectingShape = this.app.getOutermostSelectableShape(e.shape), this.selectingShape.id === this.app.focusLayerId) {
      this.didSelectOnEnter = !1;
      return;
    }
    const r = this.app.isWithinSelection(this.selectingShape.id), a = this.app.selectedIds.length > 1 && // only on 2+ selected shapes!
    this.app.selectionBounds?.containsPoint(this.app.inputs.currentPagePoint);
    if (this.didSelectOnEnter = !r && this.selectingShape.id !== this.app.focusLayerId && !a, this.didSelectOnEnter) {
      const { inputs: s, selectedIds: c } = this.app, f = this.app.getParentShape(e.shape);
      f && f.type === "group" && this.app.cancelDoubleClick(), s.shiftKey && !s.altKey ? c.includes(this.selectingShape.id) || (this.app.mark("shift selecting shape"), this.app.setSelectedIds([...c, this.selectingShape.id])) : (this.app.mark("selecting shape"), this.app.setSelectedIds([this.selectingShape.id]));
    }
  };
  onPointerUp = (e) => {
    const { shape: n } = e;
    if (n) {
      const r = this.app.getShapeUtil(n);
      if (r.onClick) {
        const a = r.onClick?.(n);
        a && this.app.updateShapes([a]);
        return;
      }
    }
    if (!this.didSelectOnEnter && this.selectingShape.id !== this.app.focusLayerId) {
      this.app.mark("selecting shape (pointer up)");
      const r = this.app.getOutermostSelectableShape(
        this.eventTargetShape,
        // if a group is selected, we want to stop before reaching that group
        // so we can drill down into the group
        (a) => !this.app.isSelected(a.id)
      );
      if (this.app.selectedIds.includes(r.id))
        this.app.setSelectedIds(
          this.app.inputs.shiftKey ? this.app.selectedIds.filter((a) => a !== this.selectingShape.id) : [this.selectingShape.id]
        );
      else if (this.app.inputs.shiftKey) {
        const a = this.app.getAncestors(r);
        this.app.setSelectedIds([
          ...this.app.selectedIds.filter((s) => !a.find((c) => c.id === s)),
          r.id
        ]);
      } else
        this.app.setSelectedIds([r.id]);
    } else
      this.selectingShape.id === this.app.focusLayerId && (this.app.selectedIds.length > 0 ? this.app.setSelectedIds([]) : this.app.popFocusLayer());
    this.parent.transition("idle", e);
  };
  onPointerMove = (e) => {
    if (this.app.inputs.isDragging) {
      if (this.app.isReadOnly)
        return;
      this.parent.transition("translating", e);
    }
  };
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.cancel();
  };
  onInterrupt = () => {
    this.cancel();
  };
  cancel() {
    this.parent.transition("idle", {});
  }
}
class Gne extends sn {
  static id = "resizing";
  info = {};
  markId = "";
  // we transition into the resizing state from the geo pointing state, which starts with a shape of size w: 1, h: 1,
  // so if the user drags x: +50, y: +50 after mouseDown, the shape will be w: 51, h: 51, which is too many pixels, alas
  // so we allow passing a further offset into this state to negate such issues
  creationCursorOffset = { x: 0, y: 0 };
  editAfterComplete = !1;
  snapshot = {};
  onEnter = (e) => {
    const {
      isCreating: n = !1,
      editAfterComplete: r = !1,
      creationCursorOffset: a = { x: 0, y: 0 }
    } = e;
    this.info = e, this.editAfterComplete = r, this.creationCursorOffset = a, e.isCreating && this.app.setCursor({ type: "cross", rotation: 0 }), this.snapshot = this._createSnapshot(), this.markId = n ? "creating" : this.app.mark("starting resizing"), this.handleResizeStart(), this.updateShapes();
  };
  onPointerMove = () => {
    this.updateShapes();
  };
  onKeyDown = () => {
    this.updateShapes();
  };
  onKeyUp = () => {
    this.updateShapes();
  };
  onPointerUp = () => {
    this.complete();
  };
  onComplete = () => {
    this.complete();
  };
  onCancel = () => {
    this.cancel();
  };
  cancel() {
    this.app.bailToMark(this.markId), this.info.onInteractionEnd ? this.app.setSelectedTool(this.info.onInteractionEnd) : this.parent.transition("idle", {});
  }
  complete() {
    if (this.handleResizeEnd(), this.editAfterComplete && this.app.onlySelectedShape) {
      this.app.setEditingId(this.app.onlySelectedShape.id), this.app.setSelectedTool("select"), this.app.root.current.value.transition("editing_shape", {});
      return;
    }
    if (this.app.instanceState.isToolLocked && this.info.onInteractionEnd) {
      this.app.setSelectedTool(this.info.onInteractionEnd);
      return;
    }
    this.parent.transition("idle", {});
  }
  handleResizeStart() {
    const { shapeSnapshots: e } = this.snapshot, n = [];
    e.forEach(({ shape: r }) => {
      const s = this.app.getShapeUtil(r).onResizeStart?.(r);
      s && n.push(s);
    }), n.length > 0 && this.app.updateShapes(n);
  }
  handleResizeEnd() {
    const { shapeSnapshots: e } = this.snapshot, n = [];
    e.forEach(({ shape: r }) => {
      const a = this.app.getShapeById(r.id), c = this.app.getShapeUtil(r).onResizeEnd?.(r, a);
      c && n.push(c);
    }), n.length > 0 && this.app.updateShapes(n);
  }
  updateShapes() {
    const { altKey: e, shiftKey: n } = this.app.inputs, {
      shapeSnapshots: r,
      selectionBounds: a,
      cursorHandleOffset: s,
      selectedIds: c,
      selectionRotation: f,
      canShapesDeform: p
    } = this.snapshot, g = n || !p, { ctrlKey: y } = this.app.inputs, v = this.app.inputs.currentPagePoint.clone().sub(s).sub(this.creationCursorOffset), S = this.app.inputs.originPagePoint.clone().sub(s);
    this.app.isGridMode && !y && v.snapToGrid(this.app.gridSize);
    const x = this.info.handle, _ = UD(x, Math.PI);
    if (this.app.snaps.clear(), (this.app.userDocumentSettings.isSnapMode ? !y : y) && f % cr === 0) {
      const { nudge: F } = this.app.snaps.snapResize({
        dragDelta: O.Sub(v, S),
        initialSelectionPageBounds: this.snapshot.initialSelectionPageBounds,
        handle: UD(x, f),
        isAspectRatioLocked: g,
        isResizingFromCenter: e
      });
      v.add(F);
    }
    const I = O.RotWith(
      e ? a.center : a.getHandlePoint(_),
      a.point,
      f
    ), D = O.Sub(v, I).rot(
      -f
    ), N = O.Sub(S, I).rot(
      -f
    ), j = O.DivV(D, N);
    Number.isFinite(j.x) || (j.x = 1), Number.isFinite(j.y) || (j.y = 1);
    const L = x === "top" || x === "bottom", z = x === "left" || x === "right";
    g ? z ? j.y = Math.abs(j.x) : L ? j.x = Math.abs(j.y) : Math.abs(j.x) > Math.abs(j.y) ? j.y = Math.abs(j.x) * (j.y < 0 ? -1 : 1) : j.x = Math.abs(j.y) * (j.x < 0 ? -1 : 1) : (L && (j.x = 1), z && (j.y = 1)), this.info.isCreating || this.updateCursor({
      dragHandle: x,
      isFlippedX: j.x < 0,
      isFlippedY: j.y < 0,
      rotation: f
    });
    for (const F of r.keys()) {
      const K = r.get(F);
      this.app.resizeShape(F, j, {
        initialBounds: K.bounds,
        dragHandle: x,
        initialPageTransform: K.pageTransform,
        initialShape: K.shape,
        mode: c.length === 1 && F === c[0] ? "resize_bounds" : "scale_shape",
        scaleOrigin: I,
        scaleAxisRotation: f
      });
    }
  }
  // ---
  updateCursor({
    dragHandle: e,
    isFlippedX: n,
    isFlippedY: r,
    rotation: a
  }) {
    const s = { ...this.app.cursor };
    switch (e) {
      case "top_left":
      case "bottom_right": {
        s.type = "nwse-resize", n !== r && (s.type = "nesw-resize");
        break;
      }
      case "top_right":
      case "bottom_left": {
        s.type = "nesw-resize", n !== r && (s.type = "nwse-resize");
        break;
      }
    }
    s.rotation = a, this.app.setCursor(s);
  }
  onExit = () => {
    this.app.snaps.clear();
  };
  _createSnapshot = () => {
    const {
      selectedIds: e,
      selectionRotation: n,
      inputs: { originPagePoint: r }
    } = this.app, a = this.app.selectionBounds, s = O.RotWith(
      a.getHandlePoint(this.info.handle),
      a.point,
      n
    ), c = O.Sub(r, s), f = /* @__PURE__ */ new Map();
    e.forEach((g) => {
      const y = this.app.getShapeById(g);
      if (y) {
        if (f.set(y.id, this._createShapeSnapshot(y)), y.type === "frame" && e.length === 1)
          return;
        this.app.visitDescendants(y.id, (v) => {
          const S = this.app.getShapeById(v);
          if (S && (f.set(S.id, this._createShapeSnapshot(S)), S.type === "frame"))
            return !1;
        });
      }
    });
    const p = ![...f.values()].some(
      (g) => !TL(g.pageRotation, n) || g.isAspectRatioLocked
    );
    return {
      shapeSnapshots: f,
      selectionBounds: a,
      cursorHandleOffset: c,
      selectionRotation: n,
      selectedIds: e,
      canShapesDeform: p,
      initialSelectionPageBounds: this.app.selectedPageBounds
    };
  };
  _createShapeSnapshot = (e) => {
    const n = this.app.getPageTransform(e), r = this.app.getShapeUtil(e);
    return {
      shape: e,
      bounds: r.bounds(e),
      pageTransform: n,
      pageRotation: De.Decompose(n).rotation,
      isAspectRatioLocked: r.isAspectRatioLocked(e)
    };
  };
}
const ck = [
  "top",
  "top_right",
  "right",
  "bottom_right",
  "bottom",
  "bottom_left",
  "left",
  "top_left"
];
function UD(t, e) {
  e = e % Kr;
  const n = Math.round(e / (Yr / 4)), r = ck.indexOf(t);
  return ck[(r + n) % ck.length];
}
class Xne extends sn {
  static id = "rotating";
  snapshot = {};
  info = {};
  markId = "";
  onEnter = (e) => {
    this.info = e, this.markId = this.app.mark("rotate start"), this.snapshot = JL({ app: this.app }), this.handleStart();
  };
  onExit = () => {
    this.app.setCursor({ type: "none" }), this.snapshot = {};
  };
  onPointerMove = () => {
    this.update();
  };
  onKeyDown = () => {
    this.update();
  };
  onKeyUp = () => {
    this.update();
  };
  onPointerUp = () => {
    this.complete();
  };
  onComplete = () => {
    this.complete();
  };
  onCancel = () => {
    this.app.bailToMark(this.markId), this.parent.transition("idle", this.info);
  };
  // ---
  update = () => {
    const e = this._getRotationFromPointerPosition({
      snapToNearestDegree: !1
    });
    cx({
      app: this.app,
      delta: e,
      snapshot: this.snapshot,
      stage: "update"
    }), this.app.setCursor({
      type: Lx[this.info.handle],
      rotation: e + this.snapshot.initialSelectionRotation
    });
  };
  complete = () => {
    cx({
      app: this.app,
      delta: this._getRotationFromPointerPosition({ snapToNearestDegree: !0 }),
      snapshot: this.snapshot,
      stage: "end"
    }), this.parent.transition("idle", this.info);
  };
  handleStart() {
    const e = this._getRotationFromPointerPosition({
      snapToNearestDegree: !1
    });
    cx({
      app: this.app,
      delta: this._getRotationFromPointerPosition({ snapToNearestDegree: !1 }),
      snapshot: this.snapshot,
      stage: "start"
    }), this.app.setCursor({
      type: Lx[this.info.handle],
      rotation: e + this.snapshot.initialSelectionRotation
    });
  }
  _getRotationFromPointerPosition({ snapToNearestDegree: e }) {
    const {
      selectionPageCenter: n,
      inputs: { shiftKey: r, currentPagePoint: a }
    } = this.app, { initialCursorAngle: s, initialSelectionRotation: c } = this.snapshot, f = n.angle(a) - s;
    let p = c + f;
    if (r)
      p = Px(p, 24);
    else if (e && (p = Math.round(p / HO) * HO, this.app.isCoarsePointer)) {
      const g = Px(p, 4), y = CL(p, g);
      Math.abs(y) < Lq(5) && (p = g);
    }
    return p - c;
  }
}
class qne extends sn {
  static id = "scribble_brushing";
  static canActivateInReadOnly = !0;
  hits = /* @__PURE__ */ new Set();
  size = 0;
  scribble = {};
  initialSelectedIds = /* @__PURE__ */ new Set();
  newlySelectedIds = /* @__PURE__ */ new Set();
  onEnter = () => {
    this.initialSelectedIds = new Set(
      this.app.inputs.shiftKey ? this.app.selectedIds : []
    ), this.newlySelectedIds = /* @__PURE__ */ new Set(), this.size = 0, this.hits.clear(), this.startScribble(), this.updateBrushSelection(), requestAnimationFrame(() => {
      this.app.setBrush(null);
    });
  };
  onExit = () => {
    this.app.setErasingIds([]), this.scribble.stop();
  };
  onPointerMove = () => {
    this.updateBrushSelection();
  };
  onPointerUp = () => {
    this.complete();
  };
  onKeyDown = () => {
    this.updateBrushSelection();
  };
  onKeyUp = () => {
    this.app.inputs.altKey ? this.updateBrushSelection() : this.parent.transition("brushing", {});
  };
  startScribble = () => {
    this.scribble = new Rj({
      onUpdate: this.onScribbleUpdate,
      onComplete: this.onScribbleComplete,
      color: "selection-stroke",
      opacity: 0.32,
      size: 12
    }), this.app.on("tick", this.scribble.tick);
  };
  pushPointToScribble = () => {
    const { x: e, y: n } = this.app.inputs.currentPagePoint;
    this.scribble.addPoint(e, n);
  };
  onScribbleUpdate = (e) => {
    this.app.setScribble(e);
  };
  onScribbleComplete = () => {
    this.app.off("tick", this.scribble.tick), this.app.setScribble(null);
  };
  updateBrushSelection() {
    const {
      shapesArray: e,
      inputs: { originPagePoint: n, previousPagePoint: r, currentPagePoint: a }
    } = this.app;
    this.pushPointToScribble();
    const s = e;
    let c, f;
    for (let p = 0, g = s.length; p < g; p++)
      if (c = s[p], f = this.app.getShapeUtil(c), !(c.type === "group" || this.newlySelectedIds.has(c.id) || c.type === "frame" && f.hitTestPoint(c, this.app.getPointInShapeSpace(c, n))) && f.hitTestLineSegment(
        c,
        this.app.getPointInShapeSpace(c, r),
        this.app.getPointInShapeSpace(c, a)
      )) {
        const y = this.app.getOutermostSelectableShape(c), v = this.app.getPageMaskById(y.id);
        if (v && kI(
          r,
          a,
          v
        ) !== null && !Lu(a, v))
          continue;
        this.newlySelectedIds.add(y.id);
      }
    this.app.setSelectedIds(
      [.../* @__PURE__ */ new Set([...this.newlySelectedIds, ...this.initialSelectedIds])],
      !0
    );
  }
  onCancel = () => {
    this.cancel();
  };
  onComplete = () => {
    this.complete();
  };
  complete() {
    this.parent.transition("idle", {});
  }
  cancel() {
    this.app.setSelectedIds([...this.initialSelectedIds], !0), this.parent.transition("idle", {});
  }
}
class Qne extends sn {
  static id = "select";
  static initial = "idle";
  static children = () => [
    Bne,
    Fne,
    Wne,
    Nne,
    jne,
    qne,
    Kne,
    Vne,
    Une,
    Gne,
    Xne,
    Yne,
    Hne,
    zne
  ];
  styles = ["color", "opacity", "dash", "fill", "size"];
  onExit = () => {
    this.app.pageState.editingId && this.app.setEditingId(null);
  };
}
class Zne extends sn {
  static id = "idle";
  onPointerEnter = (e) => {
    switch (e.target) {
      case "canvas":
        break;
      case "shape": {
        const { selectedIds: n, focusLayerId: r } = this.app, a = this.app.getOutermostSelectableShape(
          e.shape,
          (s) => !n.includes(s.id)
        );
        a.id !== r && a.type === "text" && this.app.setHoveredId(a.id);
        break;
      }
    }
  };
  onPointerLeave = (e) => {
    switch (e.target) {
      case "shape": {
        this.app.setHoveredId(null);
        break;
      }
    }
  };
  onPointerDown = (e) => {
    const { hoveredId: n } = this.app;
    if (n) {
      const r = this.app.getShapeById(n);
      if (r.type === "text") {
        requestAnimationFrame(() => {
          this.app.setSelectedIds([r.id]), this.app.setEditingId(r.id), this.app.setSelectedTool("select.editing_shape", {
            ...e,
            target: "shape",
            shape: r
          });
        });
        return;
      }
    }
    this.parent.transition("pointing", e);
  };
  onEnter = () => {
    this.app.setCursor({ type: "cross" });
  };
  onKeyDown = (e) => {
    if (e.key === "Enter") {
      const n = this.app.selectedShapes[0];
      n && n.type === "geo" && (this.app.setSelectedTool("select"), this.app.setEditingId(n.id), this.app.root.current.value.transition("editing_shape", {
        ...e,
        target: "shape",
        shape: n
      }));
    }
  };
  onCancel = () => {
    this.app.setSelectedTool("select");
  };
}
class Jne extends sn {
  static id = "pointing";
  shape;
  onExit = () => {
    this.app.setHintingIds([]);
  };
  onPointerMove = (e) => {
    if (this.app.inputs.isDragging) {
      const {
        inputs: { originPagePoint: n }
      } = this.app, r = no();
      if (this.app.mark("creating"), this.app.createShapes([
        {
          id: r,
          type: "text",
          x: n.x,
          y: n.y,
          props: {
            text: "",
            autoSize: !1,
            w: 20
          }
        }
      ]), this.app.select(r), this.shape = this.app.getShapeById(r), !this.shape)
        return;
      this.app.setSelectedTool("select.resizing", {
        ...e,
        target: "selection",
        handle: "right",
        isCreating: !0,
        creationCursorOffset: { x: 1, y: 1 },
        editAfterComplete: !0,
        onInteractionEnd: "text"
      });
    }
  };
  onPointerUp = () => {
    this.complete();
  };
  onComplete = () => {
    this.cancel();
  };
  onCancel = () => {
    this.cancel();
  };
  onInterrupt = () => {
    this.cancel();
  };
  complete() {
    this.app.mark("creating text shape");
    const e = no(), { x: n, y: r } = this.app.inputs.currentPagePoint;
    this.app.createShapes(
      [
        {
          id: e,
          type: "text",
          x: n,
          y: r,
          props: {
            text: "",
            autoSize: !0
          }
        }
      ],
      !0
    ), this.app.setEditingId(e), this.app.setSelectedTool("select"), this.app.root.current.value?.transition("editing_shape", {});
  }
  cancel() {
    this.parent.transition("idle", {}), this.app.bailToMark("creating");
  }
}
class ere extends sn {
  static id = "text";
  static initial = "idle";
  static children = () => [Zne, Jne];
  styles = ["color", "opacity", "font", "align", "size"];
}
class tre extends sn {
  static id = "root";
  static initial = "select";
  static children = () => [
    Qne,
    Ine,
    bne,
    gne,
    ere,
    Mne,
    fne,
    _ne,
    Dne,
    xne
  ];
}
var nre = Object.defineProperty, rre = Object.getOwnPropertyDescriptor, ln = (t, e, n, r) => {
  for (var a = r > 1 ? void 0 : r ? rre(e, n) : e, s = t.length - 1, c; s >= 0; s--)
    (c = t[s]) && (a = (r ? c(e, n, a) : c(a)) || a);
  return r && a && nre(e, n, a), a;
};
function ire(t) {
  return t.type === "arrow" || t.type === "line" || t.type === "draw";
}
const $j = class extends Zq.EventEmitter {
  constructor({ config: t = Tb.default, store: e, getContainer: n }) {
    if (super(), e.schema !== t.storeSchema)
      throw new Error("Store schema does not match schema given to App");
    this.config = t, this.store = e, this.getContainer = n ?? (() => document.body), this.textMeasure = new sne(this), this.shapeUtils = Object.fromEntries(
      t.shapes.map((r) => [
        r.type,
        r.createShapeUtils(this)
      ])
    ), typeof window < "u" && "navigator" in window ? (this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), this.isIos = !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPhone/i)) : (this.isSafari = !1, this.isIos = !1), this.colors = new Map($j.styles.color.map((r) => [r.id, `var(--palette-${r.id})`])), this.root = new tre(this), this.root.children && t.tools.forEach((r) => {
      this.root.children[r.id] = new r(this);
    }), this.store.onBeforeDelete = (r) => {
      r.typeName === "shape" ? this._shapeWillBeDeleted(r) : r.typeName === "page" && this._pageWillBeDeleted(r);
    }, this.store.onAfterChange = (r, a) => {
      this._updateDepth++, this._updateDepth > 1e3 && console.error("[onAfterChange] Maximum update depth exceeded, bailing out."), r.typeName === "shape" && a.typeName === "shape" ? this._shapeDidChange(r, a) : r.typeName === "instance_page_state" && a.typeName === "instance_page_state" && this._tabStateDidChange(r, a), this._updateDepth--;
    }, this.store.onAfterCreate = (r) => {
      r.typeName === "shape" && to.is(r) && this._arrowDidUpdate(r);
    }, this._shapeIds = Kte(this.store, () => this.currentPageId), this._parentIdsToChildIds = Yte(this.store), this.disposables.add(
      this.store.listen((r) => {
        this.emit("change", r);
      })
    ), this.store.ensureStoreIsUsable(), this.root.enter(void 0, "initial"), this.updateCullingBounds(), requestAnimationFrame(() => {
      this._tickManager.start();
    });
  }
  /**
   * The editor's store
   *
   * @public
   */
  store;
  /**
   * The editor's config
   *
   * @public
   */
  config;
  /**
   * The root state of the statechart.
   *
   * @public
   */
  root;
  /**
   * A cache of shape ids in the current page.
   *
   * @internal
   */
  _shapeIds;
  /**
   * A set of functions to call when the app is disposed.
   *
   * @public
   */
  disposables = /* @__PURE__ */ new Set();
  /** @internal */
  _dprManager = new Jte(this);
  /** @internal */
  _cameraManager = new qte(this);
  /** @internal */
  _activeAreaManager = new Gte(this);
  /** @internal */
  _tickManager = new lne(this);
  /** @internal */
  _updateDepth = 0;
  /**
   * A manager for the app's snapping feature.
   *
   * @public
   */
  snaps = new kb(this);
  /**
   * Whether the editor is running in Safari.
   *
   * @public
   */
  isSafari;
  /**
   * Whether the editor is running on iOS.
   *
   * @public
   */
  isIos;
  // Flags
  _canMoveCamera = fi("can move camera", !0);
  get canMoveCamera() {
    return this._canMoveCamera.value;
  }
  set canMoveCamera(t) {
    this._canMoveCamera.set(t);
  }
  /**
   * The current HTML element containing the editor.
   *
   * @example
   * ```ts
   * const container = app.getContainer()
   * ```
   *
   * @public
   */
  getContainer;
  /**
   * The editor's userId (defined in its store.props).
   *
   * @example
   * ```ts
   * const userId = app.userId
   * ```
   *
   * @public
   */
  get userId() {
    return this.store.props.userId;
  }
  /**
   * The editor's instanceId (defined in its store.props).
   *
   * @example
   * ```ts
   * const instanceId = app.instanceId
   * ```
   *
   * @public
   */
  get instanceId() {
    return this.store.props.instanceId;
  }
  /** @internal */
  annotateError(t, {
    origin: e,
    willCrashApp: n,
    tags: r,
    extras: a
  }) {
    const s = this.createErrorAnnotations(e, n);
    uI(t, {
      tags: { ...s.tags, ...r },
      extras: { ...s.extras, ...a }
    }), n && this.store.markAsPossiblyCorrupted();
  }
  /** @internal */
  createErrorAnnotations(t, e) {
    try {
      return {
        tags: {
          origin: t,
          willCrashApp: e
        },
        extras: {
          activeStateNode: this.root.path.value,
          selectedShapes: this.selectedShapes,
          editingShape: this.editingId ? this.getShapeById(this.editingId) : void 0,
          inputs: this.inputs
        }
      };
    } catch {
      return {
        tags: {
          origin: t,
          willCrashApp: e
        },
        extras: {}
      };
    }
  }
  /** @internal */
  _crashingError = null;
  /**
   * we can't use an `atom` here because there's a chance that when
   * `crashAndReportError` is called, we're in a transaction that's about to
   * be rolled back due to the same error we're currently reporting.
   *
   * instead, to listen to changes to this value, you need to listen to app's
   * `crash` event.
   *
   * @internal
   */
  get crashingError() {
    return this._crashingError;
  }
  /** @internal */
  crash(t) {
    this._crashingError = t, this.store.markAsPossiblyCorrupted(), this.emit("crash");
  }
  get devicePixelRatio() {
    return this._dprManager.dpr.value;
  }
  /**
   * A set of strings representing any open menus or modals.
   *
   * @public
   */
  openMenus = /* @__PURE__ */ new Set();
  /**
   * Get whether any menus are open.
   *
   * @public
   */
  get isMenuOpen() {
    return this.openMenus.size > 0;
  }
  /** @internal */
  _isCoarsePointer = fi("isCoarsePointer", !1);
  /**
   * Whether the user is using a "coarse" pointer, such as on a touch screen.
   *
   * @public
   */
  get isCoarsePointer() {
    return this._isCoarsePointer.value;
  }
  set isCoarsePointer(t) {
    this._isCoarsePointer.set(t);
  }
  /** @internal */
  _isChangingStyle = fi("isChangingStyle", !1);
  /** @internal */
  _isChangingStyleTimeout = -1;
  /**
   * Whether the user is currently changing the style of a shape. This may cause the UI to change.
   *
   * @example
   * ```ts
   * app.isChangingStyle = true
   * ```
   *
   * @public
   */
  get isChangingStyle() {
    return this._isChangingStyle.value;
  }
  set isChangingStyle(t) {
    this._isChangingStyle.set(t), clearTimeout(this._isChangingStyleTimeout), t && (this._isChangingStyleTimeout = setTimeout(() => this.isChangingStyle = !1, 2e3));
  }
  get _pageTransformCache() {
    return this.store.createComputedCache("pageTransformCache", (t) => {
      if (fr.isId(t.parentId))
        return this.getTransform(t);
      const e = this._pageTransformCache.get(t.parentId);
      return De.Compose(e, this.getTransform(t));
    });
  }
  get _pageBoundsCache() {
    return this.store.createComputedCache("pageBoundsCache", (t) => {
      const e = this._pageTransformCache.get(t.id);
      return e ? ot.FromPoints(
        De.applyToPoints(e, this.getShapeUtil(t).outline(t))
      ) : new ot();
    });
  }
  get _pageMaskCache() {
    return this.store.createComputedCache("pageMaskCache", (t) => {
      if (fr.isId(t.parentId))
        return;
      const e = this.getAncestorsById(t.id).filter((r) => r.type === "frame");
      return e.length === 0 ? void 0 : e.map(
        (r) => (
          // Apply the frame transform to the frame outline to get the frame outline in page space
          De.applyToPoints(this._pageTransformCache.get(r.id), this.getOutline(r))
        )
      ).reduce((r, a) => a && r ? oP(r, a) ?? void 0 : void 0);
    });
  }
  /**
   * Get the page mask for a shape.
   *
   * @example
   * ```ts
   * const pageMask = app.getPageMaskById(shape.id)
   * ```
   *
   * @public
   *
   * @param id - The id of the shape to get the page mask for.
   *
   * @returns The page mask for the shape.
   */
  getPageMaskById(t) {
    return this._pageMaskCache.get(t);
  }
  get _clipPathCache() {
    return this.store.createComputedCache("clipPathCache", (t) => {
      const e = this._pageMaskCache.get(t.id);
      if (!e)
        return;
      const n = this._pageTransformCache.get(t.id);
      return n ? e.length === 0 ? "polygon(0px 0px, 0px 0px, 0px 0px)" : `polygon(${De.applyToPoints(De.Inverse(n), e).map((a) => `${a.x}px ${a.y}px`).join(",")})` : void 0;
    });
  }
  /**
   * Get the clip path for a shape.
   *
   * @example
   * ```ts
   * const clipPath = app.getClipPathById(shape.id)
   * ```
   *
   * @param id - The shape id.
   *
   * @returns The clip path or undefined.
   *
   * @public
   */
  getClipPathById(t) {
    return this._clipPathCache.get(t);
  }
  /**
   * A cache of parents to children.
   *
   * @internal
   */
  _parentIdsToChildIds;
  /**
   * Dispose the app.
   *
   * @public
   */
  dispose() {
    this.disposables.forEach((t) => t()), this.disposables.clear();
  }
  /**
   * A manager for the app's history.
   *
   * @readonly
   */
  history = new nne(
    this,
    () => this._complete(),
    (t) => {
      this.annotateError(t, { origin: "history.batch", willCrashApp: !0 }), this.crash(t);
    }
  );
  /**
   * Undo to the last mark.
   *
   * @example
   * ```ts
   * 	app.undo()
   * ```
   *
   * @public
   */
  undo() {
    return this.history.undo();
  }
  get canUndo() {
    return this.history.numUndos > 0;
  }
  /**
   * Redo to the next mark.
   *
   * @example
   * ```ts
   * 	app.redo()
   * ```
   *
   * @public
   */
  redo() {
    return this.history.redo(), this;
  }
  get canRedo() {
    return this.history.numRedos > 0;
  }
  /**
   * Create a new "mark", or stopping point, in the undo redo history. Creating a mark will clear
   * any redos.
   *
   * @example
   * ```ts
   * app.mark()
   * app.mark('flip shapes')
   * ```
   *
   * @param reason - The reason for the mark.
   * @param onUndo - Whether to stop at the mark when undoing.
   * @param onRedo - Whether to stop at the mark when redoing.
   * @public
   */
  mark(t, e, n) {
    return this.history.mark(t, e, n);
  }
  /**
   * Clear all marks in the undo stack back to the next mark.
   *
   * @example
   * ```ts
   * app.bail()
   * ```
   *
   * @public
   */
  bail() {
    return this.history.bail(), this;
  }
  /**
   * Clear all marks in the undo stack back to the mark with the provided mark id.
   *
   * @example
   * ```ts
   * app.bailToMark("creating")
   * ```
   *
   * @public
   */
  bailToMark(t) {
    return this.history.bailToMark(t), this;
  }
  /**
   * Run a function in a batch, which will be undone/redone as a single action.
   *
   * @example
   * ```ts
   * app.batch(() => {
   *   app.selectAll()
   *   app.deleteShapes()
   *   app.createShapes(myShapes)
   *   app.selectNone()
   * })
   *
   * app.undo() // will undo all of the above
   * ```
   *
   * @public
   */
  batch(t) {
    return this.history.batch(t), this;
  }
  /**
   * A map of shape utility classes (TLShapeUtils) by shape type.
   *
   * @public
   */
  shapeUtils;
  /**
   * Get a shape util for a given shape or shape type.
   *
   * @example
   * ```ts
   * 	app.getShapeUtil('geo')
   * ```
   * 	app.getShapeUtil(myBoxShape)
   *
   * @param type - The shape type.
   *
   * @public
   */
  getShapeUtil(t) {
    return this.shapeUtils[t.type];
  }
  /**
   * Get a shape util by its definition.
   *
   * @example
   * ```ts
   * app.getShapeUtilByDef(TLDrawShapeDef)
   * ```
   *
   * @param def - The shape definition.
   *
   * @public
   */
  getShapeUtilByDef(t) {
    return this.shapeUtils[t.type];
  }
  /**
   * A cache of children for each parent.
   *
   * @internal
   */
  _childIdsCache = new lm();
  /**
   * Get an array of all the children of a shape.
   *
   * @example
   * ```ts
   * 	app.getSortedChildIds('frame1')
   * ```
   *
   * @param parentId - The id of the parent shape.
   * @public
   */
  getSortedChildIds(t) {
    const e = this._parentIdsToChildIds.value[t];
    return e ? this._childIdsCache.get(e, () => e.map(([n]) => n)) : Ys;
  }
  /**
   * Run a visitor function for all descendants of a shape.
   *
   * @example
   * ```ts
   * 	app.visitDescendants('frame1', myCallback)
   * ```
   *
   * @param parentId - The id of the parent shape.
   * @param visitor - The visitor function.
   * @public
   */
  visitDescendants(t, e) {
    const n = this.getSortedChildIds(t);
    for (const r of n)
      e(r) !== !1 && this.visitDescendants(r, e);
  }
  get erasingIds() {
    return this.pageState.erasingIds;
  }
  get hintingIds() {
    return this.pageState.hintingIds;
  }
  get erasingIdsSet() {
    return new Set(this.erasingIds);
  }
  /**
   * Get all the current props among the users selected shapes
   *
   * @internal
   */
  _extractSharedProps(t, e) {
    if (t.type === "group") {
      const n = this._parentIdsToChildIds.value[t.id];
      if (!n)
        return;
      for (let r = 0, a = n.length; r < a; r++)
        this._extractSharedProps(this.getShapeById(n[r][0]), e);
    } else {
      const n = Object.entries(t.props);
      let r;
      for (let a = 0, s = n.length; a < s; a++)
        switch (r = n[a], e[r[0]]) {
          case void 0: {
            e[r[0]] = r[1];
            break;
          }
          case null:
          case r[1]:
            continue;
          default:
            e[r[0]] = null;
        }
    }
  }
  /**
   * A derived object containing all current props among the user's selected shapes.
   *
   * @internal
   */
  _selectionSharedProps = pt("_selectionSharedProps", () => {
    const { selectedShapes: t } = this, e = {};
    for (let n = 0, r = t.length; n < r; n++)
      this._extractSharedProps(t[n], e);
    return e;
  });
  get allowUiPaste() {
    return !!navigator.clipboard && !!navigator.clipboard.read;
  }
  /** @internal */
  _prevProps = {};
  get props() {
    let t;
    if (this.isIn("select") && this.selectedIds.length > 0)
      t = this._selectionSharedProps.value;
    else {
      const e = this.root.current.value;
      if (e.styles.length === 0)
        t = null;
      else {
        const { propsForNextShape: n } = this.instanceState;
        t = Object.fromEntries(
          e.styles.map((r) => [r, n[r]])
        );
      }
    }
    return JSON.stringify(this._prevProps) === JSON.stringify(t) ? this._prevProps : (this._prevProps = t, t);
  }
  /**
   * An array of all of the shapes on the current page.
   *
   * @public
   */
  get shapeIds() {
    return this._shapeIds.value;
  }
  /**
   * _invalidParents is used to trigger the 'onChildrenChange' callback that shapes
   * can have.
   *
   * @internal
   */
  _invalidParents = /* @__PURE__ */ new Set();
  /** @internal */
  _complete() {
    const { lastUpdatedPageId: t, lastUsedTabId: e } = this.userDocumentSettings;
    (e !== this.instanceId || t !== this.currentPageId) && this.store.put([
      {
        ...this.userDocumentSettings,
        lastUsedTabId: this.instanceId,
        lastUpdatedPageId: this.currentPageId
      }
    ]);
    for (const n of this._invalidParents) {
      this._invalidParents.delete(n);
      const r = this.getShapeById(n);
      if (!r)
        continue;
      const s = this.getShapeUtil(r).onChildrenChange?.(r);
      s?.length && this.updateShapes(s, !0);
    }
    this.updateUserPresence(), this.emit("update");
  }
  get _arrowBindingsIndex() {
    return Vte(this.store);
  }
  /**
   * getArrowsBoundTo
   */
  getArrowsBoundTo(t) {
    return this._arrowBindingsIndex.value[t] || Ys;
  }
  /** @internal */
  _reparentArrow(t) {
    const e = this.getShapeById(t);
    if (!e)
      return;
    const { start: n, end: r } = e.props, a = n.type === "binding" ? this.getShapeById(n.boundShapeId) : void 0, s = r.type === "binding" ? this.getShapeById(r.boundShapeId) : void 0, c = this.getParentPageId(e);
    if (!c)
      return;
    let f;
    if (a && s)
      f = this.findCommonAncestor([a, s]) ?? c;
    else if (a || s)
      f = c;
    else
      return;
    f && f !== e.parentId && this.reparentShapesById([t], f);
    const p = this.getShapeById(t), g = this.getNearestSiblingShape(p, a), y = this.getNearestSiblingShape(p, s);
    let v;
    if (g && y)
      v = g.index > y.index ? g : y;
    else if (g && !y)
      v = g;
    else if (y && !g)
      v = y;
    else
      return;
    let S;
    const x = this.getSortedChildIds(v.parentId).map((_) => this.getShapeById(_)).filter((_) => _.index > v.index);
    if (x.length) {
      const _ = x.find((T) => T.type !== "arrow");
      if (
        // ...then, if we're above the last shape we want to be above...
        p.index > v.index && // ...but below the next non-arrow sibling...
        (!_ || p.index < _.index)
      )
        return;
      S = Fy(v.index, x[0].index);
    } else
      S = Ru(v.index);
    S !== p.index && this.updateShapes([{ id: t, type: "arrow", index: S }]);
  }
  /** @internal */
  _unbindArrowTerminal(t, e) {
    const { x: n, y: r } = Mu(this, t)[e];
    this.store.put([{ ...t, props: { ...t.props, [e]: { type: "point", x: n, y: r } } }]);
  }
  // private _shapeWillUpdate = (prev: TLShape, next: TLShape) => {
  // 	const update = this.getShapeUtil(next).onUpdate?.(prev, next)
  // 	return update ?? next
  // }
  /** @internal */
  _shapeWillBeDeleted(t) {
    t.parentId && Us(t.parentId) && this._invalidParents.add(t.parentId);
    const e = this._arrowBindingsIndex.value[t.id];
    if (e?.length)
      for (const { arrowId: s, handleId: c } of e) {
        const f = this.getShapeById(s);
        f && this._unbindArrowTerminal(f, c);
      }
    const n = this.store.query.records("instance_page_state").value, r = /* @__PURE__ */ new Set([t.id]), a = Gt(
      n.map((s) => this._cleanupInstancePageState(s, r))
    );
    a.length && this.store.put(a);
  }
  /** @internal */
  _arrowDidUpdate(t) {
    for (const e of ["start", "end"]) {
      const n = t.props[e];
      if (n.type !== "binding")
        continue;
      const r = this.getShapeById(n.boundShapeId), a = this.getParentPageId(t) === this.getParentPageId(r);
      (!r || !a) && this._unbindArrowTerminal(t, e);
    }
    this._reparentArrow(t.id);
  }
  /** @internal */
  _cleanupInstancePageState(t, e) {
    let n = null;
    const r = t.selectedIds.filter((c) => !e.has(c));
    r.length !== t.selectedIds.length && (n || (n = { ...t }), n.selectedIds = r);
    const a = t.erasingIds.filter((c) => !e.has(c));
    a.length !== t.erasingIds.length && (n || (n = { ...t }), n.erasingIds = a), t.hoveredId && e.has(t.hoveredId) && (n || (n = { ...t }), n.hoveredId = null), t.editingId && e.has(t.editingId) && (n || (n = { ...t }), n.editingId = null);
    const s = t.hintingIds.filter((c) => !e.has(c));
    return s.length !== t.hintingIds.length && (n || (n = { ...t }), n.hintingIds = s), t.focusLayerId && e.has(t.focusLayerId) && (n || (n = { ...t }), n.focusLayerId = null), n;
  }
  /** @internal */
  _shapeDidChange(t, e) {
    if (to.is(e) && this._arrowDidUpdate(e), t.parentId !== e.parentId) {
      const n = (r) => {
        const a = this._arrowBindingsIndex.value[r];
        if (a?.length)
          for (const s of a)
            this._reparentArrow(s.arrowId);
      };
      n(e.id), this.visitDescendants(e.id, n);
    }
    if (t.parentId !== e.parentId && fr.isId(e.parentId)) {
      const n = /* @__PURE__ */ new Set([t.id]);
      this.visitDescendants(t.id, (r) => {
        n.add(r);
      });
      for (const r of this.store.query.records("instance_page_state").value) {
        if (r.pageId === e.parentId)
          continue;
        const a = this._cleanupInstancePageState(r, n);
        a && this.store.put([a]);
      }
    }
    t.parentId && Us(t.parentId) && this._invalidParents.add(t.parentId), e.parentId !== t.parentId && Us(e.parentId) && this._invalidParents.add(e.parentId);
  }
  /** @internal */
  _tabStateDidChange(t, e) {
    if (t?.selectedIds !== e?.selectedIds) {
      const n = e.selectedIds.filter((a) => {
        let s = this.getShapeById(a)?.parentId;
        for (; Us(s); ) {
          if (e.selectedIds.includes(s))
            return !1;
          s = this.getShapeById(s)?.parentId;
        }
        return !0;
      }), r = n.length === 0 ? e?.focusLayerId : this.findCommonAncestor(
        Gt(n.map((a) => this.getShapeById(a))),
        (a) => a.type === "group"
      );
      (n.length !== e.selectedIds.length || r != e.focusLayerId) && this.store.put([{ ...e, selectedIds: n, focusLayerId: r ?? null }]);
    }
  }
  /** @internal */
  _pageWillBeDeleted(t) {
    const e = this.store.query.exec("instance", { currentPageId: { eq: t.id } });
    if (!e.length)
      return;
    const n = this.pages.find((r) => r.id !== t.id)?.id;
    n && this.store.put(e.map((r) => ({ ...r, currentPageId: n })));
  }
  get documentSettings() {
    return this.store.get(kx);
  }
  get gridSize() {
    return this.documentSettings.gridSize;
  }
  /**
   * The user's global settings.
   *
   * @public
   * @readonly
   */
  get userSettings() {
    return this.store.get(this.userId);
  }
  get _userDocumentSettings() {
    return this.store.query.record("user_document", () => ({ userId: { eq: this.userId } }));
  }
  get userDocumentSettings() {
    return this._userDocumentSettings.value;
  }
  get isReadOnly() {
    return this.userDocumentSettings.isReadOnly;
  }
  get isGridMode() {
    return this.userDocumentSettings.isGridMode;
  }
  setGridMode(t) {
    this.updateUserDocumentSettings({ isGridMode: t }, !0);
  }
  setDarkMode(t) {
    this.updateUserDocumentSettings({ isDarkMode: t }, !0);
  }
  //** @public */
  enableReadOnlyMode() {
    this.updateUserDocumentSettings({ isReadOnly: !0 }), this.setSelectedTool("hand");
  }
  /** @internal */
  _isPenMode = fi("isPenMode", !1);
  /** @internal */
  _touchEventsRemainingBeforeExitingPenMode = 0;
  get isPenMode() {
    return this._isPenMode.value;
  }
  setPenMode(t) {
    t && (this._touchEventsRemainingBeforeExitingPenMode = 3), this._isPenMode.set(t);
  }
  // User / User App State
  /**
   * The current user state.
   *
   * @public
   */
  get user() {
    return this.store.get(this.userId);
  }
  /** The current tab state */
  get instanceState() {
    return this.store.get(this.instanceId);
  }
  get cursor() {
    return this.instanceState.cursor;
  }
  get brush() {
    return this.instanceState.brush;
  }
  get scribble() {
    return this.instanceState.scribble;
  }
  get _pageState() {
    return this.store.query.record(
      "instance_page_state",
      () => ({
        pageId: { eq: this.currentPageId },
        instanceId: { eq: this.instanceId }
      }),
      "app._pageState"
    );
  }
  /**
   * The current page state.
   *
   * @public
   */
  get pageState() {
    return this._pageState.value;
  }
  get camera() {
    return this.store.get(this.pageState.cameraId);
  }
  get zoomLevel() {
    return this.camera.z;
  }
  get selectedIds() {
    return this.pageState.selectedIds;
  }
  get selectedIdsSet() {
    return new Set(this.selectedIds);
  }
  get _pages() {
    return this.store.query.records("page");
  }
  get pages() {
    return this._pages.value.sort(Ha);
  }
  /**
   * The current page.
   *
   * @public
   */
  get currentPage() {
    return this.getPageById(this.currentPageId);
  }
  /**
   * The current page id.
   *
   * @public
   */
  get currentPageId() {
    return this.instanceState.currentPageId;
  }
  /**
   * Get a page by its ID.
   *
   * @example
   * ```ts
   * 	app.getPageById(myPage.id)
   * ```
   *
   * @public
   */
  getPageById(t) {
    return this.store.get(t);
  }
  get _pageStates() {
    return this.store.query.records("instance_page_state", () => ({
      instanceId: { eq: this.instanceId }
    }));
  }
  /**
   * Get a page state by its id.
   *
   * @example
   * ```ts
   * 	app.getPageStateByPageId('page1')
   * ```
   *
   * @public
   */
  getPageStateByPageId(t) {
    return this._pageStates.value.find((e) => e.pageId === t);
  }
  /**
   * Get a page by its ID.
   *
   * @example
   * ```ts
   * 	app.getPageById(myPage.id)
   * ```
   *
   * @public
   */
  getPageInfoById(t) {
    return this.store.get(t);
  }
  /**
   * Get shapes on a page.
   */
  getShapesInPage(t) {
    const e = this.store.query.exec("shape", { parentId: { eq: t } });
    return this.getShapesAndDescendantsInOrder(e.map((n) => n.id));
  }
  /* --------------------- Shapes --------------------- */
  /**
   * Get the local transform for a shape as a matrix model. This transform reflects both its
   * translation (x, y) from from either its parent's top left corner, if the shape's parent is
   * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the
   * shape's rotation.
   *
   * @example
   * ```ts
   * 	app.getTransform(myShape)
   * ```
   *
   * @param shape - The shape to get the local transform for.
   * @public
   */
  getTransform(t) {
    return this.getShapeUtil(t).transform(t);
  }
  /**
   * Get the local transform of a shape's parent as a matrix model.
   *
   * @example
   * ```ts
   * 	app.getParentTransform(myShape)
   * ```
   *
   * @param shape - The shape to get the parent transform for.
   * @public
   */
  getParentTransform(t) {
    return fr.isId(t.parentId) ? De.Identity() : this._pageTransformCache.get(t.parentId) ?? De.Identity();
  }
  /**
   * Get the page transform (or absolute transform) of a shape.
   *
   * @example
   * ```ts
   * 	app.getPageTransform(myShape)
   * ```
   *
   * @param shape - The shape to get the page transform for.
   * @public
   */
  getPageTransform(t) {
    return this.getPageTransformById(t.id);
  }
  /**
   * Get the page transform (or absolute transform) of a shape by its id.
   *
   * @example
   * ```ts
   * 	app.getPageTransformById(myShape)
   * ```
   *
   * @param id - The if of the shape to get the page transform for.
   * @public
   */
  getPageTransformById(t) {
    return this._pageTransformCache.get(t);
  }
  /**
   * Get the page point (or absolute point) of a shape.
   *
   * @example
   * ```ts
   * 	app.getPagePoint(myShape)
   * ```
   *
   * @param shape - The shape to get the page point for.
   * @public
   */
  getPagePointById(t) {
    const e = this.getPageTransformById(t);
    if (e)
      return De.applyToPoint(e, new O());
  }
  /**
   * Get the page point (or absolute point) of a shape.
   *
   * @example
   * ```ts
   * 	app.getPagePoint(myShape)
   * ```
   *
   * @param shape - The shape to get the page point for.
   * @public
   */
  getPageCenter(t) {
    const e = this.getPageTransformById(t.id);
    if (!e)
      return null;
    const r = this.getShapeUtil(t).center(t);
    return De.applyToPoint(e, r);
  }
  /**
   * Get the page point (or absolute point) of a shape by its id.
   *
   * @example
   * ```ts
   * 	app.getPagePoint(myShape)
   * ```
   *
   * @param id - The shape id to get the page point for.
   * @public
   */
  getPageCenterById(t) {
    const e = this.getShapeById(t);
    return this.getPageCenter(e);
  }
  /**
   * Get the page rotation (or absolute rotation) of a shape.
   *
   * @example
   * ```ts
   * 	app.getPageRotation(myShape)
   * ```
   *
   * @param shape - The shape to get the page rotation for.
   * @public
   */
  getPageRotation(t) {
    return this.getPageRotationById(t.id);
  }
  /**
   * Get the page rotation (or absolute rotation) of a shape by its id.
   *
   * @param id - The id of the shape to get the page rotation for.
   */
  getPageRotationById(t) {
    const e = this.getPageTransformById(t);
    return e ? De.Decompose(e).rotation : 0;
  }
  /**
   * Get the local bounds of a shape.
   *
   * @example
   * ```ts
   * 	app.getBounds(myShape)
   * ```
   *
   * @param shape - The shape to get the bounds for.
   * @public
   */
  getBounds(t) {
    return this.getShapeUtil(t).bounds(t);
  }
  /**
   * Get the local bounds of a shape by its id.
   *
   * @example
   * ```ts
   * 	app.getBoundsById(myShape)
   * ```
   *
   * @param id - The id of the shape to get the bounds for.
   * @public
   */
  getBoundsById(t) {
    const e = this.getShapeById(t);
    if (e)
      return this.getBounds(e);
  }
  /**
   * Get the page (or absolute) bounds of a shape.
   *
   * @example
   * ```ts
   * 	app.getPageBounds(myShape)
   * ```
   *
   * @param shape - The shape to get the bounds for.
   * @public
   */
  getPageBounds(t) {
    return this.getPageBoundsById(t.id);
  }
  /**
   * Get the page (or absolute) bounds of a shape by its id.
   *
   * @example
   * ```ts
   * 	app.getPageBoundsById(myShape)
   * ```
   *
   * @param id - The id of the shape to get the page bounds for.
   * @public
   */
  getPageBoundsById(t) {
    return this._pageBoundsCache.get(t);
  }
  /**
   * Get the page (or absolute) bounds of a shape, incorporating any masks.
   * For example, if the shape were the child of a frame and was half way out of the frame,
   * the bounds would be the half of the shape that was in the frame.
   *
   * @example
   * ```ts
   * 	app.getMaskedPageBounds(myShape)
   * ```
   *
   * @param shape - The shape to get the masked bounds for.
   * @public
   */
  getMaskedPageBounds(t) {
    return this.getMaskedPageBoundsById(t.id);
  }
  /**
   * Get the page (or absolute) bounds of a shape by its id, incorporating any masks.
   * For example, if the shape were the child of a frame and was half way out of the frame,
   * the bounds would be the half of the shape that was in the frame.
   *
   * @example
   * ```ts
   * 	app.getMaskedPageBoundsById(myShape)
   * ```
   *
   * @param id - The id of the shape to get the masked page bounds for.
   * @public
   */
  getMaskedPageBoundsById(t) {
    const e = this._pageBoundsCache.get(t);
    if (!e)
      return;
    const n = this._pageMaskCache.get(t);
    if (n) {
      const r = oP(n, e.corners);
      return r ? ot.FromPoints(r) : void 0;
    }
    return e;
  }
  /**
   * Get the local outline of a shape.
   *
   * @example
   * ```ts
   * 	app.getOutline(myShape)
   * ```
   *
   * @param shape - The shape to get the outline for.
   * @public
   */
  getOutline(t) {
    return this.getShapeUtil(t).outline(t);
  }
  /**
   * Get the local outline of a shape.
   *
   * @example
   * ```ts
   * 	app.getOutlineById(myShape)
   * ```
   *
   * @param id - The shape id to get the outline for.
   * @public
   */
  getOutlineById(t) {
    return this.getOutline(this.getShapeById(t));
  }
  /**
   * Get the ancestors of a shape.
   *
   * @example
   * ```ts
   * 	const ancestors = app.getAncestors(myShape)
   * ```
   *
   * @param shape - The shape to get the ancestors for.
   * @public
   */
  getAncestors(t, e = []) {
    const n = t.parentId;
    if (fr.isId(n))
      return e.reverse(), e;
    const r = this.store.get(n);
    return e.push(r), this.getAncestors(r, e);
  }
  /**
   * Get the ancestors of a shape by its id.
   *
   * @example
   * ```ts
   * 	const ancestors = app.getAncestorsById(myShape)
   * ```
   *
   * @param id - The id of the shape to get the ancestors for.
   * @public
   */
  getAncestorsById(t, e = []) {
    const n = this.getShapeById(t);
    return this.getAncestors(n, e);
  }
  /**
   * Find the first ancestor matching the given predicate
   *
   * @example
   * ```ts
   * 	const ancestor = app.findAncestor(myShape)
   * ```
   *
   * @param shape - The shape to check the ancestors for.
   * @public
   */
  findAncestor(t, e) {
    const n = t.parentId;
    if (fr.isId(n))
      return;
    const r = this.getShapeById(n);
    if (r)
      return e(r) ? r : this.findAncestor(r, e);
  }
  /**
   * Returns true if the the given shape has the given ancestor
   *
   */
  hasAncestor(t, e) {
    return t ? t.parentId === e ? !0 : this.hasAncestor(this.getParentShape(t), e) : !1;
  }
  /**
   * Get the common ancestor of two or more shapes that matches a predicate.
   *
   * @param shapes - The shapes to check.
   * @param predicate - The predicate to match.
   */
  findCommonAncestor(t, e) {
    if (t.length === 0)
      return;
    if (t.length === 1) {
      const s = t[0].parentId;
      return fr.isId(s) ? void 0 : e ? this.findAncestor(t[0], e)?.id : s;
    }
    const [n, ...r] = t;
    let a = this.getParentShape(n);
    for (; a; ) {
      if (e && !e(a)) {
        a = this.getParentShape(a);
        continue;
      }
      if (r.every((s) => this.hasAncestor(s, a.id)))
        return a.id;
      a = this.getParentShape(a);
    }
  }
  /**
   * Check whether a shape is within the bounds of the current viewport.
   *
   * @param id - The id of the shape to check.
   *
   * @public
   */
  isShapeInViewport(t) {
    const e = this.getPageBoundsById(t);
    return e ? this.viewportPageBounds.includes(e) : !1;
  }
  get renderingShapes() {
    const { currentPageId: t, cullingBounds: e, cullingBoundsExpanded: n, erasingIdsSet: r, editingId: a } = this, s = [], c = (f, p, g) => {
      const y = this.getShapeById(f);
      if (!y)
        return;
      let v = +y.props.opacity * p, S = !1;
      !g && r.has(f) && (S = !0, v *= 0.32);
      const x = this.getMaskedPageBoundsById(f), _ = x ? e.includes(x) : !1, T = x ? a !== f && !n.includes(x) : !0;
      s.push({ id: f, index: s.length, opacity: v, isCulled: T, isInViewport: _ }), this.getSortedChildIds(f).forEach((I) => {
        c(I, v, g || S);
      });
    };
    return this.getSortedChildIds(t).forEach((f) => c(f, 1, !1)), s.sort(MZ);
  }
  get allShapesCommonBounds() {
    let t = null;
    return this.shapeIds.forEach((e) => {
      const n = this.getMaskedPageBoundsById(e);
      n && (t ? t.expand(n) : t = n.clone());
    }), t;
  }
  /**
   * Get the corners of a shape in page space.
   *
   * @example
   * ```ts
   * 	const corners = app.getPageCorners(myShape)
   * ```
   *
   * @param shape - The shape to get the corners for.
   * @public
   */
  getPageCorners(t) {
    const e = this.getAncestors(t), n = this.getBounds(t).corners, r = De.Compose(
      ...e.flatMap((a) => [De.Translate(a.x, a.y), De.Rotate(a.rotation)]),
      De.Translate(t.x, t.y),
      De.Rotate(t.rotation, 0, 0)
    );
    return De.applyToPoints(r, n);
  }
  /**
   * Test whether a point (in page space) will will a shape. This method takes into
   * account masks, such as when a shape is the child of a frame and is partially
   * clipped by the frame.
   *
   * @example
   * ```ts
   * 	app.isPointInShape({ x: 100, y: 100 }, myShape)
   * ```
   *
   * @param point - The page point to test.
   * @param shape - The shape to test against.
   * @public
   */
  isPointInShape(t, e) {
    const n = this.getShapeUtil(e), r = this._pageMaskCache.get(e.id);
    return r && !Lu(t, r) ? !1 : n.hitTestPoint(e, this.getPointInShapeSpace(e, t));
  }
  /**
   * Get the shapes, if any, at a given page point.
   *
   * @example
   * ```ts
   * 	app.getShapesAtPoint({ x: 100, y: 100 })
   * ```
   *
   * @param point - The page point to test.
   * @public
   */
  getShapesAtPoint(t) {
    return this.sortedShapesArray.filter((e) => {
      const n = this._pageMaskCache.get(e.id);
      return n && !Lu(t, n) ? !1 : this.getShapeUtil(e).hitTestPoint(e, this.getPointInShapeSpace(e, t));
    });
  }
  /**
   * Convert a point in page space to a point in the local space of a shape. For example, if a
   * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
   * `{ x: 10, y: 10 }` in the shape's local space.
   *
   * @example
   * ```ts
   * 	app.getPointInShapeSpace(myShape, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   * @public
   */
  getPointInShapeSpace(t, e) {
    return De.applyToPoint(De.Inverse(this.getPageTransform(t)), e);
  }
  /**
   * Convert a delta in page space to a point in the local space of a shape. For example, if a
   * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
   * `{ x: 10, y: 10 }` in the shape's local space.
   *
   * @example
   * ```ts
   * 	app.getPointInShapeSpace(myShape.id, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   * @public
   */
  getPointInParentSpace(t, e) {
    const n = this.getShapeById(t);
    if (!n)
      return new O(0, 0);
    if (fr.isId(n.parentId))
      return O.From(e);
    const r = this.getPageTransformById(n.parentId);
    return r ? De.applyToPoint(De.Inverse(r), e) : O.From(e);
  }
  /**
   * Convert a delta in page space to a delta in the local space of a shape.
   *
   * @example
   * ```ts
   * 	app.getDeltaInShapeSpace(myShape, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the delta in the local space of.
   * @param delta - The page delta to convert.
   * @public
   */
  getDeltaInShapeSpace(t, e) {
    const n = this.getPageTransform(t);
    return n ? O.Rot(e, -De.Decompose(n).rotation) : O.From(e);
  }
  /**
   * Convert a delta in page space to a delta in the parent space of a shape.
   *
   * @example
   * ```ts
   * 	app.getDeltaInParentSpace(myShape, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the delta in the parent space of.
   * @param delta - The page delta to convert.
   * @public
   */
  getDeltaInParentSpace(t, e) {
    if (fr.isId(t.parentId))
      return O.From(e);
    const n = this.getShapeById(t.parentId);
    return n ? this.getDeltaInShapeSpace(n, e) : O.From(e);
  }
  /**
   * For a given set of ids, get a map containing the ids of their parents and the children of those
   * parents.
   *
   * @example
   * ```ts
   * 	app.getParentsMappedToChildren(['id1', 'id2', 'id3'])
   * ```
   *
   * @param ids - The ids to get the parents and children of.
   * @public
   */
  getParentsMappedToChildren(t) {
    const e = t.map((r) => this.store.get(r)), n = /* @__PURE__ */ new Map();
    return e.forEach((r) => {
      n.has(r.parentId) || n.set(r.parentId, /* @__PURE__ */ new Set()), n.get(r.parentId)?.add(r);
    }), n;
  }
  /* -------------------- Viewport -------------------- */
  /**
   * Update the viewport. The viewport will measure the size and
   * screen position of its container element. This should be done whenever
   * the container's position on the screen changes.
   *
   * @example
   * ```ts
   * 	app.updateViewportScreenBounds()
   * ```
   *
   * @param center - Whether to preserve the viewport page center as the viewport changes. (optional)
   *
   * @public
   */
  updateViewportScreenBounds(t = !1) {
    const e = this.getContainer();
    if (!e)
      return this;
    const n = e.getBoundingClientRect(), r = new ot(0, 0, Math.max(n.width, 1), Math.max(n.height, 1)), a = r.equals(this.viewportScreenBounds), { _willSetInitialBounds: s } = this;
    if (a)
      this._willSetInitialBounds = !1;
    else if (s)
      this._willSetInitialBounds = !1, this.updateInstanceState({ screenBounds: r.toJson() }, !0, !0);
    else {
      const { zoomLevel: f } = this;
      if (t) {
        const p = this.viewportPageCenter;
        this.updateInstanceState({ screenBounds: r.toJson() }, !0, !0);
        const g = this.viewportPageCenter;
        this.pan((g.x - p.x) * f, (g.y - p.y) * f);
      } else {
        const p = this.screenToPage(0, 0);
        this.updateInstanceState({ screenBounds: r.toJson() }, !0, !0);
        const g = this.screenToPage(0, 0);
        this.pan((g.x - p.x) * f, (g.y - p.y) * f);
      }
    }
    this._cameraManager.tick(), this.updateCullingBounds();
    const { editingId: c } = this;
    return c && this.panZoomIntoView([c]), this;
  }
  get viewportScreenBounds() {
    const { x: t, y: e, w: n, h: r } = this.instanceState.screenBounds;
    return new ot(t, e, n, r);
  }
  get viewportScreenCenter() {
    return this.viewportScreenBounds.center;
  }
  get viewportPageBounds() {
    const { x: t, y: e, w: n, h: r } = this.viewportScreenBounds, a = this.screenToPage(t, e), s = this.screenToPage(t + n, e + r);
    return new ot(a.x, a.y, s.x - a.x, s.y - a.y);
  }
  get cullingBounds() {
    return this._cullingBounds.value;
  }
  /** @internal */
  _cullingBounds = fi("culling viewport", new ot());
  get cullingBoundsExpanded() {
    return this._cullingBoundsExpanded.value;
  }
  /** @internal */
  _cullingBoundsExpanded = fi("culling viewport expanded", new ot());
  /**
   * Update the culling bounds. This should be called when the viewport has stopped changing, such as at the end of a pan, zoom, or animation.
   *
   * @example
   * ```ts
   * 	app.updateCullingBounds()
   * ```
   *
   * @internal
   */
  updateCullingBounds() {
    const { viewportPageBounds: t } = this;
    return t.equals(this._cullingBounds.__unsafe__getWithoutCapture()) ? this : (this._cullingBounds.set(t.clone()), this._cullingBoundsExpanded.set(t.clone().expandBy(100 / this.zoomLevel)), this);
  }
  get viewportPageCenter() {
    return this.viewportPageBounds.center;
  }
  /**
   * Convert a point in screen space to a point in page space.
   *
   * @example
   * ```ts
   * 	app.screenToPage(100, 100)
   * ```
   *
   * @param x - The x coordinate of the point in screen space.
   * @param y - The y coordinate of the point in screen space.
   * @param camera - The camera to use. Defaults to the current camera.
   * @public
   */
  screenToPage(t, e, n = 0.5, r = this.camera) {
    const { screenBounds: a } = this.store.unsafeGetWithoutCapture(this.instanceId), { x: s, y: c, z: f = 1 } = r;
    return {
      x: (t - a.x) / f - s,
      y: (e - a.y) / f - c,
      z: n
    };
  }
  /**
   * Convert a point in page space to a point in screen space.
   *
   * @example
   * ```ts
   * 	app.pageToScreen(100, 100)
   * ```
   *
   * @param x - The x coordinate of the point in screen space.
   * @param y - The y coordinate of the point in screen space.
   * @param camera - The camera to use. Defaults to the current camera.
   * @public
   */
  pageToScreen(t, e, n = 0.5, r = this.camera) {
    const { x: a, y: s, z: c = 1 } = r;
    return {
      x: t + a * c,
      y: e + s * c,
      z: n
    };
  }
  /* Focus Layers */
  get focusLayerId() {
    return this.pageState.focusLayerId ?? this.currentPageId;
  }
  get focusLayerShape() {
    const t = this.pageState.focusLayerId;
    if (t)
      return this.getShapeById(t);
  }
  popFocusLayer() {
    const t = this.pageState.focusLayerId, e = t && this.getShapeById(t);
    if (e) {
      const n = this.findAncestor(e, (r) => r.type === "group");
      this.setFocusLayer(n?.id ?? null), this.select(e.id);
    } else
      this.setFocusLayer(null), this.selectNone();
    return this;
  }
  /**
   * Set the focus layer to the given shape id.
   *
   * @param next - The next focus layer id or null to reset the focus layer to the page
   *
   * @public
   */
  setFocusLayer(t) {
    return this._setFocusLayer(t), this;
  }
  /** @internal */
  _setFocusLayer = this.history.createCommand(
    "setFocusLayer",
    (t) => t === null && !this.canUndo ? void 0 : { data: { prev: this.pageState.focusLayerId, next: t }, preservesRedoStack: !0, squashing: !0 },
    {
      do: ({ next: t }) => {
        this.store.update(this.pageState.id, (e) => ({ ...e, focusLayerId: t }));
      },
      undo: ({ prev: t }) => {
        this.store.update(this.pageState.id, (e) => ({ ...e, focusLayerId: t }));
      },
      squash({ prev: t }, { next: e }) {
        return { prev: t, next: e };
      }
    }
  );
  /**
   * Set the hinted shape ids.
   *
   * @param ids - The ids to set as hinted.
   *
   * @public
   */
  setHintingIds(t) {
    return this.store.update(this.pageState.id, (e) => ({ ...e, hintingIds: Sx(t) })), this;
  }
  /**
   * The current editing shape's id.
   *
   * @public
   */
  get editingId() {
    return this.pageState.editingId;
  }
  get editingShape() {
    return this.editingId ? this.getShapeById(this.editingId) ?? null : null;
  }
  /**
   * Set the current editing id.
   *
   * @param id - The id of the shape to edit or null to clear the editing id.
   *
   * @public
   */
  setEditingId(t) {
    if (!t)
      this.setInstancePageState({ editingId: null });
    else if (t !== this.editingId) {
      const e = this.getShapeById(t), n = this.getShapeUtil(e);
      if (e && n.canEdit(e)) {
        this.setInstancePageState({ editingId: t, hoveredId: null }, !1);
        const { viewportPageBounds: r } = this, a = n.getEditingBounds(e), s = this.getPageTransformById(t), c = ot.FromPoints(
          De.applyToPoints(s, a.corners)
        );
        r.contains(c) || (c.width > r.width || c.height > r.height ? this.zoomToBounds(
          c.minX,
          c.minY,
          c.width,
          c.height
        ) : this.centerOnPoint(c.midX, c.midY));
      }
    }
    return this;
  }
  getParentIdForNewShapeAtPoint(t, e) {
    const n = this.sortedShapesArray;
    for (let r = n.length - 1; r >= 0; r--) {
      const a = n[r], s = this.getShapeUtil(a);
      if (!s.canReceiveNewChildrenOfType(e))
        continue;
      const c = this.getMaskedPageBoundsById(a.id);
      if (c && c.containsPoint(t) && s.hitTestPoint(a, this.getPointInShapeSpace(a, t)))
        return a.id;
    }
    return this.focusLayerId;
  }
  getDroppingShape(t, e = []) {
    const n = this.sortedShapesArray;
    for (let r = n.length - 1; r >= 0; r--) {
      const a = n[r];
      if (e.find((f) => f.id === a.id || this.hasAncestor(a, f.id)))
        continue;
      const s = this.getShapeUtil(a);
      if (!s.canDropShapes(a, e))
        continue;
      const c = this.getMaskedPageBoundsById(a.id);
      if (c && c.containsPoint(t) && s.hitTestPoint(a, this.getPointInShapeSpace(a, t)))
        return a;
    }
  }
  // This returns the node that should be selected when you click on this one, assuming there is nothing
  // already selected. It will not return anything higher than or including the current focus layer.
  getOutermostSelectableShape(t, e) {
    let n = t, r = t;
    for (; r; ) {
      if (r.type === "group" && this.focusLayerId !== r.id && !this.hasAncestor(this.focusLayerShape, r.id) && (e?.(r) ?? !0))
        n = r;
      else if (this.focusLayerId === r.id)
        break;
      r = this.getParentShape(r);
    }
    return n;
  }
  /* --------------------- Shapes --------------------- */
  /**
   * The app's set of styles.
   *
   * @public
   */
  static styles = Dw;
  get selectedPageBounds() {
    const {
      pageState: { selectedIds: t }
    } = this;
    return t.length === 0 ? null : ot.Common(Gt(t.map((e) => this.getPageBoundsById(e))));
  }
  get selectionRotation() {
    const { selectedIds: t } = this;
    if (t.length === 0)
      return 0;
    if (t.length === 1)
      return this.getPageRotationById(this.selectedIds[0]);
    const e = t.map((n) => this.getPageRotationById(n) % (Math.PI / 2));
    return e.every((n) => Math.abs(n - e[0]) < Math.PI / 180) ? this.getPageRotationById(t[0]) : 0;
  }
  get selectionBounds() {
    const { selectedIds: t } = this;
    if (t.length === 0)
      return;
    const { selectionRotation: e } = this;
    if (e === 0)
      return this.selectedPageBounds;
    if (t.length === 1) {
      const a = this.getBounds(this.getShapeById(t[0])).clone();
      return a.point = De.applyToPoint(this.getPageTransformById(t[0]), a.point), a;
    }
    const n = this.selectedIds.flatMap((a) => {
      const s = this.getPageTransformById(a);
      return s ? this.getOutlineById(a).map((c) => De.applyToPoint(s, c)) : [];
    }).map((a) => O.Rot(a, -e)), r = ot.FromPoints(n);
    return r.point = r.point.rot(e), r;
  }
  get selectionPageCenter() {
    const { selectionBounds: t, selectionRotation: e } = this;
    return t ? O.RotWith(t.center, t.point, e) : null;
  }
  get shapesArray() {
    return Array.from(this.shapeIds).map((t) => this.store.get(t));
  }
  get sortedShapesArray() {
    const t = new Set(this.shapesArray.sort(Ha)), e = [];
    function n(r) {
      e.push(r), t.delete(r), t.forEach((a) => {
        a.parentId === r.id && n(a);
      });
    }
    return t.forEach((r) => {
      const a = this.getShapeById(r.parentId);
      Ep(a) || n(r);
    }), e;
  }
  get selectedShapes() {
    const { selectedIds: t } = this.pageState;
    return Gt(t.map((e) => this.store.get(e)));
  }
  get onlySelectedShape() {
    const { selectedShapes: t } = this;
    return t.length === 1 ? t[0] : null;
  }
  /**
   * Get a shape by its id.
   *
   * @example
   * ```ts
   * 	app.getShapeById('box1')
   * ```
   *
   * @param id - The id of the shape to get.
   * @public
   */
  getShapeById(t) {
    if (Us(t))
      return this.store.get(t);
  }
  /**
   * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of
   * the page.
   *
   * @example
   * ```ts
   * 	app.getParentShape(myShape)
   * ```
   *
   * @public
   */
  getParentShape(t) {
    if (!(t === void 0 || !Us(t.parentId)))
      return this.store.get(t.parentId);
  }
  /**
   * If siblingShape and targetShape are siblings, this returns targetShape
   * If targetShape has an ancestor who is a sibling of siblingShape, this returns that ancestor
   * Otherwise, this returns undefined
   */
  getNearestSiblingShape(t, e) {
    return e ? e.parentId === t.parentId ? e : this.findAncestor(
      e,
      (r) => r.parentId === t.parentId
    ) : void 0;
  }
  /**
   * Get the id of the containing page for a given shape.
   */
  getParentPageId(t) {
    if (t !== void 0)
      return fr.isId(t.parentId) ? t.parentId : this.getParentPageId(this.getShapeById(t.parentId));
  }
  /**
   * Get whether the given shape is the descendant of the given page.
   *
   * @example
   * ```ts
   * 	app.isShapeInPage(myShape)
   * 	app.isShapeInPage(myShape, 'page1')
  
   * ```
   * @param shape - The shape to check.
   * @param pageId - The id of the page to check against. Defaults to the current page.
   * @public
   */
  isShapeInPage(t, e = this.currentPageId) {
    let n = !1;
    if (t.parentId === e)
      n = !0;
    else {
      let r = this.getShapeById(t.parentId);
      e:
        for (; r; ) {
          if (r.parentId === e) {
            n = !0;
            break e;
          }
          r = this.getShapeById(r.parentId);
        }
    }
    return n;
  }
  /* --------------------- Styles --------------------- */
  /**
   * A mapping of color ids to CSS color values.
   *
   * @internal
   */
  colors;
  /**
   * A mapping of size ids to size values.
   *
   * @internal
   */
  sizes = {
    s: 2,
    m: 3.5,
    l: 5,
    xl: 10
  };
  /**
   * Get the CSS color value for a given color id.
   *
   * @example
   * ```ts
   * 	app.getCssColor('red')
   * ```
   *
   * @param id - The id of the color to get.
   * @public
   */
  getCssColor(t) {
    return this.colors.get(t);
  }
  /**
   * Get the stroke width value for a given size id.
   *
   * @example
   * ```ts
   * 	app.getStrokeWidth('m')
   * ```
   *
   * @param id - The id of the size to get.
   * @public
   */
  getStrokeWidth(t) {
    return this.sizes[t];
  }
  /* ------------------- Statechart ------------------- */
  /**
   * The id of the current selected tool.
   *
   * @public
   */
  get currentToolId() {
    const t = this.root.current.value;
    let e = t?.id;
    return e === "select" && (e = t?.current.value?.info?.onInteractionEnd ?? "select"), e ?? "select";
  }
  /**
   * Set the selected tool.
   *
   * @example
   * ```ts
   * 	app.setSelectedTool('hand')
   * 	app.setSelectedTool('hand', { date: Date.now() })
   * ```
   *
   * @param id - The id of the tool to select.
   * @param info - Arbitrary data to pass along into the transition.
   * @public
   */
  setSelectedTool(t, e = {}) {
    return this.root.transition(t, e), this;
  }
  /**
   * Get a descendant by its path.
   *
   * @example
   * ```ts
   * 	state.getStateDescendant('select')
   * 	state.getStateDescendant('select.brushing')
   * ```
   *
   * @param path - The descendant's path of state ids, separated by periods.
   * @public
   */
  getStateDescendant(t) {
    const e = t.split(".").reverse();
    let n = this.root;
    for (; e.length > 0; ) {
      const r = e.pop();
      if (!r)
        return n;
      const a = n.children?.[r];
      if (!a)
        return;
      n = a;
    }
    return n;
  }
  /**
   * Get whether a certain tool (or other state node) is currently active.
   *
   * @example
   * ```ts
   * 	app.isIn('select')
   * 	app.isIn('select.brushing')
   * ```
   *
   * @param path - The path of active states, separated by periods.
   * @public
   */
  isIn(t) {
    const e = t.split(".").reverse();
    let n = this.root;
    for (; e.length > 0; ) {
      const r = e.pop();
      if (!r)
        return !0;
      const a = n.current.value;
      if (a?.id === r) {
        if (e.length === 0)
          return !0;
        n = a;
        continue;
      } else
        return !1;
    }
    return !1;
  }
  /**
   * Get whether the state node is in any of the given active paths.
   *
   * @example
   * ```ts
   * 	state.isInAny('select', 'erase')
   * 	state.isInAny('select.brushing', 'erase.idle')
   * ```
   *
   * @public
   */
  isInAny(...t) {
    return t.some((e) => this.isIn(e));
  }
  /* --------------------- Inputs --------------------- */
  /**
   * The app's current input state.
   *
   * @public
   */
  inputs = {
    /** The most recent pointer down's position in page space. */
    originPagePoint: new O(),
    /** The most recent pointer down's position in screen space. */
    originScreenPoint: new O(),
    /** The previous pointer position in page space. */
    previousPagePoint: new O(),
    /** The previous pointer position in screen space. */
    previousScreenPoint: new O(),
    /** The most recent pointer position in page space. */
    currentPagePoint: new O(),
    /** The most recent pointer position in screen space. */
    currentScreenPoint: new O(),
    /** A set containing the currently pressed keys. */
    keys: /* @__PURE__ */ new Set(),
    /** A set containing the currently pressed buttons. */
    buttons: /* @__PURE__ */ new Set(),
    /** Whether the input is from a pe. */
    isPen: !1,
    /** Whether the shift key is currently pressed. */
    shiftKey: !1,
    /** Whether the control or command key is currently pressed. */
    ctrlKey: !1,
    /** Whether the alt or option key is currently pressed. */
    altKey: !1,
    /** Whether the user is dragging. */
    isDragging: !1,
    /** Whether the user is pointing. */
    isPointing: !1,
    /** Whether the user is pinching. */
    isPinching: !1,
    /** Whether the user is editing. */
    isEditing: !1,
    /** Whether the user is panning. */
    isPanning: !1,
    /** Veclocity of mouse pointer, in pixels per millisecond */
    pointerVelocity: new O()
  };
  /**
   * Update the input points from a pointer or pinch event.
   *
   * @internal
   * @param info - The event info.
   */
  _updateInputsFromEvent(t) {
    const { previousScreenPoint: e, previousPagePoint: n, currentScreenPoint: r, currentPagePoint: a } = this.inputs, { screenBounds: s } = this.store.unsafeGetWithoutCapture(this.instanceId), { x: c, y: f, z: p } = t.point, { x: g, y, z: v } = this.camera;
    e.setTo(r), n.setTo(a);
    const S = (c - s.x) / v - g, x = (f - s.y) / v - y;
    r.set(c, f), a.set(S, x, p ?? 0.5), this.inputs.isPen = t.type === "pointer" && t.isPen, t.name === "pointer_down" && (this.inputs.pointerVelocity = new O()), this.updateUserPresence({ cursor: a.toJson() });
  }
  /* --------------------- Events --------------------- */
  /**
   * A manager for recording multiple click events.
   *
   * @internal
   */
  _clickManager = new Zte(this);
  /**
   * Prevent a double click event from firing the next time the user clicks
   *
   * @public
   */
  cancelDoubleClick() {
    this._clickManager.cancelDoubleClickTimeout();
  }
  /**
   * The previous cursor. Used for restoring the cursor after pan events.
   *
   * @internal
   */
  _prevCursor = "default";
  /** @internal */
  _shiftKeyTimeout = -1;
  /** @internal */
  _setShiftKeyTimeout = () => {
    this.inputs.shiftKey = !1, this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Shift",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey
    });
  };
  /** @internal */
  _altKeyTimeout = -1;
  /** @internal */
  _setAltKeyTimeout = () => {
    this.inputs.altKey = !1, this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Alt",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey
    });
  };
  /** @internal */
  _ctrlKeyTimeout = -1;
  /** @internal */
  _setCtrlKeyTimeout = () => {
    this.inputs.ctrlKey = !1, this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Ctrl",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey
    });
  };
  /** @internal */
  _restoreToolId = "select";
  /** @internal */
  _pinchStart = 1;
  /** @internal */
  _didPinch = !1;
  /** @internal */
  _selectedIdsAtPointerDown = [];
  /**
   * Dispatch an event to the app.
   *
   * @example
   * ```ts
   * 	app.dispatch(myPointerEvent)
   * ```
   *
   * @param info - The event info.
   * @public
   */
  dispatch = (t) => {
    if (this.crashingError)
      return this;
    const { inputs: e } = this, { type: n } = t;
    return this.batch(() => {
      if (t.type === "misc") {
        t.name === "blur" && this.inputs.isPanning && (this.inputs.isPanning = !1, this.setCursor({
          type: this._prevCursor
        })), this.root.handleEvent(t);
        return;
      }
      t.shiftKey ? (clearInterval(this._shiftKeyTimeout), this._shiftKeyTimeout = -1, e.shiftKey = !0) : !t.shiftKey && e.shiftKey && this._shiftKeyTimeout === -1 && (this._shiftKeyTimeout = setTimeout(this._setShiftKeyTimeout, 150)), t.altKey ? (clearInterval(this._altKeyTimeout), this._altKeyTimeout = -1, e.altKey = !0) : !t.altKey && e.altKey && this._altKeyTimeout === -1 && (this._altKeyTimeout = setTimeout(this._setAltKeyTimeout, 150)), t.ctrlKey ? (clearInterval(this._ctrlKeyTimeout), this._ctrlKeyTimeout = -1, e.ctrlKey = !0) : !t.ctrlKey && e.ctrlKey && this._ctrlKeyTimeout === -1 && (this._ctrlKeyTimeout = setTimeout(this._setCtrlKeyTimeout, 150));
      const { originPagePoint: r, originScreenPoint: a, currentPagePoint: s, currentScreenPoint: c } = e;
      switch (e.isPointing || (e.isDragging = !1), n) {
        case "pinch": {
          if (!this.canMoveCamera)
            return;
          switch (this._updateInputsFromEvent(t), t.name) {
            case "pinch_start": {
              if (e.isPinching)
                return;
              e.isEditing || (this._pinchStart = this.camera.z, this._selectedIdsAtPointerDown.length || (this._selectedIdsAtPointerDown = this.selectedIds.slice()), this._didPinch = !0, e.isPinching = !0, this.interrupt());
              return;
            }
            case "pinch": {
              if (!e.isPinching)
                return;
              const {
                point: { x: f, y: p, z: g = 1 },
                delta: { x: y, y: v }
              } = t, {
                camera: { x: S, y: x, z: _ }
              } = this, T = Math.min(Cp, Math.max(Ow, g));
              this.setCamera(
                S + y / _ - f / _ + f / T,
                x + v / _ - p / _ + p / T,
                T
              );
              return;
            }
            case "pinch_end": {
              if (!e.isPinching)
                return this;
              e.isPinching = !1;
              const { _selectedIdsAtPointerDown: f } = this;
              this.setSelectedIds(this._selectedIdsAtPointerDown, !0), this._selectedIdsAtPointerDown = [];
              const {
                camera: { x: p, y: g, z: y }
              } = this;
              let v;
              if (y > 0.9 && y < 1.05 ? v = 1 : y > 0.49 && y < 0.505 && (v = 0.5), y > this._pinchStart - 0.1 && y < this._pinchStart + 0.05 && (v = this._pinchStart), v !== void 0) {
                const { x: S, y: x } = this.viewportScreenCenter;
                this.animateCamera(
                  p + (S / v - S) - (S / y - S),
                  g + (x / v - x) - (x / y - x),
                  v,
                  { duration: 100 }
                );
              }
              this._didPinch && (this._didPinch = !1, requestAnimationFrame(() => {
                this._didPinch || this.setSelectedIds(f, !0);
              }));
              return;
            }
          }
        }
        case "wheel": {
          if (!this.canMoveCamera)
            return;
          if (!(this._viewportAnimation || this.isMenuOpen)) {
            if (e.ctrlKey) {
              const { x: f, y: p } = this.inputs.currentScreenPoint, { x: g, y, z: v } = this.camera, S = Math.min(Cp, Math.max(Ow, v + (t.delta.z ?? 0) * v));
              this.setCamera(
                g + (f / S - f) - (f / v - f),
                y + (p / S - p) - (p / v - p),
                S
              );
              return;
            }
            this.pan(t.delta.x, t.delta.y), e.isPointing && !e.isDragging && O.Dist(
              a,
              this.pageToScreen(c.x, c.y)
            ) > Jy && (e.isDragging = !0), this.dispatch({
              type: "pointer",
              target: "canvas",
              name: "pointer_move",
              point: c,
              pointerId: 0,
              ctrlKey: t.ctrlKey,
              altKey: t.altKey,
              shiftKey: t.shiftKey,
              button: 0,
              isPen: this.isPenMode ?? !1
            });
          }
          break;
        }
        case "pointer": {
          if (e.isPinching)
            return;
          this._updateInputsFromEvent(t);
          const { isPen: f } = t;
          switch (t.name) {
            case "pointer_down": {
              if (this._selectedIdsAtPointerDown = this.selectedIds.slice(), e.buttons.add(t.button), e.isPointing = !0, e.isDragging = !1, this.isPenMode)
                if (f)
                  this._touchEventsRemainingBeforeExitingPenMode = 3;
                else if (this._touchEventsRemainingBeforeExitingPenMode--, this._touchEventsRemainingBeforeExitingPenMode === 0)
                  this.setPenMode(!1);
                else
                  return;
              else
                f && this.setPenMode(!0);
              if (t.button === 5 ? (this._restoreToolId = this.currentToolId, this.complete(), this.setSelectedTool("eraser")) : t.button === 1 && (this.inputs.isPanning || (this._prevCursor = this.instanceState.cursor.type), this.inputs.isPanning = !0), this.inputs.isPanning)
                return this.stopCameraAnimation(), this.setCursor({
                  type: "grabbing"
                }), this;
              a.setTo(c), r.setTo(s);
              break;
            }
            case "pointer_move": {
              if (!f && this.isPenMode)
                return;
              if (this.inputs.isPanning && this.inputs.isPointing) {
                const { currentScreenPoint: p, previousScreenPoint: g } = this.inputs, y = O.Sub(p, g);
                this.pan(y.x, y.y);
                return;
              }
              e.isPointing && !e.isDragging && O.Dist(a, c) > Jy && (e.isDragging = !0);
              break;
            }
            case "pointer_up": {
              if (e.buttons.delete(t.button), e.isPointing = !1, e.isDragging = !1, this.isMenuOpen || !f && this.isPenMode)
                return;
              e.isPanning ? t.button === 1 ? this.inputs.keys.has(" ") ? (this.slideCamera({
                speed: Math.min(2, this.inputs.pointerVelocity.len()),
                direction: this.inputs.pointerVelocity,
                friction: lx
              }), this.setCursor({
                type: "grab"
              })) : (e.isPanning = !1, this.slideCamera({
                speed: Math.min(2, this.inputs.pointerVelocity.len()),
                direction: this.inputs.pointerVelocity,
                friction: lx
              }), this.setCursor({
                type: this._prevCursor
              })) : t.button === 0 && (this.slideCamera({
                speed: Math.min(2, this.inputs.pointerVelocity.len()),
                direction: this.inputs.pointerVelocity,
                friction: lx
              }), this.setCursor({
                type: "grab"
              })) : t.button === 5 && (this.complete(), this.setSelectedTool(this._restoreToolId));
              break;
            }
          }
          break;
        }
        case "keyboard": {
          switch (t.name) {
            case "key_down": {
              if (e.keys.has(t.key))
                return;
              e.keys.add(t.key), !t.ctrlKey && t.key === " " && (this.inputs.isPanning || (this._prevCursor = this.instanceState.cursor.type), this.inputs.isPanning = !0, this.setCursor({
                type: this.inputs.isPointing ? "grabbing" : "grab"
              }));
              break;
            }
            case "key_up": {
              e.keys.delete(t.key), t.key === " " && !this.inputs.buttons.has(1) && (this.inputs.isPanning = !1, this.setCursor({
                type: this._prevCursor
              }));
              break;
            }
          }
          break;
        }
      }
      if (t.type === "pointer" && (t.button === 1 ? t.name = "middle_click" : t.button === 2 && (t.name = "right_click")), t.type === "pointer" && t.isPen === this.isPenMode)
        switch (t.name) {
          case "pointer_down": {
            const f = this._clickManager.transformPointerDownEvent(t);
            if (t.name !== f.name) {
              this.root.handleEvent(t), this.emit("event", t), this.root.handleEvent(f), this.emit("event", f);
              return;
            }
            break;
          }
          case "pointer_up": {
            const f = this._clickManager.transformPointerUpEvent(t);
            if (t.name !== f.name) {
              this.root.handleEvent(t), this.emit("event", t), this.root.handleEvent(f), this.emit("event", f);
              return;
            }
            break;
          }
          case "pointer_move": {
            this._clickManager.handleMove();
            break;
          }
        }
      this.root.handleEvent(t), this.emit("event", t);
    }), this;
  };
  replaceStoreContentsWithRecordsForOtherDocument(t) {
    Pu(() => {
      this.store.clear();
      const [e, n] = jG(t, (a) => a.typeName === "shape");
      this.store.put(n, "initialize"), this.store.ensureStoreIsUsable(), this.store.put(e, "initialize"), this.history.clear(), this.updateViewportScreenBounds(), this.updateCullingBounds();
      const r = this.allShapesCommonBounds;
      r && this.zoomToBounds(r.minX, r.minY, r.width, r.height, 1);
    });
  }
  getContent(t = this.selectedIds) {
    if (!t || t.length === 0)
      return;
    const e = {};
    let n = Sx(
      t.map((s) => this.getShapeById(s)).sort(Ha).flatMap((s) => {
        const c = [s];
        return this.visitDescendants(s.id, (f) => {
          c.push(this.getShapeById(f));
        }), c;
      })
    );
    n = n.map((s) => {
      if (s = Ou(s), e[s.id] = this.getPageTransformById(s.id), !to.is(s))
        return s;
      if (s.props.start.type === "binding") {
        const c = s.props.start.boundShapeId;
        if (!n.find((f) => f.id === c)) {
          const { start: f } = Mu(this, s);
          s.props.start = {
            type: "point",
            x: f.x,
            y: f.y
          };
        }
      }
      if (s.props.end.type === "binding") {
        const c = s.props.end.boundShapeId;
        if (!n.find((f) => f.id === c)) {
          const { end: f } = Mu(this, s);
          s.props.end = {
            type: "point",
            x: f.x,
            y: f.y
          };
        }
      }
      return s;
    });
    const r = [];
    n.forEach((s) => {
      if (n.find((c) => c.id === s.parentId) === void 0) {
        const c = this.getPagePointById(s.id), f = this.getPageRotationById(s.id);
        s.x = c.x, s.y = c.y, s.rotation = f, s.parentId = this.currentPageId, r.push(s.id);
      }
    });
    const a = /* @__PURE__ */ new Set();
    return n.forEach((s) => {
      "assetId" in s.props && s.props.assetId !== null && a.add(s.props.assetId);
    }), {
      shapes: n,
      rootShapeIds: r,
      schema: this.store.schema.serialize(),
      assets: Gt(Array.from(a).map((s) => this.getAssetById(s)))
    };
  }
  /* --------------------- Commands --------------------- */
  putContent(t, e = {}) {
    if (this.isReadOnly)
      return this;
    if (!t.schema)
      throw Error("Could not put content: content is missing a schema.");
    const { select: n = !1, preserveIds: r = !1, preservePosition: a = !1 } = e;
    let { point: s = void 0 } = e;
    const { currentPageId: c } = this, { assets: f, shapes: p, rootShapeIds: g } = t, y = new Map(p.map((j) => [j.id, no()]));
    let v = this.currentPageId, S = 1 / 0, x = [];
    for (const j of this.selectedShapes) {
      if (S === 0)
        break;
      const L = this.getAncestors(j);
      j.type === "frame" && L.push(j);
      const z = j.type === "frame" ? L.length + 1 : L.length;
      if (z < S)
        S = z, x = L, v = j.type === "frame" ? j.id : j.parentId;
      else if (z === S) {
        if (x.length !== L.length)
          throw Error(`Ancestors: ${x.length} !== ${L.length}`);
        if (x.length === 0) {
          v = c;
          break;
        } else {
          v = c;
          for (let F = 0; F < x.length && L[F] === x[F]; F++)
            v = L[F].id;
        }
      }
    }
    let _ = !1;
    if (!fr.isId(v)) {
      const j = this.getShapeById(v);
      if (j) {
        if (!this.viewportPageBounds.includes(this.getPageBounds(j)))
          v = c;
        else if (g.length === 1) {
          const L = p.find((z) => z.id === g[0]);
          dx.is(j) && dx.is(L) && L.props.w === j?.props.w && L.props.h === j?.props.h && (_ = !0);
        }
      } else
        v = c;
    }
    _ || (_ = y.has(v)), _ && (v = this.getShapeById(v).parentId);
    let T = this.getHighestIndexForParent(v);
    const I = [], D = p.map((j) => {
      let L;
      if (r)
        L = Cc(j), y.set(j.id, j.id);
      else {
        const z = y.get(j.id);
        L = Cc({ ...j, id: z });
      }
      if (g.includes(j.id) && (L.parentId = c, I.push(L)), y.has(L.parentId) ? L.parentId = y.get(j.parentId) : (g.push(L.id), L.index = T, T = Ru(T)), to.is(L)) {
        if (L.props.start.type === "binding") {
          const z = y.get(L.props.start.boundShapeId);
          L.props.start = z ? { ...L.props.start, boundShapeId: z } : (
            // this shouldn't happen, if you copy an arrow but not it's bound shape it should
            // convert the binding to a point at the time of copying
            {
              type: "point",
              x: 0,
              y: 0
            }
          );
        }
        if (L.props.end.type === "binding") {
          const z = y.get(L.props.end.boundShapeId);
          L.props.end = z ? { ...L.props.end, boundShapeId: z } : (
            // this shouldn't happen, if you copy an arrow but not it's bound shape it should
            // convert the binding to a point at the time of copying
            {
              type: "point",
              x: 0,
              y: 0
            }
          );
        }
      }
      return L;
    });
    if (D.length + this.shapeIds.size > yp)
      return Uw(this), this;
    let N = [];
    if (f) {
      for (let L = 0; L < f.length; L++) {
        const z = f[L], F = this.store.schema.migratePersistedRecord(z, t.schema);
        if (F.type === "success")
          f[L] = F.value;
        else
          throw Error(
            `Could not put content: could not migrate content for asset:
${JSON.stringify(
              z,
              null,
              2
            )}`
          );
      }
      const j = [];
      N = f.filter((L) => !this.store.has(L.id)).map((L) => ((L.type === "image" || L.type === "video") && (L.props.src && L.props.src?.startsWith("data:image") ? (j.push(Ou(L)), L.props.src = null) : j.push(Ou(L))), L)), Promise.allSettled(
        j.map(async (L) => {
          const z = await EZ(
            L.props.src,
            L.props.name,
            L.props.mimeType ?? "image/png"
          ), F = await this.onCreateAssetFromFile(z);
          return [L, F];
        })
      ).then((L) => {
        this.updateAssets(
          Gt(
            L.map(
              (z) => z.status === "fulfilled" ? { ...z.value[1], id: z.value[0].id } : void 0
            )
          )
        );
      });
    }
    for (let j = 0; j < D.length; j++) {
      const L = D[j], z = this.store.schema.migratePersistedRecord(L, t.schema);
      if (z.type === "success")
        D[j] = z.value;
      else
        throw Error(
          `Could not put content: could not migrate content for shape:
${JSON.stringify(
            L,
            null,
            2
          )}`
        );
    }
    return this.batch(() => {
      N.length > 0 && this.createAssets(N), this.createShapes(D, n), v !== c && this.reparentShapesById(
        I.map((z) => z.id),
        v
      );
      const j = D.map((z) => this.getShapeById(z.id)), L = ot.Common(j.map((z) => this.getPageBounds(z)));
      if (s === void 0)
        if (fr.isId(v)) {
          const { viewportPageBounds: z } = this;
          a || z.includes(ot.From(L)) ? s = L.center : s = z.center;
        } else {
          const z = this.getShapeById(v);
          s = this.getShapeUtil(z).center(z);
        }
      if (I.length === 1) {
        const z = I[0];
        if (z.type === "frame")
          for (; this.getShapesAtPoint(s).some(
            (F) => dx.is(F) && F.props.w === z.props.w && F.props.h === z.props.h
          ); )
            s.x += L.w + 16;
      }
      this.updateShapes(
        I.map((z) => {
          const F = {
            x: (z.x ?? 0) - (L.x + L.w / 2),
            y: (z.y ?? 0) - (L.y + L.h / 2)
          };
          return { id: z.id, type: z.type, x: s.x + F.x, y: s.y + F.y };
        })
      );
    }), this;
  }
  /* --------------------- Shapes --------------------- */
  /**
   * Get a unique id for a shape.
   *
   * @example
   * ```ts
   * 	app.createShapeId()
   * 	app.createShapeId('box1')
   * ```
   *
   * @param id - The id to use.
   * @public
   */
  createShapeId(t) {
    return t ? aq(t) : no();
  }
  getHighestIndexForParent(t) {
    const e = this._parentIdsToChildIds.value[t];
    return !e || e.length === 0 ? "a1" : Ru(e[e.length - 1][1]);
  }
  /**
   * Create shapes.
   *
   * @example
   * ```ts
   * 	app.createShapes([{ id: "box1", type: "box" }]
   * ```
   *
   * @param partials - The shape partials to create.
   * @param select - Whether to select the created shapes. Defaults to false.
   * @public
   */
  createShapes(t, e = !1) {
    return this._createShapes(t, e), this;
  }
  /** @internal */
  _createShapes = this.history.createCommand(
    "createShapes",
    (t, e = !1) => {
      if (this.isReadOnly || t.length <= 0)
        return null;
      const { shapeIds: n, selectedIds: r } = this, a = e ? r : void 0, s = t.length + n.size > yp;
      s && Uw(this);
      const c = s ? t.slice(0, yp - n.size) : t;
      return c.length === 0 ? null : {
        data: {
          prevSelectedIds: a,
          partials: c,
          select: e
        }
      };
    },
    {
      do: ({ partials: t, select: e }) => {
        const { focusLayerId: n } = this;
        t = t.map((s) => {
          if (
            // No parentId provided
            !s.parentId || // A parentId is proved but the parent is neither a) in the store
            // or b) among the other creating shape partials
            !this.store.get(s.parentId) && !t.find((c) => c.id === s.parentId)
          ) {
            s = { ...s };
            const c = this.getParentIdForNewShapeAtPoint(
              { x: s.x ?? 0, y: s.y ?? 0 },
              s.type
            );
            if (s.parentId = c, Us(c)) {
              const f = this.getPointInShapeSpace(this.getShapeById(c), {
                x: s.x ?? 0,
                y: s.y ?? 0
              });
              s.x = f.x, s.y = f.y, s.rotation = -this.getPageRotationById(c) + (s.rotation ?? 0);
            }
            return s;
          }
          return s;
        });
        const r = /* @__PURE__ */ new Map(), a = [];
        for (const s of t) {
          const c = this.getShapeUtil(s);
          let f = s.index;
          if (!f) {
            const S = s.parentId ?? n;
            r.has(S) || r.set(S, this.getHighestIndexForParent(S)), f = r.get(S), r.set(S, Ru(f));
          }
          const p = c.defaultProps(), { propsForNextShape: g } = this.instanceState;
          for (const S in p)
            if (S in g) {
              if (S === "url")
                continue;
              p[S] = g[S];
            }
          let y = this.config.TLShape.create({
            ...s,
            index: f,
            parentId: s.parentId ?? n,
            props: "props" in s ? { ...p, ...s.props } : p
          });
          if (y.index === void 0)
            throw Error("no index!");
          const v = this.getShapeUtil(y).onBeforeCreate?.(y);
          v && (y = v), a.push(y);
        }
        if (this.store.put(a), e) {
          const s = t.map((c) => c.id);
          this.store.update(this.pageState.id, (c) => ({ ...c, selectedIds: s }));
        }
      },
      undo: ({ partials: t, prevSelectedIds: e }) => {
        this.store.remove(t.map((n) => n.id)), e && this.store.update(this.pageState.id, (n) => ({
          ...n,
          selectedIds: e
        }));
      }
    }
  );
  animatingShapes = /* @__PURE__ */ new Map();
  /**
   * Animate shapes.
   *
   * @example
   * ```ts
   * 	app.animateShapes([{ id: "box1", type: "box", x: 100, y: 100}])
   * ```
   *
   * @param partials - The shape partials to update.
   * @public
   */
  animateShapes(t, e = {}) {
    const { duration: n = 500, ease: r = ua.linear } = e, a = Ii();
    let s = n, c;
    const f = [];
    t.forEach((y) => {
      if (!y)
        return;
      const v = {
        partial: y,
        values: []
      }, S = this.getShapeById(y.id);
      if (S) {
        for (const x of ["x", "y", "rotation"])
          y[x] !== void 0 && S[x] !== y[x] && v.values.push({ prop: x, from: S[x], to: y[x] });
        f.push(v), this.animatingShapes.set(S.id, a);
      }
    });
    let p;
    const g = (y) => {
      if (s -= y, s < 0) {
        const { animatingShapes: S } = this, x = t.filter(
          (_) => _ && S.get(_.id) === a
        );
        x.length && this.updateShapes(x, !1), this.removeListener("tick", g);
        return;
      }
      c = r(1 - s / n);
      const { animatingShapes: v } = this;
      try {
        const S = [];
        for (let x = 0; x < f.length; x++)
          p = f[x], v.get(p.partial.id) === a && S.push({
            id: p.partial.id,
            type: p.partial.type,
            ...p.values.reduce((_, { prop: T, from: I, to: D }) => (_[T] = I + (D - I) * c, _), {})
          });
        this._updateShapes(S, !0);
      } catch {
      }
    };
    return this.addListener("tick", g), this;
  }
  /**
   * Update shapes.
   *
   * @example
   * ```ts
   * 	app.updateShapes([{ id: "box1", type: "box", x: 100, y: 100}])
   * ```
   *
   * @param partials - The shape partials to update.
   * @param squashing - Whether the change is ephemeral.
   * @public
   */
  updateShapes(t, e = !1) {
    if (this.animatingShapes.size > 0) {
      let n;
      for (let r = 0; r < t.length; r++)
        n = t[r], n && this.animatingShapes.delete(n.id);
    }
    return this._updateShapes(t, e), this;
  }
  /** @internal */
  _updateShapes = this.history.createCommand(
    "updateShapes",
    (t, e = !1) => {
      if (this.isReadOnly)
        return null;
      const n = Gt(t), r = Object.fromEntries(
        Gt(n.map(({ id: c }) => this.getShapeById(c))).map((c) => [c.id, c])
      );
      if (n.length <= 0)
        return null;
      const a = Gt(
        n.map((c) => {
          const f = r[c.id];
          if (!f)
            return null;
          let p = null;
          for (const [g, y] of Object.entries(c))
            switch (g) {
              case "id":
              case "type":
              case "typeName":
                continue;
              default:
                y !== f[g] && (p || (p = { ...f }), g === "props" ? p.props = { ...f.props, ...y } : p[g] = y);
            }
          return p ?? f;
        })
      ), s = Object.fromEntries(a.map((c) => [c.id, c]));
      return { data: { snapshots: r, updates: s }, squashing: e };
    },
    {
      do: ({ updates: t }) => {
        const e = Object.values(t);
        let n, r;
        for (let a = 0, s = e.length; a < s; a++)
          n = e[a], r = this.getShapeUtil(n).onBeforeUpdate?.(this.store.get(n.id), n), r && (e[a] = r);
        this.store.put(e);
      },
      undo: ({ snapshots: t }) => {
        this.store.put(Object.values(t));
      },
      squash(t, e) {
        return {
          // keep the oldest snapshots
          snapshots: { ...e.snapshots, ...t.snapshots },
          // keep the newest updates
          updates: { ...t.updates, ...e.updates }
        };
      }
    }
  );
  /**
   * Delete shapes.
   *
   * @example
   * ```ts
   * 	app.deleteShapes()
   * 	app.deleteShapes(['box1', 'box2'])
   * ```
   *
   * @param ids - The ids of the shapes to delete. Defaults to the selected shapes.
   * @public
   */
  deleteShapes(t = this.selectedIds) {
    return this._deleteShapes(t), this;
  }
  /** @internal */
  _deleteShapes = this.history.createCommand(
    "delete_shapes",
    (t) => {
      if (this.isReadOnly || t.length === 0)
        return null;
      const e = [...this.pageState.selectedIds], n = new Set(t);
      for (const f of t)
        this.visitDescendants(f, (p) => {
          n.add(p);
        });
      const r = [...n], a = this._arrowBindingsIndex.value, s = Gt(
        r.flatMap((f) => {
          const p = this.getShapeById(f), g = a[f];
          return g && g.length > 0 ? g.map(({ arrowId: y }) => this.getShapeById(y)).concat(p) : p;
        })
      ), c = e.filter((f) => !n.has(f));
      return { data: { deletedIds: r, snapshots: s, prevSelectedIds: e, postSelectedIds: c } };
    },
    {
      do: ({ deletedIds: t, postSelectedIds: e }) => {
        this.store.remove(t), this.store.update(this.pageState.id, (n) => ({
          ...n,
          selectedIds: e
        }));
      },
      undo: ({ snapshots: t, prevSelectedIds: e }) => {
        this.store.put(t), this.store.update(this.pageState.id, (n) => ({
          ...n,
          selectedIds: e
        }));
      }
    }
  );
  /**
   * Update user document settings
   *
   * @example
   * ```ts
   * 	app.updateUserDocumentSettings({ isGridMode: true })
   * ```
   *
   * @public
   */
  updateUserDocumentSettings(t, e = !1) {
    return this._updateUserDocumentSettings(t, e), this;
  }
  /** @internal */
  _updateUserDocumentSettings = this.history.createCommand(
    "updateUserDocumentSettings",
    (t, e = !1) => {
      const { isReadOnly: n } = t;
      if (n === !1)
        return;
      const r = this.userDocumentSettings, a = { ...r, ...t };
      return { data: { prev: r, next: a }, ephemeral: e };
    },
    {
      do: ({ next: t }) => {
        this.store.put([t]);
      },
      undo: ({ prev: t }) => {
        this.store.put([t]);
      }
    }
  );
  /**
   * Update a page.
   *
   * @example
   * ```ts
   * 	app.updatePage({ id: 'page2', name: 'Page 2' })
   * ```
   *
   * @param partial - The partial of the shape to update.
   * @public
   */
  updatePage(t, e = !1) {
    return this._updatePage(t, e), this;
  }
  /** @internal */
  _updatePage = this.history.createCommand(
    "updatePage",
    (t, e = !1) => {
      if (this.isReadOnly)
        return null;
      const n = this.getPageById(t.id);
      return n ? { data: { prev: n, partial: t }, squashing: e } : null;
    },
    {
      do: ({ partial: t }) => {
        this.store.update(t.id, (e) => ({ ...e, ...t }));
      },
      undo: ({ prev: t, partial: e }) => {
        this.store.update(e.id, () => t);
      },
      squash(t, e) {
        return {
          prev: { ...t.prev, ...e.prev },
          partial: e.partial
        };
      }
    }
  );
  /**
   * Create a page.
   *
   * @example
   * ```ts
   * 	app.createPage('New Page')
   * 	app.createPage('New Page', 'page1')
   * ```
   *
   * @param id - The new page's id.
   * @param title - The new page's title.
   * @public
   */
  createPage(t, e = fr.createId(), n) {
    return this._createPage(t, e, n), this;
  }
  /** @internal */
  _createPage = this.history.createCommand(
    "createPage",
    (t, e = fr.createId(), n) => {
      if (this.isReadOnly || this.pages.length >= Ix)
        return null;
      const r = this.pages, a = n ?? r[r.length - 1]?.index ?? "a1", s = r[r.findIndex((v) => v.index === a) + 1]?.index, c = { ...this.pageState }, f = { ...this.instanceState };
      t = CZ(
        t,
        r.map((v) => v.name)
      );
      const p = fr.create({
        id: e,
        name: t,
        index: s ? Fy(a, s) : Ru(a)
      }), g = Gy.create({}), y = Xy.create({
        pageId: p.id,
        instanceId: this.instanceId,
        cameraId: g.id
      });
      return {
        data: {
          prevPageState: c,
          prevTabState: f,
          newPage: p,
          newTabPageState: y,
          newCamera: g
        }
      };
    },
    {
      do: ({ newPage: t, newTabPageState: e, newCamera: n }) => {
        this.store.put([
          t,
          n,
          e,
          { ...this.instanceState, currentPageId: t.id }
        ]), this.updateCullingBounds();
      },
      undo: ({ newPage: t, prevPageState: e, prevTabState: n, newTabPageState: r }) => {
        this.store.put([e, n]), this.store.remove([r.id, t.id, r.cameraId]), this.updateCullingBounds();
      }
    }
  );
  duplicatePage(t = this.currentPageId, e = fr.createId()) {
    if (this.pages.length >= Ix)
      return;
    const n = this.getPageById(t);
    if (!n)
      return;
    const r = { ...this.camera }, a = this.getContent(this.getSortedChildIds(n.id));
    this.batch(() => {
      if (this.createPage(n.name + " Copy", e, n.index), this.setCurrentPageId(e), this.setCamera(r.x, r.y, r.z), a)
        return this.putContent(a);
    });
  }
  /**
   * Delete a page.
   *
   * @example
   * ```ts
   * 	app.deletePage('page1')
   * ```
   *
   * @param id - The id of the page to delete.
   * @public
   */
  deletePage(t) {
    this._deletePage(t);
  }
  /** @internal */
  _deletePage = this.history.createCommand(
    "delete_page",
    (t) => {
      if (this.isReadOnly)
        return null;
      const { pages: e } = this;
      if (e.length === 1)
        return null;
      const n = this.getPageById(t), r = this._pageStates.value.filter((a) => a.pageId === t);
      if (!n)
        return null;
      if (t === this.currentPageId) {
        const a = e.findIndex((c) => c.id === t), s = e[a - 1] ?? e[a + 1];
        this.setCurrentPageId(s.id);
      }
      return { data: { id: t, deletedPage: n, deletedPageStates: r } };
    },
    {
      do: ({ deletedPage: t, deletedPageStates: e }) => {
        this.store.remove(e.map((n) => n.id)), this.store.remove([t.id]), this.updateCullingBounds();
      },
      undo: ({ deletedPage: t, deletedPageStates: e }) => {
        this.store.put([t]), this.store.put(e), this.updateCullingBounds();
      }
    }
  );
  /**
   * Update a page state.
   *
   * @example
   * ```ts
   * 	app.setInstancePageState({ id: 'page1', editingId: "shape:123" })
   * 	app.setInstancePageState({ id: 'page1', editingId: "shape:123" }, true)
   * ```
   *
   * @param partial - The partial of the page state object containing the changes.
   * @param ephemeral - Whether the command is ephemeral.
   * @public
   */
  setInstancePageState(t, e = !1) {
    this._setInstancePageState(t, e);
  }
  /** @internal */
  _setInstancePageState = this.history.createCommand(
    "setInstancePageState",
    (t, e = !1) => ({ data: { prev: this.store.get(t.id ?? this.pageState.id), partial: t }, ephemeral: e }),
    {
      do: ({ prev: t, partial: e }) => {
        this.store.update(t.id, (n) => ({ ...n, ...e }));
      },
      undo: ({ prev: t }) => {
        this.store.update(t.id, () => t);
      }
    }
  );
  /**
   * Set user state. Always ephemeral for now.
   *
   * @example
   * ```ts
   * 	app.updateUser({ color: '#923433' })
   * ```
   *
   * @param partial - The partial of the user state object containing the changes.
   * @public
   */
  updateUser(t) {
    const e = { ...this.user, ...t };
    this.store.put([e]);
  }
  get _currentUserPresence() {
    return this.store.query.record("user_presence", () => ({ userId: { eq: this.userId } }));
  }
  get userPresence() {
    return this._currentUserPresence.value;
  }
  // when a user performs any action in the app, we update their presence record
  updateUserPresence = ({ cursor: t, color: e } = {}) => {
    const n = this._currentUserPresence.value;
    if (!n) {
      console.error("No presence found for current user");
      return;
    }
    this.store.put([
      {
        ...n,
        cursor: t ?? n.cursor,
        color: e ?? n.color,
        lastUsedInstanceId: this.instanceId,
        lastActivityTimestamp: Date.now()
      }
    ]);
  };
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * 	app.setSelectedIds(['id1'])
   * 	app.setSelectedIds(['id1', 'id2'])
   * ```
   *
   * @param ids - The ids to select.
   * @param squashing - Whether the change should create a new history entry or combine with the
   *   previous (if the previous is the same type).
   * @public
   */
  setSelectedIds(t, e = !1) {
    return this._setSelectedIds(t, e), this;
  }
  /** @internal */
  _setSelectedIds = this.history.createCommand(
    "setSelectedIds",
    (t, e = !1) => {
      const n = this.pageState.selectedIds, r = new Set(this.pageState.selectedIds);
      return t.length === r.size && t.every((a) => r.has(a)) ? null : { data: { ids: t, prevSelectedIds: n }, squashing: e, preservesRedoStack: !0 };
    },
    {
      do: ({ ids: t }) => {
        this.store.update(this.pageState.id, (e) => ({ ...e, selectedIds: t }));
      },
      undo: ({ prevSelectedIds: t }) => {
        this.store.update(this.pageState.id, () => ({
          ...this.pageState,
          selectedIds: t
        }));
      },
      squash(t, e) {
        return { ids: e.ids, prevSelectedIds: t.prevSelectedIds };
      }
    }
  );
  /**
   * Determine whether or not a shape is selected
   *
   * @example
   * ```ts
   * 	app.isSelected('id1')
   * ```
   *
   * @param id - The id of the shape to check.
   * @public
   */
  isSelected(t) {
    return this.selectedIdsSet.has(t);
  }
  /**
   * Determine whether a not a shape is within the current selection. A shape
   * is within the selection if it or any of its parents is selected.
   *
   * @param id - The id of the shape to check.
   * @public
   */
  isWithinSelection(t) {
    const e = this.getShapeById(t);
    return e ? this.isSelected(t) ? !0 : !!this.findAncestor(e, (n) => this.isSelected(n.id)) : !1;
  }
  get _assets() {
    return this.store.query.records("asset");
  }
  /**
   * Get all assets in the app.
   */
  get assets() {
    return this._assets.value;
  }
  /**
   * Create one or more assets.
   *
   * @example
   * ```ts
   * 	app.createAssets([...myAssets])
   * ```
   *
   * @param assets - The assets to create.
   * @public
   */
  createAssets(t) {
    return this._createAssets(t), this;
  }
  /** @internal */
  _createAssets = this.history.createCommand(
    "createAssets",
    (t) => this.isReadOnly || t.length <= 0 ? null : { data: { assets: t } },
    {
      do: ({ assets: t }) => {
        this.store.put(t);
      },
      undo: ({ assets: t }) => {
        this.store.remove(t.map((e) => e.id));
      }
    }
  );
  /**
   * Delete one or more assets.
   *
   * @example
   * ```ts
   * 	app.deleteAssets(['asset1', 'asset2'])
   * ```
   *
   * @param ids - The assets to delete.
   * @public
   */
  deleteAssets(t) {
    return this._deleteAssets(t), this;
  }
  /** @internal */
  _deleteAssets = this.history.createCommand(
    "deleteAssets",
    (t) => {
      if (this.isReadOnly || t.length <= 0)
        return;
      const e = Gt(t.map((n) => this.store.get(n)));
      return { data: { ids: t, prev: e } };
    },
    {
      do: ({ ids: t }) => {
        this.store.remove(t);
      },
      undo: ({ prev: t }) => {
        this.store.put(t);
      }
    }
  );
  /**
   * Update one or more assets.
   *
   * @example
   * ```ts
   * 	app.updateAssets([{ id: 'asset1', name: 'New name' }])
   * ```
   *
   * @param assets - The assets to update.
   * @public
   */
  updateAssets(t) {
    return this._updateAssets(t), this;
  }
  /** @internal */
  _updateAssets = this.history.createCommand(
    "updateAssets",
    (t) => this.isReadOnly || t.length <= 0 ? void 0 : { data: { snapshots: {}, assets: t } },
    {
      do: ({ assets: t, snapshots: e }) => {
        this.store.put(
          t.map((n) => {
            const r = this.store.get(n.id);
            return e[n.id] = r, {
              ...r,
              ...n
            };
          })
        );
      },
      undo: ({ snapshots: t }) => {
        this.store.put(Object.values(t));
      }
    }
  );
  /**
   * Get an asset by its src property.
   *
   * @example
   * ```ts
   * 	app.getAssetBySource('https://example.com/image.png')
   * ```
   *
   * @param src - The source value of the asset.
   * @public
   */
  getAssetBySrc(t) {
    return this.assets.find((e) => e.props.src === t);
  }
  /**
   * Get an asset by its id.
   *
   * @example
   * ```ts
   * 	app.getAssetById('asset1')
   * ```
   *
   * @param id - The id of the asset.
   * @public
   */
  getAssetById(t) {
    return this.store.get(t);
  }
  /* ------------------- SubCommands ------------------ */
  async getSvg(t = this.selectedIds.length ? this.selectedIds : Object.keys(this.shapeIds), e = {}) {
    if (t.length === 0)
      return;
    if (!window.document)
      throw Error("No document");
    const {
      scale: n = 1,
      background: r = !1,
      padding: a = sQ,
      darkMode: s = this.userDocumentSettings.isDarkMode,
      preserveAspectRatio: c = !1
    } = e, f = this.getContainer(), p = getComputedStyle(f), g = document.createElement("div");
    g.className = `rs-container rs-theme__${s ? "dark" : "light"}`, document.body.appendChild(g);
    const y = getComputedStyle(g), v = /* @__PURE__ */ new Map(), S = {
      fill: Object.fromEntries(
        Dw.color.map((F) => [
          F.id,
          y.getPropertyValue(`--palette-${F.id}`)
        ])
      ),
      pattern: Object.fromEntries(
        Dw.color.map((F) => [
          F.id,
          y.getPropertyValue(`--palette-${F.id}-pattern`)
        ])
      ),
      semi: Object.fromEntries(
        Dw.color.map((F) => [
          F.id,
          y.getPropertyValue(`--palette-${F.id}-semi`)
        ])
      ),
      text: y.getPropertyValue("--color-text"),
      background: y.getPropertyValue("--color-background"),
      solid: y.getPropertyValue("--palette-solid")
    };
    document.body.removeChild(g);
    const x = this.getShapesAndDescendantsInOrder(t), _ = ot.FromPoints(
      x.map((F) => {
        const K = this.getPageTransform(F);
        return De.applyToPoints(K, this.getOutline(F));
      }).flat()
    );
    _.expandBy(a);
    const T = window.document.createElementNS("http://www.w3.org/2000/svg", "svg");
    c && T.setAttribute("preserveAspectRatio", c);
    const I = _.width * n, D = _.height * n;
    T.setAttribute("direction", "ltr"), T.setAttribute("width", I + ""), T.setAttribute("height", D + ""), T.setAttribute("viewBox", `${_.minX} ${_.minY} ${_.width} ${_.height}`), T.setAttribute("stroke-linecap", "round"), T.setAttribute("stroke-linejoin", "round"), T.style.setProperty("background-color", r ? S.background : "transparent");
    const N = window.document.createElementNS("http://www.w3.org/2000/svg", "defs");
    for (const F of Array.from(ree()))
      N.appendChild(F);
    try {
      document.body.focus?.();
    } catch {
    }
    T.append(N);
    for (const F of x) {
      let K;
      "font" in F.props && F.props.font && (v.has(F.props.font) ? K = v.get(F.props.font) : (K = p.getPropertyValue(`--rs-font-${F.props.font}`), v.set(F.props.font, K)));
      let se = await this.getShapeUtil(F).toSvg?.(F, K, S);
      if (!se) {
        const ve = this.getPageBounds(F), Y = window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
        Y.setAttribute("width", ve.width + ""), Y.setAttribute("height", ve.height + ""), Y.setAttribute("fill", S.solid), Y.setAttribute("stroke", S.pattern.grey), Y.setAttribute("stroke-width", "1"), se = Y;
      }
      const ue = se;
      let pe = this.getPageTransform(F).toCssString();
      "scale" in F.props && F.props.scale !== 1 && (pe = `${pe} scale(${F.props.scale}, ${F.props.scale})`), ue.setAttribute("transform", pe), "opacity" in F.props && ue.setAttribute("opacity", F.props.opacity + ""), T.appendChild(ue);
      const Pe = this._clipPathCache.get(F.id);
      if (ue && Pe) {
        const ve = document.createElementNS("http://www.w3.org/2000/svg", "g");
        ve.style.clipPath = Pe, Array.from(ue.childNodes).forEach((le) => ve.appendChild(le)), ue.appendChild(ve);
      }
    }
    let j = "";
    const L = window.document.createElementNS("http://www.w3.org/2000/svg", "style"), z = [];
    "fonts" in document && document.fonts.forEach((F) => z.push(F));
    for (const F of z) {
      const K = new FileReader();
      let X = !1;
      if (v.forEach((pe) => {
        pe.includes(F.family) && (X = !0);
      }), !X)
        continue;
      const se = F.$$_url, ue = F.$$_fontface;
      if (se) {
        const pe = await (await fetch(se)).blob(), Pe = await new Promise((Y, le) => {
          K.onload = () => Y(K.result), K.onerror = () => le(K.error), K.readAsDataURL(pe);
        }), ve = `
` + ue.replaceAll(se, Pe);
        j += ve;
      }
    }
    return L.textContent = j, N.append(L), T;
  }
  /**
   * Rename a page.
   *
   * @example
   * ```ts
   * 	app.renamePage('page1', 'My Page')
   * ```
   *
   * @param id - The id of the page to rename.
   * @param name - The new name.
   * @public
   */
  renamePage(t, e, n = !1) {
    return this.isReadOnly ? this : (this.updatePage({ id: t, name: e }, n), this);
  }
  /**
   * Move shapes to page.
   *
   * @example
   * ```ts
   * 	app.moveShapesToPage(['box1', 'box2'], 'page1')
   * ```
   *
   * @param ids - The ids of the shapes to move.
   * @param pageId - The id of the page where the shapes will be moved.
   * @public
   */
  moveShapesToPage(t, e) {
    if (t.length === 0)
      return this;
    if (this.isReadOnly)
      return this;
    const { currentPageId: n } = this;
    if (e === n)
      return this;
    if (!this.store.has(e))
      return this;
    const r = this.getContent(t);
    if (!r)
      return this;
    if (this.getShapesInPage(e).length + r.shapes.length > yp)
      return Uw(this, e), this;
    const a = this.camera.z;
    return this.history.batch(() => {
      this.deleteShapes(t), this.setCurrentPageId(e), this.setFocusLayer(null), this.selectNone(), this.putContent(r, { select: !0, preserveIds: !0, preservePosition: !0 });
      const {
        center: { x: s, y: c }
      } = this.selectionBounds;
      this.setCamera(this.camera.x, this.camera.y, a), this.centerOnPoint(s, c);
    }), this.emit("moved-to-page", { name: this.currentPage.name, toId: e, fromId: n }), this;
  }
  lockShapes(t = this.pageState.selectedIds) {
    return this.isReadOnly ? this : this;
  }
  /**
   * Reorder shapes.
   *
   * @param operation - The operation to perform.
   * @param ids - The ids to reorder.
   * @public
   */
  reorderShapes(t, e) {
    if (this.isReadOnly)
      return this;
    if (e.length === 0)
      return this;
    const n = this.getParentsMappedToChildren(e), r = [];
    switch (t) {
      case "toBack": {
        n.forEach((a, s) => {
          const c = Gt(
            this.getSortedChildIds(s).map((y) => this.getShapeById(y))
          );
          if (a.size === c.length)
            return;
          let f, p;
          for (const y of c) {
            if (!a.has(y)) {
              p = y.index;
              break;
            }
            a.delete(y), f = y.index;
          }
          if (a.size === 0)
            return;
          const g = Rg(f, p, a.size);
          Array.from(a.values()).sort(Ha).forEach(
            (y, v) => r.push({ id: y.id, type: y.type, index: g[v] })
          );
        });
        break;
      }
      case "toFront": {
        n.forEach((a, s) => {
          const c = Gt(
            this.getSortedChildIds(s).map((v) => this.getShapeById(v))
          ), f = c.length;
          if (a.size === f)
            return;
          let p, g;
          for (let v = f - 1; v > -1; v--) {
            const S = c[v];
            if (!a.has(S)) {
              p = S.index;
              break;
            }
            a.delete(S), g = S.index;
          }
          if (a.size === 0)
            return;
          const y = Rg(p, g, a.size);
          Array.from(a.values()).sort(Ha).forEach(
            (v, S) => r.push({ id: v.id, type: v.type, index: y[S] })
          );
        });
        break;
      }
      case "forward": {
        n.forEach((a, s) => {
          const c = Gt(
            this.getSortedChildIds(s).map((_) => this.getShapeById(_))
          ), f = c.length;
          if (a.size === f)
            return;
          const p = new Set(Array.from(a).map((_) => c.indexOf(_)));
          let g = -1, y = !1, v, S, x;
          for (let _ = 0; _ < f; _++) {
            const T = p.has(_);
            if (!y && T)
              y = !0, g = _, S = void 0;
            else if (y && !T) {
              y = !1, x = _ - g, v = c[_].index, S = c[_ + 1]?.index;
              const I = Rg(v, S, x);
              for (let D = 0; D < x; D++) {
                const N = c[g + D];
                r.push({ id: N.id, type: N.type, index: I[D] });
              }
            }
          }
        });
        break;
      }
      case "backward": {
        n.forEach((a, s) => {
          const c = Gt(
            this.getSortedChildIds(s).map((S) => this.getShapeById(S))
          ), f = c.length;
          if (a.size === f)
            return;
          const p = new Set(Array.from(a).map((S) => c.indexOf(S)));
          let g = -1, y = !1, v;
          for (let S = f - 1; S > -1; S--) {
            const x = p.has(S);
            if (!y && x)
              y = !0, g = S;
            else if (y && !x) {
              y = !1, v = g - S;
              const _ = Rg(c[S - 1]?.index, c[S].index, v);
              for (let T = 0; T < v; T++) {
                const I = c[S + T + 1];
                r.push({ id: I.id, type: I.type, index: _[T] });
              }
            }
          }
        });
        break;
      }
    }
    return this.updateShapes(r), this;
  }
  /**
   * Send shapes to the back of the page's object list.
   *
   * @example
   * ```ts
   * 	app.sendToBack()
   * 	app.sendToBack(['id1', 'id2'])
   * ```
   *
   * @param ids - The ids of the shapes to move. Defaults to the ids of the selected
   *   shapes.
   * @public
   */
  sendToBack(t = this.pageState.selectedIds) {
    return this.reorderShapes("toBack", t), this;
  }
  /**
   * Send shapes backward in the page's object list.
   *
   * @example
   * ```ts
   * 	app.sendBackward()
   * 	app.sendBackward(['id1', 'id2'])
   * ```
   *
   * @param ids - The ids of the shapes to move. Defaults to the ids of the selected
   *   shapes.
   * @public
   */
  sendBackward(t = this.pageState.selectedIds) {
    return this.reorderShapes("backward", t), this;
  }
  /**
   * Bring shapes forward in the page's object list.
   *
   * @example
   * ```ts
   * 	app.bringForward()
   * 	app.bringForward(['id1', 'id2'])
   * ```
   *
   * @param ids - The ids of the shapes to move. Defaults to the ids of the selected
   *   shapes.
   * @public
   */
  bringForward(t = this.pageState.selectedIds) {
    return this.reorderShapes("forward", t), this;
  }
  /**
   * Bring shapes to the front of the page's object list.
   *
   * @example
   * ```ts
   * 	app.bringToFront()
   * 	app.bringToFront(['id1', 'id2'])
   * ```
   *
   * @param ids - The ids of the shapes to move. Defaults to the ids of the selected
   *   shapes.
   * @public
   */
  bringToFront(t = this.pageState.selectedIds) {
    return this.reorderShapes("toFront", t), this;
  }
  /**
   * Flip shape positions.
   *
   * @example
   * ```ts
   * 	app.flipShapes('horizontal')
   * 	app.flipShapes('horizontal', ['box1', 'box2'])
   * ```
   *
   * @param operation - Whether to flip horizontally or vertically.
   * @param ids - The ids of the shapes to flip. Defaults to selected shapes.
   * @public
   */
  flipShapes(t, e = this.selectedIds) {
    if (this.isReadOnly)
      return this;
    let n = Gt(e.map((a) => this.getShapeById(a)));
    if (!n.length)
      return this;
    n = n.map((a) => a.type === "group" ? this.getSortedChildIds(a.id).map((s) => this.getShapeById(s)) : a).flat();
    const r = ot.Common(Gt(n.map((a) => this.getPageBounds(a)))).center;
    for (const a of n) {
      const c = this.getShapeUtil(a).bounds(a), f = this.getPageTransformById(a.id);
      f && this.resizeShape(
        a.id,
        { x: t === "horizontal" ? -1 : 1, y: t === "vertical" ? -1 : 1 },
        {
          initialBounds: c,
          initialPageTransform: f,
          initialShape: a,
          mode: "scale_shape",
          scaleOrigin: r,
          scaleAxisRotation: 0
        }
      );
    }
    return this;
  }
  /**
   * Stack shape.
   *
   * @example
   * ```ts
   * 	app.stackShapes('horizontal')
   * 	app.stackShapes('horizontal', ['box1', 'box2'])
   * 	app.stackShapes('horizontal', ['box1', 'box2'], 20)
   * ```
   *
   * @param operation - Whether to stack horizontally or vertically.
   * @param ids - The ids of the shapes to stack. Defaults to selected shapes.
   * @param gap - A specific gap to use when stacking.
   * @public
   */
  stackShapes(t, e = this.pageState.selectedIds, n) {
    if (this.isReadOnly)
      return this;
    const r = Gt(e.map((x) => this.getShapeById(x))).filter((x) => !(!x || to.is(x) && (x.props.start.type === "binding" || x.props.end.type === "binding"))), a = r.length;
    if (n === void 0 && a < 3 || a < 2)
      return this;
    const s = Object.fromEntries(
      r.map((x) => [x.id, this.getPageBounds(x)])
    );
    let c, f, p, g;
    t === "horizontal" ? (c = "x", f = "minX", p = "maxX", g = "width") : (c = "y", f = "minY", p = "maxY", g = "height");
    let y;
    if (n === void 0) {
      const x = [];
      r.sort((T, I) => s[T.id][f] - s[I.id][f]);
      for (let T = 0; T < a - 1; T++) {
        const I = r[T], D = r[T + 1], N = s[I.id], L = s[D.id][f] - N[p], z = x.find((F) => F.gap === L);
        z ? z.count++ : x.push({ gap: L, count: 1 });
      }
      let _ = 0;
      x.forEach((T) => {
        T.count > _ && (_ = T.count, y = T.gap);
      }), _ === 1 && (y = Math.max(0, x.reduce((T, I) => T + I.gap * I.count, 0) / (a - 1)));
    } else
      y = n;
    const v = [];
    let S = s[r[0].id][p];
    return r.forEach((x, _) => {
      if (_ === 0)
        return;
      const T = { x: 0, y: 0 };
      T[c] = S + y - s[x.id][c];
      const I = this.getParentShape(x), D = I ? O.Rot(T, -this.getPageRotation(I)) : T, N = this.getShapeUtil(x).onTranslateStart?.(x);
      v.push(
        N ? {
          ...N,
          [c]: x[c] + D[c]
        } : {
          id: x.id,
          type: x.type,
          [c]: x[c] + D[c]
        }
      ), S += s[x.id][g] + y;
    }), this.updateShapes(v), this;
  }
  /**
   * Pack shapes into a grid centered on their current position.
   * Based on potpack (https://github.com/mapbox/potpack)
   *
   * @param ids - The ids of the shapes to pack. Defaults to selected shapes.
   * @param padding - The padding to apply to the packed shapes.
   */
  packShapes(t = this.pageState.selectedIds, e = 16) {
    if (this.isReadOnly)
      return this;
    if (t.length < 2)
      return this;
    const n = Gt(
      t.map((L) => this.getShapeById(L)).filter((L) => !(!L || to.is(L) && (L.props.start.type === "binding" || L.props.end.type === "binding")))
    ), r = {}, a = {};
    let s, c, f = 0;
    for (let L = 0; L < n.length; L++)
      s = n[L], c = this.getPageBounds(s), r[s.id] = c, a[s.id] = c.clone(), f += c.width * c.height;
    const p = ot.Common(Gt(Object.values(r))), g = p.width;
    n.sort((L, z) => r[z.id].height - r[L.id].height);
    const y = Math.max(Math.ceil(Math.sqrt(f / 0.95)), g), v = [new ot(p.x, p.y, y, 1 / 0)];
    let S = 0, x = 0, _, T;
    for (let L = 0; L < n.length; L++) {
      s = n[L], c = a[s.id];
      for (let z = v.length - 1; z >= 0; z--)
        if (_ = v[z], !(c.width > _.width || c.height > _.height)) {
          c.x = _.x, c.y = _.y, x = Math.max(x, c.maxY), S = Math.max(S, c.maxX), c.width === _.width && c.height === _.height ? (T = v.pop(), z < v.length && (v[z] = T)) : c.height === _.height ? (_.x += c.width + e, _.width -= c.width + e) : c.width === _.width ? (_.y += c.height + e, _.height -= c.height + e) : (v.push(
            new ot(
              _.x + (c.width + e),
              _.y,
              _.width - (c.width + e),
              c.height
            )
          ), _.y += c.height + e, _.height -= c.height + e);
          break;
        }
    }
    const I = ot.Common(Object.values(a)), D = O.Sub(p.center, I.center);
    let N;
    const j = [];
    for (let L = 0; L < n.length; L++) {
      s = n[L], c = r[s.id], N = a[s.id];
      const z = this.getDeltaInParentSpace(
        s,
        O.Sub(N.point, c.point).add(D)
      ), F = {
        id: s.id,
        type: s.type,
        x: s.x + z.x,
        y: s.y + z.y
      }, K = this.getShapeUtil(s).onTranslateStart?.({
        ...s,
        ...F
      });
      K ? j.push({ ...F, ...K }) : j.push(F);
    }
    return j.length && this.updateShapes(j), this;
  }
  /**
   * Align shape positions.
   *
   * @example
   * ```ts
   * 	app.alignShapes('left')
   * 	app.alignShapes('left', ['box1', 'box2'])
   * ```
   *
   * @param operation - The align operation to apply.
   * @param ids - The ids of the shapes to align. Defaults to selected shapes.
   * @public
   */
  alignShapes(t, e = this.pageState.selectedIds) {
    if (this.isReadOnly)
      return this;
    if (e.length < 2)
      return this;
    const n = Gt(e.map((c) => this.getShapeById(c))), r = Object.fromEntries(
      n.map((c) => [c.id, this.getPageBounds(c)])
    ), a = ot.Common(Gt(Object.values(r))), s = [];
    return n.forEach((c) => {
      const f = r[c.id];
      if (!f)
        return;
      const p = { x: 0, y: 0 };
      switch (t) {
        case "top": {
          p.y = a.minY - f.minY;
          break;
        }
        case "center-vertical": {
          p.y = a.midY - f.minY - f.height / 2;
          break;
        }
        case "bottom": {
          p.y = a.maxY - f.minY - f.height;
          break;
        }
        case "left": {
          p.x = a.minX - f.minX;
          break;
        }
        case "center-horizontal": {
          p.x = a.midX - f.minX - f.width / 2;
          break;
        }
        case "right": {
          p.x = a.maxX - f.minX - f.width;
          break;
        }
      }
      const g = this.getParentShape(c), y = g ? O.Rot(p, -this.getPageRotation(g)) : p, v = this.getShapeUtil(c).onTranslateStart?.(c);
      s.push(
        v ? {
          ...v,
          x: c.x + y.x,
          y: c.y + y.y
        } : {
          id: c.id,
          type: c.type,
          x: c.x + y.x,
          y: c.y + y.y
        }
      );
    }), this.updateShapes(s), this;
  }
  /**
   * Distribute shape positions.
   *
   * @example
   * ```ts
   * 	app.distributeShapes('left')
   * 	app.distributeShapes('left', ['box1', 'box2'])
   * ```
   *
   * @param operation - Whether to distribute shapes horizontally or vertically.
   * @param ids - The ids of the shapes to distribute. Defaults to selected shapes.
   * @public
   */
  distributeShapes(t, e = this.pageState.selectedIds) {
    if (this.isReadOnly)
      return this;
    if (e.length < 3)
      return this;
    const n = e.length, r = Gt(e.map((I) => this.getShapeById(I))), a = Object.fromEntries(
      r.map((I) => [I.id, this.getPageBounds(I)])
    );
    let s, c, f, p, g;
    t === "horizontal" ? (s = "x", c = "minX", f = "maxX", p = "midX", g = "width") : (s = "y", c = "minY", f = "maxY", p = "midY", g = "height");
    const y = [], v = r.sort((I, D) => a[I.id][c] - a[D.id][c])[0], S = r.sort((I, D) => a[D.id][f] - a[I.id][f])[0], x = a[v.id][p], _ = (a[S.id][p] - x) / (n - 1), T = x + _;
    return r.filter((I) => I !== v && I !== S).sort((I, D) => a[I.id][p] - a[D.id][p]).forEach((I, D) => {
      const N = { x: 0, y: 0 };
      N[s] = T + _ * D - a[I.id][g] / 2 - a[I.id][s];
      const j = this.getParentShape(I), L = j ? O.Rot(N, -this.getPageRotation(j)) : N, z = this.getShapeUtil(I).onTranslateStart?.(I);
      y.push(
        z ? {
          ...z,
          [s]: I[s] + L[s]
        } : {
          id: I.id,
          type: I.type,
          [s]: I[s] + L[s]
        }
      );
    }), this.updateShapes(y), this;
  }
  /** @internal */
  _resizeUnalignedShape(t, e, n) {
    const { type: r } = n.initialShape, a = new O(e.x, e.y);
    if (Math.abs(e.x) > Math.abs(e.y) ? a.x = Math.sign(e.x) * Math.abs(e.y) : a.y = Math.sign(e.y) * Math.abs(e.x), this.resizeShape(t, a, {
      initialShape: n.initialShape,
      initialBounds: n.initialBounds
    }), Math.sign(e.x) * Math.sign(e.y) < 0) {
      let { rotation: x } = De.Decompose(n.initialPageTransform);
      x -= 2 * x, this.updateShapes([{ id: t, type: r, rotation: x }], !0);
    }
    const s = De.applyToPoint(
      n.initialPageTransform,
      n.initialBounds.center
    ), c = this._scalePagePoint(
      s,
      n.scaleOrigin,
      e,
      n.scaleAxisRotation
    ), f = this.getPageCenterById(t), p = this.getPagePointById(t);
    if (!f || !p)
      return this;
    const g = O.Sub(c, f), y = O.Add(p, g), { x: v, y: S } = this.getPointInParentSpace(t, y);
    return this.updateShapes([{ id: t, type: r, x: v, y: S }], !0), this;
  }
  /** @internal */
  _scalePagePoint(t, e, n, r) {
    const a = O.RotWith(t, e, -r).sub(e), s = O.MulV(a, n);
    return O.Add(s, e).rotWith(
      e,
      r
    );
  }
  resizeShape(t, e, n) {
    if (this.isReadOnly)
      return this;
    Number.isFinite(e.x) || (e = new O(1, e.y)), Number.isFinite(e.y) || (e = new O(e.x, 1));
    const r = n?.initialShape ?? this.getShapeById(t);
    if (!r)
      return this;
    const a = n?.scaleOrigin ?? this.getPageBoundsById(t)?.center;
    if (!a)
      return this;
    const s = this.getPageRotationById(t);
    if (s == null)
      return this;
    const c = n?.scaleAxisRotation ?? s, f = n?.initialPageTransform ?? this.getPageTransformById(t);
    if (!f)
      return this;
    const p = n?.initialBounds ?? this.getBoundsById(t);
    if (!p)
      return this;
    if (!TL(s, c))
      return this._resizeUnalignedShape(t, e, {
        ...n,
        initialBounds: p,
        scaleOrigin: a,
        scaleAxisRotation: c,
        initialPageTransform: f,
        initialShape: r
      });
    const g = this.getShapeUtil(r);
    if (g.isAspectRatioLocked(r) && (Math.abs(e.x) > Math.abs(e.y) ? e = new O(e.x, Math.sign(e.y) * Math.abs(e.x)) : e = new O(Math.sign(e.x) * Math.abs(e.y), e.y)), g.onResize && g.canResize(r)) {
      const y = this._scalePagePoint(
        De.applyToPoint(f, new O(0, 0)),
        a,
        e,
        c
      ), v = this.getPointInParentSpace(r.id, y), S = new O(e.x, e.y), x = By(
        (s - c) % Math.PI,
        0
      );
      S.x = x ? e.x : e.y, S.y = x ? e.y : e.x;
      const _ = De.applyToPoint(f, new O()), { x: T, y: I } = this.getPointInParentSpace(r.id, _);
      this.updateShapes(
        [
          {
            id: t,
            type: r.type,
            x: v.x,
            y: v.y,
            ...g.onResize(
              { ...r, x: T, y: I },
              {
                newPoint: v,
                handle: n?.dragHandle ?? "bottom_right",
                // don't set isSingle to true for children
                mode: n?.mode ?? "scale_shape",
                scaleX: S.x,
                scaleY: S.y,
                initialBounds: p,
                initialShape: r
              }
            )
          }
        ],
        !0
      );
    } else {
      const y = De.applyToPoint(f, p.center), v = this._scalePagePoint(
        y,
        a,
        e,
        c
      ), S = this.getPointInParentSpace(
        r.id,
        y
      ), x = this.getPointInParentSpace(r.id, v), _ = O.Sub(x, S);
      this.updateShapes(
        [
          {
            id: t,
            type: r.type,
            x: r.x + _.x,
            y: r.y + _.y
          }
        ],
        !0
      );
    }
    return this;
  }
  /**
   * Stretch shape sizes and positions to fill their common bounding box.
   *
   * @example
   * ```ts
   * 	app.stretchShapes('horizontal')
   * 	app.stretchShapes('horizontal', ['box1', 'box2'])
   * ```
   *
   * @param operation - Whether to stretch shapes horizontally or vertically.
   * @param ids - The ids of the shapes to stretch. Defaults to selected shapes.
   * @public
   */
  stretchShapes(t, e = this.pageState.selectedIds) {
    if (this.isReadOnly)
      return this;
    if (e.length < 2)
      return this;
    const n = Gt(e.map((f) => this.getShapeById(f))), r = Object.fromEntries(n.map((f) => [f.id, this.getBounds(f)])), a = Object.fromEntries(
      n.map((f) => [f.id, this.getPageBounds(f)])
    ), s = ot.Common(Gt(Object.values(a))), c = [];
    switch (t) {
      case "vertical": {
        this.batch(() => {
          for (const f of n) {
            if (this.getPageRotation(f) % Kr)
              continue;
            const g = r[f.id], y = a[f.id], v = this.getDeltaInParentSpace(
              f,
              new O(0, s.minY - y.minY)
            ), { x: S, y: x } = O.Add(v, f);
            this.updateShapes([{ id: f.id, type: f.type, x: S, y: x }], !0);
            const _ = new O(1, s.height / y.height);
            this.resizeShape(f.id, _, {
              initialBounds: g,
              scaleOrigin: new O(y.center.x, s.minY),
              scaleAxisRotation: 0
            });
          }
        });
        break;
      }
      case "horizontal": {
        this.batch(() => {
          for (const f of n) {
            const p = r[f.id], g = a[f.id];
            if (this.getPageRotation(f) % Kr)
              continue;
            const v = this.getDeltaInParentSpace(
              f,
              new O(s.minX - g.minX, 0)
            ), { x: S, y: x } = O.Add(v, f);
            this.updateShapes([{ id: f.id, type: f.type, x: S, y: x }], !0);
            const _ = new O(s.width / g.width, 1);
            this.resizeShape(f.id, _, {
              initialBounds: p,
              scaleOrigin: new O(s.minX, g.center.y),
              scaleAxisRotation: 0
            });
          }
        });
        break;
      }
    }
    return this.updateShapes(c), this;
  }
  /**
   * Reparent shapes to a new parent. This operation preserves the shape's current page positions /
   * rotations.
   *
   * @example
   * ```ts
   * 	app.reparentShapesById(['box1', 'box2'], 'frame1')
   * ```
   *
   * @param ids - The ids of the shapes to reparent.
   * @param parentId - The id of the new parent shape.
   * @param insertIndex - The index to insert the children.
   * @public
   */
  reparentShapesById(t, e, n) {
    const r = [], a = fr.isId(e) ? De.Identity() : this.getPageTransformById(e), s = a.decompose().rotation;
    let c = [];
    const f = Gt(this.getSortedChildIds(e).map((g) => this.getShapeById(g)));
    if (n) {
      const g = f.find((y) => y.index === n);
      if (g) {
        const y = f[f.indexOf(g) + 1];
        y ? c = Rg(n, y.index, t.length) : c = JT(n, t.length);
      } else {
        const y = f.sort(Ha).find((v) => v.index > n);
        y ? c = Rg(n, y.index, t.length) : c = JT(n, t.length);
      }
    } else {
      const g = f.length && f[f.length - 1];
      c = g ? JT(g.index, t.length) : ZL(t.length);
    }
    let p;
    for (let g = 0; g < t.length; g++) {
      p = t[g];
      const y = this.getShapeById(p), v = this.getPagePointById(p);
      if (!y || !v)
        continue;
      const S = De.applyToPoint(De.Inverse(a), v), x = this.getPageRotation(y) - s;
      r.push({
        id: y.id,
        type: y.type,
        parentId: e,
        x: S.x,
        y: S.y,
        rotation: x,
        index: c[g]
      });
    }
    return this.updateShapes(r), this;
  }
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * 	app.select('id1')
   * 	app.select('id1', 'id2')
   * ```
   *
   * @param ids - The ids to select.
   * @public
   */
  select(...t) {
    return this.setSelectedIds(t), this;
  }
  /**
   * Remove a shpae from the existing set of selected shapes.
   *
   * @example
   * ```ts
   * 	app.deselect(shape.id)
   * ```
   *
   * @public
   */
  deselect(...t) {
    const { selectedIds: e } = this;
    return e.length > 0 && t.length > 0 && this.setSelectedIds(e.filter((n) => !t.includes(n))), this;
  }
  /**
   * Select all direct children of the current page.
   *
   * @example
   * ```ts
   * 	app.selectAll()
   * ```
   *
   * @public
   */
  selectAll() {
    const t = this.getSortedChildIds(this.currentPageId);
    return t.length <= 0 ? this : (this.setSelectedIds(t), this);
  }
  getShapesAndDescendantsInOrder(t) {
    const e = [], n = /* @__PURE__ */ new Set(), r = [...t];
    for (; r.length > 0; ) {
      const c = r.pop();
      if (!c)
        break;
      n.has(c) || (e.push(c), this.getSortedChildIds(c).forEach((f) => {
        r.push(f);
      }));
    }
    const a = e.map((c) => this.getShapeById(c)).filter((c) => c.type !== "group"), { sortedShapesArray: s } = this;
    return a.sort((c, f) => s.indexOf(c) - s.indexOf(f)), a;
  }
  /**
   * Clear the selection.
   *
   * @example
   * ```ts
   * 	app.selectNone()
   * ```
   *
   * @public
   */
  selectNone() {
    return this.selectedIds.length > 0 && this.setSelectedIds([]), this;
  }
  /**
   * Set the current page.
   *
   * @example
   * ```ts
   * 	app.setCurrentPageId('page1')
   * ```
   *
   * @param pageId - The id of the page to set as the current page.
   * @public
   */
  setCurrentPageId(t) {
    return this._setCurrentPageId(t), this;
  }
  /** @internal */
  _setCurrentPageId = this.history.createCommand(
    "setCurrentPage",
    (t) => {
      if (!this.store.has(t)) {
        console.error("Tried to set the current page id to a page that doesn't exist.");
        return;
      }
      return {
        data: { pageId: t, prev: this.currentPageId },
        squashing: !0,
        preservesRedoStack: !0
      };
    },
    {
      do: ({ pageId: t }) => {
        if (!this.getPageStateByPageId(t)) {
          const e = Gy.create({});
          this.store.put([
            e,
            Xy.create({
              pageId: t,
              instanceId: this.instanceId,
              cameraId: e.id
            })
          ]);
        }
        this.store.put([{ ...this.instanceState, currentPageId: t }]), this.updateCullingBounds();
      },
      undo: ({ prev: t }) => {
        this.store.put([{ ...this.instanceState, currentPageId: t }]), this.updateCullingBounds();
      },
      squash: ({ prev: t }, { pageId: e }) => ({ pageId: e, prev: t })
    }
  );
  /** Set the current user tab state */
  updateInstanceState(t, e = !1, n = !1) {
    return this._updateInstanceState(t, e, n), this;
  }
  /** @internal */
  _updateInstanceState = this.history.createCommand(
    "updateTabState",
    (t, e = !1, n = !1) => {
      const r = this.instanceState, a = { ...r, ...t };
      return {
        data: { prev: r, next: a },
        squashing: n,
        ephemeral: e
      };
    },
    {
      do: ({ next: t }) => {
        this.store.put([t]);
      },
      undo: ({ prev: t }) => {
        this.store.put([t]);
      },
      squash({ prev: t }, { next: e }) {
        return { prev: t, next: e };
      }
    }
  );
  get hoveredId() {
    return this.pageState.hoveredId;
  }
  get hoveredShape() {
    return this.hoveredId ? this.getShapeById(this.hoveredId) ?? null : null;
  }
  /**
   * Set the current hovered shape.
   *
   * @example
   * ```ts
   * 	app.setHoveredId('box1')
   * 	app.setHoveredId() // Clears the hovered shape.
   * ```
   *
   * @param id - The id of the page to set as the current page
   * @public
   */
  setHoveredId(t = null) {
    return t === this.pageState.hoveredId ? this : (this.setInstancePageState({ hoveredId: t }, !0), this);
  }
  /**
   * Set the current erasing shapes.
   *
   * @example
   * ```ts
   * 	app.setErasingIds(['box1', 'box2'])
   * 	app.setErasingIds() // Clears the erasing set
   * ```
   *
   * @param ids - The ids of shapes to set as erasing.
   * @public
   */
  setErasingIds(t = []) {
    const e = this.erasingIdsSet;
    return t.length === e.size && t.every((n) => e.has(n)) ? this : (this.setInstancePageState({ erasingIds: t }, !0), this);
  }
  /**
   * Set the current cursor.
   *
   * @example
   * ```ts
   * 	app.setCursor({ type: 'default' })
   * 	app.setCursor({ type: 'default', rotation: Math.PI / 2, color: 'red' })
   * ```
   *
   * @param cursor - A partial of the cursor object.
   * @public
   */
  setCursor(t) {
    const e = this.cursor, n = {
      ...e,
      rotation: 0,
      ...t
    };
    return e.type === n.type && e.rotation === n.rotation && e.color === n.color || this.updateInstanceState({ cursor: n }, !0), this;
  }
  /**
   * Set the current scribble.
   *
   * @example
   * ```ts
   * 	app.setScribble(nextScribble)
   * 	app.setScribble() // clears the scribble
   * ```
   *
   * @param scribble - The new scribble object.
   * @public
   */
  setScribble(t = null) {
    return this.updateInstanceState({ scribble: t }, !0), this;
  }
  /**
   * Set the current brush.
   *
   * @example
   * ```ts
   * 	app.setBrush({ x: 0, y: 0, w: 100, h: 100 })
   * 	app.setBrush() // Clears the brush
   * ```
   *
   * @param brush - The brush box model to set, or null for no brush model.
   * @public
   */
  setBrush(t = null) {
    return !t && this.brush, this.batch(() => {
      this.updateInstanceState({ brush: t }, !0);
    }), this;
  }
  /**
   * Rotate shapes by a delta in radians.
   *
   * @example
   * ```ts
   * 	app.rotateShapesBy(['box1', 'box2'], Math.PI)
   * 	app.rotateShapesBy(['box1', 'box2'], 'Math.PI / 2)
   * ```
   *
   * @param ids - The ids of the shapes to move.
   * @param delta - The delta in radians to apply to the selection rotation.
   */
  rotateShapesBy(t, e) {
    if (t.length <= 0)
      return this;
    const n = JL({ app: this });
    return cx({ delta: e, snapshot: n, app: this, stage: "one-off" }), this;
  }
  /**
   * Move shapes by a delta.
   *
   * @example
   * ```ts
   * 	app.nudgeShapes(['box1', 'box2'], 'left')
   * 	app.nudgeShapes(['box1', 'box2'], 'left', true)
   * ```
   *
   * @param ids - The ids of the shapes to move.
   * @param direction - The direction in which to move the shapes.
   * @param major - Whether this is a major nudge, e.g. a shift + arrow nudge.
   */
  nudgeShapes(t, e, n = !1) {
    if (t.length <= 0)
      return this;
    const r = this.isGridMode ? n ? this.gridSize * rQ : this.gridSize : n ? Jq : eQ, a = O.Mul(iQ[e], r), s = [];
    for (const c of t) {
      const f = this.getShapeById(c);
      if (!f)
        throw Error(`Could not find a shape with the id ${c}.`);
      const p = this.getDeltaInParentSpace(f, a), g = this.getShapeUtil(f).onTranslateStart?.(f);
      s.push(
        g ? {
          ...g,
          x: f.x + p.x,
          y: f.y + p.y
        } : {
          id: c,
          x: f.x + p.x,
          y: f.y + p.y,
          type: f.type
        }
      );
    }
    return this.updateShapes(s), this;
  }
  /**
   * Duplicate shapes.
   *
   * @example
   * ```ts
   * 	app.duplicateShapes()
   * 	app.duplicateShapes(['id1', 'id2'])
   * 	app.duplicateShapes(['id1', 'id2'], { x: 8, y: 8 })
   * ```
   *
   * @param ids - The ids of the shapes to duplicate. Defaults to the ids of the selected
   *   shapes.
   * @param offset - The offset (in pixels) to apply to the duplicated shapes.
   * @public
   */
  duplicateShapes(t = this.selectedIds, e) {
    if (t.length <= 0)
      return this;
    const n = new Set(t), r = [], a = [...t];
    for (; a.length > 0; ) {
      const f = a.pop();
      if (!f)
        break;
      r.push(f), this.getSortedChildIds(f).forEach((p) => a.push(p));
    }
    r.reverse();
    const s = new Map(r.map((f) => [f, this.createShapeId()])), c = Gt(
      r.map((f) => {
        const p = this.getShapeById(f);
        if (!p)
          return null;
        const g = s.get(f);
        let y = 0, v = 0;
        if (e && n.has(f)) {
          const j = this.getParentTransform(p), L = new O(e.x, e.y).rot(
            -De.Decompose(j).rotation
          );
          y = L.x, v = L.y;
        }
        const S = p.parentId ?? this.currentPageId, x = this.getSortedChildIds(S), _ = x.indexOf(p.id), T = x[_ + 1], I = T ? this.getShapeById(T) : null, D = I ? Fy(p.index, I.index) : Ru(p.index), N = {
          ...Cc(p),
          id: g,
          x: p.x + y,
          y: p.y + v,
          index: D
        };
        if (to.is(p) && to.is(N)) {
          if (p.props.start.type === "binding") {
            const j = s.get(p.props.start.boundShapeId);
            if (j)
              N.props.start.boundShapeId = j;
            else {
              const L = this.getPageBoundsById(p.props.start.boundShapeId), z = new O(
                p.props.start.normalizedAnchor.x * L.width + L.minX,
                p.props.start.normalizedAnchor.y * L.height + L.minY
              ), F = De.applyToPoint(
                De.Inverse(this.getTransform(N)),
                z
              );
              N.props.start = {
                type: "point",
                x: F.x + y,
                y: F.y + v
              };
            }
          }
          if (p.props.end.type === "binding") {
            const j = s.get(p.props.end.boundShapeId);
            if (j)
              N.props.end.boundShapeId = j;
            else {
              const L = this.getPageBoundsById(p.props.end.boundShapeId), z = new O(
                p.props.end.normalizedAnchor.x * L.width + L.minX,
                p.props.end.normalizedAnchor.y * L.height + L.minY
              ), F = De.applyToPoint(
                De.Inverse(this.getTransform(N)),
                z
              );
              N.props.end = {
                type: "point",
                x: F.x + y,
                y: F.y + v
              };
            }
          }
        }
        return N;
      })
    );
    return c.forEach((f) => {
      Us(f.parentId) && s.has(f.parentId) && (f.parentId = s.get(f.parentId));
    }), this.history.batch(() => {
      const f = c.length + this.shapeIds.size > yp;
      f && Uw(this);
      const p = f ? c.slice(0, yp - this.shapeIds.size) : c, g = p.map((y) => y.id);
      if (this.createShapes(p), this.setSelectedIds(g), e !== void 0) {
        const { viewportPageBounds: y, selectedPageBounds: v } = this;
        v && !y.contains(v) && this.centerOnPoint(v.center.x, v.center.y, {
          duration: $u
        });
      }
    }), this;
  }
  /**
   * Set the current props (generally styles).
   *
   * @example
   * ```ts
   * 	app.setProp('color', 'red')
   * 	app.setProp('color', 'red', true)
   * ```
   *
   * @param key - The key to set.
   * @param value - The value to set.
   * @param ephemeral - Whether the style is ephemeral. Defaults to false.
   * @public
   */
  setProp(t, e, n = !1, r = !1) {
    const a = [], s = (c) => {
      const f = this.getSortedChildIds(c);
      for (const p of f) {
        const g = this.getShapeById(p);
        g?.type === "group" && s(g.id), a.push(g);
      }
    };
    return this.history.batch(() => {
      if (this.updateInstanceState(
        {
          propsForNextShape: ZO(this.instanceState.propsForNextShape, {
            [t]: e
          })
        },
        n,
        r
      ), this.isIn("select")) {
        const {
          pageState: { selectedIds: c }
        } = this;
        if (c.length > 0) {
          const f = Gt(
            c.map((p) => {
              const g = this.getShapeById(p);
              if (g?.type === "group") {
                const y = this.getSortedChildIds(g.id);
                for (const v of y) {
                  const S = this.getShapeById(v);
                  S?.type === "group" && s(S.id), a.push(S);
                }
                return a;
              } else
                return g;
            })
          ).flat().filter(
            (p) => p.props[t] !== void 0 && p?.type !== "group"
          );
          if (this.updateShapes(
            f.map((p) => {
              const g = { ...p.props, [t]: e };
              return t === "color" && "labelColor" in g && (g.labelColor = "black"), {
                id: p.id,
                type: p.type,
                props: g
              };
            }),
            n
          ), t !== "color" && t !== "opacity") {
            const p = [];
            for (const g of f) {
              const y = this.getShapeById(g.id);
              if (!y)
                continue;
              const v = this.getShapeUtil(y), S = v.bounds(g), x = v.bounds(y), _ = { id: g.id, type: g.type };
              let T = !1;
              if (S.width !== x.width)
                if (T = !0, v1.is(g))
                  switch (g.props.align) {
                    case "middle": {
                      _.x = y.x + (S.width - x.width) / 2;
                      break;
                    }
                    case "end": {
                      _.x = y.x + S.width - x.width;
                      break;
                    }
                  }
                else
                  _.x = y.x + (S.width - x.width) / 2;
              S.height !== x.height && (T = !0, _.y = y.y + (S.height - x.height) / 2), T && p.push(_);
            }
            p.length && this.updateShapes(p, n);
          }
        }
      }
      this.updateInstanceState(
        {
          propsForNextShape: ZO(this.instanceState.propsForNextShape, {
            [t]: e
          })
        },
        n,
        r
      );
    }), this;
  }
  /** @internal */
  _willSetInitialBounds = !0;
  /** @internal */
  _setCamera(t, e, n = this.camera.z) {
    const r = this.camera;
    return r.x === t && r.y === e && r.z === n ? this : (this.store.put([{ ...r, x: t, y: e, z: n }]), this._cameraManager.tick(), this.emit("change-camera", this.camera), this);
  }
  /**
   * Set the current camera.
   *
   * @example
   * ```ts
   * 	app.setCamera(0, 0)
   * 	app.setCamera(0, 0, 1)
   * ```
   *
   * @param x - The camera's x position.
   * @param y - The camera's y position.
   * @param z - The camera's z position. Defaults to the current zoom.
   *
   * @public
   */
  setCamera(t, e, n = this.camera.z) {
    return this.stopCameraAnimation(), t = Number.isNaN(t) ? 0 : t, e = Number.isNaN(e) ? 0 : e, n = Number.isNaN(n) ? 1 : n, this._setCamera(t, e, n), this;
  }
  /**
   * Animate the camera.
   *
   * @example
   * ```ts
   * 	app.animateCamera(0, 0)
   * 	app.animateCamera(0, 0, 1)
   * 	app.animateCamera(0, 0, 1, { duration: 1000, easing: (t) => t * t })
   * ```
   *
   * @param x - The camera's x position.
   * @param y - The camera's y position.
   * @param z - The camera's z position. Defaults to the current zoom.
   * @param opts - Options for the animation.
   *
   * @public
   */
  animateCamera(t, e, n = this.camera.z, r = WO) {
    t = Number.isNaN(t) ? 0 : t, e = Number.isNaN(e) ? 0 : e, n = Number.isNaN(n) ? 1 : n;
    const { width: a, height: s } = this.viewportScreenBounds, c = a / n, f = s / n, p = new ot(-t, -e, c, f);
    return this._animateToViewport(p, r);
  }
  /**
   * Center the camera on a point (in page space).
   *
   * @example
   * ```ts
   * 	app.centerOnPoint(100, 100)
   * ```
   *
   * @param x - The x position of the point.
   * @param y - The y position of the point.
   * @param opts - The options for an animation.
   *
   * @public
   */
  centerOnPoint(t, e, n) {
    if (!this.canMoveCamera)
      return this;
    const {
      viewportPageBounds: { width: r, height: a },
      camera: s
    } = this;
    return n?.duration ? this.animateCamera(-(t - r / 2), -(e - a / 2), s.z, n) : this.setCamera(-(t - r / 2), -(e - a / 2), s.z), this;
  }
  /**
   * Zoom the camera to fit the current page's content in the viewport.
   *
   * @example
   * ```ts
   * 	app.zoomToFit()
   * ```
   *
   * @public
   */
  zoomToFit(t) {
    if (!this.canMoveCamera)
      return this;
    const e = [...this.shapeIds];
    if (e.length <= 0)
      return this;
    const n = ot.Common(Gt(e.map((r) => this.getPageBoundsById(r))));
    return this.zoomToBounds(
      n.minX,
      n.minY,
      n.width,
      n.height,
      void 0,
      t
    ), this;
  }
  /**
   * Set the zoom back to 100%.
   *
   * @example
   * ```ts
   * 	app.resetZoom()
   * ```
   *
   * @param opts - The options for an animation.
   * @public
   */
  resetZoom(t = this.viewportScreenCenter, e) {
    if (!this.canMoveCamera)
      return this;
    const { x: n, y: r, z: a } = this.camera, { x: s, y: c } = t;
    return e?.duration ? this.animateCamera(n + (s / 1 - s) - (s / a - s), r + (c / 1 - c) - (c / a - c), 1, e) : this.setCamera(n + (s / 1 - s) - (s / a - s), r + (c / 1 - c) - (c / a - c), 1), this;
  }
  /**
   * Zoom the camera in.
   *
   * @example
   * ```ts
   * 	app.zoomIn()
   * 	app.zoomIn(app.viewportScreenCenter, { duration: 120 })
   * 	app.zoomIn(app.inputs.currentScreenPoint, { duration: 120 })
   * ```
   *
   * @param opts - The options for an animation.
   * @public
   */
  zoomIn(t = this.viewportScreenCenter, e) {
    if (!this.canMoveCamera)
      return this;
    const { x: n, y: r, z: a } = this.camera;
    let s = Cp;
    for (let p = 1; p < Pg.length; p++) {
      const g = Pg[p - 1], y = Pg[p];
      if (!(y - a <= (y - g) / 2)) {
        s = y;
        break;
      }
    }
    const { x: c, y: f } = t;
    return e?.duration ? this.animateCamera(
      n + (c / s - c) - (c / a - c),
      r + (f / s - f) - (f / a - f),
      s,
      e
    ) : this.setCamera(n + (c / s - c) - (c / a - c), r + (f / s - f) - (f / a - f), s), this;
  }
  /**
   * Zoom the camera out.
   *
   * @example
   * ```ts
   * 	app.zoomOut()
   * 	app.zoomOut(app.viewportScreenCenter, { duration: 120 })
   * 	app.zoomOut(app.inputs.currentScreenPoint, { duration: 120 })
   * ```
   *
   * @param opts - The options for an animation.
   * @public
   */
  zoomOut(t = this.viewportScreenCenter, e) {
    if (!this.canMoveCamera)
      return this;
    const { x: n, y: r, z: a } = this.camera;
    let s = Ow;
    for (let p = Pg.length - 1; p > 0; p--) {
      const g = Pg[p - 1], y = Pg[p];
      if (!(y - a >= (y - g) / 2)) {
        s = g;
        break;
      }
    }
    const { x: c, y: f } = t;
    return e?.duration ? this.animateCamera(
      n + (c / s - c) - (c / a - c),
      r + (f / s - f) - (f / a - f),
      s,
      e
    ) : this.setCamera(n + (c / s - c) - (c / a - c), r + (f / s - f) - (f / a - f), s), this;
  }
  /**
   * Zoom the camera to fit the current selection in the viewport.
   *
   * @example
   * ```ts
   * 	app.zoomToSelection()
   * ```
   *
   * @param opts - The options for an animation.
   * @public
   */
  zoomToSelection(t) {
    if (!this.canMoveCamera)
      return this;
    const e = this.selectedIds;
    if (e.length <= 0)
      return this;
    const n = ot.Common(Gt(e.map((r) => this.getPageBoundsById(r))));
    return this.zoomToBounds(
      n.minX,
      n.minY,
      n.width,
      n.height,
      Math.max(1, this.camera.z),
      t
    ), this;
  }
  /**
   * Pan or pan/zoom the selected ids into view. This method tries to not
   * change the zoom if possible.
   *
   * @param ids - The ids of the shapes to pan and zoom into view.
   * @param opts - The options for an animation.
   * @public
   */
  panZoomIntoView(t, e) {
    if (!this.canMoveCamera)
      return this;
    if (t.length <= 0)
      return this;
    const n = ot.Common(Gt(t.map((a) => this.getPageBoundsById(a)))), { viewportPageBounds: r } = this;
    if (r.h < n.h || r.w < n.w)
      return this.zoomToBounds(
        n.minX,
        n.minY,
        n.width,
        n.height,
        this.camera.z,
        e
      ), this;
    {
      const a = this._activeAreaManager.offsets.value, s = r.y + a.top, c = r.maxY - a.right, f = r.maxY - a.bottom, p = r.x + a.left, g = n.y, y = n.maxX, v = n.maxY, S = n.x;
      let x = 0, _ = 0;
      f < v ? _ = f - v : s > g && (_ = s - g), c < y ? x = c - y : p > S && (x = p - S);
      const { camera: T } = this;
      e?.duration ? this.animateCamera(T.x + x, T.y + _, T.z, e) : this.setCamera(T.x + x, T.y + _, T.z);
    }
    return this;
  }
  /**
   * Zoom the camera to fit a bounding box (in page space).
   *
   * @example
   * ```ts
   * 	app.zoomToBounds(0, 0, 100, 100)
   * ```
   *
   * @param x - The bounding box's x position.
   * @param y - The bounding box's y position.
   * @param width - The bounding box's width.
   * @param height - The bounding box's height.
   * @param targetZoom - The desired zoom level. Defaults to 0.1.
   * @public
   */
  zoomToBounds(t, e, n, r, a, s) {
    if (!this.canMoveCamera)
      return this;
    const { viewportScreenBounds: c } = this, f = Math.min(256, c.width * 0.28);
    let p = Iu(
      Math.min(
        (c.width - f) / n,
        (c.height - f) / r
      ),
      Ow,
      Cp
    );
    return a !== void 0 && (p = Math.min(a, p)), s?.duration ? this.animateCamera(
      -t + (c.width - n * p) / 2 / p,
      -e + (c.height - r * p) / 2 / p,
      p,
      s
    ) : this.setCamera(
      -t + (c.width - n * p) / 2 / p,
      -e + (c.height - r * p) / 2 / p,
      p
    ), this;
  }
  /**
   * Pan the camera.
   *
   * @example
   * ```ts
   * 	app.pan(100, 100)
   * 	app.pan(100, 100, {duration: 1000})
   * ```
   *
   * @param dx - The amount to pan on the x axis.
   * @param dy - The amount to pan on the y axis.
   * @param opts - the animation options
   */
  pan(t, e, n) {
    if (!this.canMoveCamera)
      return this;
    const { camera: r } = this, { x: a, y: s, z: c } = r, f = new O(t, e).div(c);
    return n?.duration ?? 0 > 0 ? this.animateCamera(a + f.x, s + f.y, c, n) : (this.setCamera(a + f.x, s + f.y, c), this);
  }
  /**
   * Stop the current camera animation, if any.
   *
   * @public
   */
  stopCameraAnimation() {
    return this.emit("stop-camera-animation"), this;
  }
  /** @internal */
  _viewportAnimation = null;
  /** @internal */
  _animateViewport(t) {
    if (!this._viewportAnimation)
      return;
    const e = () => {
      this.removeListener("tick", this._animateViewport), this.removeListener("stop-camera-animation", e);
    };
    this.once("stop-camera-animation", e), this._viewportAnimation.elapsed += t;
    const { elapsed: n, easing: r, duration: a, start: s, end: c } = this._viewportAnimation;
    if (n > a) {
      const D = this.viewportScreenBounds.width / c.width, N = -c.x, j = -c.y;
      this._setCamera(N, j, D), this.removeListener("tick", this._animateViewport), this._viewportAnimation = null;
      return;
    }
    const f = a - n, p = r(1 - f / a), g = s.minX + (c.minX - s.minX) * p, y = s.minY + (c.minY - s.minY) * p, v = s.maxX + (c.maxX - s.maxX) * p, S = s.maxY + (c.maxY - s.maxY) * p, x = new ot(g, y, v - g, S - y), _ = this.viewportScreenBounds.width / x.width, T = -x.x, I = -x.y;
    this._setCamera(T, I, _);
  }
  /** @internal */
  _animateToViewport(t, e = {}) {
    const { duration: n = 0, easing: r = ua.easeInOutCubic } = e, a = this.viewportPageBounds.clone();
    return this.stopCameraAnimation(), this._viewportAnimation = {
      elapsed: 0,
      duration: n,
      easing: r,
      start: a,
      end: t
    }, this.addListener("tick", this._animateViewport), this;
  }
  slideCamera(t = {}) {
    if (!this.canMoveCamera)
      return this;
    const { speed: e, direction: n, friction: r, speedThreshold: a = 0.01 } = t;
    let s = e;
    this.stopCameraAnimation();
    const c = () => {
      this.removeListener("tick", f), this.removeListener("stop-camera-animation", c);
    };
    this.once("stop-camera-animation", c);
    const f = (p) => {
      const { x: g, y, z: v } = this.camera, S = n.clone().mul(s * p / v);
      s *= 1 - r, s < a ? c() : this._setCamera(g + S.x, y + S.y, v);
    };
    return this.addListener("tick", f), this;
  }
  animateToShape(t, e = WO) {
    if (!this.canMoveCamera)
      return this;
    const n = Ij(this), r = n.width / n.height, a = this.getPageBoundsById(t);
    if (!a)
      return this;
    const s = a.width / a.height, c = a.clone(), f = a.width / n.width;
    return c.width += (n.left + n.right) * f, c.height += (n.top + n.bottom) * f, c.x -= n.left * f, c.y -= n.top * f, s > r ? (c.height = a.width / r, c.y -= (c.height - a.height) / 2) : (c.width = a.height * r, c.x -= (c.width - a.width) / 2), this._animateToViewport(c, e);
  }
  /**
   * Blur the app, cancelling any interaction state.
   *
   * @example
   * ```ts
   * 	app.blur()
   * ```
   *
   * @public
   */
  blur() {
    return this.dispatch({ type: "misc", name: "blur" }), this;
  }
  /**
   * Dispatch a cancel event.
   *
   * @example
   * ```ts
   * 	app.cancel()
   * ```
   *
   * @public
   */
  cancel() {
    return this.dispatch({ type: "misc", name: "cancel" }), this;
  }
  /**
   * Dispatch an interrupt event.
   *
   * @example
   * ```ts
   * 	app.interrupt()
   * ```
   *
   * @public
   */
  interrupt() {
    return this.dispatch({ type: "misc", name: "interrupt" }), this;
  }
  /**
   * Dispatch a complete event.
   *
   * @example
   * ```ts
   * 	app.complete()
   * ```
   *
   * @public
   */
  complete() {
    return this.dispatch({ type: "misc", name: "complete" }), this;
  }
  /* -------------------- Callbacks ------------------- */
  /**
   * A callback fired when a file is converted to an asset. This callback should return the asset partial.
   *
   * @example
   * ```ts
   * 	app.onCreateAssetFromFile(myFile)
   * ```
   *
   * @param file - The file to upload.
   * @public
   */
  async onCreateAssetFromFile(t) {
    return await gZ(t);
  }
  /**
   * A callback fired when a URL is converted to a bookmark. This callback should return the
   * metadata for the bookmark.
   *
   * @example
   * ```ts
   * 	app.onCreateBookmarkFromUrl(url, id)
   * ```
   *
   * @param url - The url that was created.
   * @public
   */
  async onCreateBookmarkFromUrl(t) {
    try {
      const n = await (await fetch(t, { method: "GET", mode: "no-cors" })).text(), r = new DOMParser().parseFromString(n, "text/html");
      return {
        image: r.head.querySelector('meta[property="og:image"]')?.getAttribute("content") ?? "",
        title: r.head.querySelector('meta[property="og:title"]')?.getAttribute("content") ?? "",
        description: r.head.querySelector('meta[property="og:description"]')?.getAttribute("content") ?? ""
      };
    } catch (e) {
      return console.error(e), { image: "", title: "", description: "" };
    }
  }
  /* ---------------- Text Measurement ---------------- */
  /**
   * A helper for measuring text.
   *
   * @public
   */
  textMeasure;
  /* --------------------- Groups --------------------- */
  groupShapes(t = this.selectedIds, e = no()) {
    if (this.isReadOnly)
      return this;
    if (t.length <= 1)
      return this;
    const n = Gt(t.map((y) => this.getShapeById(y))), r = n.sort(Ha).map((y) => y.id), a = ot.Common(Gt(n.map((y) => this.getPageBounds(y)))), { x: s, y: c } = a.point, f = this.findCommonAncestor(n) ?? this.currentPageId;
    if (this.currentToolId !== "select")
      return this;
    this.isIn("select.idle") || this.cancel();
    const p = n.filter((y) => y.parentId === f).sort(Ha), g = p[p.length - 1]?.index;
    return this.batch(() => {
      this.createShapes([
        {
          id: e,
          type: "group",
          parentId: f,
          index: g,
          x: s,
          y: c,
          props: {
            opacity: "1"
          }
        }
      ]), this.reparentShapesById(r, e), this.select(e);
    }), this;
  }
  ungroupShapes(t = this.selectedIds) {
    if (this.isReadOnly)
      return this;
    if (t.length === 0)
      return this;
    if (this.currentToolId !== "select")
      return this;
    this.isIn("select.idle") || this.cancel();
    const e = /* @__PURE__ */ new Set(), n = Gt(t.map((a) => this.getShapeById(a))), r = [];
    return n.forEach((a) => {
      xj.is(a) ? r.push(a) : e.add(a.id);
    }), r.length === 0 ? this : (this.batch(() => {
      let a;
      for (let s = 0, c = r.length; s < c; s++) {
        a = r[s];
        const f = this.getSortedChildIds(a.id);
        for (let p = 0, g = f.length; p < g; p++)
          e.add(f[p]);
        this.reparentShapesById(f, a.parentId, a.index);
      }
      this.deleteShapes(r.map((s) => s.id)), this.select(...e);
    }), this);
  }
};
let en = $j;
ln([
  pt
], en.prototype, "canMoveCamera", 1);
ln([
  pt
], en.prototype, "_pageTransformCache", 1);
ln([
  pt
], en.prototype, "_pageBoundsCache", 1);
ln([
  pt
], en.prototype, "_pageMaskCache", 1);
ln([
  pt
], en.prototype, "_clipPathCache", 1);
ln([
  pt
], en.prototype, "canUndo", 1);
ln([
  pt
], en.prototype, "canRedo", 1);
ln([
  pt
], en.prototype, "erasingIds", 1);
ln([
  pt
], en.prototype, "hintingIds", 1);
ln([
  pt
], en.prototype, "erasingIdsSet", 1);
ln([
  pt
], en.prototype, "allowUiPaste", 1);
ln([
  pt
], en.prototype, "props", 1);
ln([
  pt
], en.prototype, "_arrowBindingsIndex", 1);
ln([
  pt
], en.prototype, "documentSettings", 1);
ln([
  pt
], en.prototype, "_userDocumentSettings", 1);
ln([
  pt
], en.prototype, "_pageState", 1);
ln([
  pt
], en.prototype, "camera", 1);
ln([
  pt
], en.prototype, "zoomLevel", 1);
ln([
  pt
], en.prototype, "selectedIds", 1);
ln([
  pt
], en.prototype, "selectedIdsSet", 1);
ln([
  pt
], en.prototype, "_pages", 1);
ln([
  pt
], en.prototype, "pages", 1);
ln([
  pt
], en.prototype, "_pageStates", 1);
ln([
  pt
], en.prototype, "renderingShapes", 1);
ln([
  pt
], en.prototype, "allShapesCommonBounds", 1);
ln([
  pt
], en.prototype, "viewportScreenBounds", 1);
ln([
  pt
], en.prototype, "viewportScreenCenter", 1);
ln([
  pt
], en.prototype, "viewportPageBounds", 1);
ln([
  pt
], en.prototype, "cullingBounds", 1);
ln([
  pt
], en.prototype, "cullingBoundsExpanded", 1);
ln([
  pt
], en.prototype, "viewportPageCenter", 1);
ln([
  pt
], en.prototype, "editingShape", 1);
ln([
  pt
], en.prototype, "selectedPageBounds", 1);
ln([
  pt
], en.prototype, "selectionRotation", 1);
ln([
  pt
], en.prototype, "selectionBounds", 1);
ln([
  pt
], en.prototype, "selectionPageCenter", 1);
ln([
  pt
], en.prototype, "shapesArray", 1);
ln([
  pt
], en.prototype, "sortedShapesArray", 1);
ln([
  pt
], en.prototype, "selectedShapes", 1);
ln([
  pt
], en.prototype, "onlySelectedShape", 1);
ln([
  pt
], en.prototype, "_currentUserPresence", 1);
ln([
  pt
], en.prototype, "_assets", 1);
ln([
  pt
], en.prototype, "hoveredId", 1);
ln([
  pt
], en.prototype, "hoveredShape", 1);
function Uw(t, e = t.currentPageId) {
  const n = t.getPageById(e).name;
  t.emit("max-shapes", { name: n, pageId: e, count: yp });
}
const Mj = {
  fonts: {
    draw: "/fonts/Shantell_Sans-Normal-SemiBold.woff2",
    serif: "/fonts/IBMPlexSerif-Medium.woff2",
    sansSerif: "/fonts/IBMPlexSans-Medium.woff2",
    monospace: "/fonts/IBMPlexMono-Medium.woff2"
  }
}, ore = { error: null };
class Pb extends k.Component {
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  state = ore;
  componentDidCatch(e) {
    this.props.onError?.(e);
  }
  render() {
    const { error: e } = this.state;
    return e !== null ? this.props.fallback(e) : this.props.children;
  }
}
var Aj = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(t) {
  (function() {
    var e = {}.hasOwnProperty;
    function n() {
      for (var r = [], a = 0; a < arguments.length; a++) {
        var s = arguments[a];
        if (s) {
          var c = typeof s;
          if (c === "string" || c === "number")
            r.push(s);
          else if (Array.isArray(s)) {
            if (s.length) {
              var f = n.apply(null, s);
              f && r.push(f);
            }
          } else if (c === "object") {
            if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) {
              r.push(s.toString());
              continue;
            }
            for (var p in s)
              e.call(s, p) && s[p] && r.push(p);
          }
        }
      }
      return r.join(" ");
    }
    t.exports ? (n.default = n, t.exports = n) : window.classNames = n;
  })();
})(Aj);
var are = Aj.exports;
const $n = /* @__PURE__ */ Np(are), sre = dn(function() {
  const e = Ge(), n = e.brush, r = e.isIn("select.brushing");
  return !n || !r ? null : /* @__PURE__ */ E.jsx(
    "rect",
    {
      className: "rs-brush",
      width: ze(Math.max(1, n.w)),
      height: ze(Math.max(1, n.h)),
      transform: `translate(${n.x},${n.y})`
    }
  );
}), lre = dn(function({ size: e }) {
  const n = Ge(), { x: r, y: a, z: s } = n.camera;
  return n.isGridMode ? /* @__PURE__ */ E.jsxs("svg", { className: "tl-grid", version: "1.1", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ E.jsx("defs", { children: GO.map(({ min: f, mid: p, step: g }, y) => /* @__PURE__ */ E.jsx(
      cre,
      {
        min: f,
        mid: p,
        step: g,
        x: r,
        y: a,
        z: s,
        size: e
      },
      `grid-layer-${y}`
    )) }),
    GO.map(({ step: f }, p) => /* @__PURE__ */ E.jsx("rect", { width: "100%", height: "100%", fill: `url(#grid-${f})` }, `grid-rect-${p}`))
  ] }) : null;
});
function cre({
  step: t,
  min: e,
  mid: n,
  size: r,
  x: a,
  y: s,
  z: c
}) {
  const f = t * r * c, p = 0.5 + a * c, g = 0.5 + s * c, y = p > 0 ? p % f : f + p % f, v = g > 0 ? g % f : f + g % f, S = c < n ? Jk(c, [e, n], [0, 1]) : 1;
  return /* @__PURE__ */ E.jsx(
    "pattern",
    {
      id: `grid-${t}`,
      width: f,
      height: f,
      patternUnits: "userSpaceOnUse",
      children: /* @__PURE__ */ E.jsx("circle", { className: "tl-grid-dot", cx: y, cy: v, r: 1, opacity: S })
    },
    `grid-pattern-${t}`
  );
}
function ure({ id: t, handle: e }) {
  const n = eee(t, e.id), { x: r, y: a, type: s } = e;
  return /* @__PURE__ */ E.jsxs(
    "g",
    {
      className: $n("rs-handle", { "rs-handle-hint": s !== "vertex" }),
      "aria-label": "handle",
      transform: `translate(${r}, ${a})`,
      ...n,
      children: [
        /* @__PURE__ */ E.jsx("circle", { className: "rs-handle-bg" }),
        /* @__PURE__ */ E.jsx("circle", { className: "rs-handle-fg" })
      ]
    }
  );
}
const dre = 48, fre = dn(function() {
  const e = Ge(), n = e.zoomLevel, r = e.isChangingStyle, a = e.onlySelectedShape, s = e.isInAny("select.idle", "select.pointing_handle") && !r && !e.isReadOnly;
  if (!(a && s))
    return null;
  const f = e.getShapeUtil(a).handles?.(a);
  if (!f)
    return null;
  const p = e.getPageTransform(a);
  if (!p)
    return null;
  const g = [];
  for (let y = 0, v = f[y]; y < f.length; y++, v = f[y]) {
    if (v.type !== "vertex") {
      const S = f[y - 1], x = f[y + 1];
      if (S && x && Math.hypot(S.y - x.y, S.x - x.x) < dre / n)
        continue;
    }
    g.push(v);
  }
  return g.sort((y) => y.type === "vertex" ? 1 : -1), /* @__PURE__ */ E.jsx("g", { transform: De.toCssString(p), children: g.map((y) => /* @__PURE__ */ E.jsx(ure, { id: a.id, handle: y }, y.id)) });
}), pre = ({ zoom: t, point: e, color: n }) => e ? /* @__PURE__ */ E.jsx(
  "use",
  {
    href: "#cursor",
    transform: `translate(${e.x}, ${e.y}) scale(${1 / t})`,
    color: n
  }
) : null, hre = k.memo(pre), gre = ({ zoom: t, point: e, color: n, viewport: r }) => {
  const a = Iu(e.x, r.minX + 5 / t, r.maxX - 5 / t), s = Iu(e.y, r.minY + 5 / t, r.maxY - 5 / t), c = kL(O.Angle(r.center, e));
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: /* @__PURE__ */ E.jsx(
    "use",
    {
      href: "#cursor_hint",
      transform: `translate(${a}, ${s}) scale(${1 / t}) rotate(${c})`,
      color: n
    }
  ) });
};
class mre {
  constructor(e) {
    this.shape = e;
  }
  equals(e) {
    return this.shape?.props === e?.shape?.props;
  }
}
const vre = ({ shape: t, util: e }) => II("Indicator:", () => e.indicator(t)), yre = ({ app: t, id: e }) => {
  const n = un("shape", () => new mre(t.store.get(e)), [t, e]);
  return n.shape ? /* @__PURE__ */ E.jsx(
    Pb,
    {
      fallback: bre,
      onError: (r) => t.annotateError(r, { origin: "react.shapeIndicator", willCrashApp: !1 }),
      children: /* @__PURE__ */ E.jsx(vre, { shape: n.shape, util: t.getShapeUtil(n.shape) })
    }
  ) : null;
};
function bre() {
  return /* @__PURE__ */ E.jsx("circle", { cx: 4, cy: 4, r: 8, strokeWidth: "1", stroke: "red" });
}
const b1 = k.memo(function({
  id: e,
  isHinting: n,
  color: r
}) {
  const a = Ge(), s = un(
    "transform",
    () => {
      const c = a.getPageTransformById(e);
      return c ? De.toCssString(c) : "";
    },
    [a, e]
  );
  return /* @__PURE__ */ E.jsx(
    "g",
    {
      className: $n("rs-shape-indicator", {
        "rs-shape-indicator__hinting": n
      }),
      transform: s,
      stroke: r ?? "var(--color-selected)",
      children: /* @__PURE__ */ E.jsx(yre, { app: a, id: e })
    }
  );
}), Sre = () => {
  const t = Ge(), e = OL("time", Date.now());
  return It.useEffect(() => {
    const n = setInterval(() => e.set(Date.now()), 5e3);
    return () => clearInterval(n);
  }, [e]), k.useMemo(
    () => t.store.query.records("user_presence", () => ({
      lastActivityTimestamp: { gt: e.value - xre },
      userId: { neq: t.userId }
    })),
    [t, e]
  );
}, wre = dn(function() {
  const e = Ge(), { viewportPageBounds: n, zoomLevel: r } = e, a = Sre();
  return /* @__PURE__ */ E.jsx("g", { children: a.value.map((s) => /* @__PURE__ */ E.jsx(
    Ere,
    {
      presence: s,
      viewport: n,
      zoom: r
    },
    s.id
  )) });
}), xre = 1e3 * 10, Ere = dn(function({
  presence: e,
  viewport: n,
  zoom: r
}) {
  const a = Ge(), { userId: s, color: c, cursor: f, lastUsedInstanceId: p } = e, g = k.useMemo(
    () => p ? a.store.query.record("instance_page_state", () => ({
      instanceId: { eq: p },
      pageId: { eq: a.currentPageId }
    })) : null,
    [a, p]
  );
  if (!p || !g)
    return null;
  const y = a.store.get(p);
  if (!y || y.currentPageId !== a.currentPageId || !g.value)
    return null;
  const { brush: v, scribble: S } = y, { selectedIds: x } = g.value, _ = !(f.x < n.minX - 12 / r || f.y < n.minY - 16 / r || f.x > n.maxX - 12 / r || f.y > n.maxY - 16 / r);
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    v ? /* @__PURE__ */ E.jsxs(
      "g",
      {
        className: "rs-collaborator-brush",
        transform: `translate(${v.x},${v.y})`,
        children: [
          /* @__PURE__ */ E.jsx(
            "rect",
            {
              width: ze(Math.max(1, v.w)),
              height: ze(Math.max(1, v.h)),
              fill: c,
              opacity: 0.1
            }
          ),
          /* @__PURE__ */ E.jsx(
            "rect",
            {
              width: ze(Math.max(1, v.w)),
              height: ze(Math.max(1, v.h)),
              fill: "none",
              stroke: c,
              opacity: 0.1
            }
          )
        ]
      },
      s + "_brush"
    ) : null,
    _ ? /* @__PURE__ */ E.jsx(hre, { point: f, color: c, zoom: r }, s + "_cursor") : /* @__PURE__ */ E.jsx(
      gre,
      {
        point: f,
        color: c,
        zoom: r,
        viewport: n
      },
      s + "_cursor_hint"
    ),
    S ? /* @__PURE__ */ E.jsx(
      Cre,
      {
        scribble: S,
        color: c,
        zoom: r
      },
      s + "_scribble"
    ) : null,
    x.map((T) => /* @__PURE__ */ E.jsx(b1, { id: T, color: c }, s + "_" + T))
  ] });
});
function Cre({
  scribble: t,
  color: e,
  zoom: n
}) {
  if (!t)
    return null;
  const r = ot.FromPoints(t.points), a = Jd(
    u1(t.points, {
      size: t.size / n,
      start: { taper: !0 },
      last: t.state === "stopping" || r.width < 128 && r.height < 128
    })
  );
  return /* @__PURE__ */ E.jsx("path", { className: "tl-scribble", d: a, fill: e, opacity: 0.1 });
}
const _re = dn(function() {
  const e = Ge(), n = e.scribble, r = e.zoomLevel;
  if (!n)
    return null;
  const a = Jd(
    u1(n.points, {
      size: n.size / r,
      start: { taper: !0, easing: ua.linear },
      last: !1,
      simulatePressure: !1
    })
  );
  return /* @__PURE__ */ E.jsx(
    "path",
    {
      className: "tl-scribble",
      d: a,
      fill: `var(--color-${n.color})`,
      opacity: n.opacity
    }
  );
}), Tre = dn(function() {
  const e = Ge(), n = k.useMemo(() => ({
    onPointerDown: (S) => {
      if (S.isKilled)
        return;
      wb(S.currentTarget, S);
      const x = {
        type: "pointer",
        target: "selection",
        name: "pointer_down",
        ...Vi(S, e.getContainer())
      };
      e.dispatch(x);
    },
    onPointerMove: (S) => {
      if (S.isKilled)
        return;
      const x = {
        type: "pointer",
        target: "selection",
        name: "pointer_move",
        ...Vi(S, e.getContainer())
      };
      e.dispatch(x);
    },
    onPointerUp: (S) => {
      if (S.isKilled)
        return;
      xb(S.currentTarget, S);
      const x = {
        type: "pointer",
        target: "selection",
        name: "pointer_up",
        ...Vi(S, e.getContainer())
      };
      e.dispatch(x);
    },
    onPointerEnter: (S) => {
      if (S.isKilled)
        return;
      const x = {
        type: "pointer",
        target: "selection",
        name: "pointer_enter",
        ...Vi(S, e.getContainer())
      };
      e.dispatch(x);
    },
    onPointerLeave: (S) => {
      if (S.isKilled)
        return;
      const x = {
        type: "pointer",
        target: "selection",
        name: "pointer_leave",
        ...Vi(S, e.getContainer())
      };
      e.dispatch(x);
    }
  }), [e]), { selectionBounds: r, selectedIds: a } = e;
  if (!r)
    return null;
  const s = e.isInAny(
    "select.idle",
    "select.brushing",
    "select.scribble_brushing",
    "select.pointing_shape",
    "select.pointing_selection",
    "text.resizing"
  );
  if (a.length === 1) {
    const f = e.getShapeById(a[0]);
    if (!f || e.getShapeUtil(f).hideSelectionBoundsBg(f))
      return null;
  }
  const c = De.toCssString(
    De.Compose(
      De.Translate(r.minX, r.minY),
      De.Rotate(e.selectionRotation)
    )
  );
  return /* @__PURE__ */ E.jsx(
    "div",
    {
      className: "tlui-selection__bg",
      draggable: !1,
      style: {
        transform: c,
        width: ze(Math.max(1, r.width)),
        height: ze(Math.max(1, r.height)),
        pointerEvents: s ? "all" : "none",
        opacity: s ? 1 : 0
      },
      ...n
    }
  );
});
function wc(t) {
  const e = Ge();
  return k.useMemo(
    function() {
      const a = (g) => {
        if (g.isKilled || g.button !== 0)
          return;
        const y = Ax(g.currentTarget);
        function v() {
          y.removeEventListener("pointerup", v), xb(y, g);
        }
        wb(y, g), y.addEventListener("pointerup", v), e.dispatch({
          name: "pointer_down",
          type: "pointer",
          target: "selection",
          handle: t,
          ...Vi(g, e.getContainer())
        }), g.stopPropagation();
      };
      let s, c;
      function f(g) {
        g.isKilled || g.button === 0 && (g.clientX === s && g.clientY === c || (s = g.clientX, c = g.clientY, e.dispatch({
          name: "pointer_move",
          type: "pointer",
          target: "selection",
          handle: t,
          ...Vi(g, e.getContainer())
        })));
      }
      return {
        onPointerDown: a,
        onPointerMove: f,
        onPointerUp: (g) => {
          g.isKilled || g.button === 0 && e.dispatch({
            name: "pointer_up",
            type: "pointer",
            target: "selection",
            handle: t,
            ...Vi(g, e.getContainer())
          });
        }
      };
    },
    [e, t]
  );
}
const kre = Math.sqrt(Math.PI), Pre = function({
  cx: e,
  cy: n,
  size: r,
  isHidden: a,
  "data-wd": s
}) {
  const c = wc("mobile_rotate");
  return /* @__PURE__ */ E.jsxs("g", { children: [
    /* @__PURE__ */ E.jsx(
      "circle",
      {
        "data-wd": s,
        className: $n("rs-transparent", "rs-mobile-rotate__bg", { "rs-hidden": a }),
        cx: e,
        cy: n,
        ...c
      }
    ),
    /* @__PURE__ */ E.jsx(
      "circle",
      {
        className: $n("rs-mobile-rotate__fg", { "rs-hidden": a }),
        cx: e,
        cy: n,
        r: r / kre
      }
    )
  ] });
}, Bw = function({
  cx: e,
  cy: n,
  targetSize: r,
  corner: a,
  cursor: s,
  isHidden: c,
  "data-wd": f
}) {
  const p = wc(a);
  return /* @__PURE__ */ E.jsx(
    "rect",
    {
      className: $n("rs-transparent", "rs-rotate-corner", { "rs-hidden": c }),
      "data-wd": f,
      "aria-label": `${a} target`,
      x: ze(e - r * 3),
      y: ze(n - r * 3),
      width: ze(Math.max(1, r * 3)),
      height: ze(Math.max(1, r * 3)),
      cursor: s,
      ...p
    }
  );
}, Ire = dn(function() {
  const e = Ge(), n = un("isReadOnlyMode", () => e.isReadOnly, [e]), r = wc("top"), a = wc("right"), s = wc("bottom"), c = wc("left"), f = wc("top_left"), p = wc("top_right"), g = wc("bottom_right"), y = wc("bottom_left"), v = !e.isMenuOpen && e.cursor.type === "default", S = e.isCoarsePointer, x = e.selectionBounds;
  if (!x)
    return null;
  const _ = e.selectedShapes, T = e.selectionRotation, I = e.isChangingStyle, D = Math.max(1, x.width), N = Math.max(1, x.height), j = e.zoomLevel, L = 8 / j, z = D < L * 2, F = N < L * 2, K = D < L * 4, X = N < L * 4, se = S ? 1.75 : 1, ue = 6 / j * se, pe = (K ? ue / 2 : ue) * (se * 0.75), Pe = (X ? ue / 2 : ue) * (se * 0.75), ve = De.toCssString(
    De.Compose(
      De.Translate(x.minX, x.minY),
      De.Rotate(e.selectionRotation)
    )
  ), Y = _.length === 1 ? _[0] : null, le = (Y ? !e.getShapeUtil(Y).hideSelectionBoundsFg(Y) : !0) && !I, Re = (e.isInAny(
    "select.idle",
    "select.brushing",
    "select.editing_shape",
    "select.scribble_brushing",
    "select.pointing_canvas",
    "select.pointing_selection",
    "select.pointing_shape"
  ) || e.isIn("select.resizing") && Y && _[0].type === "text" || e.isIn("select") && e.inputs.ctrlKey) && le, he = e.isInAny(
    "select.idle",
    "select.pointing_selection",
    "select.pointing_shape",
    "select.pointing_selection"
  ) && !I && !n, te = !S && !(z || F) && he && (Y ? !e.getShapeUtil(Y).hideRotateHandle(Y) : !0), de = S && (!K || !X) && he && (Y ? !e.getShapeUtil(Y).hideRotateHandle(Y) : !0), W = he && (Y ? e.getShapeUtil(Y).canResize(Y) && !e.getShapeUtil(Y).hideResizeHandles(Y) : !0), fe = z || F, ce = z && F, xe = !he || !te, $e = !he || !de, Me = !he || !W, re = !he || !W || fe, Qe = !he || !W || fe, ke = !he || !W || ce;
  let rt = S;
  rt && _.every((Tt) => e.getShapeUtil(Tt).isAspectRatioLocked(Tt)) && (rt = !1);
  const St = !he || !W || fe || ce || rt;
  return /* @__PURE__ */ E.jsxs("g", { transform: ve, children: [
    Re && /* @__PURE__ */ E.jsx(
      "rect",
      {
        className: "tlui-selection__fg-outline",
        width: ze(D),
        height: ze(N)
      }
    ),
    /* @__PURE__ */ E.jsxs("g", { children: [
      /* @__PURE__ */ E.jsx("g", { pointerEvents: "all", children: /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
        /* @__PURE__ */ E.jsx(
          Bw,
          {
            "data-wd": "selection.rotate.top-left",
            cx: 0,
            cy: 0,
            targetSize: ue,
            corner: "top_left_rotate",
            cursor: v ? ss("nwse-rotate", T) : void 0,
            isHidden: xe
          }
        ),
        /* @__PURE__ */ E.jsx(
          Bw,
          {
            "data-wd": "selection.rotate.top-right",
            cx: D + ue * 3,
            cy: 0,
            targetSize: ue,
            corner: "top_right_rotate",
            cursor: v ? ss("nesw-rotate", T) : void 0,
            isHidden: xe
          }
        ),
        /* @__PURE__ */ E.jsx(
          Bw,
          {
            "data-wd": "selection.rotate.bottom-left",
            cx: 0,
            cy: N + ue * 3,
            targetSize: ue,
            corner: "bottom_left_rotate",
            cursor: v ? ss("swne-rotate", T) : void 0,
            isHidden: xe
          }
        ),
        /* @__PURE__ */ E.jsx(
          Bw,
          {
            "data-wd": "selection.rotate.bottom-right",
            cx: D + ue * 3,
            cy: N + ue * 3,
            targetSize: ue,
            corner: "bottom_right_rotate",
            cursor: v ? ss("senw-rotate", T) : void 0,
            isHidden: xe
          }
        )
      ] }) }),
      /* @__PURE__ */ E.jsx(
        Pre,
        {
          "data-wd": "selection.rotate.mobile",
          cx: K ? -ue * 1.5 : D / 2,
          cy: K ? N / 2 : -ue * 1.5,
          size: L,
          isHidden: $e
        }
      ),
      /* @__PURE__ */ E.jsxs("g", { pointerEvents: "all", children: [
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            className: $n("rs-transparent", {
              "rs-hidden": St
            }),
            "data-wd": "selection.resize.top",
            "aria-label": "top target",
            x: 0,
            y: ze(0 - (X ? Pe * 2 : Pe)),
            width: ze(Math.max(1, D)),
            height: ze(Math.max(1, Pe * 2)),
            style: v ? { cursor: ss("ns-resize", T) } : void 0,
            ...r
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            className: $n("rs-transparent", {
              "rs-hidden": St
            }),
            "data-wd": "selection.resize.right",
            "aria-label": "right target",
            x: ze(D - (K ? 0 : pe)),
            y: 0,
            height: ze(Math.max(1, N)),
            width: ze(Math.max(1, pe * 2)),
            style: v ? { cursor: ss("ew-resize", T) } : void 0,
            ...a
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            className: $n("rs-transparent", {
              "rs-hidden": St
            }),
            "data-wd": "selection.resize.bottom",
            "aria-label": "bottom target",
            x: 0,
            y: ze(N - (X ? 0 : Pe)),
            width: ze(Math.max(1, D)),
            height: ze(Math.max(1, Pe * 2)),
            style: v ? { cursor: ss("ns-resize", T) } : void 0,
            ...s
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            className: $n("rs-transparent", {
              "rs-hidden": St
            }),
            "data-wd": "selection.resize.left",
            "aria-label": "left target",
            x: ze(0 - (K ? pe * 2 : pe)),
            y: 0,
            height: ze(Math.max(1, N)),
            width: ze(Math.max(1, pe * 2)),
            style: v ? { cursor: ss("ew-resize", T) } : void 0,
            ...c
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            className: $n("rs-transparent", {
              "rs-hidden": Me
            }),
            "data-wd": "selection.resize.top-left",
            "aria-label": "top-left target",
            x: ze(0 - (K ? pe * 2 : pe * 1.5)),
            y: ze(0 - (X ? Pe * 2 : Pe * 1.5)),
            width: ze(pe * 3),
            height: ze(Pe * 3),
            style: v ? { cursor: ss("nwse-resize", T) } : void 0,
            ...f
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            className: $n("rs-transparent", {
              "rs-hidden": re
            }),
            "data-wd": "selection.resize.top-right",
            "aria-label": "top-right target",
            x: ze(D - (K ? 0 : pe * 1.5)),
            y: ze(0 - (X ? Pe * 2 : Pe * 1.5)),
            width: ze(pe * 3),
            height: ze(Pe * 3),
            style: v ? { cursor: ss("nesw-resize", T) } : void 0,
            ...p
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            className: $n("rs-transparent", {
              "rs-hidden": ke
            }),
            "data-wd": "selection.resize.bottom-right",
            "aria-label": "bottom-right target",
            x: ze(D - (K ? pe : pe * 1.5)),
            y: ze(N - (X ? Pe : Pe * 1.5)),
            width: ze(pe * 3),
            height: ze(Pe * 3),
            style: v ? { cursor: ss("nwse-resize", T) } : void 0,
            ...g
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            className: $n("rs-transparent", {
              "rs-hidden": Qe
            }),
            "data-wd": "selection.resize.bottom-left",
            "aria-label": "bottom-left target",
            x: ze(0 - (K ? pe * 3 : pe * 1.5)),
            y: ze(N - (X ? 0 : Pe * 1.5)),
            width: ze(pe * 3),
            height: ze(Pe * 3),
            style: v ? { cursor: ss("nesw-resize", T) } : void 0,
            ...y
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            "data-wd": "selection.resize.top-left",
            className: $n("rs-corner-handle", {
              "rs-hidden": Me
            }),
            "aria-label": "top_left handle",
            x: ze(0 - L / 2),
            y: ze(0 - L / 2),
            width: ze(L),
            height: ze(L)
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            "data-wd": "selection.resize.top-right",
            className: $n("rs-corner-handle", {
              "rs-hidden": re
            }),
            "aria-label": "top_right handle",
            x: ze(D - L / 2),
            y: ze(0 - L / 2),
            width: ze(L),
            height: ze(L)
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            "data-wd": "selection.resize.bottom-right",
            className: $n("rs-corner-handle", {
              "rs-hidden": ke
            }),
            "aria-label": "bottom_right handle",
            x: ze(D - L / 2),
            y: ze(N - L / 2),
            width: ze(L),
            height: ze(L)
          }
        ),
        /* @__PURE__ */ E.jsx(
          "rect",
          {
            "data-wd": "selection.resize.bottom-left",
            className: $n("rs-corner-handle", {
              "rs-hidden": Qe
            }),
            "aria-label": "bottom_left handle",
            x: ze(0 - L / 2),
            y: ze(N - L / 2),
            width: ze(L),
            height: ze(L)
          }
        )
      ] })
    ] })
  ] });
});
function Rre() {
  return /* @__PURE__ */ E.jsx("div", { className: "rs-shape-error-boundary" });
}
const BD = dn(function({
  id: e,
  index: n,
  opacity: r,
  isCulled: a
}) {
  const s = Ge(), c = Cee(e), f = k.useRef(null);
  kp(
    "set shape container transform position",
    () => {
      const y = f.current;
      if (!y)
        return;
      const v = s.getShapeById(e), S = s.getPageTransformById(e);
      if (!v || !S)
        return null;
      const x = De.toCssString(S);
      y.style.setProperty("transform", x);
    },
    [s]
  ), kp(
    "set shape container clip path / color",
    () => {
      const y = f.current, v = s.getShapeById(e);
      if (!y)
        return;
      if (!v)
        return null;
      const S = s.getClipPathById(e);
      y.style.setProperty("clip-path", S ?? "none"), "color" in v.props && y.style.setProperty("color", s.getCssColor(v.props.color));
    },
    [s]
  ), kp(
    "set shape height and width",
    () => {
      const y = f.current, v = s.getShapeById(e);
      if (!y)
        return;
      if (!v)
        return null;
      const x = s.getShapeUtil(v).bounds(v);
      y.style.setProperty("width", Math.ceil(x.width) + "px"), y.style.setProperty("height", Math.ceil(x.height) + "px");
    },
    [s]
  ), k.useLayoutEffect(() => {
    const y = f.current;
    y && (y.style.setProperty("opacity", r + ""), y.style.setProperty("z-index", n + ""));
  }, [r, n]);
  const p = s.getShapeById(e);
  if (!p)
    return null;
  const g = s.getShapeUtil(p);
  return /* @__PURE__ */ E.jsx(
    "div",
    {
      ref: f,
      className: "rs-shape",
      "data-shape-type": p.type,
      draggable: !1,
      onPointerDown: c.onPointerDown,
      onPointerMove: c.onPointerMove,
      onPointerUp: c.onPointerUp,
      onPointerEnter: c.onPointerEnter,
      onPointerLeave: c.onPointerLeave,
      children: a && g.canUnmount(p) ? /* @__PURE__ */ E.jsx(Mre, { shape: p, util: g }) : /* @__PURE__ */ E.jsxs(
        Pb,
        {
          fallback: Rre,
          onError: (y) => s.annotateError(y, { origin: "react.shape", willCrashApp: !1 }),
          children: [
            " ",
            /* @__PURE__ */ E.jsx($re, { shape: p, util: g })
          ]
        }
      )
    },
    e
  );
}), $re = k.memo(
  function({ shape: e, util: n }) {
    return II("InnerShape:" + n.type, () => n.render(e));
  },
  (t, e) => t.shape.props === e.shape.props
), Mre = k.memo(
  function({ shape: e, util: n }) {
    const r = n.bounds(e);
    return /* @__PURE__ */ E.jsx(
      "div",
      {
        className: "rs-shape__culled",
        style: {
          transform: `translate(${r.minX}px, ${r.minY}px)`,
          width: r.width,
          height: r.height
        }
      }
    );
  },
  () => !0
);
function Are({ points: t, zoom: e }) {
  const n = 2.5 / e, r = t.reduce((S, x) => Math.min(S, x.x), 1 / 0), a = t.reduce((S, x) => Math.max(S, x.x), -1 / 0), s = t.reduce((S, x) => Math.min(S, x.y), 1 / 0), c = t.reduce((S, x) => Math.max(S, x.y), -1 / 0), f = t.some((S) => S.x === r && S.y === s);
  let p, g, y, v;
  return f ? (p = r, g = s, y = a, v = c) : (p = r, g = c, y = a, v = s), /* @__PURE__ */ E.jsxs("g", { className: "rs-snap-line", children: [
    /* @__PURE__ */ E.jsx("line", { x1: p, y1: g, x2: y, y2: v }),
    t.map((S, x) => /* @__PURE__ */ E.jsx("g", { transform: `translate(${S.x},${S.y})`, children: /* @__PURE__ */ E.jsx(
      "path",
      {
        className: "rs-snap-point",
        d: `M ${-n},${-n} L ${n},${n} M ${-n},${n} L ${n},${-n}`
      }
    ) }, x))
  ] });
}
function Ore({ gaps: t, direction: e, zoom: n }) {
  const r = 3.5 / n;
  let a = [-1 / 0, 1 / 0], s = null;
  const c = e === "horizontal";
  for (const p of t) {
    if (s = kl(
      a[0],
      a[1],
      c ? p.startEdge[0].y : p.startEdge[0].x,
      c ? p.startEdge[1].y : p.startEdge[1].x
    ), s)
      a = s;
    else
      continue;
    if (s = kl(
      a[0],
      a[1],
      c ? p.endEdge[0].y : p.endEdge[0].x,
      c ? p.endEdge[1].y : p.endEdge[1].x
    ), s)
      a = s;
    else
      continue;
  }
  if (a === null)
    return null;
  const f = (a[0] + a[1]) / 2;
  return /* @__PURE__ */ E.jsx("g", { className: "rs-snap-line", children: t.map(({ startEdge: p, endEdge: g }, y) => /* @__PURE__ */ E.jsx(k.Fragment, { children: c ? (
    // horizontal gap
    /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(
        "line",
        {
          x1: p[0].x,
          y1: f - 2 * r,
          x2: p[1].x,
          y2: f + 2 * r
        }
      ),
      /* @__PURE__ */ E.jsx(
        "line",
        {
          x1: g[0].x,
          y1: f - 2 * r,
          x2: g[1].x,
          y2: f + 2 * r
        }
      ),
      /* @__PURE__ */ E.jsx("line", { x1: p[0].x, y1: f, x2: g[0].x, y2: f }),
      /* @__PURE__ */ E.jsx(
        "line",
        {
          x1: (p[0].x + g[0].x) / 2,
          y1: f - r,
          x2: (p[0].x + g[0].x) / 2,
          y2: f + r
        }
      )
    ] })
  ) : (
    // vertical gap
    /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(
        "line",
        {
          x1: f - 2 * r,
          y1: p[0].y,
          x2: f + 2 * r,
          y2: p[1].y
        }
      ),
      /* @__PURE__ */ E.jsx(
        "line",
        {
          x1: f - 2 * r,
          y1: g[0].y,
          x2: f + 2 * r,
          y2: g[1].y
        }
      ),
      /* @__PURE__ */ E.jsx("line", { x1: f, y1: p[0].y, x2: f, y2: g[0].y }),
      /* @__PURE__ */ E.jsx(
        "line",
        {
          x1: f - r,
          y1: (p[0].y + g[0].y) / 2,
          x2: f + r,
          y2: (p[0].y + g[0].y) / 2
        }
      )
    ] })
  ) }, y)) });
}
function Dre({ line: t, zoom: e }) {
  switch (t.type) {
    case "points":
      return /* @__PURE__ */ E.jsx(Are, { ...t, zoom: e });
    case "gaps":
      return /* @__PURE__ */ E.jsx(Ore, { ...t, zoom: e });
    default:
      return null;
  }
}
const Nre = dn(function() {
  const e = Ge(), n = e.zoomLevel;
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: e.snaps.lines.map((r) => /* @__PURE__ */ E.jsx(Dre, { line: r, zoom: n }, r.id)) });
}), Lre = dn(function({ id: e }) {
  const n = Ge(), r = n.getShapeById(e), [a, s] = k.useState("");
  return k.useEffect(() => {
    let c = !1;
    return (async () => {
      if (c)
        return;
      const f = n.getPageBoundsById(e), p = await n.getSvg([e], { padding: 0 });
      p && f && !c && (p.style.setProperty("overflow", "visible"), p.setAttribute("preserveAspectRatio", "xMidYMin slice"), p.style.setProperty("transform", `translate(${f.x}px, ${f.y + f.h + 12}px)`), p.style.setProperty("border", "1px solid black"), s(p?.outerHTML));
    })(), () => {
      c = !0;
    };
  }, [n, r, e]), /* @__PURE__ */ E.jsx("div", { style: { paddingTop: 12, position: "absolute" }, children: /* @__PURE__ */ E.jsx("div", { style: { display: "flex" }, dangerouslySetInnerHTML: { __html: a } }) });
}), Oj = dn(function({
  onDropOverride: e
}) {
  const n = Ge(), r = k.useRef(null), a = k.useRef(null), s = k.useRef(null);
  YZ(), LZ(), JJ(r), XZ(r), Eee(), kp(
    "position layers",
    () => {
      const g = s.current, y = a.current;
      if (!(g && y))
        return;
      const { x: v, y: S, z: x } = n.camera, _ = x >= 1 ? Jk(x, [1, 8], [0.125, 0.5], !0) : Jk(x, [0.1, 1], [-2, 0.125], !0);
      g.style.setProperty(
        "transform",
        `scale(${ze(x)}) translate(${ze(v)}px,${ze(S)}px)`
      ), y.style.setProperty(
        "transform",
        `scale(${ze(x)}) translate(${ze(v + _)}px,${ze(
          S + _
        )}px)`
      );
    },
    [n]
  );
  const { context: c, isReady: f } = nee(), p = NZ();
  return e && (p.onDrop = e(p.onDrop)), k.useEffect(() => {
    if (f && n.isSafari) {
      const g = s.current, y = a.current;
      g && y && requestAnimationFrame(() => {
        g.style.display = "none", y.style.display = "none", requestAnimationFrame(() => {
          g.style.display = "", y.style.display = "";
        });
      });
    }
  }, [n, f]), k.useEffect(() => {
    r.current?.focus();
  }, []), /* @__PURE__ */ E.jsxs(
    "div",
    {
      ref: r,
      tabIndex: -1,
      draggable: !1,
      className: "rs-canvas",
      "data-wd": "canvas",
      ...p,
      children: [
        /* @__PURE__ */ E.jsx(lre, { size: n.gridSize }),
        /* @__PURE__ */ E.jsxs("div", { ref: a, className: "rs-html-layer", draggable: !1, children: [
          /* @__PURE__ */ E.jsx(Tre, {}),
          /* @__PURE__ */ E.jsx(jre, {})
        ] }),
        /* @__PURE__ */ E.jsxs("svg", { className: "rs-svg-layer", children: [
          c,
          /* @__PURE__ */ E.jsxs("defs", { children: [
            /* @__PURE__ */ E.jsx(Fre, {}),
            /* @__PURE__ */ E.jsx(Hre, {}),
            /* @__PURE__ */ E.jsx("marker", { id: "arrowhead-dot", className: "rs-arrow-hint", refX: "3.0", refY: "3.0", orient: "0", children: /* @__PURE__ */ E.jsx("circle", { cx: "3", cy: "3", r: "2", strokeDasharray: "100%" }) }),
            /* @__PURE__ */ E.jsxs(
              "marker",
              {
                id: "arrowhead-cross",
                className: "rs-arrow-hint",
                refX: "3.0",
                refY: "3.0",
                orient: "auto",
                children: [
                  /* @__PURE__ */ E.jsx("line", { x1: "1.5", y1: "1.5", x2: "4.5", y2: "4.5", strokeDasharray: "100%" }),
                  /* @__PURE__ */ E.jsx("line", { x1: "1.5", y1: "4.5", x2: "4.5", y2: "1.5", strokeDasharray: "100%" })
                ]
              }
            )
          ] }),
          /* @__PURE__ */ E.jsxs("g", { ref: s, children: [
            /* @__PURE__ */ E.jsx(wre, {}),
            /* @__PURE__ */ E.jsx(_re, {}),
            /* @__PURE__ */ E.jsx(sre, {}),
            /* @__PURE__ */ E.jsx(zre, {}),
            /* @__PURE__ */ E.jsx(Ure, {}),
            /* @__PURE__ */ E.jsx(Ire, {}),
            /* @__PURE__ */ E.jsx(Bre, {}),
            /* @__PURE__ */ E.jsx(fre, {}),
            /* @__PURE__ */ E.jsx(Nre, {})
          ] })
        ] })
      ]
    }
  );
}), jre = dn(function() {
  const e = Ge(), { renderingShapes: n } = e;
  return fs.debugSvg.value ? /* @__PURE__ */ E.jsx(E.Fragment, { children: n.map((a) => /* @__PURE__ */ E.jsxs(k.Fragment, { children: [
    /* @__PURE__ */ E.jsx(BD, { ...a }, a.id + "_shape"),
    /* @__PURE__ */ E.jsx(Lre, { id: a.id }, a.id + "_shape_debug")
  ] }, a.id + "_fragment")) }) : /* @__PURE__ */ E.jsx(E.Fragment, { children: n.map((a) => /* @__PURE__ */ E.jsx(BD, { ...a }, a.id + "_shape")) });
}), zre = dn(function() {
  const e = Ge(), n = e.selectedIds, r = e.isChangingStyle;
  return e.isInAny(
    "select.idle",
    "select.brushing",
    "select.scribble_brushing",
    "select.pointing_shape",
    "select.pointing_selection",
    "select.pointing_handle"
  ) && !r ? /* @__PURE__ */ E.jsx("g", { "aria-label": "SELECTED INDICATORS", children: n.map((s) => /* @__PURE__ */ E.jsx(b1, { id: s }, s + "_indicator")) }) : null;
}), Ure = dn(function() {
  const e = Ge(), n = e.pageState.hoveredId, r = e.isInAny("select.idle", "select.editing_shape");
  return n && r ? /* @__PURE__ */ E.jsx(b1, { id: n }, n) : null;
}), Bre = dn(function() {
  const e = Ge(), n = Sx(e.hintingIds);
  return n.length ? /* @__PURE__ */ E.jsx("g", { "aria-label": "HINTED SHAPES", children: n.map((r) => /* @__PURE__ */ E.jsx(b1, { id: r, isHinting: !0 }, r + "_hinting")) }) : null;
});
function Fre() {
  return /* @__PURE__ */ E.jsxs("g", { id: "cursor", children: [
    /* @__PURE__ */ E.jsxs("g", { fill: "rgba(0,0,0,.2)", transform: "translate(-11,-11)", children: [
      /* @__PURE__ */ E.jsx("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
      /* @__PURE__ */ E.jsx("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
    ] }),
    /* @__PURE__ */ E.jsxs("g", { fill: "white", transform: "translate(-12,-12)", children: [
      /* @__PURE__ */ E.jsx("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
      /* @__PURE__ */ E.jsx("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
    ] }),
    /* @__PURE__ */ E.jsxs("g", { fill: "currentColor", transform: "translate(-12,-12)", children: [
      /* @__PURE__ */ E.jsx("path", { d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" }),
      /* @__PURE__ */ E.jsx("path", { d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z" })
    ] })
  ] });
}
function Hre() {
  return /* @__PURE__ */ E.jsx("path", { id: "cursor_hint", fill: "currentColor", d: "M -2,-5 2,0 -2,5 Z", opacity: ".8" });
}
const Vre = "https://github.com/tldraw/editor/issues/new";
function Yre() {
}
function cP({ error: t, app: e }) {
  const n = k.useRef(null), [r, a] = k.useState({}.NODE_ENV === "development"), [s, c] = k.useState(!1), [f, p] = k.useState(!1), g = t instanceof Error ? t.message : String(t), y = t instanceof Error ? t.stack : null, v = un(
    "isDarkMode",
    () => {
      try {
        if (e)
          return e.userDocumentSettings.isDarkMode;
      } catch {
      }
      return null;
    },
    [e]
  ), [S, x] = k.useState(null);
  k.useLayoutEffect(() => {
    v !== null && x(v);
    let N = n.current?.parentElement, j = !1;
    for (; N; ) {
      if (N.classList.contains("rs-theme__dark") || N.classList.contains("rs-theme__light")) {
        j = !0;
        break;
      }
      N = N.parentElement;
    }
    if (j) {
      x(null);
      return;
    }
    x(window.matchMedia("(prefers-color-scheme: dark)").matches);
  }, [v]), k.useEffect(() => {
    if (s) {
      const N = setTimeout(() => {
        c(!1);
      }, 2e3);
      return () => clearTimeout(N);
    }
  }, [s]);
  const _ = () => {
    const N = document.createElement("textarea");
    N.value = y ?? g, document.body.appendChild(N), N.select(), document.execCommand("copy"), N.remove(), c(!0);
  }, T = () => {
    window.location.reload();
  }, I = async () => {
    await window.__tldraw__hardReset?.();
  }, D = new URL(Vre);
  return D.searchParams.set("title", g), D.searchParams.set("labels", "bug"), D.searchParams.set(
    "body",
    `Hey, I ran into an error while using tldraw:

\`\`\`js
${y ?? g}
\`\`\`

My browser: ${navigator.userAgent}`
  ), /* @__PURE__ */ E.jsxs(
    "div",
    {
      ref: n,
      className: $n(
        "rs-container rs-error-boundary",
        // error-boundary is sometimes used outside of the theme
        // container, so we need to provide it with a theme for our
        // styles to work correctly
        S === null ? "" : S ? "rs-theme__dark" : "rs-theme__light"
      ),
      children: [
        /* @__PURE__ */ E.jsx("div", { className: "rs-error-boundary__overlay" }),
        e && // opportunistically attempt to render the canvas to reassure
        // the user that their document is still there. there's a good
        // chance this won't work (ie the error that we're currently
        // notifying the user about originates in the canvas) so it's
        // not a big deal if it doesn't work - in that case we just have
        // a plain grey background.
        /* @__PURE__ */ E.jsx(Pb, { onError: Yre, fallback: () => null, children: /* @__PURE__ */ E.jsx(RI.Provider, { value: e, children: /* @__PURE__ */ E.jsx("div", { className: "rs-overlay rs-error-boundary__canvas", children: /* @__PURE__ */ E.jsx(Oj, {}) }) }) }),
        /* @__PURE__ */ E.jsx(
          "div",
          {
            className: $n("rs-modal", "rs-error-boundary__content", {
              "rs-error-boundary__content__expanded": r && !f
            }),
            children: f ? /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
              /* @__PURE__ */ E.jsx("h2", { children: "Are you sure?" }),
              /* @__PURE__ */ E.jsx("p", { children: "Resetting your data will delete your drawing and cannot be undone." }),
              /* @__PURE__ */ E.jsxs("div", { className: "rs-error-boundary__content__actions", children: [
                /* @__PURE__ */ E.jsx("button", { onClick: () => p(!1), children: "Cancel" }),
                /* @__PURE__ */ E.jsx("button", { className: "rs-error-boundary__reset", onClick: I, children: "Reset data" })
              ] })
            ] }) : /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
              /* @__PURE__ */ E.jsx("h2", { children: "Something's gone wrong." }),
              /* @__PURE__ */ E.jsxs("p", { children: [
                "Sorry, we encountered an error. Please refresh the page to continue. If you keep seeing this error, you can ",
                /* @__PURE__ */ E.jsx("a", { href: D.toString(), children: "create a GitHub issue" }),
                " or",
                " ",
                /* @__PURE__ */ E.jsx("a", { href: "https://discord.gg/Cq6cPsTfNy", children: "ask for help on Discord" }),
                "."
              ] }),
              r && /* @__PURE__ */ E.jsxs("div", { className: "rs-error-boundary__content__error", children: [
                /* @__PURE__ */ E.jsx("pre", { children: /* @__PURE__ */ E.jsx("code", { children: y ?? g }) }),
                /* @__PURE__ */ E.jsx("button", { onClick: _, children: s ? "Copied!" : "Copy" })
              ] }),
              /* @__PURE__ */ E.jsxs("div", { className: "rs-error-boundary__content__actions", children: [
                /* @__PURE__ */ E.jsx("button", { onClick: () => a(!r), children: r ? "Hide details" : "Show details" }),
                /* @__PURE__ */ E.jsxs("div", { className: "rs-error-boundary__content__actions__group", children: [
                  /* @__PURE__ */ E.jsx(
                    "button",
                    {
                      className: "rs-error-boundary__reset",
                      onClick: () => p(!0),
                      children: "Reset data"
                    }
                  ),
                  /* @__PURE__ */ E.jsx("button", { className: "rs-error-boundary__refresh", onClick: T, children: "Refresh Page" })
                ] })
              ] })
            ] })
          }
        )
      ]
    }
  );
}
let Dj = !1;
if (typeof window < "u") {
  const t = window.navigator.userAgent, e = !!t.match(/iPad/i) || !!t.match(/iPhone/i), n = !!t.match(/WebKit/i);
  Dj = e && n && !t.match(/CriOS/i);
}
function Kre() {
  const t = Ge();
  k.useEffect(() => {
    if (!Dj)
      return;
    function e(n) {
      (n.target instanceof HTMLInputElement && n.target.type === "text" || n.target instanceof HTMLTextAreaElement) && t.complete();
    }
    return document.addEventListener("focusout", e), () => document.removeEventListener("focusout", e);
  }, [t]);
}
const Wre = ({ children: t }) => (_ee(), HZ(), VZ(), qZ(), Kre(), t), Fw = (t, e) => {
  const [n, r] = k.useState(
    2
    /* WAITING */
  );
  return k.useEffect(() => {
    const {
      url: a,
      style: s = "normal",
      weight: c = "500",
      display: f,
      featureSettings: p,
      stretch: g,
      unicodeRange: y,
      variant: v
    } = e;
    let S = !1;
    r(
      2
      /* WAITING */
    );
    const x = {
      style: s,
      weight: c,
      display: f,
      featureSettings: p,
      stretch: g,
      unicodeRange: y,
      variant: v
    }, _ = new FontFace(t, `url(${a})`, x);
    return _.load().then(() => {
      S || (document.fonts.add(_), r(
        0
        /* SUCCESS */
      ));
    }).catch((T) => {
      S || (console.error(T), r(
        1
        /* FAILED */
      ));
    }), _.$$_url = a, _.$$_fontface = `
@font-face {
	font-family: ${_.family};
	font-stretch: ${_.stretch};
	font-weight: ${_.weight};
	font-style: ${_.style};
	src: url("${a}") format("woff2")
}`, () => {
      document.fonts.delete(_), S = !0;
    };
  }, [t, e]), n;
};
function Gre(t) {
  return {
    draw: { url: t.fonts.draw },
    serif: { url: t.fonts.serif },
    sansSerif: { url: t.fonts.sansSerif },
    monospace: { url: t.fonts.monospace }
  };
}
function Xre(t) {
  const e = k.useMemo(() => Gre(t), [t]), n = [
    Fw("tldraw_draw", e.draw),
    Fw("tldraw_serif", e.serif),
    Fw("tldraw_sans", e.sansSerif),
    Fw("tldraw_mono", e.monospace)
  ];
  return {
    // If any of the results have errored, then preloading has failed
    error: n.some(
      (r) => r === 1
      /* FAILED */
    ),
    // If any of the results are waiting, then we're not done yet
    done: !n.some(
      (r) => r === 2
      /* WAITING */
    )
  };
}
function qre(t) {
  const [e, n] = It.useState(null);
  return /* @__PURE__ */ E.jsx("div", { ref: n, draggable: !1, className: "rs-container rs-theme__light", children: /* @__PURE__ */ E.jsx(
    Pb,
    {
      fallback: (r) => /* @__PURE__ */ E.jsx(cP, { error: r }),
      onError: (r) => uI(r, { tags: { origin: "react.tldraw-before-app" } }),
      children: e && /* @__PURE__ */ E.jsx(jZ, { container: e, children: /* @__PURE__ */ E.jsx(Qre, { ...t }) })
    }
  ) });
}
function Qre({
  config: t = Tb.default,
  userId: e,
  instanceId: n,
  store: r,
  ...a
}) {
  const { done: s, error: c } = Xre(
    a.assetUrls ?? Mj
  );
  r ??= t.createStore({
    userId: e ?? Ip.createId(),
    instanceId: n ?? Pp.createId()
  });
  let f;
  if (r instanceof pL)
    f = r;
  else {
    if (r.error)
      throw r.error;
    if (!r.store)
      return /* @__PURE__ */ E.jsx(uP, { children: "Connecting..." });
    f = r.store;
  }
  return n && f.props.instanceId !== n && console.error(
    `The store's instanceId (${f.props.instanceId}) does not match the instanceId prop (${n}). This may cause unexpected behavior.`
  ), e && f.props.userId !== e && console.error(
    `The store's userId (${f.props.userId}) does not match the userId prop (${e}). This may cause unexpected behavior.`
  ), c ? /* @__PURE__ */ E.jsx(Jre, { children: "Could not load assets. Please refresh the page." }) : s ? /* @__PURE__ */ E.jsx(Zre, { ...a, store: f, config: t }) : /* @__PURE__ */ E.jsx(uP, { children: "Loading assets..." });
}
function Zre({
  onMount: t,
  config: e,
  isDarkMode: n,
  children: r,
  onCreateAssetFromFile: a,
  onCreateBookmarkFromUrl: s,
  store: c
}) {
  const f = ga(), [p, g] = It.useState(null);
  It.useLayoutEffect(() => {
    const S = new en({
      store: c,
      getContainer: () => f,
      config: e
    });
    return g(S), window.app = S, () => {
      S.dispose(), g((x) => x === S ? null : x);
    };
  }, [f, e, c]), It.useEffect(() => {
    p && (a && (p.onCreateAssetFromFile = a), s && (p.onCreateBookmarkFromUrl = s));
  }, [p, n, a, s]);
  const y = WZ((S) => t?.(S));
  It.useEffect(() => {
    p && (n !== void 0 && p.updateUserDocumentSettings({ isDarkMode: n }), window.tldrawReady = !0, y(p));
  }, [p, y, n]);
  const v = k.useSyncExternalStore(
    k.useCallback(
      (S) => p ? (p.on("crash", S), () => p.off("crash", S)) : () => {
      },
      [p]
    ),
    () => p?.crashingError ?? null
  );
  return p ? (
    // the top-level tldraw component also renders an error boundary almost
    // identical to this one. the reason we have two is because this one has
    // access to `App`, which means that here we can enrich errors with data
    // from app for reporting, and also still attempt to render the user's
    // document in the event of an error to reassure them that their work is
    // not lost.
    /* @__PURE__ */ E.jsx(Pb, {
      fallback: (S) => /* @__PURE__ */ E.jsx(cP, { error: S, app: p }),
      onError: (S) => p.annotateError(S, { origin: "react.tldraw", willCrashApp: !0 }),
      children: v ? /* @__PURE__ */ E.jsx(cP, { error: v, app: p }) : /* @__PURE__ */ E.jsx(RI.Provider, { value: p, children: /* @__PURE__ */ E.jsx(Wre, { children: r }) })
    })
  ) : null;
}
function uP({ children: t }) {
  return /* @__PURE__ */ E.jsxs("div", { className: "rs-loading", children: [
    /* @__PURE__ */ E.jsx(m1, {}),
    t
  ] });
}
function Jre({ children: t }) {
  return /* @__PURE__ */ E.jsx("div", { className: "rs-loading", children: t });
}
const eie = (t, e) => e.some((n) => t instanceof n);
let FD, HD;
function tie() {
  return FD || (FD = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function nie() {
  return HD || (HD = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const Nj = /* @__PURE__ */ new WeakMap(), dP = /* @__PURE__ */ new WeakMap(), Lj = /* @__PURE__ */ new WeakMap(), uk = /* @__PURE__ */ new WeakMap(), WI = /* @__PURE__ */ new WeakMap();
function rie(t) {
  const e = new Promise((n, r) => {
    const a = () => {
      t.removeEventListener("success", s), t.removeEventListener("error", c);
    }, s = () => {
      n(Wg(t.result)), a();
    }, c = () => {
      r(t.error), a();
    };
    t.addEventListener("success", s), t.addEventListener("error", c);
  });
  return e.then((n) => {
    n instanceof IDBCursor && Nj.set(n, t);
  }).catch(() => {
  }), WI.set(e, t), e;
}
function iie(t) {
  if (dP.has(t))
    return;
  const e = new Promise((n, r) => {
    const a = () => {
      t.removeEventListener("complete", s), t.removeEventListener("error", c), t.removeEventListener("abort", c);
    }, s = () => {
      n(), a();
    }, c = () => {
      r(t.error || new DOMException("AbortError", "AbortError")), a();
    };
    t.addEventListener("complete", s), t.addEventListener("error", c), t.addEventListener("abort", c);
  });
  dP.set(t, e);
}
let fP = {
  get(t, e, n) {
    if (t instanceof IDBTransaction) {
      if (e === "done")
        return dP.get(t);
      if (e === "objectStoreNames")
        return t.objectStoreNames || Lj.get(t);
      if (e === "store")
        return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0]);
    }
    return Wg(t[e]);
  },
  set(t, e, n) {
    return t[e] = n, !0;
  },
  has(t, e) {
    return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t;
  }
};
function oie(t) {
  fP = t(fP);
}
function aie(t) {
  return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...n) {
    const r = t.call(dk(this), e, ...n);
    return Lj.set(r, e.sort ? e.sort() : [e]), Wg(r);
  } : nie().includes(t) ? function(...e) {
    return t.apply(dk(this), e), Wg(Nj.get(this));
  } : function(...e) {
    return Wg(t.apply(dk(this), e));
  };
}
function sie(t) {
  return typeof t == "function" ? aie(t) : (t instanceof IDBTransaction && iie(t), eie(t, tie()) ? new Proxy(t, fP) : t);
}
function Wg(t) {
  if (t instanceof IDBRequest)
    return rie(t);
  if (uk.has(t))
    return uk.get(t);
  const e = sie(t);
  return e !== t && (uk.set(t, e), WI.set(e, t)), e;
}
const dk = (t) => WI.get(t);
function lie(t, { blocked: e } = {}) {
  const n = indexedDB.deleteDatabase(t);
  return e && n.addEventListener("blocked", (r) => e(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    r.oldVersion,
    r
  )), Wg(n).then(() => {
  });
}
const cie = ["get", "getKey", "getAll", "getAllKeys", "count"], uie = ["put", "add", "delete", "clear"], fk = /* @__PURE__ */ new Map();
function VD(t, e) {
  if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string"))
    return;
  if (fk.get(e))
    return fk.get(e);
  const n = e.replace(/FromIndex$/, ""), r = e !== n, a = uie.includes(n);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(a || cie.includes(n))
  )
    return;
  const s = async function(c, ...f) {
    const p = this.transaction(c, a ? "readwrite" : "readonly");
    let g = p.store;
    return r && (g = g.index(f.shift())), (await Promise.all([
      g[n](...f),
      a && p.done
    ]))[0];
  };
  return fk.set(e, s), s;
}
oie((t) => ({
  ...t,
  get: (e, n, r) => VD(e, n) || t.get(e, n, r),
  has: (e, n) => !!VD(e, n) || t.has(e, n)
}));
const Gg = "TLDRAW_TAB_ID_v2", Co = globalThis.window;
function die() {
  return Co ? ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(
    Co.navigator.platform
  ) || // iPad on iOS 13 detection
  Co.navigator.userAgent.includes("Mac") && "ontouchend" in document : !1;
}
const jj = "TLDRAW_USER_DATA_v2", fie = fi(
  "globalUserData",
  JSON.parse(Co?.localStorage.getItem(jj) || "null") ?? Ip.create({})
);
r1("set global user data", () => {
  Co && Co.localStorage.setItem(jj, JSON.stringify(fie.value));
});
const zj = "TLDRAW_DEFAULT_DOCUMENT_NAME_v2", pie = Co?.localStorage.getItem(zj) ?? Ii();
Co?.localStorage.setItem(zj, pie);
const pP = Co?.[Gg] ?? Co?.sessionStorage[Gg] ?? Pp.createId();
Co && (Co[Gg] = pP, die() ? Co.sessionStorage[Gg] = pP : delete Co.sessionStorage[Gg]);
Co?.addEventListener("beforeunload", () => {
  Co.sessionStorage[Gg] = pP;
});
const hie = "TLDRAW_DB_NAME_INDEX_v2";
function gie() {
  const t = JSON.parse(Co?.localStorage.getItem(hie) || "[]") ?? [];
  return Array.isArray(t) ? t : [];
}
async function YD({ shouldReload: t = !0 } = {}) {
  sessionStorage.clear(), await Promise.all(gie().map((e) => lie(e))), localStorage.clear(), t && window.location.reload();
}
typeof window < "u" && ({}.NODE_ENV === "development" && (window.hardReset = YD), window.__tldraw__hardReset = YD);
function qe() {
  return qe = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }, qe.apply(this, arguments);
}
var hP = { exports: {} }, Ba = {}, Hw = { exports: {} }, pk = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var KD;
function mie() {
  return KD || (KD = 1, function(t) {
    function e(te, de) {
      var W = te.length;
      te.push(de);
      e:
        for (; 0 < W; ) {
          var fe = W - 1 >>> 1, ce = te[fe];
          if (0 < a(ce, de))
            te[fe] = de, te[W] = ce, W = fe;
          else
            break e;
        }
    }
    function n(te) {
      return te.length === 0 ? null : te[0];
    }
    function r(te) {
      if (te.length === 0)
        return null;
      var de = te[0], W = te.pop();
      if (W !== de) {
        te[0] = W;
        e:
          for (var fe = 0, ce = te.length, xe = ce >>> 1; fe < xe; ) {
            var $e = 2 * (fe + 1) - 1, Me = te[$e], re = $e + 1, Qe = te[re];
            if (0 > a(Me, W))
              re < ce && 0 > a(Qe, Me) ? (te[fe] = Qe, te[re] = W, fe = re) : (te[fe] = Me, te[$e] = W, fe = $e);
            else if (re < ce && 0 > a(Qe, W))
              te[fe] = Qe, te[re] = W, fe = re;
            else
              break e;
          }
      }
      return de;
    }
    function a(te, de) {
      var W = te.sortIndex - de.sortIndex;
      return W !== 0 ? W : te.id - de.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      t.unstable_now = function() {
        return s.now();
      };
    } else {
      var c = Date, f = c.now();
      t.unstable_now = function() {
        return c.now() - f;
      };
    }
    var p = [], g = [], y = 1, v = null, S = 3, x = !1, _ = !1, T = !1, I = typeof setTimeout == "function" ? setTimeout : null, D = typeof clearTimeout == "function" ? clearTimeout : null, N = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function j(te) {
      for (var de = n(g); de !== null; ) {
        if (de.callback === null)
          r(g);
        else if (de.startTime <= te)
          r(g), de.sortIndex = de.expirationTime, e(p, de);
        else
          break;
        de = n(g);
      }
    }
    function L(te) {
      if (T = !1, j(te), !_)
        if (n(p) !== null)
          _ = !0, Re(z);
        else {
          var de = n(g);
          de !== null && he(L, de.startTime - te);
        }
    }
    function z(te, de) {
      _ = !1, T && (T = !1, D(X), X = -1), x = !0;
      var W = S;
      try {
        for (j(de), v = n(p); v !== null && (!(v.expirationTime > de) || te && !pe()); ) {
          var fe = v.callback;
          if (typeof fe == "function") {
            v.callback = null, S = v.priorityLevel;
            var ce = fe(v.expirationTime <= de);
            de = t.unstable_now(), typeof ce == "function" ? v.callback = ce : v === n(p) && r(p), j(de);
          } else
            r(p);
          v = n(p);
        }
        if (v !== null)
          var xe = !0;
        else {
          var $e = n(g);
          $e !== null && he(L, $e.startTime - de), xe = !1;
        }
        return xe;
      } finally {
        v = null, S = W, x = !1;
      }
    }
    var F = !1, K = null, X = -1, se = 5, ue = -1;
    function pe() {
      return !(t.unstable_now() - ue < se);
    }
    function Pe() {
      if (K !== null) {
        var te = t.unstable_now();
        ue = te;
        var de = !0;
        try {
          de = K(!0, te);
        } finally {
          de ? ve() : (F = !1, K = null);
        }
      } else
        F = !1;
    }
    var ve;
    if (typeof N == "function")
      ve = function() {
        N(Pe);
      };
    else if (typeof MessageChannel < "u") {
      var Y = new MessageChannel(), le = Y.port2;
      Y.port1.onmessage = Pe, ve = function() {
        le.postMessage(null);
      };
    } else
      ve = function() {
        I(Pe, 0);
      };
    function Re(te) {
      K = te, F || (F = !0, ve());
    }
    function he(te, de) {
      X = I(function() {
        te(t.unstable_now());
      }, de);
    }
    t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(te) {
      te.callback = null;
    }, t.unstable_continueExecution = function() {
      _ || x || (_ = !0, Re(z));
    }, t.unstable_forceFrameRate = function(te) {
      0 > te || 125 < te ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : se = 0 < te ? Math.floor(1e3 / te) : 5;
    }, t.unstable_getCurrentPriorityLevel = function() {
      return S;
    }, t.unstable_getFirstCallbackNode = function() {
      return n(p);
    }, t.unstable_next = function(te) {
      switch (S) {
        case 1:
        case 2:
        case 3:
          var de = 3;
          break;
        default:
          de = S;
      }
      var W = S;
      S = de;
      try {
        return te();
      } finally {
        S = W;
      }
    }, t.unstable_pauseExecution = function() {
    }, t.unstable_requestPaint = function() {
    }, t.unstable_runWithPriority = function(te, de) {
      switch (te) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          te = 3;
      }
      var W = S;
      S = te;
      try {
        return de();
      } finally {
        S = W;
      }
    }, t.unstable_scheduleCallback = function(te, de, W) {
      var fe = t.unstable_now();
      switch (typeof W == "object" && W !== null ? (W = W.delay, W = typeof W == "number" && 0 < W ? fe + W : fe) : W = fe, te) {
        case 1:
          var ce = -1;
          break;
        case 2:
          ce = 250;
          break;
        case 5:
          ce = 1073741823;
          break;
        case 4:
          ce = 1e4;
          break;
        default:
          ce = 5e3;
      }
      return ce = W + ce, te = { id: y++, callback: de, priorityLevel: te, startTime: W, expirationTime: ce, sortIndex: -1 }, W > fe ? (te.sortIndex = W, e(g, te), n(p) === null && te === n(g) && (T ? (D(X), X = -1) : T = !0, he(L, W - fe))) : (te.sortIndex = ce, e(p, te), _ || x || (_ = !0, Re(z))), te;
    }, t.unstable_shouldYield = pe, t.unstable_wrapCallback = function(te) {
      var de = S;
      return function() {
        var W = S;
        S = de;
        try {
          return te.apply(this, arguments);
        } finally {
          S = W;
        }
      };
    };
  }(pk)), pk;
}
var hk = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var WD;
function vie() {
  return WD || (WD = 1, function(t) {
    ({}).NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, n = !1, r = 5;
      function a(Je, Et) {
        var nn = Je.length;
        Je.push(Et), f(Je, Et, nn);
      }
      function s(Je) {
        return Je.length === 0 ? null : Je[0];
      }
      function c(Je) {
        if (Je.length === 0)
          return null;
        var Et = Je[0], nn = Je.pop();
        return nn !== Et && (Je[0] = nn, p(Je, nn, 0)), Et;
      }
      function f(Je, Et, nn) {
        for (var kn = nn; kn > 0; ) {
          var xn = kn - 1 >>> 1, _r = Je[xn];
          if (g(_r, Et) > 0)
            Je[xn] = Et, Je[kn] = _r, kn = xn;
          else
            return;
        }
      }
      function p(Je, Et, nn) {
        for (var kn = nn, xn = Je.length, _r = xn >>> 1; kn < _r; ) {
          var ur = (kn + 1) * 2 - 1, hi = Je[ur], pn = ur + 1, gi = Je[pn];
          if (g(hi, Et) < 0)
            pn < xn && g(gi, hi) < 0 ? (Je[kn] = gi, Je[pn] = Et, kn = pn) : (Je[kn] = hi, Je[ur] = Et, kn = ur);
          else if (pn < xn && g(gi, Et) < 0)
            Je[kn] = gi, Je[pn] = Et, kn = pn;
          else
            return;
        }
      }
      function g(Je, Et) {
        var nn = Je.sortIndex - Et.sortIndex;
        return nn !== 0 ? nn : Je.id - Et.id;
      }
      var y = 1, v = 2, S = 3, x = 4, _ = 5;
      function T(Je, Et) {
      }
      var I = typeof performance == "object" && typeof performance.now == "function";
      if (I) {
        var D = performance;
        t.unstable_now = function() {
          return D.now();
        };
      } else {
        var N = Date, j = N.now();
        t.unstable_now = function() {
          return N.now() - j;
        };
      }
      var L = 1073741823, z = -1, F = 250, K = 5e3, X = 1e4, se = L, ue = [], pe = [], Pe = 1, ve = null, Y = S, le = !1, Re = !1, he = !1, te = typeof setTimeout == "function" ? setTimeout : null, de = typeof clearTimeout == "function" ? clearTimeout : null, W = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function fe(Je) {
        for (var Et = s(pe); Et !== null; ) {
          if (Et.callback === null)
            c(pe);
          else if (Et.startTime <= Je)
            c(pe), Et.sortIndex = Et.expirationTime, a(ue, Et);
          else
            return;
          Et = s(pe);
        }
      }
      function ce(Je) {
        if (he = !1, fe(Je), !Re)
          if (s(ue) !== null)
            Re = !0, ti(xe);
          else {
            var Et = s(pe);
            Et !== null && An(ce, Et.startTime - Je);
          }
      }
      function xe(Je, Et) {
        Re = !1, he && (he = !1, qn()), le = !0;
        var nn = Y;
        try {
          var kn;
          if (!n)
            return $e(Je, Et);
        } finally {
          ve = null, Y = nn, le = !1;
        }
      }
      function $e(Je, Et) {
        var nn = Et;
        for (fe(nn), ve = s(ue); ve !== null && !e && !(ve.expirationTime > nn && (!Je || Er())); ) {
          var kn = ve.callback;
          if (typeof kn == "function") {
            ve.callback = null, Y = ve.priorityLevel;
            var xn = ve.expirationTime <= nn, _r = kn(xn);
            nn = t.unstable_now(), typeof _r == "function" ? ve.callback = _r : ve === s(ue) && c(ue), fe(nn);
          } else
            c(ue);
          ve = s(ue);
        }
        if (ve !== null)
          return !0;
        var ur = s(pe);
        return ur !== null && An(ce, ur.startTime - nn), !1;
      }
      function Me(Je, Et) {
        switch (Je) {
          case y:
          case v:
          case S:
          case x:
          case _:
            break;
          default:
            Je = S;
        }
        var nn = Y;
        Y = Je;
        try {
          return Et();
        } finally {
          Y = nn;
        }
      }
      function re(Je) {
        var Et;
        switch (Y) {
          case y:
          case v:
          case S:
            Et = S;
            break;
          default:
            Et = Y;
            break;
        }
        var nn = Y;
        Y = Et;
        try {
          return Je();
        } finally {
          Y = nn;
        }
      }
      function Qe(Je) {
        var Et = Y;
        return function() {
          var nn = Y;
          Y = Et;
          try {
            return Je.apply(this, arguments);
          } finally {
            Y = nn;
          }
        };
      }
      function ke(Je, Et, nn) {
        var kn = t.unstable_now(), xn;
        if (typeof nn == "object" && nn !== null) {
          var _r = nn.delay;
          typeof _r == "number" && _r > 0 ? xn = kn + _r : xn = kn;
        } else
          xn = kn;
        var ur;
        switch (Je) {
          case y:
            ur = z;
            break;
          case v:
            ur = F;
            break;
          case _:
            ur = se;
            break;
          case x:
            ur = X;
            break;
          case S:
          default:
            ur = K;
            break;
        }
        var hi = xn + ur, pn = {
          id: Pe++,
          callback: Et,
          priorityLevel: Je,
          startTime: xn,
          expirationTime: hi,
          sortIndex: -1
        };
        return xn > kn ? (pn.sortIndex = xn, a(pe, pn), s(ue) === null && pn === s(pe) && (he ? qn() : he = !0, An(ce, xn - kn))) : (pn.sortIndex = hi, a(ue, pn), !Re && !le && (Re = !0, ti(xe))), pn;
      }
      function rt() {
      }
      function St() {
        !Re && !le && (Re = !0, ti(xe));
      }
      function Tt() {
        return s(ue);
      }
      function Le(Je) {
        Je.callback = null;
      }
      function Nt() {
        return Y;
      }
      var Ke = !1, yt = null, Xt = -1, kt = r, yn = -1;
      function Er() {
        var Je = t.unstable_now() - yn;
        return !(Je < kt);
      }
      function tn() {
      }
      function Mr(Je) {
        if (Je < 0 || Je > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Je > 0 ? kt = Math.floor(1e3 / Je) : kt = r;
      }
      var zr = function() {
        if (yt !== null) {
          var Je = t.unstable_now();
          yn = Je;
          var Et = !0, nn = !0;
          try {
            nn = yt(Et, Je);
          } finally {
            nn ? Hn() : (Ke = !1, yt = null);
          }
        } else
          Ke = !1;
      }, Hn;
      if (typeof W == "function")
        Hn = function() {
          W(zr);
        };
      else if (typeof MessageChannel < "u") {
        var xt = new MessageChannel(), cn = xt.port2;
        xt.port1.onmessage = zr, Hn = function() {
          cn.postMessage(null);
        };
      } else
        Hn = function() {
          te(zr, 0);
        };
      function ti(Je) {
        yt = Je, Ke || (Ke = !0, Hn());
      }
      function An(Je, Et) {
        Xt = te(function() {
          Je(t.unstable_now());
        }, Et);
      }
      function qn() {
        de(Xt), Xt = -1;
      }
      var Ko = tn, Cr = null;
      t.unstable_IdlePriority = _, t.unstable_ImmediatePriority = y, t.unstable_LowPriority = x, t.unstable_NormalPriority = S, t.unstable_Profiling = Cr, t.unstable_UserBlockingPriority = v, t.unstable_cancelCallback = Le, t.unstable_continueExecution = St, t.unstable_forceFrameRate = Mr, t.unstable_getCurrentPriorityLevel = Nt, t.unstable_getFirstCallbackNode = Tt, t.unstable_next = re, t.unstable_pauseExecution = rt, t.unstable_requestPaint = Ko, t.unstable_runWithPriority = Me, t.unstable_scheduleCallback = ke, t.unstable_shouldYield = Er, t.unstable_wrapCallback = Qe, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(hk)), hk;
}
var GD;
function Uj() {
  return GD || (GD = 1, {}.NODE_ENV === "production" ? Hw.exports = mie() : Hw.exports = vie()), Hw.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var XD;
function yie() {
  if (XD)
    return Ba;
  XD = 1;
  var t = k, e = Uj();
  function n(l) {
    for (var u = "https://reactjs.org/docs/error-decoder.html?invariant=" + l, m = 1; m < arguments.length; m++)
      u += "&args[]=" + encodeURIComponent(arguments[m]);
    return "Minified React error #" + l + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = /* @__PURE__ */ new Set(), a = {};
  function s(l, u) {
    c(l, u), c(l + "Capture", u);
  }
  function c(l, u) {
    for (a[l] = u, l = 0; l < u.length; l++)
      r.add(u[l]);
  }
  var f = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), p = Object.prototype.hasOwnProperty, g = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, y = {}, v = {};
  function S(l) {
    return p.call(v, l) ? !0 : p.call(y, l) ? !1 : g.test(l) ? v[l] = !0 : (y[l] = !0, !1);
  }
  function x(l, u, m, w) {
    if (m !== null && m.type === 0)
      return !1;
    switch (typeof u) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return w ? !1 : m !== null ? !m.acceptsBooleans : (l = l.toLowerCase().slice(0, 5), l !== "data-" && l !== "aria-");
      default:
        return !1;
    }
  }
  function _(l, u, m, w) {
    if (u === null || typeof u > "u" || x(l, u, m, w))
      return !0;
    if (w)
      return !1;
    if (m !== null)
      switch (m.type) {
        case 3:
          return !u;
        case 4:
          return u === !1;
        case 5:
          return isNaN(u);
        case 6:
          return isNaN(u) || 1 > u;
      }
    return !1;
  }
  function T(l, u, m, w, P, M, H) {
    this.acceptsBooleans = u === 2 || u === 3 || u === 4, this.attributeName = w, this.attributeNamespace = P, this.mustUseProperty = m, this.propertyName = l, this.type = u, this.sanitizeURL = M, this.removeEmptyString = H;
  }
  var I = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(l) {
    I[l] = new T(l, 0, !1, l, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(l) {
    var u = l[0];
    I[u] = new T(u, 1, !1, l[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(l) {
    I[l] = new T(l, 2, !1, l.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(l) {
    I[l] = new T(l, 2, !1, l, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(l) {
    I[l] = new T(l, 3, !1, l.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(l) {
    I[l] = new T(l, 3, !0, l, null, !1, !1);
  }), ["capture", "download"].forEach(function(l) {
    I[l] = new T(l, 4, !1, l, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(l) {
    I[l] = new T(l, 6, !1, l, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(l) {
    I[l] = new T(l, 5, !1, l.toLowerCase(), null, !1, !1);
  });
  var D = /[\-:]([a-z])/g;
  function N(l) {
    return l[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(l) {
    var u = l.replace(
      D,
      N
    );
    I[u] = new T(u, 1, !1, l, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(l) {
    var u = l.replace(D, N);
    I[u] = new T(u, 1, !1, l, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(l) {
    var u = l.replace(D, N);
    I[u] = new T(u, 1, !1, l, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(l) {
    I[l] = new T(l, 1, !1, l.toLowerCase(), null, !1, !1);
  }), I.xlinkHref = new T("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(l) {
    I[l] = new T(l, 1, !1, l.toLowerCase(), null, !0, !0);
  });
  function j(l, u, m, w) {
    var P = I.hasOwnProperty(u) ? I[u] : null;
    (P !== null ? P.type !== 0 : w || !(2 < u.length) || u[0] !== "o" && u[0] !== "O" || u[1] !== "n" && u[1] !== "N") && (_(u, m, P, w) && (m = null), w || P === null ? S(u) && (m === null ? l.removeAttribute(u) : l.setAttribute(u, "" + m)) : P.mustUseProperty ? l[P.propertyName] = m === null ? P.type === 3 ? !1 : "" : m : (u = P.attributeName, w = P.attributeNamespace, m === null ? l.removeAttribute(u) : (P = P.type, m = P === 3 || P === 4 && m === !0 ? "" : "" + m, w ? l.setAttributeNS(w, u, m) : l.setAttribute(u, m))));
  }
  var L = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, z = Symbol.for("react.element"), F = Symbol.for("react.portal"), K = Symbol.for("react.fragment"), X = Symbol.for("react.strict_mode"), se = Symbol.for("react.profiler"), ue = Symbol.for("react.provider"), pe = Symbol.for("react.context"), Pe = Symbol.for("react.forward_ref"), ve = Symbol.for("react.suspense"), Y = Symbol.for("react.suspense_list"), le = Symbol.for("react.memo"), Re = Symbol.for("react.lazy"), he = Symbol.for("react.offscreen"), te = Symbol.iterator;
  function de(l) {
    return l === null || typeof l != "object" ? null : (l = te && l[te] || l["@@iterator"], typeof l == "function" ? l : null);
  }
  var W = Object.assign, fe;
  function ce(l) {
    if (fe === void 0)
      try {
        throw Error();
      } catch (m) {
        var u = m.stack.trim().match(/\n( *(at )?)/);
        fe = u && u[1] || "";
      }
    return `
` + fe + l;
  }
  var xe = !1;
  function $e(l, u) {
    if (!l || xe)
      return "";
    xe = !0;
    var m = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (u)
        if (u = function() {
          throw Error();
        }, Object.defineProperty(u.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(u, []);
          } catch (Te) {
            var w = Te;
          }
          Reflect.construct(l, [], u);
        } else {
          try {
            u.call();
          } catch (Te) {
            w = Te;
          }
          l.call(u.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Te) {
          w = Te;
        }
        l();
      }
    } catch (Te) {
      if (Te && w && typeof Te.stack == "string") {
        for (var P = Te.stack.split(`
`), M = w.stack.split(`
`), H = P.length - 1, Q = M.length - 1; 1 <= H && 0 <= Q && P[H] !== M[Q]; )
          Q--;
        for (; 1 <= H && 0 <= Q; H--, Q--)
          if (P[H] !== M[Q]) {
            if (H !== 1 || Q !== 1)
              do
                if (H--, Q--, 0 > Q || P[H] !== M[Q]) {
                  var ee = `
` + P[H].replace(" at new ", " at ");
                  return l.displayName && ee.includes("<anonymous>") && (ee = ee.replace("<anonymous>", l.displayName)), ee;
                }
              while (1 <= H && 0 <= Q);
            break;
          }
      }
    } finally {
      xe = !1, Error.prepareStackTrace = m;
    }
    return (l = l ? l.displayName || l.name : "") ? ce(l) : "";
  }
  function Me(l) {
    switch (l.tag) {
      case 5:
        return ce(l.type);
      case 16:
        return ce("Lazy");
      case 13:
        return ce("Suspense");
      case 19:
        return ce("SuspenseList");
      case 0:
      case 2:
      case 15:
        return l = $e(l.type, !1), l;
      case 11:
        return l = $e(l.type.render, !1), l;
      case 1:
        return l = $e(l.type, !0), l;
      default:
        return "";
    }
  }
  function re(l) {
    if (l == null)
      return null;
    if (typeof l == "function")
      return l.displayName || l.name || null;
    if (typeof l == "string")
      return l;
    switch (l) {
      case K:
        return "Fragment";
      case F:
        return "Portal";
      case se:
        return "Profiler";
      case X:
        return "StrictMode";
      case ve:
        return "Suspense";
      case Y:
        return "SuspenseList";
    }
    if (typeof l == "object")
      switch (l.$$typeof) {
        case pe:
          return (l.displayName || "Context") + ".Consumer";
        case ue:
          return (l._context.displayName || "Context") + ".Provider";
        case Pe:
          var u = l.render;
          return l = l.displayName, l || (l = u.displayName || u.name || "", l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef"), l;
        case le:
          return u = l.displayName || null, u !== null ? u : re(l.type) || "Memo";
        case Re:
          u = l._payload, l = l._init;
          try {
            return re(l(u));
          } catch {
          }
      }
    return null;
  }
  function Qe(l) {
    var u = l.type;
    switch (l.tag) {
      case 24:
        return "Cache";
      case 9:
        return (u.displayName || "Context") + ".Consumer";
      case 10:
        return (u._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return l = u.render, l = l.displayName || l.name || "", u.displayName || (l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return u;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return re(u);
      case 8:
        return u === X ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof u == "function")
          return u.displayName || u.name || null;
        if (typeof u == "string")
          return u;
    }
    return null;
  }
  function ke(l) {
    switch (typeof l) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return l;
      case "object":
        return l;
      default:
        return "";
    }
  }
  function rt(l) {
    var u = l.type;
    return (l = l.nodeName) && l.toLowerCase() === "input" && (u === "checkbox" || u === "radio");
  }
  function St(l) {
    var u = rt(l) ? "checked" : "value", m = Object.getOwnPropertyDescriptor(l.constructor.prototype, u), w = "" + l[u];
    if (!l.hasOwnProperty(u) && typeof m < "u" && typeof m.get == "function" && typeof m.set == "function") {
      var P = m.get, M = m.set;
      return Object.defineProperty(l, u, { configurable: !0, get: function() {
        return P.call(this);
      }, set: function(H) {
        w = "" + H, M.call(this, H);
      } }), Object.defineProperty(l, u, { enumerable: m.enumerable }), { getValue: function() {
        return w;
      }, setValue: function(H) {
        w = "" + H;
      }, stopTracking: function() {
        l._valueTracker = null, delete l[u];
      } };
    }
  }
  function Tt(l) {
    l._valueTracker || (l._valueTracker = St(l));
  }
  function Le(l) {
    if (!l)
      return !1;
    var u = l._valueTracker;
    if (!u)
      return !0;
    var m = u.getValue(), w = "";
    return l && (w = rt(l) ? l.checked ? "true" : "false" : l.value), l = w, l !== m ? (u.setValue(l), !0) : !1;
  }
  function Nt(l) {
    if (l = l || (typeof document < "u" ? document : void 0), typeof l > "u")
      return null;
    try {
      return l.activeElement || l.body;
    } catch {
      return l.body;
    }
  }
  function Ke(l, u) {
    var m = u.checked;
    return W({}, u, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: m ?? l._wrapperState.initialChecked });
  }
  function yt(l, u) {
    var m = u.defaultValue == null ? "" : u.defaultValue, w = u.checked != null ? u.checked : u.defaultChecked;
    m = ke(u.value != null ? u.value : m), l._wrapperState = { initialChecked: w, initialValue: m, controlled: u.type === "checkbox" || u.type === "radio" ? u.checked != null : u.value != null };
  }
  function Xt(l, u) {
    u = u.checked, u != null && j(l, "checked", u, !1);
  }
  function kt(l, u) {
    Xt(l, u);
    var m = ke(u.value), w = u.type;
    if (m != null)
      w === "number" ? (m === 0 && l.value === "" || l.value != m) && (l.value = "" + m) : l.value !== "" + m && (l.value = "" + m);
    else if (w === "submit" || w === "reset") {
      l.removeAttribute("value");
      return;
    }
    u.hasOwnProperty("value") ? Er(l, u.type, m) : u.hasOwnProperty("defaultValue") && Er(l, u.type, ke(u.defaultValue)), u.checked == null && u.defaultChecked != null && (l.defaultChecked = !!u.defaultChecked);
  }
  function yn(l, u, m) {
    if (u.hasOwnProperty("value") || u.hasOwnProperty("defaultValue")) {
      var w = u.type;
      if (!(w !== "submit" && w !== "reset" || u.value !== void 0 && u.value !== null))
        return;
      u = "" + l._wrapperState.initialValue, m || u === l.value || (l.value = u), l.defaultValue = u;
    }
    m = l.name, m !== "" && (l.name = ""), l.defaultChecked = !!l._wrapperState.initialChecked, m !== "" && (l.name = m);
  }
  function Er(l, u, m) {
    (u !== "number" || Nt(l.ownerDocument) !== l) && (m == null ? l.defaultValue = "" + l._wrapperState.initialValue : l.defaultValue !== "" + m && (l.defaultValue = "" + m));
  }
  var tn = Array.isArray;
  function Mr(l, u, m, w) {
    if (l = l.options, u) {
      u = {};
      for (var P = 0; P < m.length; P++)
        u["$" + m[P]] = !0;
      for (m = 0; m < l.length; m++)
        P = u.hasOwnProperty("$" + l[m].value), l[m].selected !== P && (l[m].selected = P), P && w && (l[m].defaultSelected = !0);
    } else {
      for (m = "" + ke(m), u = null, P = 0; P < l.length; P++) {
        if (l[P].value === m) {
          l[P].selected = !0, w && (l[P].defaultSelected = !0);
          return;
        }
        u !== null || l[P].disabled || (u = l[P]);
      }
      u !== null && (u.selected = !0);
    }
  }
  function zr(l, u) {
    if (u.dangerouslySetInnerHTML != null)
      throw Error(n(91));
    return W({}, u, { value: void 0, defaultValue: void 0, children: "" + l._wrapperState.initialValue });
  }
  function Hn(l, u) {
    var m = u.value;
    if (m == null) {
      if (m = u.children, u = u.defaultValue, m != null) {
        if (u != null)
          throw Error(n(92));
        if (tn(m)) {
          if (1 < m.length)
            throw Error(n(93));
          m = m[0];
        }
        u = m;
      }
      u == null && (u = ""), m = u;
    }
    l._wrapperState = { initialValue: ke(m) };
  }
  function xt(l, u) {
    var m = ke(u.value), w = ke(u.defaultValue);
    m != null && (m = "" + m, m !== l.value && (l.value = m), u.defaultValue == null && l.defaultValue !== m && (l.defaultValue = m)), w != null && (l.defaultValue = "" + w);
  }
  function cn(l) {
    var u = l.textContent;
    u === l._wrapperState.initialValue && u !== "" && u !== null && (l.value = u);
  }
  function ti(l) {
    switch (l) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function An(l, u) {
    return l == null || l === "http://www.w3.org/1999/xhtml" ? ti(u) : l === "http://www.w3.org/2000/svg" && u === "foreignObject" ? "http://www.w3.org/1999/xhtml" : l;
  }
  var qn, Ko = function(l) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(u, m, w, P) {
      MSApp.execUnsafeLocalFunction(function() {
        return l(u, m, w, P);
      });
    } : l;
  }(function(l, u) {
    if (l.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in l)
      l.innerHTML = u;
    else {
      for (qn = qn || document.createElement("div"), qn.innerHTML = "<svg>" + u.valueOf().toString() + "</svg>", u = qn.firstChild; l.firstChild; )
        l.removeChild(l.firstChild);
      for (; u.firstChild; )
        l.appendChild(u.firstChild);
    }
  });
  function Cr(l, u) {
    if (u) {
      var m = l.firstChild;
      if (m && m === l.lastChild && m.nodeType === 3) {
        m.nodeValue = u;
        return;
      }
    }
    l.textContent = u;
  }
  var Je = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, Et = ["Webkit", "ms", "Moz", "O"];
  Object.keys(Je).forEach(function(l) {
    Et.forEach(function(u) {
      u = u + l.charAt(0).toUpperCase() + l.substring(1), Je[u] = Je[l];
    });
  });
  function nn(l, u, m) {
    return u == null || typeof u == "boolean" || u === "" ? "" : m || typeof u != "number" || u === 0 || Je.hasOwnProperty(l) && Je[l] ? ("" + u).trim() : u + "px";
  }
  function kn(l, u) {
    l = l.style;
    for (var m in u)
      if (u.hasOwnProperty(m)) {
        var w = m.indexOf("--") === 0, P = nn(m, u[m], w);
        m === "float" && (m = "cssFloat"), w ? l.setProperty(m, P) : l[m] = P;
      }
  }
  var xn = W({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function _r(l, u) {
    if (u) {
      if (xn[l] && (u.children != null || u.dangerouslySetInnerHTML != null))
        throw Error(n(137, l));
      if (u.dangerouslySetInnerHTML != null) {
        if (u.children != null)
          throw Error(n(60));
        if (typeof u.dangerouslySetInnerHTML != "object" || !("__html" in u.dangerouslySetInnerHTML))
          throw Error(n(61));
      }
      if (u.style != null && typeof u.style != "object")
        throw Error(n(62));
    }
  }
  function ur(l, u) {
    if (l.indexOf("-") === -1)
      return typeof u.is == "string";
    switch (l) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var hi = null;
  function pn(l) {
    return l = l.target || l.srcElement || window, l.correspondingUseElement && (l = l.correspondingUseElement), l.nodeType === 3 ? l.parentNode : l;
  }
  var gi = null, On = null, Dn = null;
  function io(l) {
    if (l = Tf(l)) {
      if (typeof gi != "function")
        throw Error(n(280));
      var u = l.stateNode;
      u && (u = Mt(u), gi(l.stateNode, l.type, u));
    }
  }
  function mi(l) {
    On ? Dn ? Dn.push(l) : Dn = [l] : On = l;
  }
  function ya() {
    if (On) {
      var l = On, u = Dn;
      if (Dn = On = null, io(l), u)
        for (l = 0; l < u.length; l++)
          io(u[l]);
    }
  }
  function Xa(l, u) {
    return l(u);
  }
  function gs() {
  }
  var oo = !1;
  function ms(l, u, m) {
    if (oo)
      return l(u, m);
    oo = !0;
    try {
      return Xa(l, u, m);
    } finally {
      oo = !1, (On !== null || Dn !== null) && (gs(), ya());
    }
  }
  function ao(l, u) {
    var m = l.stateNode;
    if (m === null)
      return null;
    var w = Mt(m);
    if (w === null)
      return null;
    m = w[u];
    e:
      switch (u) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (w = !w.disabled) || (l = l.type, w = !(l === "button" || l === "input" || l === "select" || l === "textarea")), l = !w;
          break e;
        default:
          l = !1;
      }
    if (l)
      return null;
    if (m && typeof m != "function")
      throw Error(n(231, u, typeof m));
    return m;
  }
  var ba = !1;
  if (f)
    try {
      var so = {};
      Object.defineProperty(so, "passive", { get: function() {
        ba = !0;
      } }), window.addEventListener("test", so, so), window.removeEventListener("test", so, so);
    } catch {
      ba = !1;
    }
  function Sa(l, u, m, w, P, M, H, Q, ee) {
    var Te = Array.prototype.slice.call(arguments, 3);
    try {
      u.apply(m, Te);
    } catch (Ve) {
      this.onError(Ve);
    }
  }
  var vi = !1, Ri = null, yi = !1, J = null, Be = { onError: function(l) {
    vi = !0, Ri = l;
  } };
  function et(l, u, m, w, P, M, H, Q, ee) {
    vi = !1, Ri = null, Sa.apply(Be, arguments);
  }
  function st(l, u, m, w, P, M, H, Q, ee) {
    if (et.apply(this, arguments), vi) {
      if (vi) {
        var Te = Ri;
        vi = !1, Ri = null;
      } else
        throw Error(n(198));
      yi || (yi = !0, J = Te);
    }
  }
  function Kt(l) {
    var u = l, m = l;
    if (l.alternate)
      for (; u.return; )
        u = u.return;
    else {
      l = u;
      do
        u = l, u.flags & 4098 && (m = u.return), l = u.return;
      while (l);
    }
    return u.tag === 3 ? m : null;
  }
  function qt(l) {
    if (l.tag === 13) {
      var u = l.memoizedState;
      if (u === null && (l = l.alternate, l !== null && (u = l.memoizedState)), u !== null)
        return u.dehydrated;
    }
    return null;
  }
  function Qt(l) {
    if (Kt(l) !== l)
      throw Error(n(188));
  }
  function Rt(l) {
    var u = l.alternate;
    if (!u) {
      if (u = Kt(l), u === null)
        throw Error(n(188));
      return u !== l ? null : l;
    }
    for (var m = l, w = u; ; ) {
      var P = m.return;
      if (P === null)
        break;
      var M = P.alternate;
      if (M === null) {
        if (w = P.return, w !== null) {
          m = w;
          continue;
        }
        break;
      }
      if (P.child === M.child) {
        for (M = P.child; M; ) {
          if (M === m)
            return Qt(P), l;
          if (M === w)
            return Qt(P), u;
          M = M.sibling;
        }
        throw Error(n(188));
      }
      if (m.return !== w.return)
        m = P, w = M;
      else {
        for (var H = !1, Q = P.child; Q; ) {
          if (Q === m) {
            H = !0, m = P, w = M;
            break;
          }
          if (Q === w) {
            H = !0, w = P, m = M;
            break;
          }
          Q = Q.sibling;
        }
        if (!H) {
          for (Q = M.child; Q; ) {
            if (Q === m) {
              H = !0, m = M, w = P;
              break;
            }
            if (Q === w) {
              H = !0, w = M, m = P;
              break;
            }
            Q = Q.sibling;
          }
          if (!H)
            throw Error(n(189));
        }
      }
      if (m.alternate !== w)
        throw Error(n(190));
    }
    if (m.tag !== 3)
      throw Error(n(188));
    return m.stateNode.current === m ? l : u;
  }
  function Ur(l) {
    return l = Rt(l), l !== null ? Qn(l) : null;
  }
  function Qn(l) {
    if (l.tag === 5 || l.tag === 6)
      return l;
    for (l = l.child; l !== null; ) {
      var u = Qn(l);
      if (u !== null)
        return u;
      l = l.sibling;
    }
    return null;
  }
  var Zn = e.unstable_scheduleCallback, hr = e.unstable_cancelCallback, wa = e.unstable_shouldYield, Nl = e.unstable_requestPaint, bn = e.unstable_now, df = e.unstable_getCurrentPriorityLevel, Wo = e.unstable_ImmediatePriority, Jt = e.unstable_UserBlockingPriority, xa = e.unstable_NormalPriority, vs = e.unstable_LowPriority, lo = e.unstable_IdlePriority, ys = null, Ki = null;
  function Nc(l) {
    if (Ki && typeof Ki.onCommitFiberRoot == "function")
      try {
        Ki.onCommitFiberRoot(ys, l, void 0, (l.current.flags & 128) === 128);
      } catch {
      }
  }
  var $i = Math.clz32 ? Math.clz32 : Xs, Lc = Math.log, jc = Math.LN2;
  function Xs(l) {
    return l >>>= 0, l === 0 ? 32 : 31 - (Lc(l) / jc | 0) | 0;
  }
  var Ll = 64, To = 4194304;
  function ko(l) {
    switch (l & -l) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return l & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return l;
    }
  }
  function bi(l, u) {
    var m = l.pendingLanes;
    if (m === 0)
      return 0;
    var w = 0, P = l.suspendedLanes, M = l.pingedLanes, H = m & 268435455;
    if (H !== 0) {
      var Q = H & ~P;
      Q !== 0 ? w = ko(Q) : (M &= H, M !== 0 && (w = ko(M)));
    } else
      H = m & ~P, H !== 0 ? w = ko(H) : M !== 0 && (w = ko(M));
    if (w === 0)
      return 0;
    if (u !== 0 && u !== w && !(u & P) && (P = w & -w, M = u & -u, P >= M || P === 16 && (M & 4194240) !== 0))
      return u;
    if (w & 4 && (w |= m & 16), u = l.entangledLanes, u !== 0)
      for (l = l.entanglements, u &= w; 0 < u; )
        m = 31 - $i(u), P = 1 << m, w |= l[m], u &= ~P;
    return w;
  }
  function bs(l, u) {
    switch (l) {
      case 1:
      case 2:
      case 4:
        return u + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return u + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Ss(l, u) {
    for (var m = l.suspendedLanes, w = l.pingedLanes, P = l.expirationTimes, M = l.pendingLanes; 0 < M; ) {
      var H = 31 - $i(M), Q = 1 << H, ee = P[H];
      ee === -1 ? (!(Q & m) || Q & w) && (P[H] = bs(Q, u)) : ee <= u && (l.expiredLanes |= Q), M &= ~Q;
    }
  }
  function ws(l) {
    return l = l.pendingLanes & -1073741825, l !== 0 ? l : l & 1073741824 ? 1073741824 : 0;
  }
  function jl() {
    var l = Ll;
    return Ll <<= 1, !(Ll & 4194240) && (Ll = 64), l;
  }
  function qs(l) {
    for (var u = [], m = 0; 31 > m; m++)
      u.push(l);
    return u;
  }
  function qa(l, u, m) {
    l.pendingLanes |= u, u !== 536870912 && (l.suspendedLanes = 0, l.pingedLanes = 0), l = l.eventTimes, u = 31 - $i(u), l[u] = m;
  }
  function ff(l, u) {
    var m = l.pendingLanes & ~u;
    l.pendingLanes = u, l.suspendedLanes = 0, l.pingedLanes = 0, l.expiredLanes &= u, l.mutableReadLanes &= u, l.entangledLanes &= u, u = l.entanglements;
    var w = l.eventTimes;
    for (l = l.expirationTimes; 0 < m; ) {
      var P = 31 - $i(m), M = 1 << P;
      u[P] = 0, w[P] = -1, l[P] = -1, m &= ~M;
    }
  }
  function Go(l, u) {
    var m = l.entangledLanes |= u;
    for (l = l.entanglements; m; ) {
      var w = 31 - $i(m), P = 1 << w;
      P & u | l[w] & u && (l[w] |= u), m &= ~P;
    }
  }
  var hn = 0;
  function Xo(l) {
    return l &= -l, 1 < l ? 4 < l ? l & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var Qs, zl, rn, Ul, Bl, Ft = !1, Zs = [], gr = null, Br = null, Si = null, xs = /* @__PURE__ */ new Map(), or = /* @__PURE__ */ new Map(), Nn = [], Fl = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Wi(l, u) {
    switch (l) {
      case "focusin":
      case "focusout":
        gr = null;
        break;
      case "dragenter":
      case "dragleave":
        Br = null;
        break;
      case "mouseover":
      case "mouseout":
        Si = null;
        break;
      case "pointerover":
      case "pointerout":
        xs.delete(u.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        or.delete(u.pointerId);
    }
  }
  function Wr(l, u, m, w, P, M) {
    return l === null || l.nativeEvent !== M ? (l = { blockedOn: u, domEventName: m, eventSystemFlags: w, nativeEvent: M, targetContainers: [P] }, u !== null && (u = Tf(u), u !== null && zl(u)), l) : (l.eventSystemFlags |= w, u = l.targetContainers, P !== null && u.indexOf(P) === -1 && u.push(P), l);
  }
  function qo(l, u, m, w, P) {
    switch (u) {
      case "focusin":
        return gr = Wr(gr, l, u, m, w, P), !0;
      case "dragenter":
        return Br = Wr(Br, l, u, m, w, P), !0;
      case "mouseover":
        return Si = Wr(Si, l, u, m, w, P), !0;
      case "pointerover":
        var M = P.pointerId;
        return xs.set(M, Wr(xs.get(M) || null, l, u, m, w, P)), !0;
      case "gotpointercapture":
        return M = P.pointerId, or.set(M, Wr(or.get(M) || null, l, u, m, w, P)), !0;
    }
    return !1;
  }
  function zc(l) {
    var u = Ca(l.target);
    if (u !== null) {
      var m = Kt(u);
      if (m !== null) {
        if (u = m.tag, u === 13) {
          if (u = qt(m), u !== null) {
            l.blockedOn = u, Bl(l.priority, function() {
              rn(m);
            });
            return;
          }
        } else if (u === 3 && m.stateNode.current.memoizedState.isDehydrated) {
          l.blockedOn = m.tag === 3 ? m.stateNode.containerInfo : null;
          return;
        }
      }
    }
    l.blockedOn = null;
  }
  function co(l) {
    if (l.blockedOn !== null)
      return !1;
    for (var u = l.targetContainers; 0 < u.length; ) {
      var m = Kn(l.domEventName, l.eventSystemFlags, u[0], l.nativeEvent);
      if (m === null) {
        m = l.nativeEvent;
        var w = new m.constructor(m.type, m);
        hi = w, m.target.dispatchEvent(w), hi = null;
      } else
        return u = Tf(m), u !== null && zl(u), l.blockedOn = m, !1;
      u.shift();
    }
    return !0;
  }
  function Qa(l, u, m) {
    co(l) && m.delete(u);
  }
  function Fu() {
    Ft = !1, gr !== null && co(gr) && (gr = null), Br !== null && co(Br) && (Br = null), Si !== null && co(Si) && (Si = null), xs.forEach(Qa), or.forEach(Qa);
  }
  function Po(l, u) {
    l.blockedOn === u && (l.blockedOn = null, Ft || (Ft = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, Fu)));
  }
  function Es(l) {
    function u(P) {
      return Po(P, l);
    }
    if (0 < Zs.length) {
      Po(Zs[0], l);
      for (var m = 1; m < Zs.length; m++) {
        var w = Zs[m];
        w.blockedOn === l && (w.blockedOn = null);
      }
    }
    for (gr !== null && Po(gr, l), Br !== null && Po(Br, l), Si !== null && Po(Si, l), xs.forEach(u), or.forEach(u), m = 0; m < Nn.length; m++)
      w = Nn[m], w.blockedOn === l && (w.blockedOn = null);
    for (; 0 < Nn.length && (m = Nn[0], m.blockedOn === null); )
      zc(m), m.blockedOn === null && Nn.shift();
  }
  var q = L.ReactCurrentBatchConfig, ie = !0;
  function Ue(l, u, m, w) {
    var P = hn, M = q.transition;
    q.transition = null;
    try {
      hn = 1, Pn(l, u, m, w);
    } finally {
      hn = P, q.transition = M;
    }
  }
  function it(l, u, m, w) {
    var P = hn, M = q.transition;
    q.transition = null;
    try {
      hn = 4, Pn(l, u, m, w);
    } finally {
      hn = P, q.transition = M;
    }
  }
  function Pn(l, u, m, w) {
    if (ie) {
      var P = Kn(l, u, m, w);
      if (P === null)
        Qp(l, u, w, Ut, m), Wi(l, w);
      else if (qo(P, l, u, m, w))
        w.stopPropagation();
      else if (Wi(l, w), u & 4 && -1 < Fl.indexOf(l)) {
        for (; P !== null; ) {
          var M = Tf(P);
          if (M !== null && Qs(M), M = Kn(l, u, m, w), M === null && Qp(l, u, w, Ut, m), M === P)
            break;
          P = M;
        }
        P !== null && w.stopPropagation();
      } else
        Qp(l, u, w, null, m);
    }
  }
  var Ut = null;
  function Kn(l, u, m, w) {
    if (Ut = null, l = pn(w), l = Ca(l), l !== null)
      if (u = Kt(l), u === null)
        l = null;
      else if (m = u.tag, m === 13) {
        if (l = qt(u), l !== null)
          return l;
        l = null;
      } else if (m === 3) {
        if (u.stateNode.current.memoizedState.isDehydrated)
          return u.tag === 3 ? u.stateNode.containerInfo : null;
        l = null;
      } else
        u !== l && (l = null);
    return Ut = l, null;
  }
  function Tr(l) {
    switch (l) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (df()) {
          case Wo:
            return 1;
          case Jt:
            return 4;
          case xa:
          case vs:
            return 16;
          case lo:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Wn = null, U = null, Z = null;
  function ye() {
    if (Z)
      return Z;
    var l, u = U, m = u.length, w, P = "value" in Wn ? Wn.value : Wn.textContent, M = P.length;
    for (l = 0; l < m && u[l] === P[l]; l++)
      ;
    var H = m - l;
    for (w = 1; w <= H && u[m - w] === P[M - w]; w++)
      ;
    return Z = P.slice(l, 1 < w ? 1 - w : void 0);
  }
  function Ee(l) {
    var u = l.keyCode;
    return "charCode" in l ? (l = l.charCode, l === 0 && u === 13 && (l = 13)) : l = u, l === 10 && (l = 13), 32 <= l || l === 13 ? l : 0;
  }
  function Fe() {
    return !0;
  }
  function ht() {
    return !1;
  }
  function Ze(l) {
    function u(m, w, P, M, H) {
      this._reactName = m, this._targetInst = P, this.type = w, this.nativeEvent = M, this.target = H, this.currentTarget = null;
      for (var Q in l)
        l.hasOwnProperty(Q) && (m = l[Q], this[Q] = m ? m(M) : M[Q]);
      return this.isDefaultPrevented = (M.defaultPrevented != null ? M.defaultPrevented : M.returnValue === !1) ? Fe : ht, this.isPropagationStopped = ht, this;
    }
    return W(u.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var m = this.nativeEvent;
      m && (m.preventDefault ? m.preventDefault() : typeof m.returnValue != "unknown" && (m.returnValue = !1), this.isDefaultPrevented = Fe);
    }, stopPropagation: function() {
      var m = this.nativeEvent;
      m && (m.stopPropagation ? m.stopPropagation() : typeof m.cancelBubble != "unknown" && (m.cancelBubble = !0), this.isPropagationStopped = Fe);
    }, persist: function() {
    }, isPersistent: Fe }), u;
  }
  var bt = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(l) {
    return l.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, Yt = Ze(bt), gn = W({}, bt, { view: 0, detail: 0 }), Ln = Ze(gn), In, ar, dr, Sn = W({}, gn, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Sm, button: 0, buttons: 0, relatedTarget: function(l) {
    return l.relatedTarget === void 0 ? l.fromElement === l.srcElement ? l.toElement : l.fromElement : l.relatedTarget;
  }, movementX: function(l) {
    return "movementX" in l ? l.movementX : (l !== dr && (dr && l.type === "mousemove" ? (In = l.screenX - dr.screenX, ar = l.screenY - dr.screenY) : ar = In = 0, dr = l), In);
  }, movementY: function(l) {
    return "movementY" in l ? l.movementY : ar;
  } }), Js = Ze(Sn), Hu = W({}, Sn, { dataTransfer: 0 }), pf = Ze(Hu), mm = W({}, gn, { relatedTarget: 0 }), Za = Ze(mm), hf = W({}, bt, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), gf = Ze(hf), vm = W({}, bt, { clipboardData: function(l) {
    return "clipboardData" in l ? l.clipboardData : window.clipboardData;
  } }), V1 = Ze(vm), Y1 = W({}, bt, { data: 0 }), ym = Ze(Y1), bm = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nb = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Lb = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function jb(l) {
    var u = this.nativeEvent;
    return u.getModifierState ? u.getModifierState(l) : (l = Lb[l]) ? !!u[l] : !1;
  }
  function Sm() {
    return jb;
  }
  var el = W({}, gn, { key: function(l) {
    if (l.key) {
      var u = bm[l.key] || l.key;
      if (u !== "Unidentified")
        return u;
    }
    return l.type === "keypress" ? (l = Ee(l), l === 13 ? "Enter" : String.fromCharCode(l)) : l.type === "keydown" || l.type === "keyup" ? Nb[l.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Sm, charCode: function(l) {
    return l.type === "keypress" ? Ee(l) : 0;
  }, keyCode: function(l) {
    return l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0;
  }, which: function(l) {
    return l.type === "keypress" ? Ee(l) : l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0;
  } }), K1 = Ze(el), wm = W({}, Sn, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Hp = Ze(wm), xm = W({}, gn, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Sm }), W1 = Ze(xm), Vp = W({}, bt, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), zb = Ze(Vp), Io = W({}, Sn, {
    deltaX: function(l) {
      return "deltaX" in l ? l.deltaX : "wheelDeltaX" in l ? -l.wheelDeltaX : 0;
    },
    deltaY: function(l) {
      return "deltaY" in l ? l.deltaY : "wheelDeltaY" in l ? -l.wheelDeltaY : "wheelDelta" in l ? -l.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), tl = Ze(Io), ni = [9, 13, 27, 32], Ja = f && "CompositionEvent" in window, Uc = null;
  f && "documentMode" in document && (Uc = document.documentMode);
  var Yp = f && "TextEvent" in window && !Uc, Ub = f && (!Ja || Uc && 8 < Uc && 11 >= Uc), Vu = String.fromCharCode(32), Bb = !1;
  function Fb(l, u) {
    switch (l) {
      case "keyup":
        return ni.indexOf(u.keyCode) !== -1;
      case "keydown":
        return u.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Kp(l) {
    return l = l.detail, typeof l == "object" && "data" in l ? l.data : null;
  }
  var Yu = !1;
  function G1(l, u) {
    switch (l) {
      case "compositionend":
        return Kp(u);
      case "keypress":
        return u.which !== 32 ? null : (Bb = !0, Vu);
      case "textInput":
        return l = u.data, l === Vu && Bb ? null : l;
      default:
        return null;
    }
  }
  function X1(l, u) {
    if (Yu)
      return l === "compositionend" || !Ja && Fb(l, u) ? (l = ye(), Z = U = Wn = null, Yu = !1, l) : null;
    switch (l) {
      case "paste":
        return null;
      case "keypress":
        if (!(u.ctrlKey || u.altKey || u.metaKey) || u.ctrlKey && u.altKey) {
          if (u.char && 1 < u.char.length)
            return u.char;
          if (u.which)
            return String.fromCharCode(u.which);
        }
        return null;
      case "compositionend":
        return Ub && u.locale !== "ko" ? null : u.data;
      default:
        return null;
    }
  }
  var Hb = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function Vb(l) {
    var u = l && l.nodeName && l.nodeName.toLowerCase();
    return u === "input" ? !!Hb[l.type] : u === "textarea";
  }
  function Yb(l, u, m, w) {
    mi(w), u = Ef(u, "onChange"), 0 < u.length && (m = new Yt("onChange", "change", null, m, w), l.push({ event: m, listeners: u }));
  }
  var mf = null, Ku = null;
  function Wu(l) {
    qp(l, 0);
  }
  function Gu(l) {
    var u = qu(l);
    if (Le(u))
      return l;
  }
  function Kb(l, u) {
    if (l === "change")
      return u;
  }
  var Em = !1;
  if (f) {
    var Cm;
    if (f) {
      var _m = "oninput" in document;
      if (!_m) {
        var Wb = document.createElement("div");
        Wb.setAttribute("oninput", "return;"), _m = typeof Wb.oninput == "function";
      }
      Cm = _m;
    } else
      Cm = !1;
    Em = Cm && (!document.documentMode || 9 < document.documentMode);
  }
  function Gb() {
    mf && (mf.detachEvent("onpropertychange", Xb), Ku = mf = null);
  }
  function Xb(l) {
    if (l.propertyName === "value" && Gu(Ku)) {
      var u = [];
      Yb(u, Ku, l, pn(l)), ms(Wu, u);
    }
  }
  function q1(l, u, m) {
    l === "focusin" ? (Gb(), mf = u, Ku = m, mf.attachEvent("onpropertychange", Xb)) : l === "focusout" && Gb();
  }
  function Q1(l) {
    if (l === "selectionchange" || l === "keyup" || l === "keydown")
      return Gu(Ku);
  }
  function Z1(l, u) {
    if (l === "click")
      return Gu(u);
  }
  function qb(l, u) {
    if (l === "input" || l === "change")
      return Gu(u);
  }
  function J1(l, u) {
    return l === u && (l !== 0 || 1 / l === 1 / u) || l !== l && u !== u;
  }
  var Ea = typeof Object.is == "function" ? Object.is : J1;
  function vf(l, u) {
    if (Ea(l, u))
      return !0;
    if (typeof l != "object" || l === null || typeof u != "object" || u === null)
      return !1;
    var m = Object.keys(l), w = Object.keys(u);
    if (m.length !== w.length)
      return !1;
    for (w = 0; w < m.length; w++) {
      var P = m[w];
      if (!p.call(u, P) || !Ea(l[P], u[P]))
        return !1;
    }
    return !0;
  }
  function Qb(l) {
    for (; l && l.firstChild; )
      l = l.firstChild;
    return l;
  }
  function Zb(l, u) {
    var m = Qb(l);
    l = 0;
    for (var w; m; ) {
      if (m.nodeType === 3) {
        if (w = l + m.textContent.length, l <= u && w >= u)
          return { node: m, offset: u - l };
        l = w;
      }
      e: {
        for (; m; ) {
          if (m.nextSibling) {
            m = m.nextSibling;
            break e;
          }
          m = m.parentNode;
        }
        m = void 0;
      }
      m = Qb(m);
    }
  }
  function Jb(l, u) {
    return l && u ? l === u ? !0 : l && l.nodeType === 3 ? !1 : u && u.nodeType === 3 ? Jb(l, u.parentNode) : "contains" in l ? l.contains(u) : l.compareDocumentPosition ? !!(l.compareDocumentPosition(u) & 16) : !1 : !1;
  }
  function Wp() {
    for (var l = window, u = Nt(); u instanceof l.HTMLIFrameElement; ) {
      try {
        var m = typeof u.contentWindow.location.href == "string";
      } catch {
        m = !1;
      }
      if (m)
        l = u.contentWindow;
      else
        break;
      u = Nt(l.document);
    }
    return u;
  }
  function nl(l) {
    var u = l && l.nodeName && l.nodeName.toLowerCase();
    return u && (u === "input" && (l.type === "text" || l.type === "search" || l.type === "tel" || l.type === "url" || l.type === "password") || u === "textarea" || l.contentEditable === "true");
  }
  function Gp(l) {
    var u = Wp(), m = l.focusedElem, w = l.selectionRange;
    if (u !== m && m && m.ownerDocument && Jb(m.ownerDocument.documentElement, m)) {
      if (w !== null && nl(m)) {
        if (u = w.start, l = w.end, l === void 0 && (l = u), "selectionStart" in m)
          m.selectionStart = u, m.selectionEnd = Math.min(l, m.value.length);
        else if (l = (u = m.ownerDocument || document) && u.defaultView || window, l.getSelection) {
          l = l.getSelection();
          var P = m.textContent.length, M = Math.min(w.start, P);
          w = w.end === void 0 ? M : Math.min(w.end, P), !l.extend && M > w && (P = w, w = M, M = P), P = Zb(m, M);
          var H = Zb(
            m,
            w
          );
          P && H && (l.rangeCount !== 1 || l.anchorNode !== P.node || l.anchorOffset !== P.offset || l.focusNode !== H.node || l.focusOffset !== H.offset) && (u = u.createRange(), u.setStart(P.node, P.offset), l.removeAllRanges(), M > w ? (l.addRange(u), l.extend(H.node, H.offset)) : (u.setEnd(H.node, H.offset), l.addRange(u)));
        }
      }
      for (u = [], l = m; l = l.parentNode; )
        l.nodeType === 1 && u.push({ element: l, left: l.scrollLeft, top: l.scrollTop });
      for (typeof m.focus == "function" && m.focus(), m = 0; m < u.length; m++)
        l = u[m], l.element.scrollLeft = l.left, l.element.scrollTop = l.top;
    }
  }
  var e0 = f && "documentMode" in document && 11 >= document.documentMode, es = null, Tm = null, yf = null, km = !1;
  function t0(l, u, m) {
    var w = m.window === m ? m.document : m.nodeType === 9 ? m : m.ownerDocument;
    km || es == null || es !== Nt(w) || (w = es, "selectionStart" in w && nl(w) ? w = { start: w.selectionStart, end: w.selectionEnd } : (w = (w.ownerDocument && w.ownerDocument.defaultView || window).getSelection(), w = { anchorNode: w.anchorNode, anchorOffset: w.anchorOffset, focusNode: w.focusNode, focusOffset: w.focusOffset }), yf && vf(yf, w) || (yf = w, w = Ef(Tm, "onSelect"), 0 < w.length && (u = new Yt("onSelect", "select", null, u, m), l.push({ event: u, listeners: w }), u.target = es)));
  }
  function Xp(l, u) {
    var m = {};
    return m[l.toLowerCase()] = u.toLowerCase(), m["Webkit" + l] = "webkit" + u, m["Moz" + l] = "moz" + u, m;
  }
  var Bc = { animationend: Xp("Animation", "AnimationEnd"), animationiteration: Xp("Animation", "AnimationIteration"), animationstart: Xp("Animation", "AnimationStart"), transitionend: Xp("Transition", "TransitionEnd") }, Pm = {}, Im = {};
  f && (Im = document.createElement("div").style, "AnimationEvent" in window || (delete Bc.animationend.animation, delete Bc.animationiteration.animation, delete Bc.animationstart.animation), "TransitionEvent" in window || delete Bc.transitionend.transition);
  function wi(l) {
    if (Pm[l])
      return Pm[l];
    if (!Bc[l])
      return l;
    var u = Bc[l], m;
    for (m in u)
      if (u.hasOwnProperty(m) && m in Im)
        return Pm[l] = u[m];
    return l;
  }
  var Rm = wi("animationend"), n0 = wi("animationiteration"), r0 = wi("animationstart"), i0 = wi("transitionend"), o0 = /* @__PURE__ */ new Map(), a0 = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function rl(l, u) {
    o0.set(l, u), s(u, [l]);
  }
  for (var bf = 0; bf < a0.length; bf++) {
    var Fc = a0[bf], eE = Fc.toLowerCase(), Sf = Fc[0].toUpperCase() + Fc.slice(1);
    rl(eE, "on" + Sf);
  }
  rl(Rm, "onAnimationEnd"), rl(n0, "onAnimationIteration"), rl(r0, "onAnimationStart"), rl("dblclick", "onDoubleClick"), rl("focusin", "onFocus"), rl("focusout", "onBlur"), rl(i0, "onTransitionEnd"), c("onMouseEnter", ["mouseout", "mouseover"]), c("onMouseLeave", ["mouseout", "mouseover"]), c("onPointerEnter", ["pointerout", "pointerover"]), c("onPointerLeave", ["pointerout", "pointerover"]), s("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), s("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), s("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), s("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var wf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), tE = new Set("cancel close invalid load scroll toggle".split(" ").concat(wf));
  function s0(l, u, m) {
    var w = l.type || "unknown-event";
    l.currentTarget = m, st(w, u, void 0, l), l.currentTarget = null;
  }
  function qp(l, u) {
    u = (u & 4) !== 0;
    for (var m = 0; m < l.length; m++) {
      var w = l[m], P = w.event;
      w = w.listeners;
      e: {
        var M = void 0;
        if (u)
          for (var H = w.length - 1; 0 <= H; H--) {
            var Q = w[H], ee = Q.instance, Te = Q.currentTarget;
            if (Q = Q.listener, ee !== M && P.isPropagationStopped())
              break e;
            s0(P, Q, Te), M = ee;
          }
        else
          for (H = 0; H < w.length; H++) {
            if (Q = w[H], ee = Q.instance, Te = Q.currentTarget, Q = Q.listener, ee !== M && P.isPropagationStopped())
              break e;
            s0(P, Q, Te), M = ee;
          }
      }
    }
    if (yi)
      throw l = J, yi = !1, J = null, l;
  }
  function sr(l, u) {
    var m = u[Lm];
    m === void 0 && (m = u[Lm] = /* @__PURE__ */ new Set());
    var w = l + "__bubble";
    m.has(w) || (l0(u, l, 2, !1), m.add(w));
  }
  function Hl(l, u, m) {
    var w = 0;
    u && (w |= 4), l0(m, l, w, u);
  }
  var il = "_reactListening" + Math.random().toString(36).slice(2);
  function Xu(l) {
    if (!l[il]) {
      l[il] = !0, r.forEach(function(m) {
        m !== "selectionchange" && (tE.has(m) || Hl(m, !1, l), Hl(m, !0, l));
      });
      var u = l.nodeType === 9 ? l : l.ownerDocument;
      u === null || u[il] || (u[il] = !0, Hl("selectionchange", !1, u));
    }
  }
  function l0(l, u, m, w) {
    switch (Tr(u)) {
      case 1:
        var P = Ue;
        break;
      case 4:
        P = it;
        break;
      default:
        P = Pn;
    }
    m = P.bind(null, u, m, l), P = void 0, !ba || u !== "touchstart" && u !== "touchmove" && u !== "wheel" || (P = !0), w ? P !== void 0 ? l.addEventListener(u, m, { capture: !0, passive: P }) : l.addEventListener(u, m, !0) : P !== void 0 ? l.addEventListener(u, m, { passive: P }) : l.addEventListener(u, m, !1);
  }
  function Qp(l, u, m, w, P) {
    var M = w;
    if (!(u & 1) && !(u & 2) && w !== null)
      e:
        for (; ; ) {
          if (w === null)
            return;
          var H = w.tag;
          if (H === 3 || H === 4) {
            var Q = w.stateNode.containerInfo;
            if (Q === P || Q.nodeType === 8 && Q.parentNode === P)
              break;
            if (H === 4)
              for (H = w.return; H !== null; ) {
                var ee = H.tag;
                if ((ee === 3 || ee === 4) && (ee = H.stateNode.containerInfo, ee === P || ee.nodeType === 8 && ee.parentNode === P))
                  return;
                H = H.return;
              }
            for (; Q !== null; ) {
              if (H = Ca(Q), H === null)
                return;
              if (ee = H.tag, ee === 5 || ee === 6) {
                w = M = H;
                continue e;
              }
              Q = Q.parentNode;
            }
          }
          w = w.return;
        }
    ms(function() {
      var Te = M, Ve = pn(m), Ye = [];
      e: {
        var He = o0.get(l);
        if (He !== void 0) {
          var lt = Yt, gt = l;
          switch (l) {
            case "keypress":
              if (Ee(m) === 0)
                break e;
            case "keydown":
            case "keyup":
              lt = K1;
              break;
            case "focusin":
              gt = "focus", lt = Za;
              break;
            case "focusout":
              gt = "blur", lt = Za;
              break;
            case "beforeblur":
            case "afterblur":
              lt = Za;
              break;
            case "click":
              if (m.button === 2)
                break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              lt = Js;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              lt = pf;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              lt = W1;
              break;
            case Rm:
            case n0:
            case r0:
              lt = gf;
              break;
            case i0:
              lt = zb;
              break;
            case "scroll":
              lt = Ln;
              break;
            case "wheel":
              lt = tl;
              break;
            case "copy":
            case "cut":
            case "paste":
              lt = V1;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              lt = Hp;
          }
          var wt = (u & 4) !== 0, Xr = !wt && l === "scroll", ge = wt ? He !== null ? He + "Capture" : null : He;
          wt = [];
          for (var oe = Te, we; oe !== null; ) {
            we = oe;
            var Xe = we.stateNode;
            if (we.tag === 5 && Xe !== null && (we = Xe, ge !== null && (Xe = ao(oe, ge), Xe != null && wt.push(xf(oe, Xe, we)))), Xr)
              break;
            oe = oe.return;
          }
          0 < wt.length && (He = new lt(He, gt, null, m, Ve), Ye.push({ event: He, listeners: wt }));
        }
      }
      if (!(u & 7)) {
        e: {
          if (He = l === "mouseover" || l === "pointerover", lt = l === "mouseout" || l === "pointerout", He && m !== hi && (gt = m.relatedTarget || m.fromElement) && (Ca(gt) || gt[ol]))
            break e;
          if ((lt || He) && (He = Ve.window === Ve ? Ve : (He = Ve.ownerDocument) ? He.defaultView || He.parentWindow : window, lt ? (gt = m.relatedTarget || m.toElement, lt = Te, gt = gt ? Ca(gt) : null, gt !== null && (Xr = Kt(gt), gt !== Xr || gt.tag !== 5 && gt.tag !== 6) && (gt = null)) : (lt = null, gt = Te), lt !== gt)) {
            if (wt = Js, Xe = "onMouseLeave", ge = "onMouseEnter", oe = "mouse", (l === "pointerout" || l === "pointerover") && (wt = Hp, Xe = "onPointerLeave", ge = "onPointerEnter", oe = "pointer"), Xr = lt == null ? He : qu(lt), we = gt == null ? He : qu(gt), He = new wt(Xe, oe + "leave", lt, m, Ve), He.target = Xr, He.relatedTarget = we, Xe = null, Ca(Ve) === Te && (wt = new wt(ge, oe + "enter", gt, m, Ve), wt.target = we, wt.relatedTarget = Xr, Xe = wt), Xr = Xe, lt && gt)
              t: {
                for (wt = lt, ge = gt, oe = 0, we = wt; we; we = Hc(we))
                  oe++;
                for (we = 0, Xe = ge; Xe; Xe = Hc(Xe))
                  we++;
                for (; 0 < oe - we; )
                  wt = Hc(wt), oe--;
                for (; 0 < we - oe; )
                  ge = Hc(ge), we--;
                for (; oe--; ) {
                  if (wt === ge || ge !== null && wt === ge.alternate)
                    break t;
                  wt = Hc(wt), ge = Hc(ge);
                }
                wt = null;
              }
            else
              wt = null;
            lt !== null && $m(Ye, He, lt, wt, !1), gt !== null && Xr !== null && $m(Ye, Xr, gt, wt, !0);
          }
        }
        e: {
          if (He = Te ? qu(Te) : window, lt = He.nodeName && He.nodeName.toLowerCase(), lt === "select" || lt === "input" && He.type === "file")
            var Ct = Kb;
          else if (Vb(He))
            if (Em)
              Ct = qb;
            else {
              Ct = Q1;
              var mt = q1;
            }
          else
            (lt = He.nodeName) && lt.toLowerCase() === "input" && (He.type === "checkbox" || He.type === "radio") && (Ct = Z1);
          if (Ct && (Ct = Ct(l, Te))) {
            Yb(Ye, Ct, m, Ve);
            break e;
          }
          mt && mt(l, He, Te), l === "focusout" && (mt = He._wrapperState) && mt.controlled && He.type === "number" && Er(He, "number", He.value);
        }
        switch (mt = Te ? qu(Te) : window, l) {
          case "focusin":
            (Vb(mt) || mt.contentEditable === "true") && (es = mt, Tm = Te, yf = null);
            break;
          case "focusout":
            yf = Tm = es = null;
            break;
          case "mousedown":
            km = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            km = !1, t0(Ye, m, Ve);
            break;
          case "selectionchange":
            if (e0)
              break;
          case "keydown":
          case "keyup":
            t0(Ye, m, Ve);
        }
        var $t;
        if (Ja)
          e: {
            switch (l) {
              case "compositionstart":
                var Vt = "onCompositionStart";
                break e;
              case "compositionend":
                Vt = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Vt = "onCompositionUpdate";
                break e;
            }
            Vt = void 0;
          }
        else
          Yu ? Fb(l, m) && (Vt = "onCompositionEnd") : l === "keydown" && m.keyCode === 229 && (Vt = "onCompositionStart");
        Vt && (Ub && m.locale !== "ko" && (Yu || Vt !== "onCompositionStart" ? Vt === "onCompositionEnd" && Yu && ($t = ye()) : (Wn = Ve, U = "value" in Wn ? Wn.value : Wn.textContent, Yu = !0)), mt = Ef(Te, Vt), 0 < mt.length && (Vt = new ym(Vt, l, null, m, Ve), Ye.push({ event: Vt, listeners: mt }), $t ? Vt.data = $t : ($t = Kp(m), $t !== null && (Vt.data = $t)))), ($t = Yp ? G1(l, m) : X1(l, m)) && (Te = Ef(Te, "onBeforeInput"), 0 < Te.length && (Ve = new ym("onBeforeInput", "beforeinput", null, m, Ve), Ye.push({ event: Ve, listeners: Te }), Ve.data = $t));
      }
      qp(Ye, u);
    });
  }
  function xf(l, u, m) {
    return { instance: l, listener: u, currentTarget: m };
  }
  function Ef(l, u) {
    for (var m = u + "Capture", w = []; l !== null; ) {
      var P = l, M = P.stateNode;
      P.tag === 5 && M !== null && (P = M, M = ao(l, m), M != null && w.unshift(xf(l, M, P)), M = ao(l, u), M != null && w.push(xf(l, M, P))), l = l.return;
    }
    return w;
  }
  function Hc(l) {
    if (l === null)
      return null;
    do
      l = l.return;
    while (l && l.tag !== 5);
    return l || null;
  }
  function $m(l, u, m, w, P) {
    for (var M = u._reactName, H = []; m !== null && m !== w; ) {
      var Q = m, ee = Q.alternate, Te = Q.stateNode;
      if (ee !== null && ee === w)
        break;
      Q.tag === 5 && Te !== null && (Q = Te, P ? (ee = ao(m, M), ee != null && H.unshift(xf(m, ee, Q))) : P || (ee = ao(m, M), ee != null && H.push(xf(m, ee, Q)))), m = m.return;
    }
    H.length !== 0 && l.push({ event: u, listeners: H });
  }
  var Mm = /\r\n?/g, nE = /\u0000|\uFFFD/g;
  function Am(l) {
    return (typeof l == "string" ? l : "" + l).replace(Mm, `
`).replace(nE, "");
  }
  function Zp(l, u, m) {
    if (u = Am(u), Am(l) !== u && m)
      throw Error(n(425));
  }
  function Jp() {
  }
  var Om = null, Vc = null;
  function Cf(l, u) {
    return l === "textarea" || l === "noscript" || typeof u.children == "string" || typeof u.children == "number" || typeof u.dangerouslySetInnerHTML == "object" && u.dangerouslySetInnerHTML !== null && u.dangerouslySetInnerHTML.__html != null;
  }
  var Yc = typeof setTimeout == "function" ? setTimeout : void 0, c0 = typeof clearTimeout == "function" ? clearTimeout : void 0, Dm = typeof Promise == "function" ? Promise : void 0, Nm = typeof queueMicrotask == "function" ? queueMicrotask : typeof Dm < "u" ? function(l) {
    return Dm.resolve(null).then(l).catch(rE);
  } : Yc;
  function rE(l) {
    setTimeout(function() {
      throw l;
    });
  }
  function Vl(l, u) {
    var m = u, w = 0;
    do {
      var P = m.nextSibling;
      if (l.removeChild(m), P && P.nodeType === 8)
        if (m = P.data, m === "/$") {
          if (w === 0) {
            l.removeChild(P), Es(u);
            return;
          }
          w--;
        } else
          m !== "$" && m !== "$?" && m !== "$!" || w++;
      m = P;
    } while (m);
    Es(u);
  }
  function ts(l) {
    for (; l != null; l = l.nextSibling) {
      var u = l.nodeType;
      if (u === 1 || u === 3)
        break;
      if (u === 8) {
        if (u = l.data, u === "$" || u === "$!" || u === "$?")
          break;
        if (u === "/$")
          return null;
      }
    }
    return l;
  }
  function _f(l) {
    l = l.previousSibling;
    for (var u = 0; l; ) {
      if (l.nodeType === 8) {
        var m = l.data;
        if (m === "$" || m === "$!" || m === "$?") {
          if (u === 0)
            return l;
          u--;
        } else
          m === "/$" && u++;
      }
      l = l.previousSibling;
    }
    return null;
  }
  var Yl = Math.random().toString(36).slice(2), Cs = "__reactFiber$" + Yl, Kc = "__reactProps$" + Yl, ol = "__reactContainer$" + Yl, Lm = "__reactEvents$" + Yl, iE = "__reactListeners$" + Yl, jm = "__reactHandles$" + Yl;
  function Ca(l) {
    var u = l[Cs];
    if (u)
      return u;
    for (var m = l.parentNode; m; ) {
      if (u = m[ol] || m[Cs]) {
        if (m = u.alternate, u.child !== null || m !== null && m.child !== null)
          for (l = _f(l); l !== null; ) {
            if (m = l[Cs])
              return m;
            l = _f(l);
          }
        return u;
      }
      l = m, m = l.parentNode;
    }
    return null;
  }
  function Tf(l) {
    return l = l[Cs] || l[ol], !l || l.tag !== 5 && l.tag !== 6 && l.tag !== 13 && l.tag !== 3 ? null : l;
  }
  function qu(l) {
    if (l.tag === 5 || l.tag === 6)
      return l.stateNode;
    throw Error(n(33));
  }
  function Mt(l) {
    return l[Kc] || null;
  }
  var Kl = [], mr = -1;
  function on(l) {
    return { current: l };
  }
  function Un(l) {
    0 > mr || (l.current = Kl[mr], Kl[mr] = null, mr--);
  }
  function Vn(l, u) {
    mr++, Kl[mr] = l.current, l.current = u;
  }
  var _s = {}, Ht = on(_s), Fr = on(!1), Ro = _s;
  function _a(l, u) {
    var m = l.type.contextTypes;
    if (!m)
      return _s;
    var w = l.stateNode;
    if (w && w.__reactInternalMemoizedUnmaskedChildContext === u)
      return w.__reactInternalMemoizedMaskedChildContext;
    var P = {}, M;
    for (M in m)
      P[M] = u[M];
    return w && (l = l.stateNode, l.__reactInternalMemoizedUnmaskedChildContext = u, l.__reactInternalMemoizedMaskedChildContext = P), P;
  }
  function kr(l) {
    return l = l.childContextTypes, l != null;
  }
  function Ta() {
    Un(Fr), Un(Ht);
  }
  function Wl(l, u, m) {
    if (Ht.current !== _s)
      throw Error(n(168));
    Vn(Ht, u), Vn(Fr, m);
  }
  function kf(l, u, m) {
    var w = l.stateNode;
    if (u = u.childContextTypes, typeof w.getChildContext != "function")
      return m;
    w = w.getChildContext();
    for (var P in w)
      if (!(P in u))
        throw Error(n(108, Qe(l) || "Unknown", P));
    return W({}, m, w);
  }
  function eh(l) {
    return l = (l = l.stateNode) && l.__reactInternalMemoizedMergedChildContext || _s, Ro = Ht.current, Vn(Ht, l), Vn(Fr, Fr.current), !0;
  }
  function u0(l, u, m) {
    var w = l.stateNode;
    if (!w)
      throw Error(n(169));
    m ? (l = kf(l, u, Ro), w.__reactInternalMemoizedMergedChildContext = l, Un(Fr), Un(Ht), Vn(Ht, l)) : Un(Fr), Vn(Fr, m);
  }
  var Qo = null, xi = !1, Pf = !1;
  function zm(l) {
    Qo === null ? Qo = [l] : Qo.push(l);
  }
  function Um(l) {
    xi = !0, zm(l);
  }
  function $o() {
    if (!Pf && Qo !== null) {
      Pf = !0;
      var l = 0, u = hn;
      try {
        var m = Qo;
        for (hn = 1; l < m.length; l++) {
          var w = m[l];
          do
            w = w(!0);
          while (w !== null);
        }
        Qo = null, xi = !1;
      } catch (P) {
        throw Qo !== null && (Qo = Qo.slice(l + 1)), Zn(Wo, $o), P;
      } finally {
        hn = u, Pf = !1;
      }
    }
    return null;
  }
  var Gl = [], Mo = 0, Wc = null, Qu = 0, Ao = [], Gi = 0, ka = null, Mi = 1, al = "";
  function Zo(l, u) {
    Gl[Mo++] = Qu, Gl[Mo++] = Wc, Wc = l, Qu = u;
  }
  function Bm(l, u, m) {
    Ao[Gi++] = Mi, Ao[Gi++] = al, Ao[Gi++] = ka, ka = l;
    var w = Mi;
    l = al;
    var P = 32 - $i(w) - 1;
    w &= ~(1 << P), m += 1;
    var M = 32 - $i(u) + P;
    if (30 < M) {
      var H = P - P % 5;
      M = (w & (1 << H) - 1).toString(32), w >>= H, P -= H, Mi = 1 << 32 - $i(u) + P | m << P | w, al = M + l;
    } else
      Mi = 1 << M | m << P | w, al = l;
  }
  function th(l) {
    l.return !== null && (Zo(l, 1), Bm(l, 1, 0));
  }
  function Fm(l) {
    for (; l === Wc; )
      Wc = Gl[--Mo], Gl[Mo] = null, Qu = Gl[--Mo], Gl[Mo] = null;
    for (; l === ka; )
      ka = Ao[--Gi], Ao[Gi] = null, al = Ao[--Gi], Ao[Gi] = null, Mi = Ao[--Gi], Ao[Gi] = null;
  }
  var Jo = null, Oo = null, vr = !1, Pa = null;
  function Hm(l, u) {
    var m = Oa(5, null, null, 0);
    m.elementType = "DELETED", m.stateNode = u, m.return = l, u = l.deletions, u === null ? (l.deletions = [m], l.flags |= 16) : u.push(m);
  }
  function d0(l, u) {
    switch (l.tag) {
      case 5:
        var m = l.type;
        return u = u.nodeType !== 1 || m.toLowerCase() !== u.nodeName.toLowerCase() ? null : u, u !== null ? (l.stateNode = u, Jo = l, Oo = ts(u.firstChild), !0) : !1;
      case 6:
        return u = l.pendingProps === "" || u.nodeType !== 3 ? null : u, u !== null ? (l.stateNode = u, Jo = l, Oo = null, !0) : !1;
      case 13:
        return u = u.nodeType !== 8 ? null : u, u !== null ? (m = ka !== null ? { id: Mi, overflow: al } : null, l.memoizedState = { dehydrated: u, treeContext: m, retryLane: 1073741824 }, m = Oa(18, null, null, 0), m.stateNode = u, m.return = l, l.child = m, Jo = l, Oo = null, !0) : !1;
      default:
        return !1;
    }
  }
  function nh(l) {
    return (l.mode & 1) !== 0 && (l.flags & 128) === 0;
  }
  function rh(l) {
    if (vr) {
      var u = Oo;
      if (u) {
        var m = u;
        if (!d0(l, u)) {
          if (nh(l))
            throw Error(n(418));
          u = ts(m.nextSibling);
          var w = Jo;
          u && d0(l, u) ? Hm(w, m) : (l.flags = l.flags & -4097 | 2, vr = !1, Jo = l);
        }
      } else {
        if (nh(l))
          throw Error(n(418));
        l.flags = l.flags & -4097 | 2, vr = !1, Jo = l;
      }
    }
  }
  function f0(l) {
    for (l = l.return; l !== null && l.tag !== 5 && l.tag !== 3 && l.tag !== 13; )
      l = l.return;
    Jo = l;
  }
  function ih(l) {
    if (l !== Jo)
      return !1;
    if (!vr)
      return f0(l), vr = !0, !1;
    var u;
    if ((u = l.tag !== 3) && !(u = l.tag !== 5) && (u = l.type, u = u !== "head" && u !== "body" && !Cf(l.type, l.memoizedProps)), u && (u = Oo)) {
      if (nh(l))
        throw p0(), Error(n(418));
      for (; u; )
        Hm(l, u), u = ts(u.nextSibling);
    }
    if (f0(l), l.tag === 13) {
      if (l = l.memoizedState, l = l !== null ? l.dehydrated : null, !l)
        throw Error(n(317));
      e: {
        for (l = l.nextSibling, u = 0; l; ) {
          if (l.nodeType === 8) {
            var m = l.data;
            if (m === "/$") {
              if (u === 0) {
                Oo = ts(l.nextSibling);
                break e;
              }
              u--;
            } else
              m !== "$" && m !== "$!" && m !== "$?" || u++;
          }
          l = l.nextSibling;
        }
        Oo = null;
      }
    } else
      Oo = Jo ? ts(l.stateNode.nextSibling) : null;
    return !0;
  }
  function p0() {
    for (var l = Oo; l; )
      l = ts(l.nextSibling);
  }
  function Ar() {
    Oo = Jo = null, vr = !1;
  }
  function Vm(l) {
    Pa === null ? Pa = [l] : Pa.push(l);
  }
  var oh = L.ReactCurrentBatchConfig;
  function ea(l, u) {
    if (l && l.defaultProps) {
      u = W({}, u), l = l.defaultProps;
      for (var m in l)
        u[m] === void 0 && (u[m] = l[m]);
      return u;
    }
    return u;
  }
  var Ts = on(null), ah = null, Xl = null, Ym = null;
  function Km() {
    Ym = Xl = ah = null;
  }
  function ql(l) {
    var u = Ts.current;
    Un(Ts), l._currentValue = u;
  }
  function Ei(l, u, m) {
    for (; l !== null; ) {
      var w = l.alternate;
      if ((l.childLanes & u) !== u ? (l.childLanes |= u, w !== null && (w.childLanes |= u)) : w !== null && (w.childLanes & u) !== u && (w.childLanes |= u), l === m)
        break;
      l = l.return;
    }
  }
  function tt(l, u) {
    ah = l, Ym = Xl = null, l = l.dependencies, l !== null && l.firstContext !== null && (l.lanes & u && (ri = !0), l.firstContext = null);
  }
  function Gr(l) {
    var u = l._currentValue;
    if (Ym !== l)
      if (l = { context: l, memoizedValue: u, next: null }, Xl === null) {
        if (ah === null)
          throw Error(n(308));
        Xl = l, ah.dependencies = { lanes: 0, firstContext: l };
      } else
        Xl = Xl.next = l;
    return u;
  }
  var Ai = null;
  function Wm(l) {
    Ai === null ? Ai = [l] : Ai.push(l);
  }
  function h0(l, u, m, w) {
    var P = u.interleaved;
    return P === null ? (m.next = m, Wm(u)) : (m.next = P.next, P.next = m), u.interleaved = m, sl(l, w);
  }
  function sl(l, u) {
    l.lanes |= u;
    var m = l.alternate;
    for (m !== null && (m.lanes |= u), m = l, l = l.return; l !== null; )
      l.childLanes |= u, m = l.alternate, m !== null && (m.childLanes |= u), m = l, l = l.return;
    return m.tag === 3 ? m.stateNode : null;
  }
  var Ql = !1;
  function Gm(l) {
    l.updateQueue = { baseState: l.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function ai(l, u) {
    l = l.updateQueue, u.updateQueue === l && (u.updateQueue = { baseState: l.baseState, firstBaseUpdate: l.firstBaseUpdate, lastBaseUpdate: l.lastBaseUpdate, shared: l.shared, effects: l.effects });
  }
  function ll(l, u) {
    return { eventTime: l, lane: u, tag: 0, payload: null, callback: null, next: null };
  }
  function Zl(l, u, m) {
    var w = l.updateQueue;
    if (w === null)
      return null;
    if (w = w.shared, mn & 2) {
      var P = w.pending;
      return P === null ? u.next = u : (u.next = P.next, P.next = u), w.pending = u, sl(l, m);
    }
    return P = w.interleaved, P === null ? (u.next = u, Wm(w)) : (u.next = P.next, P.next = u), w.interleaved = u, sl(l, m);
  }
  function sh(l, u, m) {
    if (u = u.updateQueue, u !== null && (u = u.shared, (m & 4194240) !== 0)) {
      var w = u.lanes;
      w &= l.pendingLanes, m |= w, u.lanes = m, Go(l, m);
    }
  }
  function Xm(l, u) {
    var m = l.updateQueue, w = l.alternate;
    if (w !== null && (w = w.updateQueue, m === w)) {
      var P = null, M = null;
      if (m = m.firstBaseUpdate, m !== null) {
        do {
          var H = { eventTime: m.eventTime, lane: m.lane, tag: m.tag, payload: m.payload, callback: m.callback, next: null };
          M === null ? P = M = H : M = M.next = H, m = m.next;
        } while (m !== null);
        M === null ? P = M = u : M = M.next = u;
      } else
        P = M = u;
      m = { baseState: w.baseState, firstBaseUpdate: P, lastBaseUpdate: M, shared: w.shared, effects: w.effects }, l.updateQueue = m;
      return;
    }
    l = m.lastBaseUpdate, l === null ? m.firstBaseUpdate = u : l.next = u, m.lastBaseUpdate = u;
  }
  function Jl(l, u, m, w) {
    var P = l.updateQueue;
    Ql = !1;
    var M = P.firstBaseUpdate, H = P.lastBaseUpdate, Q = P.shared.pending;
    if (Q !== null) {
      P.shared.pending = null;
      var ee = Q, Te = ee.next;
      ee.next = null, H === null ? M = Te : H.next = Te, H = ee;
      var Ve = l.alternate;
      Ve !== null && (Ve = Ve.updateQueue, Q = Ve.lastBaseUpdate, Q !== H && (Q === null ? Ve.firstBaseUpdate = Te : Q.next = Te, Ve.lastBaseUpdate = ee));
    }
    if (M !== null) {
      var Ye = P.baseState;
      H = 0, Ve = Te = ee = null, Q = M;
      do {
        var He = Q.lane, lt = Q.eventTime;
        if ((w & He) === He) {
          Ve !== null && (Ve = Ve.next = {
            eventTime: lt,
            lane: 0,
            tag: Q.tag,
            payload: Q.payload,
            callback: Q.callback,
            next: null
          });
          e: {
            var gt = l, wt = Q;
            switch (He = u, lt = m, wt.tag) {
              case 1:
                if (gt = wt.payload, typeof gt == "function") {
                  Ye = gt.call(lt, Ye, He);
                  break e;
                }
                Ye = gt;
                break e;
              case 3:
                gt.flags = gt.flags & -65537 | 128;
              case 0:
                if (gt = wt.payload, He = typeof gt == "function" ? gt.call(lt, Ye, He) : gt, He == null)
                  break e;
                Ye = W({}, Ye, He);
                break e;
              case 2:
                Ql = !0;
            }
          }
          Q.callback !== null && Q.lane !== 0 && (l.flags |= 64, He = P.effects, He === null ? P.effects = [Q] : He.push(Q));
        } else
          lt = { eventTime: lt, lane: He, tag: Q.tag, payload: Q.payload, callback: Q.callback, next: null }, Ve === null ? (Te = Ve = lt, ee = Ye) : Ve = Ve.next = lt, H |= He;
        if (Q = Q.next, Q === null) {
          if (Q = P.shared.pending, Q === null)
            break;
          He = Q, Q = He.next, He.next = null, P.lastBaseUpdate = He, P.shared.pending = null;
        }
      } while (1);
      if (Ve === null && (ee = Ye), P.baseState = ee, P.firstBaseUpdate = Te, P.lastBaseUpdate = Ve, u = P.shared.interleaved, u !== null) {
        P = u;
        do
          H |= P.lane, P = P.next;
        while (P !== u);
      } else
        M === null && (P.shared.lanes = 0);
      fl |= H, l.lanes = H, l.memoizedState = Ye;
    }
  }
  function Gc(l, u, m) {
    if (l = u.effects, u.effects = null, l !== null)
      for (u = 0; u < l.length; u++) {
        var w = l[u], P = w.callback;
        if (P !== null) {
          if (w.callback = null, w = m, typeof P != "function")
            throw Error(n(191, P));
          P.call(w);
        }
      }
  }
  var g0 = new t.Component().refs;
  function qm(l, u, m, w) {
    u = l.memoizedState, m = m(w, u), m = m == null ? u : W({}, u, m), l.memoizedState = m, l.lanes === 0 && (l.updateQueue.baseState = m);
  }
  var lh = { isMounted: function(l) {
    return (l = l._reactInternals) ? Kt(l) === l : !1;
  }, enqueueSetState: function(l, u, m) {
    l = l._reactInternals;
    var w = Zi(), P = ii(l), M = ll(w, P);
    M.payload = u, m != null && (M.callback = m), u = Zl(l, M, P), u !== null && (Ji(u, l, P, w), sh(u, l, P));
  }, enqueueReplaceState: function(l, u, m) {
    l = l._reactInternals;
    var w = Zi(), P = ii(l), M = ll(w, P);
    M.tag = 1, M.payload = u, m != null && (M.callback = m), u = Zl(l, M, P), u !== null && (Ji(u, l, P, w), sh(u, l, P));
  }, enqueueForceUpdate: function(l, u) {
    l = l._reactInternals;
    var m = Zi(), w = ii(l), P = ll(m, w);
    P.tag = 2, u != null && (P.callback = u), u = Zl(l, P, w), u !== null && (Ji(u, l, w, m), sh(u, l, w));
  } };
  function m0(l, u, m, w, P, M, H) {
    return l = l.stateNode, typeof l.shouldComponentUpdate == "function" ? l.shouldComponentUpdate(w, M, H) : u.prototype && u.prototype.isPureReactComponent ? !vf(m, w) || !vf(P, M) : !0;
  }
  function v0(l, u, m) {
    var w = !1, P = _s, M = u.contextType;
    return typeof M == "object" && M !== null ? M = Gr(M) : (P = kr(u) ? Ro : Ht.current, w = u.contextTypes, M = (w = w != null) ? _a(l, P) : _s), u = new u(m, M), l.memoizedState = u.state !== null && u.state !== void 0 ? u.state : null, u.updater = lh, l.stateNode = u, u._reactInternals = l, w && (l = l.stateNode, l.__reactInternalMemoizedUnmaskedChildContext = P, l.__reactInternalMemoizedMaskedChildContext = M), u;
  }
  function y0(l, u, m, w) {
    l = u.state, typeof u.componentWillReceiveProps == "function" && u.componentWillReceiveProps(m, w), typeof u.UNSAFE_componentWillReceiveProps == "function" && u.UNSAFE_componentWillReceiveProps(m, w), u.state !== l && lh.enqueueReplaceState(u, u.state, null);
  }
  function ch(l, u, m, w) {
    var P = l.stateNode;
    P.props = m, P.state = l.memoizedState, P.refs = g0, Gm(l);
    var M = u.contextType;
    typeof M == "object" && M !== null ? P.context = Gr(M) : (M = kr(u) ? Ro : Ht.current, P.context = _a(l, M)), P.state = l.memoizedState, M = u.getDerivedStateFromProps, typeof M == "function" && (qm(l, u, M, m), P.state = l.memoizedState), typeof u.getDerivedStateFromProps == "function" || typeof P.getSnapshotBeforeUpdate == "function" || typeof P.UNSAFE_componentWillMount != "function" && typeof P.componentWillMount != "function" || (u = P.state, typeof P.componentWillMount == "function" && P.componentWillMount(), typeof P.UNSAFE_componentWillMount == "function" && P.UNSAFE_componentWillMount(), u !== P.state && lh.enqueueReplaceState(P, P.state, null), Jl(l, m, P, w), P.state = l.memoizedState), typeof P.componentDidMount == "function" && (l.flags |= 4194308);
  }
  function Zu(l, u, m) {
    if (l = m.ref, l !== null && typeof l != "function" && typeof l != "object") {
      if (m._owner) {
        if (m = m._owner, m) {
          if (m.tag !== 1)
            throw Error(n(309));
          var w = m.stateNode;
        }
        if (!w)
          throw Error(n(147, l));
        var P = w, M = "" + l;
        return u !== null && u.ref !== null && typeof u.ref == "function" && u.ref._stringRef === M ? u.ref : (u = function(H) {
          var Q = P.refs;
          Q === g0 && (Q = P.refs = {}), H === null ? delete Q[M] : Q[M] = H;
        }, u._stringRef = M, u);
      }
      if (typeof l != "string")
        throw Error(n(284));
      if (!m._owner)
        throw Error(n(290, l));
    }
    return l;
  }
  function uh(l, u) {
    throw l = Object.prototype.toString.call(u), Error(n(31, l === "[object Object]" ? "object with keys {" + Object.keys(u).join(", ") + "}" : l));
  }
  function b0(l) {
    var u = l._init;
    return u(l._payload);
  }
  function S0(l) {
    function u(ge, oe) {
      if (l) {
        var we = ge.deletions;
        we === null ? (ge.deletions = [oe], ge.flags |= 16) : we.push(oe);
      }
    }
    function m(ge, oe) {
      if (!l)
        return null;
      for (; oe !== null; )
        u(ge, oe), oe = oe.sibling;
      return null;
    }
    function w(ge, oe) {
      for (ge = /* @__PURE__ */ new Map(); oe !== null; )
        oe.key !== null ? ge.set(oe.key, oe) : ge.set(oe.index, oe), oe = oe.sibling;
      return ge;
    }
    function P(ge, oe) {
      return ge = sc(ge, oe), ge.index = 0, ge.sibling = null, ge;
    }
    function M(ge, oe, we) {
      return ge.index = we, l ? (we = ge.alternate, we !== null ? (we = we.index, we < oe ? (ge.flags |= 2, oe) : we) : (ge.flags |= 2, oe)) : (ge.flags |= 1048576, oe);
    }
    function H(ge) {
      return l && ge.alternate === null && (ge.flags |= 2), ge;
    }
    function Q(ge, oe, we, Xe) {
      return oe === null || oe.tag !== 6 ? (oe = Wf(we, ge.mode, Xe), oe.return = ge, oe) : (oe = P(oe, we), oe.return = ge, oe);
    }
    function ee(ge, oe, we, Xe) {
      var Ct = we.type;
      return Ct === K ? Ve(ge, oe, we.props.children, Xe, we.key) : oe !== null && (oe.elementType === Ct || typeof Ct == "object" && Ct !== null && Ct.$$typeof === Re && b0(Ct) === oe.type) ? (Xe = P(oe, we.props), Xe.ref = Zu(ge, oe, we), Xe.return = ge, Xe) : (Xe = Fh(we.type, we.key, we.props, null, ge.mode, Xe), Xe.ref = Zu(ge, oe, we), Xe.return = ge, Xe);
    }
    function Te(ge, oe, we, Xe) {
      return oe === null || oe.tag !== 4 || oe.stateNode.containerInfo !== we.containerInfo || oe.stateNode.implementation !== we.implementation ? (oe = pu(we, ge.mode, Xe), oe.return = ge, oe) : (oe = P(oe, we.children || []), oe.return = ge, oe);
    }
    function Ve(ge, oe, we, Xe, Ct) {
      return oe === null || oe.tag !== 7 ? (oe = fu(we, ge.mode, Xe, Ct), oe.return = ge, oe) : (oe = P(oe, we), oe.return = ge, oe);
    }
    function Ye(ge, oe, we) {
      if (typeof oe == "string" && oe !== "" || typeof oe == "number")
        return oe = Wf("" + oe, ge.mode, we), oe.return = ge, oe;
      if (typeof oe == "object" && oe !== null) {
        switch (oe.$$typeof) {
          case z:
            return we = Fh(oe.type, oe.key, oe.props, null, ge.mode, we), we.ref = Zu(ge, null, oe), we.return = ge, we;
          case F:
            return oe = pu(oe, ge.mode, we), oe.return = ge, oe;
          case Re:
            var Xe = oe._init;
            return Ye(ge, Xe(oe._payload), we);
        }
        if (tn(oe) || de(oe))
          return oe = fu(oe, ge.mode, we, null), oe.return = ge, oe;
        uh(ge, oe);
      }
      return null;
    }
    function He(ge, oe, we, Xe) {
      var Ct = oe !== null ? oe.key : null;
      if (typeof we == "string" && we !== "" || typeof we == "number")
        return Ct !== null ? null : Q(ge, oe, "" + we, Xe);
      if (typeof we == "object" && we !== null) {
        switch (we.$$typeof) {
          case z:
            return we.key === Ct ? ee(ge, oe, we, Xe) : null;
          case F:
            return we.key === Ct ? Te(ge, oe, we, Xe) : null;
          case Re:
            return Ct = we._init, He(
              ge,
              oe,
              Ct(we._payload),
              Xe
            );
        }
        if (tn(we) || de(we))
          return Ct !== null ? null : Ve(ge, oe, we, Xe, null);
        uh(ge, we);
      }
      return null;
    }
    function lt(ge, oe, we, Xe, Ct) {
      if (typeof Xe == "string" && Xe !== "" || typeof Xe == "number")
        return ge = ge.get(we) || null, Q(oe, ge, "" + Xe, Ct);
      if (typeof Xe == "object" && Xe !== null) {
        switch (Xe.$$typeof) {
          case z:
            return ge = ge.get(Xe.key === null ? we : Xe.key) || null, ee(oe, ge, Xe, Ct);
          case F:
            return ge = ge.get(Xe.key === null ? we : Xe.key) || null, Te(oe, ge, Xe, Ct);
          case Re:
            var mt = Xe._init;
            return lt(ge, oe, we, mt(Xe._payload), Ct);
        }
        if (tn(Xe) || de(Xe))
          return ge = ge.get(we) || null, Ve(oe, ge, Xe, Ct, null);
        uh(oe, Xe);
      }
      return null;
    }
    function gt(ge, oe, we, Xe) {
      for (var Ct = null, mt = null, $t = oe, Vt = oe = 0, Ti = null; $t !== null && Vt < we.length; Vt++) {
        $t.index > Vt ? (Ti = $t, $t = null) : Ti = $t.sibling;
        var Rn = He(ge, $t, we[Vt], Xe);
        if (Rn === null) {
          $t === null && ($t = Ti);
          break;
        }
        l && $t && Rn.alternate === null && u(ge, $t), oe = M(Rn, oe, Vt), mt === null ? Ct = Rn : mt.sibling = Rn, mt = Rn, $t = Ti;
      }
      if (Vt === we.length)
        return m(ge, $t), vr && Zo(ge, Vt), Ct;
      if ($t === null) {
        for (; Vt < we.length; Vt++)
          $t = Ye(ge, we[Vt], Xe), $t !== null && (oe = M($t, oe, Vt), mt === null ? Ct = $t : mt.sibling = $t, mt = $t);
        return vr && Zo(ge, Vt), Ct;
      }
      for ($t = w(ge, $t); Vt < we.length; Vt++)
        Ti = lt($t, ge, Vt, we[Vt], Xe), Ti !== null && (l && Ti.alternate !== null && $t.delete(Ti.key === null ? Vt : Ti.key), oe = M(Ti, oe, Vt), mt === null ? Ct = Ti : mt.sibling = Ti, mt = Ti);
      return l && $t.forEach(function(lc) {
        return u(ge, lc);
      }), vr && Zo(ge, Vt), Ct;
    }
    function wt(ge, oe, we, Xe) {
      var Ct = de(we);
      if (typeof Ct != "function")
        throw Error(n(150));
      if (we = Ct.call(we), we == null)
        throw Error(n(151));
      for (var mt = Ct = null, $t = oe, Vt = oe = 0, Ti = null, Rn = we.next(); $t !== null && !Rn.done; Vt++, Rn = we.next()) {
        $t.index > Vt ? (Ti = $t, $t = null) : Ti = $t.sibling;
        var lc = He(ge, $t, Rn.value, Xe);
        if (lc === null) {
          $t === null && ($t = Ti);
          break;
        }
        l && $t && lc.alternate === null && u(ge, $t), oe = M(lc, oe, Vt), mt === null ? Ct = lc : mt.sibling = lc, mt = lc, $t = Ti;
      }
      if (Rn.done)
        return m(
          ge,
          $t
        ), vr && Zo(ge, Vt), Ct;
      if ($t === null) {
        for (; !Rn.done; Vt++, Rn = we.next())
          Rn = Ye(ge, Rn.value, Xe), Rn !== null && (oe = M(Rn, oe, Vt), mt === null ? Ct = Rn : mt.sibling = Rn, mt = Rn);
        return vr && Zo(ge, Vt), Ct;
      }
      for ($t = w(ge, $t); !Rn.done; Vt++, Rn = we.next())
        Rn = lt($t, ge, Vt, Rn.value, Xe), Rn !== null && (l && Rn.alternate !== null && $t.delete(Rn.key === null ? Vt : Rn.key), oe = M(Rn, oe, Vt), mt === null ? Ct = Rn : mt.sibling = Rn, mt = Rn);
      return l && $t.forEach(function(CE) {
        return u(ge, CE);
      }), vr && Zo(ge, Vt), Ct;
    }
    function Xr(ge, oe, we, Xe) {
      if (typeof we == "object" && we !== null && we.type === K && we.key === null && (we = we.props.children), typeof we == "object" && we !== null) {
        switch (we.$$typeof) {
          case z:
            e: {
              for (var Ct = we.key, mt = oe; mt !== null; ) {
                if (mt.key === Ct) {
                  if (Ct = we.type, Ct === K) {
                    if (mt.tag === 7) {
                      m(ge, mt.sibling), oe = P(mt, we.props.children), oe.return = ge, ge = oe;
                      break e;
                    }
                  } else if (mt.elementType === Ct || typeof Ct == "object" && Ct !== null && Ct.$$typeof === Re && b0(Ct) === mt.type) {
                    m(ge, mt.sibling), oe = P(mt, we.props), oe.ref = Zu(ge, mt, we), oe.return = ge, ge = oe;
                    break e;
                  }
                  m(ge, mt);
                  break;
                } else
                  u(ge, mt);
                mt = mt.sibling;
              }
              we.type === K ? (oe = fu(we.props.children, ge.mode, Xe, we.key), oe.return = ge, ge = oe) : (Xe = Fh(we.type, we.key, we.props, null, ge.mode, Xe), Xe.ref = Zu(ge, oe, we), Xe.return = ge, ge = Xe);
            }
            return H(ge);
          case F:
            e: {
              for (mt = we.key; oe !== null; ) {
                if (oe.key === mt)
                  if (oe.tag === 4 && oe.stateNode.containerInfo === we.containerInfo && oe.stateNode.implementation === we.implementation) {
                    m(ge, oe.sibling), oe = P(oe, we.children || []), oe.return = ge, ge = oe;
                    break e;
                  } else {
                    m(ge, oe);
                    break;
                  }
                else
                  u(ge, oe);
                oe = oe.sibling;
              }
              oe = pu(we, ge.mode, Xe), oe.return = ge, ge = oe;
            }
            return H(ge);
          case Re:
            return mt = we._init, Xr(ge, oe, mt(we._payload), Xe);
        }
        if (tn(we))
          return gt(ge, oe, we, Xe);
        if (de(we))
          return wt(ge, oe, we, Xe);
        uh(ge, we);
      }
      return typeof we == "string" && we !== "" || typeof we == "number" ? (we = "" + we, oe !== null && oe.tag === 6 ? (m(ge, oe.sibling), oe = P(oe, we), oe.return = ge, ge = oe) : (m(ge, oe), oe = Wf(we, ge.mode, Xe), oe.return = ge, ge = oe), H(ge)) : m(ge, oe);
    }
    return Xr;
  }
  var Ju = S0(!0), w0 = S0(!1), If = {}, ns = on(If), Rf = on(If), ed = on(If);
  function Xc(l) {
    if (l === If)
      throw Error(n(174));
    return l;
  }
  function Qm(l, u) {
    switch (Vn(ed, u), Vn(Rf, l), Vn(ns, If), l = u.nodeType, l) {
      case 9:
      case 11:
        u = (u = u.documentElement) ? u.namespaceURI : An(null, "");
        break;
      default:
        l = l === 8 ? u.parentNode : u, u = l.namespaceURI || null, l = l.tagName, u = An(u, l);
    }
    Un(ns), Vn(ns, u);
  }
  function ec() {
    Un(ns), Un(Rf), Un(ed);
  }
  function Dt(l) {
    Xc(ed.current);
    var u = Xc(ns.current), m = An(u, l.type);
    u !== m && (Vn(Rf, l), Vn(ns, m));
  }
  function fn(l) {
    Rf.current === l && (Un(ns), Un(Rf));
  }
  var Lt = on(0);
  function Or(l) {
    for (var u = l; u !== null; ) {
      if (u.tag === 13) {
        var m = u.memoizedState;
        if (m !== null && (m = m.dehydrated, m === null || m.data === "$?" || m.data === "$!"))
          return u;
      } else if (u.tag === 19 && u.memoizedProps.revealOrder !== void 0) {
        if (u.flags & 128)
          return u;
      } else if (u.child !== null) {
        u.child.return = u, u = u.child;
        continue;
      }
      if (u === l)
        break;
      for (; u.sibling === null; ) {
        if (u.return === null || u.return === l)
          return null;
        u = u.return;
      }
      u.sibling.return = u.return, u = u.sibling;
    }
    return null;
  }
  var Ia = [];
  function dh() {
    for (var l = 0; l < Ia.length; l++)
      Ia[l]._workInProgressVersionPrimary = null;
    Ia.length = 0;
  }
  var fh = L.ReactCurrentDispatcher, Zm = L.ReactCurrentBatchConfig, qc = 0, yr = null, Ne = null, En = null, jt = !1, ks = !1, ta = 0, Qc = 0;
  function br() {
    throw Error(n(321));
  }
  function Zc(l, u) {
    if (u === null)
      return !1;
    for (var m = 0; m < u.length && m < l.length; m++)
      if (!Ea(l[m], u[m]))
        return !1;
    return !0;
  }
  function tc(l, u, m, w, P, M) {
    if (qc = M, yr = u, u.memoizedState = null, u.updateQueue = null, u.lanes = 0, fh.current = l === null || l.memoizedState === null ? aE : sE, l = m(w, P), ks) {
      M = 0;
      do {
        if (ks = !1, ta = 0, 25 <= M)
          throw Error(n(301));
        M += 1, En = Ne = null, u.updateQueue = null, fh.current = ev, l = m(w, P);
      } while (ks);
    }
    if (fh.current = Ph, u = Ne !== null && Ne.next !== null, qc = 0, En = Ne = yr = null, jt = !1, u)
      throw Error(n(300));
    return l;
  }
  function Jc() {
    var l = ta !== 0;
    return ta = 0, l;
  }
  function Ra() {
    var l = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return En === null ? yr.memoizedState = En = l : En = En.next = l, En;
  }
  function Do() {
    if (Ne === null) {
      var l = yr.alternate;
      l = l !== null ? l.memoizedState : null;
    } else
      l = Ne.next;
    var u = En === null ? yr.memoizedState : En.next;
    if (u !== null)
      En = u, Ne = l;
    else {
      if (l === null)
        throw Error(n(310));
      Ne = l, l = { memoizedState: Ne.memoizedState, baseState: Ne.baseState, baseQueue: Ne.baseQueue, queue: Ne.queue, next: null }, En === null ? yr.memoizedState = En = l : En = En.next = l;
    }
    return En;
  }
  function eu(l, u) {
    return typeof u == "function" ? u(l) : u;
  }
  function $f(l) {
    var u = Do(), m = u.queue;
    if (m === null)
      throw Error(n(311));
    m.lastRenderedReducer = l;
    var w = Ne, P = w.baseQueue, M = m.pending;
    if (M !== null) {
      if (P !== null) {
        var H = P.next;
        P.next = M.next, M.next = H;
      }
      w.baseQueue = P = M, m.pending = null;
    }
    if (P !== null) {
      M = P.next, w = w.baseState;
      var Q = H = null, ee = null, Te = M;
      do {
        var Ve = Te.lane;
        if ((qc & Ve) === Ve)
          ee !== null && (ee = ee.next = { lane: 0, action: Te.action, hasEagerState: Te.hasEagerState, eagerState: Te.eagerState, next: null }), w = Te.hasEagerState ? Te.eagerState : l(w, Te.action);
        else {
          var Ye = {
            lane: Ve,
            action: Te.action,
            hasEagerState: Te.hasEagerState,
            eagerState: Te.eagerState,
            next: null
          };
          ee === null ? (Q = ee = Ye, H = w) : ee = ee.next = Ye, yr.lanes |= Ve, fl |= Ve;
        }
        Te = Te.next;
      } while (Te !== null && Te !== M);
      ee === null ? H = w : ee.next = Q, Ea(w, u.memoizedState) || (ri = !0), u.memoizedState = w, u.baseState = H, u.baseQueue = ee, m.lastRenderedState = w;
    }
    if (l = m.interleaved, l !== null) {
      P = l;
      do
        M = P.lane, yr.lanes |= M, fl |= M, P = P.next;
      while (P !== l);
    } else
      P === null && (m.lanes = 0);
    return [u.memoizedState, m.dispatch];
  }
  function Mf(l) {
    var u = Do(), m = u.queue;
    if (m === null)
      throw Error(n(311));
    m.lastRenderedReducer = l;
    var w = m.dispatch, P = m.pending, M = u.memoizedState;
    if (P !== null) {
      m.pending = null;
      var H = P = P.next;
      do
        M = l(M, H.action), H = H.next;
      while (H !== P);
      Ea(M, u.memoizedState) || (ri = !0), u.memoizedState = M, u.baseQueue === null && (u.baseState = M), m.lastRenderedState = M;
    }
    return [M, w];
  }
  function ph() {
  }
  function hh(l, u) {
    var m = yr, w = Do(), P = u(), M = !Ea(w.memoizedState, P);
    if (M && (w.memoizedState = P, ri = !0), w = w.queue, Af(vh.bind(null, m, w, l), [l]), w.getSnapshot !== u || M || En !== null && En.memoizedState.tag & 1) {
      if (m.flags |= 2048, tu(9, mh.bind(null, m, w, P, u), void 0, null), Dr === null)
        throw Error(n(349));
      qc & 30 || gh(m, u, P);
    }
    return P;
  }
  function gh(l, u, m) {
    l.flags |= 16384, l = { getSnapshot: u, value: m }, u = yr.updateQueue, u === null ? (u = { lastEffect: null, stores: null }, yr.updateQueue = u, u.stores = [l]) : (m = u.stores, m === null ? u.stores = [l] : m.push(l));
  }
  function mh(l, u, m, w) {
    u.value = m, u.getSnapshot = w, yh(u) && bh(l);
  }
  function vh(l, u, m) {
    return m(function() {
      yh(u) && bh(l);
    });
  }
  function yh(l) {
    var u = l.getSnapshot;
    l = l.value;
    try {
      var m = u();
      return !Ea(l, m);
    } catch {
      return !0;
    }
  }
  function bh(l) {
    var u = sl(l, 1);
    u !== null && Ji(u, l, 1, -1);
  }
  function Sh(l) {
    var u = Ra();
    return typeof l == "function" && (l = l()), u.memoizedState = u.baseState = l, l = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: eu, lastRenderedState: l }, u.queue = l, l = l.dispatch = kh.bind(null, yr, l), [u.memoizedState, l];
  }
  function tu(l, u, m, w) {
    return l = { tag: l, create: u, destroy: m, deps: w, next: null }, u = yr.updateQueue, u === null ? (u = { lastEffect: null, stores: null }, yr.updateQueue = u, u.lastEffect = l.next = l) : (m = u.lastEffect, m === null ? u.lastEffect = l.next = l : (w = m.next, m.next = l, l.next = w, u.lastEffect = l)), l;
  }
  function wh() {
    return Do().memoizedState;
  }
  function nu(l, u, m, w) {
    var P = Ra();
    yr.flags |= l, P.memoizedState = tu(1 | u, m, void 0, w === void 0 ? null : w);
  }
  function cl(l, u, m, w) {
    var P = Do();
    w = w === void 0 ? null : w;
    var M = void 0;
    if (Ne !== null) {
      var H = Ne.memoizedState;
      if (M = H.destroy, w !== null && Zc(w, H.deps)) {
        P.memoizedState = tu(u, m, M, w);
        return;
      }
    }
    yr.flags |= l, P.memoizedState = tu(1 | u, m, M, w);
  }
  function xh(l, u) {
    return nu(8390656, 8, l, u);
  }
  function Af(l, u) {
    return cl(2048, 8, l, u);
  }
  function Eh(l, u) {
    return cl(4, 2, l, u);
  }
  function Ch(l, u) {
    return cl(4, 4, l, u);
  }
  function Jm(l, u) {
    if (typeof u == "function")
      return l = l(), u(l), function() {
        u(null);
      };
    if (u != null)
      return l = l(), u.current = l, function() {
        u.current = null;
      };
  }
  function td(l, u, m) {
    return m = m != null ? m.concat([l]) : null, cl(4, 4, Jm.bind(null, u, l), m);
  }
  function _h() {
  }
  function nd(l, u) {
    var m = Do();
    u = u === void 0 ? null : u;
    var w = m.memoizedState;
    return w !== null && u !== null && Zc(u, w[1]) ? w[0] : (m.memoizedState = [l, u], l);
  }
  function nc(l, u) {
    var m = Do();
    u = u === void 0 ? null : u;
    var w = m.memoizedState;
    return w !== null && u !== null && Zc(u, w[1]) ? w[0] : (l = l(), m.memoizedState = [l, u], l);
  }
  function No(l, u, m) {
    return qc & 21 ? (Ea(m, u) || (m = jl(), yr.lanes |= m, fl |= m, l.baseState = !0), u) : (l.baseState && (l.baseState = !1, ri = !0), l.memoizedState = m);
  }
  function oE(l, u) {
    var m = hn;
    hn = m !== 0 && 4 > m ? m : 4, l(!0);
    var w = Zm.transition;
    Zm.transition = {};
    try {
      l(!1), u();
    } finally {
      hn = m, Zm.transition = w;
    }
  }
  function lr() {
    return Do().memoizedState;
  }
  function Th(l, u, m) {
    var w = ii(l);
    if (m = { lane: w, action: m, hasEagerState: !1, eagerState: null, next: null }, rd(l))
      Of(u, m);
    else if (m = h0(l, u, m, w), m !== null) {
      var P = Zi();
      Ji(m, l, w, P), x0(m, u, w);
    }
  }
  function kh(l, u, m) {
    var w = ii(l), P = { lane: w, action: m, hasEagerState: !1, eagerState: null, next: null };
    if (rd(l))
      Of(u, P);
    else {
      var M = l.alternate;
      if (l.lanes === 0 && (M === null || M.lanes === 0) && (M = u.lastRenderedReducer, M !== null))
        try {
          var H = u.lastRenderedState, Q = M(H, m);
          if (P.hasEagerState = !0, P.eagerState = Q, Ea(Q, H)) {
            var ee = u.interleaved;
            ee === null ? (P.next = P, Wm(u)) : (P.next = ee.next, ee.next = P), u.interleaved = P;
            return;
          }
        } catch {
        } finally {
        }
      m = h0(l, u, P, w), m !== null && (P = Zi(), Ji(m, l, w, P), x0(m, u, w));
    }
  }
  function rd(l) {
    var u = l.alternate;
    return l === yr || u !== null && u === yr;
  }
  function Of(l, u) {
    ks = jt = !0;
    var m = l.pending;
    m === null ? u.next = u : (u.next = m.next, m.next = u), l.pending = u;
  }
  function x0(l, u, m) {
    if (m & 4194240) {
      var w = u.lanes;
      w &= l.pendingLanes, m |= w, u.lanes = m, Go(l, m);
    }
  }
  var Ph = { readContext: Gr, useCallback: br, useContext: br, useEffect: br, useImperativeHandle: br, useInsertionEffect: br, useLayoutEffect: br, useMemo: br, useReducer: br, useRef: br, useState: br, useDebugValue: br, useDeferredValue: br, useTransition: br, useMutableSource: br, useSyncExternalStore: br, useId: br, unstable_isNewReconciler: !1 }, aE = { readContext: Gr, useCallback: function(l, u) {
    return Ra().memoizedState = [l, u === void 0 ? null : u], l;
  }, useContext: Gr, useEffect: xh, useImperativeHandle: function(l, u, m) {
    return m = m != null ? m.concat([l]) : null, nu(
      4194308,
      4,
      Jm.bind(null, u, l),
      m
    );
  }, useLayoutEffect: function(l, u) {
    return nu(4194308, 4, l, u);
  }, useInsertionEffect: function(l, u) {
    return nu(4, 2, l, u);
  }, useMemo: function(l, u) {
    var m = Ra();
    return u = u === void 0 ? null : u, l = l(), m.memoizedState = [l, u], l;
  }, useReducer: function(l, u, m) {
    var w = Ra();
    return u = m !== void 0 ? m(u) : u, w.memoizedState = w.baseState = u, l = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: l, lastRenderedState: u }, w.queue = l, l = l.dispatch = Th.bind(null, yr, l), [w.memoizedState, l];
  }, useRef: function(l) {
    var u = Ra();
    return l = { current: l }, u.memoizedState = l;
  }, useState: Sh, useDebugValue: _h, useDeferredValue: function(l) {
    return Ra().memoizedState = l;
  }, useTransition: function() {
    var l = Sh(!1), u = l[0];
    return l = oE.bind(null, l[1]), Ra().memoizedState = l, [u, l];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(l, u, m) {
    var w = yr, P = Ra();
    if (vr) {
      if (m === void 0)
        throw Error(n(407));
      m = m();
    } else {
      if (m = u(), Dr === null)
        throw Error(n(349));
      qc & 30 || gh(w, u, m);
    }
    P.memoizedState = m;
    var M = { value: m, getSnapshot: u };
    return P.queue = M, xh(vh.bind(
      null,
      w,
      M,
      l
    ), [l]), w.flags |= 2048, tu(9, mh.bind(null, w, M, m, u), void 0, null), m;
  }, useId: function() {
    var l = Ra(), u = Dr.identifierPrefix;
    if (vr) {
      var m = al, w = Mi;
      m = (w & ~(1 << 32 - $i(w) - 1)).toString(32) + m, u = ":" + u + "R" + m, m = ta++, 0 < m && (u += "H" + m.toString(32)), u += ":";
    } else
      m = Qc++, u = ":" + u + "r" + m.toString(32) + ":";
    return l.memoizedState = u;
  }, unstable_isNewReconciler: !1 }, sE = {
    readContext: Gr,
    useCallback: nd,
    useContext: Gr,
    useEffect: Af,
    useImperativeHandle: td,
    useInsertionEffect: Eh,
    useLayoutEffect: Ch,
    useMemo: nc,
    useReducer: $f,
    useRef: wh,
    useState: function() {
      return $f(eu);
    },
    useDebugValue: _h,
    useDeferredValue: function(l) {
      var u = Do();
      return No(u, Ne.memoizedState, l);
    },
    useTransition: function() {
      var l = $f(eu)[0], u = Do().memoizedState;
      return [l, u];
    },
    useMutableSource: ph,
    useSyncExternalStore: hh,
    useId: lr,
    unstable_isNewReconciler: !1
  }, ev = { readContext: Gr, useCallback: nd, useContext: Gr, useEffect: Af, useImperativeHandle: td, useInsertionEffect: Eh, useLayoutEffect: Ch, useMemo: nc, useReducer: Mf, useRef: wh, useState: function() {
    return Mf(eu);
  }, useDebugValue: _h, useDeferredValue: function(l) {
    var u = Do();
    return Ne === null ? u.memoizedState = l : No(u, Ne.memoizedState, l);
  }, useTransition: function() {
    var l = Mf(eu)[0], u = Do().memoizedState;
    return [l, u];
  }, useMutableSource: ph, useSyncExternalStore: hh, useId: lr, unstable_isNewReconciler: !1 };
  function id(l, u) {
    try {
      var m = "", w = u;
      do
        m += Me(w), w = w.return;
      while (w);
      var P = m;
    } catch (M) {
      P = `
Error generating stack: ` + M.message + `
` + M.stack;
    }
    return { value: l, source: u, stack: P, digest: null };
  }
  function Df(l, u, m) {
    return { value: l, source: null, stack: m ?? null, digest: u ?? null };
  }
  function Ih(l, u) {
    try {
      console.error(u.value);
    } catch (m) {
      setTimeout(function() {
        throw m;
      });
    }
  }
  var lE = typeof WeakMap == "function" ? WeakMap : Map;
  function E0(l, u, m) {
    m = ll(-1, m), m.tag = 3, m.payload = { element: null };
    var w = u.value;
    return m.callback = function() {
      Nh || (Nh = !0, su = w), Ih(l, u);
    }, m;
  }
  function Nf(l, u, m) {
    m = ll(-1, m), m.tag = 3;
    var w = l.type.getDerivedStateFromError;
    if (typeof w == "function") {
      var P = u.value;
      m.payload = function() {
        return w(P);
      }, m.callback = function() {
        Ih(l, u);
      };
    }
    var M = l.stateNode;
    return M !== null && typeof M.componentDidCatch == "function" && (m.callback = function() {
      Ih(l, u), typeof w != "function" && (Rs === null ? Rs = /* @__PURE__ */ new Set([this]) : Rs.add(this));
      var H = u.stack;
      this.componentDidCatch(u.value, { componentStack: H !== null ? H : "" });
    }), m;
  }
  function C0(l, u, m) {
    var w = l.pingCache;
    if (w === null) {
      w = l.pingCache = new lE();
      var P = /* @__PURE__ */ new Set();
      w.set(u, P);
    } else
      P = w.get(u), P === void 0 && (P = /* @__PURE__ */ new Set(), w.set(u, P));
    P.has(m) || (P.add(m), l = gE.bind(null, l, u, m), u.then(l, l));
  }
  function tv(l) {
    do {
      var u;
      if ((u = l.tag === 13) && (u = l.memoizedState, u = u !== null ? u.dehydrated !== null : !0), u)
        return l;
      l = l.return;
    } while (l !== null);
    return null;
  }
  function nv(l, u, m, w, P) {
    return l.mode & 1 ? (l.flags |= 65536, l.lanes = P, l) : (l === u ? l.flags |= 65536 : (l.flags |= 128, m.flags |= 131072, m.flags &= -52805, m.tag === 1 && (m.alternate === null ? m.tag = 17 : (u = ll(-1, 1), u.tag = 2, Zl(m, u, 1))), m.lanes |= 1), l);
  }
  var cE = L.ReactCurrentOwner, ri = !1;
  function si(l, u, m, w) {
    u.child = l === null ? w0(u, null, m, w) : Ju(u, l.child, m, w);
  }
  function rc(l, u, m, w, P) {
    m = m.render;
    var M = u.ref;
    return tt(u, P), w = tc(l, u, m, w, M, P), m = Jc(), l !== null && !ri ? (u.updateQueue = l.updateQueue, u.flags &= -2053, l.lanes &= ~P, Oi(l, u, P)) : (vr && m && th(u), u.flags |= 1, si(l, u, w, P), u.child);
  }
  function Rh(l, u, m, w, P) {
    if (l === null) {
      var M = m.type;
      return typeof M == "function" && !wv(M) && M.defaultProps === void 0 && m.compare === null && m.defaultProps === void 0 ? (u.tag = 15, u.type = M, Lo(l, u, M, w, P)) : (l = Fh(m.type, null, w, u, u.mode, P), l.ref = u.ref, l.return = u, u.child = l);
    }
    if (M = l.child, !(l.lanes & P)) {
      var H = M.memoizedProps;
      if (m = m.compare, m = m !== null ? m : vf, m(H, w) && l.ref === u.ref)
        return Oi(l, u, P);
    }
    return u.flags |= 1, l = sc(M, w), l.ref = u.ref, l.return = u, u.child = l;
  }
  function Lo(l, u, m, w, P) {
    if (l !== null) {
      var M = l.memoizedProps;
      if (vf(M, w) && l.ref === u.ref)
        if (ri = !1, u.pendingProps = w = M, (l.lanes & P) !== 0)
          l.flags & 131072 && (ri = !0);
        else
          return u.lanes = l.lanes, Oi(l, u, P);
    }
    return od(l, u, m, w, P);
  }
  function ru(l, u, m) {
    var w = u.pendingProps, P = w.children, M = l !== null ? l.memoizedState : null;
    if (w.mode === "hidden")
      if (!(u.mode & 1))
        u.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Vn(dd, na), na |= m;
      else {
        if (!(m & 1073741824))
          return l = M !== null ? M.baseLanes | m : m, u.lanes = u.childLanes = 1073741824, u.memoizedState = { baseLanes: l, cachePool: null, transitions: null }, u.updateQueue = null, Vn(dd, na), na |= l, null;
        u.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, w = M !== null ? M.baseLanes : m, Vn(dd, na), na |= w;
      }
    else
      M !== null ? (w = M.baseLanes | m, u.memoizedState = null) : w = m, Vn(dd, na), na |= w;
    return si(l, u, P, m), u.child;
  }
  function an(l, u) {
    var m = u.ref;
    (l === null && m !== null || l !== null && l.ref !== m) && (u.flags |= 512, u.flags |= 2097152);
  }
  function od(l, u, m, w, P) {
    var M = kr(m) ? Ro : Ht.current;
    return M = _a(u, M), tt(u, P), m = tc(l, u, m, w, M, P), w = Jc(), l !== null && !ri ? (u.updateQueue = l.updateQueue, u.flags &= -2053, l.lanes &= ~P, Oi(l, u, P)) : (vr && w && th(u), u.flags |= 1, si(l, u, m, P), u.child);
  }
  function rv(l, u, m, w, P) {
    if (kr(m)) {
      var M = !0;
      eh(u);
    } else
      M = !1;
    if (tt(u, P), u.stateNode === null)
      Xi(l, u), v0(u, m, w), ch(u, m, w, P), w = !0;
    else if (l === null) {
      var H = u.stateNode, Q = u.memoizedProps;
      H.props = Q;
      var ee = H.context, Te = m.contextType;
      typeof Te == "object" && Te !== null ? Te = Gr(Te) : (Te = kr(m) ? Ro : Ht.current, Te = _a(u, Te));
      var Ve = m.getDerivedStateFromProps, Ye = typeof Ve == "function" || typeof H.getSnapshotBeforeUpdate == "function";
      Ye || typeof H.UNSAFE_componentWillReceiveProps != "function" && typeof H.componentWillReceiveProps != "function" || (Q !== w || ee !== Te) && y0(u, H, w, Te), Ql = !1;
      var He = u.memoizedState;
      H.state = He, Jl(u, w, H, P), ee = u.memoizedState, Q !== w || He !== ee || Fr.current || Ql ? (typeof Ve == "function" && (qm(u, m, Ve, w), ee = u.memoizedState), (Q = Ql || m0(u, m, Q, w, He, ee, Te)) ? (Ye || typeof H.UNSAFE_componentWillMount != "function" && typeof H.componentWillMount != "function" || (typeof H.componentWillMount == "function" && H.componentWillMount(), typeof H.UNSAFE_componentWillMount == "function" && H.UNSAFE_componentWillMount()), typeof H.componentDidMount == "function" && (u.flags |= 4194308)) : (typeof H.componentDidMount == "function" && (u.flags |= 4194308), u.memoizedProps = w, u.memoizedState = ee), H.props = w, H.state = ee, H.context = Te, w = Q) : (typeof H.componentDidMount == "function" && (u.flags |= 4194308), w = !1);
    } else {
      H = u.stateNode, ai(l, u), Q = u.memoizedProps, Te = u.type === u.elementType ? Q : ea(u.type, Q), H.props = Te, Ye = u.pendingProps, He = H.context, ee = m.contextType, typeof ee == "object" && ee !== null ? ee = Gr(ee) : (ee = kr(m) ? Ro : Ht.current, ee = _a(u, ee));
      var lt = m.getDerivedStateFromProps;
      (Ve = typeof lt == "function" || typeof H.getSnapshotBeforeUpdate == "function") || typeof H.UNSAFE_componentWillReceiveProps != "function" && typeof H.componentWillReceiveProps != "function" || (Q !== Ye || He !== ee) && y0(u, H, w, ee), Ql = !1, He = u.memoizedState, H.state = He, Jl(u, w, H, P);
      var gt = u.memoizedState;
      Q !== Ye || He !== gt || Fr.current || Ql ? (typeof lt == "function" && (qm(u, m, lt, w), gt = u.memoizedState), (Te = Ql || m0(u, m, Te, w, He, gt, ee) || !1) ? (Ve || typeof H.UNSAFE_componentWillUpdate != "function" && typeof H.componentWillUpdate != "function" || (typeof H.componentWillUpdate == "function" && H.componentWillUpdate(w, gt, ee), typeof H.UNSAFE_componentWillUpdate == "function" && H.UNSAFE_componentWillUpdate(w, gt, ee)), typeof H.componentDidUpdate == "function" && (u.flags |= 4), typeof H.getSnapshotBeforeUpdate == "function" && (u.flags |= 1024)) : (typeof H.componentDidUpdate != "function" || Q === l.memoizedProps && He === l.memoizedState || (u.flags |= 4), typeof H.getSnapshotBeforeUpdate != "function" || Q === l.memoizedProps && He === l.memoizedState || (u.flags |= 1024), u.memoizedProps = w, u.memoizedState = gt), H.props = w, H.state = gt, H.context = ee, w = Te) : (typeof H.componentDidUpdate != "function" || Q === l.memoizedProps && He === l.memoizedState || (u.flags |= 4), typeof H.getSnapshotBeforeUpdate != "function" || Q === l.memoizedProps && He === l.memoizedState || (u.flags |= 1024), w = !1);
    }
    return _0(l, u, m, w, M, P);
  }
  function _0(l, u, m, w, P, M) {
    an(l, u);
    var H = (u.flags & 128) !== 0;
    if (!w && !H)
      return P && u0(u, m, !1), Oi(l, u, M);
    w = u.stateNode, cE.current = u;
    var Q = H && typeof m.getDerivedStateFromError != "function" ? null : w.render();
    return u.flags |= 1, l !== null && H ? (u.child = Ju(u, l.child, null, M), u.child = Ju(u, null, Q, M)) : si(l, u, Q, M), u.memoizedState = w.state, P && u0(u, m, !0), u.child;
  }
  function T0(l) {
    var u = l.stateNode;
    u.pendingContext ? Wl(l, u.pendingContext, u.pendingContext !== u.context) : u.context && Wl(l, u.context, !1), Qm(l, u.containerInfo);
  }
  function $h(l, u, m, w, P) {
    return Ar(), Vm(P), u.flags |= 256, si(l, u, m, w), u.child;
  }
  var iu = { dehydrated: null, treeContext: null, retryLane: 0 };
  function iv(l) {
    return { baseLanes: l, cachePool: null, transitions: null };
  }
  function ov(l, u, m) {
    var w = u.pendingProps, P = Lt.current, M = !1, H = (u.flags & 128) !== 0, Q;
    if ((Q = H) || (Q = l !== null && l.memoizedState === null ? !1 : (P & 2) !== 0), Q ? (M = !0, u.flags &= -129) : (l === null || l.memoizedState !== null) && (P |= 1), Vn(Lt, P & 1), l === null)
      return rh(u), l = u.memoizedState, l !== null && (l = l.dehydrated, l !== null) ? (u.mode & 1 ? l.data === "$!" ? u.lanes = 8 : u.lanes = 1073741824 : u.lanes = 1, null) : (H = w.children, l = w.fallback, M ? (w = u.mode, M = u.child, H = { mode: "hidden", children: H }, !(w & 1) && M !== null ? (M.childLanes = 0, M.pendingProps = H) : M = Kf(H, w, 0, null), l = fu(l, w, m, null), M.return = u, l.return = u, M.sibling = l, u.child = M, u.child.memoizedState = iv(m), u.memoizedState = iu, l) : av(u, H));
    if (P = l.memoizedState, P !== null && (Q = P.dehydrated, Q !== null))
      return uE(l, u, H, w, Q, P, m);
    if (M) {
      M = w.fallback, H = u.mode, P = l.child, Q = P.sibling;
      var ee = { mode: "hidden", children: w.children };
      return !(H & 1) && u.child !== P ? (w = u.child, w.childLanes = 0, w.pendingProps = ee, u.deletions = null) : (w = sc(P, ee), w.subtreeFlags = P.subtreeFlags & 14680064), Q !== null ? M = sc(Q, M) : (M = fu(M, H, m, null), M.flags |= 2), M.return = u, w.return = u, w.sibling = M, u.child = w, w = M, M = u.child, H = l.child.memoizedState, H = H === null ? iv(m) : { baseLanes: H.baseLanes | m, cachePool: null, transitions: H.transitions }, M.memoizedState = H, M.childLanes = l.childLanes & ~m, u.memoizedState = iu, w;
    }
    return M = l.child, l = M.sibling, w = sc(M, { mode: "visible", children: w.children }), !(u.mode & 1) && (w.lanes = m), w.return = u, w.sibling = null, l !== null && (m = u.deletions, m === null ? (u.deletions = [l], u.flags |= 16) : m.push(l)), u.child = w, u.memoizedState = null, w;
  }
  function av(l, u) {
    return u = Kf({ mode: "visible", children: u }, l.mode, 0, null), u.return = l, l.child = u;
  }
  function ad(l, u, m, w) {
    return w !== null && Vm(w), Ju(u, l.child, null, m), l = av(u, u.pendingProps.children), l.flags |= 2, u.memoizedState = null, l;
  }
  function uE(l, u, m, w, P, M, H) {
    if (m)
      return u.flags & 256 ? (u.flags &= -257, w = Df(Error(n(422))), ad(l, u, H, w)) : u.memoizedState !== null ? (u.child = l.child, u.flags |= 128, null) : (M = w.fallback, P = u.mode, w = Kf({ mode: "visible", children: w.children }, P, 0, null), M = fu(M, P, H, null), M.flags |= 2, w.return = u, M.return = u, w.sibling = M, u.child = w, u.mode & 1 && Ju(u, l.child, null, H), u.child.memoizedState = iv(H), u.memoizedState = iu, M);
    if (!(u.mode & 1))
      return ad(l, u, H, null);
    if (P.data === "$!") {
      if (w = P.nextSibling && P.nextSibling.dataset, w)
        var Q = w.dgst;
      return w = Q, M = Error(n(419)), w = Df(M, w, void 0), ad(l, u, H, w);
    }
    if (Q = (H & l.childLanes) !== 0, ri || Q) {
      if (w = Dr, w !== null) {
        switch (H & -H) {
          case 4:
            P = 2;
            break;
          case 16:
            P = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            P = 32;
            break;
          case 536870912:
            P = 268435456;
            break;
          default:
            P = 0;
        }
        P = P & (w.suspendedLanes | H) ? 0 : P, P !== 0 && P !== M.retryLane && (M.retryLane = P, sl(l, P), Ji(w, l, P, -1));
      }
      return yv(), w = Df(Error(n(421))), ad(l, u, H, w);
    }
    return P.data === "$?" ? (u.flags |= 128, u.child = l.child, u = mE.bind(null, l), P._reactRetry = u, null) : (l = M.treeContext, Oo = ts(P.nextSibling), Jo = u, vr = !0, Pa = null, l !== null && (Ao[Gi++] = Mi, Ao[Gi++] = al, Ao[Gi++] = ka, Mi = l.id, al = l.overflow, ka = u), u = av(u, w.children), u.flags |= 4096, u);
  }
  function sv(l, u, m) {
    l.lanes |= u;
    var w = l.alternate;
    w !== null && (w.lanes |= u), Ei(l.return, u, m);
  }
  function Mh(l, u, m, w, P) {
    var M = l.memoizedState;
    M === null ? l.memoizedState = { isBackwards: u, rendering: null, renderingStartTime: 0, last: w, tail: m, tailMode: P } : (M.isBackwards = u, M.rendering = null, M.renderingStartTime = 0, M.last = w, M.tail = m, M.tailMode = P);
  }
  function lv(l, u, m) {
    var w = u.pendingProps, P = w.revealOrder, M = w.tail;
    if (si(l, u, w.children, m), w = Lt.current, w & 2)
      w = w & 1 | 2, u.flags |= 128;
    else {
      if (l !== null && l.flags & 128)
        e:
          for (l = u.child; l !== null; ) {
            if (l.tag === 13)
              l.memoizedState !== null && sv(l, m, u);
            else if (l.tag === 19)
              sv(l, m, u);
            else if (l.child !== null) {
              l.child.return = l, l = l.child;
              continue;
            }
            if (l === u)
              break e;
            for (; l.sibling === null; ) {
              if (l.return === null || l.return === u)
                break e;
              l = l.return;
            }
            l.sibling.return = l.return, l = l.sibling;
          }
      w &= 1;
    }
    if (Vn(Lt, w), !(u.mode & 1))
      u.memoizedState = null;
    else
      switch (P) {
        case "forwards":
          for (m = u.child, P = null; m !== null; )
            l = m.alternate, l !== null && Or(l) === null && (P = m), m = m.sibling;
          m = P, m === null ? (P = u.child, u.child = null) : (P = m.sibling, m.sibling = null), Mh(u, !1, P, m, M);
          break;
        case "backwards":
          for (m = null, P = u.child, u.child = null; P !== null; ) {
            if (l = P.alternate, l !== null && Or(l) === null) {
              u.child = P;
              break;
            }
            l = P.sibling, P.sibling = m, m = P, P = l;
          }
          Mh(u, !0, m, null, M);
          break;
        case "together":
          Mh(u, !1, null, null, void 0);
          break;
        default:
          u.memoizedState = null;
      }
    return u.child;
  }
  function Xi(l, u) {
    !(u.mode & 1) && l !== null && (l.alternate = null, u.alternate = null, u.flags |= 2);
  }
  function Oi(l, u, m) {
    if (l !== null && (u.dependencies = l.dependencies), fl |= u.lanes, !(m & u.childLanes))
      return null;
    if (l !== null && u.child !== l.child)
      throw Error(n(153));
    if (u.child !== null) {
      for (l = u.child, m = sc(l, l.pendingProps), u.child = m, m.return = u; l.sibling !== null; )
        l = l.sibling, m = m.sibling = sc(l, l.pendingProps), m.return = u;
      m.sibling = null;
    }
    return u.child;
  }
  function ul(l, u, m) {
    switch (u.tag) {
      case 3:
        T0(u), Ar();
        break;
      case 5:
        Dt(u);
        break;
      case 1:
        kr(u.type) && eh(u);
        break;
      case 4:
        Qm(u, u.stateNode.containerInfo);
        break;
      case 10:
        var w = u.type._context, P = u.memoizedProps.value;
        Vn(Ts, w._currentValue), w._currentValue = P;
        break;
      case 13:
        if (w = u.memoizedState, w !== null)
          return w.dehydrated !== null ? (Vn(Lt, Lt.current & 1), u.flags |= 128, null) : m & u.child.childLanes ? ov(l, u, m) : (Vn(Lt, Lt.current & 1), l = Oi(l, u, m), l !== null ? l.sibling : null);
        Vn(Lt, Lt.current & 1);
        break;
      case 19:
        if (w = (m & u.childLanes) !== 0, l.flags & 128) {
          if (w)
            return lv(l, u, m);
          u.flags |= 128;
        }
        if (P = u.memoizedState, P !== null && (P.rendering = null, P.tail = null, P.lastEffect = null), Vn(Lt, Lt.current), w)
          break;
        return null;
      case 22:
      case 23:
        return u.lanes = 0, ru(l, u, m);
    }
    return Oi(l, u, m);
  }
  var Lf, ou, $a, li;
  Lf = function(l, u) {
    for (var m = u.child; m !== null; ) {
      if (m.tag === 5 || m.tag === 6)
        l.appendChild(m.stateNode);
      else if (m.tag !== 4 && m.child !== null) {
        m.child.return = m, m = m.child;
        continue;
      }
      if (m === u)
        break;
      for (; m.sibling === null; ) {
        if (m.return === null || m.return === u)
          return;
        m = m.return;
      }
      m.sibling.return = m.return, m = m.sibling;
    }
  }, ou = function() {
  }, $a = function(l, u, m, w) {
    var P = l.memoizedProps;
    if (P !== w) {
      l = u.stateNode, Xc(ns.current);
      var M = null;
      switch (m) {
        case "input":
          P = Ke(l, P), w = Ke(l, w), M = [];
          break;
        case "select":
          P = W({}, P, { value: void 0 }), w = W({}, w, { value: void 0 }), M = [];
          break;
        case "textarea":
          P = zr(l, P), w = zr(l, w), M = [];
          break;
        default:
          typeof P.onClick != "function" && typeof w.onClick == "function" && (l.onclick = Jp);
      }
      _r(m, w);
      var H;
      m = null;
      for (Te in P)
        if (!w.hasOwnProperty(Te) && P.hasOwnProperty(Te) && P[Te] != null)
          if (Te === "style") {
            var Q = P[Te];
            for (H in Q)
              Q.hasOwnProperty(H) && (m || (m = {}), m[H] = "");
          } else
            Te !== "dangerouslySetInnerHTML" && Te !== "children" && Te !== "suppressContentEditableWarning" && Te !== "suppressHydrationWarning" && Te !== "autoFocus" && (a.hasOwnProperty(Te) ? M || (M = []) : (M = M || []).push(Te, null));
      for (Te in w) {
        var ee = w[Te];
        if (Q = P?.[Te], w.hasOwnProperty(Te) && ee !== Q && (ee != null || Q != null))
          if (Te === "style")
            if (Q) {
              for (H in Q)
                !Q.hasOwnProperty(H) || ee && ee.hasOwnProperty(H) || (m || (m = {}), m[H] = "");
              for (H in ee)
                ee.hasOwnProperty(H) && Q[H] !== ee[H] && (m || (m = {}), m[H] = ee[H]);
            } else
              m || (M || (M = []), M.push(
                Te,
                m
              )), m = ee;
          else
            Te === "dangerouslySetInnerHTML" ? (ee = ee ? ee.__html : void 0, Q = Q ? Q.__html : void 0, ee != null && Q !== ee && (M = M || []).push(Te, ee)) : Te === "children" ? typeof ee != "string" && typeof ee != "number" || (M = M || []).push(Te, "" + ee) : Te !== "suppressContentEditableWarning" && Te !== "suppressHydrationWarning" && (a.hasOwnProperty(Te) ? (ee != null && Te === "onScroll" && sr("scroll", l), M || Q === ee || (M = [])) : (M = M || []).push(Te, ee));
      }
      m && (M = M || []).push("style", m);
      var Te = M;
      (u.updateQueue = Te) && (u.flags |= 4);
    }
  }, li = function(l, u, m, w) {
    m !== w && (u.flags |= 4);
  };
  function jf(l, u) {
    if (!vr)
      switch (l.tailMode) {
        case "hidden":
          u = l.tail;
          for (var m = null; u !== null; )
            u.alternate !== null && (m = u), u = u.sibling;
          m === null ? l.tail = null : m.sibling = null;
          break;
        case "collapsed":
          m = l.tail;
          for (var w = null; m !== null; )
            m.alternate !== null && (w = m), m = m.sibling;
          w === null ? u || l.tail === null ? l.tail = null : l.tail.sibling = null : w.sibling = null;
      }
  }
  function qi(l) {
    var u = l.alternate !== null && l.alternate.child === l.child, m = 0, w = 0;
    if (u)
      for (var P = l.child; P !== null; )
        m |= P.lanes | P.childLanes, w |= P.subtreeFlags & 14680064, w |= P.flags & 14680064, P.return = l, P = P.sibling;
    else
      for (P = l.child; P !== null; )
        m |= P.lanes | P.childLanes, w |= P.subtreeFlags, w |= P.flags, P.return = l, P = P.sibling;
    return l.subtreeFlags |= w, l.childLanes = m, u;
  }
  function dE(l, u, m) {
    var w = u.pendingProps;
    switch (Fm(u), u.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return qi(u), null;
      case 1:
        return kr(u.type) && Ta(), qi(u), null;
      case 3:
        return w = u.stateNode, ec(), Un(Fr), Un(Ht), dh(), w.pendingContext && (w.context = w.pendingContext, w.pendingContext = null), (l === null || l.child === null) && (ih(u) ? u.flags |= 4 : l === null || l.memoizedState.isDehydrated && !(u.flags & 256) || (u.flags |= 1024, Pa !== null && (Yf(Pa), Pa = null))), ou(l, u), qi(u), null;
      case 5:
        fn(u);
        var P = Xc(ed.current);
        if (m = u.type, l !== null && u.stateNode != null)
          $a(l, u, m, w, P), l.ref !== u.ref && (u.flags |= 512, u.flags |= 2097152);
        else {
          if (!w) {
            if (u.stateNode === null)
              throw Error(n(166));
            return qi(u), null;
          }
          if (l = Xc(ns.current), ih(u)) {
            w = u.stateNode, m = u.type;
            var M = u.memoizedProps;
            switch (w[Cs] = u, w[Kc] = M, l = (u.mode & 1) !== 0, m) {
              case "dialog":
                sr("cancel", w), sr("close", w);
                break;
              case "iframe":
              case "object":
              case "embed":
                sr("load", w);
                break;
              case "video":
              case "audio":
                for (P = 0; P < wf.length; P++)
                  sr(wf[P], w);
                break;
              case "source":
                sr("error", w);
                break;
              case "img":
              case "image":
              case "link":
                sr(
                  "error",
                  w
                ), sr("load", w);
                break;
              case "details":
                sr("toggle", w);
                break;
              case "input":
                yt(w, M), sr("invalid", w);
                break;
              case "select":
                w._wrapperState = { wasMultiple: !!M.multiple }, sr("invalid", w);
                break;
              case "textarea":
                Hn(w, M), sr("invalid", w);
            }
            _r(m, M), P = null;
            for (var H in M)
              if (M.hasOwnProperty(H)) {
                var Q = M[H];
                H === "children" ? typeof Q == "string" ? w.textContent !== Q && (M.suppressHydrationWarning !== !0 && Zp(w.textContent, Q, l), P = ["children", Q]) : typeof Q == "number" && w.textContent !== "" + Q && (M.suppressHydrationWarning !== !0 && Zp(
                  w.textContent,
                  Q,
                  l
                ), P = ["children", "" + Q]) : a.hasOwnProperty(H) && Q != null && H === "onScroll" && sr("scroll", w);
              }
            switch (m) {
              case "input":
                Tt(w), yn(w, M, !0);
                break;
              case "textarea":
                Tt(w), cn(w);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof M.onClick == "function" && (w.onclick = Jp);
            }
            w = P, u.updateQueue = w, w !== null && (u.flags |= 4);
          } else {
            H = P.nodeType === 9 ? P : P.ownerDocument, l === "http://www.w3.org/1999/xhtml" && (l = ti(m)), l === "http://www.w3.org/1999/xhtml" ? m === "script" ? (l = H.createElement("div"), l.innerHTML = "<script><\/script>", l = l.removeChild(l.firstChild)) : typeof w.is == "string" ? l = H.createElement(m, { is: w.is }) : (l = H.createElement(m), m === "select" && (H = l, w.multiple ? H.multiple = !0 : w.size && (H.size = w.size))) : l = H.createElementNS(l, m), l[Cs] = u, l[Kc] = w, Lf(l, u, !1, !1), u.stateNode = l;
            e: {
              switch (H = ur(m, w), m) {
                case "dialog":
                  sr("cancel", l), sr("close", l), P = w;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  sr("load", l), P = w;
                  break;
                case "video":
                case "audio":
                  for (P = 0; P < wf.length; P++)
                    sr(wf[P], l);
                  P = w;
                  break;
                case "source":
                  sr("error", l), P = w;
                  break;
                case "img":
                case "image":
                case "link":
                  sr(
                    "error",
                    l
                  ), sr("load", l), P = w;
                  break;
                case "details":
                  sr("toggle", l), P = w;
                  break;
                case "input":
                  yt(l, w), P = Ke(l, w), sr("invalid", l);
                  break;
                case "option":
                  P = w;
                  break;
                case "select":
                  l._wrapperState = { wasMultiple: !!w.multiple }, P = W({}, w, { value: void 0 }), sr("invalid", l);
                  break;
                case "textarea":
                  Hn(l, w), P = zr(l, w), sr("invalid", l);
                  break;
                default:
                  P = w;
              }
              _r(m, P), Q = P;
              for (M in Q)
                if (Q.hasOwnProperty(M)) {
                  var ee = Q[M];
                  M === "style" ? kn(l, ee) : M === "dangerouslySetInnerHTML" ? (ee = ee ? ee.__html : void 0, ee != null && Ko(l, ee)) : M === "children" ? typeof ee == "string" ? (m !== "textarea" || ee !== "") && Cr(l, ee) : typeof ee == "number" && Cr(l, "" + ee) : M !== "suppressContentEditableWarning" && M !== "suppressHydrationWarning" && M !== "autoFocus" && (a.hasOwnProperty(M) ? ee != null && M === "onScroll" && sr("scroll", l) : ee != null && j(l, M, ee, H));
                }
              switch (m) {
                case "input":
                  Tt(l), yn(l, w, !1);
                  break;
                case "textarea":
                  Tt(l), cn(l);
                  break;
                case "option":
                  w.value != null && l.setAttribute("value", "" + ke(w.value));
                  break;
                case "select":
                  l.multiple = !!w.multiple, M = w.value, M != null ? Mr(l, !!w.multiple, M, !1) : w.defaultValue != null && Mr(
                    l,
                    !!w.multiple,
                    w.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof P.onClick == "function" && (l.onclick = Jp);
              }
              switch (m) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  w = !!w.autoFocus;
                  break e;
                case "img":
                  w = !0;
                  break e;
                default:
                  w = !1;
              }
            }
            w && (u.flags |= 4);
          }
          u.ref !== null && (u.flags |= 512, u.flags |= 2097152);
        }
        return qi(u), null;
      case 6:
        if (l && u.stateNode != null)
          li(l, u, l.memoizedProps, w);
        else {
          if (typeof w != "string" && u.stateNode === null)
            throw Error(n(166));
          if (m = Xc(ed.current), Xc(ns.current), ih(u)) {
            if (w = u.stateNode, m = u.memoizedProps, w[Cs] = u, (M = w.nodeValue !== m) && (l = Jo, l !== null))
              switch (l.tag) {
                case 3:
                  Zp(w.nodeValue, m, (l.mode & 1) !== 0);
                  break;
                case 5:
                  l.memoizedProps.suppressHydrationWarning !== !0 && Zp(w.nodeValue, m, (l.mode & 1) !== 0);
              }
            M && (u.flags |= 4);
          } else
            w = (m.nodeType === 9 ? m : m.ownerDocument).createTextNode(w), w[Cs] = u, u.stateNode = w;
        }
        return qi(u), null;
      case 13:
        if (Un(Lt), w = u.memoizedState, l === null || l.memoizedState !== null && l.memoizedState.dehydrated !== null) {
          if (vr && Oo !== null && u.mode & 1 && !(u.flags & 128))
            p0(), Ar(), u.flags |= 98560, M = !1;
          else if (M = ih(u), w !== null && w.dehydrated !== null) {
            if (l === null) {
              if (!M)
                throw Error(n(318));
              if (M = u.memoizedState, M = M !== null ? M.dehydrated : null, !M)
                throw Error(n(317));
              M[Cs] = u;
            } else
              Ar(), !(u.flags & 128) && (u.memoizedState = null), u.flags |= 4;
            qi(u), M = !1;
          } else
            Pa !== null && (Yf(Pa), Pa = null), M = !0;
          if (!M)
            return u.flags & 65536 ? u : null;
        }
        return u.flags & 128 ? (u.lanes = m, u) : (w = w !== null, w !== (l !== null && l.memoizedState !== null) && w && (u.child.flags |= 8192, u.mode & 1 && (l === null || Lt.current & 1 ? ui === 0 && (ui = 3) : yv())), u.updateQueue !== null && (u.flags |= 4), qi(u), null);
      case 4:
        return ec(), ou(l, u), l === null && Xu(u.stateNode.containerInfo), qi(u), null;
      case 10:
        return ql(u.type._context), qi(u), null;
      case 17:
        return kr(u.type) && Ta(), qi(u), null;
      case 19:
        if (Un(Lt), M = u.memoizedState, M === null)
          return qi(u), null;
        if (w = (u.flags & 128) !== 0, H = M.rendering, H === null)
          if (w)
            jf(M, !1);
          else {
            if (ui !== 0 || l !== null && l.flags & 128)
              for (l = u.child; l !== null; ) {
                if (H = Or(l), H !== null) {
                  for (u.flags |= 128, jf(M, !1), w = H.updateQueue, w !== null && (u.updateQueue = w, u.flags |= 4), u.subtreeFlags = 0, w = m, m = u.child; m !== null; )
                    M = m, l = w, M.flags &= 14680066, H = M.alternate, H === null ? (M.childLanes = 0, M.lanes = l, M.child = null, M.subtreeFlags = 0, M.memoizedProps = null, M.memoizedState = null, M.updateQueue = null, M.dependencies = null, M.stateNode = null) : (M.childLanes = H.childLanes, M.lanes = H.lanes, M.child = H.child, M.subtreeFlags = 0, M.deletions = null, M.memoizedProps = H.memoizedProps, M.memoizedState = H.memoizedState, M.updateQueue = H.updateQueue, M.type = H.type, l = H.dependencies, M.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }), m = m.sibling;
                  return Vn(Lt, Lt.current & 1 | 2), u.child;
                }
                l = l.sibling;
              }
            M.tail !== null && bn() > pd && (u.flags |= 128, w = !0, jf(M, !1), u.lanes = 4194304);
          }
        else {
          if (!w)
            if (l = Or(H), l !== null) {
              if (u.flags |= 128, w = !0, m = l.updateQueue, m !== null && (u.updateQueue = m, u.flags |= 4), jf(M, !0), M.tail === null && M.tailMode === "hidden" && !H.alternate && !vr)
                return qi(u), null;
            } else
              2 * bn() - M.renderingStartTime > pd && m !== 1073741824 && (u.flags |= 128, w = !0, jf(M, !1), u.lanes = 4194304);
          M.isBackwards ? (H.sibling = u.child, u.child = H) : (m = M.last, m !== null ? m.sibling = H : u.child = H, M.last = H);
        }
        return M.tail !== null ? (u = M.tail, M.rendering = u, M.tail = u.sibling, M.renderingStartTime = bn(), u.sibling = null, m = Lt.current, Vn(Lt, w ? m & 1 | 2 : m & 1), u) : (qi(u), null);
      case 22:
      case 23:
        return vv(), w = u.memoizedState !== null, l !== null && l.memoizedState !== null !== w && (u.flags |= 8192), w && u.mode & 1 ? na & 1073741824 && (qi(u), u.subtreeFlags & 6 && (u.flags |= 8192)) : qi(u), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(n(156, u.tag));
  }
  function cv(l, u) {
    switch (Fm(u), u.tag) {
      case 1:
        return kr(u.type) && Ta(), l = u.flags, l & 65536 ? (u.flags = l & -65537 | 128, u) : null;
      case 3:
        return ec(), Un(Fr), Un(Ht), dh(), l = u.flags, l & 65536 && !(l & 128) ? (u.flags = l & -65537 | 128, u) : null;
      case 5:
        return fn(u), null;
      case 13:
        if (Un(Lt), l = u.memoizedState, l !== null && l.dehydrated !== null) {
          if (u.alternate === null)
            throw Error(n(340));
          Ar();
        }
        return l = u.flags, l & 65536 ? (u.flags = l & -65537 | 128, u) : null;
      case 19:
        return Un(Lt), null;
      case 4:
        return ec(), null;
      case 10:
        return ql(u.type._context), null;
      case 22:
      case 23:
        return vv(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var zf = !1, ci = !1, k0 = typeof WeakSet == "function" ? WeakSet : Set, ft = null;
  function sd(l, u) {
    var m = l.ref;
    if (m !== null)
      if (typeof m == "function")
        try {
          m(null);
        } catch (w) {
          Vr(l, u, w);
        }
      else
        m.current = null;
  }
  function Uf(l, u, m) {
    try {
      m();
    } catch (w) {
      Vr(l, u, w);
    }
  }
  var P0 = !1;
  function I0(l, u) {
    if (Om = ie, l = Wp(), nl(l)) {
      if ("selectionStart" in l)
        var m = { start: l.selectionStart, end: l.selectionEnd };
      else
        e: {
          m = (m = l.ownerDocument) && m.defaultView || window;
          var w = m.getSelection && m.getSelection();
          if (w && w.rangeCount !== 0) {
            m = w.anchorNode;
            var P = w.anchorOffset, M = w.focusNode;
            w = w.focusOffset;
            try {
              m.nodeType, M.nodeType;
            } catch {
              m = null;
              break e;
            }
            var H = 0, Q = -1, ee = -1, Te = 0, Ve = 0, Ye = l, He = null;
            t:
              for (; ; ) {
                for (var lt; Ye !== m || P !== 0 && Ye.nodeType !== 3 || (Q = H + P), Ye !== M || w !== 0 && Ye.nodeType !== 3 || (ee = H + w), Ye.nodeType === 3 && (H += Ye.nodeValue.length), (lt = Ye.firstChild) !== null; )
                  He = Ye, Ye = lt;
                for (; ; ) {
                  if (Ye === l)
                    break t;
                  if (He === m && ++Te === P && (Q = H), He === M && ++Ve === w && (ee = H), (lt = Ye.nextSibling) !== null)
                    break;
                  Ye = He, He = Ye.parentNode;
                }
                Ye = lt;
              }
            m = Q === -1 || ee === -1 ? null : { start: Q, end: ee };
          } else
            m = null;
        }
      m = m || { start: 0, end: 0 };
    } else
      m = null;
    for (Vc = { focusedElem: l, selectionRange: m }, ie = !1, ft = u; ft !== null; )
      if (u = ft, l = u.child, (u.subtreeFlags & 1028) !== 0 && l !== null)
        l.return = u, ft = l;
      else
        for (; ft !== null; ) {
          u = ft;
          try {
            var gt = u.alternate;
            if (u.flags & 1024)
              switch (u.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (gt !== null) {
                    var wt = gt.memoizedProps, Xr = gt.memoizedState, ge = u.stateNode, oe = ge.getSnapshotBeforeUpdate(u.elementType === u.type ? wt : ea(u.type, wt), Xr);
                    ge.__reactInternalSnapshotBeforeUpdate = oe;
                  }
                  break;
                case 3:
                  var we = u.stateNode.containerInfo;
                  we.nodeType === 1 ? we.textContent = "" : we.nodeType === 9 && we.documentElement && we.removeChild(we.documentElement);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(n(163));
              }
          } catch (Xe) {
            Vr(u, u.return, Xe);
          }
          if (l = u.sibling, l !== null) {
            l.return = u.return, ft = l;
            break;
          }
          ft = u.return;
        }
    return gt = P0, P0 = !1, gt;
  }
  function Bf(l, u, m) {
    var w = u.updateQueue;
    if (w = w !== null ? w.lastEffect : null, w !== null) {
      var P = w = w.next;
      do {
        if ((P.tag & l) === l) {
          var M = P.destroy;
          P.destroy = void 0, M !== void 0 && Uf(u, m, M);
        }
        P = P.next;
      } while (P !== w);
    }
  }
  function Ff(l, u) {
    if (u = u.updateQueue, u = u !== null ? u.lastEffect : null, u !== null) {
      var m = u = u.next;
      do {
        if ((m.tag & l) === l) {
          var w = m.create;
          m.destroy = w();
        }
        m = m.next;
      } while (m !== u);
    }
  }
  function uv(l) {
    var u = l.ref;
    if (u !== null) {
      var m = l.stateNode;
      switch (l.tag) {
        case 5:
          l = m;
          break;
        default:
          l = m;
      }
      typeof u == "function" ? u(l) : u.current = l;
    }
  }
  function dv(l) {
    var u = l.alternate;
    u !== null && (l.alternate = null, dv(u)), l.child = null, l.deletions = null, l.sibling = null, l.tag === 5 && (u = l.stateNode, u !== null && (delete u[Cs], delete u[Kc], delete u[Lm], delete u[iE], delete u[jm])), l.stateNode = null, l.return = null, l.dependencies = null, l.memoizedProps = null, l.memoizedState = null, l.pendingProps = null, l.stateNode = null, l.updateQueue = null;
  }
  function R0(l) {
    return l.tag === 5 || l.tag === 3 || l.tag === 4;
  }
  function Ah(l) {
    e:
      for (; ; ) {
        for (; l.sibling === null; ) {
          if (l.return === null || R0(l.return))
            return null;
          l = l.return;
        }
        for (l.sibling.return = l.return, l = l.sibling; l.tag !== 5 && l.tag !== 6 && l.tag !== 18; ) {
          if (l.flags & 2 || l.child === null || l.tag === 4)
            continue e;
          l.child.return = l, l = l.child;
        }
        if (!(l.flags & 2))
          return l.stateNode;
      }
  }
  function ld(l, u, m) {
    var w = l.tag;
    if (w === 5 || w === 6)
      l = l.stateNode, u ? m.nodeType === 8 ? m.parentNode.insertBefore(l, u) : m.insertBefore(l, u) : (m.nodeType === 8 ? (u = m.parentNode, u.insertBefore(l, m)) : (u = m, u.appendChild(l)), m = m._reactRootContainer, m != null || u.onclick !== null || (u.onclick = Jp));
    else if (w !== 4 && (l = l.child, l !== null))
      for (ld(l, u, m), l = l.sibling; l !== null; )
        ld(l, u, m), l = l.sibling;
  }
  function Ps(l, u, m) {
    var w = l.tag;
    if (w === 5 || w === 6)
      l = l.stateNode, u ? m.insertBefore(l, u) : m.appendChild(l);
    else if (w !== 4 && (l = l.child, l !== null))
      for (Ps(l, u, m), l = l.sibling; l !== null; )
        Ps(l, u, m), l = l.sibling;
  }
  var Pr = null, Ci = !1;
  function Ma(l, u, m) {
    for (m = m.child; m !== null; )
      cd(l, u, m), m = m.sibling;
  }
  function cd(l, u, m) {
    if (Ki && typeof Ki.onCommitFiberUnmount == "function")
      try {
        Ki.onCommitFiberUnmount(ys, m);
      } catch {
      }
    switch (m.tag) {
      case 5:
        ci || sd(m, u);
      case 6:
        var w = Pr, P = Ci;
        Pr = null, Ma(l, u, m), Pr = w, Ci = P, Pr !== null && (Ci ? (l = Pr, m = m.stateNode, l.nodeType === 8 ? l.parentNode.removeChild(m) : l.removeChild(m)) : Pr.removeChild(m.stateNode));
        break;
      case 18:
        Pr !== null && (Ci ? (l = Pr, m = m.stateNode, l.nodeType === 8 ? Vl(l.parentNode, m) : l.nodeType === 1 && Vl(l, m), Es(l)) : Vl(Pr, m.stateNode));
        break;
      case 4:
        w = Pr, P = Ci, Pr = m.stateNode.containerInfo, Ci = !0, Ma(l, u, m), Pr = w, Ci = P;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!ci && (w = m.updateQueue, w !== null && (w = w.lastEffect, w !== null))) {
          P = w = w.next;
          do {
            var M = P, H = M.destroy;
            M = M.tag, H !== void 0 && (M & 2 || M & 4) && Uf(m, u, H), P = P.next;
          } while (P !== w);
        }
        Ma(l, u, m);
        break;
      case 1:
        if (!ci && (sd(m, u), w = m.stateNode, typeof w.componentWillUnmount == "function"))
          try {
            w.props = m.memoizedProps, w.state = m.memoizedState, w.componentWillUnmount();
          } catch (Q) {
            Vr(m, u, Q);
          }
        Ma(l, u, m);
        break;
      case 21:
        Ma(l, u, m);
        break;
      case 22:
        m.mode & 1 ? (ci = (w = ci) || m.memoizedState !== null, Ma(l, u, m), ci = w) : Ma(l, u, m);
        break;
      default:
        Ma(l, u, m);
    }
  }
  function dl(l) {
    var u = l.updateQueue;
    if (u !== null) {
      l.updateQueue = null;
      var m = l.stateNode;
      m === null && (m = l.stateNode = new k0()), u.forEach(function(w) {
        var P = vE.bind(null, l, w);
        m.has(w) || (m.add(w), w.then(P, P));
      });
    }
  }
  function rs(l, u) {
    var m = u.deletions;
    if (m !== null)
      for (var w = 0; w < m.length; w++) {
        var P = m[w];
        try {
          var M = l, H = u, Q = H;
          e:
            for (; Q !== null; ) {
              switch (Q.tag) {
                case 5:
                  Pr = Q.stateNode, Ci = !1;
                  break e;
                case 3:
                  Pr = Q.stateNode.containerInfo, Ci = !0;
                  break e;
                case 4:
                  Pr = Q.stateNode.containerInfo, Ci = !0;
                  break e;
              }
              Q = Q.return;
            }
          if (Pr === null)
            throw Error(n(160));
          cd(M, H, P), Pr = null, Ci = !1;
          var ee = P.alternate;
          ee !== null && (ee.return = null), P.return = null;
        } catch (Te) {
          Vr(P, u, Te);
        }
      }
    if (u.subtreeFlags & 12854)
      for (u = u.child; u !== null; )
        $0(u, l), u = u.sibling;
  }
  function $0(l, u) {
    var m = l.alternate, w = l.flags;
    switch (l.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (rs(u, l), Is(l), w & 4) {
          try {
            Bf(3, l, l.return), Ff(3, l);
          } catch (wt) {
            Vr(l, l.return, wt);
          }
          try {
            Bf(5, l, l.return);
          } catch (wt) {
            Vr(l, l.return, wt);
          }
        }
        break;
      case 1:
        rs(u, l), Is(l), w & 512 && m !== null && sd(m, m.return);
        break;
      case 5:
        if (rs(u, l), Is(l), w & 512 && m !== null && sd(m, m.return), l.flags & 32) {
          var P = l.stateNode;
          try {
            Cr(P, "");
          } catch (wt) {
            Vr(l, l.return, wt);
          }
        }
        if (w & 4 && (P = l.stateNode, P != null)) {
          var M = l.memoizedProps, H = m !== null ? m.memoizedProps : M, Q = l.type, ee = l.updateQueue;
          if (l.updateQueue = null, ee !== null)
            try {
              Q === "input" && M.type === "radio" && M.name != null && Xt(P, M), ur(Q, H);
              var Te = ur(Q, M);
              for (H = 0; H < ee.length; H += 2) {
                var Ve = ee[H], Ye = ee[H + 1];
                Ve === "style" ? kn(P, Ye) : Ve === "dangerouslySetInnerHTML" ? Ko(P, Ye) : Ve === "children" ? Cr(P, Ye) : j(P, Ve, Ye, Te);
              }
              switch (Q) {
                case "input":
                  kt(P, M);
                  break;
                case "textarea":
                  xt(P, M);
                  break;
                case "select":
                  var He = P._wrapperState.wasMultiple;
                  P._wrapperState.wasMultiple = !!M.multiple;
                  var lt = M.value;
                  lt != null ? Mr(P, !!M.multiple, lt, !1) : He !== !!M.multiple && (M.defaultValue != null ? Mr(
                    P,
                    !!M.multiple,
                    M.defaultValue,
                    !0
                  ) : Mr(P, !!M.multiple, M.multiple ? [] : "", !1));
              }
              P[Kc] = M;
            } catch (wt) {
              Vr(l, l.return, wt);
            }
        }
        break;
      case 6:
        if (rs(u, l), Is(l), w & 4) {
          if (l.stateNode === null)
            throw Error(n(162));
          P = l.stateNode, M = l.memoizedProps;
          try {
            P.nodeValue = M;
          } catch (wt) {
            Vr(l, l.return, wt);
          }
        }
        break;
      case 3:
        if (rs(u, l), Is(l), w & 4 && m !== null && m.memoizedState.isDehydrated)
          try {
            Es(u.containerInfo);
          } catch (wt) {
            Vr(l, l.return, wt);
          }
        break;
      case 4:
        rs(u, l), Is(l);
        break;
      case 13:
        rs(u, l), Is(l), P = l.child, P.flags & 8192 && (M = P.memoizedState !== null, P.stateNode.isHidden = M, !M || P.alternate !== null && P.alternate.memoizedState !== null || (hv = bn())), w & 4 && dl(l);
        break;
      case 22:
        if (Ve = m !== null && m.memoizedState !== null, l.mode & 1 ? (ci = (Te = ci) || Ve, rs(u, l), ci = Te) : rs(u, l), Is(l), w & 8192) {
          if (Te = l.memoizedState !== null, (l.stateNode.isHidden = Te) && !Ve && l.mode & 1)
            for (ft = l, Ve = l.child; Ve !== null; ) {
              for (Ye = ft = Ve; ft !== null; ) {
                switch (He = ft, lt = He.child, He.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                    Bf(4, He, He.return);
                    break;
                  case 1:
                    sd(He, He.return);
                    var gt = He.stateNode;
                    if (typeof gt.componentWillUnmount == "function") {
                      w = He, m = He.return;
                      try {
                        u = w, gt.props = u.memoizedProps, gt.state = u.memoizedState, gt.componentWillUnmount();
                      } catch (wt) {
                        Vr(w, m, wt);
                      }
                    }
                    break;
                  case 5:
                    sd(He, He.return);
                    break;
                  case 22:
                    if (He.memoizedState !== null) {
                      fv(Ye);
                      continue;
                    }
                }
                lt !== null ? (lt.return = He, ft = lt) : fv(Ye);
              }
              Ve = Ve.sibling;
            }
          e:
            for (Ve = null, Ye = l; ; ) {
              if (Ye.tag === 5) {
                if (Ve === null) {
                  Ve = Ye;
                  try {
                    P = Ye.stateNode, Te ? (M = P.style, typeof M.setProperty == "function" ? M.setProperty("display", "none", "important") : M.display = "none") : (Q = Ye.stateNode, ee = Ye.memoizedProps.style, H = ee != null && ee.hasOwnProperty("display") ? ee.display : null, Q.style.display = nn("display", H));
                  } catch (wt) {
                    Vr(l, l.return, wt);
                  }
                }
              } else if (Ye.tag === 6) {
                if (Ve === null)
                  try {
                    Ye.stateNode.nodeValue = Te ? "" : Ye.memoizedProps;
                  } catch (wt) {
                    Vr(l, l.return, wt);
                  }
              } else if ((Ye.tag !== 22 && Ye.tag !== 23 || Ye.memoizedState === null || Ye === l) && Ye.child !== null) {
                Ye.child.return = Ye, Ye = Ye.child;
                continue;
              }
              if (Ye === l)
                break e;
              for (; Ye.sibling === null; ) {
                if (Ye.return === null || Ye.return === l)
                  break e;
                Ve === Ye && (Ve = null), Ye = Ye.return;
              }
              Ve === Ye && (Ve = null), Ye.sibling.return = Ye.return, Ye = Ye.sibling;
            }
        }
        break;
      case 19:
        rs(u, l), Is(l), w & 4 && dl(l);
        break;
      case 21:
        break;
      default:
        rs(
          u,
          l
        ), Is(l);
    }
  }
  function Is(l) {
    var u = l.flags;
    if (u & 2) {
      try {
        e: {
          for (var m = l.return; m !== null; ) {
            if (R0(m)) {
              var w = m;
              break e;
            }
            m = m.return;
          }
          throw Error(n(160));
        }
        switch (w.tag) {
          case 5:
            var P = w.stateNode;
            w.flags & 32 && (Cr(P, ""), w.flags &= -33);
            var M = Ah(l);
            Ps(l, M, P);
            break;
          case 3:
          case 4:
            var H = w.stateNode.containerInfo, Q = Ah(l);
            ld(l, Q, H);
            break;
          default:
            throw Error(n(161));
        }
      } catch (ee) {
        Vr(l, l.return, ee);
      }
      l.flags &= -3;
    }
    u & 4096 && (l.flags &= -4097);
  }
  function M0(l, u, m) {
    ft = l, ud(l);
  }
  function ud(l, u, m) {
    for (var w = (l.mode & 1) !== 0; ft !== null; ) {
      var P = ft, M = P.child;
      if (P.tag === 22 && w) {
        var H = P.memoizedState !== null || zf;
        if (!H) {
          var Q = P.alternate, ee = Q !== null && Q.memoizedState !== null || ci;
          Q = zf;
          var Te = ci;
          if (zf = H, (ci = ee) && !Te)
            for (ft = P; ft !== null; )
              H = ft, ee = H.child, H.tag === 22 && H.memoizedState !== null ? O0(P) : ee !== null ? (ee.return = H, ft = ee) : O0(P);
          for (; M !== null; )
            ft = M, ud(M), M = M.sibling;
          ft = P, zf = Q, ci = Te;
        }
        A0(l);
      } else
        P.subtreeFlags & 8772 && M !== null ? (M.return = P, ft = M) : A0(l);
    }
  }
  function A0(l) {
    for (; ft !== null; ) {
      var u = ft;
      if (u.flags & 8772) {
        var m = u.alternate;
        try {
          if (u.flags & 8772)
            switch (u.tag) {
              case 0:
              case 11:
              case 15:
                ci || Ff(5, u);
                break;
              case 1:
                var w = u.stateNode;
                if (u.flags & 4 && !ci)
                  if (m === null)
                    w.componentDidMount();
                  else {
                    var P = u.elementType === u.type ? m.memoizedProps : ea(u.type, m.memoizedProps);
                    w.componentDidUpdate(P, m.memoizedState, w.__reactInternalSnapshotBeforeUpdate);
                  }
                var M = u.updateQueue;
                M !== null && Gc(u, M, w);
                break;
              case 3:
                var H = u.updateQueue;
                if (H !== null) {
                  if (m = null, u.child !== null)
                    switch (u.child.tag) {
                      case 5:
                        m = u.child.stateNode;
                        break;
                      case 1:
                        m = u.child.stateNode;
                    }
                  Gc(u, H, m);
                }
                break;
              case 5:
                var Q = u.stateNode;
                if (m === null && u.flags & 4) {
                  m = Q;
                  var ee = u.memoizedProps;
                  switch (u.type) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      ee.autoFocus && m.focus();
                      break;
                    case "img":
                      ee.src && (m.src = ee.src);
                  }
                }
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (u.memoizedState === null) {
                  var Te = u.alternate;
                  if (Te !== null) {
                    var Ve = Te.memoizedState;
                    if (Ve !== null) {
                      var Ye = Ve.dehydrated;
                      Ye !== null && Es(Ye);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
              case 25:
                break;
              default:
                throw Error(n(163));
            }
          ci || u.flags & 512 && uv(u);
        } catch (He) {
          Vr(u, u.return, He);
        }
      }
      if (u === l) {
        ft = null;
        break;
      }
      if (m = u.sibling, m !== null) {
        m.return = u.return, ft = m;
        break;
      }
      ft = u.return;
    }
  }
  function fv(l) {
    for (; ft !== null; ) {
      var u = ft;
      if (u === l) {
        ft = null;
        break;
      }
      var m = u.sibling;
      if (m !== null) {
        m.return = u.return, ft = m;
        break;
      }
      ft = u.return;
    }
  }
  function O0(l) {
    for (; ft !== null; ) {
      var u = ft;
      try {
        switch (u.tag) {
          case 0:
          case 11:
          case 15:
            var m = u.return;
            try {
              Ff(4, u);
            } catch (ee) {
              Vr(u, m, ee);
            }
            break;
          case 1:
            var w = u.stateNode;
            if (typeof w.componentDidMount == "function") {
              var P = u.return;
              try {
                w.componentDidMount();
              } catch (ee) {
                Vr(u, P, ee);
              }
            }
            var M = u.return;
            try {
              uv(u);
            } catch (ee) {
              Vr(u, M, ee);
            }
            break;
          case 5:
            var H = u.return;
            try {
              uv(u);
            } catch (ee) {
              Vr(u, H, ee);
            }
        }
      } catch (ee) {
        Vr(u, u.return, ee);
      }
      if (u === l) {
        ft = null;
        break;
      }
      var Q = u.sibling;
      if (Q !== null) {
        Q.return = u.return, ft = Q;
        break;
      }
      ft = u.return;
    }
  }
  var Oh = Math.ceil, Hf = L.ReactCurrentDispatcher, pv = L.ReactCurrentOwner, Qi = L.ReactCurrentBatchConfig, mn = 0, Dr = null, Hr = null, _i = 0, na = 0, dd = on(0), ui = 0, Vf = null, fl = 0, Dh = 0, fd = 0, au = null, uo = null, hv = 0, pd = 1 / 0, pl = null, Nh = !1, su = null, Rs = null, ic = !1, oc = null, Lh = 0, hd = 0, jh = null, lu = -1, cu = 0;
  function Zi() {
    return mn & 6 ? bn() : lu !== -1 ? lu : lu = bn();
  }
  function ii(l) {
    return l.mode & 1 ? mn & 2 && _i !== 0 ? _i & -_i : oh.transition !== null ? (cu === 0 && (cu = jl()), cu) : (l = hn, l !== 0 || (l = window.event, l = l === void 0 ? 16 : Tr(l.type)), l) : 1;
  }
  function Ji(l, u, m, w) {
    if (50 < hd)
      throw hd = 0, jh = null, Error(n(185));
    qa(l, m, w), (!(mn & 2) || l !== Dr) && (l === Dr && (!(mn & 2) && (Dh |= m), ui === 4 && Aa(l, _i)), eo(l, w), m === 1 && mn === 0 && !(u.mode & 1) && (pd = bn() + 500, xi && $o()));
  }
  function eo(l, u) {
    var m = l.callbackNode;
    Ss(l, u);
    var w = bi(l, l === Dr ? _i : 0);
    if (w === 0)
      m !== null && hr(m), l.callbackNode = null, l.callbackPriority = 0;
    else if (u = w & -w, l.callbackPriority !== u) {
      if (m != null && hr(m), u === 1)
        l.tag === 0 ? Um(D0.bind(null, l)) : zm(D0.bind(null, l)), Nm(function() {
          !(mn & 6) && $o();
        }), m = null;
      else {
        switch (Xo(w)) {
          case 1:
            m = Wo;
            break;
          case 4:
            m = Jt;
            break;
          case 16:
            m = xa;
            break;
          case 536870912:
            m = lo;
            break;
          default:
            m = xa;
        }
        m = Sv(m, gd.bind(null, l));
      }
      l.callbackPriority = u, l.callbackNode = m;
    }
  }
  function gd(l, u) {
    if (lu = -1, cu = 0, mn & 6)
      throw Error(n(327));
    var m = l.callbackNode;
    if (vd() && l.callbackNode !== m)
      return null;
    var w = bi(l, l === Dr ? _i : 0);
    if (w === 0)
      return null;
    if (w & 30 || w & l.expiredLanes || u)
      u = Uh(l, w);
    else {
      u = w;
      var P = mn;
      mn |= 2;
      var M = zh();
      (Dr !== l || _i !== u) && (pl = null, pd = bn() + 500, uu(l, u));
      do
        try {
          pE();
          break;
        } catch (Q) {
          N0(l, Q);
        }
      while (1);
      Km(), Hf.current = M, mn = P, Hr !== null ? u = 0 : (Dr = null, _i = 0, u = ui);
    }
    if (u !== 0) {
      if (u === 2 && (P = ws(l), P !== 0 && (w = P, u = gv(l, P))), u === 1)
        throw m = Vf, uu(l, 0), Aa(l, w), eo(l, bn()), m;
      if (u === 6)
        Aa(l, w);
      else {
        if (P = l.current.alternate, !(w & 30) && !mv(P) && (u = Uh(l, w), u === 2 && (M = ws(l), M !== 0 && (w = M, u = gv(l, M))), u === 1))
          throw m = Vf, uu(l, 0), Aa(l, w), eo(l, bn()), m;
        switch (l.finishedWork = P, l.finishedLanes = w, u) {
          case 0:
          case 1:
            throw Error(n(345));
          case 2:
            du(l, uo, pl);
            break;
          case 3:
            if (Aa(l, w), (w & 130023424) === w && (u = hv + 500 - bn(), 10 < u)) {
              if (bi(l, 0) !== 0)
                break;
              if (P = l.suspendedLanes, (P & w) !== w) {
                Zi(), l.pingedLanes |= l.suspendedLanes & P;
                break;
              }
              l.timeoutHandle = Yc(du.bind(null, l, uo, pl), u);
              break;
            }
            du(l, uo, pl);
            break;
          case 4:
            if (Aa(l, w), (w & 4194240) === w)
              break;
            for (u = l.eventTimes, P = -1; 0 < w; ) {
              var H = 31 - $i(w);
              M = 1 << H, H = u[H], H > P && (P = H), w &= ~M;
            }
            if (w = P, w = bn() - w, w = (120 > w ? 120 : 480 > w ? 480 : 1080 > w ? 1080 : 1920 > w ? 1920 : 3e3 > w ? 3e3 : 4320 > w ? 4320 : 1960 * Oh(w / 1960)) - w, 10 < w) {
              l.timeoutHandle = Yc(du.bind(null, l, uo, pl), w);
              break;
            }
            du(l, uo, pl);
            break;
          case 5:
            du(l, uo, pl);
            break;
          default:
            throw Error(n(329));
        }
      }
    }
    return eo(l, bn()), l.callbackNode === m ? gd.bind(null, l) : null;
  }
  function gv(l, u) {
    var m = au;
    return l.current.memoizedState.isDehydrated && (uu(l, u).flags |= 256), l = Uh(l, u), l !== 2 && (u = uo, uo = m, u !== null && Yf(u)), l;
  }
  function Yf(l) {
    uo === null ? uo = l : uo.push.apply(uo, l);
  }
  function mv(l) {
    for (var u = l; ; ) {
      if (u.flags & 16384) {
        var m = u.updateQueue;
        if (m !== null && (m = m.stores, m !== null))
          for (var w = 0; w < m.length; w++) {
            var P = m[w], M = P.getSnapshot;
            P = P.value;
            try {
              if (!Ea(M(), P))
                return !1;
            } catch {
              return !1;
            }
          }
      }
      if (m = u.child, u.subtreeFlags & 16384 && m !== null)
        m.return = u, u = m;
      else {
        if (u === l)
          break;
        for (; u.sibling === null; ) {
          if (u.return === null || u.return === l)
            return !0;
          u = u.return;
        }
        u.sibling.return = u.return, u = u.sibling;
      }
    }
    return !0;
  }
  function Aa(l, u) {
    for (u &= ~fd, u &= ~Dh, l.suspendedLanes |= u, l.pingedLanes &= ~u, l = l.expirationTimes; 0 < u; ) {
      var m = 31 - $i(u), w = 1 << m;
      l[m] = -1, u &= ~w;
    }
  }
  function D0(l) {
    if (mn & 6)
      throw Error(n(327));
    vd();
    var u = bi(l, 0);
    if (!(u & 1))
      return eo(l, bn()), null;
    var m = Uh(l, u);
    if (l.tag !== 0 && m === 2) {
      var w = ws(l);
      w !== 0 && (u = w, m = gv(l, w));
    }
    if (m === 1)
      throw m = Vf, uu(l, 0), Aa(l, u), eo(l, bn()), m;
    if (m === 6)
      throw Error(n(345));
    return l.finishedWork = l.current.alternate, l.finishedLanes = u, du(l, uo, pl), eo(l, bn()), null;
  }
  function md(l, u) {
    var m = mn;
    mn |= 1;
    try {
      return l(u);
    } finally {
      mn = m, mn === 0 && (pd = bn() + 500, xi && $o());
    }
  }
  function ac(l) {
    oc !== null && oc.tag === 0 && !(mn & 6) && vd();
    var u = mn;
    mn |= 1;
    var m = Qi.transition, w = hn;
    try {
      if (Qi.transition = null, hn = 1, l)
        return l();
    } finally {
      hn = w, Qi.transition = m, mn = u, !(mn & 6) && $o();
    }
  }
  function vv() {
    na = dd.current, Un(dd);
  }
  function uu(l, u) {
    l.finishedWork = null, l.finishedLanes = 0;
    var m = l.timeoutHandle;
    if (m !== -1 && (l.timeoutHandle = -1, c0(m)), Hr !== null)
      for (m = Hr.return; m !== null; ) {
        var w = m;
        switch (Fm(w), w.tag) {
          case 1:
            w = w.type.childContextTypes, w != null && Ta();
            break;
          case 3:
            ec(), Un(Fr), Un(Ht), dh();
            break;
          case 5:
            fn(w);
            break;
          case 4:
            ec();
            break;
          case 13:
            Un(Lt);
            break;
          case 19:
            Un(Lt);
            break;
          case 10:
            ql(w.type._context);
            break;
          case 22:
          case 23:
            vv();
        }
        m = m.return;
      }
    if (Dr = l, Hr = l = sc(l.current, null), _i = na = u, ui = 0, Vf = null, fd = Dh = fl = 0, uo = au = null, Ai !== null) {
      for (u = 0; u < Ai.length; u++)
        if (m = Ai[u], w = m.interleaved, w !== null) {
          m.interleaved = null;
          var P = w.next, M = m.pending;
          if (M !== null) {
            var H = M.next;
            M.next = P, w.next = H;
          }
          m.pending = w;
        }
      Ai = null;
    }
    return l;
  }
  function N0(l, u) {
    do {
      var m = Hr;
      try {
        if (Km(), fh.current = Ph, jt) {
          for (var w = yr.memoizedState; w !== null; ) {
            var P = w.queue;
            P !== null && (P.pending = null), w = w.next;
          }
          jt = !1;
        }
        if (qc = 0, En = Ne = yr = null, ks = !1, ta = 0, pv.current = null, m === null || m.return === null) {
          ui = 1, Vf = u, Hr = null;
          break;
        }
        e: {
          var M = l, H = m.return, Q = m, ee = u;
          if (u = _i, Q.flags |= 32768, ee !== null && typeof ee == "object" && typeof ee.then == "function") {
            var Te = ee, Ve = Q, Ye = Ve.tag;
            if (!(Ve.mode & 1) && (Ye === 0 || Ye === 11 || Ye === 15)) {
              var He = Ve.alternate;
              He ? (Ve.updateQueue = He.updateQueue, Ve.memoizedState = He.memoizedState, Ve.lanes = He.lanes) : (Ve.updateQueue = null, Ve.memoizedState = null);
            }
            var lt = tv(H);
            if (lt !== null) {
              lt.flags &= -257, nv(lt, H, Q, M, u), lt.mode & 1 && C0(M, Te, u), u = lt, ee = Te;
              var gt = u.updateQueue;
              if (gt === null) {
                var wt = /* @__PURE__ */ new Set();
                wt.add(ee), u.updateQueue = wt;
              } else
                gt.add(ee);
              break e;
            } else {
              if (!(u & 1)) {
                C0(M, Te, u), yv();
                break e;
              }
              ee = Error(n(426));
            }
          } else if (vr && Q.mode & 1) {
            var Xr = tv(H);
            if (Xr !== null) {
              !(Xr.flags & 65536) && (Xr.flags |= 256), nv(Xr, H, Q, M, u), Vm(id(ee, Q));
              break e;
            }
          }
          M = ee = id(ee, Q), ui !== 4 && (ui = 2), au === null ? au = [M] : au.push(M), M = H;
          do {
            switch (M.tag) {
              case 3:
                M.flags |= 65536, u &= -u, M.lanes |= u;
                var ge = E0(M, ee, u);
                Xm(M, ge);
                break e;
              case 1:
                Q = ee;
                var oe = M.type, we = M.stateNode;
                if (!(M.flags & 128) && (typeof oe.getDerivedStateFromError == "function" || we !== null && typeof we.componentDidCatch == "function" && (Rs === null || !Rs.has(we)))) {
                  M.flags |= 65536, u &= -u, M.lanes |= u;
                  var Xe = Nf(M, Q, u);
                  Xm(M, Xe);
                  break e;
                }
            }
            M = M.return;
          } while (M !== null);
        }
        bv(m);
      } catch (Ct) {
        u = Ct, Hr === m && m !== null && (Hr = m = m.return);
        continue;
      }
      break;
    } while (1);
  }
  function zh() {
    var l = Hf.current;
    return Hf.current = Ph, l === null ? Ph : l;
  }
  function yv() {
    (ui === 0 || ui === 3 || ui === 2) && (ui = 4), Dr === null || !(fl & 268435455) && !(Dh & 268435455) || Aa(Dr, _i);
  }
  function Uh(l, u) {
    var m = mn;
    mn |= 2;
    var w = zh();
    (Dr !== l || _i !== u) && (pl = null, uu(l, u));
    do
      try {
        fE();
        break;
      } catch (P) {
        N0(l, P);
      }
    while (1);
    if (Km(), mn = m, Hf.current = w, Hr !== null)
      throw Error(n(261));
    return Dr = null, _i = 0, ui;
  }
  function fE() {
    for (; Hr !== null; )
      L0(Hr);
  }
  function pE() {
    for (; Hr !== null && !wa(); )
      L0(Hr);
  }
  function L0(l) {
    var u = z0(l.alternate, l, na);
    l.memoizedProps = l.pendingProps, u === null ? bv(l) : Hr = u, pv.current = null;
  }
  function bv(l) {
    var u = l;
    do {
      var m = u.alternate;
      if (l = u.return, u.flags & 32768) {
        if (m = cv(m, u), m !== null) {
          m.flags &= 32767, Hr = m;
          return;
        }
        if (l !== null)
          l.flags |= 32768, l.subtreeFlags = 0, l.deletions = null;
        else {
          ui = 6, Hr = null;
          return;
        }
      } else if (m = dE(m, u, na), m !== null) {
        Hr = m;
        return;
      }
      if (u = u.sibling, u !== null) {
        Hr = u;
        return;
      }
      Hr = u = l;
    } while (u !== null);
    ui === 0 && (ui = 5);
  }
  function du(l, u, m) {
    var w = hn, P = Qi.transition;
    try {
      Qi.transition = null, hn = 1, hE(l, u, m, w);
    } finally {
      Qi.transition = P, hn = w;
    }
    return null;
  }
  function hE(l, u, m, w) {
    do
      vd();
    while (oc !== null);
    if (mn & 6)
      throw Error(n(327));
    m = l.finishedWork;
    var P = l.finishedLanes;
    if (m === null)
      return null;
    if (l.finishedWork = null, l.finishedLanes = 0, m === l.current)
      throw Error(n(177));
    l.callbackNode = null, l.callbackPriority = 0;
    var M = m.lanes | m.childLanes;
    if (ff(l, M), l === Dr && (Hr = Dr = null, _i = 0), !(m.subtreeFlags & 2064) && !(m.flags & 2064) || ic || (ic = !0, Sv(xa, function() {
      return vd(), null;
    })), M = (m.flags & 15990) !== 0, m.subtreeFlags & 15990 || M) {
      M = Qi.transition, Qi.transition = null;
      var H = hn;
      hn = 1;
      var Q = mn;
      mn |= 4, pv.current = null, I0(l, m), $0(m, l), Gp(Vc), ie = !!Om, Vc = Om = null, l.current = m, M0(m), Nl(), mn = Q, hn = H, Qi.transition = M;
    } else
      l.current = m;
    if (ic && (ic = !1, oc = l, Lh = P), M = l.pendingLanes, M === 0 && (Rs = null), Nc(m.stateNode), eo(l, bn()), u !== null)
      for (w = l.onRecoverableError, m = 0; m < u.length; m++)
        P = u[m], w(P.value, { componentStack: P.stack, digest: P.digest });
    if (Nh)
      throw Nh = !1, l = su, su = null, l;
    return Lh & 1 && l.tag !== 0 && vd(), M = l.pendingLanes, M & 1 ? l === jh ? hd++ : (hd = 0, jh = l) : hd = 0, $o(), null;
  }
  function vd() {
    if (oc !== null) {
      var l = Xo(Lh), u = Qi.transition, m = hn;
      try {
        if (Qi.transition = null, hn = 16 > l ? 16 : l, oc === null)
          var w = !1;
        else {
          if (l = oc, oc = null, Lh = 0, mn & 6)
            throw Error(n(331));
          var P = mn;
          for (mn |= 4, ft = l.current; ft !== null; ) {
            var M = ft, H = M.child;
            if (ft.flags & 16) {
              var Q = M.deletions;
              if (Q !== null) {
                for (var ee = 0; ee < Q.length; ee++) {
                  var Te = Q[ee];
                  for (ft = Te; ft !== null; ) {
                    var Ve = ft;
                    switch (Ve.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Bf(8, Ve, M);
                    }
                    var Ye = Ve.child;
                    if (Ye !== null)
                      Ye.return = Ve, ft = Ye;
                    else
                      for (; ft !== null; ) {
                        Ve = ft;
                        var He = Ve.sibling, lt = Ve.return;
                        if (dv(Ve), Ve === Te) {
                          ft = null;
                          break;
                        }
                        if (He !== null) {
                          He.return = lt, ft = He;
                          break;
                        }
                        ft = lt;
                      }
                  }
                }
                var gt = M.alternate;
                if (gt !== null) {
                  var wt = gt.child;
                  if (wt !== null) {
                    gt.child = null;
                    do {
                      var Xr = wt.sibling;
                      wt.sibling = null, wt = Xr;
                    } while (wt !== null);
                  }
                }
                ft = M;
              }
            }
            if (M.subtreeFlags & 2064 && H !== null)
              H.return = M, ft = H;
            else
              e:
                for (; ft !== null; ) {
                  if (M = ft, M.flags & 2048)
                    switch (M.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Bf(9, M, M.return);
                    }
                  var ge = M.sibling;
                  if (ge !== null) {
                    ge.return = M.return, ft = ge;
                    break e;
                  }
                  ft = M.return;
                }
          }
          var oe = l.current;
          for (ft = oe; ft !== null; ) {
            H = ft;
            var we = H.child;
            if (H.subtreeFlags & 2064 && we !== null)
              we.return = H, ft = we;
            else
              e:
                for (H = oe; ft !== null; ) {
                  if (Q = ft, Q.flags & 2048)
                    try {
                      switch (Q.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Ff(9, Q);
                      }
                    } catch (Ct) {
                      Vr(Q, Q.return, Ct);
                    }
                  if (Q === H) {
                    ft = null;
                    break e;
                  }
                  var Xe = Q.sibling;
                  if (Xe !== null) {
                    Xe.return = Q.return, ft = Xe;
                    break e;
                  }
                  ft = Q.return;
                }
          }
          if (mn = P, $o(), Ki && typeof Ki.onPostCommitFiberRoot == "function")
            try {
              Ki.onPostCommitFiberRoot(ys, l);
            } catch {
            }
          w = !0;
        }
        return w;
      } finally {
        hn = m, Qi.transition = u;
      }
    }
    return !1;
  }
  function j0(l, u, m) {
    u = id(m, u), u = E0(l, u, 1), l = Zl(l, u, 1), u = Zi(), l !== null && (qa(l, 1, u), eo(l, u));
  }
  function Vr(l, u, m) {
    if (l.tag === 3)
      j0(l, l, m);
    else
      for (; u !== null; ) {
        if (u.tag === 3) {
          j0(u, l, m);
          break;
        } else if (u.tag === 1) {
          var w = u.stateNode;
          if (typeof u.type.getDerivedStateFromError == "function" || typeof w.componentDidCatch == "function" && (Rs === null || !Rs.has(w))) {
            l = id(m, l), l = Nf(u, l, 1), u = Zl(u, l, 1), l = Zi(), u !== null && (qa(u, 1, l), eo(u, l));
            break;
          }
        }
        u = u.return;
      }
  }
  function gE(l, u, m) {
    var w = l.pingCache;
    w !== null && w.delete(u), u = Zi(), l.pingedLanes |= l.suspendedLanes & m, Dr === l && (_i & m) === m && (ui === 4 || ui === 3 && (_i & 130023424) === _i && 500 > bn() - hv ? uu(l, 0) : fd |= m), eo(l, u);
  }
  function Bh(l, u) {
    u === 0 && (l.mode & 1 ? (u = To, To <<= 1, !(To & 130023424) && (To = 4194304)) : u = 1);
    var m = Zi();
    l = sl(l, u), l !== null && (qa(l, u, m), eo(l, m));
  }
  function mE(l) {
    var u = l.memoizedState, m = 0;
    u !== null && (m = u.retryLane), Bh(l, m);
  }
  function vE(l, u) {
    var m = 0;
    switch (l.tag) {
      case 13:
        var w = l.stateNode, P = l.memoizedState;
        P !== null && (m = P.retryLane);
        break;
      case 19:
        w = l.stateNode;
        break;
      default:
        throw Error(n(314));
    }
    w !== null && w.delete(u), Bh(l, m);
  }
  var z0;
  z0 = function(l, u, m) {
    if (l !== null)
      if (l.memoizedProps !== u.pendingProps || Fr.current)
        ri = !0;
      else {
        if (!(l.lanes & m) && !(u.flags & 128))
          return ri = !1, ul(l, u, m);
        ri = !!(l.flags & 131072);
      }
    else
      ri = !1, vr && u.flags & 1048576 && Bm(u, Qu, u.index);
    switch (u.lanes = 0, u.tag) {
      case 2:
        var w = u.type;
        Xi(l, u), l = u.pendingProps;
        var P = _a(u, Ht.current);
        tt(u, m), P = tc(null, u, w, l, P, m);
        var M = Jc();
        return u.flags |= 1, typeof P == "object" && P !== null && typeof P.render == "function" && P.$$typeof === void 0 ? (u.tag = 1, u.memoizedState = null, u.updateQueue = null, kr(w) ? (M = !0, eh(u)) : M = !1, u.memoizedState = P.state !== null && P.state !== void 0 ? P.state : null, Gm(u), P.updater = lh, u.stateNode = P, P._reactInternals = u, ch(u, w, l, m), u = _0(null, u, w, !0, M, m)) : (u.tag = 0, vr && M && th(u), si(null, u, P, m), u = u.child), u;
      case 16:
        w = u.elementType;
        e: {
          switch (Xi(l, u), l = u.pendingProps, P = w._init, w = P(w._payload), u.type = w, P = u.tag = bE(w), l = ea(w, l), P) {
            case 0:
              u = od(null, u, w, l, m);
              break e;
            case 1:
              u = rv(null, u, w, l, m);
              break e;
            case 11:
              u = rc(null, u, w, l, m);
              break e;
            case 14:
              u = Rh(null, u, w, ea(w.type, l), m);
              break e;
          }
          throw Error(n(
            306,
            w,
            ""
          ));
        }
        return u;
      case 0:
        return w = u.type, P = u.pendingProps, P = u.elementType === w ? P : ea(w, P), od(l, u, w, P, m);
      case 1:
        return w = u.type, P = u.pendingProps, P = u.elementType === w ? P : ea(w, P), rv(l, u, w, P, m);
      case 3:
        e: {
          if (T0(u), l === null)
            throw Error(n(387));
          w = u.pendingProps, M = u.memoizedState, P = M.element, ai(l, u), Jl(u, w, null, m);
          var H = u.memoizedState;
          if (w = H.element, M.isDehydrated)
            if (M = { element: w, isDehydrated: !1, cache: H.cache, pendingSuspenseBoundaries: H.pendingSuspenseBoundaries, transitions: H.transitions }, u.updateQueue.baseState = M, u.memoizedState = M, u.flags & 256) {
              P = id(Error(n(423)), u), u = $h(l, u, w, m, P);
              break e;
            } else if (w !== P) {
              P = id(Error(n(424)), u), u = $h(l, u, w, m, P);
              break e;
            } else
              for (Oo = ts(u.stateNode.containerInfo.firstChild), Jo = u, vr = !0, Pa = null, m = w0(u, null, w, m), u.child = m; m; )
                m.flags = m.flags & -3 | 4096, m = m.sibling;
          else {
            if (Ar(), w === P) {
              u = Oi(l, u, m);
              break e;
            }
            si(l, u, w, m);
          }
          u = u.child;
        }
        return u;
      case 5:
        return Dt(u), l === null && rh(u), w = u.type, P = u.pendingProps, M = l !== null ? l.memoizedProps : null, H = P.children, Cf(w, P) ? H = null : M !== null && Cf(w, M) && (u.flags |= 32), an(l, u), si(l, u, H, m), u.child;
      case 6:
        return l === null && rh(u), null;
      case 13:
        return ov(l, u, m);
      case 4:
        return Qm(u, u.stateNode.containerInfo), w = u.pendingProps, l === null ? u.child = Ju(u, null, w, m) : si(l, u, w, m), u.child;
      case 11:
        return w = u.type, P = u.pendingProps, P = u.elementType === w ? P : ea(w, P), rc(l, u, w, P, m);
      case 7:
        return si(l, u, u.pendingProps, m), u.child;
      case 8:
        return si(l, u, u.pendingProps.children, m), u.child;
      case 12:
        return si(l, u, u.pendingProps.children, m), u.child;
      case 10:
        e: {
          if (w = u.type._context, P = u.pendingProps, M = u.memoizedProps, H = P.value, Vn(Ts, w._currentValue), w._currentValue = H, M !== null)
            if (Ea(M.value, H)) {
              if (M.children === P.children && !Fr.current) {
                u = Oi(l, u, m);
                break e;
              }
            } else
              for (M = u.child, M !== null && (M.return = u); M !== null; ) {
                var Q = M.dependencies;
                if (Q !== null) {
                  H = M.child;
                  for (var ee = Q.firstContext; ee !== null; ) {
                    if (ee.context === w) {
                      if (M.tag === 1) {
                        ee = ll(-1, m & -m), ee.tag = 2;
                        var Te = M.updateQueue;
                        if (Te !== null) {
                          Te = Te.shared;
                          var Ve = Te.pending;
                          Ve === null ? ee.next = ee : (ee.next = Ve.next, Ve.next = ee), Te.pending = ee;
                        }
                      }
                      M.lanes |= m, ee = M.alternate, ee !== null && (ee.lanes |= m), Ei(
                        M.return,
                        m,
                        u
                      ), Q.lanes |= m;
                      break;
                    }
                    ee = ee.next;
                  }
                } else if (M.tag === 10)
                  H = M.type === u.type ? null : M.child;
                else if (M.tag === 18) {
                  if (H = M.return, H === null)
                    throw Error(n(341));
                  H.lanes |= m, Q = H.alternate, Q !== null && (Q.lanes |= m), Ei(H, m, u), H = M.sibling;
                } else
                  H = M.child;
                if (H !== null)
                  H.return = M;
                else
                  for (H = M; H !== null; ) {
                    if (H === u) {
                      H = null;
                      break;
                    }
                    if (M = H.sibling, M !== null) {
                      M.return = H.return, H = M;
                      break;
                    }
                    H = H.return;
                  }
                M = H;
              }
          si(l, u, P.children, m), u = u.child;
        }
        return u;
      case 9:
        return P = u.type, w = u.pendingProps.children, tt(u, m), P = Gr(P), w = w(P), u.flags |= 1, si(l, u, w, m), u.child;
      case 14:
        return w = u.type, P = ea(w, u.pendingProps), P = ea(w.type, P), Rh(l, u, w, P, m);
      case 15:
        return Lo(l, u, u.type, u.pendingProps, m);
      case 17:
        return w = u.type, P = u.pendingProps, P = u.elementType === w ? P : ea(w, P), Xi(l, u), u.tag = 1, kr(w) ? (l = !0, eh(u)) : l = !1, tt(u, m), v0(u, w, P), ch(u, w, P, m), _0(null, u, w, !0, l, m);
      case 19:
        return lv(l, u, m);
      case 22:
        return ru(l, u, m);
    }
    throw Error(n(156, u.tag));
  };
  function Sv(l, u) {
    return Zn(l, u);
  }
  function yE(l, u, m, w) {
    this.tag = l, this.key = m, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = u, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = w, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Oa(l, u, m, w) {
    return new yE(l, u, m, w);
  }
  function wv(l) {
    return l = l.prototype, !(!l || !l.isReactComponent);
  }
  function bE(l) {
    if (typeof l == "function")
      return wv(l) ? 1 : 0;
    if (l != null) {
      if (l = l.$$typeof, l === Pe)
        return 11;
      if (l === le)
        return 14;
    }
    return 2;
  }
  function sc(l, u) {
    var m = l.alternate;
    return m === null ? (m = Oa(l.tag, u, l.key, l.mode), m.elementType = l.elementType, m.type = l.type, m.stateNode = l.stateNode, m.alternate = l, l.alternate = m) : (m.pendingProps = u, m.type = l.type, m.flags = 0, m.subtreeFlags = 0, m.deletions = null), m.flags = l.flags & 14680064, m.childLanes = l.childLanes, m.lanes = l.lanes, m.child = l.child, m.memoizedProps = l.memoizedProps, m.memoizedState = l.memoizedState, m.updateQueue = l.updateQueue, u = l.dependencies, m.dependencies = u === null ? null : { lanes: u.lanes, firstContext: u.firstContext }, m.sibling = l.sibling, m.index = l.index, m.ref = l.ref, m;
  }
  function Fh(l, u, m, w, P, M) {
    var H = 2;
    if (w = l, typeof l == "function")
      wv(l) && (H = 1);
    else if (typeof l == "string")
      H = 5;
    else
      e:
        switch (l) {
          case K:
            return fu(m.children, P, M, u);
          case X:
            H = 8, P |= 8;
            break;
          case se:
            return l = Oa(12, m, u, P | 2), l.elementType = se, l.lanes = M, l;
          case ve:
            return l = Oa(13, m, u, P), l.elementType = ve, l.lanes = M, l;
          case Y:
            return l = Oa(19, m, u, P), l.elementType = Y, l.lanes = M, l;
          case he:
            return Kf(m, P, M, u);
          default:
            if (typeof l == "object" && l !== null)
              switch (l.$$typeof) {
                case ue:
                  H = 10;
                  break e;
                case pe:
                  H = 9;
                  break e;
                case Pe:
                  H = 11;
                  break e;
                case le:
                  H = 14;
                  break e;
                case Re:
                  H = 16, w = null;
                  break e;
              }
            throw Error(n(130, l == null ? l : typeof l, ""));
        }
    return u = Oa(H, m, u, P), u.elementType = l, u.type = w, u.lanes = M, u;
  }
  function fu(l, u, m, w) {
    return l = Oa(7, l, w, u), l.lanes = m, l;
  }
  function Kf(l, u, m, w) {
    return l = Oa(22, l, w, u), l.elementType = he, l.lanes = m, l.stateNode = { isHidden: !1 }, l;
  }
  function Wf(l, u, m) {
    return l = Oa(6, l, null, u), l.lanes = m, l;
  }
  function pu(l, u, m) {
    return u = Oa(4, l.children !== null ? l.children : [], l.key, u), u.lanes = m, u.stateNode = { containerInfo: l.containerInfo, pendingChildren: null, implementation: l.implementation }, u;
  }
  function SE(l, u, m, w, P) {
    this.tag = u, this.containerInfo = l, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = qs(0), this.expirationTimes = qs(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = qs(0), this.identifierPrefix = w, this.onRecoverableError = P, this.mutableSourceEagerHydrationData = null;
  }
  function Hh(l, u, m, w, P, M, H, Q, ee) {
    return l = new SE(l, u, m, Q, ee), u === 1 ? (u = 1, M === !0 && (u |= 8)) : u = 0, M = Oa(3, null, null, u), l.current = M, M.stateNode = l, M.memoizedState = { element: w, isDehydrated: m, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Gm(M), l;
  }
  function U0(l, u, m) {
    var w = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: F, key: w == null ? null : "" + w, children: l, containerInfo: u, implementation: m };
  }
  function xv(l) {
    if (!l)
      return _s;
    l = l._reactInternals;
    e: {
      if (Kt(l) !== l || l.tag !== 1)
        throw Error(n(170));
      var u = l;
      do {
        switch (u.tag) {
          case 3:
            u = u.stateNode.context;
            break e;
          case 1:
            if (kr(u.type)) {
              u = u.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        u = u.return;
      } while (u !== null);
      throw Error(n(171));
    }
    if (l.tag === 1) {
      var m = l.type;
      if (kr(m))
        return kf(l, m, u);
    }
    return u;
  }
  function B0(l, u, m, w, P, M, H, Q, ee) {
    return l = Hh(m, w, !0, l, P, M, H, Q, ee), l.context = xv(null), m = l.current, w = Zi(), P = ii(m), M = ll(w, P), M.callback = u ?? null, Zl(m, M, P), l.current.lanes = P, qa(l, P, w), eo(l, w), l;
  }
  function Gf(l, u, m, w) {
    var P = u.current, M = Zi(), H = ii(P);
    return m = xv(m), u.context === null ? u.context = m : u.pendingContext = m, u = ll(M, H), u.payload = { element: l }, w = w === void 0 ? null : w, w !== null && (u.callback = w), l = Zl(P, u, H), l !== null && (Ji(l, P, H, M), sh(l, P, H)), H;
  }
  function Vh(l) {
    if (l = l.current, !l.child)
      return null;
    switch (l.child.tag) {
      case 5:
        return l.child.stateNode;
      default:
        return l.child.stateNode;
    }
  }
  function F0(l, u) {
    if (l = l.memoizedState, l !== null && l.dehydrated !== null) {
      var m = l.retryLane;
      l.retryLane = m !== 0 && m < u ? m : u;
    }
  }
  function Ev(l, u) {
    F0(l, u), (l = l.alternate) && F0(l, u);
  }
  function H0() {
    return null;
  }
  var Cv = typeof reportError == "function" ? reportError : function(l) {
    console.error(l);
  };
  function Yh(l) {
    this._internalRoot = l;
  }
  hl.prototype.render = Yh.prototype.render = function(l) {
    var u = this._internalRoot;
    if (u === null)
      throw Error(n(409));
    Gf(l, u, null, null);
  }, hl.prototype.unmount = Yh.prototype.unmount = function() {
    var l = this._internalRoot;
    if (l !== null) {
      this._internalRoot = null;
      var u = l.containerInfo;
      ac(function() {
        Gf(null, l, null, null);
      }), u[ol] = null;
    }
  };
  function hl(l) {
    this._internalRoot = l;
  }
  hl.prototype.unstable_scheduleHydration = function(l) {
    if (l) {
      var u = Ul();
      l = { blockedOn: null, target: l, priority: u };
      for (var m = 0; m < Nn.length && u !== 0 && u < Nn[m].priority; m++)
        ;
      Nn.splice(m, 0, l), m === 0 && zc(l);
    }
  };
  function _v(l) {
    return !(!l || l.nodeType !== 1 && l.nodeType !== 9 && l.nodeType !== 11);
  }
  function Kh(l) {
    return !(!l || l.nodeType !== 1 && l.nodeType !== 9 && l.nodeType !== 11 && (l.nodeType !== 8 || l.nodeValue !== " react-mount-point-unstable "));
  }
  function V0() {
  }
  function wE(l, u, m, w, P) {
    if (P) {
      if (typeof w == "function") {
        var M = w;
        w = function() {
          var Te = Vh(H);
          M.call(Te);
        };
      }
      var H = B0(u, w, l, 0, null, !1, !1, "", V0);
      return l._reactRootContainer = H, l[ol] = H.current, Xu(l.nodeType === 8 ? l.parentNode : l), ac(), H;
    }
    for (; P = l.lastChild; )
      l.removeChild(P);
    if (typeof w == "function") {
      var Q = w;
      w = function() {
        var Te = Vh(ee);
        Q.call(Te);
      };
    }
    var ee = Hh(l, 0, !1, null, null, !1, !1, "", V0);
    return l._reactRootContainer = ee, l[ol] = ee.current, Xu(l.nodeType === 8 ? l.parentNode : l), ac(function() {
      Gf(u, ee, m, w);
    }), ee;
  }
  function Wh(l, u, m, w, P) {
    var M = m._reactRootContainer;
    if (M) {
      var H = M;
      if (typeof P == "function") {
        var Q = P;
        P = function() {
          var ee = Vh(H);
          Q.call(ee);
        };
      }
      Gf(u, H, l, P);
    } else
      H = wE(m, u, l, P, w);
    return Vh(H);
  }
  Qs = function(l) {
    switch (l.tag) {
      case 3:
        var u = l.stateNode;
        if (u.current.memoizedState.isDehydrated) {
          var m = ko(u.pendingLanes);
          m !== 0 && (Go(u, m | 1), eo(u, bn()), !(mn & 6) && (pd = bn() + 500, $o()));
        }
        break;
      case 13:
        ac(function() {
          var w = sl(l, 1);
          if (w !== null) {
            var P = Zi();
            Ji(w, l, 1, P);
          }
        }), Ev(l, 1);
    }
  }, zl = function(l) {
    if (l.tag === 13) {
      var u = sl(l, 134217728);
      if (u !== null) {
        var m = Zi();
        Ji(u, l, 134217728, m);
      }
      Ev(l, 134217728);
    }
  }, rn = function(l) {
    if (l.tag === 13) {
      var u = ii(l), m = sl(l, u);
      if (m !== null) {
        var w = Zi();
        Ji(m, l, u, w);
      }
      Ev(l, u);
    }
  }, Ul = function() {
    return hn;
  }, Bl = function(l, u) {
    var m = hn;
    try {
      return hn = l, u();
    } finally {
      hn = m;
    }
  }, gi = function(l, u, m) {
    switch (u) {
      case "input":
        if (kt(l, m), u = m.name, m.type === "radio" && u != null) {
          for (m = l; m.parentNode; )
            m = m.parentNode;
          for (m = m.querySelectorAll("input[name=" + JSON.stringify("" + u) + '][type="radio"]'), u = 0; u < m.length; u++) {
            var w = m[u];
            if (w !== l && w.form === l.form) {
              var P = Mt(w);
              if (!P)
                throw Error(n(90));
              Le(w), kt(w, P);
            }
          }
        }
        break;
      case "textarea":
        xt(l, m);
        break;
      case "select":
        u = m.value, u != null && Mr(l, !!m.multiple, u, !1);
    }
  }, Xa = md, gs = ac;
  var xE = { usingClientEntryPoint: !1, Events: [Tf, qu, Mt, mi, ya, md] }, yd = { findFiberByHostInstance: Ca, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, EE = { bundleType: yd.bundleType, version: yd.version, rendererPackageName: yd.rendererPackageName, rendererConfig: yd.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: L.ReactCurrentDispatcher, findHostInstanceByFiber: function(l) {
    return l = Ur(l), l === null ? null : l.stateNode;
  }, findFiberByHostInstance: yd.findFiberByHostInstance || H0, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Gh = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Gh.isDisabled && Gh.supportsFiber)
      try {
        ys = Gh.inject(EE), Ki = Gh;
      } catch {
      }
  }
  return Ba.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = xE, Ba.createPortal = function(l, u) {
    var m = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!_v(u))
      throw Error(n(200));
    return U0(l, u, null, m);
  }, Ba.createRoot = function(l, u) {
    if (!_v(l))
      throw Error(n(299));
    var m = !1, w = "", P = Cv;
    return u != null && (u.unstable_strictMode === !0 && (m = !0), u.identifierPrefix !== void 0 && (w = u.identifierPrefix), u.onRecoverableError !== void 0 && (P = u.onRecoverableError)), u = Hh(l, 1, !1, null, null, m, !1, w, P), l[ol] = u.current, Xu(l.nodeType === 8 ? l.parentNode : l), new Yh(u);
  }, Ba.findDOMNode = function(l) {
    if (l == null)
      return null;
    if (l.nodeType === 1)
      return l;
    var u = l._reactInternals;
    if (u === void 0)
      throw typeof l.render == "function" ? Error(n(188)) : (l = Object.keys(l).join(","), Error(n(268, l)));
    return l = Ur(u), l = l === null ? null : l.stateNode, l;
  }, Ba.flushSync = function(l) {
    return ac(l);
  }, Ba.hydrate = function(l, u, m) {
    if (!Kh(u))
      throw Error(n(200));
    return Wh(null, l, u, !0, m);
  }, Ba.hydrateRoot = function(l, u, m) {
    if (!_v(l))
      throw Error(n(405));
    var w = m != null && m.hydratedSources || null, P = !1, M = "", H = Cv;
    if (m != null && (m.unstable_strictMode === !0 && (P = !0), m.identifierPrefix !== void 0 && (M = m.identifierPrefix), m.onRecoverableError !== void 0 && (H = m.onRecoverableError)), u = B0(u, null, l, 1, m ?? null, P, !1, M, H), l[ol] = u.current, Xu(l), w)
      for (l = 0; l < w.length; l++)
        m = w[l], P = m._getVersion, P = P(m._source), u.mutableSourceEagerHydrationData == null ? u.mutableSourceEagerHydrationData = [m, P] : u.mutableSourceEagerHydrationData.push(
          m,
          P
        );
    return new hl(u);
  }, Ba.render = function(l, u, m) {
    if (!Kh(u))
      throw Error(n(200));
    return Wh(null, l, u, !1, m);
  }, Ba.unmountComponentAtNode = function(l) {
    if (!Kh(l))
      throw Error(n(40));
    return l._reactRootContainer ? (ac(function() {
      Wh(null, null, l, !1, function() {
        l._reactRootContainer = null, l[ol] = null;
      });
    }), !0) : !1;
  }, Ba.unstable_batchedUpdates = md, Ba.unstable_renderSubtreeIntoContainer = function(l, u, m, w) {
    if (!Kh(m))
      throw Error(n(200));
    if (l == null || l._reactInternals === void 0)
      throw Error(n(38));
    return Wh(l, u, m, !1, w);
  }, Ba.version = "18.2.0-next-9e3b772b8-20220608", Ba;
}
var Fa = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qD;
function bie() {
  return qD || (qD = 1, {}.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = k, e = Uj(), n = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, r = !1;
    function a(i) {
      r = i;
    }
    function s(i) {
      if (!r) {
        for (var o = arguments.length, d = new Array(o > 1 ? o - 1 : 0), h = 1; h < o; h++)
          d[h - 1] = arguments[h];
        f("warn", i, d);
      }
    }
    function c(i) {
      if (!r) {
        for (var o = arguments.length, d = new Array(o > 1 ? o - 1 : 0), h = 1; h < o; h++)
          d[h - 1] = arguments[h];
        f("error", i, d);
      }
    }
    function f(i, o, d) {
      {
        var h = n.ReactDebugCurrentFrame, b = h.getStackAddendum();
        b !== "" && (o += "%s", d = d.concat([b]));
        var C = d.map(function(R) {
          return String(R);
        });
        C.unshift("Warning: " + o), Function.prototype.apply.call(console[i], console, C);
      }
    }
    var p = 0, g = 1, y = 2, v = 3, S = 4, x = 5, _ = 6, T = 7, I = 8, D = 9, N = 10, j = 11, L = 12, z = 13, F = 14, K = 15, X = 16, se = 17, ue = 18, pe = 19, Pe = 21, ve = 22, Y = 23, le = 24, Re = 25, he = !0, te = !1, de = !1, W = !1, fe = !1, ce = !0, xe = !1, $e = !1, Me = !0, re = !0, Qe = !0, ke = /* @__PURE__ */ new Set(), rt = {}, St = {};
    function Tt(i, o) {
      Le(i, o), Le(i + "Capture", o);
    }
    function Le(i, o) {
      rt[i] && c("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", i), rt[i] = o;
      {
        var d = i.toLowerCase();
        St[d] = i, i === "onDoubleClick" && (St.ondblclick = i);
      }
      for (var h = 0; h < o.length; h++)
        ke.add(o[h]);
    }
    var Nt = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Ke = Object.prototype.hasOwnProperty;
    function yt(i) {
      {
        var o = typeof Symbol == "function" && Symbol.toStringTag, d = o && i[Symbol.toStringTag] || i.constructor.name || "Object";
        return d;
      }
    }
    function Xt(i) {
      try {
        return kt(i), !1;
      } catch {
        return !0;
      }
    }
    function kt(i) {
      return "" + i;
    }
    function yn(i, o) {
      if (Xt(i))
        return c("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", o, yt(i)), kt(i);
    }
    function Er(i) {
      if (Xt(i))
        return c("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", yt(i)), kt(i);
    }
    function tn(i, o) {
      if (Xt(i))
        return c("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", o, yt(i)), kt(i);
    }
    function Mr(i, o) {
      if (Xt(i))
        return c("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", o, yt(i)), kt(i);
    }
    function zr(i) {
      if (Xt(i))
        return c("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", yt(i)), kt(i);
    }
    function Hn(i) {
      if (Xt(i))
        return c("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", yt(i)), kt(i);
    }
    var xt = 0, cn = 1, ti = 2, An = 3, qn = 4, Ko = 5, Cr = 6, Je = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Et = Je + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", nn = new RegExp("^[" + Je + "][" + Et + "]*$"), kn = {}, xn = {};
    function _r(i) {
      return Ke.call(xn, i) ? !0 : Ke.call(kn, i) ? !1 : nn.test(i) ? (xn[i] = !0, !0) : (kn[i] = !0, c("Invalid attribute name: `%s`", i), !1);
    }
    function ur(i, o, d) {
      return o !== null ? o.type === xt : d ? !1 : i.length > 2 && (i[0] === "o" || i[0] === "O") && (i[1] === "n" || i[1] === "N");
    }
    function hi(i, o, d, h) {
      if (d !== null && d.type === xt)
        return !1;
      switch (typeof o) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (h)
            return !1;
          if (d !== null)
            return !d.acceptsBooleans;
          var b = i.toLowerCase().slice(0, 5);
          return b !== "data-" && b !== "aria-";
        }
        default:
          return !1;
      }
    }
    function pn(i, o, d, h) {
      if (o === null || typeof o > "u" || hi(i, o, d, h))
        return !0;
      if (h)
        return !1;
      if (d !== null)
        switch (d.type) {
          case An:
            return !o;
          case qn:
            return o === !1;
          case Ko:
            return isNaN(o);
          case Cr:
            return isNaN(o) || o < 1;
        }
      return !1;
    }
    function gi(i) {
      return Dn.hasOwnProperty(i) ? Dn[i] : null;
    }
    function On(i, o, d, h, b, C, R) {
      this.acceptsBooleans = o === ti || o === An || o === qn, this.attributeName = h, this.attributeNamespace = b, this.mustUseProperty = d, this.propertyName = i, this.type = o, this.sanitizeURL = C, this.removeEmptyString = R;
    }
    var Dn = {}, io = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    io.forEach(function(i) {
      Dn[i] = new On(
        i,
        xt,
        !1,
        // mustUseProperty
        i,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(i) {
      var o = i[0], d = i[1];
      Dn[o] = new On(
        o,
        cn,
        !1,
        // mustUseProperty
        d,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(i) {
      Dn[i] = new On(
        i,
        ti,
        !1,
        // mustUseProperty
        i.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(i) {
      Dn[i] = new On(
        i,
        ti,
        !1,
        // mustUseProperty
        i,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(i) {
      Dn[i] = new On(
        i,
        An,
        !1,
        // mustUseProperty
        i.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(i) {
      Dn[i] = new On(
        i,
        An,
        !0,
        // mustUseProperty
        i,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(i) {
      Dn[i] = new On(
        i,
        qn,
        !1,
        // mustUseProperty
        i,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(i) {
      Dn[i] = new On(
        i,
        Cr,
        !1,
        // mustUseProperty
        i,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(i) {
      Dn[i] = new On(
        i,
        Ko,
        !1,
        // mustUseProperty
        i.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var mi = /[\-\:]([a-z])/g, ya = function(i) {
      return i[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(i) {
      var o = i.replace(mi, ya);
      Dn[o] = new On(
        o,
        cn,
        !1,
        // mustUseProperty
        i,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(i) {
      var o = i.replace(mi, ya);
      Dn[o] = new On(
        o,
        cn,
        !1,
        // mustUseProperty
        i,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(i) {
      var o = i.replace(mi, ya);
      Dn[o] = new On(
        o,
        cn,
        !1,
        // mustUseProperty
        i,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(i) {
      Dn[i] = new On(
        i,
        cn,
        !1,
        // mustUseProperty
        i.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Xa = "xlinkHref";
    Dn[Xa] = new On(
      "xlinkHref",
      cn,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(i) {
      Dn[i] = new On(
        i,
        cn,
        !1,
        // mustUseProperty
        i.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var gs = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, oo = !1;
    function ms(i) {
      !oo && gs.test(i) && (oo = !0, c("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(i)));
    }
    function ao(i, o, d, h) {
      if (h.mustUseProperty) {
        var b = h.propertyName;
        return i[b];
      } else {
        yn(d, o), h.sanitizeURL && ms("" + d);
        var C = h.attributeName, R = null;
        if (h.type === qn) {
          if (i.hasAttribute(C)) {
            var A = i.getAttribute(C);
            return A === "" ? !0 : pn(o, d, h, !1) ? A : A === "" + d ? d : A;
          }
        } else if (i.hasAttribute(C)) {
          if (pn(o, d, h, !1))
            return i.getAttribute(C);
          if (h.type === An)
            return d;
          R = i.getAttribute(C);
        }
        return pn(o, d, h, !1) ? R === null ? d : R : R === "" + d ? d : R;
      }
    }
    function ba(i, o, d, h) {
      {
        if (!_r(o))
          return;
        if (!i.hasAttribute(o))
          return d === void 0 ? void 0 : null;
        var b = i.getAttribute(o);
        return yn(d, o), b === "" + d ? d : b;
      }
    }
    function so(i, o, d, h) {
      var b = gi(o);
      if (!ur(o, b, h)) {
        if (pn(o, d, b, h) && (d = null), h || b === null) {
          if (_r(o)) {
            var C = o;
            d === null ? i.removeAttribute(C) : (yn(d, o), i.setAttribute(C, "" + d));
          }
          return;
        }
        var R = b.mustUseProperty;
        if (R) {
          var A = b.propertyName;
          if (d === null) {
            var B = b.type;
            i[A] = B === An ? !1 : "";
          } else
            i[A] = d;
          return;
        }
        var V = b.attributeName, G = b.attributeNamespace;
        if (d === null)
          i.removeAttribute(V);
        else {
          var ae = b.type, ne;
          ae === An || ae === qn && d === !0 ? ne = "" : (yn(d, V), ne = "" + d, b.sanitizeURL && ms(ne.toString())), G ? i.setAttributeNS(G, V, ne) : i.setAttribute(V, ne);
        }
      }
    }
    var Sa = Symbol.for("react.element"), vi = Symbol.for("react.portal"), Ri = Symbol.for("react.fragment"), yi = Symbol.for("react.strict_mode"), J = Symbol.for("react.profiler"), Be = Symbol.for("react.provider"), et = Symbol.for("react.context"), st = Symbol.for("react.forward_ref"), Kt = Symbol.for("react.suspense"), qt = Symbol.for("react.suspense_list"), Qt = Symbol.for("react.memo"), Rt = Symbol.for("react.lazy"), Ur = Symbol.for("react.scope"), Qn = Symbol.for("react.debug_trace_mode"), Zn = Symbol.for("react.offscreen"), hr = Symbol.for("react.legacy_hidden"), wa = Symbol.for("react.cache"), Nl = Symbol.for("react.tracing_marker"), bn = Symbol.iterator, df = "@@iterator";
    function Wo(i) {
      if (i === null || typeof i != "object")
        return null;
      var o = bn && i[bn] || i[df];
      return typeof o == "function" ? o : null;
    }
    var Jt = Object.assign, xa = 0, vs, lo, ys, Ki, Nc, $i, Lc;
    function jc() {
    }
    jc.__reactDisabledLog = !0;
    function Xs() {
      {
        if (xa === 0) {
          vs = console.log, lo = console.info, ys = console.warn, Ki = console.error, Nc = console.group, $i = console.groupCollapsed, Lc = console.groupEnd;
          var i = {
            configurable: !0,
            enumerable: !0,
            value: jc,
            writable: !0
          };
          Object.defineProperties(console, {
            info: i,
            log: i,
            warn: i,
            error: i,
            group: i,
            groupCollapsed: i,
            groupEnd: i
          });
        }
        xa++;
      }
    }
    function Ll() {
      {
        if (xa--, xa === 0) {
          var i = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Jt({}, i, {
              value: vs
            }),
            info: Jt({}, i, {
              value: lo
            }),
            warn: Jt({}, i, {
              value: ys
            }),
            error: Jt({}, i, {
              value: Ki
            }),
            group: Jt({}, i, {
              value: Nc
            }),
            groupCollapsed: Jt({}, i, {
              value: $i
            }),
            groupEnd: Jt({}, i, {
              value: Lc
            })
          });
        }
        xa < 0 && c("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var To = n.ReactCurrentDispatcher, ko;
    function bi(i, o, d) {
      {
        if (ko === void 0)
          try {
            throw Error();
          } catch (b) {
            var h = b.stack.trim().match(/\n( *(at )?)/);
            ko = h && h[1] || "";
          }
        return `
` + ko + i;
      }
    }
    var bs = !1, Ss;
    {
      var ws = typeof WeakMap == "function" ? WeakMap : Map;
      Ss = new ws();
    }
    function jl(i, o) {
      if (!i || bs)
        return "";
      {
        var d = Ss.get(i);
        if (d !== void 0)
          return d;
      }
      var h;
      bs = !0;
      var b = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var C;
      C = To.current, To.current = null, Xs();
      try {
        if (o) {
          var R = function() {
            throw Error();
          };
          if (Object.defineProperty(R.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(R, []);
            } catch (_e) {
              h = _e;
            }
            Reflect.construct(i, [], R);
          } else {
            try {
              R.call();
            } catch (_e) {
              h = _e;
            }
            i.call(R.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (_e) {
            h = _e;
          }
          i();
        }
      } catch (_e) {
        if (_e && h && typeof _e.stack == "string") {
          for (var A = _e.stack.split(`
`), B = h.stack.split(`
`), V = A.length - 1, G = B.length - 1; V >= 1 && G >= 0 && A[V] !== B[G]; )
            G--;
          for (; V >= 1 && G >= 0; V--, G--)
            if (A[V] !== B[G]) {
              if (V !== 1 || G !== 1)
                do
                  if (V--, G--, G < 0 || A[V] !== B[G]) {
                    var ae = `
` + A[V].replace(" at new ", " at ");
                    return i.displayName && ae.includes("<anonymous>") && (ae = ae.replace("<anonymous>", i.displayName)), typeof i == "function" && Ss.set(i, ae), ae;
                  }
                while (V >= 1 && G >= 0);
              break;
            }
        }
      } finally {
        bs = !1, To.current = C, Ll(), Error.prepareStackTrace = b;
      }
      var ne = i ? i.displayName || i.name : "", Ce = ne ? bi(ne) : "";
      return typeof i == "function" && Ss.set(i, Ce), Ce;
    }
    function qs(i, o, d) {
      return jl(i, !0);
    }
    function qa(i, o, d) {
      return jl(i, !1);
    }
    function ff(i) {
      var o = i.prototype;
      return !!(o && o.isReactComponent);
    }
    function Go(i, o, d) {
      if (i == null)
        return "";
      if (typeof i == "function")
        return jl(i, ff(i));
      if (typeof i == "string")
        return bi(i);
      switch (i) {
        case Kt:
          return bi("Suspense");
        case qt:
          return bi("SuspenseList");
      }
      if (typeof i == "object")
        switch (i.$$typeof) {
          case st:
            return qa(i.render);
          case Qt:
            return Go(i.type, o, d);
          case Rt: {
            var h = i, b = h._payload, C = h._init;
            try {
              return Go(C(b), o, d);
            } catch {
            }
          }
        }
      return "";
    }
    function hn(i) {
      switch (i._debugOwner && i._debugOwner.type, i._debugSource, i.tag) {
        case x:
          return bi(i.type);
        case X:
          return bi("Lazy");
        case z:
          return bi("Suspense");
        case pe:
          return bi("SuspenseList");
        case p:
        case y:
        case K:
          return qa(i.type);
        case j:
          return qa(i.type.render);
        case g:
          return qs(i.type);
        default:
          return "";
      }
    }
    function Xo(i) {
      try {
        var o = "", d = i;
        do
          o += hn(d), d = d.return;
        while (d);
        return o;
      } catch (h) {
        return `
Error generating stack: ` + h.message + `
` + h.stack;
      }
    }
    function Qs(i, o, d) {
      var h = i.displayName;
      if (h)
        return h;
      var b = o.displayName || o.name || "";
      return b !== "" ? d + "(" + b + ")" : d;
    }
    function zl(i) {
      return i.displayName || "Context";
    }
    function rn(i) {
      if (i == null)
        return null;
      if (typeof i.tag == "number" && c("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof i == "function")
        return i.displayName || i.name || null;
      if (typeof i == "string")
        return i;
      switch (i) {
        case Ri:
          return "Fragment";
        case vi:
          return "Portal";
        case J:
          return "Profiler";
        case yi:
          return "StrictMode";
        case Kt:
          return "Suspense";
        case qt:
          return "SuspenseList";
      }
      if (typeof i == "object")
        switch (i.$$typeof) {
          case et:
            var o = i;
            return zl(o) + ".Consumer";
          case Be:
            var d = i;
            return zl(d._context) + ".Provider";
          case st:
            return Qs(i, i.render, "ForwardRef");
          case Qt:
            var h = i.displayName || null;
            return h !== null ? h : rn(i.type) || "Memo";
          case Rt: {
            var b = i, C = b._payload, R = b._init;
            try {
              return rn(R(C));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Ul(i, o, d) {
      var h = o.displayName || o.name || "";
      return i.displayName || (h !== "" ? d + "(" + h + ")" : d);
    }
    function Bl(i) {
      return i.displayName || "Context";
    }
    function Ft(i) {
      var o = i.tag, d = i.type;
      switch (o) {
        case le:
          return "Cache";
        case D:
          var h = d;
          return Bl(h) + ".Consumer";
        case N:
          var b = d;
          return Bl(b._context) + ".Provider";
        case ue:
          return "DehydratedFragment";
        case j:
          return Ul(d, d.render, "ForwardRef");
        case T:
          return "Fragment";
        case x:
          return d;
        case S:
          return "Portal";
        case v:
          return "Root";
        case _:
          return "Text";
        case X:
          return rn(d);
        case I:
          return d === yi ? "StrictMode" : "Mode";
        case ve:
          return "Offscreen";
        case L:
          return "Profiler";
        case Pe:
          return "Scope";
        case z:
          return "Suspense";
        case pe:
          return "SuspenseList";
        case Re:
          return "TracingMarker";
        case g:
        case p:
        case se:
        case y:
        case F:
        case K:
          if (typeof d == "function")
            return d.displayName || d.name || null;
          if (typeof d == "string")
            return d;
          break;
      }
      return null;
    }
    var Zs = n.ReactDebugCurrentFrame, gr = null, Br = !1;
    function Si() {
      {
        if (gr === null)
          return null;
        var i = gr._debugOwner;
        if (i !== null && typeof i < "u")
          return Ft(i);
      }
      return null;
    }
    function xs() {
      return gr === null ? "" : Xo(gr);
    }
    function or() {
      Zs.getCurrentStack = null, gr = null, Br = !1;
    }
    function Nn(i) {
      Zs.getCurrentStack = i === null ? null : xs, gr = i, Br = !1;
    }
    function Fl() {
      return gr;
    }
    function Wi(i) {
      Br = i;
    }
    function Wr(i) {
      return "" + i;
    }
    function qo(i) {
      switch (typeof i) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return i;
        case "object":
          return Hn(i), i;
        default:
          return "";
      }
    }
    var zc = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function co(i, o) {
      zc[o.type] || o.onChange || o.onInput || o.readOnly || o.disabled || o.value == null || c("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), o.onChange || o.readOnly || o.disabled || o.checked == null || c("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function Qa(i) {
      var o = i.type, d = i.nodeName;
      return d && d.toLowerCase() === "input" && (o === "checkbox" || o === "radio");
    }
    function Fu(i) {
      return i._valueTracker;
    }
    function Po(i) {
      i._valueTracker = null;
    }
    function Es(i) {
      var o = "";
      return i && (Qa(i) ? o = i.checked ? "true" : "false" : o = i.value), o;
    }
    function q(i) {
      var o = Qa(i) ? "checked" : "value", d = Object.getOwnPropertyDescriptor(i.constructor.prototype, o);
      Hn(i[o]);
      var h = "" + i[o];
      if (!(i.hasOwnProperty(o) || typeof d > "u" || typeof d.get != "function" || typeof d.set != "function")) {
        var b = d.get, C = d.set;
        Object.defineProperty(i, o, {
          configurable: !0,
          get: function() {
            return b.call(this);
          },
          set: function(A) {
            Hn(A), h = "" + A, C.call(this, A);
          }
        }), Object.defineProperty(i, o, {
          enumerable: d.enumerable
        });
        var R = {
          getValue: function() {
            return h;
          },
          setValue: function(A) {
            Hn(A), h = "" + A;
          },
          stopTracking: function() {
            Po(i), delete i[o];
          }
        };
        return R;
      }
    }
    function ie(i) {
      Fu(i) || (i._valueTracker = q(i));
    }
    function Ue(i) {
      if (!i)
        return !1;
      var o = Fu(i);
      if (!o)
        return !0;
      var d = o.getValue(), h = Es(i);
      return h !== d ? (o.setValue(h), !0) : !1;
    }
    function it(i) {
      if (i = i || (typeof document < "u" ? document : void 0), typeof i > "u")
        return null;
      try {
        return i.activeElement || i.body;
      } catch {
        return i.body;
      }
    }
    var Pn = !1, Ut = !1, Kn = !1, Tr = !1;
    function Wn(i) {
      var o = i.type === "checkbox" || i.type === "radio";
      return o ? i.checked != null : i.value != null;
    }
    function U(i, o) {
      var d = i, h = o.checked, b = Jt({}, o, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: h ?? d._wrapperState.initialChecked
      });
      return b;
    }
    function Z(i, o) {
      co("input", o), o.checked !== void 0 && o.defaultChecked !== void 0 && !Ut && (c("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Si() || "A component", o.type), Ut = !0), o.value !== void 0 && o.defaultValue !== void 0 && !Pn && (c("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Si() || "A component", o.type), Pn = !0);
      var d = i, h = o.defaultValue == null ? "" : o.defaultValue;
      d._wrapperState = {
        initialChecked: o.checked != null ? o.checked : o.defaultChecked,
        initialValue: qo(o.value != null ? o.value : h),
        controlled: Wn(o)
      };
    }
    function ye(i, o) {
      var d = i, h = o.checked;
      h != null && so(d, "checked", h, !1);
    }
    function Ee(i, o) {
      var d = i;
      {
        var h = Wn(o);
        !d._wrapperState.controlled && h && !Tr && (c("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Tr = !0), d._wrapperState.controlled && !h && !Kn && (c("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Kn = !0);
      }
      ye(i, o);
      var b = qo(o.value), C = o.type;
      if (b != null)
        C === "number" ? (b === 0 && d.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        d.value != b) && (d.value = Wr(b)) : d.value !== Wr(b) && (d.value = Wr(b));
      else if (C === "submit" || C === "reset") {
        d.removeAttribute("value");
        return;
      }
      o.hasOwnProperty("value") ? bt(d, o.type, b) : o.hasOwnProperty("defaultValue") && bt(d, o.type, qo(o.defaultValue)), o.checked == null && o.defaultChecked != null && (d.defaultChecked = !!o.defaultChecked);
    }
    function Fe(i, o, d) {
      var h = i;
      if (o.hasOwnProperty("value") || o.hasOwnProperty("defaultValue")) {
        var b = o.type, C = b === "submit" || b === "reset";
        if (C && (o.value === void 0 || o.value === null))
          return;
        var R = Wr(h._wrapperState.initialValue);
        d || R !== h.value && (h.value = R), h.defaultValue = R;
      }
      var A = h.name;
      A !== "" && (h.name = ""), h.defaultChecked = !h.defaultChecked, h.defaultChecked = !!h._wrapperState.initialChecked, A !== "" && (h.name = A);
    }
    function ht(i, o) {
      var d = i;
      Ee(d, o), Ze(d, o);
    }
    function Ze(i, o) {
      var d = o.name;
      if (o.type === "radio" && d != null) {
        for (var h = i; h.parentNode; )
          h = h.parentNode;
        yn(d, "name");
        for (var b = h.querySelectorAll("input[name=" + JSON.stringify("" + d) + '][type="radio"]'), C = 0; C < b.length; C++) {
          var R = b[C];
          if (!(R === i || R.form !== i.form)) {
            var A = sS(R);
            if (!A)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            Ue(R), Ee(R, A);
          }
        }
      }
    }
    function bt(i, o, d) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (o !== "number" || it(i.ownerDocument) !== i) && (d == null ? i.defaultValue = Wr(i._wrapperState.initialValue) : i.defaultValue !== Wr(d) && (i.defaultValue = Wr(d)));
    }
    var Yt = !1, gn = !1, Ln = !1;
    function In(i, o) {
      o.value == null && (typeof o.children == "object" && o.children !== null ? t.Children.forEach(o.children, function(d) {
        d != null && (typeof d == "string" || typeof d == "number" || gn || (gn = !0, c("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : o.dangerouslySetInnerHTML != null && (Ln || (Ln = !0, c("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), o.selected != null && !Yt && (c("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Yt = !0);
    }
    function ar(i, o) {
      o.value != null && i.setAttribute("value", Wr(qo(o.value)));
    }
    var dr = Array.isArray;
    function Sn(i) {
      return dr(i);
    }
    var Js;
    Js = !1;
    function Hu() {
      var i = Si();
      return i ? `

Check the render method of \`` + i + "`." : "";
    }
    var pf = ["value", "defaultValue"];
    function mm(i) {
      {
        co("select", i);
        for (var o = 0; o < pf.length; o++) {
          var d = pf[o];
          if (i[d] != null) {
            var h = Sn(i[d]);
            i.multiple && !h ? c("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", d, Hu()) : !i.multiple && h && c("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", d, Hu());
          }
        }
      }
    }
    function Za(i, o, d, h) {
      var b = i.options;
      if (o) {
        for (var C = d, R = {}, A = 0; A < C.length; A++)
          R["$" + C[A]] = !0;
        for (var B = 0; B < b.length; B++) {
          var V = R.hasOwnProperty("$" + b[B].value);
          b[B].selected !== V && (b[B].selected = V), V && h && (b[B].defaultSelected = !0);
        }
      } else {
        for (var G = Wr(qo(d)), ae = null, ne = 0; ne < b.length; ne++) {
          if (b[ne].value === G) {
            b[ne].selected = !0, h && (b[ne].defaultSelected = !0);
            return;
          }
          ae === null && !b[ne].disabled && (ae = b[ne]);
        }
        ae !== null && (ae.selected = !0);
      }
    }
    function hf(i, o) {
      return Jt({}, o, {
        value: void 0
      });
    }
    function gf(i, o) {
      var d = i;
      mm(o), d._wrapperState = {
        wasMultiple: !!o.multiple
      }, o.value !== void 0 && o.defaultValue !== void 0 && !Js && (c("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), Js = !0);
    }
    function vm(i, o) {
      var d = i;
      d.multiple = !!o.multiple;
      var h = o.value;
      h != null ? Za(d, !!o.multiple, h, !1) : o.defaultValue != null && Za(d, !!o.multiple, o.defaultValue, !0);
    }
    function V1(i, o) {
      var d = i, h = d._wrapperState.wasMultiple;
      d._wrapperState.wasMultiple = !!o.multiple;
      var b = o.value;
      b != null ? Za(d, !!o.multiple, b, !1) : h !== !!o.multiple && (o.defaultValue != null ? Za(d, !!o.multiple, o.defaultValue, !0) : Za(d, !!o.multiple, o.multiple ? [] : "", !1));
    }
    function Y1(i, o) {
      var d = i, h = o.value;
      h != null && Za(d, !!o.multiple, h, !1);
    }
    var ym = !1;
    function bm(i, o) {
      var d = i;
      if (o.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var h = Jt({}, o, {
        value: void 0,
        defaultValue: void 0,
        children: Wr(d._wrapperState.initialValue)
      });
      return h;
    }
    function Nb(i, o) {
      var d = i;
      co("textarea", o), o.value !== void 0 && o.defaultValue !== void 0 && !ym && (c("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", Si() || "A component"), ym = !0);
      var h = o.value;
      if (h == null) {
        var b = o.children, C = o.defaultValue;
        if (b != null) {
          c("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (C != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (Sn(b)) {
              if (b.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              b = b[0];
            }
            C = b;
          }
        }
        C == null && (C = ""), h = C;
      }
      d._wrapperState = {
        initialValue: qo(h)
      };
    }
    function Lb(i, o) {
      var d = i, h = qo(o.value), b = qo(o.defaultValue);
      if (h != null) {
        var C = Wr(h);
        C !== d.value && (d.value = C), o.defaultValue == null && d.defaultValue !== C && (d.defaultValue = C);
      }
      b != null && (d.defaultValue = Wr(b));
    }
    function jb(i, o) {
      var d = i, h = d.textContent;
      h === d._wrapperState.initialValue && h !== "" && h !== null && (d.value = h);
    }
    function Sm(i, o) {
      Lb(i, o);
    }
    var el = "http://www.w3.org/1999/xhtml", K1 = "http://www.w3.org/1998/Math/MathML", wm = "http://www.w3.org/2000/svg";
    function Hp(i) {
      switch (i) {
        case "svg":
          return wm;
        case "math":
          return K1;
        default:
          return el;
      }
    }
    function xm(i, o) {
      return i == null || i === el ? Hp(o) : i === wm && o === "foreignObject" ? el : i;
    }
    var W1 = function(i) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(o, d, h, b) {
        MSApp.execUnsafeLocalFunction(function() {
          return i(o, d, h, b);
        });
      } : i;
    }, Vp, zb = W1(function(i, o) {
      if (i.namespaceURI === wm && !("innerHTML" in i)) {
        Vp = Vp || document.createElement("div"), Vp.innerHTML = "<svg>" + o.valueOf().toString() + "</svg>";
        for (var d = Vp.firstChild; i.firstChild; )
          i.removeChild(i.firstChild);
        for (; d.firstChild; )
          i.appendChild(d.firstChild);
        return;
      }
      i.innerHTML = o;
    }), Io = 1, tl = 3, ni = 8, Ja = 9, Uc = 11, Yp = function(i, o) {
      if (o) {
        var d = i.firstChild;
        if (d && d === i.lastChild && d.nodeType === tl) {
          d.nodeValue = o;
          return;
        }
      }
      i.textContent = o;
    }, Ub = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, Vu = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Bb(i, o) {
      return i + o.charAt(0).toUpperCase() + o.substring(1);
    }
    var Fb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(Vu).forEach(function(i) {
      Fb.forEach(function(o) {
        Vu[Bb(o, i)] = Vu[i];
      });
    });
    function Kp(i, o, d) {
      var h = o == null || typeof o == "boolean" || o === "";
      return h ? "" : !d && typeof o == "number" && o !== 0 && !(Vu.hasOwnProperty(i) && Vu[i]) ? o + "px" : (Mr(o, i), ("" + o).trim());
    }
    var Yu = /([A-Z])/g, G1 = /^ms-/;
    function X1(i) {
      return i.replace(Yu, "-$1").toLowerCase().replace(G1, "-ms-");
    }
    var Hb = function() {
    };
    {
      var Vb = /^(?:webkit|moz|o)[A-Z]/, Yb = /^-ms-/, mf = /-(.)/g, Ku = /;\s*$/, Wu = {}, Gu = {}, Kb = !1, Em = !1, Cm = function(i) {
        return i.replace(mf, function(o, d) {
          return d.toUpperCase();
        });
      }, _m = function(i) {
        Wu.hasOwnProperty(i) && Wu[i] || (Wu[i] = !0, c(
          "Unsupported style property %s. Did you mean %s?",
          i,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Cm(i.replace(Yb, "ms-"))
        ));
      }, Wb = function(i) {
        Wu.hasOwnProperty(i) && Wu[i] || (Wu[i] = !0, c("Unsupported vendor-prefixed style property %s. Did you mean %s?", i, i.charAt(0).toUpperCase() + i.slice(1)));
      }, Gb = function(i, o) {
        Gu.hasOwnProperty(o) && Gu[o] || (Gu[o] = !0, c(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, i, o.replace(Ku, "")));
      }, Xb = function(i, o) {
        Kb || (Kb = !0, c("`NaN` is an invalid value for the `%s` css style property.", i));
      }, q1 = function(i, o) {
        Em || (Em = !0, c("`Infinity` is an invalid value for the `%s` css style property.", i));
      };
      Hb = function(i, o) {
        i.indexOf("-") > -1 ? _m(i) : Vb.test(i) ? Wb(i) : Ku.test(o) && Gb(i, o), typeof o == "number" && (isNaN(o) ? Xb(i, o) : isFinite(o) || q1(i, o));
      };
    }
    var Q1 = Hb;
    function Z1(i) {
      {
        var o = "", d = "";
        for (var h in i)
          if (i.hasOwnProperty(h)) {
            var b = i[h];
            if (b != null) {
              var C = h.indexOf("--") === 0;
              o += d + (C ? h : X1(h)) + ":", o += Kp(h, b, C), d = ";";
            }
          }
        return o || null;
      }
    }
    function qb(i, o) {
      var d = i.style;
      for (var h in o)
        if (o.hasOwnProperty(h)) {
          var b = h.indexOf("--") === 0;
          b || Q1(h, o[h]);
          var C = Kp(h, o[h], b);
          h === "float" && (h = "cssFloat"), b ? d.setProperty(h, C) : d[h] = C;
        }
    }
    function J1(i) {
      return i == null || typeof i == "boolean" || i === "";
    }
    function Ea(i) {
      var o = {};
      for (var d in i)
        for (var h = Ub[d] || [d], b = 0; b < h.length; b++)
          o[h[b]] = d;
      return o;
    }
    function vf(i, o) {
      {
        if (!o)
          return;
        var d = Ea(i), h = Ea(o), b = {};
        for (var C in d) {
          var R = d[C], A = h[C];
          if (A && R !== A) {
            var B = R + "," + A;
            if (b[B])
              continue;
            b[B] = !0, c("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", J1(i[R]) ? "Removing" : "Updating", R, A);
          }
        }
      }
    }
    var Qb = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, Zb = Jt({
      menuitem: !0
    }, Qb), Jb = "__html";
    function Wp(i, o) {
      if (o) {
        if (Zb[i] && (o.children != null || o.dangerouslySetInnerHTML != null))
          throw new Error(i + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (o.dangerouslySetInnerHTML != null) {
          if (o.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof o.dangerouslySetInnerHTML != "object" || !(Jb in o.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!o.suppressContentEditableWarning && o.contentEditable && o.children != null && c("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), o.style != null && typeof o.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function nl(i, o) {
      if (i.indexOf("-") === -1)
        return typeof o.is == "string";
      switch (i) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Gp = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, e0 = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, es = {}, Tm = new RegExp("^(aria)-[" + Et + "]*$"), yf = new RegExp("^(aria)[A-Z][" + Et + "]*$");
    function km(i, o) {
      {
        if (Ke.call(es, o) && es[o])
          return !0;
        if (yf.test(o)) {
          var d = "aria-" + o.slice(4).toLowerCase(), h = e0.hasOwnProperty(d) ? d : null;
          if (h == null)
            return c("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", o), es[o] = !0, !0;
          if (o !== h)
            return c("Invalid ARIA attribute `%s`. Did you mean `%s`?", o, h), es[o] = !0, !0;
        }
        if (Tm.test(o)) {
          var b = o.toLowerCase(), C = e0.hasOwnProperty(b) ? b : null;
          if (C == null)
            return es[o] = !0, !1;
          if (o !== C)
            return c("Unknown ARIA attribute `%s`. Did you mean `%s`?", o, C), es[o] = !0, !0;
        }
      }
      return !0;
    }
    function t0(i, o) {
      {
        var d = [];
        for (var h in o) {
          var b = km(i, h);
          b || d.push(h);
        }
        var C = d.map(function(R) {
          return "`" + R + "`";
        }).join(", ");
        d.length === 1 ? c("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", C, i) : d.length > 1 && c("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", C, i);
      }
    }
    function Xp(i, o) {
      nl(i, o) || t0(i, o);
    }
    var Bc = !1;
    function Pm(i, o) {
      {
        if (i !== "input" && i !== "textarea" && i !== "select")
          return;
        o != null && o.value === null && !Bc && (Bc = !0, i === "select" && o.multiple ? c("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", i) : c("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", i));
      }
    }
    var Im = function() {
    };
    {
      var wi = {}, Rm = /^on./, n0 = /^on[^A-Z]/, r0 = new RegExp("^(aria)-[" + Et + "]*$"), i0 = new RegExp("^(aria)[A-Z][" + Et + "]*$");
      Im = function(i, o, d, h) {
        if (Ke.call(wi, o) && wi[o])
          return !0;
        var b = o.toLowerCase();
        if (b === "onfocusin" || b === "onfocusout")
          return c("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), wi[o] = !0, !0;
        if (h != null) {
          var C = h.registrationNameDependencies, R = h.possibleRegistrationNames;
          if (C.hasOwnProperty(o))
            return !0;
          var A = R.hasOwnProperty(b) ? R[b] : null;
          if (A != null)
            return c("Invalid event handler property `%s`. Did you mean `%s`?", o, A), wi[o] = !0, !0;
          if (Rm.test(o))
            return c("Unknown event handler property `%s`. It will be ignored.", o), wi[o] = !0, !0;
        } else if (Rm.test(o))
          return n0.test(o) && c("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", o), wi[o] = !0, !0;
        if (r0.test(o) || i0.test(o))
          return !0;
        if (b === "innerhtml")
          return c("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), wi[o] = !0, !0;
        if (b === "aria")
          return c("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), wi[o] = !0, !0;
        if (b === "is" && d !== null && d !== void 0 && typeof d != "string")
          return c("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof d), wi[o] = !0, !0;
        if (typeof d == "number" && isNaN(d))
          return c("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", o), wi[o] = !0, !0;
        var B = gi(o), V = B !== null && B.type === xt;
        if (Gp.hasOwnProperty(b)) {
          var G = Gp[b];
          if (G !== o)
            return c("Invalid DOM property `%s`. Did you mean `%s`?", o, G), wi[o] = !0, !0;
        } else if (!V && o !== b)
          return c("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", o, b), wi[o] = !0, !0;
        return typeof d == "boolean" && hi(o, d, B, !1) ? (d ? c('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', d, o, o, d, o) : c('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', d, o, o, d, o, o, o), wi[o] = !0, !0) : V ? !0 : hi(o, d, B, !1) ? (wi[o] = !0, !1) : ((d === "false" || d === "true") && B !== null && B.type === An && (c("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", d, o, d === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', o, d), wi[o] = !0), !0);
      };
    }
    var o0 = function(i, o, d) {
      {
        var h = [];
        for (var b in o) {
          var C = Im(i, b, o[b], d);
          C || h.push(b);
        }
        var R = h.map(function(A) {
          return "`" + A + "`";
        }).join(", ");
        h.length === 1 ? c("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", R, i) : h.length > 1 && c("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", R, i);
      }
    };
    function a0(i, o, d) {
      nl(i, o) || o0(i, o, d);
    }
    var rl = 1, bf = 1 << 1, Fc = 1 << 2, eE = rl | bf | Fc, Sf = null;
    function wf(i) {
      Sf !== null && c("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Sf = i;
    }
    function tE() {
      Sf === null && c("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Sf = null;
    }
    function s0(i) {
      return i === Sf;
    }
    function qp(i) {
      var o = i.target || i.srcElement || window;
      return o.correspondingUseElement && (o = o.correspondingUseElement), o.nodeType === tl ? o.parentNode : o;
    }
    var sr = null, Hl = null, il = null;
    function Xu(i) {
      var o = wd(i);
      if (o) {
        if (typeof sr != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var d = o.stateNode;
        if (d) {
          var h = sS(d);
          sr(o.stateNode, o.type, h);
        }
      }
    }
    function l0(i) {
      sr = i;
    }
    function Qp(i) {
      Hl ? il ? il.push(i) : il = [i] : Hl = i;
    }
    function xf() {
      return Hl !== null || il !== null;
    }
    function Ef() {
      if (Hl) {
        var i = Hl, o = il;
        if (Hl = null, il = null, Xu(i), o)
          for (var d = 0; d < o.length; d++)
            Xu(o[d]);
      }
    }
    var Hc = function(i, o) {
      return i(o);
    }, $m = function() {
    }, Mm = !1;
    function nE() {
      var i = xf();
      i && ($m(), Ef());
    }
    function Am(i, o, d) {
      if (Mm)
        return i(o, d);
      Mm = !0;
      try {
        return Hc(i, o, d);
      } finally {
        Mm = !1, nE();
      }
    }
    function Zp(i, o, d) {
      Hc = i, $m = d;
    }
    function Jp(i) {
      return i === "button" || i === "input" || i === "select" || i === "textarea";
    }
    function Om(i, o, d) {
      switch (i) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(d.disabled && Jp(o));
        default:
          return !1;
      }
    }
    function Vc(i, o) {
      var d = i.stateNode;
      if (d === null)
        return null;
      var h = sS(d);
      if (h === null)
        return null;
      var b = h[o];
      if (Om(o, i.type, h))
        return null;
      if (b && typeof b != "function")
        throw new Error("Expected `" + o + "` listener to be a function, instead got a value of `" + typeof b + "` type.");
      return b;
    }
    var Cf = !1;
    if (Nt)
      try {
        var Yc = {};
        Object.defineProperty(Yc, "passive", {
          get: function() {
            Cf = !0;
          }
        }), window.addEventListener("test", Yc, Yc), window.removeEventListener("test", Yc, Yc);
      } catch {
        Cf = !1;
      }
    function c0(i, o, d, h, b, C, R, A, B) {
      var V = Array.prototype.slice.call(arguments, 3);
      try {
        o.apply(d, V);
      } catch (G) {
        this.onError(G);
      }
    }
    var Dm = c0;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var Nm = document.createElement("react");
      Dm = function(o, d, h, b, C, R, A, B, V) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var G = document.createEvent("Event"), ae = !1, ne = !0, Ce = window.event, _e = Object.getOwnPropertyDescriptor(window, "event");
        function Ae() {
          Nm.removeEventListener(Oe, Ot, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Ce);
        }
        var ut = Array.prototype.slice.call(arguments, 3);
        function Ot() {
          ae = !0, Ae(), d.apply(h, ut), ne = !1;
        }
        var Pt, _n = !1, vn = !1;
        function be(Se) {
          if (Pt = Se.error, _n = !0, Pt === null && Se.colno === 0 && Se.lineno === 0 && (vn = !0), Se.defaultPrevented && Pt != null && typeof Pt == "object")
            try {
              Pt._suppressLogging = !0;
            } catch {
            }
        }
        var Oe = "react-" + (o || "invokeguardedcallback");
        if (window.addEventListener("error", be), Nm.addEventListener(Oe, Ot, !1), G.initEvent(Oe, !1, !1), Nm.dispatchEvent(G), _e && Object.defineProperty(window, "event", _e), ae && ne && (_n ? vn && (Pt = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Pt = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Pt)), window.removeEventListener("error", be), !ae)
          return Ae(), c0.apply(this, arguments);
      };
    }
    var rE = Dm, Vl = !1, ts = null, _f = !1, Yl = null, Cs = {
      onError: function(i) {
        Vl = !0, ts = i;
      }
    };
    function Kc(i, o, d, h, b, C, R, A, B) {
      Vl = !1, ts = null, rE.apply(Cs, arguments);
    }
    function ol(i, o, d, h, b, C, R, A, B) {
      if (Kc.apply(this, arguments), Vl) {
        var V = jm();
        _f || (_f = !0, Yl = V);
      }
    }
    function Lm() {
      if (_f) {
        var i = Yl;
        throw _f = !1, Yl = null, i;
      }
    }
    function iE() {
      return Vl;
    }
    function jm() {
      if (Vl) {
        var i = ts;
        return Vl = !1, ts = null, i;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Ca(i) {
      return i._reactInternals;
    }
    function Tf(i) {
      return i._reactInternals !== void 0;
    }
    function qu(i, o) {
      i._reactInternals = o;
    }
    var Mt = (
      /*                      */
      0
    ), Kl = (
      /*                */
      1
    ), mr = (
      /*                    */
      2
    ), on = (
      /*                       */
      4
    ), Un = (
      /*                */
      16
    ), Vn = (
      /*                 */
      32
    ), _s = (
      /*                     */
      64
    ), Ht = (
      /*                   */
      128
    ), Fr = (
      /*            */
      256
    ), Ro = (
      /*                          */
      512
    ), _a = (
      /*                     */
      1024
    ), kr = (
      /*                      */
      2048
    ), Ta = (
      /*                    */
      4096
    ), Wl = (
      /*                   */
      8192
    ), kf = (
      /*             */
      16384
    ), eh = kr | on | _s | Ro | _a | kf, u0 = (
      /*               */
      32767
    ), Qo = (
      /*                   */
      32768
    ), xi = (
      /*                */
      65536
    ), Pf = (
      /* */
      131072
    ), zm = (
      /*                       */
      1048576
    ), Um = (
      /*                    */
      2097152
    ), $o = (
      /*                 */
      4194304
    ), Gl = (
      /*                */
      8388608
    ), Mo = (
      /*               */
      16777216
    ), Wc = (
      /*              */
      33554432
    ), Qu = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      on | _a | 0
    ), Ao = mr | on | Un | Vn | Ro | Ta | Wl, Gi = on | _s | Ro | Wl, ka = kr | Un, Mi = $o | Gl | Um, al = n.ReactCurrentOwner;
    function Zo(i) {
      var o = i, d = i;
      if (i.alternate)
        for (; o.return; )
          o = o.return;
      else {
        var h = o;
        do
          o = h, (o.flags & (mr | Ta)) !== Mt && (d = o.return), h = o.return;
        while (h);
      }
      return o.tag === v ? d : null;
    }
    function Bm(i) {
      if (i.tag === z) {
        var o = i.memoizedState;
        if (o === null) {
          var d = i.alternate;
          d !== null && (o = d.memoizedState);
        }
        if (o !== null)
          return o.dehydrated;
      }
      return null;
    }
    function th(i) {
      return i.tag === v ? i.stateNode.containerInfo : null;
    }
    function Fm(i) {
      return Zo(i) === i;
    }
    function Jo(i) {
      {
        var o = al.current;
        if (o !== null && o.tag === g) {
          var d = o, h = d.stateNode;
          h._warnedAboutRefsInRender || c("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Ft(d) || "A component"), h._warnedAboutRefsInRender = !0;
        }
      }
      var b = Ca(i);
      return b ? Zo(b) === b : !1;
    }
    function Oo(i) {
      if (Zo(i) !== i)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function vr(i) {
      var o = i.alternate;
      if (!o) {
        var d = Zo(i);
        if (d === null)
          throw new Error("Unable to find node on an unmounted component.");
        return d !== i ? null : i;
      }
      for (var h = i, b = o; ; ) {
        var C = h.return;
        if (C === null)
          break;
        var R = C.alternate;
        if (R === null) {
          var A = C.return;
          if (A !== null) {
            h = b = A;
            continue;
          }
          break;
        }
        if (C.child === R.child) {
          for (var B = C.child; B; ) {
            if (B === h)
              return Oo(C), i;
            if (B === b)
              return Oo(C), o;
            B = B.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (h.return !== b.return)
          h = C, b = R;
        else {
          for (var V = !1, G = C.child; G; ) {
            if (G === h) {
              V = !0, h = C, b = R;
              break;
            }
            if (G === b) {
              V = !0, b = C, h = R;
              break;
            }
            G = G.sibling;
          }
          if (!V) {
            for (G = R.child; G; ) {
              if (G === h) {
                V = !0, h = R, b = C;
                break;
              }
              if (G === b) {
                V = !0, b = R, h = C;
                break;
              }
              G = G.sibling;
            }
            if (!V)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (h.alternate !== b)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (h.tag !== v)
        throw new Error("Unable to find node on an unmounted component.");
      return h.stateNode.current === h ? i : o;
    }
    function Pa(i) {
      var o = vr(i);
      return o !== null ? Hm(o) : null;
    }
    function Hm(i) {
      if (i.tag === x || i.tag === _)
        return i;
      for (var o = i.child; o !== null; ) {
        var d = Hm(o);
        if (d !== null)
          return d;
        o = o.sibling;
      }
      return null;
    }
    function d0(i) {
      var o = vr(i);
      return o !== null ? nh(o) : null;
    }
    function nh(i) {
      if (i.tag === x || i.tag === _)
        return i;
      for (var o = i.child; o !== null; ) {
        if (o.tag !== S) {
          var d = nh(o);
          if (d !== null)
            return d;
        }
        o = o.sibling;
      }
      return null;
    }
    var rh = e.unstable_scheduleCallback, f0 = e.unstable_cancelCallback, ih = e.unstable_shouldYield, p0 = e.unstable_requestPaint, Ar = e.unstable_now, Vm = e.unstable_getCurrentPriorityLevel, oh = e.unstable_ImmediatePriority, ea = e.unstable_UserBlockingPriority, Ts = e.unstable_NormalPriority, ah = e.unstable_LowPriority, Xl = e.unstable_IdlePriority, Ym = e.unstable_yieldValue, Km = e.unstable_setDisableYieldValue, ql = null, Ei = null, tt = null, Gr = !1, Ai = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function Wm(i) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var o = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (o.isDisabled)
        return !0;
      if (!o.supportsFiber)
        return c("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        Me && (i = Jt({}, i, {
          getLaneLabelMap: Zl,
          injectProfilingHooks: ll
        })), ql = o.inject(i), Ei = o;
      } catch (d) {
        c("React instrumentation encountered an error: %s.", d);
      }
      return !!o.checkDCE;
    }
    function h0(i, o) {
      if (Ei && typeof Ei.onScheduleFiberRoot == "function")
        try {
          Ei.onScheduleFiberRoot(ql, i, o);
        } catch (d) {
          Gr || (Gr = !0, c("React instrumentation encountered an error: %s", d));
        }
    }
    function sl(i, o) {
      if (Ei && typeof Ei.onCommitFiberRoot == "function")
        try {
          var d = (i.current.flags & Ht) === Ht;
          if (re) {
            var h;
            switch (o) {
              case Xi:
                h = oh;
                break;
              case Oi:
                h = ea;
                break;
              case ul:
                h = Ts;
                break;
              case Lf:
                h = Xl;
                break;
              default:
                h = Ts;
                break;
            }
            Ei.onCommitFiberRoot(ql, i, h, d);
          }
        } catch (b) {
          Gr || (Gr = !0, c("React instrumentation encountered an error: %s", b));
        }
    }
    function Ql(i) {
      if (Ei && typeof Ei.onPostCommitFiberRoot == "function")
        try {
          Ei.onPostCommitFiberRoot(ql, i);
        } catch (o) {
          Gr || (Gr = !0, c("React instrumentation encountered an error: %s", o));
        }
    }
    function Gm(i) {
      if (Ei && typeof Ei.onCommitFiberUnmount == "function")
        try {
          Ei.onCommitFiberUnmount(ql, i);
        } catch (o) {
          Gr || (Gr = !0, c("React instrumentation encountered an error: %s", o));
        }
    }
    function ai(i) {
      if (typeof Ym == "function" && (Km(i), a(i)), Ei && typeof Ei.setStrictMode == "function")
        try {
          Ei.setStrictMode(ql, i);
        } catch (o) {
          Gr || (Gr = !0, c("React instrumentation encountered an error: %s", o));
        }
    }
    function ll(i) {
      tt = i;
    }
    function Zl() {
      {
        for (var i = /* @__PURE__ */ new Map(), o = 1, d = 0; d < yr; d++) {
          var h = oE(o);
          i.set(o, h), o *= 2;
        }
        return i;
      }
    }
    function sh(i) {
      tt !== null && typeof tt.markCommitStarted == "function" && tt.markCommitStarted(i);
    }
    function Xm() {
      tt !== null && typeof tt.markCommitStopped == "function" && tt.markCommitStopped();
    }
    function Jl(i) {
      tt !== null && typeof tt.markComponentRenderStarted == "function" && tt.markComponentRenderStarted(i);
    }
    function Gc() {
      tt !== null && typeof tt.markComponentRenderStopped == "function" && tt.markComponentRenderStopped();
    }
    function g0(i) {
      tt !== null && typeof tt.markComponentPassiveEffectMountStarted == "function" && tt.markComponentPassiveEffectMountStarted(i);
    }
    function qm() {
      tt !== null && typeof tt.markComponentPassiveEffectMountStopped == "function" && tt.markComponentPassiveEffectMountStopped();
    }
    function lh(i) {
      tt !== null && typeof tt.markComponentPassiveEffectUnmountStarted == "function" && tt.markComponentPassiveEffectUnmountStarted(i);
    }
    function m0() {
      tt !== null && typeof tt.markComponentPassiveEffectUnmountStopped == "function" && tt.markComponentPassiveEffectUnmountStopped();
    }
    function v0(i) {
      tt !== null && typeof tt.markComponentLayoutEffectMountStarted == "function" && tt.markComponentLayoutEffectMountStarted(i);
    }
    function y0() {
      tt !== null && typeof tt.markComponentLayoutEffectMountStopped == "function" && tt.markComponentLayoutEffectMountStopped();
    }
    function ch(i) {
      tt !== null && typeof tt.markComponentLayoutEffectUnmountStarted == "function" && tt.markComponentLayoutEffectUnmountStarted(i);
    }
    function Zu() {
      tt !== null && typeof tt.markComponentLayoutEffectUnmountStopped == "function" && tt.markComponentLayoutEffectUnmountStopped();
    }
    function uh(i, o, d) {
      tt !== null && typeof tt.markComponentErrored == "function" && tt.markComponentErrored(i, o, d);
    }
    function b0(i, o, d) {
      tt !== null && typeof tt.markComponentSuspended == "function" && tt.markComponentSuspended(i, o, d);
    }
    function S0(i) {
      tt !== null && typeof tt.markLayoutEffectsStarted == "function" && tt.markLayoutEffectsStarted(i);
    }
    function Ju() {
      tt !== null && typeof tt.markLayoutEffectsStopped == "function" && tt.markLayoutEffectsStopped();
    }
    function w0(i) {
      tt !== null && typeof tt.markPassiveEffectsStarted == "function" && tt.markPassiveEffectsStarted(i);
    }
    function If() {
      tt !== null && typeof tt.markPassiveEffectsStopped == "function" && tt.markPassiveEffectsStopped();
    }
    function ns(i) {
      tt !== null && typeof tt.markRenderStarted == "function" && tt.markRenderStarted(i);
    }
    function Rf() {
      tt !== null && typeof tt.markRenderYielded == "function" && tt.markRenderYielded();
    }
    function ed() {
      tt !== null && typeof tt.markRenderStopped == "function" && tt.markRenderStopped();
    }
    function Xc(i) {
      tt !== null && typeof tt.markRenderScheduled == "function" && tt.markRenderScheduled(i);
    }
    function Qm(i, o) {
      tt !== null && typeof tt.markForceUpdateScheduled == "function" && tt.markForceUpdateScheduled(i, o);
    }
    function ec(i, o) {
      tt !== null && typeof tt.markStateUpdateScheduled == "function" && tt.markStateUpdateScheduled(i, o);
    }
    var Dt = (
      /*                         */
      0
    ), fn = (
      /*                 */
      1
    ), Lt = (
      /*                    */
      2
    ), Or = (
      /*               */
      8
    ), Ia = (
      /*              */
      16
    ), dh = Math.clz32 ? Math.clz32 : qc, fh = Math.log, Zm = Math.LN2;
    function qc(i) {
      var o = i >>> 0;
      return o === 0 ? 32 : 31 - (fh(o) / Zm | 0) | 0;
    }
    var yr = 31, Ne = (
      /*                        */
      0
    ), En = (
      /*                          */
      0
    ), jt = (
      /*                        */
      1
    ), ks = (
      /*    */
      2
    ), ta = (
      /*             */
      4
    ), Qc = (
      /*            */
      8
    ), br = (
      /*                     */
      16
    ), Zc = (
      /*                */
      32
    ), tc = (
      /*                       */
      4194240
    ), Jc = (
      /*                        */
      64
    ), Ra = (
      /*                        */
      128
    ), Do = (
      /*                        */
      256
    ), eu = (
      /*                        */
      512
    ), $f = (
      /*                        */
      1024
    ), Mf = (
      /*                        */
      2048
    ), ph = (
      /*                        */
      4096
    ), hh = (
      /*                        */
      8192
    ), gh = (
      /*                        */
      16384
    ), mh = (
      /*                       */
      32768
    ), vh = (
      /*                       */
      65536
    ), yh = (
      /*                       */
      131072
    ), bh = (
      /*                       */
      262144
    ), Sh = (
      /*                       */
      524288
    ), tu = (
      /*                       */
      1048576
    ), wh = (
      /*                       */
      2097152
    ), nu = (
      /*                            */
      130023424
    ), cl = (
      /*                             */
      4194304
    ), xh = (
      /*                             */
      8388608
    ), Af = (
      /*                             */
      16777216
    ), Eh = (
      /*                             */
      33554432
    ), Ch = (
      /*                             */
      67108864
    ), Jm = cl, td = (
      /*          */
      134217728
    ), _h = (
      /*                          */
      268435455
    ), nd = (
      /*               */
      268435456
    ), nc = (
      /*                        */
      536870912
    ), No = (
      /*                   */
      1073741824
    );
    function oE(i) {
      {
        if (i & jt)
          return "Sync";
        if (i & ks)
          return "InputContinuousHydration";
        if (i & ta)
          return "InputContinuous";
        if (i & Qc)
          return "DefaultHydration";
        if (i & br)
          return "Default";
        if (i & Zc)
          return "TransitionHydration";
        if (i & tc)
          return "Transition";
        if (i & nu)
          return "Retry";
        if (i & td)
          return "SelectiveHydration";
        if (i & nd)
          return "IdleHydration";
        if (i & nc)
          return "Idle";
        if (i & No)
          return "Offscreen";
      }
    }
    var lr = -1, Th = Jc, kh = cl;
    function rd(i) {
      switch (ri(i)) {
        case jt:
          return jt;
        case ks:
          return ks;
        case ta:
          return ta;
        case Qc:
          return Qc;
        case br:
          return br;
        case Zc:
          return Zc;
        case Jc:
        case Ra:
        case Do:
        case eu:
        case $f:
        case Mf:
        case ph:
        case hh:
        case gh:
        case mh:
        case vh:
        case yh:
        case bh:
        case Sh:
        case tu:
        case wh:
          return i & tc;
        case cl:
        case xh:
        case Af:
        case Eh:
        case Ch:
          return i & nu;
        case td:
          return td;
        case nd:
          return nd;
        case nc:
          return nc;
        case No:
          return No;
        default:
          return c("Should have found matching lanes. This is a bug in React."), i;
      }
    }
    function Of(i, o) {
      var d = i.pendingLanes;
      if (d === Ne)
        return Ne;
      var h = Ne, b = i.suspendedLanes, C = i.pingedLanes, R = d & _h;
      if (R !== Ne) {
        var A = R & ~b;
        if (A !== Ne)
          h = rd(A);
        else {
          var B = R & C;
          B !== Ne && (h = rd(B));
        }
      } else {
        var V = d & ~b;
        V !== Ne ? h = rd(V) : C !== Ne && (h = rd(C));
      }
      if (h === Ne)
        return Ne;
      if (o !== Ne && o !== h && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (o & b) === Ne) {
        var G = ri(h), ae = ri(o);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          G >= ae || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          G === br && (ae & tc) !== Ne
        )
          return o;
      }
      (h & ta) !== Ne && (h |= d & br);
      var ne = i.entangledLanes;
      if (ne !== Ne)
        for (var Ce = i.entanglements, _e = h & ne; _e > 0; ) {
          var Ae = rc(_e), ut = 1 << Ae;
          h |= Ce[Ae], _e &= ~ut;
        }
      return h;
    }
    function x0(i, o) {
      for (var d = i.eventTimes, h = lr; o > 0; ) {
        var b = rc(o), C = 1 << b, R = d[b];
        R > h && (h = R), o &= ~C;
      }
      return h;
    }
    function Ph(i, o) {
      switch (i) {
        case jt:
        case ks:
        case ta:
          return o + 250;
        case Qc:
        case br:
        case Zc:
        case Jc:
        case Ra:
        case Do:
        case eu:
        case $f:
        case Mf:
        case ph:
        case hh:
        case gh:
        case mh:
        case vh:
        case yh:
        case bh:
        case Sh:
        case tu:
        case wh:
          return o + 5e3;
        case cl:
        case xh:
        case Af:
        case Eh:
        case Ch:
          return lr;
        case td:
        case nd:
        case nc:
        case No:
          return lr;
        default:
          return c("Should have found matching lanes. This is a bug in React."), lr;
      }
    }
    function aE(i, o) {
      for (var d = i.pendingLanes, h = i.suspendedLanes, b = i.pingedLanes, C = i.expirationTimes, R = d; R > 0; ) {
        var A = rc(R), B = 1 << A, V = C[A];
        V === lr ? ((B & h) === Ne || (B & b) !== Ne) && (C[A] = Ph(B, o)) : V <= o && (i.expiredLanes |= B), R &= ~B;
      }
    }
    function sE(i) {
      return rd(i.pendingLanes);
    }
    function ev(i) {
      var o = i.pendingLanes & ~No;
      return o !== Ne ? o : o & No ? No : Ne;
    }
    function id(i) {
      return (i & jt) !== Ne;
    }
    function Df(i) {
      return (i & _h) !== Ne;
    }
    function Ih(i) {
      return (i & nu) === i;
    }
    function lE(i) {
      var o = jt | ta | br;
      return (i & o) === Ne;
    }
    function E0(i) {
      return (i & tc) === i;
    }
    function Nf(i, o) {
      var d = ks | ta | Qc | br;
      return (o & d) !== Ne;
    }
    function C0(i, o) {
      return (o & i.expiredLanes) !== Ne;
    }
    function tv(i) {
      return (i & tc) !== Ne;
    }
    function nv() {
      var i = Th;
      return Th <<= 1, (Th & tc) === Ne && (Th = Jc), i;
    }
    function cE() {
      var i = kh;
      return kh <<= 1, (kh & nu) === Ne && (kh = cl), i;
    }
    function ri(i) {
      return i & -i;
    }
    function si(i) {
      return ri(i);
    }
    function rc(i) {
      return 31 - dh(i);
    }
    function Rh(i) {
      return rc(i);
    }
    function Lo(i, o) {
      return (i & o) !== Ne;
    }
    function ru(i, o) {
      return (i & o) === o;
    }
    function an(i, o) {
      return i | o;
    }
    function od(i, o) {
      return i & ~o;
    }
    function rv(i, o) {
      return i & o;
    }
    function _0(i) {
      return i;
    }
    function T0(i, o) {
      return i !== En && i < o ? i : o;
    }
    function $h(i) {
      for (var o = [], d = 0; d < yr; d++)
        o.push(i);
      return o;
    }
    function iu(i, o, d) {
      i.pendingLanes |= o, o !== nc && (i.suspendedLanes = Ne, i.pingedLanes = Ne);
      var h = i.eventTimes, b = Rh(o);
      h[b] = d;
    }
    function iv(i, o) {
      i.suspendedLanes |= o, i.pingedLanes &= ~o;
      for (var d = i.expirationTimes, h = o; h > 0; ) {
        var b = rc(h), C = 1 << b;
        d[b] = lr, h &= ~C;
      }
    }
    function ov(i, o, d) {
      i.pingedLanes |= i.suspendedLanes & o;
    }
    function av(i, o) {
      var d = i.pendingLanes & ~o;
      i.pendingLanes = o, i.suspendedLanes = Ne, i.pingedLanes = Ne, i.expiredLanes &= o, i.mutableReadLanes &= o, i.entangledLanes &= o;
      for (var h = i.entanglements, b = i.eventTimes, C = i.expirationTimes, R = d; R > 0; ) {
        var A = rc(R), B = 1 << A;
        h[A] = Ne, b[A] = lr, C[A] = lr, R &= ~B;
      }
    }
    function ad(i, o) {
      for (var d = i.entangledLanes |= o, h = i.entanglements, b = d; b; ) {
        var C = rc(b), R = 1 << C;
        // Is this one of the newly entangled lanes?
        R & o | // Is this lane transitively entangled with the newly entangled lanes?
        h[C] & o && (h[C] |= o), b &= ~R;
      }
    }
    function uE(i, o) {
      var d = ri(o), h;
      switch (d) {
        case ta:
          h = ks;
          break;
        case br:
          h = Qc;
          break;
        case Jc:
        case Ra:
        case Do:
        case eu:
        case $f:
        case Mf:
        case ph:
        case hh:
        case gh:
        case mh:
        case vh:
        case yh:
        case bh:
        case Sh:
        case tu:
        case wh:
        case cl:
        case xh:
        case Af:
        case Eh:
        case Ch:
          h = Zc;
          break;
        case nc:
          h = nd;
          break;
        default:
          h = En;
          break;
      }
      return (h & (i.suspendedLanes | o)) !== En ? En : h;
    }
    function sv(i, o, d) {
      if (Ai)
        for (var h = i.pendingUpdatersLaneMap; d > 0; ) {
          var b = Rh(d), C = 1 << b, R = h[b];
          R.add(o), d &= ~C;
        }
    }
    function Mh(i, o) {
      if (Ai)
        for (var d = i.pendingUpdatersLaneMap, h = i.memoizedUpdaters; o > 0; ) {
          var b = Rh(o), C = 1 << b, R = d[b];
          R.size > 0 && (R.forEach(function(A) {
            var B = A.alternate;
            (B === null || !h.has(B)) && h.add(A);
          }), R.clear()), o &= ~C;
        }
    }
    function lv(i, o) {
      return null;
    }
    var Xi = jt, Oi = ta, ul = br, Lf = nc, ou = En;
    function $a() {
      return ou;
    }
    function li(i) {
      ou = i;
    }
    function jf(i, o) {
      var d = ou;
      try {
        return ou = i, o();
      } finally {
        ou = d;
      }
    }
    function qi(i, o) {
      return i !== 0 && i < o ? i : o;
    }
    function dE(i, o) {
      return i === 0 || i > o ? i : o;
    }
    function cv(i, o) {
      return i !== 0 && i < o;
    }
    function zf(i) {
      var o = ri(i);
      return cv(Xi, o) ? cv(Oi, o) ? Df(o) ? ul : Lf : Oi : Xi;
    }
    function ci(i) {
      var o = i.current.memoizedState;
      return o.isDehydrated;
    }
    var k0;
    function ft(i) {
      k0 = i;
    }
    function sd(i) {
      k0(i);
    }
    var Uf;
    function P0(i) {
      Uf = i;
    }
    var I0;
    function Bf(i) {
      I0 = i;
    }
    var Ff;
    function uv(i) {
      Ff = i;
    }
    var dv;
    function R0(i) {
      dv = i;
    }
    var Ah = !1, ld = [], Ps = null, Pr = null, Ci = null, Ma = /* @__PURE__ */ new Map(), cd = /* @__PURE__ */ new Map(), dl = [], rs = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function $0(i) {
      return rs.indexOf(i) > -1;
    }
    function Is(i, o, d, h, b) {
      return {
        blockedOn: i,
        domEventName: o,
        eventSystemFlags: d,
        nativeEvent: b,
        targetContainers: [h]
      };
    }
    function M0(i, o) {
      switch (i) {
        case "focusin":
        case "focusout":
          Ps = null;
          break;
        case "dragenter":
        case "dragleave":
          Pr = null;
          break;
        case "mouseover":
        case "mouseout":
          Ci = null;
          break;
        case "pointerover":
        case "pointerout": {
          var d = o.pointerId;
          Ma.delete(d);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var h = o.pointerId;
          cd.delete(h);
          break;
        }
      }
    }
    function ud(i, o, d, h, b, C) {
      if (i === null || i.nativeEvent !== C) {
        var R = Is(o, d, h, b, C);
        if (o !== null) {
          var A = wd(o);
          A !== null && Uf(A);
        }
        return R;
      }
      i.eventSystemFlags |= h;
      var B = i.targetContainers;
      return b !== null && B.indexOf(b) === -1 && B.push(b), i;
    }
    function A0(i, o, d, h, b) {
      switch (o) {
        case "focusin": {
          var C = b;
          return Ps = ud(Ps, i, o, d, h, C), !0;
        }
        case "dragenter": {
          var R = b;
          return Pr = ud(Pr, i, o, d, h, R), !0;
        }
        case "mouseover": {
          var A = b;
          return Ci = ud(Ci, i, o, d, h, A), !0;
        }
        case "pointerover": {
          var B = b, V = B.pointerId;
          return Ma.set(V, ud(Ma.get(V) || null, i, o, d, h, B)), !0;
        }
        case "gotpointercapture": {
          var G = b, ae = G.pointerId;
          return cd.set(ae, ud(cd.get(ae) || null, i, o, d, h, G)), !0;
        }
      }
      return !1;
    }
    function fv(i) {
      var o = Qf(i.target);
      if (o !== null) {
        var d = Zo(o);
        if (d !== null) {
          var h = d.tag;
          if (h === z) {
            var b = Bm(d);
            if (b !== null) {
              i.blockedOn = b, dv(i.priority, function() {
                I0(d);
              });
              return;
            }
          } else if (h === v) {
            var C = d.stateNode;
            if (ci(C)) {
              i.blockedOn = th(d);
              return;
            }
          }
        }
      }
      i.blockedOn = null;
    }
    function O0(i) {
      for (var o = Ff(), d = {
        blockedOn: null,
        target: i,
        priority: o
      }, h = 0; h < dl.length && cv(o, dl[h].priority); h++)
        ;
      dl.splice(h, 0, d), h === 0 && fv(d);
    }
    function Oh(i) {
      if (i.blockedOn !== null)
        return !1;
      for (var o = i.targetContainers; o.length > 0; ) {
        var d = o[0], h = au(i.domEventName, i.eventSystemFlags, d, i.nativeEvent);
        if (h === null) {
          var b = i.nativeEvent, C = new b.constructor(b.type, b);
          wf(C), b.target.dispatchEvent(C), tE();
        } else {
          var R = wd(h);
          return R !== null && Uf(R), i.blockedOn = h, !1;
        }
        o.shift();
      }
      return !0;
    }
    function Hf(i, o, d) {
      Oh(i) && d.delete(o);
    }
    function pv() {
      Ah = !1, Ps !== null && Oh(Ps) && (Ps = null), Pr !== null && Oh(Pr) && (Pr = null), Ci !== null && Oh(Ci) && (Ci = null), Ma.forEach(Hf), cd.forEach(Hf);
    }
    function Qi(i, o) {
      i.blockedOn === o && (i.blockedOn = null, Ah || (Ah = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, pv)));
    }
    function mn(i) {
      if (ld.length > 0) {
        Qi(ld[0], i);
        for (var o = 1; o < ld.length; o++) {
          var d = ld[o];
          d.blockedOn === i && (d.blockedOn = null);
        }
      }
      Ps !== null && Qi(Ps, i), Pr !== null && Qi(Pr, i), Ci !== null && Qi(Ci, i);
      var h = function(A) {
        return Qi(A, i);
      };
      Ma.forEach(h), cd.forEach(h);
      for (var b = 0; b < dl.length; b++) {
        var C = dl[b];
        C.blockedOn === i && (C.blockedOn = null);
      }
      for (; dl.length > 0; ) {
        var R = dl[0];
        if (R.blockedOn !== null)
          break;
        fv(R), R.blockedOn === null && dl.shift();
      }
    }
    var Dr = n.ReactCurrentBatchConfig, Hr = !0;
    function _i(i) {
      Hr = !!i;
    }
    function na() {
      return Hr;
    }
    function dd(i, o, d) {
      var h = uo(o), b;
      switch (h) {
        case Xi:
          b = ui;
          break;
        case Oi:
          b = Vf;
          break;
        case ul:
        default:
          b = fl;
          break;
      }
      return b.bind(null, o, d, i);
    }
    function ui(i, o, d, h) {
      var b = $a(), C = Dr.transition;
      Dr.transition = null;
      try {
        li(Xi), fl(i, o, d, h);
      } finally {
        li(b), Dr.transition = C;
      }
    }
    function Vf(i, o, d, h) {
      var b = $a(), C = Dr.transition;
      Dr.transition = null;
      try {
        li(Oi), fl(i, o, d, h);
      } finally {
        li(b), Dr.transition = C;
      }
    }
    function fl(i, o, d, h) {
      Hr && Dh(i, o, d, h);
    }
    function Dh(i, o, d, h) {
      var b = au(i, o, d, h);
      if (b === null) {
        $E(i, o, h, fd, d), M0(i, h);
        return;
      }
      if (A0(b, i, o, d, h)) {
        h.stopPropagation();
        return;
      }
      if (M0(i, h), o & Fc && $0(i)) {
        for (; b !== null; ) {
          var C = wd(b);
          C !== null && sd(C);
          var R = au(i, o, d, h);
          if (R === null && $E(i, o, h, fd, d), R === b)
            break;
          b = R;
        }
        b !== null && h.stopPropagation();
        return;
      }
      $E(i, o, h, null, d);
    }
    var fd = null;
    function au(i, o, d, h) {
      fd = null;
      var b = qp(h), C = Qf(b);
      if (C !== null) {
        var R = Zo(C);
        if (R === null)
          C = null;
        else {
          var A = R.tag;
          if (A === z) {
            var B = Bm(R);
            if (B !== null)
              return B;
            C = null;
          } else if (A === v) {
            var V = R.stateNode;
            if (ci(V))
              return th(R);
            C = null;
          } else
            R !== C && (C = null);
        }
      }
      return fd = C, null;
    }
    function uo(i) {
      switch (i) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return Xi;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return Oi;
        case "message": {
          var o = Vm();
          switch (o) {
            case oh:
              return Xi;
            case ea:
              return Oi;
            case Ts:
            case ah:
              return ul;
            case Xl:
              return Lf;
            default:
              return ul;
          }
        }
        default:
          return ul;
      }
    }
    function hv(i, o, d) {
      return i.addEventListener(o, d, !1), d;
    }
    function pd(i, o, d) {
      return i.addEventListener(o, d, !0), d;
    }
    function pl(i, o, d, h) {
      return i.addEventListener(o, d, {
        capture: !0,
        passive: h
      }), d;
    }
    function Nh(i, o, d, h) {
      return i.addEventListener(o, d, {
        passive: h
      }), d;
    }
    var su = null, Rs = null, ic = null;
    function oc(i) {
      return su = i, Rs = jh(), !0;
    }
    function Lh() {
      su = null, Rs = null, ic = null;
    }
    function hd() {
      if (ic)
        return ic;
      var i, o = Rs, d = o.length, h, b = jh(), C = b.length;
      for (i = 0; i < d && o[i] === b[i]; i++)
        ;
      var R = d - i;
      for (h = 1; h <= R && o[d - h] === b[C - h]; h++)
        ;
      var A = h > 1 ? 1 - h : void 0;
      return ic = b.slice(i, A), ic;
    }
    function jh() {
      return "value" in su ? su.value : su.textContent;
    }
    function lu(i) {
      var o, d = i.keyCode;
      return "charCode" in i ? (o = i.charCode, o === 0 && d === 13 && (o = 13)) : o = d, o === 10 && (o = 13), o >= 32 || o === 13 ? o : 0;
    }
    function cu() {
      return !0;
    }
    function Zi() {
      return !1;
    }
    function ii(i) {
      function o(d, h, b, C, R) {
        this._reactName = d, this._targetInst = b, this.type = h, this.nativeEvent = C, this.target = R, this.currentTarget = null;
        for (var A in i)
          if (i.hasOwnProperty(A)) {
            var B = i[A];
            B ? this[A] = B(C) : this[A] = C[A];
          }
        var V = C.defaultPrevented != null ? C.defaultPrevented : C.returnValue === !1;
        return V ? this.isDefaultPrevented = cu : this.isDefaultPrevented = Zi, this.isPropagationStopped = Zi, this;
      }
      return Jt(o.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var d = this.nativeEvent;
          d && (d.preventDefault ? d.preventDefault() : typeof d.returnValue != "unknown" && (d.returnValue = !1), this.isDefaultPrevented = cu);
        },
        stopPropagation: function() {
          var d = this.nativeEvent;
          d && (d.stopPropagation ? d.stopPropagation() : typeof d.cancelBubble != "unknown" && (d.cancelBubble = !0), this.isPropagationStopped = cu);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: cu
      }), o;
    }
    var Ji = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(i) {
        return i.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, eo = ii(Ji), gd = Jt({}, Ji, {
      view: 0,
      detail: 0
    }), gv = ii(gd), Yf, mv, Aa;
    function D0(i) {
      i !== Aa && (Aa && i.type === "mousemove" ? (Yf = i.screenX - Aa.screenX, mv = i.screenY - Aa.screenY) : (Yf = 0, mv = 0), Aa = i);
    }
    var md = Jt({}, gd, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Bh,
      button: 0,
      buttons: 0,
      relatedTarget: function(i) {
        return i.relatedTarget === void 0 ? i.fromElement === i.srcElement ? i.toElement : i.fromElement : i.relatedTarget;
      },
      movementX: function(i) {
        return "movementX" in i ? i.movementX : (D0(i), Yf);
      },
      movementY: function(i) {
        return "movementY" in i ? i.movementY : mv;
      }
    }), ac = ii(md), vv = Jt({}, md, {
      dataTransfer: 0
    }), uu = ii(vv), N0 = Jt({}, gd, {
      relatedTarget: 0
    }), zh = ii(N0), yv = Jt({}, Ji, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Uh = ii(yv), fE = Jt({}, Ji, {
      clipboardData: function(i) {
        return "clipboardData" in i ? i.clipboardData : window.clipboardData;
      }
    }), pE = ii(fE), L0 = Jt({}, Ji, {
      data: 0
    }), bv = ii(L0), du = bv, hE = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, vd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function j0(i) {
      if (i.key) {
        var o = hE[i.key] || i.key;
        if (o !== "Unidentified")
          return o;
      }
      if (i.type === "keypress") {
        var d = lu(i);
        return d === 13 ? "Enter" : String.fromCharCode(d);
      }
      return i.type === "keydown" || i.type === "keyup" ? vd[i.keyCode] || "Unidentified" : "";
    }
    var Vr = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function gE(i) {
      var o = this, d = o.nativeEvent;
      if (d.getModifierState)
        return d.getModifierState(i);
      var h = Vr[i];
      return h ? !!d[h] : !1;
    }
    function Bh(i) {
      return gE;
    }
    var mE = Jt({}, gd, {
      key: j0,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Bh,
      // Legacy Interface
      charCode: function(i) {
        return i.type === "keypress" ? lu(i) : 0;
      },
      keyCode: function(i) {
        return i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
      },
      which: function(i) {
        return i.type === "keypress" ? lu(i) : i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
      }
    }), vE = ii(mE), z0 = Jt({}, md, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), Sv = ii(z0), yE = Jt({}, gd, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Bh
    }), Oa = ii(yE), wv = Jt({}, Ji, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), bE = ii(wv), sc = Jt({}, md, {
      deltaX: function(i) {
        return "deltaX" in i ? i.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in i ? -i.wheelDeltaX : 0
        );
      },
      deltaY: function(i) {
        return "deltaY" in i ? i.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in i ? -i.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in i ? -i.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), Fh = ii(sc), fu = [9, 13, 27, 32], Kf = 229, Wf = Nt && "CompositionEvent" in window, pu = null;
    Nt && "documentMode" in document && (pu = document.documentMode);
    var SE = Nt && "TextEvent" in window && !pu, Hh = Nt && (!Wf || pu && pu > 8 && pu <= 11), U0 = 32, xv = String.fromCharCode(U0);
    function B0() {
      Tt("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), Tt("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Tt("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), Tt("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Gf = !1;
    function Vh(i) {
      return (i.ctrlKey || i.altKey || i.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(i.ctrlKey && i.altKey);
    }
    function F0(i) {
      switch (i) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function Ev(i, o) {
      return i === "keydown" && o.keyCode === Kf;
    }
    function H0(i, o) {
      switch (i) {
        case "keyup":
          return fu.indexOf(o.keyCode) !== -1;
        case "keydown":
          return o.keyCode !== Kf;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function Cv(i) {
      var o = i.detail;
      return typeof o == "object" && "data" in o ? o.data : null;
    }
    function Yh(i) {
      return i.locale === "ko";
    }
    var hl = !1;
    function _v(i, o, d, h, b) {
      var C, R;
      if (Wf ? C = F0(o) : hl ? H0(o, h) && (C = "onCompositionEnd") : Ev(o, h) && (C = "onCompositionStart"), !C)
        return null;
      Hh && !Yh(h) && (!hl && C === "onCompositionStart" ? hl = oc(b) : C === "onCompositionEnd" && hl && (R = hd()));
      var A = G0(d, C);
      if (A.length > 0) {
        var B = new bv(C, o, null, h, b);
        if (i.push({
          event: B,
          listeners: A
        }), R)
          B.data = R;
        else {
          var V = Cv(h);
          V !== null && (B.data = V);
        }
      }
    }
    function Kh(i, o) {
      switch (i) {
        case "compositionend":
          return Cv(o);
        case "keypress":
          var d = o.which;
          return d !== U0 ? null : (Gf = !0, xv);
        case "textInput":
          var h = o.data;
          return h === xv && Gf ? null : h;
        default:
          return null;
      }
    }
    function V0(i, o) {
      if (hl) {
        if (i === "compositionend" || !Wf && H0(i, o)) {
          var d = hd();
          return Lh(), hl = !1, d;
        }
        return null;
      }
      switch (i) {
        case "paste":
          return null;
        case "keypress":
          if (!Vh(o)) {
            if (o.char && o.char.length > 1)
              return o.char;
            if (o.which)
              return String.fromCharCode(o.which);
          }
          return null;
        case "compositionend":
          return Hh && !Yh(o) ? null : o.data;
        default:
          return null;
      }
    }
    function wE(i, o, d, h, b) {
      var C;
      if (SE ? C = Kh(o, h) : C = V0(o, h), !C)
        return null;
      var R = G0(d, "onBeforeInput");
      if (R.length > 0) {
        var A = new du("onBeforeInput", "beforeinput", null, h, b);
        i.push({
          event: A,
          listeners: R
        }), A.data = C;
      }
    }
    function Wh(i, o, d, h, b, C, R) {
      _v(i, o, d, h, b), wE(i, o, d, h, b);
    }
    var xE = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function yd(i) {
      var o = i && i.nodeName && i.nodeName.toLowerCase();
      return o === "input" ? !!xE[i.type] : o === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function EE(i) {
      if (!Nt)
        return !1;
      var o = "on" + i, d = o in document;
      if (!d) {
        var h = document.createElement("div");
        h.setAttribute(o, "return;"), d = typeof h[o] == "function";
      }
      return d;
    }
    function Gh() {
      Tt("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function l(i, o, d, h) {
      Qp(h);
      var b = G0(o, "onChange");
      if (b.length > 0) {
        var C = new eo("onChange", "change", null, d, h);
        i.push({
          event: C,
          listeners: b
        });
      }
    }
    var u = null, m = null;
    function w(i) {
      var o = i.nodeName && i.nodeName.toLowerCase();
      return o === "select" || o === "input" && i.type === "file";
    }
    function P(i) {
      var o = [];
      l(o, m, i, qp(i)), Am(M, o);
    }
    function M(i) {
      J2(i, 0);
    }
    function H(i) {
      var o = eg(i);
      if (Ue(o))
        return i;
    }
    function Q(i, o) {
      if (i === "change")
        return o;
    }
    var ee = !1;
    Nt && (ee = EE("input") && (!document.documentMode || document.documentMode > 9));
    function Te(i, o) {
      u = i, m = o, u.attachEvent("onpropertychange", Ye);
    }
    function Ve() {
      u && (u.detachEvent("onpropertychange", Ye), u = null, m = null);
    }
    function Ye(i) {
      i.propertyName === "value" && H(m) && P(i);
    }
    function He(i, o, d) {
      i === "focusin" ? (Ve(), Te(o, d)) : i === "focusout" && Ve();
    }
    function lt(i, o) {
      if (i === "selectionchange" || i === "keyup" || i === "keydown")
        return H(m);
    }
    function gt(i) {
      var o = i.nodeName;
      return o && o.toLowerCase() === "input" && (i.type === "checkbox" || i.type === "radio");
    }
    function wt(i, o) {
      if (i === "click")
        return H(o);
    }
    function Xr(i, o) {
      if (i === "input" || i === "change")
        return H(o);
    }
    function ge(i) {
      var o = i._wrapperState;
      !o || !o.controlled || i.type !== "number" || bt(i, "number", i.value);
    }
    function oe(i, o, d, h, b, C, R) {
      var A = d ? eg(d) : window, B, V;
      if (w(A) ? B = Q : yd(A) ? ee ? B = Xr : (B = lt, V = He) : gt(A) && (B = wt), B) {
        var G = B(o, d);
        if (G) {
          l(i, G, h, b);
          return;
        }
      }
      V && V(o, A, d), o === "focusout" && ge(A);
    }
    function we() {
      Le("onMouseEnter", ["mouseout", "mouseover"]), Le("onMouseLeave", ["mouseout", "mouseover"]), Le("onPointerEnter", ["pointerout", "pointerover"]), Le("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function Xe(i, o, d, h, b, C, R) {
      var A = o === "mouseover" || o === "pointerover", B = o === "mouseout" || o === "pointerout";
      if (A && !s0(h)) {
        var V = h.relatedTarget || h.fromElement;
        if (V && (Qf(V) || zv(V)))
          return;
      }
      if (!(!B && !A)) {
        var G;
        if (b.window === b)
          G = b;
        else {
          var ae = b.ownerDocument;
          ae ? G = ae.defaultView || ae.parentWindow : G = window;
        }
        var ne, Ce;
        if (B) {
          var _e = h.relatedTarget || h.toElement;
          if (ne = d, Ce = _e ? Qf(_e) : null, Ce !== null) {
            var Ae = Zo(Ce);
            (Ce !== Ae || Ce.tag !== x && Ce.tag !== _) && (Ce = null);
          }
        } else
          ne = null, Ce = d;
        if (ne !== Ce) {
          var ut = ac, Ot = "onMouseLeave", Pt = "onMouseEnter", _n = "mouse";
          (o === "pointerout" || o === "pointerover") && (ut = Sv, Ot = "onPointerLeave", Pt = "onPointerEnter", _n = "pointer");
          var vn = ne == null ? G : eg(ne), be = Ce == null ? G : eg(Ce), Oe = new ut(Ot, _n + "leave", ne, h, b);
          Oe.target = vn, Oe.relatedTarget = be;
          var Se = null, We = Qf(b);
          if (We === d) {
            var dt = new ut(Pt, _n + "enter", Ce, h, b);
            dt.target = be, dt.relatedTarget = vn, Se = dt;
          }
          f6(i, Oe, Se, ne, Ce);
        }
      }
    }
    function Ct(i, o) {
      return i === o && (i !== 0 || 1 / i === 1 / o) || i !== i && o !== o;
    }
    var mt = typeof Object.is == "function" ? Object.is : Ct;
    function $t(i, o) {
      if (mt(i, o))
        return !0;
      if (typeof i != "object" || i === null || typeof o != "object" || o === null)
        return !1;
      var d = Object.keys(i), h = Object.keys(o);
      if (d.length !== h.length)
        return !1;
      for (var b = 0; b < d.length; b++) {
        var C = d[b];
        if (!Ke.call(o, C) || !mt(i[C], o[C]))
          return !1;
      }
      return !0;
    }
    function Vt(i) {
      for (; i && i.firstChild; )
        i = i.firstChild;
      return i;
    }
    function Ti(i) {
      for (; i; ) {
        if (i.nextSibling)
          return i.nextSibling;
        i = i.parentNode;
      }
    }
    function Rn(i, o) {
      for (var d = Vt(i), h = 0, b = 0; d; ) {
        if (d.nodeType === tl) {
          if (b = h + d.textContent.length, h <= o && b >= o)
            return {
              node: d,
              offset: o - h
            };
          h = b;
        }
        d = Vt(Ti(d));
      }
    }
    function lc(i) {
      var o = i.ownerDocument, d = o && o.defaultView || window, h = d.getSelection && d.getSelection();
      if (!h || h.rangeCount === 0)
        return null;
      var b = h.anchorNode, C = h.anchorOffset, R = h.focusNode, A = h.focusOffset;
      try {
        b.nodeType, R.nodeType;
      } catch {
        return null;
      }
      return CE(i, b, C, R, A);
    }
    function CE(i, o, d, h, b) {
      var C = 0, R = -1, A = -1, B = 0, V = 0, G = i, ae = null;
      e:
        for (; ; ) {
          for (var ne = null; G === o && (d === 0 || G.nodeType === tl) && (R = C + d), G === h && (b === 0 || G.nodeType === tl) && (A = C + b), G.nodeType === tl && (C += G.nodeValue.length), (ne = G.firstChild) !== null; )
            ae = G, G = ne;
          for (; ; ) {
            if (G === i)
              break e;
            if (ae === o && ++B === d && (R = C), ae === h && ++V === b && (A = C), (ne = G.nextSibling) !== null)
              break;
            G = ae, ae = G.parentNode;
          }
          G = ne;
        }
      return R === -1 || A === -1 ? null : {
        start: R,
        end: A
      };
    }
    function W5(i, o) {
      var d = i.ownerDocument || document, h = d && d.defaultView || window;
      if (h.getSelection) {
        var b = h.getSelection(), C = i.textContent.length, R = Math.min(o.start, C), A = o.end === void 0 ? R : Math.min(o.end, C);
        if (!b.extend && R > A) {
          var B = A;
          A = R, R = B;
        }
        var V = Rn(i, R), G = Rn(i, A);
        if (V && G) {
          if (b.rangeCount === 1 && b.anchorNode === V.node && b.anchorOffset === V.offset && b.focusNode === G.node && b.focusOffset === G.offset)
            return;
          var ae = d.createRange();
          ae.setStart(V.node, V.offset), b.removeAllRanges(), R > A ? (b.addRange(ae), b.extend(G.node, G.offset)) : (ae.setEnd(G.node, G.offset), b.addRange(ae));
        }
      }
    }
    function B2(i) {
      return i && i.nodeType === tl;
    }
    function F2(i, o) {
      return !i || !o ? !1 : i === o ? !0 : B2(i) ? !1 : B2(o) ? F2(i, o.parentNode) : "contains" in i ? i.contains(o) : i.compareDocumentPosition ? !!(i.compareDocumentPosition(o) & 16) : !1;
    }
    function G5(i) {
      return i && i.ownerDocument && F2(i.ownerDocument.documentElement, i);
    }
    function X5(i) {
      try {
        return typeof i.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function H2() {
      for (var i = window, o = it(); o instanceof i.HTMLIFrameElement; ) {
        if (X5(o))
          i = o.contentWindow;
        else
          return o;
        o = it(i.document);
      }
      return o;
    }
    function _E(i) {
      var o = i && i.nodeName && i.nodeName.toLowerCase();
      return o && (o === "input" && (i.type === "text" || i.type === "search" || i.type === "tel" || i.type === "url" || i.type === "password") || o === "textarea" || i.contentEditable === "true");
    }
    function q5() {
      var i = H2();
      return {
        focusedElem: i,
        selectionRange: _E(i) ? Z5(i) : null
      };
    }
    function Q5(i) {
      var o = H2(), d = i.focusedElem, h = i.selectionRange;
      if (o !== d && G5(d)) {
        h !== null && _E(d) && J5(d, h);
        for (var b = [], C = d; C = C.parentNode; )
          C.nodeType === Io && b.push({
            element: C,
            left: C.scrollLeft,
            top: C.scrollTop
          });
        typeof d.focus == "function" && d.focus();
        for (var R = 0; R < b.length; R++) {
          var A = b[R];
          A.element.scrollLeft = A.left, A.element.scrollTop = A.top;
        }
      }
    }
    function Z5(i) {
      var o;
      return "selectionStart" in i ? o = {
        start: i.selectionStart,
        end: i.selectionEnd
      } : o = lc(i), o || {
        start: 0,
        end: 0
      };
    }
    function J5(i, o) {
      var d = o.start, h = o.end;
      h === void 0 && (h = d), "selectionStart" in i ? (i.selectionStart = d, i.selectionEnd = Math.min(h, i.value.length)) : W5(i, o);
    }
    var e6 = Nt && "documentMode" in document && document.documentMode <= 11;
    function t6() {
      Tt("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var Xh = null, TE = null, Tv = null, kE = !1;
    function n6(i) {
      if ("selectionStart" in i && _E(i))
        return {
          start: i.selectionStart,
          end: i.selectionEnd
        };
      var o = i.ownerDocument && i.ownerDocument.defaultView || window, d = o.getSelection();
      return {
        anchorNode: d.anchorNode,
        anchorOffset: d.anchorOffset,
        focusNode: d.focusNode,
        focusOffset: d.focusOffset
      };
    }
    function r6(i) {
      return i.window === i ? i.document : i.nodeType === Ja ? i : i.ownerDocument;
    }
    function V2(i, o, d) {
      var h = r6(d);
      if (!(kE || Xh == null || Xh !== it(h))) {
        var b = n6(Xh);
        if (!Tv || !$t(Tv, b)) {
          Tv = b;
          var C = G0(TE, "onSelect");
          if (C.length > 0) {
            var R = new eo("onSelect", "select", null, o, d);
            i.push({
              event: R,
              listeners: C
            }), R.target = Xh;
          }
        }
      }
    }
    function i6(i, o, d, h, b, C, R) {
      var A = d ? eg(d) : window;
      switch (o) {
        case "focusin":
          (yd(A) || A.contentEditable === "true") && (Xh = A, TE = d, Tv = null);
          break;
        case "focusout":
          Xh = null, TE = null, Tv = null;
          break;
        case "mousedown":
          kE = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          kE = !1, V2(i, h, b);
          break;
        case "selectionchange":
          if (e6)
            break;
        case "keydown":
        case "keyup":
          V2(i, h, b);
      }
    }
    function Y0(i, o) {
      var d = {};
      return d[i.toLowerCase()] = o.toLowerCase(), d["Webkit" + i] = "webkit" + o, d["Moz" + i] = "moz" + o, d;
    }
    var qh = {
      animationend: Y0("Animation", "AnimationEnd"),
      animationiteration: Y0("Animation", "AnimationIteration"),
      animationstart: Y0("Animation", "AnimationStart"),
      transitionend: Y0("Transition", "TransitionEnd")
    }, PE = {}, Y2 = {};
    Nt && (Y2 = document.createElement("div").style, "AnimationEvent" in window || (delete qh.animationend.animation, delete qh.animationiteration.animation, delete qh.animationstart.animation), "TransitionEvent" in window || delete qh.transitionend.transition);
    function K0(i) {
      if (PE[i])
        return PE[i];
      if (!qh[i])
        return i;
      var o = qh[i];
      for (var d in o)
        if (o.hasOwnProperty(d) && d in Y2)
          return PE[i] = o[d];
      return i;
    }
    var K2 = K0("animationend"), W2 = K0("animationiteration"), G2 = K0("animationstart"), X2 = K0("transitionend"), q2 = /* @__PURE__ */ new Map(), Q2 = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function bd(i, o) {
      q2.set(i, o), Tt(o, [i]);
    }
    function o6() {
      for (var i = 0; i < Q2.length; i++) {
        var o = Q2[i], d = o.toLowerCase(), h = o[0].toUpperCase() + o.slice(1);
        bd(d, "on" + h);
      }
      bd(K2, "onAnimationEnd"), bd(W2, "onAnimationIteration"), bd(G2, "onAnimationStart"), bd("dblclick", "onDoubleClick"), bd("focusin", "onFocus"), bd("focusout", "onBlur"), bd(X2, "onTransitionEnd");
    }
    function a6(i, o, d, h, b, C, R) {
      var A = q2.get(o);
      if (A !== void 0) {
        var B = eo, V = o;
        switch (o) {
          case "keypress":
            if (lu(h) === 0)
              return;
          case "keydown":
          case "keyup":
            B = vE;
            break;
          case "focusin":
            V = "focus", B = zh;
            break;
          case "focusout":
            V = "blur", B = zh;
            break;
          case "beforeblur":
          case "afterblur":
            B = zh;
            break;
          case "click":
            if (h.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            B = ac;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            B = uu;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            B = Oa;
            break;
          case K2:
          case W2:
          case G2:
            B = Uh;
            break;
          case X2:
            B = bE;
            break;
          case "scroll":
            B = gv;
            break;
          case "wheel":
            B = Fh;
            break;
          case "copy":
          case "cut":
          case "paste":
            B = pE;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            B = Sv;
            break;
        }
        var G = (C & Fc) !== 0;
        {
          var ae = !G && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          o === "scroll", ne = u6(d, A, h.type, G, ae);
          if (ne.length > 0) {
            var Ce = new B(A, V, null, h, b);
            i.push({
              event: Ce,
              listeners: ne
            });
          }
        }
      }
    }
    o6(), we(), Gh(), t6(), B0();
    function s6(i, o, d, h, b, C, R) {
      a6(i, o, d, h, b, C);
      var A = (C & eE) === 0;
      A && (Xe(i, o, d, h, b), oe(i, o, d, h, b), i6(i, o, d, h, b), Wh(i, o, d, h, b));
    }
    var kv = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], IE = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(kv));
    function Z2(i, o, d) {
      var h = i.type || "unknown-event";
      i.currentTarget = d, ol(h, o, void 0, i), i.currentTarget = null;
    }
    function l6(i, o, d) {
      var h;
      if (d)
        for (var b = o.length - 1; b >= 0; b--) {
          var C = o[b], R = C.instance, A = C.currentTarget, B = C.listener;
          if (R !== h && i.isPropagationStopped())
            return;
          Z2(i, B, A), h = R;
        }
      else
        for (var V = 0; V < o.length; V++) {
          var G = o[V], ae = G.instance, ne = G.currentTarget, Ce = G.listener;
          if (ae !== h && i.isPropagationStopped())
            return;
          Z2(i, Ce, ne), h = ae;
        }
    }
    function J2(i, o) {
      for (var d = (o & Fc) !== 0, h = 0; h < i.length; h++) {
        var b = i[h], C = b.event, R = b.listeners;
        l6(C, R, d);
      }
      Lm();
    }
    function c6(i, o, d, h, b) {
      var C = qp(d), R = [];
      s6(R, i, h, d, C, o), J2(R, o);
    }
    function Nr(i, o) {
      IE.has(i) || c('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', i);
      var d = !1, h = zU(o), b = p6(i, d);
      h.has(b) || (eR(o, i, bf, d), h.add(b));
    }
    function RE(i, o, d) {
      IE.has(i) && !o && c('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', i);
      var h = 0;
      o && (h |= Fc), eR(d, i, h, o);
    }
    var W0 = "_reactListening" + Math.random().toString(36).slice(2);
    function Pv(i) {
      if (!i[W0]) {
        i[W0] = !0, ke.forEach(function(d) {
          d !== "selectionchange" && (IE.has(d) || RE(d, !1, i), RE(d, !0, i));
        });
        var o = i.nodeType === Ja ? i : i.ownerDocument;
        o !== null && (o[W0] || (o[W0] = !0, RE("selectionchange", !1, o)));
      }
    }
    function eR(i, o, d, h, b) {
      var C = dd(i, o, d), R = void 0;
      Cf && (o === "touchstart" || o === "touchmove" || o === "wheel") && (R = !0), i = i, h ? R !== void 0 ? pl(i, o, C, R) : pd(i, o, C) : R !== void 0 ? Nh(i, o, C, R) : hv(i, o, C);
    }
    function tR(i, o) {
      return i === o || i.nodeType === ni && i.parentNode === o;
    }
    function $E(i, o, d, h, b) {
      var C = h;
      if (!(o & rl) && !(o & bf)) {
        var R = b;
        if (h !== null) {
          var A = h;
          e:
            for (; ; ) {
              if (A === null)
                return;
              var B = A.tag;
              if (B === v || B === S) {
                var V = A.stateNode.containerInfo;
                if (tR(V, R))
                  break;
                if (B === S)
                  for (var G = A.return; G !== null; ) {
                    var ae = G.tag;
                    if (ae === v || ae === S) {
                      var ne = G.stateNode.containerInfo;
                      if (tR(ne, R))
                        return;
                    }
                    G = G.return;
                  }
                for (; V !== null; ) {
                  var Ce = Qf(V);
                  if (Ce === null)
                    return;
                  var _e = Ce.tag;
                  if (_e === x || _e === _) {
                    A = C = Ce;
                    continue e;
                  }
                  V = V.parentNode;
                }
              }
              A = A.return;
            }
        }
      }
      Am(function() {
        return c6(i, o, d, C);
      });
    }
    function Iv(i, o, d) {
      return {
        instance: i,
        listener: o,
        currentTarget: d
      };
    }
    function u6(i, o, d, h, b, C) {
      for (var R = o !== null ? o + "Capture" : null, A = h ? R : o, B = [], V = i, G = null; V !== null; ) {
        var ae = V, ne = ae.stateNode, Ce = ae.tag;
        if (Ce === x && ne !== null && (G = ne, A !== null)) {
          var _e = Vc(V, A);
          _e != null && B.push(Iv(V, _e, G));
        }
        if (b)
          break;
        V = V.return;
      }
      return B;
    }
    function G0(i, o) {
      for (var d = o + "Capture", h = [], b = i; b !== null; ) {
        var C = b, R = C.stateNode, A = C.tag;
        if (A === x && R !== null) {
          var B = R, V = Vc(b, d);
          V != null && h.unshift(Iv(b, V, B));
          var G = Vc(b, o);
          G != null && h.push(Iv(b, G, B));
        }
        b = b.return;
      }
      return h;
    }
    function Qh(i) {
      if (i === null)
        return null;
      do
        i = i.return;
      while (i && i.tag !== x);
      return i || null;
    }
    function d6(i, o) {
      for (var d = i, h = o, b = 0, C = d; C; C = Qh(C))
        b++;
      for (var R = 0, A = h; A; A = Qh(A))
        R++;
      for (; b - R > 0; )
        d = Qh(d), b--;
      for (; R - b > 0; )
        h = Qh(h), R--;
      for (var B = b; B--; ) {
        if (d === h || h !== null && d === h.alternate)
          return d;
        d = Qh(d), h = Qh(h);
      }
      return null;
    }
    function nR(i, o, d, h, b) {
      for (var C = o._reactName, R = [], A = d; A !== null && A !== h; ) {
        var B = A, V = B.alternate, G = B.stateNode, ae = B.tag;
        if (V !== null && V === h)
          break;
        if (ae === x && G !== null) {
          var ne = G;
          if (b) {
            var Ce = Vc(A, C);
            Ce != null && R.unshift(Iv(A, Ce, ne));
          } else if (!b) {
            var _e = Vc(A, C);
            _e != null && R.push(Iv(A, _e, ne));
          }
        }
        A = A.return;
      }
      R.length !== 0 && i.push({
        event: o,
        listeners: R
      });
    }
    function f6(i, o, d, h, b) {
      var C = h && b ? d6(h, b) : null;
      h !== null && nR(i, o, h, C, !1), b !== null && d !== null && nR(i, d, b, C, !0);
    }
    function p6(i, o) {
      return i + "__" + (o ? "capture" : "bubble");
    }
    var Da = !1, Rv = "dangerouslySetInnerHTML", X0 = "suppressContentEditableWarning", Sd = "suppressHydrationWarning", rR = "autoFocus", Xf = "children", qf = "style", q0 = "__html", ME, Q0, $v, iR, Z0, oR, aR;
    ME = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, Q0 = function(i, o) {
      Xp(i, o), Pm(i, o), a0(i, o, {
        registrationNameDependencies: rt,
        possibleRegistrationNames: St
      });
    }, oR = Nt && !document.documentMode, $v = function(i, o, d) {
      if (!Da) {
        var h = J0(d), b = J0(o);
        b !== h && (Da = !0, c("Prop `%s` did not match. Server: %s Client: %s", i, JSON.stringify(b), JSON.stringify(h)));
      }
    }, iR = function(i) {
      if (!Da) {
        Da = !0;
        var o = [];
        i.forEach(function(d) {
          o.push(d);
        }), c("Extra attributes from the server: %s", o);
      }
    }, Z0 = function(i, o) {
      o === !1 ? c("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", i, i, i) : c("Expected `%s` listener to be a function, instead got a value of `%s` type.", i, typeof o);
    }, aR = function(i, o) {
      var d = i.namespaceURI === el ? i.ownerDocument.createElement(i.tagName) : i.ownerDocument.createElementNS(i.namespaceURI, i.tagName);
      return d.innerHTML = o, d.innerHTML;
    };
    var h6 = /\r\n?/g, g6 = /\u0000|\uFFFD/g;
    function J0(i) {
      zr(i);
      var o = typeof i == "string" ? i : "" + i;
      return o.replace(h6, `
`).replace(g6, "");
    }
    function eS(i, o, d, h) {
      var b = J0(o), C = J0(i);
      if (C !== b && (h && (Da || (Da = !0, c('Text content did not match. Server: "%s" Client: "%s"', C, b))), d && he))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function sR(i) {
      return i.nodeType === Ja ? i : i.ownerDocument;
    }
    function m6() {
    }
    function tS(i) {
      i.onclick = m6;
    }
    function v6(i, o, d, h, b) {
      for (var C in h)
        if (h.hasOwnProperty(C)) {
          var R = h[C];
          if (C === qf)
            R && Object.freeze(R), qb(o, R);
          else if (C === Rv) {
            var A = R ? R[q0] : void 0;
            A != null && zb(o, A);
          } else if (C === Xf)
            if (typeof R == "string") {
              var B = i !== "textarea" || R !== "";
              B && Yp(o, R);
            } else
              typeof R == "number" && Yp(o, "" + R);
          else
            C === X0 || C === Sd || C === rR || (rt.hasOwnProperty(C) ? R != null && (typeof R != "function" && Z0(C, R), C === "onScroll" && Nr("scroll", o)) : R != null && so(o, C, R, b));
        }
    }
    function y6(i, o, d, h) {
      for (var b = 0; b < o.length; b += 2) {
        var C = o[b], R = o[b + 1];
        C === qf ? qb(i, R) : C === Rv ? zb(i, R) : C === Xf ? Yp(i, R) : so(i, C, R, h);
      }
    }
    function b6(i, o, d, h) {
      var b, C = sR(d), R, A = h;
      if (A === el && (A = Hp(i)), A === el) {
        if (b = nl(i, o), !b && i !== i.toLowerCase() && c("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", i), i === "script") {
          var B = C.createElement("div");
          B.innerHTML = "<script><\/script>";
          var V = B.firstChild;
          R = B.removeChild(V);
        } else if (typeof o.is == "string")
          R = C.createElement(i, {
            is: o.is
          });
        else if (R = C.createElement(i), i === "select") {
          var G = R;
          o.multiple ? G.multiple = !0 : o.size && (G.size = o.size);
        }
      } else
        R = C.createElementNS(A, i);
      return A === el && !b && Object.prototype.toString.call(R) === "[object HTMLUnknownElement]" && !Ke.call(ME, i) && (ME[i] = !0, c("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", i)), R;
    }
    function S6(i, o) {
      return sR(o).createTextNode(i);
    }
    function w6(i, o, d, h) {
      var b = nl(o, d);
      Q0(o, d);
      var C;
      switch (o) {
        case "dialog":
          Nr("cancel", i), Nr("close", i), C = d;
          break;
        case "iframe":
        case "object":
        case "embed":
          Nr("load", i), C = d;
          break;
        case "video":
        case "audio":
          for (var R = 0; R < kv.length; R++)
            Nr(kv[R], i);
          C = d;
          break;
        case "source":
          Nr("error", i), C = d;
          break;
        case "img":
        case "image":
        case "link":
          Nr("error", i), Nr("load", i), C = d;
          break;
        case "details":
          Nr("toggle", i), C = d;
          break;
        case "input":
          Z(i, d), C = U(i, d), Nr("invalid", i);
          break;
        case "option":
          In(i, d), C = d;
          break;
        case "select":
          gf(i, d), C = hf(i, d), Nr("invalid", i);
          break;
        case "textarea":
          Nb(i, d), C = bm(i, d), Nr("invalid", i);
          break;
        default:
          C = d;
      }
      switch (Wp(o, C), v6(o, i, h, C, b), o) {
        case "input":
          ie(i), Fe(i, d, !1);
          break;
        case "textarea":
          ie(i), jb(i);
          break;
        case "option":
          ar(i, d);
          break;
        case "select":
          vm(i, d);
          break;
        default:
          typeof C.onClick == "function" && tS(i);
          break;
      }
    }
    function x6(i, o, d, h, b) {
      Q0(o, h);
      var C = null, R, A;
      switch (o) {
        case "input":
          R = U(i, d), A = U(i, h), C = [];
          break;
        case "select":
          R = hf(i, d), A = hf(i, h), C = [];
          break;
        case "textarea":
          R = bm(i, d), A = bm(i, h), C = [];
          break;
        default:
          R = d, A = h, typeof R.onClick != "function" && typeof A.onClick == "function" && tS(i);
          break;
      }
      Wp(o, A);
      var B, V, G = null;
      for (B in R)
        if (!(A.hasOwnProperty(B) || !R.hasOwnProperty(B) || R[B] == null))
          if (B === qf) {
            var ae = R[B];
            for (V in ae)
              ae.hasOwnProperty(V) && (G || (G = {}), G[V] = "");
          } else
            B === Rv || B === Xf || B === X0 || B === Sd || B === rR || (rt.hasOwnProperty(B) ? C || (C = []) : (C = C || []).push(B, null));
      for (B in A) {
        var ne = A[B], Ce = R?.[B];
        if (!(!A.hasOwnProperty(B) || ne === Ce || ne == null && Ce == null))
          if (B === qf)
            if (ne && Object.freeze(ne), Ce) {
              for (V in Ce)
                Ce.hasOwnProperty(V) && (!ne || !ne.hasOwnProperty(V)) && (G || (G = {}), G[V] = "");
              for (V in ne)
                ne.hasOwnProperty(V) && Ce[V] !== ne[V] && (G || (G = {}), G[V] = ne[V]);
            } else
              G || (C || (C = []), C.push(B, G)), G = ne;
          else if (B === Rv) {
            var _e = ne ? ne[q0] : void 0, Ae = Ce ? Ce[q0] : void 0;
            _e != null && Ae !== _e && (C = C || []).push(B, _e);
          } else
            B === Xf ? (typeof ne == "string" || typeof ne == "number") && (C = C || []).push(B, "" + ne) : B === X0 || B === Sd || (rt.hasOwnProperty(B) ? (ne != null && (typeof ne != "function" && Z0(B, ne), B === "onScroll" && Nr("scroll", i)), !C && Ce !== ne && (C = [])) : (C = C || []).push(B, ne));
      }
      return G && (vf(G, A[qf]), (C = C || []).push(qf, G)), C;
    }
    function E6(i, o, d, h, b) {
      d === "input" && b.type === "radio" && b.name != null && ye(i, b);
      var C = nl(d, h), R = nl(d, b);
      switch (y6(i, o, C, R), d) {
        case "input":
          Ee(i, b);
          break;
        case "textarea":
          Lb(i, b);
          break;
        case "select":
          V1(i, b);
          break;
      }
    }
    function C6(i) {
      {
        var o = i.toLowerCase();
        return Gp.hasOwnProperty(o) && Gp[o] || null;
      }
    }
    function _6(i, o, d, h, b, C, R) {
      var A, B;
      switch (A = nl(o, d), Q0(o, d), o) {
        case "dialog":
          Nr("cancel", i), Nr("close", i);
          break;
        case "iframe":
        case "object":
        case "embed":
          Nr("load", i);
          break;
        case "video":
        case "audio":
          for (var V = 0; V < kv.length; V++)
            Nr(kv[V], i);
          break;
        case "source":
          Nr("error", i);
          break;
        case "img":
        case "image":
        case "link":
          Nr("error", i), Nr("load", i);
          break;
        case "details":
          Nr("toggle", i);
          break;
        case "input":
          Z(i, d), Nr("invalid", i);
          break;
        case "option":
          In(i, d);
          break;
        case "select":
          gf(i, d), Nr("invalid", i);
          break;
        case "textarea":
          Nb(i, d), Nr("invalid", i);
          break;
      }
      Wp(o, d);
      {
        B = /* @__PURE__ */ new Set();
        for (var G = i.attributes, ae = 0; ae < G.length; ae++) {
          var ne = G[ae].name.toLowerCase();
          switch (ne) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              B.add(G[ae].name);
          }
        }
      }
      var Ce = null;
      for (var _e in d)
        if (d.hasOwnProperty(_e)) {
          var Ae = d[_e];
          if (_e === Xf)
            typeof Ae == "string" ? i.textContent !== Ae && (d[Sd] !== !0 && eS(i.textContent, Ae, C, R), Ce = [Xf, Ae]) : typeof Ae == "number" && i.textContent !== "" + Ae && (d[Sd] !== !0 && eS(i.textContent, Ae, C, R), Ce = [Xf, "" + Ae]);
          else if (rt.hasOwnProperty(_e))
            Ae != null && (typeof Ae != "function" && Z0(_e, Ae), _e === "onScroll" && Nr("scroll", i));
          else if (R && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof A == "boolean") {
            var ut = void 0, Ot = A && xe ? null : gi(_e);
            if (d[Sd] !== !0) {
              if (!(_e === X0 || _e === Sd || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              _e === "value" || _e === "checked" || _e === "selected")) {
                if (_e === Rv) {
                  var Pt = i.innerHTML, _n = Ae ? Ae[q0] : void 0;
                  if (_n != null) {
                    var vn = aR(i, _n);
                    vn !== Pt && $v(_e, Pt, vn);
                  }
                } else if (_e === qf) {
                  if (B.delete(_e), oR) {
                    var be = Z1(Ae);
                    ut = i.getAttribute("style"), be !== ut && $v(_e, ut, be);
                  }
                } else if (A && !xe)
                  B.delete(_e.toLowerCase()), ut = ba(i, _e, Ae), Ae !== ut && $v(_e, ut, Ae);
                else if (!ur(_e, Ot, A) && !pn(_e, Ae, Ot, A)) {
                  var Oe = !1;
                  if (Ot !== null)
                    B.delete(Ot.attributeName), ut = ao(i, _e, Ae, Ot);
                  else {
                    var Se = h;
                    if (Se === el && (Se = Hp(o)), Se === el)
                      B.delete(_e.toLowerCase());
                    else {
                      var We = C6(_e);
                      We !== null && We !== _e && (Oe = !0, B.delete(We)), B.delete(_e);
                    }
                    ut = ba(i, _e, Ae);
                  }
                  var dt = xe;
                  !dt && Ae !== ut && !Oe && $v(_e, ut, Ae);
                }
              }
            }
          }
        }
      switch (R && // $FlowFixMe - Should be inferred as not undefined.
      B.size > 0 && d[Sd] !== !0 && iR(B), o) {
        case "input":
          ie(i), Fe(i, d, !0);
          break;
        case "textarea":
          ie(i), jb(i);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof d.onClick == "function" && tS(i);
          break;
      }
      return Ce;
    }
    function T6(i, o, d) {
      var h = i.nodeValue !== o;
      return h;
    }
    function AE(i, o) {
      {
        if (Da)
          return;
        Da = !0, c("Did not expect server HTML to contain a <%s> in <%s>.", o.nodeName.toLowerCase(), i.nodeName.toLowerCase());
      }
    }
    function OE(i, o) {
      {
        if (Da)
          return;
        Da = !0, c('Did not expect server HTML to contain the text node "%s" in <%s>.', o.nodeValue, i.nodeName.toLowerCase());
      }
    }
    function DE(i, o, d) {
      {
        if (Da)
          return;
        Da = !0, c("Expected server HTML to contain a matching <%s> in <%s>.", o, i.nodeName.toLowerCase());
      }
    }
    function NE(i, o) {
      {
        if (o === "" || Da)
          return;
        Da = !0, c('Expected server HTML to contain a matching text node for "%s" in <%s>.', o, i.nodeName.toLowerCase());
      }
    }
    function k6(i, o, d) {
      switch (o) {
        case "input":
          ht(i, d);
          return;
        case "textarea":
          Sm(i, d);
          return;
        case "select":
          Y1(i, d);
          return;
      }
    }
    var Mv = function() {
    }, Av = function() {
    };
    {
      var P6 = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], lR = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], I6 = lR.concat(["button"]), R6 = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], cR = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      Av = function(i, o) {
        var d = Jt({}, i || cR), h = {
          tag: o
        };
        return lR.indexOf(o) !== -1 && (d.aTagInScope = null, d.buttonTagInScope = null, d.nobrTagInScope = null), I6.indexOf(o) !== -1 && (d.pTagInButtonScope = null), P6.indexOf(o) !== -1 && o !== "address" && o !== "div" && o !== "p" && (d.listItemTagAutoclosing = null, d.dlItemTagAutoclosing = null), d.current = h, o === "form" && (d.formTag = h), o === "a" && (d.aTagInScope = h), o === "button" && (d.buttonTagInScope = h), o === "nobr" && (d.nobrTagInScope = h), o === "p" && (d.pTagInButtonScope = h), o === "li" && (d.listItemTagAutoclosing = h), (o === "dd" || o === "dt") && (d.dlItemTagAutoclosing = h), d;
      };
      var $6 = function(i, o) {
        switch (o) {
          case "select":
            return i === "option" || i === "optgroup" || i === "#text";
          case "optgroup":
            return i === "option" || i === "#text";
          case "option":
            return i === "#text";
          case "tr":
            return i === "th" || i === "td" || i === "style" || i === "script" || i === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return i === "tr" || i === "style" || i === "script" || i === "template";
          case "colgroup":
            return i === "col" || i === "template";
          case "table":
            return i === "caption" || i === "colgroup" || i === "tbody" || i === "tfoot" || i === "thead" || i === "style" || i === "script" || i === "template";
          case "head":
            return i === "base" || i === "basefont" || i === "bgsound" || i === "link" || i === "meta" || i === "title" || i === "noscript" || i === "noframes" || i === "style" || i === "script" || i === "template";
          case "html":
            return i === "head" || i === "body" || i === "frameset";
          case "frameset":
            return i === "frame";
          case "#document":
            return i === "html";
        }
        switch (i) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return o !== "h1" && o !== "h2" && o !== "h3" && o !== "h4" && o !== "h5" && o !== "h6";
          case "rp":
          case "rt":
            return R6.indexOf(o) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return o == null;
        }
        return !0;
      }, M6 = function(i, o) {
        switch (i) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return o.pTagInButtonScope;
          case "form":
            return o.formTag || o.pTagInButtonScope;
          case "li":
            return o.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return o.dlItemTagAutoclosing;
          case "button":
            return o.buttonTagInScope;
          case "a":
            return o.aTagInScope;
          case "nobr":
            return o.nobrTagInScope;
        }
        return null;
      }, uR = {};
      Mv = function(i, o, d) {
        d = d || cR;
        var h = d.current, b = h && h.tag;
        o != null && (i != null && c("validateDOMNesting: when childText is passed, childTag should be null"), i = "#text");
        var C = $6(i, b) ? null : h, R = C ? null : M6(i, d), A = C || R;
        if (A) {
          var B = A.tag, V = !!C + "|" + i + "|" + B;
          if (!uR[V]) {
            uR[V] = !0;
            var G = i, ae = "";
            if (i === "#text" ? /\S/.test(o) ? G = "Text nodes" : (G = "Whitespace text nodes", ae = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : G = "<" + i + ">", C) {
              var ne = "";
              B === "table" && i === "tr" && (ne += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), c("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", G, B, ae, ne);
            } else
              c("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", G, B);
          }
        }
      };
    }
    var nS = "suppressHydrationWarning", rS = "$", iS = "/$", Ov = "$?", Dv = "$!", A6 = "style", LE = null, jE = null;
    function O6(i) {
      var o, d, h = i.nodeType;
      switch (h) {
        case Ja:
        case Uc: {
          o = h === Ja ? "#document" : "#fragment";
          var b = i.documentElement;
          d = b ? b.namespaceURI : xm(null, "");
          break;
        }
        default: {
          var C = h === ni ? i.parentNode : i, R = C.namespaceURI || null;
          o = C.tagName, d = xm(R, o);
          break;
        }
      }
      {
        var A = o.toLowerCase(), B = Av(null, A);
        return {
          namespace: d,
          ancestorInfo: B
        };
      }
    }
    function D6(i, o, d) {
      {
        var h = i, b = xm(h.namespace, o), C = Av(h.ancestorInfo, o);
        return {
          namespace: b,
          ancestorInfo: C
        };
      }
    }
    function Tpe(i) {
      return i;
    }
    function N6(i) {
      LE = na(), jE = q5();
      var o = null;
      return _i(!1), o;
    }
    function L6(i) {
      Q5(jE), _i(LE), LE = null, jE = null;
    }
    function j6(i, o, d, h, b) {
      var C;
      {
        var R = h;
        if (Mv(i, null, R.ancestorInfo), typeof o.children == "string" || typeof o.children == "number") {
          var A = "" + o.children, B = Av(R.ancestorInfo, i);
          Mv(null, A, B);
        }
        C = R.namespace;
      }
      var V = b6(i, o, d, C);
      return jv(b, V), KE(V, o), V;
    }
    function z6(i, o) {
      i.appendChild(o);
    }
    function U6(i, o, d, h, b) {
      switch (w6(i, o, d, h), o) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!d.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function B6(i, o, d, h, b, C) {
      {
        var R = C;
        if (typeof h.children != typeof d.children && (typeof h.children == "string" || typeof h.children == "number")) {
          var A = "" + h.children, B = Av(R.ancestorInfo, o);
          Mv(null, A, B);
        }
      }
      return x6(i, o, d, h);
    }
    function zE(i, o) {
      return i === "textarea" || i === "noscript" || typeof o.children == "string" || typeof o.children == "number" || typeof o.dangerouslySetInnerHTML == "object" && o.dangerouslySetInnerHTML !== null && o.dangerouslySetInnerHTML.__html != null;
    }
    function F6(i, o, d, h) {
      {
        var b = d;
        Mv(null, i, b.ancestorInfo);
      }
      var C = S6(i, o);
      return jv(h, C), C;
    }
    function H6() {
      var i = window.event;
      return i === void 0 ? ul : uo(i.type);
    }
    var UE = typeof setTimeout == "function" ? setTimeout : void 0, V6 = typeof clearTimeout == "function" ? clearTimeout : void 0, BE = -1, dR = typeof Promise == "function" ? Promise : void 0, Y6 = typeof queueMicrotask == "function" ? queueMicrotask : typeof dR < "u" ? function(i) {
      return dR.resolve(null).then(i).catch(K6);
    } : UE;
    function K6(i) {
      setTimeout(function() {
        throw i;
      });
    }
    function W6(i, o, d, h) {
      switch (o) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          d.autoFocus && i.focus();
          return;
        case "img": {
          d.src && (i.src = d.src);
          return;
        }
      }
    }
    function G6(i, o, d, h, b, C) {
      E6(i, o, d, h, b), KE(i, b);
    }
    function fR(i) {
      Yp(i, "");
    }
    function X6(i, o, d) {
      i.nodeValue = d;
    }
    function q6(i, o) {
      i.appendChild(o);
    }
    function Q6(i, o) {
      var d;
      i.nodeType === ni ? (d = i.parentNode, d.insertBefore(o, i)) : (d = i, d.appendChild(o));
      var h = i._reactRootContainer;
      h == null && d.onclick === null && tS(d);
    }
    function Z6(i, o, d) {
      i.insertBefore(o, d);
    }
    function J6(i, o, d) {
      i.nodeType === ni ? i.parentNode.insertBefore(o, d) : i.insertBefore(o, d);
    }
    function eU(i, o) {
      i.removeChild(o);
    }
    function tU(i, o) {
      i.nodeType === ni ? i.parentNode.removeChild(o) : i.removeChild(o);
    }
    function FE(i, o) {
      var d = o, h = 0;
      do {
        var b = d.nextSibling;
        if (i.removeChild(d), b && b.nodeType === ni) {
          var C = b.data;
          if (C === iS)
            if (h === 0) {
              i.removeChild(b), mn(o);
              return;
            } else
              h--;
          else
            (C === rS || C === Ov || C === Dv) && h++;
        }
        d = b;
      } while (d);
      mn(o);
    }
    function nU(i, o) {
      i.nodeType === ni ? FE(i.parentNode, o) : i.nodeType === Io && FE(i, o), mn(i);
    }
    function rU(i) {
      i = i;
      var o = i.style;
      typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none";
    }
    function iU(i) {
      i.nodeValue = "";
    }
    function oU(i, o) {
      i = i;
      var d = o[A6], h = d != null && d.hasOwnProperty("display") ? d.display : null;
      i.style.display = Kp("display", h);
    }
    function aU(i, o) {
      i.nodeValue = o;
    }
    function sU(i) {
      i.nodeType === Io ? i.textContent = "" : i.nodeType === Ja && i.documentElement && i.removeChild(i.documentElement);
    }
    function lU(i, o, d) {
      return i.nodeType !== Io || o.toLowerCase() !== i.nodeName.toLowerCase() ? null : i;
    }
    function cU(i, o) {
      return o === "" || i.nodeType !== tl ? null : i;
    }
    function uU(i) {
      return i.nodeType !== ni ? null : i;
    }
    function pR(i) {
      return i.data === Ov;
    }
    function HE(i) {
      return i.data === Dv;
    }
    function dU(i) {
      var o = i.nextSibling && i.nextSibling.dataset, d, h, b;
      return o && (d = o.dgst, h = o.msg, b = o.stck), {
        message: h,
        digest: d,
        stack: b
      };
    }
    function fU(i, o) {
      i._reactRetry = o;
    }
    function oS(i) {
      for (; i != null; i = i.nextSibling) {
        var o = i.nodeType;
        if (o === Io || o === tl)
          break;
        if (o === ni) {
          var d = i.data;
          if (d === rS || d === Dv || d === Ov)
            break;
          if (d === iS)
            return null;
        }
      }
      return i;
    }
    function Nv(i) {
      return oS(i.nextSibling);
    }
    function pU(i) {
      return oS(i.firstChild);
    }
    function hU(i) {
      return oS(i.firstChild);
    }
    function gU(i) {
      return oS(i.nextSibling);
    }
    function mU(i, o, d, h, b, C, R) {
      jv(C, i), KE(i, d);
      var A;
      {
        var B = b;
        A = B.namespace;
      }
      var V = (C.mode & fn) !== Dt;
      return _6(i, o, d, A, h, V, R);
    }
    function vU(i, o, d, h) {
      return jv(d, i), d.mode & fn, T6(i, o);
    }
    function yU(i, o) {
      jv(o, i);
    }
    function bU(i) {
      for (var o = i.nextSibling, d = 0; o; ) {
        if (o.nodeType === ni) {
          var h = o.data;
          if (h === iS) {
            if (d === 0)
              return Nv(o);
            d--;
          } else
            (h === rS || h === Dv || h === Ov) && d++;
        }
        o = o.nextSibling;
      }
      return null;
    }
    function hR(i) {
      for (var o = i.previousSibling, d = 0; o; ) {
        if (o.nodeType === ni) {
          var h = o.data;
          if (h === rS || h === Dv || h === Ov) {
            if (d === 0)
              return o;
            d--;
          } else
            h === iS && d++;
        }
        o = o.previousSibling;
      }
      return null;
    }
    function SU(i) {
      mn(i);
    }
    function wU(i) {
      mn(i);
    }
    function xU(i) {
      return i !== "head" && i !== "body";
    }
    function EU(i, o, d, h) {
      var b = !0;
      eS(o.nodeValue, d, h, b);
    }
    function CU(i, o, d, h, b, C) {
      if (o[nS] !== !0) {
        var R = !0;
        eS(h.nodeValue, b, C, R);
      }
    }
    function _U(i, o) {
      o.nodeType === Io ? AE(i, o) : o.nodeType === ni || OE(i, o);
    }
    function TU(i, o) {
      {
        var d = i.parentNode;
        d !== null && (o.nodeType === Io ? AE(d, o) : o.nodeType === ni || OE(d, o));
      }
    }
    function kU(i, o, d, h, b) {
      (b || o[nS] !== !0) && (h.nodeType === Io ? AE(d, h) : h.nodeType === ni || OE(d, h));
    }
    function PU(i, o, d) {
      DE(i, o);
    }
    function IU(i, o) {
      NE(i, o);
    }
    function RU(i, o, d) {
      {
        var h = i.parentNode;
        h !== null && DE(h, o);
      }
    }
    function $U(i, o) {
      {
        var d = i.parentNode;
        d !== null && NE(d, o);
      }
    }
    function MU(i, o, d, h, b, C) {
      (C || o[nS] !== !0) && DE(d, h);
    }
    function AU(i, o, d, h, b) {
      (b || o[nS] !== !0) && NE(d, h);
    }
    function OU(i) {
      c("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", i.nodeName.toLowerCase());
    }
    function DU(i) {
      Pv(i);
    }
    var Zh = Math.random().toString(36).slice(2), Jh = "__reactFiber$" + Zh, VE = "__reactProps$" + Zh, Lv = "__reactContainer$" + Zh, YE = "__reactEvents$" + Zh, NU = "__reactListeners$" + Zh, LU = "__reactHandles$" + Zh;
    function jU(i) {
      delete i[Jh], delete i[VE], delete i[YE], delete i[NU], delete i[LU];
    }
    function jv(i, o) {
      o[Jh] = i;
    }
    function aS(i, o) {
      o[Lv] = i;
    }
    function gR(i) {
      i[Lv] = null;
    }
    function zv(i) {
      return !!i[Lv];
    }
    function Qf(i) {
      var o = i[Jh];
      if (o)
        return o;
      for (var d = i.parentNode; d; ) {
        if (o = d[Lv] || d[Jh], o) {
          var h = o.alternate;
          if (o.child !== null || h !== null && h.child !== null)
            for (var b = hR(i); b !== null; ) {
              var C = b[Jh];
              if (C)
                return C;
              b = hR(b);
            }
          return o;
        }
        i = d, d = i.parentNode;
      }
      return null;
    }
    function wd(i) {
      var o = i[Jh] || i[Lv];
      return o && (o.tag === x || o.tag === _ || o.tag === z || o.tag === v) ? o : null;
    }
    function eg(i) {
      if (i.tag === x || i.tag === _)
        return i.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function sS(i) {
      return i[VE] || null;
    }
    function KE(i, o) {
      i[VE] = o;
    }
    function zU(i) {
      var o = i[YE];
      return o === void 0 && (o = i[YE] = /* @__PURE__ */ new Set()), o;
    }
    var mR = {}, vR = n.ReactDebugCurrentFrame;
    function lS(i) {
      if (i) {
        var o = i._owner, d = Go(i.type, i._source, o ? o.type : null);
        vR.setExtraStackFrame(d);
      } else
        vR.setExtraStackFrame(null);
    }
    function gl(i, o, d, h, b) {
      {
        var C = Function.call.bind(Ke);
        for (var R in i)
          if (C(i, R)) {
            var A = void 0;
            try {
              if (typeof i[R] != "function") {
                var B = Error((h || "React class") + ": " + d + " type `" + R + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[R] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw B.name = "Invariant Violation", B;
              }
              A = i[R](o, R, h, d, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (V) {
              A = V;
            }
            A && !(A instanceof Error) && (lS(b), c("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", h || "React class", d, R, typeof A), lS(null)), A instanceof Error && !(A.message in mR) && (mR[A.message] = !0, lS(b), c("Failed %s type: %s", d, A.message), lS(null));
          }
      }
    }
    var WE = [], cS;
    cS = [];
    var hu = -1;
    function xd(i) {
      return {
        current: i
      };
    }
    function jo(i, o) {
      if (hu < 0) {
        c("Unexpected pop.");
        return;
      }
      o !== cS[hu] && c("Unexpected Fiber popped."), i.current = WE[hu], WE[hu] = null, cS[hu] = null, hu--;
    }
    function zo(i, o, d) {
      hu++, WE[hu] = i.current, cS[hu] = d, i.current = o;
    }
    var GE;
    GE = {};
    var is = {};
    Object.freeze(is);
    var gu = xd(is), cc = xd(!1), XE = is;
    function tg(i, o, d) {
      return d && uc(o) ? XE : gu.current;
    }
    function yR(i, o, d) {
      {
        var h = i.stateNode;
        h.__reactInternalMemoizedUnmaskedChildContext = o, h.__reactInternalMemoizedMaskedChildContext = d;
      }
    }
    function ng(i, o) {
      {
        var d = i.type, h = d.contextTypes;
        if (!h)
          return is;
        var b = i.stateNode;
        if (b && b.__reactInternalMemoizedUnmaskedChildContext === o)
          return b.__reactInternalMemoizedMaskedChildContext;
        var C = {};
        for (var R in h)
          C[R] = o[R];
        {
          var A = Ft(i) || "Unknown";
          gl(h, C, "context", A);
        }
        return b && yR(i, o, C), C;
      }
    }
    function uS() {
      return cc.current;
    }
    function uc(i) {
      {
        var o = i.childContextTypes;
        return o != null;
      }
    }
    function dS(i) {
      jo(cc, i), jo(gu, i);
    }
    function qE(i) {
      jo(cc, i), jo(gu, i);
    }
    function bR(i, o, d) {
      {
        if (gu.current !== is)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        zo(gu, o, i), zo(cc, d, i);
      }
    }
    function SR(i, o, d) {
      {
        var h = i.stateNode, b = o.childContextTypes;
        if (typeof h.getChildContext != "function") {
          {
            var C = Ft(i) || "Unknown";
            GE[C] || (GE[C] = !0, c("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", C, C));
          }
          return d;
        }
        var R = h.getChildContext();
        for (var A in R)
          if (!(A in b))
            throw new Error((Ft(i) || "Unknown") + '.getChildContext(): key "' + A + '" is not defined in childContextTypes.');
        {
          var B = Ft(i) || "Unknown";
          gl(b, R, "child context", B);
        }
        return Jt({}, d, R);
      }
    }
    function fS(i) {
      {
        var o = i.stateNode, d = o && o.__reactInternalMemoizedMergedChildContext || is;
        return XE = gu.current, zo(gu, d, i), zo(cc, cc.current, i), !0;
      }
    }
    function wR(i, o, d) {
      {
        var h = i.stateNode;
        if (!h)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (d) {
          var b = SR(i, o, XE);
          h.__reactInternalMemoizedMergedChildContext = b, jo(cc, i), jo(gu, i), zo(gu, b, i), zo(cc, d, i);
        } else
          jo(cc, i), zo(cc, d, i);
      }
    }
    function UU(i) {
      {
        if (!Fm(i) || i.tag !== g)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var o = i;
        do {
          switch (o.tag) {
            case v:
              return o.stateNode.context;
            case g: {
              var d = o.type;
              if (uc(d))
                return o.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          o = o.return;
        } while (o !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Ed = 0, pS = 1, mu = null, QE = !1, ZE = !1;
    function xR(i) {
      mu === null ? mu = [i] : mu.push(i);
    }
    function BU(i) {
      QE = !0, xR(i);
    }
    function ER() {
      QE && Cd();
    }
    function Cd() {
      if (!ZE && mu !== null) {
        ZE = !0;
        var i = 0, o = $a();
        try {
          var d = !0, h = mu;
          for (li(Xi); i < h.length; i++) {
            var b = h[i];
            do
              b = b(d);
            while (b !== null);
          }
          mu = null, QE = !1;
        } catch (C) {
          throw mu !== null && (mu = mu.slice(i + 1)), rh(oh, Cd), C;
        } finally {
          li(o), ZE = !1;
        }
      }
      return null;
    }
    var rg = [], ig = 0, hS = null, gS = 0, $s = [], Ms = 0, Zf = null, vu = 1, yu = "";
    function FU(i) {
      return ep(), (i.flags & zm) !== Mt;
    }
    function HU(i) {
      return ep(), gS;
    }
    function VU() {
      var i = yu, o = vu, d = o & ~YU(o);
      return d.toString(32) + i;
    }
    function Jf(i, o) {
      ep(), rg[ig++] = gS, rg[ig++] = hS, hS = i, gS = o;
    }
    function CR(i, o, d) {
      ep(), $s[Ms++] = vu, $s[Ms++] = yu, $s[Ms++] = Zf, Zf = i;
      var h = vu, b = yu, C = mS(h) - 1, R = h & ~(1 << C), A = d + 1, B = mS(o) + C;
      if (B > 30) {
        var V = C - C % 5, G = (1 << V) - 1, ae = (R & G).toString(32), ne = R >> V, Ce = C - V, _e = mS(o) + Ce, Ae = A << Ce, ut = Ae | ne, Ot = ae + b;
        vu = 1 << _e | ut, yu = Ot;
      } else {
        var Pt = A << C, _n = Pt | R, vn = b;
        vu = 1 << B | _n, yu = vn;
      }
    }
    function JE(i) {
      ep();
      var o = i.return;
      if (o !== null) {
        var d = 1, h = 0;
        Jf(i, d), CR(i, d, h);
      }
    }
    function mS(i) {
      return 32 - dh(i);
    }
    function YU(i) {
      return 1 << mS(i) - 1;
    }
    function eC(i) {
      for (; i === hS; )
        hS = rg[--ig], rg[ig] = null, gS = rg[--ig], rg[ig] = null;
      for (; i === Zf; )
        Zf = $s[--Ms], $s[Ms] = null, yu = $s[--Ms], $s[Ms] = null, vu = $s[--Ms], $s[Ms] = null;
    }
    function KU() {
      return ep(), Zf !== null ? {
        id: vu,
        overflow: yu
      } : null;
    }
    function WU(i, o) {
      ep(), $s[Ms++] = vu, $s[Ms++] = yu, $s[Ms++] = Zf, vu = o.id, yu = o.overflow, Zf = i;
    }
    function ep() {
      po() || c("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var fo = null, As = null, ml = !1, tp = !1, _d = null;
    function GU() {
      ml && c("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function _R() {
      tp = !0;
    }
    function XU() {
      return tp;
    }
    function qU(i) {
      var o = i.stateNode.containerInfo;
      return As = hU(o), fo = i, ml = !0, _d = null, tp = !1, !0;
    }
    function QU(i, o, d) {
      return As = gU(o), fo = i, ml = !0, _d = null, tp = !1, d !== null && WU(i, d), !0;
    }
    function TR(i, o) {
      switch (i.tag) {
        case v: {
          _U(i.stateNode.containerInfo, o);
          break;
        }
        case x: {
          var d = (i.mode & fn) !== Dt;
          kU(
            i.type,
            i.memoizedProps,
            i.stateNode,
            o,
            // TODO: Delete this argument when we remove the legacy root API.
            d
          );
          break;
        }
        case z: {
          var h = i.memoizedState;
          h.dehydrated !== null && TU(h.dehydrated, o);
          break;
        }
      }
    }
    function kR(i, o) {
      TR(i, o);
      var d = e7();
      d.stateNode = o, d.return = i;
      var h = i.deletions;
      h === null ? (i.deletions = [d], i.flags |= Un) : h.push(d);
    }
    function tC(i, o) {
      {
        if (tp)
          return;
        switch (i.tag) {
          case v: {
            var d = i.stateNode.containerInfo;
            switch (o.tag) {
              case x:
                var h = o.type;
                o.pendingProps, PU(d, h);
                break;
              case _:
                var b = o.pendingProps;
                IU(d, b);
                break;
            }
            break;
          }
          case x: {
            var C = i.type, R = i.memoizedProps, A = i.stateNode;
            switch (o.tag) {
              case x: {
                var B = o.type, V = o.pendingProps, G = (i.mode & fn) !== Dt;
                MU(
                  C,
                  R,
                  A,
                  B,
                  V,
                  // TODO: Delete this argument when we remove the legacy root API.
                  G
                );
                break;
              }
              case _: {
                var ae = o.pendingProps, ne = (i.mode & fn) !== Dt;
                AU(
                  C,
                  R,
                  A,
                  ae,
                  // TODO: Delete this argument when we remove the legacy root API.
                  ne
                );
                break;
              }
            }
            break;
          }
          case z: {
            var Ce = i.memoizedState, _e = Ce.dehydrated;
            if (_e !== null)
              switch (o.tag) {
                case x:
                  var Ae = o.type;
                  o.pendingProps, RU(_e, Ae);
                  break;
                case _:
                  var ut = o.pendingProps;
                  $U(_e, ut);
                  break;
              }
            break;
          }
          default:
            return;
        }
      }
    }
    function PR(i, o) {
      o.flags = o.flags & ~Ta | mr, tC(i, o);
    }
    function IR(i, o) {
      switch (i.tag) {
        case x: {
          var d = i.type;
          i.pendingProps;
          var h = lU(o, d);
          return h !== null ? (i.stateNode = h, fo = i, As = pU(h), !0) : !1;
        }
        case _: {
          var b = i.pendingProps, C = cU(o, b);
          return C !== null ? (i.stateNode = C, fo = i, As = null, !0) : !1;
        }
        case z: {
          var R = uU(o);
          if (R !== null) {
            var A = {
              dehydrated: R,
              treeContext: KU(),
              retryLane: No
            };
            i.memoizedState = A;
            var B = t7(R);
            return B.return = i, i.child = B, fo = i, As = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function nC(i) {
      return (i.mode & fn) !== Dt && (i.flags & Ht) === Mt;
    }
    function rC(i) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function iC(i) {
      if (ml) {
        var o = As;
        if (!o) {
          nC(i) && (tC(fo, i), rC()), PR(fo, i), ml = !1, fo = i;
          return;
        }
        var d = o;
        if (!IR(i, o)) {
          nC(i) && (tC(fo, i), rC()), o = Nv(d);
          var h = fo;
          if (!o || !IR(i, o)) {
            PR(fo, i), ml = !1, fo = i;
            return;
          }
          kR(h, d);
        }
      }
    }
    function ZU(i, o, d) {
      var h = i.stateNode, b = !tp, C = mU(h, i.type, i.memoizedProps, o, d, i, b);
      return i.updateQueue = C, C !== null;
    }
    function JU(i) {
      var o = i.stateNode, d = i.memoizedProps, h = vU(o, d, i);
      if (h) {
        var b = fo;
        if (b !== null)
          switch (b.tag) {
            case v: {
              var C = b.stateNode.containerInfo, R = (b.mode & fn) !== Dt;
              EU(
                C,
                o,
                d,
                // TODO: Delete this argument when we remove the legacy root API.
                R
              );
              break;
            }
            case x: {
              var A = b.type, B = b.memoizedProps, V = b.stateNode, G = (b.mode & fn) !== Dt;
              CU(
                A,
                B,
                V,
                o,
                d,
                // TODO: Delete this argument when we remove the legacy root API.
                G
              );
              break;
            }
          }
      }
      return h;
    }
    function eB(i) {
      var o = i.memoizedState, d = o !== null ? o.dehydrated : null;
      if (!d)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      yU(d, i);
    }
    function tB(i) {
      var o = i.memoizedState, d = o !== null ? o.dehydrated : null;
      if (!d)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return bU(d);
    }
    function RR(i) {
      for (var o = i.return; o !== null && o.tag !== x && o.tag !== v && o.tag !== z; )
        o = o.return;
      fo = o;
    }
    function vS(i) {
      if (i !== fo)
        return !1;
      if (!ml)
        return RR(i), ml = !0, !1;
      if (i.tag !== v && (i.tag !== x || xU(i.type) && !zE(i.type, i.memoizedProps))) {
        var o = As;
        if (o)
          if (nC(i))
            $R(i), rC();
          else
            for (; o; )
              kR(i, o), o = Nv(o);
      }
      return RR(i), i.tag === z ? As = tB(i) : As = fo ? Nv(i.stateNode) : null, !0;
    }
    function nB() {
      return ml && As !== null;
    }
    function $R(i) {
      for (var o = As; o; )
        TR(i, o), o = Nv(o);
    }
    function og() {
      fo = null, As = null, ml = !1, tp = !1;
    }
    function MR() {
      _d !== null && (TM(_d), _d = null);
    }
    function po() {
      return ml;
    }
    function oC(i) {
      _d === null ? _d = [i] : _d.push(i);
    }
    var rB = n.ReactCurrentBatchConfig, iB = null;
    function oB() {
      return rB.transition;
    }
    var vl = {
      recordUnsafeLifecycleWarnings: function(i, o) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(i, o) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var aB = function(i) {
        for (var o = null, d = i; d !== null; )
          d.mode & Or && (o = d), d = d.return;
        return o;
      }, np = function(i) {
        var o = [];
        return i.forEach(function(d) {
          o.push(d);
        }), o.sort().join(", ");
      }, Uv = [], Bv = [], Fv = [], Hv = [], Vv = [], Yv = [], rp = /* @__PURE__ */ new Set();
      vl.recordUnsafeLifecycleWarnings = function(i, o) {
        rp.has(i.type) || (typeof o.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        o.componentWillMount.__suppressDeprecationWarning !== !0 && Uv.push(i), i.mode & Or && typeof o.UNSAFE_componentWillMount == "function" && Bv.push(i), typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && Fv.push(i), i.mode & Or && typeof o.UNSAFE_componentWillReceiveProps == "function" && Hv.push(i), typeof o.componentWillUpdate == "function" && o.componentWillUpdate.__suppressDeprecationWarning !== !0 && Vv.push(i), i.mode & Or && typeof o.UNSAFE_componentWillUpdate == "function" && Yv.push(i));
      }, vl.flushPendingUnsafeLifecycleWarnings = function() {
        var i = /* @__PURE__ */ new Set();
        Uv.length > 0 && (Uv.forEach(function(ne) {
          i.add(Ft(ne) || "Component"), rp.add(ne.type);
        }), Uv = []);
        var o = /* @__PURE__ */ new Set();
        Bv.length > 0 && (Bv.forEach(function(ne) {
          o.add(Ft(ne) || "Component"), rp.add(ne.type);
        }), Bv = []);
        var d = /* @__PURE__ */ new Set();
        Fv.length > 0 && (Fv.forEach(function(ne) {
          d.add(Ft(ne) || "Component"), rp.add(ne.type);
        }), Fv = []);
        var h = /* @__PURE__ */ new Set();
        Hv.length > 0 && (Hv.forEach(function(ne) {
          h.add(Ft(ne) || "Component"), rp.add(ne.type);
        }), Hv = []);
        var b = /* @__PURE__ */ new Set();
        Vv.length > 0 && (Vv.forEach(function(ne) {
          b.add(Ft(ne) || "Component"), rp.add(ne.type);
        }), Vv = []);
        var C = /* @__PURE__ */ new Set();
        if (Yv.length > 0 && (Yv.forEach(function(ne) {
          C.add(Ft(ne) || "Component"), rp.add(ne.type);
        }), Yv = []), o.size > 0) {
          var R = np(o);
          c(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, R);
        }
        if (h.size > 0) {
          var A = np(h);
          c(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, A);
        }
        if (C.size > 0) {
          var B = np(C);
          c(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, B);
        }
        if (i.size > 0) {
          var V = np(i);
          s(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, V);
        }
        if (d.size > 0) {
          var G = np(d);
          s(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, G);
        }
        if (b.size > 0) {
          var ae = np(b);
          s(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, ae);
        }
      };
      var yS = /* @__PURE__ */ new Map(), AR = /* @__PURE__ */ new Set();
      vl.recordLegacyContextWarning = function(i, o) {
        var d = aB(i);
        if (d === null) {
          c("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!AR.has(i.type)) {
          var h = yS.get(d);
          (i.type.contextTypes != null || i.type.childContextTypes != null || o !== null && typeof o.getChildContext == "function") && (h === void 0 && (h = [], yS.set(d, h)), h.push(i));
        }
      }, vl.flushLegacyContextWarning = function() {
        yS.forEach(function(i, o) {
          if (i.length !== 0) {
            var d = i[0], h = /* @__PURE__ */ new Set();
            i.forEach(function(C) {
              h.add(Ft(C) || "Component"), AR.add(C.type);
            });
            var b = np(h);
            try {
              Nn(d), c(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, b);
            } finally {
              or();
            }
          }
        });
      }, vl.discardPendingWarnings = function() {
        Uv = [], Bv = [], Fv = [], Hv = [], Vv = [], Yv = [], yS = /* @__PURE__ */ new Map();
      };
    }
    function yl(i, o) {
      if (i && i.defaultProps) {
        var d = Jt({}, o), h = i.defaultProps;
        for (var b in h)
          d[b] === void 0 && (d[b] = h[b]);
        return d;
      }
      return o;
    }
    var aC = xd(null), sC;
    sC = {};
    var bS = null, ag = null, lC = null, SS = !1;
    function wS() {
      bS = null, ag = null, lC = null, SS = !1;
    }
    function OR() {
      SS = !0;
    }
    function DR() {
      SS = !1;
    }
    function NR(i, o, d) {
      zo(aC, o._currentValue, i), o._currentValue = d, o._currentRenderer !== void 0 && o._currentRenderer !== null && o._currentRenderer !== sC && c("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), o._currentRenderer = sC;
    }
    function cC(i, o) {
      var d = aC.current;
      jo(aC, o), i._currentValue = d;
    }
    function uC(i, o, d) {
      for (var h = i; h !== null; ) {
        var b = h.alternate;
        if (ru(h.childLanes, o) ? b !== null && !ru(b.childLanes, o) && (b.childLanes = an(b.childLanes, o)) : (h.childLanes = an(h.childLanes, o), b !== null && (b.childLanes = an(b.childLanes, o))), h === d)
          break;
        h = h.return;
      }
      h !== d && c("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function sB(i, o, d) {
      lB(i, o, d);
    }
    function lB(i, o, d) {
      var h = i.child;
      for (h !== null && (h.return = i); h !== null; ) {
        var b = void 0, C = h.dependencies;
        if (C !== null) {
          b = h.child;
          for (var R = C.firstContext; R !== null; ) {
            if (R.context === o) {
              if (h.tag === g) {
                var A = si(d), B = bu(lr, A);
                B.tag = ES;
                var V = h.updateQueue;
                if (V !== null) {
                  var G = V.shared, ae = G.pending;
                  ae === null ? B.next = B : (B.next = ae.next, ae.next = B), G.pending = B;
                }
              }
              h.lanes = an(h.lanes, d);
              var ne = h.alternate;
              ne !== null && (ne.lanes = an(ne.lanes, d)), uC(h.return, d, i), C.lanes = an(C.lanes, d);
              break;
            }
            R = R.next;
          }
        } else if (h.tag === N)
          b = h.type === i.type ? null : h.child;
        else if (h.tag === ue) {
          var Ce = h.return;
          if (Ce === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Ce.lanes = an(Ce.lanes, d);
          var _e = Ce.alternate;
          _e !== null && (_e.lanes = an(_e.lanes, d)), uC(Ce, d, i), b = h.sibling;
        } else
          b = h.child;
        if (b !== null)
          b.return = h;
        else
          for (b = h; b !== null; ) {
            if (b === i) {
              b = null;
              break;
            }
            var Ae = b.sibling;
            if (Ae !== null) {
              Ae.return = b.return, b = Ae;
              break;
            }
            b = b.return;
          }
        h = b;
      }
    }
    function sg(i, o) {
      bS = i, ag = null, lC = null;
      var d = i.dependencies;
      if (d !== null) {
        var h = d.firstContext;
        h !== null && (Lo(d.lanes, o) && oy(), d.firstContext = null);
      }
    }
    function ki(i) {
      SS && c("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var o = i._currentValue;
      if (lC !== i) {
        var d = {
          context: i,
          memoizedValue: o,
          next: null
        };
        if (ag === null) {
          if (bS === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          ag = d, bS.dependencies = {
            lanes: Ne,
            firstContext: d
          };
        } else
          ag = ag.next = d;
      }
      return o;
    }
    var ip = null;
    function dC(i) {
      ip === null ? ip = [i] : ip.push(i);
    }
    function cB() {
      if (ip !== null) {
        for (var i = 0; i < ip.length; i++) {
          var o = ip[i], d = o.interleaved;
          if (d !== null) {
            o.interleaved = null;
            var h = d.next, b = o.pending;
            if (b !== null) {
              var C = b.next;
              b.next = h, d.next = C;
            }
            o.pending = d;
          }
        }
        ip = null;
      }
    }
    function LR(i, o, d, h) {
      var b = o.interleaved;
      return b === null ? (d.next = d, dC(o)) : (d.next = b.next, b.next = d), o.interleaved = d, xS(i, h);
    }
    function uB(i, o, d, h) {
      var b = o.interleaved;
      b === null ? (d.next = d, dC(o)) : (d.next = b.next, b.next = d), o.interleaved = d;
    }
    function dB(i, o, d, h) {
      var b = o.interleaved;
      return b === null ? (d.next = d, dC(o)) : (d.next = b.next, b.next = d), o.interleaved = d, xS(i, h);
    }
    function Na(i, o) {
      return xS(i, o);
    }
    var fB = xS;
    function xS(i, o) {
      i.lanes = an(i.lanes, o);
      var d = i.alternate;
      d !== null && (d.lanes = an(d.lanes, o)), d === null && (i.flags & (mr | Ta)) !== Mt && jM(i);
      for (var h = i, b = i.return; b !== null; )
        b.childLanes = an(b.childLanes, o), d = b.alternate, d !== null ? d.childLanes = an(d.childLanes, o) : (b.flags & (mr | Ta)) !== Mt && jM(i), h = b, b = b.return;
      if (h.tag === v) {
        var C = h.stateNode;
        return C;
      } else
        return null;
    }
    var jR = 0, zR = 1, ES = 2, fC = 3, CS = !1, pC, _S;
    pC = !1, _S = null;
    function hC(i) {
      var o = {
        baseState: i.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Ne
        },
        effects: null
      };
      i.updateQueue = o;
    }
    function UR(i, o) {
      var d = o.updateQueue, h = i.updateQueue;
      if (d === h) {
        var b = {
          baseState: h.baseState,
          firstBaseUpdate: h.firstBaseUpdate,
          lastBaseUpdate: h.lastBaseUpdate,
          shared: h.shared,
          effects: h.effects
        };
        o.updateQueue = b;
      }
    }
    function bu(i, o) {
      var d = {
        eventTime: i,
        lane: o,
        tag: jR,
        payload: null,
        callback: null,
        next: null
      };
      return d;
    }
    function Td(i, o, d) {
      var h = i.updateQueue;
      if (h === null)
        return null;
      var b = h.shared;
      if (_S === b && !pC && (c("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), pC = !0), fF()) {
        var C = b.pending;
        return C === null ? o.next = o : (o.next = C.next, C.next = o), b.pending = o, fB(i, d);
      } else
        return dB(i, b, o, d);
    }
    function TS(i, o, d) {
      var h = o.updateQueue;
      if (h !== null) {
        var b = h.shared;
        if (tv(d)) {
          var C = b.lanes;
          C = rv(C, i.pendingLanes);
          var R = an(C, d);
          b.lanes = R, ad(i, R);
        }
      }
    }
    function gC(i, o) {
      var d = i.updateQueue, h = i.alternate;
      if (h !== null) {
        var b = h.updateQueue;
        if (d === b) {
          var C = null, R = null, A = d.firstBaseUpdate;
          if (A !== null) {
            var B = A;
            do {
              var V = {
                eventTime: B.eventTime,
                lane: B.lane,
                tag: B.tag,
                payload: B.payload,
                callback: B.callback,
                next: null
              };
              R === null ? C = R = V : (R.next = V, R = V), B = B.next;
            } while (B !== null);
            R === null ? C = R = o : (R.next = o, R = o);
          } else
            C = R = o;
          d = {
            baseState: b.baseState,
            firstBaseUpdate: C,
            lastBaseUpdate: R,
            shared: b.shared,
            effects: b.effects
          }, i.updateQueue = d;
          return;
        }
      }
      var G = d.lastBaseUpdate;
      G === null ? d.firstBaseUpdate = o : G.next = o, d.lastBaseUpdate = o;
    }
    function pB(i, o, d, h, b, C) {
      switch (d.tag) {
        case zR: {
          var R = d.payload;
          if (typeof R == "function") {
            OR();
            var A = R.call(C, h, b);
            {
              if (i.mode & Or) {
                ai(!0);
                try {
                  R.call(C, h, b);
                } finally {
                  ai(!1);
                }
              }
              DR();
            }
            return A;
          }
          return R;
        }
        case fC:
          i.flags = i.flags & ~xi | Ht;
        case jR: {
          var B = d.payload, V;
          if (typeof B == "function") {
            OR(), V = B.call(C, h, b);
            {
              if (i.mode & Or) {
                ai(!0);
                try {
                  B.call(C, h, b);
                } finally {
                  ai(!1);
                }
              }
              DR();
            }
          } else
            V = B;
          return V == null ? h : Jt({}, h, V);
        }
        case ES:
          return CS = !0, h;
      }
      return h;
    }
    function kS(i, o, d, h) {
      var b = i.updateQueue;
      CS = !1, _S = b.shared;
      var C = b.firstBaseUpdate, R = b.lastBaseUpdate, A = b.shared.pending;
      if (A !== null) {
        b.shared.pending = null;
        var B = A, V = B.next;
        B.next = null, R === null ? C = V : R.next = V, R = B;
        var G = i.alternate;
        if (G !== null) {
          var ae = G.updateQueue, ne = ae.lastBaseUpdate;
          ne !== R && (ne === null ? ae.firstBaseUpdate = V : ne.next = V, ae.lastBaseUpdate = B);
        }
      }
      if (C !== null) {
        var Ce = b.baseState, _e = Ne, Ae = null, ut = null, Ot = null, Pt = C;
        do {
          var _n = Pt.lane, vn = Pt.eventTime;
          if (ru(h, _n)) {
            if (Ot !== null) {
              var Oe = {
                eventTime: vn,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: En,
                tag: Pt.tag,
                payload: Pt.payload,
                callback: Pt.callback,
                next: null
              };
              Ot = Ot.next = Oe;
            }
            Ce = pB(i, b, Pt, Ce, o, d);
            var Se = Pt.callback;
            if (Se !== null && // If the update was already committed, we should not queue its
            // callback again.
            Pt.lane !== En) {
              i.flags |= _s;
              var We = b.effects;
              We === null ? b.effects = [Pt] : We.push(Pt);
            }
          } else {
            var be = {
              eventTime: vn,
              lane: _n,
              tag: Pt.tag,
              payload: Pt.payload,
              callback: Pt.callback,
              next: null
            };
            Ot === null ? (ut = Ot = be, Ae = Ce) : Ot = Ot.next = be, _e = an(_e, _n);
          }
          if (Pt = Pt.next, Pt === null) {
            if (A = b.shared.pending, A === null)
              break;
            var dt = A, at = dt.next;
            dt.next = null, Pt = at, b.lastBaseUpdate = dt, b.shared.pending = null;
          }
        } while (!0);
        Ot === null && (Ae = Ce), b.baseState = Ae, b.firstBaseUpdate = ut, b.lastBaseUpdate = Ot;
        var Bt = b.shared.interleaved;
        if (Bt !== null) {
          var Zt = Bt;
          do
            _e = an(_e, Zt.lane), Zt = Zt.next;
          while (Zt !== Bt);
        } else
          C === null && (b.shared.lanes = Ne);
        vy(_e), i.lanes = _e, i.memoizedState = Ce;
      }
      _S = null;
    }
    function hB(i, o) {
      if (typeof i != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + i));
      i.call(o);
    }
    function BR() {
      CS = !1;
    }
    function PS() {
      return CS;
    }
    function FR(i, o, d) {
      var h = o.effects;
      if (o.effects = null, h !== null)
        for (var b = 0; b < h.length; b++) {
          var C = h[b], R = C.callback;
          R !== null && (C.callback = null, hB(R, d));
        }
    }
    var mC = {}, HR = new t.Component().refs, vC, yC, bC, SC, wC, VR, IS, xC, EC, CC;
    {
      vC = /* @__PURE__ */ new Set(), yC = /* @__PURE__ */ new Set(), bC = /* @__PURE__ */ new Set(), SC = /* @__PURE__ */ new Set(), xC = /* @__PURE__ */ new Set(), wC = /* @__PURE__ */ new Set(), EC = /* @__PURE__ */ new Set(), CC = /* @__PURE__ */ new Set();
      var YR = /* @__PURE__ */ new Set();
      IS = function(i, o) {
        if (!(i === null || typeof i == "function")) {
          var d = o + "_" + i;
          YR.has(d) || (YR.add(d), c("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", o, i));
        }
      }, VR = function(i, o) {
        if (o === void 0) {
          var d = rn(i) || "Component";
          wC.has(d) || (wC.add(d), c("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", d));
        }
      }, Object.defineProperty(mC, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(mC);
    }
    function _C(i, o, d, h) {
      var b = i.memoizedState, C = d(h, b);
      {
        if (i.mode & Or) {
          ai(!0);
          try {
            C = d(h, b);
          } finally {
            ai(!1);
          }
        }
        VR(o, C);
      }
      var R = C == null ? b : Jt({}, b, C);
      if (i.memoizedState = R, i.lanes === Ne) {
        var A = i.updateQueue;
        A.baseState = R;
      }
    }
    var TC = {
      isMounted: Jo,
      enqueueSetState: function(i, o, d) {
        var h = Ca(i), b = oa(), C = Od(h), R = bu(b, C);
        R.payload = o, d != null && (IS(d, "setState"), R.callback = d);
        var A = Td(h, R, C);
        A !== null && (Fi(A, h, C, b), TS(A, h, C)), ec(h, C);
      },
      enqueueReplaceState: function(i, o, d) {
        var h = Ca(i), b = oa(), C = Od(h), R = bu(b, C);
        R.tag = zR, R.payload = o, d != null && (IS(d, "replaceState"), R.callback = d);
        var A = Td(h, R, C);
        A !== null && (Fi(A, h, C, b), TS(A, h, C)), ec(h, C);
      },
      enqueueForceUpdate: function(i, o) {
        var d = Ca(i), h = oa(), b = Od(d), C = bu(h, b);
        C.tag = ES, o != null && (IS(o, "forceUpdate"), C.callback = o);
        var R = Td(d, C, b);
        R !== null && (Fi(R, d, b, h), TS(R, d, b)), Qm(d, b);
      }
    };
    function KR(i, o, d, h, b, C, R) {
      var A = i.stateNode;
      if (typeof A.shouldComponentUpdate == "function") {
        var B = A.shouldComponentUpdate(h, C, R);
        {
          if (i.mode & Or) {
            ai(!0);
            try {
              B = A.shouldComponentUpdate(h, C, R);
            } finally {
              ai(!1);
            }
          }
          B === void 0 && c("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", rn(o) || "Component");
        }
        return B;
      }
      return o.prototype && o.prototype.isPureReactComponent ? !$t(d, h) || !$t(b, C) : !0;
    }
    function gB(i, o, d) {
      var h = i.stateNode;
      {
        var b = rn(o) || "Component", C = h.render;
        C || (o.prototype && typeof o.prototype.render == "function" ? c("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", b) : c("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", b)), h.getInitialState && !h.getInitialState.isReactClassApproved && !h.state && c("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", b), h.getDefaultProps && !h.getDefaultProps.isReactClassApproved && c("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", b), h.propTypes && c("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", b), h.contextType && c("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", b), h.contextTypes && c("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", b), o.contextType && o.contextTypes && !EC.has(o) && (EC.add(o), c("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", b)), typeof h.componentShouldUpdate == "function" && c("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", b), o.prototype && o.prototype.isPureReactComponent && typeof h.shouldComponentUpdate < "u" && c("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", rn(o) || "A pure component"), typeof h.componentDidUnmount == "function" && c("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", b), typeof h.componentDidReceiveProps == "function" && c("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", b), typeof h.componentWillRecieveProps == "function" && c("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", b), typeof h.UNSAFE_componentWillRecieveProps == "function" && c("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", b);
        var R = h.props !== d;
        h.props !== void 0 && R && c("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", b, b), h.defaultProps && c("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", b, b), typeof h.getSnapshotBeforeUpdate == "function" && typeof h.componentDidUpdate != "function" && !bC.has(o) && (bC.add(o), c("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", rn(o))), typeof h.getDerivedStateFromProps == "function" && c("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", b), typeof h.getDerivedStateFromError == "function" && c("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", b), typeof o.getSnapshotBeforeUpdate == "function" && c("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", b);
        var A = h.state;
        A && (typeof A != "object" || Sn(A)) && c("%s.state: must be set to an object or null", b), typeof h.getChildContext == "function" && typeof o.childContextTypes != "object" && c("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", b);
      }
    }
    function WR(i, o) {
      o.updater = TC, i.stateNode = o, qu(o, i), o._reactInternalInstance = mC;
    }
    function GR(i, o, d) {
      var h = !1, b = is, C = is, R = o.contextType;
      if ("contextType" in o) {
        var A = (
          // Allow null for conditional declaration
          R === null || R !== void 0 && R.$$typeof === et && R._context === void 0
        );
        if (!A && !CC.has(o)) {
          CC.add(o);
          var B = "";
          R === void 0 ? B = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof R != "object" ? B = " However, it is set to a " + typeof R + "." : R.$$typeof === Be ? B = " Did you accidentally pass the Context.Provider instead?" : R._context !== void 0 ? B = " Did you accidentally pass the Context.Consumer instead?" : B = " However, it is set to an object with keys {" + Object.keys(R).join(", ") + "}.", c("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", rn(o) || "Component", B);
        }
      }
      if (typeof R == "object" && R !== null)
        C = ki(R);
      else {
        b = tg(i, o, !0);
        var V = o.contextTypes;
        h = V != null, C = h ? ng(i, b) : is;
      }
      var G = new o(d, C);
      if (i.mode & Or) {
        ai(!0);
        try {
          G = new o(d, C);
        } finally {
          ai(!1);
        }
      }
      var ae = i.memoizedState = G.state !== null && G.state !== void 0 ? G.state : null;
      WR(i, G);
      {
        if (typeof o.getDerivedStateFromProps == "function" && ae === null) {
          var ne = rn(o) || "Component";
          yC.has(ne) || (yC.add(ne), c("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", ne, G.state === null ? "null" : "undefined", ne));
        }
        if (typeof o.getDerivedStateFromProps == "function" || typeof G.getSnapshotBeforeUpdate == "function") {
          var Ce = null, _e = null, Ae = null;
          if (typeof G.componentWillMount == "function" && G.componentWillMount.__suppressDeprecationWarning !== !0 ? Ce = "componentWillMount" : typeof G.UNSAFE_componentWillMount == "function" && (Ce = "UNSAFE_componentWillMount"), typeof G.componentWillReceiveProps == "function" && G.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? _e = "componentWillReceiveProps" : typeof G.UNSAFE_componentWillReceiveProps == "function" && (_e = "UNSAFE_componentWillReceiveProps"), typeof G.componentWillUpdate == "function" && G.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Ae = "componentWillUpdate" : typeof G.UNSAFE_componentWillUpdate == "function" && (Ae = "UNSAFE_componentWillUpdate"), Ce !== null || _e !== null || Ae !== null) {
            var ut = rn(o) || "Component", Ot = typeof o.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            SC.has(ut) || (SC.add(ut), c(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, ut, Ot, Ce !== null ? `
  ` + Ce : "", _e !== null ? `
  ` + _e : "", Ae !== null ? `
  ` + Ae : ""));
          }
        }
      }
      return h && yR(i, b, C), G;
    }
    function mB(i, o) {
      var d = o.state;
      typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount(), d !== o.state && (c("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Ft(i) || "Component"), TC.enqueueReplaceState(o, o.state, null));
    }
    function XR(i, o, d, h) {
      var b = o.state;
      if (typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps(d, h), typeof o.UNSAFE_componentWillReceiveProps == "function" && o.UNSAFE_componentWillReceiveProps(d, h), o.state !== b) {
        {
          var C = Ft(i) || "Component";
          vC.has(C) || (vC.add(C), c("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", C));
        }
        TC.enqueueReplaceState(o, o.state, null);
      }
    }
    function kC(i, o, d, h) {
      gB(i, o, d);
      var b = i.stateNode;
      b.props = d, b.state = i.memoizedState, b.refs = HR, hC(i);
      var C = o.contextType;
      if (typeof C == "object" && C !== null)
        b.context = ki(C);
      else {
        var R = tg(i, o, !0);
        b.context = ng(i, R);
      }
      {
        if (b.state === d) {
          var A = rn(o) || "Component";
          xC.has(A) || (xC.add(A), c("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", A));
        }
        i.mode & Or && vl.recordLegacyContextWarning(i, b), vl.recordUnsafeLifecycleWarnings(i, b);
      }
      b.state = i.memoizedState;
      var B = o.getDerivedStateFromProps;
      if (typeof B == "function" && (_C(i, o, B, d), b.state = i.memoizedState), typeof o.getDerivedStateFromProps != "function" && typeof b.getSnapshotBeforeUpdate != "function" && (typeof b.UNSAFE_componentWillMount == "function" || typeof b.componentWillMount == "function") && (mB(i, b), kS(i, d, b, h), b.state = i.memoizedState), typeof b.componentDidMount == "function") {
        var V = on;
        V |= $o, (i.mode & Ia) !== Dt && (V |= Mo), i.flags |= V;
      }
    }
    function vB(i, o, d, h) {
      var b = i.stateNode, C = i.memoizedProps;
      b.props = C;
      var R = b.context, A = o.contextType, B = is;
      if (typeof A == "object" && A !== null)
        B = ki(A);
      else {
        var V = tg(i, o, !0);
        B = ng(i, V);
      }
      var G = o.getDerivedStateFromProps, ae = typeof G == "function" || typeof b.getSnapshotBeforeUpdate == "function";
      !ae && (typeof b.UNSAFE_componentWillReceiveProps == "function" || typeof b.componentWillReceiveProps == "function") && (C !== d || R !== B) && XR(i, b, d, B), BR();
      var ne = i.memoizedState, Ce = b.state = ne;
      if (kS(i, d, b, h), Ce = i.memoizedState, C === d && ne === Ce && !uS() && !PS()) {
        if (typeof b.componentDidMount == "function") {
          var _e = on;
          _e |= $o, (i.mode & Ia) !== Dt && (_e |= Mo), i.flags |= _e;
        }
        return !1;
      }
      typeof G == "function" && (_C(i, o, G, d), Ce = i.memoizedState);
      var Ae = PS() || KR(i, o, C, d, ne, Ce, B);
      if (Ae) {
        if (!ae && (typeof b.UNSAFE_componentWillMount == "function" || typeof b.componentWillMount == "function") && (typeof b.componentWillMount == "function" && b.componentWillMount(), typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount()), typeof b.componentDidMount == "function") {
          var ut = on;
          ut |= $o, (i.mode & Ia) !== Dt && (ut |= Mo), i.flags |= ut;
        }
      } else {
        if (typeof b.componentDidMount == "function") {
          var Ot = on;
          Ot |= $o, (i.mode & Ia) !== Dt && (Ot |= Mo), i.flags |= Ot;
        }
        i.memoizedProps = d, i.memoizedState = Ce;
      }
      return b.props = d, b.state = Ce, b.context = B, Ae;
    }
    function yB(i, o, d, h, b) {
      var C = o.stateNode;
      UR(i, o);
      var R = o.memoizedProps, A = o.type === o.elementType ? R : yl(o.type, R);
      C.props = A;
      var B = o.pendingProps, V = C.context, G = d.contextType, ae = is;
      if (typeof G == "object" && G !== null)
        ae = ki(G);
      else {
        var ne = tg(o, d, !0);
        ae = ng(o, ne);
      }
      var Ce = d.getDerivedStateFromProps, _e = typeof Ce == "function" || typeof C.getSnapshotBeforeUpdate == "function";
      !_e && (typeof C.UNSAFE_componentWillReceiveProps == "function" || typeof C.componentWillReceiveProps == "function") && (R !== B || V !== ae) && XR(o, C, h, ae), BR();
      var Ae = o.memoizedState, ut = C.state = Ae;
      if (kS(o, h, C, b), ut = o.memoizedState, R === B && Ae === ut && !uS() && !PS() && !de)
        return typeof C.componentDidUpdate == "function" && (R !== i.memoizedProps || Ae !== i.memoizedState) && (o.flags |= on), typeof C.getSnapshotBeforeUpdate == "function" && (R !== i.memoizedProps || Ae !== i.memoizedState) && (o.flags |= _a), !1;
      typeof Ce == "function" && (_C(o, d, Ce, h), ut = o.memoizedState);
      var Ot = PS() || KR(o, d, A, h, Ae, ut, ae) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      de;
      return Ot ? (!_e && (typeof C.UNSAFE_componentWillUpdate == "function" || typeof C.componentWillUpdate == "function") && (typeof C.componentWillUpdate == "function" && C.componentWillUpdate(h, ut, ae), typeof C.UNSAFE_componentWillUpdate == "function" && C.UNSAFE_componentWillUpdate(h, ut, ae)), typeof C.componentDidUpdate == "function" && (o.flags |= on), typeof C.getSnapshotBeforeUpdate == "function" && (o.flags |= _a)) : (typeof C.componentDidUpdate == "function" && (R !== i.memoizedProps || Ae !== i.memoizedState) && (o.flags |= on), typeof C.getSnapshotBeforeUpdate == "function" && (R !== i.memoizedProps || Ae !== i.memoizedState) && (o.flags |= _a), o.memoizedProps = h, o.memoizedState = ut), C.props = h, C.state = ut, C.context = ae, Ot;
    }
    var PC, IC, RC, $C, MC, qR = function(i, o) {
    };
    PC = !1, IC = !1, RC = {}, $C = {}, MC = {}, qR = function(i, o) {
      if (!(i === null || typeof i != "object") && !(!i._store || i._store.validated || i.key != null)) {
        if (typeof i._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        i._store.validated = !0;
        var d = Ft(o) || "Component";
        $C[d] || ($C[d] = !0, c('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function Kv(i, o, d) {
      var h = d.ref;
      if (h !== null && typeof h != "function" && typeof h != "object") {
        if ((i.mode & Or || $e) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(d._owner && d._self && d._owner.stateNode !== d._self)) {
          var b = Ft(i) || "Component";
          RC[b] || (c('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', h), RC[b] = !0);
        }
        if (d._owner) {
          var C = d._owner, R;
          if (C) {
            var A = C;
            if (A.tag !== g)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            R = A.stateNode;
          }
          if (!R)
            throw new Error("Missing owner for string ref " + h + ". This error is likely caused by a bug in React. Please file an issue.");
          var B = R;
          tn(h, "ref");
          var V = "" + h;
          if (o !== null && o.ref !== null && typeof o.ref == "function" && o.ref._stringRef === V)
            return o.ref;
          var G = function(ae) {
            var ne = B.refs;
            ne === HR && (ne = B.refs = {}), ae === null ? delete ne[V] : ne[V] = ae;
          };
          return G._stringRef = V, G;
        } else {
          if (typeof h != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!d._owner)
            throw new Error("Element ref was specified as a string (" + h + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return h;
    }
    function RS(i, o) {
      var d = Object.prototype.toString.call(o);
      throw new Error("Objects are not valid as a React child (found: " + (d === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : d) + "). If you meant to render a collection of children, use an array instead.");
    }
    function $S(i) {
      {
        var o = Ft(i) || "Component";
        if (MC[o])
          return;
        MC[o] = !0, c("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function QR(i) {
      var o = i._payload, d = i._init;
      return d(o);
    }
    function ZR(i) {
      function o(be, Oe) {
        if (i) {
          var Se = be.deletions;
          Se === null ? (be.deletions = [Oe], be.flags |= Un) : Se.push(Oe);
        }
      }
      function d(be, Oe) {
        if (!i)
          return null;
        for (var Se = Oe; Se !== null; )
          o(be, Se), Se = Se.sibling;
        return null;
      }
      function h(be, Oe) {
        for (var Se = /* @__PURE__ */ new Map(), We = Oe; We !== null; )
          We.key !== null ? Se.set(We.key, We) : Se.set(We.index, We), We = We.sibling;
        return Se;
      }
      function b(be, Oe) {
        var Se = fp(be, Oe);
        return Se.index = 0, Se.sibling = null, Se;
      }
      function C(be, Oe, Se) {
        if (be.index = Se, !i)
          return be.flags |= zm, Oe;
        var We = be.alternate;
        if (We !== null) {
          var dt = We.index;
          return dt < Oe ? (be.flags |= mr, Oe) : dt;
        } else
          return be.flags |= mr, Oe;
      }
      function R(be) {
        return i && be.alternate === null && (be.flags |= mr), be;
      }
      function A(be, Oe, Se, We) {
        if (Oe === null || Oe.tag !== _) {
          var dt = oT(Se, be.mode, We);
          return dt.return = be, dt;
        } else {
          var at = b(Oe, Se);
          return at.return = be, at;
        }
      }
      function B(be, Oe, Se, We) {
        var dt = Se.type;
        if (dt === Ri)
          return G(be, Oe, Se.props.children, We, Se.key);
        if (Oe !== null && (Oe.elementType === dt || // Keep this check inline so it only runs on the false path:
        FM(Oe, Se) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof dt == "object" && dt !== null && dt.$$typeof === Rt && QR(dt) === Oe.type)) {
          var at = b(Oe, Se.props);
          return at.ref = Kv(be, Oe, Se), at.return = be, at._debugSource = Se._source, at._debugOwner = Se._owner, at;
        }
        var Bt = iT(Se, be.mode, We);
        return Bt.ref = Kv(be, Oe, Se), Bt.return = be, Bt;
      }
      function V(be, Oe, Se, We) {
        if (Oe === null || Oe.tag !== S || Oe.stateNode.containerInfo !== Se.containerInfo || Oe.stateNode.implementation !== Se.implementation) {
          var dt = aT(Se, be.mode, We);
          return dt.return = be, dt;
        } else {
          var at = b(Oe, Se.children || []);
          return at.return = be, at;
        }
      }
      function G(be, Oe, Se, We, dt) {
        if (Oe === null || Oe.tag !== T) {
          var at = Nd(Se, be.mode, We, dt);
          return at.return = be, at;
        } else {
          var Bt = b(Oe, Se);
          return Bt.return = be, Bt;
        }
      }
      function ae(be, Oe, Se) {
        if (typeof Oe == "string" && Oe !== "" || typeof Oe == "number") {
          var We = oT("" + Oe, be.mode, Se);
          return We.return = be, We;
        }
        if (typeof Oe == "object" && Oe !== null) {
          switch (Oe.$$typeof) {
            case Sa: {
              var dt = iT(Oe, be.mode, Se);
              return dt.ref = Kv(be, null, Oe), dt.return = be, dt;
            }
            case vi: {
              var at = aT(Oe, be.mode, Se);
              return at.return = be, at;
            }
            case Rt: {
              var Bt = Oe._payload, Zt = Oe._init;
              return ae(be, Zt(Bt), Se);
            }
          }
          if (Sn(Oe) || Wo(Oe)) {
            var er = Nd(Oe, be.mode, Se, null);
            return er.return = be, er;
          }
          RS(be, Oe);
        }
        return typeof Oe == "function" && $S(be), null;
      }
      function ne(be, Oe, Se, We) {
        var dt = Oe !== null ? Oe.key : null;
        if (typeof Se == "string" && Se !== "" || typeof Se == "number")
          return dt !== null ? null : A(be, Oe, "" + Se, We);
        if (typeof Se == "object" && Se !== null) {
          switch (Se.$$typeof) {
            case Sa:
              return Se.key === dt ? B(be, Oe, Se, We) : null;
            case vi:
              return Se.key === dt ? V(be, Oe, Se, We) : null;
            case Rt: {
              var at = Se._payload, Bt = Se._init;
              return ne(be, Oe, Bt(at), We);
            }
          }
          if (Sn(Se) || Wo(Se))
            return dt !== null ? null : G(be, Oe, Se, We, null);
          RS(be, Se);
        }
        return typeof Se == "function" && $S(be), null;
      }
      function Ce(be, Oe, Se, We, dt) {
        if (typeof We == "string" && We !== "" || typeof We == "number") {
          var at = be.get(Se) || null;
          return A(Oe, at, "" + We, dt);
        }
        if (typeof We == "object" && We !== null) {
          switch (We.$$typeof) {
            case Sa: {
              var Bt = be.get(We.key === null ? Se : We.key) || null;
              return B(Oe, Bt, We, dt);
            }
            case vi: {
              var Zt = be.get(We.key === null ? Se : We.key) || null;
              return V(Oe, Zt, We, dt);
            }
            case Rt:
              var er = We._payload, jn = We._init;
              return Ce(be, Oe, Se, jn(er), dt);
          }
          if (Sn(We) || Wo(We)) {
            var di = be.get(Se) || null;
            return G(Oe, di, We, dt, null);
          }
          RS(Oe, We);
        }
        return typeof We == "function" && $S(Oe), null;
      }
      function _e(be, Oe, Se) {
        {
          if (typeof be != "object" || be === null)
            return Oe;
          switch (be.$$typeof) {
            case Sa:
            case vi:
              qR(be, Se);
              var We = be.key;
              if (typeof We != "string")
                break;
              if (Oe === null) {
                Oe = /* @__PURE__ */ new Set(), Oe.add(We);
                break;
              }
              if (!Oe.has(We)) {
                Oe.add(We);
                break;
              }
              c("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", We);
              break;
            case Rt:
              var dt = be._payload, at = be._init;
              _e(at(dt), Oe, Se);
              break;
          }
        }
        return Oe;
      }
      function Ae(be, Oe, Se, We) {
        for (var dt = null, at = 0; at < Se.length; at++) {
          var Bt = Se[at];
          dt = _e(Bt, dt, be);
        }
        for (var Zt = null, er = null, jn = Oe, di = 0, zn = 0, oi = null; jn !== null && zn < Se.length; zn++) {
          jn.index > zn ? (oi = jn, jn = null) : oi = jn.sibling;
          var Bo = ne(be, jn, Se[zn], We);
          if (Bo === null) {
            jn === null && (jn = oi);
            break;
          }
          i && jn && Bo.alternate === null && o(be, jn), di = C(Bo, di, zn), er === null ? Zt = Bo : er.sibling = Bo, er = Bo, jn = oi;
        }
        if (zn === Se.length) {
          if (d(be, jn), po()) {
            var So = zn;
            Jf(be, So);
          }
          return Zt;
        }
        if (jn === null) {
          for (; zn < Se.length; zn++) {
            var as = ae(be, Se[zn], We);
            as !== null && (di = C(as, di, zn), er === null ? Zt = as : er.sibling = as, er = as);
          }
          if (po()) {
            var aa = zn;
            Jf(be, aa);
          }
          return Zt;
        }
        for (var sa = h(be, jn); zn < Se.length; zn++) {
          var Fo = Ce(sa, be, zn, Se[zn], We);
          Fo !== null && (i && Fo.alternate !== null && sa.delete(Fo.key === null ? zn : Fo.key), di = C(Fo, di, zn), er === null ? Zt = Fo : er.sibling = Fo, er = Fo);
        }
        if (i && sa.forEach(function(Cg) {
          return o(be, Cg);
        }), po()) {
          var _u = zn;
          Jf(be, _u);
        }
        return Zt;
      }
      function ut(be, Oe, Se, We) {
        var dt = Wo(Se);
        if (typeof dt != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          Se[Symbol.toStringTag] === "Generator" && (IC || c("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), IC = !0), Se.entries === dt && (PC || c("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), PC = !0);
          var at = dt.call(Se);
          if (at)
            for (var Bt = null, Zt = at.next(); !Zt.done; Zt = at.next()) {
              var er = Zt.value;
              Bt = _e(er, Bt, be);
            }
        }
        var jn = dt.call(Se);
        if (jn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var di = null, zn = null, oi = Oe, Bo = 0, So = 0, as = null, aa = jn.next(); oi !== null && !aa.done; So++, aa = jn.next()) {
          oi.index > So ? (as = oi, oi = null) : as = oi.sibling;
          var sa = ne(be, oi, aa.value, We);
          if (sa === null) {
            oi === null && (oi = as);
            break;
          }
          i && oi && sa.alternate === null && o(be, oi), Bo = C(sa, Bo, So), zn === null ? di = sa : zn.sibling = sa, zn = sa, oi = as;
        }
        if (aa.done) {
          if (d(be, oi), po()) {
            var Fo = So;
            Jf(be, Fo);
          }
          return di;
        }
        if (oi === null) {
          for (; !aa.done; So++, aa = jn.next()) {
            var _u = ae(be, aa.value, We);
            _u !== null && (Bo = C(_u, Bo, So), zn === null ? di = _u : zn.sibling = _u, zn = _u);
          }
          if (po()) {
            var Cg = So;
            Jf(be, Cg);
          }
          return di;
        }
        for (var xy = h(be, oi); !aa.done; So++, aa = jn.next()) {
          var yc = Ce(xy, be, So, aa.value, We);
          yc !== null && (i && yc.alternate !== null && xy.delete(yc.key === null ? So : yc.key), Bo = C(yc, Bo, So), zn === null ? di = yc : zn.sibling = yc, zn = yc);
        }
        if (i && xy.forEach(function(M7) {
          return o(be, M7);
        }), po()) {
          var $7 = So;
          Jf(be, $7);
        }
        return di;
      }
      function Ot(be, Oe, Se, We) {
        if (Oe !== null && Oe.tag === _) {
          d(be, Oe.sibling);
          var dt = b(Oe, Se);
          return dt.return = be, dt;
        }
        d(be, Oe);
        var at = oT(Se, be.mode, We);
        return at.return = be, at;
      }
      function Pt(be, Oe, Se, We) {
        for (var dt = Se.key, at = Oe; at !== null; ) {
          if (at.key === dt) {
            var Bt = Se.type;
            if (Bt === Ri) {
              if (at.tag === T) {
                d(be, at.sibling);
                var Zt = b(at, Se.props.children);
                return Zt.return = be, Zt._debugSource = Se._source, Zt._debugOwner = Se._owner, Zt;
              }
            } else if (at.elementType === Bt || // Keep this check inline so it only runs on the false path:
            FM(at, Se) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof Bt == "object" && Bt !== null && Bt.$$typeof === Rt && QR(Bt) === at.type) {
              d(be, at.sibling);
              var er = b(at, Se.props);
              return er.ref = Kv(be, at, Se), er.return = be, er._debugSource = Se._source, er._debugOwner = Se._owner, er;
            }
            d(be, at);
            break;
          } else
            o(be, at);
          at = at.sibling;
        }
        if (Se.type === Ri) {
          var jn = Nd(Se.props.children, be.mode, We, Se.key);
          return jn.return = be, jn;
        } else {
          var di = iT(Se, be.mode, We);
          return di.ref = Kv(be, Oe, Se), di.return = be, di;
        }
      }
      function _n(be, Oe, Se, We) {
        for (var dt = Se.key, at = Oe; at !== null; ) {
          if (at.key === dt)
            if (at.tag === S && at.stateNode.containerInfo === Se.containerInfo && at.stateNode.implementation === Se.implementation) {
              d(be, at.sibling);
              var Bt = b(at, Se.children || []);
              return Bt.return = be, Bt;
            } else {
              d(be, at);
              break;
            }
          else
            o(be, at);
          at = at.sibling;
        }
        var Zt = aT(Se, be.mode, We);
        return Zt.return = be, Zt;
      }
      function vn(be, Oe, Se, We) {
        var dt = typeof Se == "object" && Se !== null && Se.type === Ri && Se.key === null;
        if (dt && (Se = Se.props.children), typeof Se == "object" && Se !== null) {
          switch (Se.$$typeof) {
            case Sa:
              return R(Pt(be, Oe, Se, We));
            case vi:
              return R(_n(be, Oe, Se, We));
            case Rt:
              var at = Se._payload, Bt = Se._init;
              return vn(be, Oe, Bt(at), We);
          }
          if (Sn(Se))
            return Ae(be, Oe, Se, We);
          if (Wo(Se))
            return ut(be, Oe, Se, We);
          RS(be, Se);
        }
        return typeof Se == "string" && Se !== "" || typeof Se == "number" ? R(Ot(be, Oe, "" + Se, We)) : (typeof Se == "function" && $S(be), d(be, Oe));
      }
      return vn;
    }
    var lg = ZR(!0), JR = ZR(!1);
    function bB(i, o) {
      if (i !== null && o.child !== i.child)
        throw new Error("Resuming work not yet implemented.");
      if (o.child !== null) {
        var d = o.child, h = fp(d, d.pendingProps);
        for (o.child = h, h.return = o; d.sibling !== null; )
          d = d.sibling, h = h.sibling = fp(d, d.pendingProps), h.return = o;
        h.sibling = null;
      }
    }
    function SB(i, o) {
      for (var d = i.child; d !== null; )
        XF(d, o), d = d.sibling;
    }
    var Wv = {}, kd = xd(Wv), Gv = xd(Wv), MS = xd(Wv);
    function AS(i) {
      if (i === Wv)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return i;
    }
    function e$() {
      var i = AS(MS.current);
      return i;
    }
    function AC(i, o) {
      zo(MS, o, i), zo(Gv, i, i), zo(kd, Wv, i);
      var d = O6(o);
      jo(kd, i), zo(kd, d, i);
    }
    function cg(i) {
      jo(kd, i), jo(Gv, i), jo(MS, i);
    }
    function OC() {
      var i = AS(kd.current);
      return i;
    }
    function t$(i) {
      AS(MS.current);
      var o = AS(kd.current), d = D6(o, i.type);
      o !== d && (zo(Gv, i, i), zo(kd, d, i));
    }
    function DC(i) {
      Gv.current === i && (jo(kd, i), jo(Gv, i));
    }
    var wB = 0, n$ = 1, r$ = 1, Xv = 2, bl = xd(wB);
    function NC(i, o) {
      return (i & o) !== 0;
    }
    function ug(i) {
      return i & n$;
    }
    function LC(i, o) {
      return i & n$ | o;
    }
    function xB(i, o) {
      return i | o;
    }
    function Pd(i, o) {
      zo(bl, o, i);
    }
    function dg(i) {
      jo(bl, i);
    }
    function EB(i, o) {
      var d = i.memoizedState;
      return d !== null ? d.dehydrated !== null : (i.memoizedProps, !0);
    }
    function OS(i) {
      for (var o = i; o !== null; ) {
        if (o.tag === z) {
          var d = o.memoizedState;
          if (d !== null) {
            var h = d.dehydrated;
            if (h === null || pR(h) || HE(h))
              return o;
          }
        } else if (o.tag === pe && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        o.memoizedProps.revealOrder !== void 0) {
          var b = (o.flags & Ht) !== Mt;
          if (b)
            return o;
        } else if (o.child !== null) {
          o.child.return = o, o = o.child;
          continue;
        }
        if (o === i)
          return null;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === i)
            return null;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
      return null;
    }
    var La = (
      /*   */
      0
    ), Di = (
      /* */
      1
    ), dc = (
      /*  */
      2
    ), Ni = (
      /*    */
      4
    ), ho = (
      /*   */
      8
    ), jC = [];
    function zC() {
      for (var i = 0; i < jC.length; i++) {
        var o = jC[i];
        o._workInProgressVersionPrimary = null;
      }
      jC.length = 0;
    }
    function CB(i, o) {
      var d = o._getVersion, h = d(o._source);
      i.mutableSourceEagerHydrationData == null ? i.mutableSourceEagerHydrationData = [o, h] : i.mutableSourceEagerHydrationData.push(o, h);
    }
    var ct = n.ReactCurrentDispatcher, qv = n.ReactCurrentBatchConfig, UC, fg;
    UC = /* @__PURE__ */ new Set();
    var op = Ne, Jn = null, Li = null, ji = null, DS = !1, Qv = !1, Zv = 0, _B = 0, TB = 25, je = null, Os = null, Id = -1, BC = !1;
    function Yn() {
      {
        var i = je;
        Os === null ? Os = [i] : Os.push(i);
      }
    }
    function nt() {
      {
        var i = je;
        Os !== null && (Id++, Os[Id] !== i && kB(i));
      }
    }
    function pg(i) {
      i != null && !Sn(i) && c("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", je, typeof i);
    }
    function kB(i) {
      {
        var o = Ft(Jn);
        if (!UC.has(o) && (UC.add(o), Os !== null)) {
          for (var d = "", h = 30, b = 0; b <= Id; b++) {
            for (var C = Os[b], R = b === Id ? i : C, A = b + 1 + ". " + C; A.length < h; )
              A += " ";
            A += R + `
`, d += A;
          }
          c(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, o, d);
        }
      }
    }
    function Uo() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function FC(i, o) {
      if (BC)
        return !1;
      if (o === null)
        return c("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", je), !1;
      i.length !== o.length && c(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, je, "[" + o.join(", ") + "]", "[" + i.join(", ") + "]");
      for (var d = 0; d < o.length && d < i.length; d++)
        if (!mt(i[d], o[d]))
          return !1;
      return !0;
    }
    function hg(i, o, d, h, b, C) {
      op = C, Jn = o, Os = i !== null ? i._debugHookTypes : null, Id = -1, BC = i !== null && i.type !== o.type, o.memoizedState = null, o.updateQueue = null, o.lanes = Ne, i !== null && i.memoizedState !== null ? ct.current = _$ : Os !== null ? ct.current = C$ : ct.current = E$;
      var R = d(h, b);
      if (Qv) {
        var A = 0;
        do {
          if (Qv = !1, Zv = 0, A >= TB)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          A += 1, BC = !1, Li = null, ji = null, o.updateQueue = null, Id = -1, ct.current = T$, R = d(h, b);
        } while (Qv);
      }
      ct.current = GS, o._debugHookTypes = Os;
      var B = Li !== null && Li.next !== null;
      if (op = Ne, Jn = null, Li = null, ji = null, je = null, Os = null, Id = -1, i !== null && (i.flags & Mi) !== (o.flags & Mi) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (i.mode & fn) !== Dt && c("Internal React error: Expected static flag was missing. Please notify the React team."), DS = !1, B)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return R;
    }
    function gg() {
      var i = Zv !== 0;
      return Zv = 0, i;
    }
    function i$(i, o, d) {
      o.updateQueue = i.updateQueue, (o.mode & Ia) !== Dt ? o.flags &= ~(Wc | Mo | kr | on) : o.flags &= ~(kr | on), i.lanes = od(i.lanes, d);
    }
    function o$() {
      if (ct.current = GS, DS) {
        for (var i = Jn.memoizedState; i !== null; ) {
          var o = i.queue;
          o !== null && (o.pending = null), i = i.next;
        }
        DS = !1;
      }
      op = Ne, Jn = null, Li = null, ji = null, Os = null, Id = -1, je = null, y$ = !1, Qv = !1, Zv = 0;
    }
    function fc() {
      var i = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return ji === null ? Jn.memoizedState = ji = i : ji = ji.next = i, ji;
    }
    function Ds() {
      var i;
      if (Li === null) {
        var o = Jn.alternate;
        o !== null ? i = o.memoizedState : i = null;
      } else
        i = Li.next;
      var d;
      if (ji === null ? d = Jn.memoizedState : d = ji.next, d !== null)
        ji = d, d = ji.next, Li = i;
      else {
        if (i === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Li = i;
        var h = {
          memoizedState: Li.memoizedState,
          baseState: Li.baseState,
          baseQueue: Li.baseQueue,
          queue: Li.queue,
          next: null
        };
        ji === null ? Jn.memoizedState = ji = h : ji = ji.next = h;
      }
      return ji;
    }
    function a$() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function HC(i, o) {
      return typeof o == "function" ? o(i) : o;
    }
    function VC(i, o, d) {
      var h = fc(), b;
      d !== void 0 ? b = d(o) : b = o, h.memoizedState = h.baseState = b;
      var C = {
        pending: null,
        interleaved: null,
        lanes: Ne,
        dispatch: null,
        lastRenderedReducer: i,
        lastRenderedState: b
      };
      h.queue = C;
      var R = C.dispatch = $B.bind(null, Jn, C);
      return [h.memoizedState, R];
    }
    function YC(i, o, d) {
      var h = Ds(), b = h.queue;
      if (b === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      b.lastRenderedReducer = i;
      var C = Li, R = C.baseQueue, A = b.pending;
      if (A !== null) {
        if (R !== null) {
          var B = R.next, V = A.next;
          R.next = V, A.next = B;
        }
        C.baseQueue !== R && c("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), C.baseQueue = R = A, b.pending = null;
      }
      if (R !== null) {
        var G = R.next, ae = C.baseState, ne = null, Ce = null, _e = null, Ae = G;
        do {
          var ut = Ae.lane;
          if (ru(op, ut)) {
            if (_e !== null) {
              var Pt = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: En,
                action: Ae.action,
                hasEagerState: Ae.hasEagerState,
                eagerState: Ae.eagerState,
                next: null
              };
              _e = _e.next = Pt;
            }
            if (Ae.hasEagerState)
              ae = Ae.eagerState;
            else {
              var _n = Ae.action;
              ae = i(ae, _n);
            }
          } else {
            var Ot = {
              lane: ut,
              action: Ae.action,
              hasEagerState: Ae.hasEagerState,
              eagerState: Ae.eagerState,
              next: null
            };
            _e === null ? (Ce = _e = Ot, ne = ae) : _e = _e.next = Ot, Jn.lanes = an(Jn.lanes, ut), vy(ut);
          }
          Ae = Ae.next;
        } while (Ae !== null && Ae !== G);
        _e === null ? ne = ae : _e.next = Ce, mt(ae, h.memoizedState) || oy(), h.memoizedState = ae, h.baseState = ne, h.baseQueue = _e, b.lastRenderedState = ae;
      }
      var vn = b.interleaved;
      if (vn !== null) {
        var be = vn;
        do {
          var Oe = be.lane;
          Jn.lanes = an(Jn.lanes, Oe), vy(Oe), be = be.next;
        } while (be !== vn);
      } else
        R === null && (b.lanes = Ne);
      var Se = b.dispatch;
      return [h.memoizedState, Se];
    }
    function KC(i, o, d) {
      var h = Ds(), b = h.queue;
      if (b === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      b.lastRenderedReducer = i;
      var C = b.dispatch, R = b.pending, A = h.memoizedState;
      if (R !== null) {
        b.pending = null;
        var B = R.next, V = B;
        do {
          var G = V.action;
          A = i(A, G), V = V.next;
        } while (V !== B);
        mt(A, h.memoizedState) || oy(), h.memoizedState = A, h.baseQueue === null && (h.baseState = A), b.lastRenderedState = A;
      }
      return [A, C];
    }
    function kpe(i, o, d) {
    }
    function Ppe(i, o, d) {
    }
    function WC(i, o, d) {
      var h = Jn, b = fc(), C, R = po();
      if (R) {
        if (d === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        C = d(), fg || C !== d() && (c("The result of getServerSnapshot should be cached to avoid an infinite loop"), fg = !0);
      } else {
        if (C = o(), !fg) {
          var A = o();
          mt(C, A) || (c("The result of getSnapshot should be cached to avoid an infinite loop"), fg = !0);
        }
        var B = fw();
        if (B === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Nf(B, op) || s$(h, o, C);
      }
      b.memoizedState = C;
      var V = {
        value: C,
        getSnapshot: o
      };
      return b.queue = V, US(c$.bind(null, h, V, i), [i]), h.flags |= kr, Jv(Di | ho, l$.bind(null, h, V, C, o), void 0, null), C;
    }
    function NS(i, o, d) {
      var h = Jn, b = Ds(), C = o();
      if (!fg) {
        var R = o();
        mt(C, R) || (c("The result of getSnapshot should be cached to avoid an infinite loop"), fg = !0);
      }
      var A = b.memoizedState, B = !mt(A, C);
      B && (b.memoizedState = C, oy());
      var V = b.queue;
      if (ty(c$.bind(null, h, V, i), [i]), V.getSnapshot !== o || B || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      ji !== null && ji.memoizedState.tag & Di) {
        h.flags |= kr, Jv(Di | ho, l$.bind(null, h, V, C, o), void 0, null);
        var G = fw();
        if (G === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Nf(G, op) || s$(h, o, C);
      }
      return C;
    }
    function s$(i, o, d) {
      i.flags |= kf;
      var h = {
        getSnapshot: o,
        value: d
      }, b = Jn.updateQueue;
      if (b === null)
        b = a$(), Jn.updateQueue = b, b.stores = [h];
      else {
        var C = b.stores;
        C === null ? b.stores = [h] : C.push(h);
      }
    }
    function l$(i, o, d, h) {
      o.value = d, o.getSnapshot = h, u$(o) && d$(i);
    }
    function c$(i, o, d) {
      var h = function() {
        u$(o) && d$(i);
      };
      return d(h);
    }
    function u$(i) {
      var o = i.getSnapshot, d = i.value;
      try {
        var h = o();
        return !mt(d, h);
      } catch {
        return !0;
      }
    }
    function d$(i) {
      var o = Na(i, jt);
      o !== null && Fi(o, i, jt, lr);
    }
    function LS(i) {
      var o = fc();
      typeof i == "function" && (i = i()), o.memoizedState = o.baseState = i;
      var d = {
        pending: null,
        interleaved: null,
        lanes: Ne,
        dispatch: null,
        lastRenderedReducer: HC,
        lastRenderedState: i
      };
      o.queue = d;
      var h = d.dispatch = MB.bind(null, Jn, d);
      return [o.memoizedState, h];
    }
    function GC(i) {
      return YC(HC);
    }
    function XC(i) {
      return KC(HC);
    }
    function Jv(i, o, d, h) {
      var b = {
        tag: i,
        create: o,
        destroy: d,
        deps: h,
        // Circular
        next: null
      }, C = Jn.updateQueue;
      if (C === null)
        C = a$(), Jn.updateQueue = C, C.lastEffect = b.next = b;
      else {
        var R = C.lastEffect;
        if (R === null)
          C.lastEffect = b.next = b;
        else {
          var A = R.next;
          R.next = b, b.next = A, C.lastEffect = b;
        }
      }
      return b;
    }
    function qC(i) {
      var o = fc();
      {
        var d = {
          current: i
        };
        return o.memoizedState = d, d;
      }
    }
    function jS(i) {
      var o = Ds();
      return o.memoizedState;
    }
    function ey(i, o, d, h) {
      var b = fc(), C = h === void 0 ? null : h;
      Jn.flags |= i, b.memoizedState = Jv(Di | o, d, void 0, C);
    }
    function zS(i, o, d, h) {
      var b = Ds(), C = h === void 0 ? null : h, R = void 0;
      if (Li !== null) {
        var A = Li.memoizedState;
        if (R = A.destroy, C !== null) {
          var B = A.deps;
          if (FC(C, B)) {
            b.memoizedState = Jv(o, d, R, C);
            return;
          }
        }
      }
      Jn.flags |= i, b.memoizedState = Jv(Di | o, d, R, C);
    }
    function US(i, o) {
      return (Jn.mode & Ia) !== Dt ? ey(Wc | kr | Gl, ho, i, o) : ey(kr | Gl, ho, i, o);
    }
    function ty(i, o) {
      return zS(kr, ho, i, o);
    }
    function QC(i, o) {
      return ey(on, dc, i, o);
    }
    function BS(i, o) {
      return zS(on, dc, i, o);
    }
    function ZC(i, o) {
      var d = on;
      return d |= $o, (Jn.mode & Ia) !== Dt && (d |= Mo), ey(d, Ni, i, o);
    }
    function FS(i, o) {
      return zS(on, Ni, i, o);
    }
    function f$(i, o) {
      if (typeof o == "function") {
        var d = o, h = i();
        return d(h), function() {
          d(null);
        };
      } else if (o != null) {
        var b = o;
        b.hasOwnProperty("current") || c("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(b).join(", ") + "}");
        var C = i();
        return b.current = C, function() {
          b.current = null;
        };
      }
    }
    function JC(i, o, d) {
      typeof o != "function" && c("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", o !== null ? typeof o : "null");
      var h = d != null ? d.concat([i]) : null, b = on;
      return b |= $o, (Jn.mode & Ia) !== Dt && (b |= Mo), ey(b, Ni, f$.bind(null, o, i), h);
    }
    function HS(i, o, d) {
      typeof o != "function" && c("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", o !== null ? typeof o : "null");
      var h = d != null ? d.concat([i]) : null;
      return zS(on, Ni, f$.bind(null, o, i), h);
    }
    function PB(i, o) {
    }
    var VS = PB;
    function e_(i, o) {
      var d = fc(), h = o === void 0 ? null : o;
      return d.memoizedState = [i, h], i;
    }
    function YS(i, o) {
      var d = Ds(), h = o === void 0 ? null : o, b = d.memoizedState;
      if (b !== null && h !== null) {
        var C = b[1];
        if (FC(h, C))
          return b[0];
      }
      return d.memoizedState = [i, h], i;
    }
    function t_(i, o) {
      var d = fc(), h = o === void 0 ? null : o, b = i();
      return d.memoizedState = [b, h], b;
    }
    function KS(i, o) {
      var d = Ds(), h = o === void 0 ? null : o, b = d.memoizedState;
      if (b !== null && h !== null) {
        var C = b[1];
        if (FC(h, C))
          return b[0];
      }
      var R = i();
      return d.memoizedState = [R, h], R;
    }
    function n_(i) {
      var o = fc();
      return o.memoizedState = i, i;
    }
    function p$(i) {
      var o = Ds(), d = Li, h = d.memoizedState;
      return g$(o, h, i);
    }
    function h$(i) {
      var o = Ds();
      if (Li === null)
        return o.memoizedState = i, i;
      var d = Li.memoizedState;
      return g$(o, d, i);
    }
    function g$(i, o, d) {
      var h = !lE(op);
      if (h) {
        if (!mt(d, o)) {
          var b = nv();
          Jn.lanes = an(Jn.lanes, b), vy(b), i.baseState = !0;
        }
        return o;
      } else
        return i.baseState && (i.baseState = !1, oy()), i.memoizedState = d, d;
    }
    function IB(i, o, d) {
      var h = $a();
      li(qi(h, Oi)), i(!0);
      var b = qv.transition;
      qv.transition = {};
      var C = qv.transition;
      qv.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        i(!1), o();
      } finally {
        if (li(h), qv.transition = b, b === null && C._updatedFibers) {
          var R = C._updatedFibers.size;
          R > 10 && s("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), C._updatedFibers.clear();
        }
      }
    }
    function r_() {
      var i = LS(!1), o = i[0], d = i[1], h = IB.bind(null, d), b = fc();
      return b.memoizedState = h, [o, h];
    }
    function m$() {
      var i = GC(), o = i[0], d = Ds(), h = d.memoizedState;
      return [o, h];
    }
    function v$() {
      var i = XC(), o = i[0], d = Ds(), h = d.memoizedState;
      return [o, h];
    }
    var y$ = !1;
    function RB() {
      return y$;
    }
    function i_() {
      var i = fc(), o = fw(), d = o.identifierPrefix, h;
      if (po()) {
        var b = VU();
        h = ":" + d + "R" + b;
        var C = Zv++;
        C > 0 && (h += "H" + C.toString(32)), h += ":";
      } else {
        var R = _B++;
        h = ":" + d + "r" + R.toString(32) + ":";
      }
      return i.memoizedState = h, h;
    }
    function WS() {
      var i = Ds(), o = i.memoizedState;
      return o;
    }
    function $B(i, o, d) {
      typeof arguments[3] == "function" && c("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var h = Od(i), b = {
        lane: h,
        action: d,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (b$(i))
        S$(o, b);
      else {
        var C = LR(i, o, b, h);
        if (C !== null) {
          var R = oa();
          Fi(C, i, h, R), w$(C, o, h);
        }
      }
      x$(i, h);
    }
    function MB(i, o, d) {
      typeof arguments[3] == "function" && c("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var h = Od(i), b = {
        lane: h,
        action: d,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (b$(i))
        S$(o, b);
      else {
        var C = i.alternate;
        if (i.lanes === Ne && (C === null || C.lanes === Ne)) {
          var R = o.lastRenderedReducer;
          if (R !== null) {
            var A;
            A = ct.current, ct.current = Sl;
            try {
              var B = o.lastRenderedState, V = R(B, d);
              if (b.hasEagerState = !0, b.eagerState = V, mt(V, B)) {
                uB(i, o, b, h);
                return;
              }
            } catch {
            } finally {
              ct.current = A;
            }
          }
        }
        var G = LR(i, o, b, h);
        if (G !== null) {
          var ae = oa();
          Fi(G, i, h, ae), w$(G, o, h);
        }
      }
      x$(i, h);
    }
    function b$(i) {
      var o = i.alternate;
      return i === Jn || o !== null && o === Jn;
    }
    function S$(i, o) {
      Qv = DS = !0;
      var d = i.pending;
      d === null ? o.next = o : (o.next = d.next, d.next = o), i.pending = o;
    }
    function w$(i, o, d) {
      if (tv(d)) {
        var h = o.lanes;
        h = rv(h, i.pendingLanes);
        var b = an(h, d);
        o.lanes = b, ad(i, b);
      }
    }
    function x$(i, o, d) {
      ec(i, o);
    }
    var GS = {
      readContext: ki,
      useCallback: Uo,
      useContext: Uo,
      useEffect: Uo,
      useImperativeHandle: Uo,
      useInsertionEffect: Uo,
      useLayoutEffect: Uo,
      useMemo: Uo,
      useReducer: Uo,
      useRef: Uo,
      useState: Uo,
      useDebugValue: Uo,
      useDeferredValue: Uo,
      useTransition: Uo,
      useMutableSource: Uo,
      useSyncExternalStore: Uo,
      useId: Uo,
      unstable_isNewReconciler: te
    }, E$ = null, C$ = null, _$ = null, T$ = null, pc = null, Sl = null, XS = null;
    {
      var o_ = function() {
        c("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, Wt = function() {
        c("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      E$ = {
        readContext: function(i) {
          return ki(i);
        },
        useCallback: function(i, o) {
          return je = "useCallback", Yn(), pg(o), e_(i, o);
        },
        useContext: function(i) {
          return je = "useContext", Yn(), ki(i);
        },
        useEffect: function(i, o) {
          return je = "useEffect", Yn(), pg(o), US(i, o);
        },
        useImperativeHandle: function(i, o, d) {
          return je = "useImperativeHandle", Yn(), pg(d), JC(i, o, d);
        },
        useInsertionEffect: function(i, o) {
          return je = "useInsertionEffect", Yn(), pg(o), QC(i, o);
        },
        useLayoutEffect: function(i, o) {
          return je = "useLayoutEffect", Yn(), pg(o), ZC(i, o);
        },
        useMemo: function(i, o) {
          je = "useMemo", Yn(), pg(o);
          var d = ct.current;
          ct.current = pc;
          try {
            return t_(i, o);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(i, o, d) {
          je = "useReducer", Yn();
          var h = ct.current;
          ct.current = pc;
          try {
            return VC(i, o, d);
          } finally {
            ct.current = h;
          }
        },
        useRef: function(i) {
          return je = "useRef", Yn(), qC(i);
        },
        useState: function(i) {
          je = "useState", Yn();
          var o = ct.current;
          ct.current = pc;
          try {
            return LS(i);
          } finally {
            ct.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return je = "useDebugValue", Yn(), void 0;
        },
        useDeferredValue: function(i) {
          return je = "useDeferredValue", Yn(), n_(i);
        },
        useTransition: function() {
          return je = "useTransition", Yn(), r_();
        },
        useMutableSource: function(i, o, d) {
          return je = "useMutableSource", Yn(), void 0;
        },
        useSyncExternalStore: function(i, o, d) {
          return je = "useSyncExternalStore", Yn(), WC(i, o, d);
        },
        useId: function() {
          return je = "useId", Yn(), i_();
        },
        unstable_isNewReconciler: te
      }, C$ = {
        readContext: function(i) {
          return ki(i);
        },
        useCallback: function(i, o) {
          return je = "useCallback", nt(), e_(i, o);
        },
        useContext: function(i) {
          return je = "useContext", nt(), ki(i);
        },
        useEffect: function(i, o) {
          return je = "useEffect", nt(), US(i, o);
        },
        useImperativeHandle: function(i, o, d) {
          return je = "useImperativeHandle", nt(), JC(i, o, d);
        },
        useInsertionEffect: function(i, o) {
          return je = "useInsertionEffect", nt(), QC(i, o);
        },
        useLayoutEffect: function(i, o) {
          return je = "useLayoutEffect", nt(), ZC(i, o);
        },
        useMemo: function(i, o) {
          je = "useMemo", nt();
          var d = ct.current;
          ct.current = pc;
          try {
            return t_(i, o);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(i, o, d) {
          je = "useReducer", nt();
          var h = ct.current;
          ct.current = pc;
          try {
            return VC(i, o, d);
          } finally {
            ct.current = h;
          }
        },
        useRef: function(i) {
          return je = "useRef", nt(), qC(i);
        },
        useState: function(i) {
          je = "useState", nt();
          var o = ct.current;
          ct.current = pc;
          try {
            return LS(i);
          } finally {
            ct.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return je = "useDebugValue", nt(), void 0;
        },
        useDeferredValue: function(i) {
          return je = "useDeferredValue", nt(), n_(i);
        },
        useTransition: function() {
          return je = "useTransition", nt(), r_();
        },
        useMutableSource: function(i, o, d) {
          return je = "useMutableSource", nt(), void 0;
        },
        useSyncExternalStore: function(i, o, d) {
          return je = "useSyncExternalStore", nt(), WC(i, o, d);
        },
        useId: function() {
          return je = "useId", nt(), i_();
        },
        unstable_isNewReconciler: te
      }, _$ = {
        readContext: function(i) {
          return ki(i);
        },
        useCallback: function(i, o) {
          return je = "useCallback", nt(), YS(i, o);
        },
        useContext: function(i) {
          return je = "useContext", nt(), ki(i);
        },
        useEffect: function(i, o) {
          return je = "useEffect", nt(), ty(i, o);
        },
        useImperativeHandle: function(i, o, d) {
          return je = "useImperativeHandle", nt(), HS(i, o, d);
        },
        useInsertionEffect: function(i, o) {
          return je = "useInsertionEffect", nt(), BS(i, o);
        },
        useLayoutEffect: function(i, o) {
          return je = "useLayoutEffect", nt(), FS(i, o);
        },
        useMemo: function(i, o) {
          je = "useMemo", nt();
          var d = ct.current;
          ct.current = Sl;
          try {
            return KS(i, o);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(i, o, d) {
          je = "useReducer", nt();
          var h = ct.current;
          ct.current = Sl;
          try {
            return YC(i, o, d);
          } finally {
            ct.current = h;
          }
        },
        useRef: function(i) {
          return je = "useRef", nt(), jS();
        },
        useState: function(i) {
          je = "useState", nt();
          var o = ct.current;
          ct.current = Sl;
          try {
            return GC(i);
          } finally {
            ct.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return je = "useDebugValue", nt(), VS();
        },
        useDeferredValue: function(i) {
          return je = "useDeferredValue", nt(), p$(i);
        },
        useTransition: function() {
          return je = "useTransition", nt(), m$();
        },
        useMutableSource: function(i, o, d) {
          return je = "useMutableSource", nt(), void 0;
        },
        useSyncExternalStore: function(i, o, d) {
          return je = "useSyncExternalStore", nt(), NS(i, o);
        },
        useId: function() {
          return je = "useId", nt(), WS();
        },
        unstable_isNewReconciler: te
      }, T$ = {
        readContext: function(i) {
          return ki(i);
        },
        useCallback: function(i, o) {
          return je = "useCallback", nt(), YS(i, o);
        },
        useContext: function(i) {
          return je = "useContext", nt(), ki(i);
        },
        useEffect: function(i, o) {
          return je = "useEffect", nt(), ty(i, o);
        },
        useImperativeHandle: function(i, o, d) {
          return je = "useImperativeHandle", nt(), HS(i, o, d);
        },
        useInsertionEffect: function(i, o) {
          return je = "useInsertionEffect", nt(), BS(i, o);
        },
        useLayoutEffect: function(i, o) {
          return je = "useLayoutEffect", nt(), FS(i, o);
        },
        useMemo: function(i, o) {
          je = "useMemo", nt();
          var d = ct.current;
          ct.current = XS;
          try {
            return KS(i, o);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(i, o, d) {
          je = "useReducer", nt();
          var h = ct.current;
          ct.current = XS;
          try {
            return KC(i, o, d);
          } finally {
            ct.current = h;
          }
        },
        useRef: function(i) {
          return je = "useRef", nt(), jS();
        },
        useState: function(i) {
          je = "useState", nt();
          var o = ct.current;
          ct.current = XS;
          try {
            return XC(i);
          } finally {
            ct.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return je = "useDebugValue", nt(), VS();
        },
        useDeferredValue: function(i) {
          return je = "useDeferredValue", nt(), h$(i);
        },
        useTransition: function() {
          return je = "useTransition", nt(), v$();
        },
        useMutableSource: function(i, o, d) {
          return je = "useMutableSource", nt(), void 0;
        },
        useSyncExternalStore: function(i, o, d) {
          return je = "useSyncExternalStore", nt(), NS(i, o);
        },
        useId: function() {
          return je = "useId", nt(), WS();
        },
        unstable_isNewReconciler: te
      }, pc = {
        readContext: function(i) {
          return o_(), ki(i);
        },
        useCallback: function(i, o) {
          return je = "useCallback", Wt(), Yn(), e_(i, o);
        },
        useContext: function(i) {
          return je = "useContext", Wt(), Yn(), ki(i);
        },
        useEffect: function(i, o) {
          return je = "useEffect", Wt(), Yn(), US(i, o);
        },
        useImperativeHandle: function(i, o, d) {
          return je = "useImperativeHandle", Wt(), Yn(), JC(i, o, d);
        },
        useInsertionEffect: function(i, o) {
          return je = "useInsertionEffect", Wt(), Yn(), QC(i, o);
        },
        useLayoutEffect: function(i, o) {
          return je = "useLayoutEffect", Wt(), Yn(), ZC(i, o);
        },
        useMemo: function(i, o) {
          je = "useMemo", Wt(), Yn();
          var d = ct.current;
          ct.current = pc;
          try {
            return t_(i, o);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(i, o, d) {
          je = "useReducer", Wt(), Yn();
          var h = ct.current;
          ct.current = pc;
          try {
            return VC(i, o, d);
          } finally {
            ct.current = h;
          }
        },
        useRef: function(i) {
          return je = "useRef", Wt(), Yn(), qC(i);
        },
        useState: function(i) {
          je = "useState", Wt(), Yn();
          var o = ct.current;
          ct.current = pc;
          try {
            return LS(i);
          } finally {
            ct.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return je = "useDebugValue", Wt(), Yn(), void 0;
        },
        useDeferredValue: function(i) {
          return je = "useDeferredValue", Wt(), Yn(), n_(i);
        },
        useTransition: function() {
          return je = "useTransition", Wt(), Yn(), r_();
        },
        useMutableSource: function(i, o, d) {
          return je = "useMutableSource", Wt(), Yn(), void 0;
        },
        useSyncExternalStore: function(i, o, d) {
          return je = "useSyncExternalStore", Wt(), Yn(), WC(i, o, d);
        },
        useId: function() {
          return je = "useId", Wt(), Yn(), i_();
        },
        unstable_isNewReconciler: te
      }, Sl = {
        readContext: function(i) {
          return o_(), ki(i);
        },
        useCallback: function(i, o) {
          return je = "useCallback", Wt(), nt(), YS(i, o);
        },
        useContext: function(i) {
          return je = "useContext", Wt(), nt(), ki(i);
        },
        useEffect: function(i, o) {
          return je = "useEffect", Wt(), nt(), ty(i, o);
        },
        useImperativeHandle: function(i, o, d) {
          return je = "useImperativeHandle", Wt(), nt(), HS(i, o, d);
        },
        useInsertionEffect: function(i, o) {
          return je = "useInsertionEffect", Wt(), nt(), BS(i, o);
        },
        useLayoutEffect: function(i, o) {
          return je = "useLayoutEffect", Wt(), nt(), FS(i, o);
        },
        useMemo: function(i, o) {
          je = "useMemo", Wt(), nt();
          var d = ct.current;
          ct.current = Sl;
          try {
            return KS(i, o);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(i, o, d) {
          je = "useReducer", Wt(), nt();
          var h = ct.current;
          ct.current = Sl;
          try {
            return YC(i, o, d);
          } finally {
            ct.current = h;
          }
        },
        useRef: function(i) {
          return je = "useRef", Wt(), nt(), jS();
        },
        useState: function(i) {
          je = "useState", Wt(), nt();
          var o = ct.current;
          ct.current = Sl;
          try {
            return GC(i);
          } finally {
            ct.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return je = "useDebugValue", Wt(), nt(), VS();
        },
        useDeferredValue: function(i) {
          return je = "useDeferredValue", Wt(), nt(), p$(i);
        },
        useTransition: function() {
          return je = "useTransition", Wt(), nt(), m$();
        },
        useMutableSource: function(i, o, d) {
          return je = "useMutableSource", Wt(), nt(), void 0;
        },
        useSyncExternalStore: function(i, o, d) {
          return je = "useSyncExternalStore", Wt(), nt(), NS(i, o);
        },
        useId: function() {
          return je = "useId", Wt(), nt(), WS();
        },
        unstable_isNewReconciler: te
      }, XS = {
        readContext: function(i) {
          return o_(), ki(i);
        },
        useCallback: function(i, o) {
          return je = "useCallback", Wt(), nt(), YS(i, o);
        },
        useContext: function(i) {
          return je = "useContext", Wt(), nt(), ki(i);
        },
        useEffect: function(i, o) {
          return je = "useEffect", Wt(), nt(), ty(i, o);
        },
        useImperativeHandle: function(i, o, d) {
          return je = "useImperativeHandle", Wt(), nt(), HS(i, o, d);
        },
        useInsertionEffect: function(i, o) {
          return je = "useInsertionEffect", Wt(), nt(), BS(i, o);
        },
        useLayoutEffect: function(i, o) {
          return je = "useLayoutEffect", Wt(), nt(), FS(i, o);
        },
        useMemo: function(i, o) {
          je = "useMemo", Wt(), nt();
          var d = ct.current;
          ct.current = Sl;
          try {
            return KS(i, o);
          } finally {
            ct.current = d;
          }
        },
        useReducer: function(i, o, d) {
          je = "useReducer", Wt(), nt();
          var h = ct.current;
          ct.current = Sl;
          try {
            return KC(i, o, d);
          } finally {
            ct.current = h;
          }
        },
        useRef: function(i) {
          return je = "useRef", Wt(), nt(), jS();
        },
        useState: function(i) {
          je = "useState", Wt(), nt();
          var o = ct.current;
          ct.current = Sl;
          try {
            return XC(i);
          } finally {
            ct.current = o;
          }
        },
        useDebugValue: function(i, o) {
          return je = "useDebugValue", Wt(), nt(), VS();
        },
        useDeferredValue: function(i) {
          return je = "useDeferredValue", Wt(), nt(), h$(i);
        },
        useTransition: function() {
          return je = "useTransition", Wt(), nt(), v$();
        },
        useMutableSource: function(i, o, d) {
          return je = "useMutableSource", Wt(), nt(), void 0;
        },
        useSyncExternalStore: function(i, o, d) {
          return je = "useSyncExternalStore", Wt(), nt(), NS(i, o);
        },
        useId: function() {
          return je = "useId", Wt(), nt(), WS();
        },
        unstable_isNewReconciler: te
      };
    }
    var Rd = e.unstable_now, k$ = 0, qS = -1, ny = -1, QS = -1, a_ = !1, ZS = !1;
    function P$() {
      return a_;
    }
    function AB() {
      ZS = !0;
    }
    function OB() {
      a_ = !1, ZS = !1;
    }
    function DB() {
      a_ = ZS, ZS = !1;
    }
    function I$() {
      return k$;
    }
    function R$() {
      k$ = Rd();
    }
    function s_(i) {
      ny = Rd(), i.actualStartTime < 0 && (i.actualStartTime = Rd());
    }
    function $$(i) {
      ny = -1;
    }
    function JS(i, o) {
      if (ny >= 0) {
        var d = Rd() - ny;
        i.actualDuration += d, o && (i.selfBaseDuration = d), ny = -1;
      }
    }
    function hc(i) {
      if (qS >= 0) {
        var o = Rd() - qS;
        qS = -1;
        for (var d = i.return; d !== null; ) {
          switch (d.tag) {
            case v:
              var h = d.stateNode;
              h.effectDuration += o;
              return;
            case L:
              var b = d.stateNode;
              b.effectDuration += o;
              return;
          }
          d = d.return;
        }
      }
    }
    function l_(i) {
      if (QS >= 0) {
        var o = Rd() - QS;
        QS = -1;
        for (var d = i.return; d !== null; ) {
          switch (d.tag) {
            case v:
              var h = d.stateNode;
              h !== null && (h.passiveEffectDuration += o);
              return;
            case L:
              var b = d.stateNode;
              b !== null && (b.passiveEffectDuration += o);
              return;
          }
          d = d.return;
        }
      }
    }
    function gc() {
      qS = Rd();
    }
    function c_() {
      QS = Rd();
    }
    function u_(i) {
      for (var o = i.child; o; )
        i.actualDuration += o.actualDuration, o = o.sibling;
    }
    function ap(i, o) {
      return {
        value: i,
        source: o,
        stack: Xo(o),
        digest: null
      };
    }
    function d_(i, o, d) {
      return {
        value: i,
        source: null,
        stack: d ?? null,
        digest: o ?? null
      };
    }
    function NB(i, o) {
      return !0;
    }
    function f_(i, o) {
      try {
        var d = NB(i, o);
        if (d === !1)
          return;
        var h = o.value, b = o.source, C = o.stack, R = C !== null ? C : "";
        if (h != null && h._suppressLogging) {
          if (i.tag === g)
            return;
          console.error(h);
        }
        var A = b ? Ft(b) : null, B = A ? "The above error occurred in the <" + A + "> component:" : "The above error occurred in one of your React components:", V;
        if (i.tag === v)
          V = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var G = Ft(i) || "Anonymous";
          V = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + G + ".");
        }
        var ae = B + `
` + R + `

` + ("" + V);
        console.error(ae);
      } catch (ne) {
        setTimeout(function() {
          throw ne;
        });
      }
    }
    var LB = typeof WeakMap == "function" ? WeakMap : Map;
    function M$(i, o, d) {
      var h = bu(lr, d);
      h.tag = fC, h.payload = {
        element: null
      };
      var b = o.value;
      return h.callback = function() {
        IF(b), f_(i, o);
      }, h;
    }
    function p_(i, o, d) {
      var h = bu(lr, d);
      h.tag = fC;
      var b = i.type.getDerivedStateFromError;
      if (typeof b == "function") {
        var C = o.value;
        h.payload = function() {
          return b(C);
        }, h.callback = function() {
          HM(i), f_(i, o);
        };
      }
      var R = i.stateNode;
      return R !== null && typeof R.componentDidCatch == "function" && (h.callback = function() {
        HM(i), f_(i, o), typeof b != "function" && kF(this);
        var B = o.value, V = o.stack;
        this.componentDidCatch(B, {
          componentStack: V !== null ? V : ""
        }), typeof b != "function" && (Lo(i.lanes, jt) || c("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", Ft(i) || "Unknown"));
      }), h;
    }
    function A$(i, o, d) {
      var h = i.pingCache, b;
      if (h === null ? (h = i.pingCache = new LB(), b = /* @__PURE__ */ new Set(), h.set(o, b)) : (b = h.get(o), b === void 0 && (b = /* @__PURE__ */ new Set(), h.set(o, b))), !b.has(d)) {
        b.add(d);
        var C = RF.bind(null, i, o, d);
        Ai && yy(i, d), o.then(C, C);
      }
    }
    function jB(i, o, d, h) {
      var b = i.updateQueue;
      if (b === null) {
        var C = /* @__PURE__ */ new Set();
        C.add(d), i.updateQueue = C;
      } else
        b.add(d);
    }
    function zB(i, o) {
      var d = i.tag;
      if ((i.mode & fn) === Dt && (d === p || d === j || d === K)) {
        var h = i.alternate;
        h ? (i.updateQueue = h.updateQueue, i.memoizedState = h.memoizedState, i.lanes = h.lanes) : (i.updateQueue = null, i.memoizedState = null);
      }
    }
    function O$(i) {
      var o = i;
      do {
        if (o.tag === z && EB(o))
          return o;
        o = o.return;
      } while (o !== null);
      return null;
    }
    function D$(i, o, d, h, b) {
      if ((i.mode & fn) === Dt) {
        if (i === o)
          i.flags |= xi;
        else {
          if (i.flags |= Ht, d.flags |= Pf, d.flags &= ~(eh | Qo), d.tag === g) {
            var C = d.alternate;
            if (C === null)
              d.tag = se;
            else {
              var R = bu(lr, jt);
              R.tag = ES, Td(d, R, jt);
            }
          }
          d.lanes = an(d.lanes, jt);
        }
        return i;
      }
      return i.flags |= xi, i.lanes = b, i;
    }
    function UB(i, o, d, h, b) {
      if (d.flags |= Qo, Ai && yy(i, b), h !== null && typeof h == "object" && typeof h.then == "function") {
        var C = h;
        zB(d), po() && d.mode & fn && _R();
        var R = O$(o);
        if (R !== null) {
          R.flags &= ~Fr, D$(R, o, d, i, b), R.mode & fn && A$(i, C, b), jB(R, i, C);
          return;
        } else {
          if (!id(b)) {
            A$(i, C, b), K_();
            return;
          }
          var A = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          h = A;
        }
      } else if (po() && d.mode & fn) {
        _R();
        var B = O$(o);
        if (B !== null) {
          (B.flags & xi) === Mt && (B.flags |= Fr), D$(B, o, d, i, b), oC(ap(h, d));
          return;
        }
      }
      h = ap(h, d), bF(h);
      var V = o;
      do {
        switch (V.tag) {
          case v: {
            var G = h;
            V.flags |= xi;
            var ae = si(b);
            V.lanes = an(V.lanes, ae);
            var ne = M$(V, G, ae);
            gC(V, ne);
            return;
          }
          case g:
            var Ce = h, _e = V.type, Ae = V.stateNode;
            if ((V.flags & Ht) === Mt && (typeof _e.getDerivedStateFromError == "function" || Ae !== null && typeof Ae.componentDidCatch == "function" && !OM(Ae))) {
              V.flags |= xi;
              var ut = si(b);
              V.lanes = an(V.lanes, ut);
              var Ot = p_(V, Ce, ut);
              gC(V, Ot);
              return;
            }
            break;
        }
        V = V.return;
      } while (V !== null);
    }
    function BB() {
      return null;
    }
    var ry = n.ReactCurrentOwner, wl = !1, h_, iy, g_, m_, v_, sp, y_, ew;
    h_ = {}, iy = {}, g_ = {}, m_ = {}, v_ = {}, sp = !1, y_ = {}, ew = {};
    function ra(i, o, d, h) {
      i === null ? o.child = JR(o, null, d, h) : o.child = lg(o, i.child, d, h);
    }
    function FB(i, o, d, h) {
      o.child = lg(o, i.child, null, h), o.child = lg(o, null, d, h);
    }
    function N$(i, o, d, h, b) {
      if (o.type !== o.elementType) {
        var C = d.propTypes;
        C && gl(
          C,
          h,
          // Resolved props
          "prop",
          rn(d)
        );
      }
      var R = d.render, A = o.ref, B, V;
      sg(o, b), Jl(o);
      {
        if (ry.current = o, Wi(!0), B = hg(i, o, R, h, A, b), V = gg(), o.mode & Or) {
          ai(!0);
          try {
            B = hg(i, o, R, h, A, b), V = gg();
          } finally {
            ai(!1);
          }
        }
        Wi(!1);
      }
      return Gc(), i !== null && !wl ? (i$(i, o, b), Su(i, o, b)) : (po() && V && JE(o), o.flags |= Kl, ra(i, o, B, b), o.child);
    }
    function L$(i, o, d, h, b) {
      if (i === null) {
        var C = d.type;
        if (WF(C) && d.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        d.defaultProps === void 0) {
          var R = C;
          return R = Eg(C), o.tag = K, o.type = R, w_(o, C), j$(i, o, R, h, b);
        }
        {
          var A = C.propTypes;
          A && gl(
            A,
            h,
            // Resolved props
            "prop",
            rn(C)
          );
        }
        var B = rT(d.type, null, h, o, o.mode, b);
        return B.ref = o.ref, B.return = o, o.child = B, B;
      }
      {
        var V = d.type, G = V.propTypes;
        G && gl(
          G,
          h,
          // Resolved props
          "prop",
          rn(V)
        );
      }
      var ae = i.child, ne = k_(i, b);
      if (!ne) {
        var Ce = ae.memoizedProps, _e = d.compare;
        if (_e = _e !== null ? _e : $t, _e(Ce, h) && i.ref === o.ref)
          return Su(i, o, b);
      }
      o.flags |= Kl;
      var Ae = fp(ae, h);
      return Ae.ref = o.ref, Ae.return = o, o.child = Ae, Ae;
    }
    function j$(i, o, d, h, b) {
      if (o.type !== o.elementType) {
        var C = o.elementType;
        if (C.$$typeof === Rt) {
          var R = C, A = R._payload, B = R._init;
          try {
            C = B(A);
          } catch {
            C = null;
          }
          var V = C && C.propTypes;
          V && gl(
            V,
            h,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            rn(C)
          );
        }
      }
      if (i !== null) {
        var G = i.memoizedProps;
        if ($t(G, h) && i.ref === o.ref && // Prevent bailout if the implementation changed due to hot reload.
        o.type === i.type)
          if (wl = !1, o.pendingProps = h = G, k_(i, b))
            (i.flags & Pf) !== Mt && (wl = !0);
          else
            return o.lanes = i.lanes, Su(i, o, b);
      }
      return b_(i, o, d, h, b);
    }
    function z$(i, o, d) {
      var h = o.pendingProps, b = h.children, C = i !== null ? i.memoizedState : null;
      if (h.mode === "hidden" || W)
        if ((o.mode & fn) === Dt) {
          var R = {
            baseLanes: Ne,
            cachePool: null,
            transitions: null
          };
          o.memoizedState = R, pw(o, d);
        } else if (Lo(d, No)) {
          var ae = {
            baseLanes: Ne,
            cachePool: null,
            transitions: null
          };
          o.memoizedState = ae;
          var ne = C !== null ? C.baseLanes : d;
          pw(o, ne);
        } else {
          var A = null, B;
          if (C !== null) {
            var V = C.baseLanes;
            B = an(V, d);
          } else
            B = d;
          o.lanes = o.childLanes = No;
          var G = {
            baseLanes: B,
            cachePool: A,
            transitions: null
          };
          return o.memoizedState = G, o.updateQueue = null, pw(o, B), null;
        }
      else {
        var Ce;
        C !== null ? (Ce = an(C.baseLanes, d), o.memoizedState = null) : Ce = d, pw(o, Ce);
      }
      return ra(i, o, b, d), o.child;
    }
    function HB(i, o, d) {
      var h = o.pendingProps;
      return ra(i, o, h, d), o.child;
    }
    function VB(i, o, d) {
      var h = o.pendingProps.children;
      return ra(i, o, h, d), o.child;
    }
    function YB(i, o, d) {
      {
        o.flags |= on;
        {
          var h = o.stateNode;
          h.effectDuration = 0, h.passiveEffectDuration = 0;
        }
      }
      var b = o.pendingProps, C = b.children;
      return ra(i, o, C, d), o.child;
    }
    function U$(i, o) {
      var d = o.ref;
      (i === null && d !== null || i !== null && i.ref !== d) && (o.flags |= Ro, o.flags |= Um);
    }
    function b_(i, o, d, h, b) {
      if (o.type !== o.elementType) {
        var C = d.propTypes;
        C && gl(
          C,
          h,
          // Resolved props
          "prop",
          rn(d)
        );
      }
      var R;
      {
        var A = tg(o, d, !0);
        R = ng(o, A);
      }
      var B, V;
      sg(o, b), Jl(o);
      {
        if (ry.current = o, Wi(!0), B = hg(i, o, d, h, R, b), V = gg(), o.mode & Or) {
          ai(!0);
          try {
            B = hg(i, o, d, h, R, b), V = gg();
          } finally {
            ai(!1);
          }
        }
        Wi(!1);
      }
      return Gc(), i !== null && !wl ? (i$(i, o, b), Su(i, o, b)) : (po() && V && JE(o), o.flags |= Kl, ra(i, o, B, b), o.child);
    }
    function B$(i, o, d, h, b) {
      {
        switch (l7(o)) {
          case !1: {
            var C = o.stateNode, R = o.type, A = new R(o.memoizedProps, C.context), B = A.state;
            C.updater.enqueueSetState(C, B, null);
            break;
          }
          case !0: {
            o.flags |= Ht, o.flags |= xi;
            var V = new Error("Simulated error coming from DevTools"), G = si(b);
            o.lanes = an(o.lanes, G);
            var ae = p_(o, ap(V, o), G);
            gC(o, ae);
            break;
          }
        }
        if (o.type !== o.elementType) {
          var ne = d.propTypes;
          ne && gl(
            ne,
            h,
            // Resolved props
            "prop",
            rn(d)
          );
        }
      }
      var Ce;
      uc(d) ? (Ce = !0, fS(o)) : Ce = !1, sg(o, b);
      var _e = o.stateNode, Ae;
      _e === null ? (nw(i, o), GR(o, d, h), kC(o, d, h, b), Ae = !0) : i === null ? Ae = vB(o, d, h, b) : Ae = yB(i, o, d, h, b);
      var ut = S_(i, o, d, Ae, Ce, b);
      {
        var Ot = o.stateNode;
        Ae && Ot.props !== h && (sp || c("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Ft(o) || "a component"), sp = !0);
      }
      return ut;
    }
    function S_(i, o, d, h, b, C) {
      U$(i, o);
      var R = (o.flags & Ht) !== Mt;
      if (!h && !R)
        return b && wR(o, d, !1), Su(i, o, C);
      var A = o.stateNode;
      ry.current = o;
      var B;
      if (R && typeof d.getDerivedStateFromError != "function")
        B = null, $$();
      else {
        Jl(o);
        {
          if (Wi(!0), B = A.render(), o.mode & Or) {
            ai(!0);
            try {
              A.render();
            } finally {
              ai(!1);
            }
          }
          Wi(!1);
        }
        Gc();
      }
      return o.flags |= Kl, i !== null && R ? FB(i, o, B, C) : ra(i, o, B, C), o.memoizedState = A.state, b && wR(o, d, !0), o.child;
    }
    function F$(i) {
      var o = i.stateNode;
      o.pendingContext ? bR(i, o.pendingContext, o.pendingContext !== o.context) : o.context && bR(i, o.context, !1), AC(i, o.containerInfo);
    }
    function KB(i, o, d) {
      if (F$(o), i === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var h = o.pendingProps, b = o.memoizedState, C = b.element;
      UR(i, o), kS(o, h, null, d);
      var R = o.memoizedState;
      o.stateNode;
      var A = R.element;
      if (b.isDehydrated) {
        var B = {
          element: A,
          isDehydrated: !1,
          cache: R.cache,
          pendingSuspenseBoundaries: R.pendingSuspenseBoundaries,
          transitions: R.transitions
        }, V = o.updateQueue;
        if (V.baseState = B, o.memoizedState = B, o.flags & Fr) {
          var G = ap(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), o);
          return H$(i, o, A, d, G);
        } else if (A !== C) {
          var ae = ap(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), o);
          return H$(i, o, A, d, ae);
        } else {
          qU(o);
          var ne = JR(o, null, A, d);
          o.child = ne;
          for (var Ce = ne; Ce; )
            Ce.flags = Ce.flags & ~mr | Ta, Ce = Ce.sibling;
        }
      } else {
        if (og(), A === C)
          return Su(i, o, d);
        ra(i, o, A, d);
      }
      return o.child;
    }
    function H$(i, o, d, h, b) {
      return og(), oC(b), o.flags |= Fr, ra(i, o, d, h), o.child;
    }
    function WB(i, o, d) {
      t$(o), i === null && iC(o);
      var h = o.type, b = o.pendingProps, C = i !== null ? i.memoizedProps : null, R = b.children, A = zE(h, b);
      return A ? R = null : C !== null && zE(h, C) && (o.flags |= Vn), U$(i, o), ra(i, o, R, d), o.child;
    }
    function GB(i, o) {
      return i === null && iC(o), null;
    }
    function XB(i, o, d, h) {
      nw(i, o);
      var b = o.pendingProps, C = d, R = C._payload, A = C._init, B = A(R);
      o.type = B;
      var V = o.tag = GF(B), G = yl(B, b), ae;
      switch (V) {
        case p:
          return w_(o, B), o.type = B = Eg(B), ae = b_(null, o, B, G, h), ae;
        case g:
          return o.type = B = Q_(B), ae = B$(null, o, B, G, h), ae;
        case j:
          return o.type = B = Z_(B), ae = N$(null, o, B, G, h), ae;
        case F: {
          if (o.type !== o.elementType) {
            var ne = B.propTypes;
            ne && gl(
              ne,
              G,
              // Resolved for outer only
              "prop",
              rn(B)
            );
          }
          return ae = L$(
            null,
            o,
            B,
            yl(B.type, G),
            // The inner type can have defaults too
            h
          ), ae;
        }
      }
      var Ce = "";
      throw B !== null && typeof B == "object" && B.$$typeof === Rt && (Ce = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + B + ". " + ("Lazy element type must resolve to a class or function." + Ce));
    }
    function qB(i, o, d, h, b) {
      nw(i, o), o.tag = g;
      var C;
      return uc(d) ? (C = !0, fS(o)) : C = !1, sg(o, b), GR(o, d, h), kC(o, d, h, b), S_(null, o, d, !0, C, b);
    }
    function QB(i, o, d, h) {
      nw(i, o);
      var b = o.pendingProps, C;
      {
        var R = tg(o, d, !1);
        C = ng(o, R);
      }
      sg(o, h);
      var A, B;
      Jl(o);
      {
        if (d.prototype && typeof d.prototype.render == "function") {
          var V = rn(d) || "Unknown";
          h_[V] || (c("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", V, V), h_[V] = !0);
        }
        o.mode & Or && vl.recordLegacyContextWarning(o, null), Wi(!0), ry.current = o, A = hg(null, o, d, b, C, h), B = gg(), Wi(!1);
      }
      if (Gc(), o.flags |= Kl, typeof A == "object" && A !== null && typeof A.render == "function" && A.$$typeof === void 0) {
        var G = rn(d) || "Unknown";
        iy[G] || (c("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", G, G, G), iy[G] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof A == "object" && A !== null && typeof A.render == "function" && A.$$typeof === void 0
      ) {
        {
          var ae = rn(d) || "Unknown";
          iy[ae] || (c("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", ae, ae, ae), iy[ae] = !0);
        }
        o.tag = g, o.memoizedState = null, o.updateQueue = null;
        var ne = !1;
        return uc(d) ? (ne = !0, fS(o)) : ne = !1, o.memoizedState = A.state !== null && A.state !== void 0 ? A.state : null, hC(o), WR(o, A), kC(o, d, b, h), S_(null, o, d, !0, ne, h);
      } else {
        if (o.tag = p, o.mode & Or) {
          ai(!0);
          try {
            A = hg(null, o, d, b, C, h), B = gg();
          } finally {
            ai(!1);
          }
        }
        return po() && B && JE(o), ra(null, o, A, h), w_(o, d), o.child;
      }
    }
    function w_(i, o) {
      {
        if (o && o.childContextTypes && c("%s(...): childContextTypes cannot be defined on a function component.", o.displayName || o.name || "Component"), i.ref !== null) {
          var d = "", h = Si();
          h && (d += `

Check the render method of \`` + h + "`.");
          var b = h || "", C = i._debugSource;
          C && (b = C.fileName + ":" + C.lineNumber), v_[b] || (v_[b] = !0, c("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", d));
        }
        if (typeof o.getDerivedStateFromProps == "function") {
          var R = rn(o) || "Unknown";
          m_[R] || (c("%s: Function components do not support getDerivedStateFromProps.", R), m_[R] = !0);
        }
        if (typeof o.contextType == "object" && o.contextType !== null) {
          var A = rn(o) || "Unknown";
          g_[A] || (c("%s: Function components do not support contextType.", A), g_[A] = !0);
        }
      }
    }
    var x_ = {
      dehydrated: null,
      treeContext: null,
      retryLane: En
    };
    function E_(i) {
      return {
        baseLanes: i,
        cachePool: BB(),
        transitions: null
      };
    }
    function ZB(i, o) {
      var d = null;
      return {
        baseLanes: an(i.baseLanes, o),
        cachePool: d,
        transitions: i.transitions
      };
    }
    function JB(i, o, d, h) {
      if (o !== null) {
        var b = o.memoizedState;
        if (b === null)
          return !1;
      }
      return NC(i, Xv);
    }
    function e8(i, o) {
      return od(i.childLanes, o);
    }
    function V$(i, o, d) {
      var h = o.pendingProps;
      c7(o) && (o.flags |= Ht);
      var b = bl.current, C = !1, R = (o.flags & Ht) !== Mt;
      if (R || JB(b, i) ? (C = !0, o.flags &= ~Ht) : (i === null || i.memoizedState !== null) && (b = xB(b, r$)), b = ug(b), Pd(o, b), i === null) {
        iC(o);
        var A = o.memoizedState;
        if (A !== null) {
          var B = A.dehydrated;
          if (B !== null)
            return o8(o, B);
        }
        var V = h.children, G = h.fallback;
        if (C) {
          var ae = t8(o, V, G, d), ne = o.child;
          return ne.memoizedState = E_(d), o.memoizedState = x_, ae;
        } else
          return C_(o, V);
      } else {
        var Ce = i.memoizedState;
        if (Ce !== null) {
          var _e = Ce.dehydrated;
          if (_e !== null)
            return a8(i, o, R, h, _e, Ce, d);
        }
        if (C) {
          var Ae = h.fallback, ut = h.children, Ot = r8(i, o, ut, Ae, d), Pt = o.child, _n = i.child.memoizedState;
          return Pt.memoizedState = _n === null ? E_(d) : ZB(_n, d), Pt.childLanes = e8(i, d), o.memoizedState = x_, Ot;
        } else {
          var vn = h.children, be = n8(i, o, vn, d);
          return o.memoizedState = null, be;
        }
      }
    }
    function C_(i, o, d) {
      var h = i.mode, b = {
        mode: "visible",
        children: o
      }, C = __(b, h);
      return C.return = i, i.child = C, C;
    }
    function t8(i, o, d, h) {
      var b = i.mode, C = i.child, R = {
        mode: "hidden",
        children: o
      }, A, B;
      return (b & fn) === Dt && C !== null ? (A = C, A.childLanes = Ne, A.pendingProps = R, i.mode & Lt && (A.actualDuration = 0, A.actualStartTime = -1, A.selfBaseDuration = 0, A.treeBaseDuration = 0), B = Nd(d, b, h, null)) : (A = __(R, b), B = Nd(d, b, h, null)), A.return = i, B.return = i, A.sibling = B, i.child = A, B;
    }
    function __(i, o, d) {
      return YM(i, o, Ne, null);
    }
    function Y$(i, o) {
      return fp(i, o);
    }
    function n8(i, o, d, h) {
      var b = i.child, C = b.sibling, R = Y$(b, {
        mode: "visible",
        children: d
      });
      if ((o.mode & fn) === Dt && (R.lanes = h), R.return = o, R.sibling = null, C !== null) {
        var A = o.deletions;
        A === null ? (o.deletions = [C], o.flags |= Un) : A.push(C);
      }
      return o.child = R, R;
    }
    function r8(i, o, d, h, b) {
      var C = o.mode, R = i.child, A = R.sibling, B = {
        mode: "hidden",
        children: d
      }, V;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (C & fn) === Dt && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        o.child !== R
      ) {
        var G = o.child;
        V = G, V.childLanes = Ne, V.pendingProps = B, o.mode & Lt && (V.actualDuration = 0, V.actualStartTime = -1, V.selfBaseDuration = R.selfBaseDuration, V.treeBaseDuration = R.treeBaseDuration), o.deletions = null;
      } else
        V = Y$(R, B), V.subtreeFlags = R.subtreeFlags & Mi;
      var ae;
      return A !== null ? ae = fp(A, h) : (ae = Nd(h, C, b, null), ae.flags |= mr), ae.return = o, V.return = o, V.sibling = ae, o.child = V, ae;
    }
    function tw(i, o, d, h) {
      h !== null && oC(h), lg(o, i.child, null, d);
      var b = o.pendingProps, C = b.children, R = C_(o, C);
      return R.flags |= mr, o.memoizedState = null, R;
    }
    function i8(i, o, d, h, b) {
      var C = o.mode, R = {
        mode: "visible",
        children: d
      }, A = __(R, C), B = Nd(h, C, b, null);
      return B.flags |= mr, A.return = o, B.return = o, A.sibling = B, o.child = A, (o.mode & fn) !== Dt && lg(o, i.child, null, b), B;
    }
    function o8(i, o, d) {
      return (i.mode & fn) === Dt ? (c("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), i.lanes = jt) : HE(o) ? i.lanes = Qc : i.lanes = No, null;
    }
    function a8(i, o, d, h, b, C, R) {
      if (d)
        if (o.flags & Fr) {
          o.flags &= ~Fr;
          var be = d_(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return tw(i, o, R, be);
        } else {
          if (o.memoizedState !== null)
            return o.child = i.child, o.flags |= Ht, null;
          var Oe = h.children, Se = h.fallback, We = i8(i, o, Oe, Se, R), dt = o.child;
          return dt.memoizedState = E_(R), o.memoizedState = x_, We;
        }
      else {
        if (GU(), (o.mode & fn) === Dt)
          return tw(
            i,
            o,
            R,
            // TODO: When we delete legacy mode, we should make this error argument
            // required — every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (HE(b)) {
          var A, B, V;
          {
            var G = dU(b);
            A = G.digest, B = G.message, V = G.stack;
          }
          var ae;
          B ? ae = new Error(B) : ae = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var ne = d_(ae, A, V);
          return tw(i, o, R, ne);
        }
        var Ce = Lo(R, i.childLanes);
        if (wl || Ce) {
          var _e = fw();
          if (_e !== null) {
            var Ae = uE(_e, R);
            if (Ae !== En && Ae !== C.retryLane) {
              C.retryLane = Ae;
              var ut = lr;
              Na(i, Ae), Fi(_e, i, Ae, ut);
            }
          }
          K_();
          var Ot = d_(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return tw(i, o, R, Ot);
        } else if (pR(b)) {
          o.flags |= Ht, o.child = i.child;
          var Pt = $F.bind(null, i);
          return fU(b, Pt), null;
        } else {
          QU(o, b, C.treeContext);
          var _n = h.children, vn = C_(o, _n);
          return vn.flags |= Ta, vn;
        }
      }
    }
    function K$(i, o, d) {
      i.lanes = an(i.lanes, o);
      var h = i.alternate;
      h !== null && (h.lanes = an(h.lanes, o)), uC(i.return, o, d);
    }
    function s8(i, o, d) {
      for (var h = o; h !== null; ) {
        if (h.tag === z) {
          var b = h.memoizedState;
          b !== null && K$(h, d, i);
        } else if (h.tag === pe)
          K$(h, d, i);
        else if (h.child !== null) {
          h.child.return = h, h = h.child;
          continue;
        }
        if (h === i)
          return;
        for (; h.sibling === null; ) {
          if (h.return === null || h.return === i)
            return;
          h = h.return;
        }
        h.sibling.return = h.return, h = h.sibling;
      }
    }
    function l8(i) {
      for (var o = i, d = null; o !== null; ) {
        var h = o.alternate;
        h !== null && OS(h) === null && (d = o), o = o.sibling;
      }
      return d;
    }
    function c8(i) {
      if (i !== void 0 && i !== "forwards" && i !== "backwards" && i !== "together" && !y_[i])
        if (y_[i] = !0, typeof i == "string")
          switch (i.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              c('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', i, i.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              c('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', i, i.toLowerCase());
              break;
            }
            default:
              c('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', i);
              break;
          }
        else
          c('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', i);
    }
    function u8(i, o) {
      i !== void 0 && !ew[i] && (i !== "collapsed" && i !== "hidden" ? (ew[i] = !0, c('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', i)) : o !== "forwards" && o !== "backwards" && (ew[i] = !0, c('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', i)));
    }
    function W$(i, o) {
      {
        var d = Sn(i), h = !d && typeof Wo(i) == "function";
        if (d || h) {
          var b = d ? "array" : "iterable";
          return c("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", b, o, b), !1;
        }
      }
      return !0;
    }
    function d8(i, o) {
      if ((o === "forwards" || o === "backwards") && i !== void 0 && i !== null && i !== !1)
        if (Sn(i)) {
          for (var d = 0; d < i.length; d++)
            if (!W$(i[d], d))
              return;
        } else {
          var h = Wo(i);
          if (typeof h == "function") {
            var b = h.call(i);
            if (b)
              for (var C = b.next(), R = 0; !C.done; C = b.next()) {
                if (!W$(C.value, R))
                  return;
                R++;
              }
          } else
            c('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', o);
        }
    }
    function T_(i, o, d, h, b) {
      var C = i.memoizedState;
      C === null ? i.memoizedState = {
        isBackwards: o,
        rendering: null,
        renderingStartTime: 0,
        last: h,
        tail: d,
        tailMode: b
      } : (C.isBackwards = o, C.rendering = null, C.renderingStartTime = 0, C.last = h, C.tail = d, C.tailMode = b);
    }
    function G$(i, o, d) {
      var h = o.pendingProps, b = h.revealOrder, C = h.tail, R = h.children;
      c8(b), u8(C, b), d8(R, b), ra(i, o, R, d);
      var A = bl.current, B = NC(A, Xv);
      if (B)
        A = LC(A, Xv), o.flags |= Ht;
      else {
        var V = i !== null && (i.flags & Ht) !== Mt;
        V && s8(o, o.child, d), A = ug(A);
      }
      if (Pd(o, A), (o.mode & fn) === Dt)
        o.memoizedState = null;
      else
        switch (b) {
          case "forwards": {
            var G = l8(o.child), ae;
            G === null ? (ae = o.child, o.child = null) : (ae = G.sibling, G.sibling = null), T_(
              o,
              !1,
              // isBackwards
              ae,
              G,
              C
            );
            break;
          }
          case "backwards": {
            var ne = null, Ce = o.child;
            for (o.child = null; Ce !== null; ) {
              var _e = Ce.alternate;
              if (_e !== null && OS(_e) === null) {
                o.child = Ce;
                break;
              }
              var Ae = Ce.sibling;
              Ce.sibling = ne, ne = Ce, Ce = Ae;
            }
            T_(
              o,
              !0,
              // isBackwards
              ne,
              null,
              // last
              C
            );
            break;
          }
          case "together": {
            T_(
              o,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            o.memoizedState = null;
        }
      return o.child;
    }
    function f8(i, o, d) {
      AC(o, o.stateNode.containerInfo);
      var h = o.pendingProps;
      return i === null ? o.child = lg(o, null, h, d) : ra(i, o, h, d), o.child;
    }
    var X$ = !1;
    function p8(i, o, d) {
      var h = o.type, b = h._context, C = o.pendingProps, R = o.memoizedProps, A = C.value;
      {
        "value" in C || X$ || (X$ = !0, c("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var B = o.type.propTypes;
        B && gl(B, C, "prop", "Context.Provider");
      }
      if (NR(o, b, A), R !== null) {
        var V = R.value;
        if (mt(V, A)) {
          if (R.children === C.children && !uS())
            return Su(i, o, d);
        } else
          sB(o, b, d);
      }
      var G = C.children;
      return ra(i, o, G, d), o.child;
    }
    var q$ = !1;
    function h8(i, o, d) {
      var h = o.type;
      h._context === void 0 ? h !== h.Consumer && (q$ || (q$ = !0, c("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : h = h._context;
      var b = o.pendingProps, C = b.children;
      typeof C != "function" && c("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), sg(o, d);
      var R = ki(h);
      Jl(o);
      var A;
      return ry.current = o, Wi(!0), A = C(R), Wi(!1), Gc(), o.flags |= Kl, ra(i, o, A, d), o.child;
    }
    function oy() {
      wl = !0;
    }
    function nw(i, o) {
      (o.mode & fn) === Dt && i !== null && (i.alternate = null, o.alternate = null, o.flags |= mr);
    }
    function Su(i, o, d) {
      return i !== null && (o.dependencies = i.dependencies), $$(), vy(o.lanes), Lo(d, o.childLanes) ? (bB(i, o), o.child) : null;
    }
    function g8(i, o, d) {
      {
        var h = o.return;
        if (h === null)
          throw new Error("Cannot swap the root fiber.");
        if (i.alternate = null, o.alternate = null, d.index = o.index, d.sibling = o.sibling, d.return = o.return, d.ref = o.ref, o === h.child)
          h.child = d;
        else {
          var b = h.child;
          if (b === null)
            throw new Error("Expected parent to have a child.");
          for (; b.sibling !== o; )
            if (b = b.sibling, b === null)
              throw new Error("Expected to find the previous sibling.");
          b.sibling = d;
        }
        var C = h.deletions;
        return C === null ? (h.deletions = [i], h.flags |= Un) : C.push(i), d.flags |= mr, d;
      }
    }
    function k_(i, o) {
      var d = i.lanes;
      return !!Lo(d, o);
    }
    function m8(i, o, d) {
      switch (o.tag) {
        case v:
          F$(o), o.stateNode, og();
          break;
        case x:
          t$(o);
          break;
        case g: {
          var h = o.type;
          uc(h) && fS(o);
          break;
        }
        case S:
          AC(o, o.stateNode.containerInfo);
          break;
        case N: {
          var b = o.memoizedProps.value, C = o.type._context;
          NR(o, C, b);
          break;
        }
        case L:
          {
            var R = Lo(d, o.childLanes);
            R && (o.flags |= on);
            {
              var A = o.stateNode;
              A.effectDuration = 0, A.passiveEffectDuration = 0;
            }
          }
          break;
        case z: {
          var B = o.memoizedState;
          if (B !== null) {
            if (B.dehydrated !== null)
              return Pd(o, ug(bl.current)), o.flags |= Ht, null;
            var V = o.child, G = V.childLanes;
            if (Lo(d, G))
              return V$(i, o, d);
            Pd(o, ug(bl.current));
            var ae = Su(i, o, d);
            return ae !== null ? ae.sibling : null;
          } else
            Pd(o, ug(bl.current));
          break;
        }
        case pe: {
          var ne = (i.flags & Ht) !== Mt, Ce = Lo(d, o.childLanes);
          if (ne) {
            if (Ce)
              return G$(i, o, d);
            o.flags |= Ht;
          }
          var _e = o.memoizedState;
          if (_e !== null && (_e.rendering = null, _e.tail = null, _e.lastEffect = null), Pd(o, bl.current), Ce)
            break;
          return null;
        }
        case ve:
        case Y:
          return o.lanes = Ne, z$(i, o, d);
      }
      return Su(i, o, d);
    }
    function Q$(i, o, d) {
      if (o._debugNeedsRemount && i !== null)
        return g8(i, o, rT(o.type, o.key, o.pendingProps, o._debugOwner || null, o.mode, o.lanes));
      if (i !== null) {
        var h = i.memoizedProps, b = o.pendingProps;
        if (h !== b || uS() || // Force a re-render if the implementation changed due to hot reload:
        o.type !== i.type)
          wl = !0;
        else {
          var C = k_(i, d);
          if (!C && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (o.flags & Ht) === Mt)
            return wl = !1, m8(i, o, d);
          (i.flags & Pf) !== Mt ? wl = !0 : wl = !1;
        }
      } else if (wl = !1, po() && FU(o)) {
        var R = o.index, A = HU();
        CR(o, A, R);
      }
      switch (o.lanes = Ne, o.tag) {
        case y:
          return QB(i, o, o.type, d);
        case X: {
          var B = o.elementType;
          return XB(i, o, B, d);
        }
        case p: {
          var V = o.type, G = o.pendingProps, ae = o.elementType === V ? G : yl(V, G);
          return b_(i, o, V, ae, d);
        }
        case g: {
          var ne = o.type, Ce = o.pendingProps, _e = o.elementType === ne ? Ce : yl(ne, Ce);
          return B$(i, o, ne, _e, d);
        }
        case v:
          return KB(i, o, d);
        case x:
          return WB(i, o, d);
        case _:
          return GB(i, o);
        case z:
          return V$(i, o, d);
        case S:
          return f8(i, o, d);
        case j: {
          var Ae = o.type, ut = o.pendingProps, Ot = o.elementType === Ae ? ut : yl(Ae, ut);
          return N$(i, o, Ae, Ot, d);
        }
        case T:
          return HB(i, o, d);
        case I:
          return VB(i, o, d);
        case L:
          return YB(i, o, d);
        case N:
          return p8(i, o, d);
        case D:
          return h8(i, o, d);
        case F: {
          var Pt = o.type, _n = o.pendingProps, vn = yl(Pt, _n);
          if (o.type !== o.elementType) {
            var be = Pt.propTypes;
            be && gl(
              be,
              vn,
              // Resolved for outer only
              "prop",
              rn(Pt)
            );
          }
          return vn = yl(Pt.type, vn), L$(i, o, Pt, vn, d);
        }
        case K:
          return j$(i, o, o.type, o.pendingProps, d);
        case se: {
          var Oe = o.type, Se = o.pendingProps, We = o.elementType === Oe ? Se : yl(Oe, Se);
          return qB(i, o, Oe, We, d);
        }
        case pe:
          return G$(i, o, d);
        case Pe:
          break;
        case ve:
          return z$(i, o, d);
      }
      throw new Error("Unknown unit of work tag (" + o.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function mg(i) {
      i.flags |= on;
    }
    function Z$(i) {
      i.flags |= Ro, i.flags |= Um;
    }
    var J$, P_, eM, tM;
    J$ = function(i, o, d, h) {
      for (var b = o.child; b !== null; ) {
        if (b.tag === x || b.tag === _)
          z6(i, b.stateNode);
        else if (b.tag !== S) {
          if (b.child !== null) {
            b.child.return = b, b = b.child;
            continue;
          }
        }
        if (b === o)
          return;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === o)
            return;
          b = b.return;
        }
        b.sibling.return = b.return, b = b.sibling;
      }
    }, P_ = function(i, o) {
    }, eM = function(i, o, d, h, b) {
      var C = i.memoizedProps;
      if (C !== h) {
        var R = o.stateNode, A = OC(), B = B6(R, d, C, h, b, A);
        o.updateQueue = B, B && mg(o);
      }
    }, tM = function(i, o, d, h) {
      d !== h && mg(o);
    };
    function ay(i, o) {
      if (!po())
        switch (i.tailMode) {
          case "hidden": {
            for (var d = i.tail, h = null; d !== null; )
              d.alternate !== null && (h = d), d = d.sibling;
            h === null ? i.tail = null : h.sibling = null;
            break;
          }
          case "collapsed": {
            for (var b = i.tail, C = null; b !== null; )
              b.alternate !== null && (C = b), b = b.sibling;
            C === null ? !o && i.tail !== null ? i.tail.sibling = null : i.tail = null : C.sibling = null;
            break;
          }
        }
    }
    function go(i) {
      var o = i.alternate !== null && i.alternate.child === i.child, d = Ne, h = Mt;
      if (o) {
        if ((i.mode & Lt) !== Dt) {
          for (var B = i.selfBaseDuration, V = i.child; V !== null; )
            d = an(d, an(V.lanes, V.childLanes)), h |= V.subtreeFlags & Mi, h |= V.flags & Mi, B += V.treeBaseDuration, V = V.sibling;
          i.treeBaseDuration = B;
        } else
          for (var G = i.child; G !== null; )
            d = an(d, an(G.lanes, G.childLanes)), h |= G.subtreeFlags & Mi, h |= G.flags & Mi, G.return = i, G = G.sibling;
        i.subtreeFlags |= h;
      } else {
        if ((i.mode & Lt) !== Dt) {
          for (var b = i.actualDuration, C = i.selfBaseDuration, R = i.child; R !== null; )
            d = an(d, an(R.lanes, R.childLanes)), h |= R.subtreeFlags, h |= R.flags, b += R.actualDuration, C += R.treeBaseDuration, R = R.sibling;
          i.actualDuration = b, i.treeBaseDuration = C;
        } else
          for (var A = i.child; A !== null; )
            d = an(d, an(A.lanes, A.childLanes)), h |= A.subtreeFlags, h |= A.flags, A.return = i, A = A.sibling;
        i.subtreeFlags |= h;
      }
      return i.childLanes = d, o;
    }
    function v8(i, o, d) {
      if (nB() && (o.mode & fn) !== Dt && (o.flags & Ht) === Mt)
        return $R(o), og(), o.flags |= Fr | Qo | xi, !1;
      var h = vS(o);
      if (d !== null && d.dehydrated !== null)
        if (i === null) {
          if (!h)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (eB(o), go(o), (o.mode & Lt) !== Dt) {
            var b = d !== null;
            if (b) {
              var C = o.child;
              C !== null && (o.treeBaseDuration -= C.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (og(), (o.flags & Ht) === Mt && (o.memoizedState = null), o.flags |= on, go(o), (o.mode & Lt) !== Dt) {
            var R = d !== null;
            if (R) {
              var A = o.child;
              A !== null && (o.treeBaseDuration -= A.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return MR(), !0;
    }
    function nM(i, o, d) {
      var h = o.pendingProps;
      switch (eC(o), o.tag) {
        case y:
        case X:
        case K:
        case p:
        case j:
        case T:
        case I:
        case L:
        case D:
        case F:
          return go(o), null;
        case g: {
          var b = o.type;
          return uc(b) && dS(o), go(o), null;
        }
        case v: {
          var C = o.stateNode;
          if (cg(o), qE(o), zC(), C.pendingContext && (C.context = C.pendingContext, C.pendingContext = null), i === null || i.child === null) {
            var R = vS(o);
            if (R)
              mg(o);
            else if (i !== null) {
              var A = i.memoizedState;
              // Check if this is a client root
              (!A.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (o.flags & Fr) !== Mt) && (o.flags |= _a, MR());
            }
          }
          return P_(i, o), go(o), null;
        }
        case x: {
          DC(o);
          var B = e$(), V = o.type;
          if (i !== null && o.stateNode != null)
            eM(i, o, V, h, B), i.ref !== o.ref && Z$(o);
          else {
            if (!h) {
              if (o.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return go(o), null;
            }
            var G = OC(), ae = vS(o);
            if (ae)
              ZU(o, B, G) && mg(o);
            else {
              var ne = j6(V, h, B, G, o);
              J$(ne, o, !1, !1), o.stateNode = ne, U6(ne, V, h, B) && mg(o);
            }
            o.ref !== null && Z$(o);
          }
          return go(o), null;
        }
        case _: {
          var Ce = h;
          if (i && o.stateNode != null) {
            var _e = i.memoizedProps;
            tM(i, o, _e, Ce);
          } else {
            if (typeof Ce != "string" && o.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Ae = e$(), ut = OC(), Ot = vS(o);
            Ot ? JU(o) && mg(o) : o.stateNode = F6(Ce, Ae, ut, o);
          }
          return go(o), null;
        }
        case z: {
          dg(o);
          var Pt = o.memoizedState;
          if (i === null || i.memoizedState !== null && i.memoizedState.dehydrated !== null) {
            var _n = v8(i, o, Pt);
            if (!_n)
              return o.flags & xi ? o : null;
          }
          if ((o.flags & Ht) !== Mt)
            return o.lanes = d, (o.mode & Lt) !== Dt && u_(o), o;
          var vn = Pt !== null, be = i !== null && i.memoizedState !== null;
          if (vn !== be && vn) {
            var Oe = o.child;
            if (Oe.flags |= Wl, (o.mode & fn) !== Dt) {
              var Se = i === null && (o.memoizedProps.unstable_avoidThisFallback !== !0 || !fe);
              Se || NC(bl.current, r$) ? yF() : K_();
            }
          }
          var We = o.updateQueue;
          if (We !== null && (o.flags |= on), go(o), (o.mode & Lt) !== Dt && vn) {
            var dt = o.child;
            dt !== null && (o.treeBaseDuration -= dt.treeBaseDuration);
          }
          return null;
        }
        case S:
          return cg(o), P_(i, o), i === null && DU(o.stateNode.containerInfo), go(o), null;
        case N:
          var at = o.type._context;
          return cC(at, o), go(o), null;
        case se: {
          var Bt = o.type;
          return uc(Bt) && dS(o), go(o), null;
        }
        case pe: {
          dg(o);
          var Zt = o.memoizedState;
          if (Zt === null)
            return go(o), null;
          var er = (o.flags & Ht) !== Mt, jn = Zt.rendering;
          if (jn === null)
            if (er)
              ay(Zt, !1);
            else {
              var di = SF() && (i === null || (i.flags & Ht) === Mt);
              if (!di)
                for (var zn = o.child; zn !== null; ) {
                  var oi = OS(zn);
                  if (oi !== null) {
                    er = !0, o.flags |= Ht, ay(Zt, !1);
                    var Bo = oi.updateQueue;
                    return Bo !== null && (o.updateQueue = Bo, o.flags |= on), o.subtreeFlags = Mt, SB(o, d), Pd(o, LC(bl.current, Xv)), o.child;
                  }
                  zn = zn.sibling;
                }
              Zt.tail !== null && Ar() > EM() && (o.flags |= Ht, er = !0, ay(Zt, !1), o.lanes = Jm);
            }
          else {
            if (!er) {
              var So = OS(jn);
              if (So !== null) {
                o.flags |= Ht, er = !0;
                var as = So.updateQueue;
                if (as !== null && (o.updateQueue = as, o.flags |= on), ay(Zt, !0), Zt.tail === null && Zt.tailMode === "hidden" && !jn.alternate && !po())
                  return go(o), null;
              } else
                // The time it took to render last row is greater than the remaining
                // time we have to render. So rendering one more row would likely
                // exceed it.
                Ar() * 2 - Zt.renderingStartTime > EM() && d !== No && (o.flags |= Ht, er = !0, ay(Zt, !1), o.lanes = Jm);
            }
            if (Zt.isBackwards)
              jn.sibling = o.child, o.child = jn;
            else {
              var aa = Zt.last;
              aa !== null ? aa.sibling = jn : o.child = jn, Zt.last = jn;
            }
          }
          if (Zt.tail !== null) {
            var sa = Zt.tail;
            Zt.rendering = sa, Zt.tail = sa.sibling, Zt.renderingStartTime = Ar(), sa.sibling = null;
            var Fo = bl.current;
            return er ? Fo = LC(Fo, Xv) : Fo = ug(Fo), Pd(o, Fo), sa;
          }
          return go(o), null;
        }
        case Pe:
          break;
        case ve:
        case Y: {
          Y_(o);
          var _u = o.memoizedState, Cg = _u !== null;
          if (i !== null) {
            var xy = i.memoizedState, yc = xy !== null;
            yc !== Cg && // LegacyHidden doesn't do any hiding — it only pre-renders.
            !W && (o.flags |= Wl);
          }
          return !Cg || (o.mode & fn) === Dt ? go(o) : Lo(vc, No) && (go(o), o.subtreeFlags & (mr | on) && (o.flags |= Wl)), null;
        }
        case le:
          return null;
        case Re:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + o.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function y8(i, o, d) {
      switch (eC(o), o.tag) {
        case g: {
          var h = o.type;
          uc(h) && dS(o);
          var b = o.flags;
          return b & xi ? (o.flags = b & ~xi | Ht, (o.mode & Lt) !== Dt && u_(o), o) : null;
        }
        case v: {
          o.stateNode, cg(o), qE(o), zC();
          var C = o.flags;
          return (C & xi) !== Mt && (C & Ht) === Mt ? (o.flags = C & ~xi | Ht, o) : null;
        }
        case x:
          return DC(o), null;
        case z: {
          dg(o);
          var R = o.memoizedState;
          if (R !== null && R.dehydrated !== null) {
            if (o.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            og();
          }
          var A = o.flags;
          return A & xi ? (o.flags = A & ~xi | Ht, (o.mode & Lt) !== Dt && u_(o), o) : null;
        }
        case pe:
          return dg(o), null;
        case S:
          return cg(o), null;
        case N:
          var B = o.type._context;
          return cC(B, o), null;
        case ve:
        case Y:
          return Y_(o), null;
        case le:
          return null;
        default:
          return null;
      }
    }
    function rM(i, o, d) {
      switch (eC(o), o.tag) {
        case g: {
          var h = o.type.childContextTypes;
          h != null && dS(o);
          break;
        }
        case v: {
          o.stateNode, cg(o), qE(o), zC();
          break;
        }
        case x: {
          DC(o);
          break;
        }
        case S:
          cg(o);
          break;
        case z:
          dg(o);
          break;
        case pe:
          dg(o);
          break;
        case N:
          var b = o.type._context;
          cC(b, o);
          break;
        case ve:
        case Y:
          Y_(o);
          break;
      }
    }
    var iM = null;
    iM = /* @__PURE__ */ new Set();
    var rw = !1, mo = !1, b8 = typeof WeakSet == "function" ? WeakSet : Set, vt = null, vg = null, yg = null;
    function S8(i) {
      Kc(null, function() {
        throw i;
      }), jm();
    }
    var w8 = function(i, o) {
      if (o.props = i.memoizedProps, o.state = i.memoizedState, i.mode & Lt)
        try {
          gc(), o.componentWillUnmount();
        } finally {
          hc(i);
        }
      else
        o.componentWillUnmount();
    };
    function oM(i, o) {
      try {
        $d(Ni, i);
      } catch (d) {
        Sr(i, o, d);
      }
    }
    function I_(i, o, d) {
      try {
        w8(i, d);
      } catch (h) {
        Sr(i, o, h);
      }
    }
    function x8(i, o, d) {
      try {
        d.componentDidMount();
      } catch (h) {
        Sr(i, o, h);
      }
    }
    function aM(i, o) {
      try {
        lM(i);
      } catch (d) {
        Sr(i, o, d);
      }
    }
    function bg(i, o) {
      var d = i.ref;
      if (d !== null)
        if (typeof d == "function") {
          var h;
          try {
            if (re && Qe && i.mode & Lt)
              try {
                gc(), h = d(null);
              } finally {
                hc(i);
              }
            else
              h = d(null);
          } catch (b) {
            Sr(i, o, b);
          }
          typeof h == "function" && c("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Ft(i));
        } else
          d.current = null;
    }
    function iw(i, o, d) {
      try {
        d();
      } catch (h) {
        Sr(i, o, h);
      }
    }
    var sM = !1;
    function E8(i, o) {
      N6(i.containerInfo), vt = o, C8();
      var d = sM;
      return sM = !1, d;
    }
    function C8() {
      for (; vt !== null; ) {
        var i = vt, o = i.child;
        (i.subtreeFlags & Qu) !== Mt && o !== null ? (o.return = i, vt = o) : _8();
      }
    }
    function _8() {
      for (; vt !== null; ) {
        var i = vt;
        Nn(i);
        try {
          T8(i);
        } catch (d) {
          Sr(i, i.return, d);
        }
        or();
        var o = i.sibling;
        if (o !== null) {
          o.return = i.return, vt = o;
          return;
        }
        vt = i.return;
      }
    }
    function T8(i) {
      var o = i.alternate, d = i.flags;
      if ((d & _a) !== Mt) {
        switch (Nn(i), i.tag) {
          case p:
          case j:
          case K:
            break;
          case g: {
            if (o !== null) {
              var h = o.memoizedProps, b = o.memoizedState, C = i.stateNode;
              i.type === i.elementType && !sp && (C.props !== i.memoizedProps && c("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ft(i) || "instance"), C.state !== i.memoizedState && c("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ft(i) || "instance"));
              var R = C.getSnapshotBeforeUpdate(i.elementType === i.type ? h : yl(i.type, h), b);
              {
                var A = iM;
                R === void 0 && !A.has(i.type) && (A.add(i.type), c("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", Ft(i)));
              }
              C.__reactInternalSnapshotBeforeUpdate = R;
            }
            break;
          }
          case v: {
            {
              var B = i.stateNode;
              sU(B.containerInfo);
            }
            break;
          }
          case x:
          case _:
          case S:
          case se:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        or();
      }
    }
    function xl(i, o, d) {
      var h = o.updateQueue, b = h !== null ? h.lastEffect : null;
      if (b !== null) {
        var C = b.next, R = C;
        do {
          if ((R.tag & i) === i) {
            var A = R.destroy;
            R.destroy = void 0, A !== void 0 && ((i & ho) !== La ? lh(o) : (i & Ni) !== La && ch(o), (i & dc) !== La && by(!0), iw(o, d, A), (i & dc) !== La && by(!1), (i & ho) !== La ? m0() : (i & Ni) !== La && Zu());
          }
          R = R.next;
        } while (R !== C);
      }
    }
    function $d(i, o) {
      var d = o.updateQueue, h = d !== null ? d.lastEffect : null;
      if (h !== null) {
        var b = h.next, C = b;
        do {
          if ((C.tag & i) === i) {
            (i & ho) !== La ? g0(o) : (i & Ni) !== La && v0(o);
            var R = C.create;
            (i & dc) !== La && by(!0), C.destroy = R(), (i & dc) !== La && by(!1), (i & ho) !== La ? qm() : (i & Ni) !== La && y0();
            {
              var A = C.destroy;
              if (A !== void 0 && typeof A != "function") {
                var B = void 0;
                (C.tag & Ni) !== Mt ? B = "useLayoutEffect" : (C.tag & dc) !== Mt ? B = "useInsertionEffect" : B = "useEffect";
                var V = void 0;
                A === null ? V = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof A.then == "function" ? V = `

It looks like you wrote ` + B + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + B + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : V = " You returned: " + A, c("%s must not return anything besides a function, which is used for clean-up.%s", B, V);
              }
            }
          }
          C = C.next;
        } while (C !== b);
      }
    }
    function k8(i, o) {
      if ((o.flags & on) !== Mt)
        switch (o.tag) {
          case L: {
            var d = o.stateNode.passiveEffectDuration, h = o.memoizedProps, b = h.id, C = h.onPostCommit, R = I$(), A = o.alternate === null ? "mount" : "update";
            P$() && (A = "nested-update"), typeof C == "function" && C(b, A, d, R);
            var B = o.return;
            e:
              for (; B !== null; ) {
                switch (B.tag) {
                  case v:
                    var V = B.stateNode;
                    V.passiveEffectDuration += d;
                    break e;
                  case L:
                    var G = B.stateNode;
                    G.passiveEffectDuration += d;
                    break e;
                }
                B = B.return;
              }
            break;
          }
        }
    }
    function P8(i, o, d, h) {
      if ((d.flags & Gi) !== Mt)
        switch (d.tag) {
          case p:
          case j:
          case K: {
            if (!mo)
              if (d.mode & Lt)
                try {
                  gc(), $d(Ni | Di, d);
                } finally {
                  hc(d);
                }
              else
                $d(Ni | Di, d);
            break;
          }
          case g: {
            var b = d.stateNode;
            if (d.flags & on && !mo)
              if (o === null)
                if (d.type === d.elementType && !sp && (b.props !== d.memoizedProps && c("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ft(d) || "instance"), b.state !== d.memoizedState && c("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ft(d) || "instance")), d.mode & Lt)
                  try {
                    gc(), b.componentDidMount();
                  } finally {
                    hc(d);
                  }
                else
                  b.componentDidMount();
              else {
                var C = d.elementType === d.type ? o.memoizedProps : yl(d.type, o.memoizedProps), R = o.memoizedState;
                if (d.type === d.elementType && !sp && (b.props !== d.memoizedProps && c("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ft(d) || "instance"), b.state !== d.memoizedState && c("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ft(d) || "instance")), d.mode & Lt)
                  try {
                    gc(), b.componentDidUpdate(C, R, b.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    hc(d);
                  }
                else
                  b.componentDidUpdate(C, R, b.__reactInternalSnapshotBeforeUpdate);
              }
            var A = d.updateQueue;
            A !== null && (d.type === d.elementType && !sp && (b.props !== d.memoizedProps && c("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ft(d) || "instance"), b.state !== d.memoizedState && c("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ft(d) || "instance")), FR(d, A, b));
            break;
          }
          case v: {
            var B = d.updateQueue;
            if (B !== null) {
              var V = null;
              if (d.child !== null)
                switch (d.child.tag) {
                  case x:
                    V = d.child.stateNode;
                    break;
                  case g:
                    V = d.child.stateNode;
                    break;
                }
              FR(d, B, V);
            }
            break;
          }
          case x: {
            var G = d.stateNode;
            if (o === null && d.flags & on) {
              var ae = d.type, ne = d.memoizedProps;
              W6(G, ae, ne);
            }
            break;
          }
          case _:
            break;
          case S:
            break;
          case L: {
            {
              var Ce = d.memoizedProps, _e = Ce.onCommit, Ae = Ce.onRender, ut = d.stateNode.effectDuration, Ot = I$(), Pt = o === null ? "mount" : "update";
              P$() && (Pt = "nested-update"), typeof Ae == "function" && Ae(d.memoizedProps.id, Pt, d.actualDuration, d.treeBaseDuration, d.actualStartTime, Ot);
              {
                typeof _e == "function" && _e(d.memoizedProps.id, Pt, ut, Ot), _F(d);
                var _n = d.return;
                e:
                  for (; _n !== null; ) {
                    switch (_n.tag) {
                      case v:
                        var vn = _n.stateNode;
                        vn.effectDuration += ut;
                        break e;
                      case L:
                        var be = _n.stateNode;
                        be.effectDuration += ut;
                        break e;
                    }
                    _n = _n.return;
                  }
              }
            }
            break;
          }
          case z: {
            N8(i, d);
            break;
          }
          case pe:
          case se:
          case Pe:
          case ve:
          case Y:
          case Re:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      mo || d.flags & Ro && lM(d);
    }
    function I8(i) {
      switch (i.tag) {
        case p:
        case j:
        case K: {
          if (i.mode & Lt)
            try {
              gc(), oM(i, i.return);
            } finally {
              hc(i);
            }
          else
            oM(i, i.return);
          break;
        }
        case g: {
          var o = i.stateNode;
          typeof o.componentDidMount == "function" && x8(i, i.return, o), aM(i, i.return);
          break;
        }
        case x: {
          aM(i, i.return);
          break;
        }
      }
    }
    function R8(i, o) {
      for (var d = null, h = i; ; ) {
        if (h.tag === x) {
          if (d === null) {
            d = h;
            try {
              var b = h.stateNode;
              o ? rU(b) : oU(h.stateNode, h.memoizedProps);
            } catch (R) {
              Sr(i, i.return, R);
            }
          }
        } else if (h.tag === _) {
          if (d === null)
            try {
              var C = h.stateNode;
              o ? iU(C) : aU(C, h.memoizedProps);
            } catch (R) {
              Sr(i, i.return, R);
            }
        } else if (!((h.tag === ve || h.tag === Y) && h.memoizedState !== null && h !== i)) {
          if (h.child !== null) {
            h.child.return = h, h = h.child;
            continue;
          }
        }
        if (h === i)
          return;
        for (; h.sibling === null; ) {
          if (h.return === null || h.return === i)
            return;
          d === h && (d = null), h = h.return;
        }
        d === h && (d = null), h.sibling.return = h.return, h = h.sibling;
      }
    }
    function lM(i) {
      var o = i.ref;
      if (o !== null) {
        var d = i.stateNode, h;
        switch (i.tag) {
          case x:
            h = d;
            break;
          default:
            h = d;
        }
        if (typeof o == "function") {
          var b;
          if (i.mode & Lt)
            try {
              gc(), b = o(h);
            } finally {
              hc(i);
            }
          else
            b = o(h);
          typeof b == "function" && c("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Ft(i));
        } else
          o.hasOwnProperty("current") || c("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", Ft(i)), o.current = h;
      }
    }
    function $8(i) {
      var o = i.alternate;
      o !== null && (o.return = null), i.return = null;
    }
    function cM(i) {
      var o = i.alternate;
      o !== null && (i.alternate = null, cM(o));
      {
        if (i.child = null, i.deletions = null, i.sibling = null, i.tag === x) {
          var d = i.stateNode;
          d !== null && jU(d);
        }
        i.stateNode = null, i._debugOwner = null, i.return = null, i.dependencies = null, i.memoizedProps = null, i.memoizedState = null, i.pendingProps = null, i.stateNode = null, i.updateQueue = null;
      }
    }
    function M8(i) {
      for (var o = i.return; o !== null; ) {
        if (uM(o))
          return o;
        o = o.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function uM(i) {
      return i.tag === x || i.tag === v || i.tag === S;
    }
    function dM(i) {
      var o = i;
      e:
        for (; ; ) {
          for (; o.sibling === null; ) {
            if (o.return === null || uM(o.return))
              return null;
            o = o.return;
          }
          for (o.sibling.return = o.return, o = o.sibling; o.tag !== x && o.tag !== _ && o.tag !== ue; ) {
            if (o.flags & mr || o.child === null || o.tag === S)
              continue e;
            o.child.return = o, o = o.child;
          }
          if (!(o.flags & mr))
            return o.stateNode;
        }
    }
    function A8(i) {
      var o = M8(i);
      switch (o.tag) {
        case x: {
          var d = o.stateNode;
          o.flags & Vn && (fR(d), o.flags &= ~Vn);
          var h = dM(i);
          $_(i, h, d);
          break;
        }
        case v:
        case S: {
          var b = o.stateNode.containerInfo, C = dM(i);
          R_(i, C, b);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function R_(i, o, d) {
      var h = i.tag, b = h === x || h === _;
      if (b) {
        var C = i.stateNode;
        o ? J6(d, C, o) : Q6(d, C);
      } else if (h !== S) {
        var R = i.child;
        if (R !== null) {
          R_(R, o, d);
          for (var A = R.sibling; A !== null; )
            R_(A, o, d), A = A.sibling;
        }
      }
    }
    function $_(i, o, d) {
      var h = i.tag, b = h === x || h === _;
      if (b) {
        var C = i.stateNode;
        o ? Z6(d, C, o) : q6(d, C);
      } else if (h !== S) {
        var R = i.child;
        if (R !== null) {
          $_(R, o, d);
          for (var A = R.sibling; A !== null; )
            $_(A, o, d), A = A.sibling;
        }
      }
    }
    var vo = null, El = !1;
    function O8(i, o, d) {
      {
        var h = o;
        e:
          for (; h !== null; ) {
            switch (h.tag) {
              case x: {
                vo = h.stateNode, El = !1;
                break e;
              }
              case v: {
                vo = h.stateNode.containerInfo, El = !0;
                break e;
              }
              case S: {
                vo = h.stateNode.containerInfo, El = !0;
                break e;
              }
            }
            h = h.return;
          }
        if (vo === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        fM(i, o, d), vo = null, El = !1;
      }
      $8(d);
    }
    function Md(i, o, d) {
      for (var h = d.child; h !== null; )
        fM(i, o, h), h = h.sibling;
    }
    function fM(i, o, d) {
      switch (Gm(d), d.tag) {
        case x:
          mo || bg(d, o);
        case _: {
          {
            var h = vo, b = El;
            vo = null, Md(i, o, d), vo = h, El = b, vo !== null && (El ? tU(vo, d.stateNode) : eU(vo, d.stateNode));
          }
          return;
        }
        case ue: {
          vo !== null && (El ? nU(vo, d.stateNode) : FE(vo, d.stateNode));
          return;
        }
        case S: {
          {
            var C = vo, R = El;
            vo = d.stateNode.containerInfo, El = !0, Md(i, o, d), vo = C, El = R;
          }
          return;
        }
        case p:
        case j:
        case F:
        case K: {
          if (!mo) {
            var A = d.updateQueue;
            if (A !== null) {
              var B = A.lastEffect;
              if (B !== null) {
                var V = B.next, G = V;
                do {
                  var ae = G, ne = ae.destroy, Ce = ae.tag;
                  ne !== void 0 && ((Ce & dc) !== La ? iw(d, o, ne) : (Ce & Ni) !== La && (ch(d), d.mode & Lt ? (gc(), iw(d, o, ne), hc(d)) : iw(d, o, ne), Zu())), G = G.next;
                } while (G !== V);
              }
            }
          }
          Md(i, o, d);
          return;
        }
        case g: {
          if (!mo) {
            bg(d, o);
            var _e = d.stateNode;
            typeof _e.componentWillUnmount == "function" && I_(d, o, _e);
          }
          Md(i, o, d);
          return;
        }
        case Pe: {
          Md(i, o, d);
          return;
        }
        case ve: {
          if (
            // TODO: Remove this dead flag
            d.mode & fn
          ) {
            var Ae = mo;
            mo = Ae || d.memoizedState !== null, Md(i, o, d), mo = Ae;
          } else
            Md(i, o, d);
          break;
        }
        default: {
          Md(i, o, d);
          return;
        }
      }
    }
    function D8(i) {
      i.memoizedState;
    }
    function N8(i, o) {
      var d = o.memoizedState;
      if (d === null) {
        var h = o.alternate;
        if (h !== null) {
          var b = h.memoizedState;
          if (b !== null) {
            var C = b.dehydrated;
            C !== null && wU(C);
          }
        }
      }
    }
    function pM(i) {
      var o = i.updateQueue;
      if (o !== null) {
        i.updateQueue = null;
        var d = i.stateNode;
        d === null && (d = i.stateNode = new b8()), o.forEach(function(h) {
          var b = MF.bind(null, i, h);
          if (!d.has(h)) {
            if (d.add(h), Ai)
              if (vg !== null && yg !== null)
                yy(yg, vg);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            h.then(b, b);
          }
        });
      }
    }
    function L8(i, o, d) {
      vg = d, yg = i, Nn(o), hM(o, i), Nn(o), vg = null, yg = null;
    }
    function Cl(i, o, d) {
      var h = o.deletions;
      if (h !== null)
        for (var b = 0; b < h.length; b++) {
          var C = h[b];
          try {
            O8(i, o, C);
          } catch (B) {
            Sr(C, o, B);
          }
        }
      var R = Fl();
      if (o.subtreeFlags & Ao)
        for (var A = o.child; A !== null; )
          Nn(A), hM(A, i), A = A.sibling;
      Nn(R);
    }
    function hM(i, o, d) {
      var h = i.alternate, b = i.flags;
      switch (i.tag) {
        case p:
        case j:
        case F:
        case K: {
          if (Cl(o, i), mc(i), b & on) {
            try {
              xl(dc | Di, i, i.return), $d(dc | Di, i);
            } catch (Bt) {
              Sr(i, i.return, Bt);
            }
            if (i.mode & Lt) {
              try {
                gc(), xl(Ni | Di, i, i.return);
              } catch (Bt) {
                Sr(i, i.return, Bt);
              }
              hc(i);
            } else
              try {
                xl(Ni | Di, i, i.return);
              } catch (Bt) {
                Sr(i, i.return, Bt);
              }
          }
          return;
        }
        case g: {
          Cl(o, i), mc(i), b & Ro && h !== null && bg(h, h.return);
          return;
        }
        case x: {
          Cl(o, i), mc(i), b & Ro && h !== null && bg(h, h.return);
          {
            if (i.flags & Vn) {
              var C = i.stateNode;
              try {
                fR(C);
              } catch (Bt) {
                Sr(i, i.return, Bt);
              }
            }
            if (b & on) {
              var R = i.stateNode;
              if (R != null) {
                var A = i.memoizedProps, B = h !== null ? h.memoizedProps : A, V = i.type, G = i.updateQueue;
                if (i.updateQueue = null, G !== null)
                  try {
                    G6(R, G, V, B, A, i);
                  } catch (Bt) {
                    Sr(i, i.return, Bt);
                  }
              }
            }
          }
          return;
        }
        case _: {
          if (Cl(o, i), mc(i), b & on) {
            if (i.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var ae = i.stateNode, ne = i.memoizedProps, Ce = h !== null ? h.memoizedProps : ne;
            try {
              X6(ae, Ce, ne);
            } catch (Bt) {
              Sr(i, i.return, Bt);
            }
          }
          return;
        }
        case v: {
          if (Cl(o, i), mc(i), b & on && h !== null) {
            var _e = h.memoizedState;
            if (_e.isDehydrated)
              try {
                SU(o.containerInfo);
              } catch (Bt) {
                Sr(i, i.return, Bt);
              }
          }
          return;
        }
        case S: {
          Cl(o, i), mc(i);
          return;
        }
        case z: {
          Cl(o, i), mc(i);
          var Ae = i.child;
          if (Ae.flags & Wl) {
            var ut = Ae.stateNode, Ot = Ae.memoizedState, Pt = Ot !== null;
            if (ut.isHidden = Pt, Pt) {
              var _n = Ae.alternate !== null && Ae.alternate.memoizedState !== null;
              _n || vF();
            }
          }
          if (b & on) {
            try {
              D8(i);
            } catch (Bt) {
              Sr(i, i.return, Bt);
            }
            pM(i);
          }
          return;
        }
        case ve: {
          var vn = h !== null && h.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            i.mode & fn
          ) {
            var be = mo;
            mo = be || vn, Cl(o, i), mo = be;
          } else
            Cl(o, i);
          if (mc(i), b & Wl) {
            var Oe = i.stateNode, Se = i.memoizedState, We = Se !== null, dt = i;
            if (Oe.isHidden = We, We && !vn && (dt.mode & fn) !== Dt) {
              vt = dt;
              for (var at = dt.child; at !== null; )
                vt = at, z8(at), at = at.sibling;
            }
            R8(dt, We);
          }
          return;
        }
        case pe: {
          Cl(o, i), mc(i), b & on && pM(i);
          return;
        }
        case Pe:
          return;
        default: {
          Cl(o, i), mc(i);
          return;
        }
      }
    }
    function mc(i) {
      var o = i.flags;
      if (o & mr) {
        try {
          A8(i);
        } catch (d) {
          Sr(i, i.return, d);
        }
        i.flags &= ~mr;
      }
      o & Ta && (i.flags &= ~Ta);
    }
    function j8(i, o, d) {
      vg = d, yg = o, vt = i, gM(i, o, d), vg = null, yg = null;
    }
    function gM(i, o, d) {
      for (var h = (i.mode & fn) !== Dt; vt !== null; ) {
        var b = vt, C = b.child;
        if (b.tag === ve && h) {
          var R = b.memoizedState !== null, A = R || rw;
          if (A) {
            M_(i, o, d);
            continue;
          } else {
            var B = b.alternate, V = B !== null && B.memoizedState !== null, G = V || mo, ae = rw, ne = mo;
            rw = A, mo = G, mo && !ne && (vt = b, U8(b));
            for (var Ce = C; Ce !== null; )
              vt = Ce, gM(
                Ce,
                // New root; bubble back up to here and stop.
                o,
                d
              ), Ce = Ce.sibling;
            vt = b, rw = ae, mo = ne, M_(i, o, d);
            continue;
          }
        }
        (b.subtreeFlags & Gi) !== Mt && C !== null ? (C.return = b, vt = C) : M_(i, o, d);
      }
    }
    function M_(i, o, d) {
      for (; vt !== null; ) {
        var h = vt;
        if ((h.flags & Gi) !== Mt) {
          var b = h.alternate;
          Nn(h);
          try {
            P8(o, b, h, d);
          } catch (R) {
            Sr(h, h.return, R);
          }
          or();
        }
        if (h === i) {
          vt = null;
          return;
        }
        var C = h.sibling;
        if (C !== null) {
          C.return = h.return, vt = C;
          return;
        }
        vt = h.return;
      }
    }
    function z8(i) {
      for (; vt !== null; ) {
        var o = vt, d = o.child;
        switch (o.tag) {
          case p:
          case j:
          case F:
          case K: {
            if (o.mode & Lt)
              try {
                gc(), xl(Ni, o, o.return);
              } finally {
                hc(o);
              }
            else
              xl(Ni, o, o.return);
            break;
          }
          case g: {
            bg(o, o.return);
            var h = o.stateNode;
            typeof h.componentWillUnmount == "function" && I_(o, o.return, h);
            break;
          }
          case x: {
            bg(o, o.return);
            break;
          }
          case ve: {
            var b = o.memoizedState !== null;
            if (b) {
              mM(i);
              continue;
            }
            break;
          }
        }
        d !== null ? (d.return = o, vt = d) : mM(i);
      }
    }
    function mM(i) {
      for (; vt !== null; ) {
        var o = vt;
        if (o === i) {
          vt = null;
          return;
        }
        var d = o.sibling;
        if (d !== null) {
          d.return = o.return, vt = d;
          return;
        }
        vt = o.return;
      }
    }
    function U8(i) {
      for (; vt !== null; ) {
        var o = vt, d = o.child;
        if (o.tag === ve) {
          var h = o.memoizedState !== null;
          if (h) {
            vM(i);
            continue;
          }
        }
        d !== null ? (d.return = o, vt = d) : vM(i);
      }
    }
    function vM(i) {
      for (; vt !== null; ) {
        var o = vt;
        Nn(o);
        try {
          I8(o);
        } catch (h) {
          Sr(o, o.return, h);
        }
        if (or(), o === i) {
          vt = null;
          return;
        }
        var d = o.sibling;
        if (d !== null) {
          d.return = o.return, vt = d;
          return;
        }
        vt = o.return;
      }
    }
    function B8(i, o, d, h) {
      vt = o, F8(o, i, d, h);
    }
    function F8(i, o, d, h) {
      for (; vt !== null; ) {
        var b = vt, C = b.child;
        (b.subtreeFlags & ka) !== Mt && C !== null ? (C.return = b, vt = C) : H8(i, o, d, h);
      }
    }
    function H8(i, o, d, h) {
      for (; vt !== null; ) {
        var b = vt;
        if ((b.flags & kr) !== Mt) {
          Nn(b);
          try {
            V8(o, b, d, h);
          } catch (R) {
            Sr(b, b.return, R);
          }
          or();
        }
        if (b === i) {
          vt = null;
          return;
        }
        var C = b.sibling;
        if (C !== null) {
          C.return = b.return, vt = C;
          return;
        }
        vt = b.return;
      }
    }
    function V8(i, o, d, h) {
      switch (o.tag) {
        case p:
        case j:
        case K: {
          if (o.mode & Lt) {
            c_();
            try {
              $d(ho | Di, o);
            } finally {
              l_(o);
            }
          } else
            $d(ho | Di, o);
          break;
        }
      }
    }
    function Y8(i) {
      vt = i, K8();
    }
    function K8() {
      for (; vt !== null; ) {
        var i = vt, o = i.child;
        if ((vt.flags & Un) !== Mt) {
          var d = i.deletions;
          if (d !== null) {
            for (var h = 0; h < d.length; h++) {
              var b = d[h];
              vt = b, X8(b, i);
            }
            {
              var C = i.alternate;
              if (C !== null) {
                var R = C.child;
                if (R !== null) {
                  C.child = null;
                  do {
                    var A = R.sibling;
                    R.sibling = null, R = A;
                  } while (R !== null);
                }
              }
            }
            vt = i;
          }
        }
        (i.subtreeFlags & ka) !== Mt && o !== null ? (o.return = i, vt = o) : W8();
      }
    }
    function W8() {
      for (; vt !== null; ) {
        var i = vt;
        (i.flags & kr) !== Mt && (Nn(i), G8(i), or());
        var o = i.sibling;
        if (o !== null) {
          o.return = i.return, vt = o;
          return;
        }
        vt = i.return;
      }
    }
    function G8(i) {
      switch (i.tag) {
        case p:
        case j:
        case K: {
          i.mode & Lt ? (c_(), xl(ho | Di, i, i.return), l_(i)) : xl(ho | Di, i, i.return);
          break;
        }
      }
    }
    function X8(i, o) {
      for (; vt !== null; ) {
        var d = vt;
        Nn(d), Q8(d, o), or();
        var h = d.child;
        h !== null ? (h.return = d, vt = h) : q8(i);
      }
    }
    function q8(i) {
      for (; vt !== null; ) {
        var o = vt, d = o.sibling, h = o.return;
        if (cM(o), o === i) {
          vt = null;
          return;
        }
        if (d !== null) {
          d.return = h, vt = d;
          return;
        }
        vt = h;
      }
    }
    function Q8(i, o) {
      switch (i.tag) {
        case p:
        case j:
        case K: {
          i.mode & Lt ? (c_(), xl(ho, i, o), l_(i)) : xl(ho, i, o);
          break;
        }
      }
    }
    function Z8(i) {
      switch (i.tag) {
        case p:
        case j:
        case K: {
          try {
            $d(Ni | Di, i);
          } catch (d) {
            Sr(i, i.return, d);
          }
          break;
        }
        case g: {
          var o = i.stateNode;
          try {
            o.componentDidMount();
          } catch (d) {
            Sr(i, i.return, d);
          }
          break;
        }
      }
    }
    function J8(i) {
      switch (i.tag) {
        case p:
        case j:
        case K: {
          try {
            $d(ho | Di, i);
          } catch (o) {
            Sr(i, i.return, o);
          }
          break;
        }
      }
    }
    function eF(i) {
      switch (i.tag) {
        case p:
        case j:
        case K: {
          try {
            xl(Ni | Di, i, i.return);
          } catch (d) {
            Sr(i, i.return, d);
          }
          break;
        }
        case g: {
          var o = i.stateNode;
          typeof o.componentWillUnmount == "function" && I_(i, i.return, o);
          break;
        }
      }
    }
    function tF(i) {
      switch (i.tag) {
        case p:
        case j:
        case K:
          try {
            xl(ho | Di, i, i.return);
          } catch (o) {
            Sr(i, i.return, o);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var sy = Symbol.for;
      sy("selector.component"), sy("selector.has_pseudo_class"), sy("selector.role"), sy("selector.test_id"), sy("selector.text");
    }
    var nF = [];
    function rF() {
      nF.forEach(function(i) {
        return i();
      });
    }
    var iF = n.ReactCurrentActQueue;
    function oF(i) {
      {
        var o = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), d = typeof jest < "u";
        return d && o !== !1;
      }
    }
    function yM() {
      {
        var i = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !i && iF.current !== null && c("The current testing environment is not configured to support act(...)"), i;
      }
    }
    var aF = Math.ceil, A_ = n.ReactCurrentDispatcher, O_ = n.ReactCurrentOwner, yo = n.ReactCurrentBatchConfig, _l = n.ReactCurrentActQueue, zi = (
      /*             */
      0
    ), bM = (
      /*               */
      1
    ), bo = (
      /*                */
      2
    ), Ns = (
      /*                */
      4
    ), wu = 0, ly = 1, lp = 2, ow = 3, cy = 4, SM = 5, D_ = 6, Cn = zi, ia = null, qr = null, Ui = Ne, vc = Ne, N_ = xd(Ne), Bi = wu, uy = null, aw = Ne, dy = Ne, sw = Ne, fy = null, ja = null, L_ = 0, wM = 500, xM = 1 / 0, sF = 500, xu = null;
    function py() {
      xM = Ar() + sF;
    }
    function EM() {
      return xM;
    }
    var lw = !1, j_ = null, Sg = null, cp = !1, Ad = null, hy = Ne, z_ = [], U_ = null, lF = 50, gy = 0, B_ = null, F_ = !1, cw = !1, cF = 50, wg = 0, uw = null, my = lr, dw = Ne, CM = !1;
    function fw() {
      return ia;
    }
    function oa() {
      return (Cn & (bo | Ns)) !== zi ? Ar() : (my !== lr || (my = Ar()), my);
    }
    function Od(i) {
      var o = i.mode;
      if ((o & fn) === Dt)
        return jt;
      if ((Cn & bo) !== zi && Ui !== Ne)
        return si(Ui);
      var d = oB() !== iB;
      if (d) {
        if (yo.transition !== null) {
          var h = yo.transition;
          h._updatedFibers || (h._updatedFibers = /* @__PURE__ */ new Set()), h._updatedFibers.add(i);
        }
        return dw === En && (dw = nv()), dw;
      }
      var b = $a();
      if (b !== En)
        return b;
      var C = H6();
      return C;
    }
    function uF(i) {
      var o = i.mode;
      return (o & fn) === Dt ? jt : cE();
    }
    function Fi(i, o, d, h) {
      OF(), CM && c("useInsertionEffect must not schedule updates."), F_ && (cw = !0), iu(i, d, h), (Cn & bo) !== Ne && i === ia ? LF(o) : (Ai && sv(i, o, d), jF(o), i === ia && ((Cn & bo) === zi && (dy = an(dy, d)), Bi === cy && Dd(i, Ui)), za(i, h), d === jt && Cn === zi && (o.mode & fn) === Dt && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !_l.isBatchingLegacy && (py(), ER()));
    }
    function dF(i, o, d) {
      var h = i.current;
      h.lanes = o, iu(i, o, d), za(i, d);
    }
    function fF(i) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (Cn & bo) !== zi
      );
    }
    function za(i, o) {
      var d = i.callbackNode;
      aE(i, o);
      var h = Of(i, i === ia ? Ui : Ne);
      if (h === Ne) {
        d !== null && UM(d), i.callbackNode = null, i.callbackPriority = En;
        return;
      }
      var b = ri(h), C = i.callbackPriority;
      if (C === b && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(_l.current !== null && d !== X_)) {
        d == null && C !== jt && c("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      d != null && UM(d);
      var R;
      if (b === jt)
        i.tag === Ed ? (_l.isBatchingLegacy !== null && (_l.didScheduleLegacyUpdate = !0), BU(kM.bind(null, i))) : xR(kM.bind(null, i)), _l.current !== null ? _l.current.push(Cd) : Y6(function() {
          (Cn & (bo | Ns)) === zi && Cd();
        }), R = null;
      else {
        var A;
        switch (zf(h)) {
          case Xi:
            A = oh;
            break;
          case Oi:
            A = ea;
            break;
          case ul:
            A = Ts;
            break;
          case Lf:
            A = Xl;
            break;
          default:
            A = Ts;
            break;
        }
        R = q_(A, _M.bind(null, i));
      }
      i.callbackPriority = b, i.callbackNode = R;
    }
    function _M(i, o) {
      if (OB(), my = lr, dw = Ne, (Cn & (bo | Ns)) !== zi)
        throw new Error("Should not already be working.");
      var d = i.callbackNode, h = Cu();
      if (h && i.callbackNode !== d)
        return null;
      var b = Of(i, i === ia ? Ui : Ne);
      if (b === Ne)
        return null;
      var C = !Nf(i, b) && !C0(i, b) && !o, R = C ? xF(i, b) : hw(i, b);
      if (R !== wu) {
        if (R === lp) {
          var A = ev(i);
          A !== Ne && (b = A, R = H_(i, A));
        }
        if (R === ly) {
          var B = uy;
          throw up(i, Ne), Dd(i, b), za(i, Ar()), B;
        }
        if (R === D_)
          Dd(i, b);
        else {
          var V = !Nf(i, b), G = i.current.alternate;
          if (V && !hF(G)) {
            if (R = hw(i, b), R === lp) {
              var ae = ev(i);
              ae !== Ne && (b = ae, R = H_(i, ae));
            }
            if (R === ly) {
              var ne = uy;
              throw up(i, Ne), Dd(i, b), za(i, Ar()), ne;
            }
          }
          i.finishedWork = G, i.finishedLanes = b, pF(i, R, b);
        }
      }
      return za(i, Ar()), i.callbackNode === d ? _M.bind(null, i) : null;
    }
    function H_(i, o) {
      var d = fy;
      if (ci(i)) {
        var h = up(i, o);
        h.flags |= Fr, OU(i.containerInfo);
      }
      var b = hw(i, o);
      if (b !== lp) {
        var C = ja;
        ja = d, C !== null && TM(C);
      }
      return b;
    }
    function TM(i) {
      ja === null ? ja = i : ja.push.apply(ja, i);
    }
    function pF(i, o, d) {
      switch (o) {
        case wu:
        case ly:
          throw new Error("Root did not complete. This is a bug in React.");
        case lp: {
          dp(i, ja, xu);
          break;
        }
        case ow: {
          if (Dd(i, d), Ih(d) && // do not delay if we're inside an act() scope
          !BM()) {
            var h = L_ + wM - Ar();
            if (h > 10) {
              var b = Of(i, Ne);
              if (b !== Ne)
                break;
              var C = i.suspendedLanes;
              if (!ru(C, d)) {
                oa(), ov(i, C);
                break;
              }
              i.timeoutHandle = UE(dp.bind(null, i, ja, xu), h);
              break;
            }
          }
          dp(i, ja, xu);
          break;
        }
        case cy: {
          if (Dd(i, d), E0(d))
            break;
          if (!BM()) {
            var R = x0(i, d), A = R, B = Ar() - A, V = AF(B) - B;
            if (V > 10) {
              i.timeoutHandle = UE(dp.bind(null, i, ja, xu), V);
              break;
            }
          }
          dp(i, ja, xu);
          break;
        }
        case SM: {
          dp(i, ja, xu);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function hF(i) {
      for (var o = i; ; ) {
        if (o.flags & kf) {
          var d = o.updateQueue;
          if (d !== null) {
            var h = d.stores;
            if (h !== null)
              for (var b = 0; b < h.length; b++) {
                var C = h[b], R = C.getSnapshot, A = C.value;
                try {
                  if (!mt(R(), A))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var B = o.child;
        if (o.subtreeFlags & kf && B !== null) {
          B.return = o, o = B;
          continue;
        }
        if (o === i)
          return !0;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === i)
            return !0;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
      return !0;
    }
    function Dd(i, o) {
      o = od(o, sw), o = od(o, dy), iv(i, o);
    }
    function kM(i) {
      if (DB(), (Cn & (bo | Ns)) !== zi)
        throw new Error("Should not already be working.");
      Cu();
      var o = Of(i, Ne);
      if (!Lo(o, jt))
        return za(i, Ar()), null;
      var d = hw(i, o);
      if (i.tag !== Ed && d === lp) {
        var h = ev(i);
        h !== Ne && (o = h, d = H_(i, h));
      }
      if (d === ly) {
        var b = uy;
        throw up(i, Ne), Dd(i, o), za(i, Ar()), b;
      }
      if (d === D_)
        throw new Error("Root did not complete. This is a bug in React.");
      var C = i.current.alternate;
      return i.finishedWork = C, i.finishedLanes = o, dp(i, ja, xu), za(i, Ar()), null;
    }
    function gF(i, o) {
      o !== Ne && (ad(i, an(o, jt)), za(i, Ar()), (Cn & (bo | Ns)) === zi && (py(), Cd()));
    }
    function V_(i, o) {
      var d = Cn;
      Cn |= bM;
      try {
        return i(o);
      } finally {
        Cn = d, Cn === zi && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !_l.isBatchingLegacy && (py(), ER());
      }
    }
    function mF(i, o, d, h, b) {
      var C = $a(), R = yo.transition;
      try {
        return yo.transition = null, li(Xi), i(o, d, h, b);
      } finally {
        li(C), yo.transition = R, Cn === zi && py();
      }
    }
    function Eu(i) {
      Ad !== null && Ad.tag === Ed && (Cn & (bo | Ns)) === zi && Cu();
      var o = Cn;
      Cn |= bM;
      var d = yo.transition, h = $a();
      try {
        return yo.transition = null, li(Xi), i ? i() : void 0;
      } finally {
        li(h), yo.transition = d, Cn = o, (Cn & (bo | Ns)) === zi && Cd();
      }
    }
    function PM() {
      return (Cn & (bo | Ns)) !== zi;
    }
    function pw(i, o) {
      zo(N_, vc, i), vc = an(vc, o);
    }
    function Y_(i) {
      vc = N_.current, jo(N_, i);
    }
    function up(i, o) {
      i.finishedWork = null, i.finishedLanes = Ne;
      var d = i.timeoutHandle;
      if (d !== BE && (i.timeoutHandle = BE, V6(d)), qr !== null)
        for (var h = qr.return; h !== null; ) {
          var b = h.alternate;
          rM(b, h), h = h.return;
        }
      ia = i;
      var C = fp(i.current, null);
      return qr = C, Ui = vc = o, Bi = wu, uy = null, aw = Ne, dy = Ne, sw = Ne, fy = null, ja = null, cB(), vl.discardPendingWarnings(), C;
    }
    function IM(i, o) {
      do {
        var d = qr;
        try {
          if (wS(), o$(), or(), O_.current = null, d === null || d.return === null) {
            Bi = ly, uy = o, qr = null;
            return;
          }
          if (re && d.mode & Lt && JS(d, !0), Me)
            if (Gc(), o !== null && typeof o == "object" && typeof o.then == "function") {
              var h = o;
              b0(d, h, Ui);
            } else
              uh(d, o, Ui);
          UB(i, d.return, d, o, Ui), AM(d);
        } catch (b) {
          o = b, qr === d && d !== null ? (d = d.return, qr = d) : d = qr;
          continue;
        }
        return;
      } while (!0);
    }
    function RM() {
      var i = A_.current;
      return A_.current = GS, i === null ? GS : i;
    }
    function $M(i) {
      A_.current = i;
    }
    function vF() {
      L_ = Ar();
    }
    function vy(i) {
      aw = an(i, aw);
    }
    function yF() {
      Bi === wu && (Bi = ow);
    }
    function K_() {
      (Bi === wu || Bi === ow || Bi === lp) && (Bi = cy), ia !== null && (Df(aw) || Df(dy)) && Dd(ia, Ui);
    }
    function bF(i) {
      Bi !== cy && (Bi = lp), fy === null ? fy = [i] : fy.push(i);
    }
    function SF() {
      return Bi === wu;
    }
    function hw(i, o) {
      var d = Cn;
      Cn |= bo;
      var h = RM();
      if (ia !== i || Ui !== o) {
        if (Ai) {
          var b = i.memoizedUpdaters;
          b.size > 0 && (yy(i, Ui), b.clear()), Mh(i, o);
        }
        xu = lv(), up(i, o);
      }
      ns(o);
      do
        try {
          wF();
          break;
        } catch (C) {
          IM(i, C);
        }
      while (!0);
      if (wS(), Cn = d, $M(h), qr !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return ed(), ia = null, Ui = Ne, Bi;
    }
    function wF() {
      for (; qr !== null; )
        MM(qr);
    }
    function xF(i, o) {
      var d = Cn;
      Cn |= bo;
      var h = RM();
      if (ia !== i || Ui !== o) {
        if (Ai) {
          var b = i.memoizedUpdaters;
          b.size > 0 && (yy(i, Ui), b.clear()), Mh(i, o);
        }
        xu = lv(), py(), up(i, o);
      }
      ns(o);
      do
        try {
          EF();
          break;
        } catch (C) {
          IM(i, C);
        }
      while (!0);
      return wS(), $M(h), Cn = d, qr !== null ? (Rf(), wu) : (ed(), ia = null, Ui = Ne, Bi);
    }
    function EF() {
      for (; qr !== null && !ih(); )
        MM(qr);
    }
    function MM(i) {
      var o = i.alternate;
      Nn(i);
      var d;
      (i.mode & Lt) !== Dt ? (s_(i), d = W_(o, i, vc), JS(i, !0)) : d = W_(o, i, vc), or(), i.memoizedProps = i.pendingProps, d === null ? AM(i) : qr = d, O_.current = null;
    }
    function AM(i) {
      var o = i;
      do {
        var d = o.alternate, h = o.return;
        if ((o.flags & Qo) === Mt) {
          Nn(o);
          var b = void 0;
          if ((o.mode & Lt) === Dt ? b = nM(d, o, vc) : (s_(o), b = nM(d, o, vc), JS(o, !1)), or(), b !== null) {
            qr = b;
            return;
          }
        } else {
          var C = y8(d, o);
          if (C !== null) {
            C.flags &= u0, qr = C;
            return;
          }
          if ((o.mode & Lt) !== Dt) {
            JS(o, !1);
            for (var R = o.actualDuration, A = o.child; A !== null; )
              R += A.actualDuration, A = A.sibling;
            o.actualDuration = R;
          }
          if (h !== null)
            h.flags |= Qo, h.subtreeFlags = Mt, h.deletions = null;
          else {
            Bi = D_, qr = null;
            return;
          }
        }
        var B = o.sibling;
        if (B !== null) {
          qr = B;
          return;
        }
        o = h, qr = o;
      } while (o !== null);
      Bi === wu && (Bi = SM);
    }
    function dp(i, o, d) {
      var h = $a(), b = yo.transition;
      try {
        yo.transition = null, li(Xi), CF(i, o, d, h);
      } finally {
        yo.transition = b, li(h);
      }
      return null;
    }
    function CF(i, o, d, h) {
      do
        Cu();
      while (Ad !== null);
      if (DF(), (Cn & (bo | Ns)) !== zi)
        throw new Error("Should not already be working.");
      var b = i.finishedWork, C = i.finishedLanes;
      if (sh(C), b === null)
        return Xm(), null;
      if (C === Ne && c("root.finishedLanes should not be empty during a commit. This is a bug in React."), i.finishedWork = null, i.finishedLanes = Ne, b === i.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      i.callbackNode = null, i.callbackPriority = En;
      var R = an(b.lanes, b.childLanes);
      av(i, R), i === ia && (ia = null, qr = null, Ui = Ne), ((b.subtreeFlags & ka) !== Mt || (b.flags & ka) !== Mt) && (cp || (cp = !0, U_ = d, q_(Ts, function() {
        return Cu(), null;
      })));
      var A = (b.subtreeFlags & (Qu | Ao | Gi | ka)) !== Mt, B = (b.flags & (Qu | Ao | Gi | ka)) !== Mt;
      if (A || B) {
        var V = yo.transition;
        yo.transition = null;
        var G = $a();
        li(Xi);
        var ae = Cn;
        Cn |= Ns, O_.current = null, E8(i, b), R$(), L8(i, b, C), L6(i.containerInfo), i.current = b, S0(C), j8(b, i, C), Ju(), p0(), Cn = ae, li(G), yo.transition = V;
      } else
        i.current = b, R$();
      var ne = cp;
      if (cp ? (cp = !1, Ad = i, hy = C) : (wg = 0, uw = null), R = i.pendingLanes, R === Ne && (Sg = null), ne || LM(i.current, !1), sl(b.stateNode, h), Ai && i.memoizedUpdaters.clear(), rF(), za(i, Ar()), o !== null)
        for (var Ce = i.onRecoverableError, _e = 0; _e < o.length; _e++) {
          var Ae = o[_e], ut = Ae.stack, Ot = Ae.digest;
          Ce(Ae.value, {
            componentStack: ut,
            digest: Ot
          });
        }
      if (lw) {
        lw = !1;
        var Pt = j_;
        throw j_ = null, Pt;
      }
      return Lo(hy, jt) && i.tag !== Ed && Cu(), R = i.pendingLanes, Lo(R, jt) ? (AB(), i === B_ ? gy++ : (gy = 0, B_ = i)) : gy = 0, Cd(), Xm(), null;
    }
    function Cu() {
      if (Ad !== null) {
        var i = zf(hy), o = dE(ul, i), d = yo.transition, h = $a();
        try {
          return yo.transition = null, li(o), TF();
        } finally {
          li(h), yo.transition = d;
        }
      }
      return !1;
    }
    function _F(i) {
      z_.push(i), cp || (cp = !0, q_(Ts, function() {
        return Cu(), null;
      }));
    }
    function TF() {
      if (Ad === null)
        return !1;
      var i = U_;
      U_ = null;
      var o = Ad, d = hy;
      if (Ad = null, hy = Ne, (Cn & (bo | Ns)) !== zi)
        throw new Error("Cannot flush passive effects while already rendering.");
      F_ = !0, cw = !1, w0(d);
      var h = Cn;
      Cn |= Ns, Y8(o.current), B8(o, o.current, d, i);
      {
        var b = z_;
        z_ = [];
        for (var C = 0; C < b.length; C++) {
          var R = b[C];
          k8(o, R);
        }
      }
      If(), LM(o.current, !0), Cn = h, Cd(), cw ? o === uw ? wg++ : (wg = 0, uw = o) : wg = 0, F_ = !1, cw = !1, Ql(o);
      {
        var A = o.current.stateNode;
        A.effectDuration = 0, A.passiveEffectDuration = 0;
      }
      return !0;
    }
    function OM(i) {
      return Sg !== null && Sg.has(i);
    }
    function kF(i) {
      Sg === null ? Sg = /* @__PURE__ */ new Set([i]) : Sg.add(i);
    }
    function PF(i) {
      lw || (lw = !0, j_ = i);
    }
    var IF = PF;
    function DM(i, o, d) {
      var h = ap(d, o), b = M$(i, h, jt), C = Td(i, b, jt), R = oa();
      C !== null && (iu(C, jt, R), za(C, R));
    }
    function Sr(i, o, d) {
      if (S8(d), by(!1), i.tag === v) {
        DM(i, i, d);
        return;
      }
      var h = null;
      for (h = o; h !== null; ) {
        if (h.tag === v) {
          DM(h, i, d);
          return;
        } else if (h.tag === g) {
          var b = h.type, C = h.stateNode;
          if (typeof b.getDerivedStateFromError == "function" || typeof C.componentDidCatch == "function" && !OM(C)) {
            var R = ap(d, i), A = p_(h, R, jt), B = Td(h, A, jt), V = oa();
            B !== null && (iu(B, jt, V), za(B, V));
            return;
          }
        }
        h = h.return;
      }
      c(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, d);
    }
    function RF(i, o, d) {
      var h = i.pingCache;
      h !== null && h.delete(o);
      var b = oa();
      ov(i, d), zF(i), ia === i && ru(Ui, d) && (Bi === cy || Bi === ow && Ih(Ui) && Ar() - L_ < wM ? up(i, Ne) : sw = an(sw, d)), za(i, b);
    }
    function NM(i, o) {
      o === En && (o = uF(i));
      var d = oa(), h = Na(i, o);
      h !== null && (iu(h, o, d), za(h, d));
    }
    function $F(i) {
      var o = i.memoizedState, d = En;
      o !== null && (d = o.retryLane), NM(i, d);
    }
    function MF(i, o) {
      var d = En, h;
      switch (i.tag) {
        case z:
          h = i.stateNode;
          var b = i.memoizedState;
          b !== null && (d = b.retryLane);
          break;
        case pe:
          h = i.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      h !== null && h.delete(o), NM(i, d);
    }
    function AF(i) {
      return i < 120 ? 120 : i < 480 ? 480 : i < 1080 ? 1080 : i < 1920 ? 1920 : i < 3e3 ? 3e3 : i < 4320 ? 4320 : aF(i / 1960) * 1960;
    }
    function OF() {
      if (gy > lF)
        throw gy = 0, B_ = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      wg > cF && (wg = 0, uw = null, c("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function DF() {
      vl.flushLegacyContextWarning(), vl.flushPendingUnsafeLifecycleWarnings();
    }
    function LM(i, o) {
      Nn(i), gw(i, Mo, eF), o && gw(i, Wc, tF), gw(i, Mo, Z8), o && gw(i, Wc, J8), or();
    }
    function gw(i, o, d) {
      for (var h = i, b = null; h !== null; ) {
        var C = h.subtreeFlags & o;
        h !== b && h.child !== null && C !== Mt ? h = h.child : ((h.flags & o) !== Mt && d(h), h.sibling !== null ? h = h.sibling : h = b = h.return);
      }
    }
    var mw = null;
    function jM(i) {
      {
        if ((Cn & bo) !== zi || !(i.mode & fn))
          return;
        var o = i.tag;
        if (o !== y && o !== v && o !== g && o !== p && o !== j && o !== F && o !== K)
          return;
        var d = Ft(i) || "ReactComponent";
        if (mw !== null) {
          if (mw.has(d))
            return;
          mw.add(d);
        } else
          mw = /* @__PURE__ */ new Set([d]);
        var h = gr;
        try {
          Nn(i), c("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          h ? Nn(i) : or();
        }
      }
    }
    var W_;
    {
      var NF = null;
      W_ = function(i, o, d) {
        var h = KM(NF, o);
        try {
          return Q$(i, o, d);
        } catch (C) {
          if (XU() || C !== null && typeof C == "object" && typeof C.then == "function")
            throw C;
          if (wS(), o$(), rM(i, o), KM(o, h), o.mode & Lt && s_(o), Kc(null, Q$, null, i, o, d), iE()) {
            var b = jm();
            typeof b == "object" && b !== null && b._suppressLogging && typeof C == "object" && C !== null && !C._suppressLogging && (C._suppressLogging = !0);
          }
          throw C;
        }
      };
    }
    var zM = !1, G_;
    G_ = /* @__PURE__ */ new Set();
    function LF(i) {
      if (Br && !RB())
        switch (i.tag) {
          case p:
          case j:
          case K: {
            var o = qr && Ft(qr) || "Unknown", d = o;
            if (!G_.has(d)) {
              G_.add(d);
              var h = Ft(i) || "Unknown";
              c("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", h, o, o);
            }
            break;
          }
          case g: {
            zM || (c("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), zM = !0);
            break;
          }
        }
    }
    function yy(i, o) {
      if (Ai) {
        var d = i.memoizedUpdaters;
        d.forEach(function(h) {
          sv(i, h, o);
        });
      }
    }
    var X_ = {};
    function q_(i, o) {
      {
        var d = _l.current;
        return d !== null ? (d.push(o), X_) : rh(i, o);
      }
    }
    function UM(i) {
      if (i !== X_)
        return f0(i);
    }
    function BM() {
      return _l.current !== null;
    }
    function jF(i) {
      {
        if (i.mode & fn) {
          if (!yM())
            return;
        } else if (!oF() || Cn !== zi || i.tag !== p && i.tag !== j && i.tag !== K)
          return;
        if (_l.current === null) {
          var o = gr;
          try {
            Nn(i), c(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, Ft(i));
          } finally {
            o ? Nn(i) : or();
          }
        }
      }
    }
    function zF(i) {
      i.tag !== Ed && yM() && _l.current === null && c(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function by(i) {
      CM = i;
    }
    var Ls = null, xg = null, UF = function(i) {
      Ls = i;
    };
    function Eg(i) {
      {
        if (Ls === null)
          return i;
        var o = Ls(i);
        return o === void 0 ? i : o.current;
      }
    }
    function Q_(i) {
      return Eg(i);
    }
    function Z_(i) {
      {
        if (Ls === null)
          return i;
        var o = Ls(i);
        if (o === void 0) {
          if (i != null && typeof i.render == "function") {
            var d = Eg(i.render);
            if (i.render !== d) {
              var h = {
                $$typeof: st,
                render: d
              };
              return i.displayName !== void 0 && (h.displayName = i.displayName), h;
            }
          }
          return i;
        }
        return o.current;
      }
    }
    function FM(i, o) {
      {
        if (Ls === null)
          return !1;
        var d = i.elementType, h = o.type, b = !1, C = typeof h == "object" && h !== null ? h.$$typeof : null;
        switch (i.tag) {
          case g: {
            typeof h == "function" && (b = !0);
            break;
          }
          case p: {
            (typeof h == "function" || C === Rt) && (b = !0);
            break;
          }
          case j: {
            (C === st || C === Rt) && (b = !0);
            break;
          }
          case F:
          case K: {
            (C === Qt || C === Rt) && (b = !0);
            break;
          }
          default:
            return !1;
        }
        if (b) {
          var R = Ls(d);
          if (R !== void 0 && R === Ls(h))
            return !0;
        }
        return !1;
      }
    }
    function HM(i) {
      {
        if (Ls === null || typeof WeakSet != "function")
          return;
        xg === null && (xg = /* @__PURE__ */ new WeakSet()), xg.add(i);
      }
    }
    var BF = function(i, o) {
      {
        if (Ls === null)
          return;
        var d = o.staleFamilies, h = o.updatedFamilies;
        Cu(), Eu(function() {
          J_(i.current, h, d);
        });
      }
    }, FF = function(i, o) {
      {
        if (i.context !== is)
          return;
        Cu(), Eu(function() {
          Sy(o, i, null, null);
        });
      }
    };
    function J_(i, o, d) {
      {
        var h = i.alternate, b = i.child, C = i.sibling, R = i.tag, A = i.type, B = null;
        switch (R) {
          case p:
          case K:
          case g:
            B = A;
            break;
          case j:
            B = A.render;
            break;
        }
        if (Ls === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var V = !1, G = !1;
        if (B !== null) {
          var ae = Ls(B);
          ae !== void 0 && (d.has(ae) ? G = !0 : o.has(ae) && (R === g ? G = !0 : V = !0));
        }
        if (xg !== null && (xg.has(i) || h !== null && xg.has(h)) && (G = !0), G && (i._debugNeedsRemount = !0), G || V) {
          var ne = Na(i, jt);
          ne !== null && Fi(ne, i, jt, lr);
        }
        b !== null && !G && J_(b, o, d), C !== null && J_(C, o, d);
      }
    }
    var HF = function(i, o) {
      {
        var d = /* @__PURE__ */ new Set(), h = new Set(o.map(function(b) {
          return b.current;
        }));
        return eT(i.current, h, d), d;
      }
    };
    function eT(i, o, d) {
      {
        var h = i.child, b = i.sibling, C = i.tag, R = i.type, A = null;
        switch (C) {
          case p:
          case K:
          case g:
            A = R;
            break;
          case j:
            A = R.render;
            break;
        }
        var B = !1;
        A !== null && o.has(A) && (B = !0), B ? VF(i, d) : h !== null && eT(h, o, d), b !== null && eT(b, o, d);
      }
    }
    function VF(i, o) {
      {
        var d = YF(i, o);
        if (d)
          return;
        for (var h = i; ; ) {
          switch (h.tag) {
            case x:
              o.add(h.stateNode);
              return;
            case S:
              o.add(h.stateNode.containerInfo);
              return;
            case v:
              o.add(h.stateNode.containerInfo);
              return;
          }
          if (h.return === null)
            throw new Error("Expected to reach root first.");
          h = h.return;
        }
      }
    }
    function YF(i, o) {
      for (var d = i, h = !1; ; ) {
        if (d.tag === x)
          h = !0, o.add(d.stateNode);
        else if (d.child !== null) {
          d.child.return = d, d = d.child;
          continue;
        }
        if (d === i)
          return h;
        for (; d.sibling === null; ) {
          if (d.return === null || d.return === i)
            return h;
          d = d.return;
        }
        d.sibling.return = d.return, d = d.sibling;
      }
      return !1;
    }
    var tT;
    {
      tT = !1;
      try {
        var VM = Object.preventExtensions({});
      } catch {
        tT = !0;
      }
    }
    function KF(i, o, d, h) {
      this.tag = i, this.key = d, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = o, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = h, this.flags = Mt, this.subtreeFlags = Mt, this.deletions = null, this.lanes = Ne, this.childLanes = Ne, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !tT && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var os = function(i, o, d, h) {
      return new KF(i, o, d, h);
    };
    function nT(i) {
      var o = i.prototype;
      return !!(o && o.isReactComponent);
    }
    function WF(i) {
      return typeof i == "function" && !nT(i) && i.defaultProps === void 0;
    }
    function GF(i) {
      if (typeof i == "function")
        return nT(i) ? g : p;
      if (i != null) {
        var o = i.$$typeof;
        if (o === st)
          return j;
        if (o === Qt)
          return F;
      }
      return y;
    }
    function fp(i, o) {
      var d = i.alternate;
      d === null ? (d = os(i.tag, o, i.key, i.mode), d.elementType = i.elementType, d.type = i.type, d.stateNode = i.stateNode, d._debugSource = i._debugSource, d._debugOwner = i._debugOwner, d._debugHookTypes = i._debugHookTypes, d.alternate = i, i.alternate = d) : (d.pendingProps = o, d.type = i.type, d.flags = Mt, d.subtreeFlags = Mt, d.deletions = null, d.actualDuration = 0, d.actualStartTime = -1), d.flags = i.flags & Mi, d.childLanes = i.childLanes, d.lanes = i.lanes, d.child = i.child, d.memoizedProps = i.memoizedProps, d.memoizedState = i.memoizedState, d.updateQueue = i.updateQueue;
      var h = i.dependencies;
      switch (d.dependencies = h === null ? null : {
        lanes: h.lanes,
        firstContext: h.firstContext
      }, d.sibling = i.sibling, d.index = i.index, d.ref = i.ref, d.selfBaseDuration = i.selfBaseDuration, d.treeBaseDuration = i.treeBaseDuration, d._debugNeedsRemount = i._debugNeedsRemount, d.tag) {
        case y:
        case p:
        case K:
          d.type = Eg(i.type);
          break;
        case g:
          d.type = Q_(i.type);
          break;
        case j:
          d.type = Z_(i.type);
          break;
      }
      return d;
    }
    function XF(i, o) {
      i.flags &= Mi | mr;
      var d = i.alternate;
      if (d === null)
        i.childLanes = Ne, i.lanes = o, i.child = null, i.subtreeFlags = Mt, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null, i.selfBaseDuration = 0, i.treeBaseDuration = 0;
      else {
        i.childLanes = d.childLanes, i.lanes = d.lanes, i.child = d.child, i.subtreeFlags = Mt, i.deletions = null, i.memoizedProps = d.memoizedProps, i.memoizedState = d.memoizedState, i.updateQueue = d.updateQueue, i.type = d.type;
        var h = d.dependencies;
        i.dependencies = h === null ? null : {
          lanes: h.lanes,
          firstContext: h.firstContext
        }, i.selfBaseDuration = d.selfBaseDuration, i.treeBaseDuration = d.treeBaseDuration;
      }
      return i;
    }
    function qF(i, o, d) {
      var h;
      return i === pS ? (h = fn, o === !0 && (h |= Or, h |= Ia)) : h = Dt, Ai && (h |= Lt), os(v, null, null, h);
    }
    function rT(i, o, d, h, b, C) {
      var R = y, A = i;
      if (typeof i == "function")
        nT(i) ? (R = g, A = Q_(A)) : A = Eg(A);
      else if (typeof i == "string")
        R = x;
      else
        e:
          switch (i) {
            case Ri:
              return Nd(d.children, b, C, o);
            case yi:
              R = I, b |= Or, (b & fn) !== Dt && (b |= Ia);
              break;
            case J:
              return QF(d, b, C, o);
            case Kt:
              return ZF(d, b, C, o);
            case qt:
              return JF(d, b, C, o);
            case Zn:
              return YM(d, b, C, o);
            case hr:
            case Ur:
            case wa:
            case Nl:
            case Qn:
            default: {
              if (typeof i == "object" && i !== null)
                switch (i.$$typeof) {
                  case Be:
                    R = N;
                    break e;
                  case et:
                    R = D;
                    break e;
                  case st:
                    R = j, A = Z_(A);
                    break e;
                  case Qt:
                    R = F;
                    break e;
                  case Rt:
                    R = X, A = null;
                    break e;
                }
              var B = "";
              {
                (i === void 0 || typeof i == "object" && i !== null && Object.keys(i).length === 0) && (B += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
                var V = h ? Ft(h) : null;
                V && (B += `

Check the render method of \`` + V + "`.");
              }
              throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (i == null ? i : typeof i) + "." + B));
            }
          }
      var G = os(R, d, o, b);
      return G.elementType = i, G.type = A, G.lanes = C, G._debugOwner = h, G;
    }
    function iT(i, o, d) {
      var h = null;
      h = i._owner;
      var b = i.type, C = i.key, R = i.props, A = rT(b, C, R, h, o, d);
      return A._debugSource = i._source, A._debugOwner = i._owner, A;
    }
    function Nd(i, o, d, h) {
      var b = os(T, i, h, o);
      return b.lanes = d, b;
    }
    function QF(i, o, d, h) {
      typeof i.id != "string" && c('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof i.id);
      var b = os(L, i, h, o | Lt);
      return b.elementType = J, b.lanes = d, b.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, b;
    }
    function ZF(i, o, d, h) {
      var b = os(z, i, h, o);
      return b.elementType = Kt, b.lanes = d, b;
    }
    function JF(i, o, d, h) {
      var b = os(pe, i, h, o);
      return b.elementType = qt, b.lanes = d, b;
    }
    function YM(i, o, d, h) {
      var b = os(ve, i, h, o);
      b.elementType = Zn, b.lanes = d;
      var C = {
        isHidden: !1
      };
      return b.stateNode = C, b;
    }
    function oT(i, o, d) {
      var h = os(_, i, null, o);
      return h.lanes = d, h;
    }
    function e7() {
      var i = os(x, null, null, Dt);
      return i.elementType = "DELETED", i;
    }
    function t7(i) {
      var o = os(ue, null, null, Dt);
      return o.stateNode = i, o;
    }
    function aT(i, o, d) {
      var h = i.children !== null ? i.children : [], b = os(S, h, i.key, o);
      return b.lanes = d, b.stateNode = {
        containerInfo: i.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: i.implementation
      }, b;
    }
    function KM(i, o) {
      return i === null && (i = os(y, null, null, Dt)), i.tag = o.tag, i.key = o.key, i.elementType = o.elementType, i.type = o.type, i.stateNode = o.stateNode, i.return = o.return, i.child = o.child, i.sibling = o.sibling, i.index = o.index, i.ref = o.ref, i.pendingProps = o.pendingProps, i.memoizedProps = o.memoizedProps, i.updateQueue = o.updateQueue, i.memoizedState = o.memoizedState, i.dependencies = o.dependencies, i.mode = o.mode, i.flags = o.flags, i.subtreeFlags = o.subtreeFlags, i.deletions = o.deletions, i.lanes = o.lanes, i.childLanes = o.childLanes, i.alternate = o.alternate, i.actualDuration = o.actualDuration, i.actualStartTime = o.actualStartTime, i.selfBaseDuration = o.selfBaseDuration, i.treeBaseDuration = o.treeBaseDuration, i._debugSource = o._debugSource, i._debugOwner = o._debugOwner, i._debugNeedsRemount = o._debugNeedsRemount, i._debugHookTypes = o._debugHookTypes, i;
    }
    function n7(i, o, d, h, b) {
      this.tag = o, this.containerInfo = i, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = BE, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = En, this.eventTimes = $h(Ne), this.expirationTimes = $h(lr), this.pendingLanes = Ne, this.suspendedLanes = Ne, this.pingedLanes = Ne, this.expiredLanes = Ne, this.mutableReadLanes = Ne, this.finishedLanes = Ne, this.entangledLanes = Ne, this.entanglements = $h(Ne), this.identifierPrefix = h, this.onRecoverableError = b, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var C = this.pendingUpdatersLaneMap = [], R = 0; R < yr; R++)
          C.push(/* @__PURE__ */ new Set());
      }
      switch (o) {
        case pS:
          this._debugRootType = d ? "hydrateRoot()" : "createRoot()";
          break;
        case Ed:
          this._debugRootType = d ? "hydrate()" : "render()";
          break;
      }
    }
    function WM(i, o, d, h, b, C, R, A, B, V) {
      var G = new n7(i, o, d, A, B), ae = qF(o, C);
      G.current = ae, ae.stateNode = G;
      {
        var ne = {
          element: h,
          isDehydrated: d,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        ae.memoizedState = ne;
      }
      return hC(ae), G;
    }
    var sT = "18.2.0";
    function r7(i, o, d) {
      var h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return Er(h), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: vi,
        key: h == null ? null : "" + h,
        children: i,
        containerInfo: o,
        implementation: d
      };
    }
    var lT, cT;
    lT = !1, cT = {};
    function GM(i) {
      if (!i)
        return is;
      var o = Ca(i), d = UU(o);
      if (o.tag === g) {
        var h = o.type;
        if (uc(h))
          return SR(o, h, d);
      }
      return d;
    }
    function i7(i, o) {
      {
        var d = Ca(i);
        if (d === void 0) {
          if (typeof i.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var h = Object.keys(i).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + h);
        }
        var b = Pa(d);
        if (b === null)
          return null;
        if (b.mode & Or) {
          var C = Ft(d) || "Component";
          if (!cT[C]) {
            cT[C] = !0;
            var R = gr;
            try {
              Nn(b), d.mode & Or ? c("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", o, o, C) : c("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", o, o, C);
            } finally {
              R ? Nn(R) : or();
            }
          }
        }
        return b.stateNode;
      }
    }
    function XM(i, o, d, h, b, C, R, A) {
      var B = !1, V = null;
      return WM(i, o, B, V, d, h, b, C, R);
    }
    function qM(i, o, d, h, b, C, R, A, B, V) {
      var G = !0, ae = WM(d, h, G, i, b, C, R, A, B);
      ae.context = GM(null);
      var ne = ae.current, Ce = oa(), _e = Od(ne), Ae = bu(Ce, _e);
      return Ae.callback = o ?? null, Td(ne, Ae, _e), dF(ae, _e, Ce), ae;
    }
    function Sy(i, o, d, h) {
      h0(o, i);
      var b = o.current, C = oa(), R = Od(b);
      Xc(R);
      var A = GM(d);
      o.context === null ? o.context = A : o.pendingContext = A, Br && gr !== null && !lT && (lT = !0, c(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, Ft(gr) || "Unknown"));
      var B = bu(C, R);
      B.payload = {
        element: i
      }, h = h === void 0 ? null : h, h !== null && (typeof h != "function" && c("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", h), B.callback = h);
      var V = Td(b, B, R);
      return V !== null && (Fi(V, b, R, C), TS(V, b, R)), R;
    }
    function vw(i) {
      var o = i.current;
      if (!o.child)
        return null;
      switch (o.child.tag) {
        case x:
          return o.child.stateNode;
        default:
          return o.child.stateNode;
      }
    }
    function o7(i) {
      switch (i.tag) {
        case v: {
          var o = i.stateNode;
          if (ci(o)) {
            var d = sE(o);
            gF(o, d);
          }
          break;
        }
        case z: {
          Eu(function() {
            var b = Na(i, jt);
            if (b !== null) {
              var C = oa();
              Fi(b, i, jt, C);
            }
          });
          var h = jt;
          uT(i, h);
          break;
        }
      }
    }
    function QM(i, o) {
      var d = i.memoizedState;
      d !== null && d.dehydrated !== null && (d.retryLane = T0(d.retryLane, o));
    }
    function uT(i, o) {
      QM(i, o);
      var d = i.alternate;
      d && QM(d, o);
    }
    function a7(i) {
      if (i.tag === z) {
        var o = td, d = Na(i, o);
        if (d !== null) {
          var h = oa();
          Fi(d, i, o, h);
        }
        uT(i, o);
      }
    }
    function s7(i) {
      if (i.tag === z) {
        var o = Od(i), d = Na(i, o);
        if (d !== null) {
          var h = oa();
          Fi(d, i, o, h);
        }
        uT(i, o);
      }
    }
    function ZM(i) {
      var o = d0(i);
      return o === null ? null : o.stateNode;
    }
    var JM = function(i) {
      return null;
    };
    function l7(i) {
      return JM(i);
    }
    var eA = function(i) {
      return !1;
    };
    function c7(i) {
      return eA(i);
    }
    var tA = null, nA = null, rA = null, iA = null, oA = null, aA = null, sA = null, lA = null, cA = null;
    {
      var uA = function(i, o, d) {
        var h = o[d], b = Sn(i) ? i.slice() : Jt({}, i);
        return d + 1 === o.length ? (Sn(b) ? b.splice(h, 1) : delete b[h], b) : (b[h] = uA(i[h], o, d + 1), b);
      }, dA = function(i, o) {
        return uA(i, o, 0);
      }, fA = function(i, o, d, h) {
        var b = o[h], C = Sn(i) ? i.slice() : Jt({}, i);
        if (h + 1 === o.length) {
          var R = d[h];
          C[R] = C[b], Sn(C) ? C.splice(b, 1) : delete C[b];
        } else
          C[b] = fA(
            // $FlowFixMe number or string is fine here
            i[b],
            o,
            d,
            h + 1
          );
        return C;
      }, pA = function(i, o, d) {
        if (o.length !== d.length) {
          s("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var h = 0; h < d.length - 1; h++)
            if (o[h] !== d[h]) {
              s("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return fA(i, o, d, 0);
      }, hA = function(i, o, d, h) {
        if (d >= o.length)
          return h;
        var b = o[d], C = Sn(i) ? i.slice() : Jt({}, i);
        return C[b] = hA(i[b], o, d + 1, h), C;
      }, gA = function(i, o, d) {
        return hA(i, o, 0, d);
      }, dT = function(i, o) {
        for (var d = i.memoizedState; d !== null && o > 0; )
          d = d.next, o--;
        return d;
      };
      tA = function(i, o, d, h) {
        var b = dT(i, o);
        if (b !== null) {
          var C = gA(b.memoizedState, d, h);
          b.memoizedState = C, b.baseState = C, i.memoizedProps = Jt({}, i.memoizedProps);
          var R = Na(i, jt);
          R !== null && Fi(R, i, jt, lr);
        }
      }, nA = function(i, o, d) {
        var h = dT(i, o);
        if (h !== null) {
          var b = dA(h.memoizedState, d);
          h.memoizedState = b, h.baseState = b, i.memoizedProps = Jt({}, i.memoizedProps);
          var C = Na(i, jt);
          C !== null && Fi(C, i, jt, lr);
        }
      }, rA = function(i, o, d, h) {
        var b = dT(i, o);
        if (b !== null) {
          var C = pA(b.memoizedState, d, h);
          b.memoizedState = C, b.baseState = C, i.memoizedProps = Jt({}, i.memoizedProps);
          var R = Na(i, jt);
          R !== null && Fi(R, i, jt, lr);
        }
      }, iA = function(i, o, d) {
        i.pendingProps = gA(i.memoizedProps, o, d), i.alternate && (i.alternate.pendingProps = i.pendingProps);
        var h = Na(i, jt);
        h !== null && Fi(h, i, jt, lr);
      }, oA = function(i, o) {
        i.pendingProps = dA(i.memoizedProps, o), i.alternate && (i.alternate.pendingProps = i.pendingProps);
        var d = Na(i, jt);
        d !== null && Fi(d, i, jt, lr);
      }, aA = function(i, o, d) {
        i.pendingProps = pA(i.memoizedProps, o, d), i.alternate && (i.alternate.pendingProps = i.pendingProps);
        var h = Na(i, jt);
        h !== null && Fi(h, i, jt, lr);
      }, sA = function(i) {
        var o = Na(i, jt);
        o !== null && Fi(o, i, jt, lr);
      }, lA = function(i) {
        JM = i;
      }, cA = function(i) {
        eA = i;
      };
    }
    function u7(i) {
      var o = Pa(i);
      return o === null ? null : o.stateNode;
    }
    function d7(i) {
      return null;
    }
    function f7() {
      return gr;
    }
    function p7(i) {
      var o = i.findFiberByHostInstance, d = n.ReactCurrentDispatcher;
      return Wm({
        bundleType: i.bundleType,
        version: i.version,
        rendererPackageName: i.rendererPackageName,
        rendererConfig: i.rendererConfig,
        overrideHookState: tA,
        overrideHookStateDeletePath: nA,
        overrideHookStateRenamePath: rA,
        overrideProps: iA,
        overridePropsDeletePath: oA,
        overridePropsRenamePath: aA,
        setErrorHandler: lA,
        setSuspenseHandler: cA,
        scheduleUpdate: sA,
        currentDispatcherRef: d,
        findHostInstanceByFiber: u7,
        findFiberByHostInstance: o || d7,
        // React Refresh
        findHostInstancesForRefresh: HF,
        scheduleRefresh: BF,
        scheduleRoot: FF,
        setRefreshHandler: UF,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: f7,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: sT
      });
    }
    var mA = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(i) {
      console.error(i);
    };
    function fT(i) {
      this._internalRoot = i;
    }
    yw.prototype.render = fT.prototype.render = function(i) {
      var o = this._internalRoot;
      if (o === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? c("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : bw(arguments[1]) ? c("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && c("You passed a second argument to root.render(...) but it only accepts one argument.");
        var d = o.containerInfo;
        if (d.nodeType !== ni) {
          var h = ZM(o.current);
          h && h.parentNode !== d && c("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      Sy(i, o, null, null);
    }, yw.prototype.unmount = fT.prototype.unmount = function() {
      typeof arguments[0] == "function" && c("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var i = this._internalRoot;
      if (i !== null) {
        this._internalRoot = null;
        var o = i.containerInfo;
        PM() && c("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), Eu(function() {
          Sy(null, i, null, null);
        }), gR(o);
      }
    };
    function h7(i, o) {
      if (!bw(i))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      vA(i);
      var d = !1, h = !1, b = "", C = mA;
      o != null && (o.hydrate ? s("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof o == "object" && o !== null && o.$$typeof === Sa && c(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), o.unstable_strictMode === !0 && (d = !0), o.identifierPrefix !== void 0 && (b = o.identifierPrefix), o.onRecoverableError !== void 0 && (C = o.onRecoverableError), o.transitionCallbacks !== void 0 && o.transitionCallbacks);
      var R = XM(i, pS, null, d, h, b, C);
      aS(R.current, i);
      var A = i.nodeType === ni ? i.parentNode : i;
      return Pv(A), new fT(R);
    }
    function yw(i) {
      this._internalRoot = i;
    }
    function g7(i) {
      i && O0(i);
    }
    yw.prototype.unstable_scheduleHydration = g7;
    function m7(i, o, d) {
      if (!bw(i))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      vA(i), o === void 0 && c("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var h = d ?? null, b = d != null && d.hydratedSources || null, C = !1, R = !1, A = "", B = mA;
      d != null && (d.unstable_strictMode === !0 && (C = !0), d.identifierPrefix !== void 0 && (A = d.identifierPrefix), d.onRecoverableError !== void 0 && (B = d.onRecoverableError));
      var V = qM(o, null, i, pS, h, C, R, A, B);
      if (aS(V.current, i), Pv(i), b)
        for (var G = 0; G < b.length; G++) {
          var ae = b[G];
          CB(V, ae);
        }
      return new yw(V);
    }
    function bw(i) {
      return !!(i && (i.nodeType === Io || i.nodeType === Ja || i.nodeType === Uc || !ce));
    }
    function wy(i) {
      return !!(i && (i.nodeType === Io || i.nodeType === Ja || i.nodeType === Uc || i.nodeType === ni && i.nodeValue === " react-mount-point-unstable "));
    }
    function vA(i) {
      i.nodeType === Io && i.tagName && i.tagName.toUpperCase() === "BODY" && c("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), zv(i) && (i._reactRootContainer ? c("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : c("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var v7 = n.ReactCurrentOwner, yA;
    yA = function(i) {
      if (i._reactRootContainer && i.nodeType !== ni) {
        var o = ZM(i._reactRootContainer.current);
        o && o.parentNode !== i && c("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var d = !!i._reactRootContainer, h = pT(i), b = !!(h && wd(h));
      b && !d && c("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), i.nodeType === Io && i.tagName && i.tagName.toUpperCase() === "BODY" && c("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function pT(i) {
      return i ? i.nodeType === Ja ? i.documentElement : i.firstChild : null;
    }
    function bA() {
    }
    function y7(i, o, d, h, b) {
      if (b) {
        if (typeof h == "function") {
          var C = h;
          h = function() {
            var ne = vw(R);
            C.call(ne);
          };
        }
        var R = qM(
          o,
          h,
          i,
          Ed,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          bA
        );
        i._reactRootContainer = R, aS(R.current, i);
        var A = i.nodeType === ni ? i.parentNode : i;
        return Pv(A), Eu(), R;
      } else {
        for (var B; B = i.lastChild; )
          i.removeChild(B);
        if (typeof h == "function") {
          var V = h;
          h = function() {
            var ne = vw(G);
            V.call(ne);
          };
        }
        var G = XM(
          i,
          Ed,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          bA
        );
        i._reactRootContainer = G, aS(G.current, i);
        var ae = i.nodeType === ni ? i.parentNode : i;
        return Pv(ae), Eu(function() {
          Sy(o, G, d, h);
        }), G;
      }
    }
    function b7(i, o) {
      i !== null && typeof i != "function" && c("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", o, i);
    }
    function Sw(i, o, d, h, b) {
      yA(d), b7(b === void 0 ? null : b, "render");
      var C = d._reactRootContainer, R;
      if (!C)
        R = y7(d, o, i, b, h);
      else {
        if (R = C, typeof b == "function") {
          var A = b;
          b = function() {
            var B = vw(R);
            A.call(B);
          };
        }
        Sy(o, R, i, b);
      }
      return vw(R);
    }
    function S7(i) {
      {
        var o = v7.current;
        if (o !== null && o.stateNode !== null) {
          var d = o.stateNode._warnedAboutRefsInRender;
          d || c("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", rn(o.type) || "A component"), o.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return i == null ? null : i.nodeType === Io ? i : i7(i, "findDOMNode");
    }
    function w7(i, o, d) {
      if (c("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !wy(o))
        throw new Error("Target container is not a DOM element.");
      {
        var h = zv(o) && o._reactRootContainer === void 0;
        h && c("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return Sw(null, i, o, !0, d);
    }
    function x7(i, o, d) {
      if (c("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !wy(o))
        throw new Error("Target container is not a DOM element.");
      {
        var h = zv(o) && o._reactRootContainer === void 0;
        h && c("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return Sw(null, i, o, !1, d);
    }
    function E7(i, o, d, h) {
      if (c("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !wy(d))
        throw new Error("Target container is not a DOM element.");
      if (i == null || !Tf(i))
        throw new Error("parentComponent must be a valid React Component");
      return Sw(i, o, d, !1, h);
    }
    function C7(i) {
      if (!wy(i))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var o = zv(i) && i._reactRootContainer === void 0;
        o && c("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (i._reactRootContainer) {
        {
          var d = pT(i), h = d && !wd(d);
          h && c("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return Eu(function() {
          Sw(null, null, i, !1, function() {
            i._reactRootContainer = null, gR(i);
          });
        }), !0;
      } else {
        {
          var b = pT(i), C = !!(b && wd(b)), R = i.nodeType === Io && wy(i.parentNode) && !!i.parentNode._reactRootContainer;
          C && c("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", R ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    ft(o7), P0(a7), Bf(s7), uv($a), R0(jf), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && c("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), l0(k6), Zp(V_, mF, Eu);
    function _7(i, o) {
      var d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!bw(o))
        throw new Error("Target container is not a DOM element.");
      return r7(i, o, null, d);
    }
    function T7(i, o, d, h) {
      return E7(i, o, d, h);
    }
    var hT = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [wd, eg, sS, Qp, Ef, V_]
    };
    function k7(i, o) {
      return hT.usingClientEntryPoint || c('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), h7(i, o);
    }
    function P7(i, o, d) {
      return hT.usingClientEntryPoint || c('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), m7(i, o, d);
    }
    function I7(i) {
      return PM() && c("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), Eu(i);
    }
    var R7 = p7({
      findFiberByHostInstance: Qf,
      bundleType: 1,
      version: sT,
      rendererPackageName: "react-dom"
    });
    if (!R7 && Nt && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var SA = window.location.protocol;
      /^(https?|file):$/.test(SA) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (SA === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    Fa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = hT, Fa.createPortal = _7, Fa.createRoot = k7, Fa.findDOMNode = S7, Fa.flushSync = I7, Fa.hydrate = w7, Fa.hydrateRoot = P7, Fa.render = x7, Fa.unmountComponentAtNode = C7, Fa.unstable_batchedUpdates = V_, Fa.unstable_renderSubtreeIntoContainer = T7, Fa.version = sT, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Fa;
}
function Bj() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if ({}.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Bj);
    } catch (t) {
      console.error(t);
    }
  }
}
({}).NODE_ENV === "production" ? (Bj(), hP.exports = yie()) : hP.exports = bie();
var dm = hP.exports;
const Sie = /* @__PURE__ */ Np(dm);
function _t(t, e, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(a) {
    if (t?.(a), n === !1 || !a.defaultPrevented)
      return e?.(a);
  };
}
function wie(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e);
}
function S1(...t) {
  return (e) => t.forEach(
    (n) => wie(n, e)
  );
}
function Rr(...t) {
  return k.useCallback(S1(...t), t);
}
function Oc(t, e = []) {
  let n = [];
  function r(s, c) {
    const f = /* @__PURE__ */ k.createContext(c), p = n.length;
    n = [
      ...n,
      c
    ];
    function g(v) {
      const { scope: S, children: x, ..._ } = v, T = S?.[t][p] || f, I = k.useMemo(
        () => _,
        Object.values(_)
      );
      return /* @__PURE__ */ k.createElement(T.Provider, {
        value: I
      }, x);
    }
    function y(v, S) {
      const x = S?.[t][p] || f, _ = k.useContext(x);
      if (_)
        return _;
      if (c !== void 0)
        return c;
      throw new Error(`\`${v}\` must be used within \`${s}\``);
    }
    return g.displayName = s + "Provider", [
      g,
      y
    ];
  }
  const a = () => {
    const s = n.map((c) => /* @__PURE__ */ k.createContext(c));
    return function(f) {
      const p = f?.[t] || s;
      return k.useMemo(
        () => ({
          [`__scope${t}`]: {
            ...f,
            [t]: p
          }
        }),
        [
          f,
          p
        ]
      );
    };
  };
  return a.scopeName = t, [
    r,
    xie(a, ...e)
  ];
}
function xie(...t) {
  const e = t[0];
  if (t.length === 1)
    return e;
  const n = () => {
    const r = t.map(
      (a) => ({
        useScope: a(),
        scopeName: a.scopeName
      })
    );
    return function(s) {
      const c = r.reduce((f, { useScope: p, scopeName: g }) => {
        const v = p(s)[`__scope${g}`];
        return {
          ...f,
          ...v
        };
      }, {});
      return k.useMemo(
        () => ({
          [`__scope${e.scopeName}`]: c
        }),
        [
          c
        ]
      );
    };
  };
  return n.scopeName = e.scopeName, n;
}
const Mp = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { children: n, ...r } = t, a = k.Children.toArray(n), s = a.find(Cie);
  if (s) {
    const c = s.props.children, f = a.map((p) => p === s ? k.Children.count(c) > 1 ? k.Children.only(null) : /* @__PURE__ */ k.isValidElement(c) ? c.props.children : null : p);
    return /* @__PURE__ */ k.createElement(gP, qe({}, r, {
      ref: e
    }), /* @__PURE__ */ k.isValidElement(c) ? /* @__PURE__ */ k.cloneElement(c, void 0, f) : null);
  }
  return /* @__PURE__ */ k.createElement(gP, qe({}, r, {
    ref: e
  }), n);
});
Mp.displayName = "Slot";
const gP = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { children: n, ...r } = t;
  return /* @__PURE__ */ k.isValidElement(n) ? /* @__PURE__ */ k.cloneElement(n, {
    ..._ie(r, n.props),
    ref: e ? S1(e, n.ref) : n.ref
  }) : k.Children.count(n) > 1 ? k.Children.only(null) : null;
});
gP.displayName = "SlotClone";
const Eie = ({ children: t }) => /* @__PURE__ */ k.createElement(k.Fragment, null, t);
function Cie(t) {
  return /* @__PURE__ */ k.isValidElement(t) && t.type === Eie;
}
function _ie(t, e) {
  const n = {
    ...e
  };
  for (const r in e) {
    const a = t[r], s = e[r];
    /^on[A-Z]/.test(r) ? a && s ? n[r] = (...f) => {
      s(...f), a(...f);
    } : a && (n[r] = a) : r === "style" ? n[r] = {
      ...a,
      ...s
    } : r === "className" && (n[r] = [
      a,
      s
    ].filter(Boolean).join(" "));
  }
  return {
    ...t,
    ...n
  };
}
function w1(t) {
  const e = t + "CollectionProvider", [n, r] = Oc(e), [a, s] = n(e, {
    collectionRef: {
      current: null
    },
    itemMap: /* @__PURE__ */ new Map()
  }), c = (x) => {
    const { scope: _, children: T } = x, I = It.useRef(null), D = It.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ It.createElement(a, {
      scope: _,
      itemMap: D,
      collectionRef: I
    }, T);
  }, f = t + "CollectionSlot", p = /* @__PURE__ */ It.forwardRef((x, _) => {
    const { scope: T, children: I } = x, D = s(f, T), N = Rr(_, D.collectionRef);
    return /* @__PURE__ */ It.createElement(Mp, {
      ref: N
    }, I);
  }), g = t + "CollectionItemSlot", y = "data-radix-collection-item", v = /* @__PURE__ */ It.forwardRef((x, _) => {
    const { scope: T, children: I, ...D } = x, N = It.useRef(null), j = Rr(_, N), L = s(g, T);
    return It.useEffect(() => (L.itemMap.set(N, {
      ref: N,
      ...D
    }), () => void L.itemMap.delete(N))), /* @__PURE__ */ It.createElement(Mp, {
      [y]: "",
      ref: j
    }, I);
  });
  function S(x) {
    const _ = s(t + "CollectionConsumer", x);
    return It.useCallback(() => {
      const I = _.collectionRef.current;
      if (!I)
        return [];
      const D = Array.from(I.querySelectorAll(`[${y}]`));
      return Array.from(_.itemMap.values()).sort(
        (L, z) => D.indexOf(L.ref.current) - D.indexOf(z.ref.current)
      );
    }, [
      _.collectionRef,
      _.itemMap
    ]);
  }
  return [
    {
      Provider: c,
      Slot: p,
      ItemSlot: v
    },
    S,
    r
  ];
}
const Tie = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], pr = Tie.reduce((t, e) => {
  const n = /* @__PURE__ */ k.forwardRef((r, a) => {
    const { asChild: s, ...c } = r, f = s ? Mp : e;
    return k.useEffect(() => {
      window[Symbol.for("radix-ui")] = !0;
    }, []), /* @__PURE__ */ k.createElement(f, qe({}, c, {
      ref: a
    }));
  });
  return n.displayName = `Primitive.${e}`, {
    ...t,
    [e]: n
  };
}, {});
function GI(t, e) {
  t && dm.flushSync(
    () => t.dispatchEvent(e)
  );
}
function Yo(t) {
  const e = k.useRef(t);
  return k.useEffect(() => {
    e.current = t;
  }), k.useMemo(
    () => (...n) => {
      var r;
      return (r = e.current) === null || r === void 0 ? void 0 : r.call(e, ...n);
    },
    []
  );
}
function kie(t, e = globalThis?.document) {
  const n = Yo(t);
  k.useEffect(() => {
    const r = (a) => {
      a.key === "Escape" && n(a);
    };
    return e.addEventListener("keydown", r), () => e.removeEventListener("keydown", r);
  }, [
    n,
    e
  ]);
}
const mP = "dismissableLayer.update", Pie = "dismissableLayer.pointerDownOutside", Iie = "dismissableLayer.focusOutside";
let QD;
const Fj = /* @__PURE__ */ k.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), x1 = /* @__PURE__ */ k.forwardRef((t, e) => {
  var n;
  const { disableOutsidePointerEvents: r = !1, onEscapeKeyDown: a, onPointerDownOutside: s, onFocusOutside: c, onInteractOutside: f, onDismiss: p, ...g } = t, y = k.useContext(Fj), [v, S] = k.useState(null), x = (n = v?.ownerDocument) !== null && n !== void 0 ? n : globalThis?.document, [, _] = k.useState({}), T = Rr(
    e,
    (X) => S(X)
  ), I = Array.from(y.layers), [D] = [
    ...y.layersWithOutsidePointerEventsDisabled
  ].slice(-1), N = I.indexOf(D), j = v ? I.indexOf(v) : -1, L = y.layersWithOutsidePointerEventsDisabled.size > 0, z = j >= N, F = $ie((X) => {
    const se = X.target, ue = [
      ...y.branches
    ].some(
      (pe) => pe.contains(se)
    );
    !z || ue || (s?.(X), f?.(X), X.defaultPrevented || p?.());
  }, x), K = Mie((X) => {
    const se = X.target;
    [
      ...y.branches
    ].some(
      (pe) => pe.contains(se)
    ) || (c?.(X), f?.(X), X.defaultPrevented || p?.());
  }, x);
  return kie((X) => {
    j === y.layers.size - 1 && (a?.(X), !X.defaultPrevented && p && (X.preventDefault(), p()));
  }, x), k.useEffect(() => {
    if (v)
      return r && (y.layersWithOutsidePointerEventsDisabled.size === 0 && (QD = x.body.style.pointerEvents, x.body.style.pointerEvents = "none"), y.layersWithOutsidePointerEventsDisabled.add(v)), y.layers.add(v), ZD(), () => {
        r && y.layersWithOutsidePointerEventsDisabled.size === 1 && (x.body.style.pointerEvents = QD);
      };
  }, [
    v,
    x,
    r,
    y
  ]), k.useEffect(() => () => {
    v && (y.layers.delete(v), y.layersWithOutsidePointerEventsDisabled.delete(v), ZD());
  }, [
    v,
    y
  ]), k.useEffect(() => {
    const X = () => _({});
    return document.addEventListener(mP, X), () => document.removeEventListener(mP, X);
  }, []), /* @__PURE__ */ k.createElement(pr.div, qe({}, g, {
    ref: T,
    style: {
      pointerEvents: L ? z ? "auto" : "none" : void 0,
      ...t.style
    },
    onFocusCapture: _t(t.onFocusCapture, K.onFocusCapture),
    onBlurCapture: _t(t.onBlurCapture, K.onBlurCapture),
    onPointerDownCapture: _t(t.onPointerDownCapture, F.onPointerDownCapture)
  }));
}), Rie = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = k.useContext(Fj), r = k.useRef(null), a = Rr(e, r);
  return k.useEffect(() => {
    const s = r.current;
    if (s)
      return n.branches.add(s), () => {
        n.branches.delete(s);
      };
  }, [
    n.branches
  ]), /* @__PURE__ */ k.createElement(pr.div, qe({}, t, {
    ref: a
  }));
});
function $ie(t, e = globalThis?.document) {
  const n = Yo(t), r = k.useRef(!1), a = k.useRef(() => {
  });
  return k.useEffect(() => {
    const s = (f) => {
      if (f.target && !r.current) {
        let y = function() {
          Hj(Pie, n, g, {
            discrete: !0
          });
        };
        var p = y;
        const g = {
          originalEvent: f
        };
        f.pointerType === "touch" ? (e.removeEventListener("click", a.current), a.current = y, e.addEventListener("click", a.current, {
          once: !0
        })) : y();
      }
      r.current = !1;
    }, c = window.setTimeout(() => {
      e.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(c), e.removeEventListener("pointerdown", s), e.removeEventListener("click", a.current);
    };
  }, [
    e,
    n
  ]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function Mie(t, e = globalThis?.document) {
  const n = Yo(t), r = k.useRef(!1);
  return k.useEffect(() => {
    const a = (s) => {
      s.target && !r.current && Hj(Iie, n, {
        originalEvent: s
      }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", a), () => e.removeEventListener("focusin", a);
  }, [
    e,
    n
  ]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function ZD() {
  const t = new CustomEvent(mP);
  document.dispatchEvent(t);
}
function Hj(t, e, n, { discrete: r }) {
  const a = n.originalEvent.target, s = new CustomEvent(t, {
    bubbles: !1,
    cancelable: !0,
    detail: n
  });
  e && a.addEventListener(t, e, {
    once: !0
  }), r ? GI(a, s) : a.dispatchEvent(s);
}
const Aie = x1, Oie = Rie, E1 = /* @__PURE__ */ k.forwardRef((t, e) => {
  var n;
  const { container: r = globalThis == null || (n = globalThis.document) === null || n === void 0 ? void 0 : n.body, ...a } = t;
  return r ? /* @__PURE__ */ Sie.createPortal(/* @__PURE__ */ k.createElement(pr.div, qe({}, a, {
    ref: e
  })), r) : null;
}), Ap = globalThis?.document ? k.useLayoutEffect : () => {
};
function Die(t, e) {
  return k.useReducer((n, r) => {
    const a = e[n][r];
    return a ?? n;
  }, t);
}
const Ol = (t) => {
  const { present: e, children: n } = t, r = Nie(e), a = typeof n == "function" ? n({
    present: r.isPresent
  }) : k.Children.only(n), s = Rr(r.ref, a.ref);
  return typeof n == "function" || r.isPresent ? /* @__PURE__ */ k.cloneElement(a, {
    ref: s
  }) : null;
};
Ol.displayName = "Presence";
function Nie(t) {
  const [e, n] = k.useState(), r = k.useRef({}), a = k.useRef(t), s = k.useRef("none"), c = t ? "mounted" : "unmounted", [f, p] = Die(c, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return k.useEffect(() => {
    const g = Vw(r.current);
    s.current = f === "mounted" ? g : "none";
  }, [
    f
  ]), Ap(() => {
    const g = r.current, y = a.current;
    if (y !== t) {
      const S = s.current, x = Vw(g);
      t ? p("MOUNT") : x === "none" || g?.display === "none" ? p("UNMOUNT") : p(y && S !== x ? "ANIMATION_OUT" : "UNMOUNT"), a.current = t;
    }
  }, [
    t,
    p
  ]), Ap(() => {
    if (e) {
      const g = (v) => {
        const x = Vw(r.current).includes(v.animationName);
        v.target === e && x && dm.flushSync(
          () => p("ANIMATION_END")
        );
      }, y = (v) => {
        v.target === e && (s.current = Vw(r.current));
      };
      return e.addEventListener("animationstart", y), e.addEventListener("animationcancel", g), e.addEventListener("animationend", g), () => {
        e.removeEventListener("animationstart", y), e.removeEventListener("animationcancel", g), e.removeEventListener("animationend", g);
      };
    } else
      p("ANIMATION_END");
  }, [
    e,
    p
  ]), {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(f),
    ref: k.useCallback((g) => {
      g && (r.current = getComputedStyle(g)), n(g);
    }, [])
  };
}
function Vw(t) {
  return t?.animationName || "none";
}
function cf({ prop: t, defaultProp: e, onChange: n = () => {
} }) {
  const [r, a] = Lie({
    defaultProp: e,
    onChange: n
  }), s = t !== void 0, c = s ? t : r, f = Yo(n), p = k.useCallback((g) => {
    if (s) {
      const v = typeof g == "function" ? g(t) : g;
      v !== t && f(v);
    } else
      a(g);
  }, [
    s,
    t,
    a,
    f
  ]);
  return [
    c,
    p
  ];
}
function Lie({ defaultProp: t, onChange: e }) {
  const n = k.useState(t), [r] = n, a = k.useRef(r), s = Yo(e);
  return k.useEffect(() => {
    a.current !== r && (s(r), a.current = r);
  }, [
    r,
    a,
    s
  ]), n;
}
const Vj = /* @__PURE__ */ k.forwardRef((t, e) => /* @__PURE__ */ k.createElement(pr.span, qe({}, t, {
  ref: e,
  style: {
    // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal",
    ...t.style
  }
}))), Yj = "ToastProvider", [XI, jie, zie] = w1("Toast"), [Kj, Ype] = Oc("Toast", [
  zie
]), [Uie, C1] = Kj(Yj), Wj = (t) => {
  const { __scopeToast: e, label: n = "Notification", duration: r = 5e3, swipeDirection: a = "right", swipeThreshold: s = 50, children: c } = t, [f, p] = k.useState(null), [g, y] = k.useState(0), v = k.useRef(!1), S = k.useRef(!1);
  return /* @__PURE__ */ k.createElement(XI.Provider, {
    scope: e
  }, /* @__PURE__ */ k.createElement(Uie, {
    scope: e,
    label: n,
    duration: r,
    swipeDirection: a,
    swipeThreshold: s,
    toastCount: g,
    viewport: f,
    onViewportChange: p,
    onToastAdd: k.useCallback(
      () => y(
        (x) => x + 1
      ),
      []
    ),
    onToastRemove: k.useCallback(
      () => y(
        (x) => x - 1
      ),
      []
    ),
    isFocusedToastEscapeKeyDownRef: v,
    isClosePausedRef: S
  }, c));
};
Wj.propTypes = {
  label(t) {
    if (t.label && typeof t.label == "string" && !t.label.trim()) {
      const e = `Invalid prop \`label\` supplied to \`${Yj}\`. Expected non-empty \`string\`.`;
      return new Error(e);
    }
    return null;
  }
};
const Bie = "ToastViewport", Fie = [
  "F8"
], vP = "toast.viewportPause", yP = "toast.viewportResume", Hie = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeToast: n, hotkey: r = Fie, label: a = "Notifications ({hotkey})", ...s } = t, c = C1(Bie, n), f = jie(n), p = k.useRef(null), g = k.useRef(null), y = k.useRef(null), v = k.useRef(null), S = Rr(e, v, c.onViewportChange), x = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), _ = c.toastCount > 0;
  k.useEffect(() => {
    const I = (D) => {
      var N;
      r.every(
        (L) => D[L] || D.code === L
      ) && ((N = v.current) === null || N === void 0 || N.focus());
    };
    return document.addEventListener("keydown", I), () => document.removeEventListener("keydown", I);
  }, [
    r
  ]), k.useEffect(() => {
    const I = p.current, D = v.current;
    if (_ && I && D) {
      const N = () => {
        if (!c.isClosePausedRef.current) {
          const F = new CustomEvent(vP);
          D.dispatchEvent(F), c.isClosePausedRef.current = !0;
        }
      }, j = () => {
        if (c.isClosePausedRef.current) {
          const F = new CustomEvent(yP);
          D.dispatchEvent(F), c.isClosePausedRef.current = !1;
        }
      }, L = (F) => {
        !I.contains(F.relatedTarget) && j();
      }, z = () => {
        I.contains(document.activeElement) || j();
      };
      return I.addEventListener("focusin", N), I.addEventListener("focusout", L), I.addEventListener("pointermove", N), I.addEventListener("pointerleave", z), window.addEventListener("blur", N), window.addEventListener("focus", j), () => {
        I.removeEventListener("focusin", N), I.removeEventListener("focusout", L), I.removeEventListener("pointermove", N), I.removeEventListener("pointerleave", z), window.removeEventListener("blur", N), window.removeEventListener("focus", j);
      };
    }
  }, [
    _,
    c.isClosePausedRef
  ]);
  const T = k.useCallback(({ tabbingDirection: I }) => {
    const N = f().map((j) => {
      const L = j.ref.current, z = [
        L,
        ...ooe(L)
      ];
      return I === "forwards" ? z : z.reverse();
    });
    return (I === "forwards" ? N.reverse() : N).flat();
  }, [
    f
  ]);
  return k.useEffect(() => {
    const I = v.current;
    if (I) {
      const D = (N) => {
        const j = N.altKey || N.ctrlKey || N.metaKey;
        if (N.key === "Tab" && !j) {
          const X = document.activeElement, se = N.shiftKey;
          if (N.target === I && se) {
            var z;
            (z = g.current) === null || z === void 0 || z.focus();
            return;
          }
          const Pe = T({
            tabbingDirection: se ? "backwards" : "forwards"
          }), ve = Pe.findIndex(
            (Y) => Y === X
          );
          if (gk(Pe.slice(ve + 1)))
            N.preventDefault();
          else {
            var F, K;
            se ? (F = g.current) === null || F === void 0 || F.focus() : (K = y.current) === null || K === void 0 || K.focus();
          }
        }
      };
      return I.addEventListener("keydown", D), () => I.removeEventListener("keydown", D);
    }
  }, [
    f,
    T
  ]), /* @__PURE__ */ k.createElement(Oie, {
    ref: p,
    role: "region",
    "aria-label": a.replace("{hotkey}", x),
    tabIndex: -1,
    style: {
      pointerEvents: _ ? void 0 : "none"
    }
  }, _ && /* @__PURE__ */ k.createElement(JD, {
    ref: g,
    onFocusFromOutsideViewport: () => {
      const I = T({
        tabbingDirection: "forwards"
      });
      gk(I);
    }
  }), /* @__PURE__ */ k.createElement(XI.Slot, {
    scope: n
  }, /* @__PURE__ */ k.createElement(pr.ol, qe({
    tabIndex: -1
  }, s, {
    ref: S
  }))), _ && /* @__PURE__ */ k.createElement(JD, {
    ref: y,
    onFocusFromOutsideViewport: () => {
      const I = T({
        tabbingDirection: "backwards"
      });
      gk(I);
    }
  }));
}), Vie = "ToastFocusProxy", JD = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeToast: n, onFocusFromOutsideViewport: r, ...a } = t, s = C1(Vie, n);
  return /* @__PURE__ */ k.createElement(Vj, qe({
    "aria-hidden": !0,
    tabIndex: 0
  }, a, {
    ref: e,
    style: {
      position: "fixed"
    },
    onFocus: (c) => {
      var f;
      const p = c.relatedTarget;
      !((f = s.viewport) !== null && f !== void 0 && f.contains(p)) && r();
    }
  }));
}), _1 = "Toast", Yie = "toast.swipeStart", Kie = "toast.swipeMove", Wie = "toast.swipeCancel", Gie = "toast.swipeEnd", Xie = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { forceMount: n, open: r, defaultOpen: a, onOpenChange: s, ...c } = t, [f = !0, p] = cf({
    prop: r,
    defaultProp: a,
    onChange: s
  });
  return /* @__PURE__ */ k.createElement(Ol, {
    present: n || f
  }, /* @__PURE__ */ k.createElement(Gj, qe({
    open: f
  }, c, {
    ref: e,
    onClose: () => p(!1),
    onPause: Yo(t.onPause),
    onResume: Yo(t.onResume),
    onSwipeStart: _t(t.onSwipeStart, (g) => {
      g.currentTarget.setAttribute("data-swipe", "start");
    }),
    onSwipeMove: _t(t.onSwipeMove, (g) => {
      const { x: y, y: v } = g.detail.delta;
      g.currentTarget.setAttribute("data-swipe", "move"), g.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${y}px`), g.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${v}px`);
    }),
    onSwipeCancel: _t(t.onSwipeCancel, (g) => {
      g.currentTarget.setAttribute("data-swipe", "cancel"), g.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), g.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), g.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), g.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
    }),
    onSwipeEnd: _t(t.onSwipeEnd, (g) => {
      const { x: y, y: v } = g.detail.delta;
      g.currentTarget.setAttribute("data-swipe", "end"), g.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), g.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), g.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${y}px`), g.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${v}px`), p(!1);
    })
  })));
}), [qie, Qie] = Kj(_1, {
  onClose() {
  }
}), Gj = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeToast: n, type: r = "foreground", duration: a, open: s, onClose: c, onEscapeKeyDown: f, onPause: p, onResume: g, onSwipeStart: y, onSwipeMove: v, onSwipeCancel: S, onSwipeEnd: x, ..._ } = t, T = C1(_1, n), [I, D] = k.useState(null), N = Rr(
    e,
    (Y) => D(Y)
  ), j = k.useRef(null), L = k.useRef(null), z = a || T.duration, F = k.useRef(0), K = k.useRef(z), X = k.useRef(0), { onToastAdd: se, onToastRemove: ue } = T, pe = Yo(() => {
    var Y;
    I?.contains(document.activeElement) && ((Y = T.viewport) === null || Y === void 0 || Y.focus()), c();
  }), Pe = k.useCallback((Y) => {
    !Y || Y === 1 / 0 || (window.clearTimeout(X.current), F.current = (/* @__PURE__ */ new Date()).getTime(), X.current = window.setTimeout(pe, Y));
  }, [
    pe
  ]);
  k.useEffect(() => {
    const Y = T.viewport;
    if (Y) {
      const le = () => {
        Pe(K.current), g?.();
      }, Re = () => {
        const he = (/* @__PURE__ */ new Date()).getTime() - F.current;
        K.current = K.current - he, window.clearTimeout(X.current), p?.();
      };
      return Y.addEventListener(vP, Re), Y.addEventListener(yP, le), () => {
        Y.removeEventListener(vP, Re), Y.removeEventListener(yP, le);
      };
    }
  }, [
    T.viewport,
    z,
    p,
    g,
    Pe
  ]), k.useEffect(() => {
    s && !T.isClosePausedRef.current && Pe(z);
  }, [
    s,
    z,
    T.isClosePausedRef,
    Pe
  ]), k.useEffect(() => (se(), () => ue()), [
    se,
    ue
  ]);
  const ve = k.useMemo(() => I ? Zj(I) : null, [
    I
  ]);
  return T.viewport ? /* @__PURE__ */ k.createElement(k.Fragment, null, ve && /* @__PURE__ */ k.createElement(Zie, {
    __scopeToast: n,
    role: "status",
    "aria-live": r === "foreground" ? "assertive" : "polite",
    "aria-atomic": !0
  }, ve), /* @__PURE__ */ k.createElement(qie, {
    scope: n,
    onClose: pe
  }, /* @__PURE__ */ dm.createPortal(/* @__PURE__ */ k.createElement(XI.ItemSlot, {
    scope: n
  }, /* @__PURE__ */ k.createElement(Aie, {
    asChild: !0,
    onEscapeKeyDown: _t(f, () => {
      T.isFocusedToastEscapeKeyDownRef.current || pe(), T.isFocusedToastEscapeKeyDownRef.current = !1;
    })
  }, /* @__PURE__ */ k.createElement(pr.li, qe({
    // Ensure toasts are announced as status list or status when focused
    role: "status",
    "aria-live": "off",
    "aria-atomic": !0,
    tabIndex: 0,
    "data-state": s ? "open" : "closed",
    "data-swipe-direction": T.swipeDirection
  }, _, {
    ref: N,
    style: {
      userSelect: "none",
      touchAction: "none",
      ...t.style
    },
    onKeyDown: _t(t.onKeyDown, (Y) => {
      Y.key === "Escape" && (f?.(Y.nativeEvent), Y.nativeEvent.defaultPrevented || (T.isFocusedToastEscapeKeyDownRef.current = !0, pe()));
    }),
    onPointerDown: _t(t.onPointerDown, (Y) => {
      Y.button === 0 && (j.current = {
        x: Y.clientX,
        y: Y.clientY
      });
    }),
    onPointerMove: _t(t.onPointerMove, (Y) => {
      if (!j.current)
        return;
      const le = Y.clientX - j.current.x, Re = Y.clientY - j.current.y, he = !!L.current, te = [
        "left",
        "right"
      ].includes(T.swipeDirection), de = [
        "left",
        "up"
      ].includes(T.swipeDirection) ? Math.min : Math.max, W = te ? de(0, le) : 0, fe = te ? 0 : de(0, Re), ce = Y.pointerType === "touch" ? 10 : 2, xe = {
        x: W,
        y: fe
      }, $e = {
        originalEvent: Y,
        delta: xe
      };
      he ? (L.current = xe, Yw(Kie, v, $e, {
        discrete: !1
      })) : eN(xe, T.swipeDirection, ce) ? (L.current = xe, Yw(Yie, y, $e, {
        discrete: !1
      }), Y.target.setPointerCapture(Y.pointerId)) : (Math.abs(le) > ce || Math.abs(Re) > ce) && (j.current = null);
    }),
    onPointerUp: _t(t.onPointerUp, (Y) => {
      const le = L.current, Re = Y.target;
      if (Re.hasPointerCapture(Y.pointerId) && Re.releasePointerCapture(Y.pointerId), L.current = null, j.current = null, le) {
        const he = Y.currentTarget, te = {
          originalEvent: Y,
          delta: le
        };
        eN(le, T.swipeDirection, T.swipeThreshold) ? Yw(Gie, x, te, {
          discrete: !0
        }) : Yw(Wie, S, te, {
          discrete: !0
        }), he.addEventListener(
          "click",
          (de) => de.preventDefault(),
          {
            once: !0
          }
        );
      }
    })
  })))), T.viewport))) : null;
});
Gj.propTypes = {
  type(t) {
    if (t.type && ![
      "foreground",
      "background"
    ].includes(t.type)) {
      const e = `Invalid prop \`type\` supplied to \`${_1}\`. Expected \`foreground | background\`.`;
      return new Error(e);
    }
    return null;
  }
};
const Zie = (t) => {
  const { __scopeToast: e, children: n, ...r } = t, a = C1(_1, e), [s, c] = k.useState(!1), [f, p] = k.useState(!1);
  return roe(
    () => c(!0)
  ), k.useEffect(() => {
    const g = window.setTimeout(
      () => p(!0),
      1e3
    );
    return () => window.clearTimeout(g);
  }, []), f ? null : /* @__PURE__ */ k.createElement(E1, {
    asChild: !0
  }, /* @__PURE__ */ k.createElement(Vj, r, s && /* @__PURE__ */ k.createElement(k.Fragment, null, a.label, " ", n)));
}, Jie = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeToast: n, ...r } = t;
  return /* @__PURE__ */ k.createElement(pr.div, qe({}, r, {
    ref: e
  }));
}), eoe = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeToast: n, ...r } = t;
  return /* @__PURE__ */ k.createElement(pr.div, qe({}, r, {
    ref: e
  }));
}), toe = "ToastAction", Xj = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { altText: n, ...r } = t;
  return n ? /* @__PURE__ */ k.createElement(Qj, {
    altText: n,
    asChild: !0
  }, /* @__PURE__ */ k.createElement(qj, qe({}, r, {
    ref: e
  }))) : null;
});
Xj.propTypes = {
  altText(t) {
    return t.altText ? null : new Error(`Missing prop \`altText\` expected on \`${toe}\``);
  }
};
const noe = "ToastClose", qj = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeToast: n, ...r } = t, a = Qie(noe, n);
  return /* @__PURE__ */ k.createElement(Qj, {
    asChild: !0
  }, /* @__PURE__ */ k.createElement(pr.button, qe({
    type: "button"
  }, r, {
    ref: e,
    onClick: _t(t.onClick, a.onClose)
  })));
}), Qj = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeToast: n, altText: r, ...a } = t;
  return /* @__PURE__ */ k.createElement(pr.div, qe({
    "data-radix-toast-announce-exclude": "",
    "data-radix-toast-announce-alt": r || void 0
  }, a, {
    ref: e
  }));
});
function Zj(t) {
  const e = [];
  return Array.from(t.childNodes).forEach((r) => {
    if (r.nodeType === r.TEXT_NODE && r.textContent && e.push(r.textContent), ioe(r)) {
      const a = r.ariaHidden || r.hidden || r.style.display === "none", s = r.dataset.radixToastAnnounceExclude === "";
      if (!a)
        if (s) {
          const c = r.dataset.radixToastAnnounceAlt;
          c && e.push(c);
        } else
          e.push(...Zj(r));
    }
  }), e;
}
function Yw(t, e, n, { discrete: r }) {
  const a = n.originalEvent.currentTarget, s = new CustomEvent(t, {
    bubbles: !0,
    cancelable: !0,
    detail: n
  });
  e && a.addEventListener(t, e, {
    once: !0
  }), r ? GI(a, s) : a.dispatchEvent(s);
}
const eN = (t, e, n = 0) => {
  const r = Math.abs(t.x), a = Math.abs(t.y), s = r > a;
  return e === "left" || e === "right" ? s && r > n : !s && a > n;
};
function roe(t = () => {
}) {
  const e = Yo(t);
  Ap(() => {
    let n = 0, r = 0;
    return n = window.requestAnimationFrame(
      () => r = window.requestAnimationFrame(e)
    ), () => {
      window.cancelAnimationFrame(n), window.cancelAnimationFrame(r);
    };
  }, [
    e
  ]);
}
function ioe(t) {
  return t.nodeType === t.ELEMENT_NODE;
}
function ooe(t) {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const a = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || a ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); )
    e.push(n.currentNode);
  return e;
}
function gk(t) {
  const e = document.activeElement;
  return t.some((n) => n === e ? !0 : (n.focus(), document.activeElement !== e));
}
const aoe = Xie, soe = Jie, loe = eoe, coe = Xj, tN = qj, uoe = /* @__PURE__ */ k.createContext(void 0);
function qI(t) {
  const e = k.useContext(uoe);
  return t || e || "ltr";
}
let mk = 0;
function QI() {
  k.useEffect(() => {
    var t, e;
    const n = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", (t = n[0]) !== null && t !== void 0 ? t : nN()), document.body.insertAdjacentElement("beforeend", (e = n[1]) !== null && e !== void 0 ? e : nN()), mk++, () => {
      mk === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(
        (r) => r.remove()
      ), mk--;
    };
  }, []);
}
function nN() {
  const t = document.createElement("span");
  return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", t;
}
const vk = "focusScope.autoFocusOnMount", yk = "focusScope.autoFocusOnUnmount", rN = {
  bubbles: !1,
  cancelable: !0
}, ZI = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { loop: n = !1, trapped: r = !1, onMountAutoFocus: a, onUnmountAutoFocus: s, ...c } = t, [f, p] = k.useState(null), g = Yo(a), y = Yo(s), v = k.useRef(null), S = Rr(
    e,
    (T) => p(T)
  ), x = k.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  k.useEffect(() => {
    if (r) {
      let N = function(F) {
        if (x.paused || !f)
          return;
        const K = F.target;
        f.contains(K) ? v.current = K : zd(v.current, {
          select: !0
        });
      }, j = function(F) {
        if (x.paused || !f)
          return;
        const K = F.relatedTarget;
        K !== null && (f.contains(K) || zd(v.current, {
          select: !0
        }));
      }, L = function(F) {
        const K = document.activeElement;
        for (const X of F)
          X.removedNodes.length > 0 && (f != null && f.contains(K) || zd(f));
      };
      var T = N, I = j, D = L;
      document.addEventListener("focusin", N), document.addEventListener("focusout", j);
      const z = new MutationObserver(L);
      return f && z.observe(f, {
        childList: !0,
        subtree: !0
      }), () => {
        document.removeEventListener("focusin", N), document.removeEventListener("focusout", j), z.disconnect();
      };
    }
  }, [
    r,
    f,
    x.paused
  ]), k.useEffect(() => {
    if (f) {
      oN.add(x);
      const T = document.activeElement;
      if (!f.contains(T)) {
        const D = new CustomEvent(vk, rN);
        f.addEventListener(vk, g), f.dispatchEvent(D), D.defaultPrevented || (doe(moe(Jj(f)), {
          select: !0
        }), document.activeElement === T && zd(f));
      }
      return () => {
        f.removeEventListener(vk, g), setTimeout(() => {
          const D = new CustomEvent(yk, rN);
          f.addEventListener(yk, y), f.dispatchEvent(D), D.defaultPrevented || zd(T ?? document.body, {
            select: !0
          }), f.removeEventListener(yk, y), oN.remove(x);
        }, 0);
      };
    }
  }, [
    f,
    g,
    y,
    x
  ]);
  const _ = k.useCallback((T) => {
    if (!n && !r || x.paused)
      return;
    const I = T.key === "Tab" && !T.altKey && !T.ctrlKey && !T.metaKey, D = document.activeElement;
    if (I && D) {
      const N = T.currentTarget, [j, L] = foe(N);
      j && L ? !T.shiftKey && D === L ? (T.preventDefault(), n && zd(j, {
        select: !0
      })) : T.shiftKey && D === j && (T.preventDefault(), n && zd(L, {
        select: !0
      })) : D === N && T.preventDefault();
    }
  }, [
    n,
    r,
    x.paused
  ]);
  return /* @__PURE__ */ k.createElement(pr.div, qe({
    tabIndex: -1
  }, c, {
    ref: S,
    onKeyDown: _
  }));
});
function doe(t, { select: e = !1 } = {}) {
  const n = document.activeElement;
  for (const r of t)
    if (zd(r, {
      select: e
    }), document.activeElement !== n)
      return;
}
function foe(t) {
  const e = Jj(t), n = iN(e, t), r = iN(e.reverse(), t);
  return [
    n,
    r
  ];
}
function Jj(t) {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const a = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || a ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); )
    e.push(n.currentNode);
  return e;
}
function iN(t, e) {
  for (const n of t)
    if (!poe(n, {
      upTo: e
    }))
      return n;
}
function poe(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  for (; t; ) {
    if (e !== void 0 && t === e)
      return !1;
    if (getComputedStyle(t).display === "none")
      return !0;
    t = t.parentElement;
  }
  return !1;
}
function hoe(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function zd(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({
      preventScroll: !0
    }), t !== n && hoe(t) && e && t.select();
  }
}
const oN = goe();
function goe() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && n?.pause(), t = aN(t, e), t.unshift(e);
    },
    remove(e) {
      var n;
      t = aN(t, e), (n = t[0]) === null || n === void 0 || n.resume();
    }
  };
}
function aN(t, e) {
  const n = [
    ...t
  ], r = n.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
function moe(t) {
  return t.filter(
    (e) => e.tagName !== "A"
  );
}
const voe = B7["useId".toString()] || (() => {
});
let yoe = 0;
function Du(t) {
  const [e, n] = k.useState(voe());
  return Ap(() => {
    t || n(
      (r) => r ?? String(yoe++)
    );
  }, [
    t
  ]), t || (e ? `radix-${e}` : "");
}
function fm(t) {
  return t.split("-")[1];
}
function JI(t) {
  return t === "y" ? "height" : "width";
}
function Nu(t) {
  return t.split("-")[0];
}
function Up(t) {
  return ["top", "bottom"].includes(Nu(t)) ? "x" : "y";
}
function sN(t, e, n) {
  let { reference: r, floating: a } = t;
  const s = r.x + r.width / 2 - a.width / 2, c = r.y + r.height / 2 - a.height / 2, f = Up(e), p = JI(f), g = r[p] / 2 - a[p] / 2, y = f === "x";
  let v;
  switch (Nu(e)) {
    case "top":
      v = { x: s, y: r.y - a.height };
      break;
    case "bottom":
      v = { x: s, y: r.y + r.height };
      break;
    case "right":
      v = { x: r.x + r.width, y: c };
      break;
    case "left":
      v = { x: r.x - a.width, y: c };
      break;
    default:
      v = { x: r.x, y: r.y };
  }
  switch (fm(e)) {
    case "start":
      v[f] -= g * (n && y ? -1 : 1);
      break;
    case "end":
      v[f] += g * (n && y ? -1 : 1);
  }
  return v;
}
const boe = async (t, e, n) => {
  const { placement: r = "bottom", strategy: a = "absolute", middleware: s = [], platform: c } = n, f = s.filter(Boolean), p = await (c.isRTL == null ? void 0 : c.isRTL(e));
  let g = await c.getElementRects({ reference: t, floating: e, strategy: a }), { x: y, y: v } = sN(g, r, p), S = r, x = {}, _ = 0;
  for (let T = 0; T < f.length; T++) {
    const { name: I, fn: D } = f[T], { x: N, y: j, data: L, reset: z } = await D({ x: y, y: v, initialPlacement: r, placement: S, strategy: a, middlewareData: x, rects: g, platform: c, elements: { reference: t, floating: e } });
    y = N ?? y, v = j ?? v, x = { ...x, [I]: { ...x[I], ...L } }, z && _ <= 50 && (_++, typeof z == "object" && (z.placement && (S = z.placement), z.rects && (g = z.rects === !0 ? await c.getElementRects({ reference: t, floating: e, strategy: a }) : z.rects), { x: y, y: v } = sN(g, S, p)), T = -1);
  }
  return { x: y, y: v, placement: S, strategy: a, middlewareData: x };
};
function ez(t) {
  return typeof t != "number" ? function(e) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...e };
  }(t) : { top: t, right: t, bottom: t, left: t };
}
function jx(t) {
  return { ...t, top: t.y, left: t.x, right: t.x + t.width, bottom: t.y + t.height };
}
async function rb(t, e) {
  var n;
  e === void 0 && (e = {});
  const { x: r, y: a, platform: s, rects: c, elements: f, strategy: p } = t, { boundary: g = "clippingAncestors", rootBoundary: y = "viewport", elementContext: v = "floating", altBoundary: S = !1, padding: x = 0 } = e, _ = ez(x), T = f[S ? v === "floating" ? "reference" : "floating" : v], I = jx(await s.getClippingRect({ element: (n = await (s.isElement == null ? void 0 : s.isElement(T))) == null || n ? T : T.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(f.floating)), boundary: g, rootBoundary: y, strategy: p })), D = v === "floating" ? { ...c.floating, x: r, y: a } : c.reference, N = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(f.floating)), j = await (s.isElement == null ? void 0 : s.isElement(N)) && await (s.getScale == null ? void 0 : s.getScale(N)) || { x: 1, y: 1 }, L = jx(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: D, offsetParent: N, strategy: p }) : D);
  return { top: (I.top - L.top + _.top) / j.y, bottom: (L.bottom - I.bottom + _.bottom) / j.y, left: (I.left - L.left + _.left) / j.x, right: (L.right - I.right + _.right) / j.x };
}
const bP = Math.min, Sp = Math.max;
function SP(t, e, n) {
  return Sp(t, bP(e, n));
}
const lN = (t) => ({ name: "arrow", options: t, async fn(e) {
  const { element: n, padding: r = 0 } = t || {}, { x: a, y: s, placement: c, rects: f, platform: p, elements: g } = e;
  if (n == null)
    return {};
  const y = ez(r), v = { x: a, y: s }, S = Up(c), x = JI(S), _ = await p.getDimensions(n), T = S === "y", I = T ? "top" : "left", D = T ? "bottom" : "right", N = T ? "clientHeight" : "clientWidth", j = f.reference[x] + f.reference[S] - v[S] - f.floating[x], L = v[S] - f.reference[S], z = await (p.getOffsetParent == null ? void 0 : p.getOffsetParent(n));
  let F = z ? z[N] : 0;
  F && await (p.isElement == null ? void 0 : p.isElement(z)) || (F = g.floating[N] || f.floating[x]);
  const K = j / 2 - L / 2, X = y[I], se = F - _[x] - y[D], ue = F / 2 - _[x] / 2 + K, pe = SP(X, ue, se), Pe = fm(c) != null && ue != pe && f.reference[x] / 2 - (ue < X ? y[I] : y[D]) - _[x] / 2 < 0;
  return { [S]: v[S] - (Pe ? ue < X ? X - ue : se - ue : 0), data: { [S]: pe, centerOffset: ue - pe } };
} }), tz = ["top", "right", "bottom", "left"];
tz.reduce((t, e) => t.concat(e, e + "-start", e + "-end"), []);
const Soe = { left: "right", right: "left", bottom: "top", top: "bottom" };
function zx(t) {
  return t.replace(/left|right|bottom|top/g, (e) => Soe[e]);
}
function woe(t, e, n) {
  n === void 0 && (n = !1);
  const r = fm(t), a = Up(t), s = JI(a);
  let c = a === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[s] > e.floating[s] && (c = zx(c)), { main: c, cross: zx(c) };
}
const xoe = { start: "end", end: "start" };
function bk(t) {
  return t.replace(/start|end/g, (e) => xoe[e]);
}
const Eoe = function(t) {
  return t === void 0 && (t = {}), { name: "flip", options: t, async fn(e) {
    var n;
    const { placement: r, middlewareData: a, rects: s, initialPlacement: c, platform: f, elements: p } = e, { mainAxis: g = !0, crossAxis: y = !0, fallbackPlacements: v, fallbackStrategy: S = "bestFit", fallbackAxisSideDirection: x = "none", flipAlignment: _ = !0, ...T } = t, I = Nu(r), D = Nu(c) === c, N = await (f.isRTL == null ? void 0 : f.isRTL(p.floating)), j = v || (D || !_ ? [zx(c)] : function(pe) {
      const Pe = zx(pe);
      return [bk(pe), Pe, bk(Pe)];
    }(c));
    v || x === "none" || j.push(...function(pe, Pe, ve, Y) {
      const le = fm(pe);
      let Re = function(he, te, de) {
        const W = ["left", "right"], fe = ["right", "left"], ce = ["top", "bottom"], xe = ["bottom", "top"];
        switch (he) {
          case "top":
          case "bottom":
            return de ? te ? fe : W : te ? W : fe;
          case "left":
          case "right":
            return te ? ce : xe;
          default:
            return [];
        }
      }(Nu(pe), ve === "start", Y);
      return le && (Re = Re.map((he) => he + "-" + le), Pe && (Re = Re.concat(Re.map(bk)))), Re;
    }(c, _, x, N));
    const L = [c, ...j], z = await rb(e, T), F = [];
    let K = ((n = a.flip) == null ? void 0 : n.overflows) || [];
    if (g && F.push(z[I]), y) {
      const { main: pe, cross: Pe } = woe(r, s, N);
      F.push(z[pe], z[Pe]);
    }
    if (K = [...K, { placement: r, overflows: F }], !F.every((pe) => pe <= 0)) {
      var X, se;
      const pe = (((X = a.flip) == null ? void 0 : X.index) || 0) + 1, Pe = L[pe];
      if (Pe)
        return { data: { index: pe, overflows: K }, reset: { placement: Pe } };
      let ve = (se = K.filter((Y) => Y.overflows[0] <= 0).sort((Y, le) => Y.overflows[1] - le.overflows[1])[0]) == null ? void 0 : se.placement;
      if (!ve)
        switch (S) {
          case "bestFit": {
            var ue;
            const Y = (ue = K.map((le) => [le.placement, le.overflows.filter((Re) => Re > 0).reduce((Re, he) => Re + he, 0)]).sort((le, Re) => le[1] - Re[1])[0]) == null ? void 0 : ue[0];
            Y && (ve = Y);
            break;
          }
          case "initialPlacement":
            ve = c;
        }
      if (r !== ve)
        return { reset: { placement: ve } };
    }
    return {};
  } };
};
function cN(t, e) {
  return { top: t.top - e.height, right: t.right - e.width, bottom: t.bottom - e.height, left: t.left - e.width };
}
function uN(t) {
  return tz.some((e) => t[e] >= 0);
}
const Coe = function(t) {
  return t === void 0 && (t = {}), { name: "hide", options: t, async fn(e) {
    const { strategy: n = "referenceHidden", ...r } = t, { rects: a } = e;
    switch (n) {
      case "referenceHidden": {
        const s = cN(await rb(e, { ...r, elementContext: "reference" }), a.reference);
        return { data: { referenceHiddenOffsets: s, referenceHidden: uN(s) } };
      }
      case "escaped": {
        const s = cN(await rb(e, { ...r, altBoundary: !0 }), a.floating);
        return { data: { escapedOffsets: s, escaped: uN(s) } };
      }
      default:
        return {};
    }
  } };
}, _oe = function(t) {
  return t === void 0 && (t = 0), { name: "offset", options: t, async fn(e) {
    const { x: n, y: r } = e, a = await async function(s, c) {
      const { placement: f, platform: p, elements: g } = s, y = await (p.isRTL == null ? void 0 : p.isRTL(g.floating)), v = Nu(f), S = fm(f), x = Up(f) === "x", _ = ["left", "top"].includes(v) ? -1 : 1, T = y && x ? -1 : 1, I = typeof c == "function" ? c(s) : c;
      let { mainAxis: D, crossAxis: N, alignmentAxis: j } = typeof I == "number" ? { mainAxis: I, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...I };
      return S && typeof j == "number" && (N = S === "end" ? -1 * j : j), x ? { x: N * T, y: D * _ } : { x: D * _, y: N * T };
    }(e, t);
    return { x: n + a.x, y: r + a.y, data: a };
  } };
};
function nz(t) {
  return t === "x" ? "y" : "x";
}
const Toe = function(t) {
  return t === void 0 && (t = {}), { name: "shift", options: t, async fn(e) {
    const { x: n, y: r, placement: a } = e, { mainAxis: s = !0, crossAxis: c = !1, limiter: f = { fn: (I) => {
      let { x: D, y: N } = I;
      return { x: D, y: N };
    } }, ...p } = t, g = { x: n, y: r }, y = await rb(e, p), v = Up(Nu(a)), S = nz(v);
    let x = g[v], _ = g[S];
    if (s) {
      const I = v === "y" ? "bottom" : "right";
      x = SP(x + y[v === "y" ? "top" : "left"], x, x - y[I]);
    }
    if (c) {
      const I = S === "y" ? "bottom" : "right";
      _ = SP(_ + y[S === "y" ? "top" : "left"], _, _ - y[I]);
    }
    const T = f.fn({ ...e, [v]: x, [S]: _ });
    return { ...T, data: { x: T.x - n, y: T.y - r } };
  } };
}, koe = function(t) {
  return t === void 0 && (t = {}), { options: t, fn(e) {
    const { x: n, y: r, placement: a, rects: s, middlewareData: c } = e, { offset: f = 0, mainAxis: p = !0, crossAxis: g = !0 } = t, y = { x: n, y: r }, v = Up(a), S = nz(v);
    let x = y[v], _ = y[S];
    const T = typeof f == "function" ? f(e) : f, I = typeof T == "number" ? { mainAxis: T, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...T };
    if (p) {
      const j = v === "y" ? "height" : "width", L = s.reference[v] - s.floating[j] + I.mainAxis, z = s.reference[v] + s.reference[j] - I.mainAxis;
      x < L ? x = L : x > z && (x = z);
    }
    if (g) {
      var D, N;
      const j = v === "y" ? "width" : "height", L = ["top", "left"].includes(Nu(a)), z = s.reference[S] - s.floating[j] + (L && ((D = c.offset) == null ? void 0 : D[S]) || 0) + (L ? 0 : I.crossAxis), F = s.reference[S] + s.reference[j] + (L ? 0 : ((N = c.offset) == null ? void 0 : N[S]) || 0) - (L ? I.crossAxis : 0);
      _ < z ? _ = z : _ > F && (_ = F);
    }
    return { [v]: x, [S]: _ };
  } };
}, Poe = function(t) {
  return t === void 0 && (t = {}), { name: "size", options: t, async fn(e) {
    const { placement: n, rects: r, platform: a, elements: s } = e, { apply: c = () => {
    }, ...f } = t, p = await rb(e, f), g = Nu(n), y = fm(n), v = Up(n) === "x", { width: S, height: x } = r.floating;
    let _, T;
    g === "top" || g === "bottom" ? (_ = g, T = y === (await (a.isRTL == null ? void 0 : a.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (T = g, _ = y === "end" ? "top" : "bottom");
    const I = x - p[_], D = S - p[T], N = !e.middlewareData.shift;
    let j = I, L = D;
    if (v) {
      const F = S - p.left - p.right;
      L = y || N ? bP(D, F) : F;
    } else {
      const F = x - p.top - p.bottom;
      j = y || N ? bP(I, F) : F;
    }
    if (N && !y) {
      const F = Sp(p.left, 0), K = Sp(p.right, 0), X = Sp(p.top, 0), se = Sp(p.bottom, 0);
      v ? L = S - 2 * (F !== 0 || K !== 0 ? F + K : Sp(p.left, p.right)) : j = x - 2 * (X !== 0 || se !== 0 ? X + se : Sp(p.top, p.bottom));
    }
    await c({ ...e, availableWidth: L, availableHeight: j });
    const z = await a.getDimensions(s.floating);
    return S !== z.width || x !== z.height ? { reset: { rects: !0 } } : {};
  } };
};
function Ws(t) {
  var e;
  return ((e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function Il(t) {
  return Ws(t).getComputedStyle(t);
}
function rz(t) {
  return t instanceof Ws(t).Node;
}
function ef(t) {
  return rz(t) ? (t.nodeName || "").toLowerCase() : "";
}
function Al(t) {
  return t instanceof Ws(t).HTMLElement;
}
function cs(t) {
  return t instanceof Ws(t).Element;
}
function dN(t) {
  return typeof ShadowRoot > "u" ? !1 : t instanceof Ws(t).ShadowRoot || t instanceof ShadowRoot;
}
function ib(t) {
  const { overflow: e, overflowX: n, overflowY: r, display: a } = Il(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !["inline", "contents"].includes(a);
}
function Ioe(t) {
  return ["table", "td", "th"].includes(ef(t));
}
function wP(t) {
  const e = e2(), n = Il(t);
  return n.transform !== "none" || n.perspective !== "none" || !e && !!n.backdropFilter && n.backdropFilter !== "none" || !e && !!n.filter && n.filter !== "none" || ["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function e2() {
  return !(typeof CSS > "u" || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none");
}
function T1(t) {
  return ["html", "body", "#document"].includes(ef(t));
}
const fN = Math.min, Hy = Math.max, Ux = Math.round;
function iz(t) {
  const e = Il(t);
  let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const a = Al(t), s = a ? t.offsetWidth : n, c = a ? t.offsetHeight : r, f = Ux(n) !== s || Ux(r) !== c;
  return f && (n = s, r = c), { width: n, height: r, fallback: f };
}
function oz(t) {
  return cs(t) ? t : t.contextElement;
}
const az = { x: 1, y: 1 };
function Xg(t) {
  const e = oz(t);
  if (!Al(e))
    return az;
  const n = e.getBoundingClientRect(), { width: r, height: a, fallback: s } = iz(e);
  let c = (s ? Ux(n.width) : n.width) / r, f = (s ? Ux(n.height) : n.height) / a;
  return c && Number.isFinite(c) || (c = 1), f && Number.isFinite(f) || (f = 1), { x: c, y: f };
}
const pN = { x: 0, y: 0 };
function sz(t, e, n) {
  var r, a;
  if (e === void 0 && (e = !0), !e2())
    return pN;
  const s = t ? Ws(t) : window;
  return !n || e && n !== s ? pN : { x: ((r = s.visualViewport) == null ? void 0 : r.offsetLeft) || 0, y: ((a = s.visualViewport) == null ? void 0 : a.offsetTop) || 0 };
}
function Op(t, e, n, r) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const a = t.getBoundingClientRect(), s = oz(t);
  let c = az;
  e && (r ? cs(r) && (c = Xg(r)) : c = Xg(t));
  const f = sz(s, n, r);
  let p = (a.left + f.x) / c.x, g = (a.top + f.y) / c.y, y = a.width / c.x, v = a.height / c.y;
  if (s) {
    const S = Ws(s), x = r && cs(r) ? Ws(r) : r;
    let _ = S.frameElement;
    for (; _ && r && x !== S; ) {
      const T = Xg(_), I = _.getBoundingClientRect(), D = getComputedStyle(_);
      I.x += (_.clientLeft + parseFloat(D.paddingLeft)) * T.x, I.y += (_.clientTop + parseFloat(D.paddingTop)) * T.y, p *= T.x, g *= T.y, y *= T.x, v *= T.y, p += I.x, g += I.y, _ = Ws(_).frameElement;
    }
  }
  return jx({ width: y, height: v, x: p, y: g });
}
function Xd(t) {
  return ((rz(t) ? t.ownerDocument : t.document) || window.document).documentElement;
}
function k1(t) {
  return cs(t) ? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop } : { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset };
}
function lz(t) {
  return Op(Xd(t)).left + k1(t).scrollLeft;
}
function Zg(t) {
  if (ef(t) === "html")
    return t;
  const e = t.assignedSlot || t.parentNode || dN(t) && t.host || Xd(t);
  return dN(e) ? e.host : e;
}
function cz(t) {
  const e = Zg(t);
  return T1(e) ? e.ownerDocument.body : Al(e) && ib(e) ? e : cz(e);
}
function Vy(t, e) {
  var n;
  e === void 0 && (e = []);
  const r = cz(t), a = r === ((n = t.ownerDocument) == null ? void 0 : n.body), s = Ws(r);
  return a ? e.concat(s, s.visualViewport || [], ib(r) ? r : []) : e.concat(r, Vy(r));
}
function hN(t, e, n) {
  let r;
  if (e === "viewport")
    r = function(a, s) {
      const c = Ws(a), f = Xd(a), p = c.visualViewport;
      let g = f.clientWidth, y = f.clientHeight, v = 0, S = 0;
      if (p) {
        g = p.width, y = p.height;
        const x = e2();
        (!x || x && s === "fixed") && (v = p.offsetLeft, S = p.offsetTop);
      }
      return { width: g, height: y, x: v, y: S };
    }(t, n);
  else if (e === "document")
    r = function(a) {
      const s = Xd(a), c = k1(a), f = a.ownerDocument.body, p = Hy(s.scrollWidth, s.clientWidth, f.scrollWidth, f.clientWidth), g = Hy(s.scrollHeight, s.clientHeight, f.scrollHeight, f.clientHeight);
      let y = -c.scrollLeft + lz(a);
      const v = -c.scrollTop;
      return Il(f).direction === "rtl" && (y += Hy(s.clientWidth, f.clientWidth) - p), { width: p, height: g, x: y, y: v };
    }(Xd(t));
  else if (cs(e))
    r = function(a, s) {
      const c = Op(a, !0, s === "fixed"), f = c.top + a.clientTop, p = c.left + a.clientLeft, g = Al(a) ? Xg(a) : { x: 1, y: 1 };
      return { width: a.clientWidth * g.x, height: a.clientHeight * g.y, x: p * g.x, y: f * g.y };
    }(e, n);
  else {
    const a = sz(t);
    r = { ...e, x: e.x - a.x, y: e.y - a.y };
  }
  return jx(r);
}
function uz(t, e) {
  const n = Zg(t);
  return !(n === e || !cs(n) || T1(n)) && (Il(n).position === "fixed" || uz(n, e));
}
function gN(t, e) {
  return Al(t) && Il(t).position !== "fixed" ? e ? e(t) : t.offsetParent : null;
}
function mN(t, e) {
  const n = Ws(t);
  if (!Al(t))
    return n;
  let r = gN(t, e);
  for (; r && Ioe(r) && Il(r).position === "static"; )
    r = gN(r, e);
  return r && (ef(r) === "html" || ef(r) === "body" && Il(r).position === "static" && !wP(r)) ? n : r || function(a) {
    let s = Zg(a);
    for (; Al(s) && !T1(s); ) {
      if (wP(s))
        return s;
      s = Zg(s);
    }
    return null;
  }(t) || n;
}
function Roe(t, e, n) {
  const r = Al(e), a = Xd(e), s = n === "fixed", c = Op(t, !0, s, e);
  let f = { scrollLeft: 0, scrollTop: 0 };
  const p = { x: 0, y: 0 };
  if (r || !r && !s)
    if ((ef(e) !== "body" || ib(a)) && (f = k1(e)), Al(e)) {
      const g = Op(e, !0, s, e);
      p.x = g.x + e.clientLeft, p.y = g.y + e.clientTop;
    } else
      a && (p.x = lz(a));
  return { x: c.left + f.scrollLeft - p.x, y: c.top + f.scrollTop - p.y, width: c.width, height: c.height };
}
const $oe = { getClippingRect: function(t) {
  let { element: e, boundary: n, rootBoundary: r, strategy: a } = t;
  const s = n === "clippingAncestors" ? function(g, y) {
    const v = y.get(g);
    if (v)
      return v;
    let S = Vy(g).filter((I) => cs(I) && ef(I) !== "body"), x = null;
    const _ = Il(g).position === "fixed";
    let T = _ ? Zg(g) : g;
    for (; cs(T) && !T1(T); ) {
      const I = Il(T), D = wP(T);
      D || I.position !== "fixed" || (x = null), (_ ? !D && !x : !D && I.position === "static" && x && ["absolute", "fixed"].includes(x.position) || ib(T) && !D && uz(g, T)) ? S = S.filter((N) => N !== T) : x = I, T = Zg(T);
    }
    return y.set(g, S), S;
  }(e, this._c) : [].concat(n), c = [...s, r], f = c[0], p = c.reduce((g, y) => {
    const v = hN(e, y, a);
    return g.top = Hy(v.top, g.top), g.right = fN(v.right, g.right), g.bottom = fN(v.bottom, g.bottom), g.left = Hy(v.left, g.left), g;
  }, hN(e, f, a));
  return { width: p.right - p.left, height: p.bottom - p.top, x: p.left, y: p.top };
}, convertOffsetParentRelativeRectToViewportRelativeRect: function(t) {
  let { rect: e, offsetParent: n, strategy: r } = t;
  const a = Al(n), s = Xd(n);
  if (n === s)
    return e;
  let c = { scrollLeft: 0, scrollTop: 0 }, f = { x: 1, y: 1 };
  const p = { x: 0, y: 0 };
  if ((a || !a && r !== "fixed") && ((ef(n) !== "body" || ib(s)) && (c = k1(n)), Al(n))) {
    const g = Op(n);
    f = Xg(n), p.x = g.x + n.clientLeft, p.y = g.y + n.clientTop;
  }
  return { width: e.width * f.x, height: e.height * f.y, x: e.x * f.x - c.scrollLeft * f.x + p.x, y: e.y * f.y - c.scrollTop * f.y + p.y };
}, isElement: cs, getDimensions: function(t) {
  return iz(t);
}, getOffsetParent: mN, getDocumentElement: Xd, getScale: Xg, async getElementRects(t) {
  let { reference: e, floating: n, strategy: r } = t;
  const a = this.getOffsetParent || mN, s = this.getDimensions;
  return { reference: Roe(e, await a(n), r), floating: { x: 0, y: 0, ...await s(n) } };
}, getClientRects: (t) => Array.from(t.getClientRects()), isRTL: (t) => Il(t).direction === "rtl" };
function Moe(t, e, n, r) {
  r === void 0 && (r = {});
  const { ancestorScroll: a = !0, ancestorResize: s = !0, elementResize: c = !0, animationFrame: f = !1 } = r, p = a || s ? [...cs(t) ? Vy(t) : t.contextElement ? Vy(t.contextElement) : [], ...Vy(e)] : [];
  p.forEach((S) => {
    const x = !cs(S) && S.toString().includes("V");
    !a || f && !x || S.addEventListener("scroll", n, { passive: !0 }), s && S.addEventListener("resize", n);
  });
  let g, y = null;
  c && (y = new ResizeObserver(() => {
    n();
  }), cs(t) && !f && y.observe(t), cs(t) || !t.contextElement || f || y.observe(t.contextElement), y.observe(e));
  let v = f ? Op(t) : null;
  return f && function S() {
    const x = Op(t);
    !v || x.x === v.x && x.y === v.y && x.width === v.width && x.height === v.height || n(), v = x, g = requestAnimationFrame(S);
  }(), n(), () => {
    var S;
    p.forEach((x) => {
      a && x.removeEventListener("scroll", n), s && x.removeEventListener("resize", n);
    }), (S = y) == null || S.disconnect(), y = null, f && cancelAnimationFrame(g);
  };
}
const Aoe = (t, e, n) => {
  const r = /* @__PURE__ */ new Map(), a = { platform: $oe, ...n }, s = { ...a.platform, _c: r };
  return boe(t, e, { ...a, platform: s });
}, Ooe = (t) => {
  const {
    element: e,
    padding: n
  } = t;
  function r(a) {
    return {}.hasOwnProperty.call(a, "current");
  }
  return {
    name: "arrow",
    options: t,
    fn(a) {
      return e && r(e) ? e.current != null ? lN({
        element: e.current,
        padding: n
      }).fn(a) : {} : e ? lN({
        element: e,
        padding: n
      }).fn(a) : {};
    }
  };
};
var fx = typeof document < "u" ? k.useLayoutEffect : k.useEffect;
function Bx(t, e) {
  if (t === e)
    return !0;
  if (typeof t != typeof e)
    return !1;
  if (typeof t == "function" && t.toString() === e.toString())
    return !0;
  let n, r, a;
  if (t && e && typeof t == "object") {
    if (Array.isArray(t)) {
      if (n = t.length, n != e.length)
        return !1;
      for (r = n; r-- !== 0; )
        if (!Bx(t[r], e[r]))
          return !1;
      return !0;
    }
    if (a = Object.keys(t), n = a.length, n !== Object.keys(e).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(e, a[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const s = a[r];
      if (!(s === "_owner" && t.$$typeof) && !Bx(t[s], e[s]))
        return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
}
function dz(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function vN(t, e) {
  const n = dz(t);
  return Math.round(e * n) / n;
}
function yN(t) {
  const e = k.useRef(t);
  return fx(() => {
    e.current = t;
  }), e;
}
function Doe(t) {
  t === void 0 && (t = {});
  const {
    placement: e = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: a,
    elements: {
      reference: s,
      floating: c
    } = {},
    transform: f = !0,
    whileElementsMounted: p,
    open: g
  } = t, [y, v] = k.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [S, x] = k.useState(r);
  Bx(S, r) || x(r);
  const [_, T] = k.useState(null), [I, D] = k.useState(null), N = k.useCallback((Re) => {
    Re != F.current && (F.current = Re, T(Re));
  }, [T]), j = k.useCallback((Re) => {
    Re !== K.current && (K.current = Re, D(Re));
  }, [D]), L = s || _, z = c || I, F = k.useRef(null), K = k.useRef(null), X = k.useRef(y), se = yN(p), ue = yN(a), pe = k.useCallback(() => {
    if (!F.current || !K.current)
      return;
    const Re = {
      placement: e,
      strategy: n,
      middleware: S
    };
    ue.current && (Re.platform = ue.current), Aoe(F.current, K.current, Re).then((he) => {
      const te = {
        ...he,
        isPositioned: !0
      };
      Pe.current && !Bx(X.current, te) && (X.current = te, dm.flushSync(() => {
        v(te);
      }));
    });
  }, [S, e, n, ue]);
  fx(() => {
    g === !1 && X.current.isPositioned && (X.current.isPositioned = !1, v((Re) => ({
      ...Re,
      isPositioned: !1
    })));
  }, [g]);
  const Pe = k.useRef(!1);
  fx(() => (Pe.current = !0, () => {
    Pe.current = !1;
  }), []), fx(() => {
    if (L && (F.current = L), z && (K.current = z), L && z) {
      if (se.current)
        return se.current(L, z, pe);
      pe();
    }
  }, [L, z, pe, se]);
  const ve = k.useMemo(() => ({
    reference: F,
    floating: K,
    setReference: N,
    setFloating: j
  }), [N, j]), Y = k.useMemo(() => ({
    reference: L,
    floating: z
  }), [L, z]), le = k.useMemo(() => {
    const Re = {
      position: n,
      left: 0,
      top: 0
    };
    if (!Y.floating)
      return Re;
    const he = vN(Y.floating, y.x), te = vN(Y.floating, y.y);
    return f ? {
      ...Re,
      transform: "translate(" + he + "px, " + te + "px)",
      ...dz(Y.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: he,
      top: te
    };
  }, [n, f, Y.floating, y.x, y.y]);
  return k.useMemo(() => ({
    ...y,
    update: pe,
    refs: ve,
    elements: Y,
    floatingStyles: le
  }), [y, pe, ve, Y, le]);
}
function fz(t) {
  const [e, n] = k.useState(void 0);
  return Ap(() => {
    if (t) {
      n({
        width: t.offsetWidth,
        height: t.offsetHeight
      });
      const r = new ResizeObserver((a) => {
        if (!Array.isArray(a) || !a.length)
          return;
        const s = a[0];
        let c, f;
        if ("borderBoxSize" in s) {
          const p = s.borderBoxSize, g = Array.isArray(p) ? p[0] : p;
          c = g.inlineSize, f = g.blockSize;
        } else
          c = t.offsetWidth, f = t.offsetHeight;
        n({
          width: c,
          height: f
        });
      });
      return r.observe(t, {
        box: "border-box"
      }), () => r.unobserve(t);
    } else
      n(void 0);
  }, [
    t
  ]), e;
}
const pz = "Popper", [hz, P1] = Oc(pz), [Noe, gz] = hz(pz), Loe = (t) => {
  const { __scopePopper: e, children: n } = t, [r, a] = k.useState(null);
  return /* @__PURE__ */ k.createElement(Noe, {
    scope: e,
    anchor: r,
    onAnchorChange: a
  }, n);
}, joe = "PopperAnchor", zoe = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopePopper: n, virtualRef: r, ...a } = t, s = gz(joe, n), c = k.useRef(null), f = Rr(e, c);
  return k.useEffect(() => {
    s.onAnchorChange(r?.current || c.current);
  }), r ? null : /* @__PURE__ */ k.createElement(pr.div, qe({}, a, {
    ref: f
  }));
}), mz = "PopperContent", [Uoe, Kpe] = hz(mz), Boe = /* @__PURE__ */ k.forwardRef((t, e) => {
  var n, r, a, s, c, f, p, g;
  const { __scopePopper: y, side: v = "bottom", sideOffset: S = 0, align: x = "center", alignOffset: _ = 0, arrowPadding: T = 0, collisionBoundary: I = [], collisionPadding: D = 0, sticky: N = "partial", hideWhenDetached: j = !1, avoidCollisions: L = !0, onPlaced: z, ...F } = t, K = gz(mz, y), [X, se] = k.useState(null), ue = Rr(
    e,
    (Ke) => se(Ke)
  ), [pe, Pe] = k.useState(null), ve = fz(pe), Y = (n = ve?.width) !== null && n !== void 0 ? n : 0, le = (r = ve?.height) !== null && r !== void 0 ? r : 0, Re = v + (x !== "center" ? "-" + x : ""), he = typeof D == "number" ? D : {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...D
  }, te = Array.isArray(I) ? I : [
    I
  ], de = te.length > 0, W = {
    padding: he,
    boundary: te.filter(Foe),
    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
    altBoundary: de
  }, { refs: fe, floatingStyles: ce, placement: xe, isPositioned: $e, middlewareData: Me } = Doe({
    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
    strategy: "fixed",
    placement: Re,
    whileElementsMounted: Moe,
    elements: {
      reference: K.anchor
    },
    middleware: [
      _oe({
        mainAxis: S + le,
        alignmentAxis: _
      }),
      L && Toe({
        mainAxis: !0,
        crossAxis: !1,
        limiter: N === "partial" ? koe() : void 0,
        ...W
      }),
      L && Eoe({
        ...W
      }),
      Poe({
        ...W,
        apply: ({ elements: Ke, rects: yt, availableWidth: Xt, availableHeight: kt }) => {
          const { width: yn, height: Er } = yt.reference, tn = Ke.floating.style;
          tn.setProperty("--radix-popper-available-width", `${Xt}px`), tn.setProperty("--radix-popper-available-height", `${kt}px`), tn.setProperty("--radix-popper-anchor-width", `${yn}px`), tn.setProperty("--radix-popper-anchor-height", `${Er}px`);
        }
      }),
      pe && Ooe({
        element: pe,
        padding: T
      }),
      Hoe({
        arrowWidth: Y,
        arrowHeight: le
      }),
      j && Coe({
        strategy: "referenceHidden"
      })
    ]
  }), [re, Qe] = vz(xe), ke = Yo(z);
  Ap(() => {
    $e && ke?.();
  }, [
    $e,
    ke
  ]);
  const rt = (a = Me.arrow) === null || a === void 0 ? void 0 : a.x, St = (s = Me.arrow) === null || s === void 0 ? void 0 : s.y, Tt = ((c = Me.arrow) === null || c === void 0 ? void 0 : c.centerOffset) !== 0, [Le, Nt] = k.useState();
  return Ap(() => {
    X && Nt(window.getComputedStyle(X).zIndex);
  }, [
    X
  ]), /* @__PURE__ */ k.createElement("div", {
    ref: fe.setFloating,
    "data-radix-popper-content-wrapper": "",
    style: {
      ...ce,
      transform: $e ? ce.transform : "translate(0, -200%)",
      // keep off the page when measuring
      minWidth: "max-content",
      zIndex: Le,
      ["--radix-popper-transform-origin"]: [
        (f = Me.transformOrigin) === null || f === void 0 ? void 0 : f.x,
        (p = Me.transformOrigin) === null || p === void 0 ? void 0 : p.y
      ].join(" ")
    },
    dir: t.dir
  }, /* @__PURE__ */ k.createElement(Uoe, {
    scope: y,
    placedSide: re,
    onArrowChange: Pe,
    arrowX: rt,
    arrowY: St,
    shouldHideArrow: Tt
  }, /* @__PURE__ */ k.createElement(pr.div, qe({
    "data-side": re,
    "data-align": Qe
  }, F, {
    ref: ue,
    style: {
      ...F.style,
      // if the PopperContent hasn't been placed yet (not all measurements done)
      // we prevent animations so that users's animation don't kick in too early referring wrong sides
      animation: $e ? void 0 : "none",
      // hide the content if using the hide middleware and should be hidden
      opacity: (g = Me.hide) !== null && g !== void 0 && g.referenceHidden ? 0 : void 0
    }
  }))));
});
function Foe(t) {
  return t !== null;
}
const Hoe = (t) => ({
  name: "transformOrigin",
  options: t,
  fn(e) {
    var n, r, a, s, c;
    const { placement: f, rects: p, middlewareData: g } = e, v = ((n = g.arrow) === null || n === void 0 ? void 0 : n.centerOffset) !== 0, S = v ? 0 : t.arrowWidth, x = v ? 0 : t.arrowHeight, [_, T] = vz(f), I = {
      start: "0%",
      center: "50%",
      end: "100%"
    }[T], D = ((r = (a = g.arrow) === null || a === void 0 ? void 0 : a.x) !== null && r !== void 0 ? r : 0) + S / 2, N = ((s = (c = g.arrow) === null || c === void 0 ? void 0 : c.y) !== null && s !== void 0 ? s : 0) + x / 2;
    let j = "", L = "";
    return _ === "bottom" ? (j = v ? I : `${D}px`, L = `${-x}px`) : _ === "top" ? (j = v ? I : `${D}px`, L = `${p.floating.height + x}px`) : _ === "right" ? (j = `${-x}px`, L = v ? I : `${N}px`) : _ === "left" && (j = `${p.floating.width + x}px`, L = v ? I : `${N}px`), {
      data: {
        x: j,
        y: L
      }
    };
  }
});
function vz(t) {
  const [e, n = "center"] = t.split("-");
  return [
    e,
    n
  ];
}
const t2 = Loe, yz = zoe, bz = Boe, Sk = "rovingFocusGroup.onEntryFocus", Voe = {
  bubbles: !1,
  cancelable: !0
}, n2 = "RovingFocusGroup", [xP, Sz, Yoe] = w1(n2), [Koe, wz] = Oc(n2, [
  Yoe
]), [Woe, Goe] = Koe(n2), Xoe = /* @__PURE__ */ k.forwardRef((t, e) => /* @__PURE__ */ k.createElement(xP.Provider, {
  scope: t.__scopeRovingFocusGroup
}, /* @__PURE__ */ k.createElement(xP.Slot, {
  scope: t.__scopeRovingFocusGroup
}, /* @__PURE__ */ k.createElement(qoe, qe({}, t, {
  ref: e
}))))), qoe = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeRovingFocusGroup: n, orientation: r, loop: a = !1, dir: s, currentTabStopId: c, defaultCurrentTabStopId: f, onCurrentTabStopIdChange: p, onEntryFocus: g, ...y } = t, v = k.useRef(null), S = Rr(e, v), x = qI(s), [_ = null, T] = cf({
    prop: c,
    defaultProp: f,
    onChange: p
  }), [I, D] = k.useState(!1), N = Yo(g), j = Sz(n), L = k.useRef(!1), [z, F] = k.useState(0);
  return k.useEffect(() => {
    const K = v.current;
    if (K)
      return K.addEventListener(Sk, N), () => K.removeEventListener(Sk, N);
  }, [
    N
  ]), /* @__PURE__ */ k.createElement(Woe, {
    scope: n,
    orientation: r,
    dir: x,
    loop: a,
    currentTabStopId: _,
    onItemFocus: k.useCallback(
      (K) => T(K),
      [
        T
      ]
    ),
    onItemShiftTab: k.useCallback(
      () => D(!0),
      []
    ),
    onFocusableItemAdd: k.useCallback(
      () => F(
        (K) => K + 1
      ),
      []
    ),
    onFocusableItemRemove: k.useCallback(
      () => F(
        (K) => K - 1
      ),
      []
    )
  }, /* @__PURE__ */ k.createElement(pr.div, qe({
    tabIndex: I || z === 0 ? -1 : 0,
    "data-orientation": r
  }, y, {
    ref: S,
    style: {
      outline: "none",
      ...t.style
    },
    onMouseDown: _t(t.onMouseDown, () => {
      L.current = !0;
    }),
    onFocus: _t(t.onFocus, (K) => {
      const X = !L.current;
      if (K.target === K.currentTarget && X && !I) {
        const se = new CustomEvent(Sk, Voe);
        if (K.currentTarget.dispatchEvent(se), !se.defaultPrevented) {
          const ue = j().filter(
            (le) => le.focusable
          ), pe = ue.find(
            (le) => le.active
          ), Pe = ue.find(
            (le) => le.id === _
          ), Y = [
            pe,
            Pe,
            ...ue
          ].filter(Boolean).map(
            (le) => le.ref.current
          );
          xz(Y);
        }
      }
      L.current = !1;
    }),
    onBlur: _t(
      t.onBlur,
      () => D(!1)
    )
  })));
}), Qoe = "RovingFocusGroupItem", Zoe = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeRovingFocusGroup: n, focusable: r = !0, active: a = !1, tabStopId: s, ...c } = t, f = Du(), p = s || f, g = Goe(Qoe, n), y = g.currentTabStopId === p, v = Sz(n), { onFocusableItemAdd: S, onFocusableItemRemove: x } = g;
  return k.useEffect(() => {
    if (r)
      return S(), () => x();
  }, [
    r,
    S,
    x
  ]), /* @__PURE__ */ k.createElement(xP.ItemSlot, {
    scope: n,
    id: p,
    focusable: r,
    active: a
  }, /* @__PURE__ */ k.createElement(pr.span, qe({
    tabIndex: y ? 0 : -1,
    "data-orientation": g.orientation
  }, c, {
    ref: e,
    onMouseDown: _t(t.onMouseDown, (_) => {
      r ? g.onItemFocus(p) : _.preventDefault();
    }),
    onFocus: _t(
      t.onFocus,
      () => g.onItemFocus(p)
    ),
    onKeyDown: _t(t.onKeyDown, (_) => {
      if (_.key === "Tab" && _.shiftKey) {
        g.onItemShiftTab();
        return;
      }
      if (_.target !== _.currentTarget)
        return;
      const T = tae(_, g.orientation, g.dir);
      if (T !== void 0) {
        _.preventDefault();
        let D = v().filter(
          (N) => N.focusable
        ).map(
          (N) => N.ref.current
        );
        if (T === "last")
          D.reverse();
        else if (T === "prev" || T === "next") {
          T === "prev" && D.reverse();
          const N = D.indexOf(_.currentTarget);
          D = g.loop ? nae(D, N + 1) : D.slice(N + 1);
        }
        setTimeout(
          () => xz(D)
        );
      }
    })
  })));
}), Joe = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function eae(t, e) {
  return e !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t;
}
function tae(t, e, n) {
  const r = eae(t.key, n);
  if (!(e === "vertical" && [
    "ArrowLeft",
    "ArrowRight"
  ].includes(r)) && !(e === "horizontal" && [
    "ArrowUp",
    "ArrowDown"
  ].includes(r)))
    return Joe[r];
}
function xz(t) {
  const e = document.activeElement;
  for (const n of t)
    if (n === e || (n.focus(), document.activeElement !== e))
      return;
}
function nae(t, e) {
  return t.map(
    (n, r) => t[(e + r) % t.length]
  );
}
const rae = Xoe, iae = Zoe;
var oae = function(t) {
  if (typeof document > "u")
    return null;
  var e = Array.isArray(t) ? t[0] : t;
  return e.ownerDocument.body;
}, Dg = /* @__PURE__ */ new WeakMap(), Kw = /* @__PURE__ */ new WeakMap(), Ww = {}, wk = 0, Ez = function(t) {
  return t && (t.host || Ez(t.parentNode));
}, aae = function(t, e) {
  return e.map(function(n) {
    if (t.contains(n))
      return n;
    var r = Ez(n);
    return r && t.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", t, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, sae = function(t, e, n, r) {
  var a = aae(e, Array.isArray(t) ? t : [t]);
  Ww[n] || (Ww[n] = /* @__PURE__ */ new WeakMap());
  var s = Ww[n], c = [], f = /* @__PURE__ */ new Set(), p = new Set(a), g = function(v) {
    !v || f.has(v) || (f.add(v), g(v.parentNode));
  };
  a.forEach(g);
  var y = function(v) {
    !v || p.has(v) || Array.prototype.forEach.call(v.children, function(S) {
      if (f.has(S))
        y(S);
      else {
        var x = S.getAttribute(r), _ = x !== null && x !== "false", T = (Dg.get(S) || 0) + 1, I = (s.get(S) || 0) + 1;
        Dg.set(S, T), s.set(S, I), c.push(S), T === 1 && _ && Kw.set(S, !0), I === 1 && S.setAttribute(n, "true"), _ || S.setAttribute(r, "true");
      }
    });
  };
  return y(e), f.clear(), wk++, function() {
    c.forEach(function(v) {
      var S = Dg.get(v) - 1, x = s.get(v) - 1;
      Dg.set(v, S), s.set(v, x), S || (Kw.has(v) || v.removeAttribute(r), Kw.delete(v)), x || v.removeAttribute(n);
    }), wk--, wk || (Dg = /* @__PURE__ */ new WeakMap(), Dg = /* @__PURE__ */ new WeakMap(), Kw = /* @__PURE__ */ new WeakMap(), Ww = {});
  };
}, r2 = function(t, e, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(t) ? t : [t]), a = e || oae(t);
  return a ? (r.push.apply(r, Array.from(a.querySelectorAll("[aria-live]"))), sae(r, a, n, "aria-hidden")) : function() {
    return null;
  };
}, Fd = function() {
  return Fd = Object.assign || function(e) {
    for (var n, r = 1, a = arguments.length; r < a; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, Fd.apply(this, arguments);
};
function lae(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(t); a < r.length; a++)
      e.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[a]) && (n[r[a]] = t[r[a]]);
  return n;
}
function cae(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, a = e.length, s; r < a; r++)
      (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
  return t.concat(s || Array.prototype.slice.call(e));
}
var px = "right-scroll-bar-position", hx = "width-before-scroll-bar", uae = "with-scroll-bars-hidden", dae = "--removed-body-scroll-bar-size";
function fae(t, e) {
  return typeof t == "function" ? t(e) : t && (t.current = e), t;
}
function pae(t, e) {
  var n = k.useState(function() {
    return {
      // value
      value: t,
      // last callback
      callback: e,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var a = n.value;
          a !== r && (n.value = r, n.callback(r, a));
        }
      }
    };
  })[0];
  return n.callback = e, n.facade;
}
function hae(t, e) {
  return pae(e || null, function(n) {
    return t.forEach(function(r) {
      return fae(r, n);
    });
  });
}
var Fx = function() {
  return Fx = Object.assign || function(e) {
    for (var n, r = 1, a = arguments.length; r < a; r++) {
      n = arguments[r];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s]);
    }
    return e;
  }, Fx.apply(this, arguments);
};
function gae(t, e) {
  var n = {};
  for (var r in t)
    Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(t); a < r.length; a++)
      e.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[a]) && (n[r[a]] = t[r[a]]);
  return n;
}
function mae(t) {
  return t;
}
function vae(t, e) {
  e === void 0 && (e = mae);
  var n = [], r = !1, a = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : t;
    },
    useMedium: function(s) {
      var c = e(s, r);
      return n.push(c), function() {
        n = n.filter(function(f) {
          return f !== c;
        });
      };
    },
    assignSyncMedium: function(s) {
      for (r = !0; n.length; ) {
        var c = n;
        n = [], c.forEach(s);
      }
      n = {
        push: function(f) {
          return s(f);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(s) {
      r = !0;
      var c = [];
      if (n.length) {
        var f = n;
        n = [], f.forEach(s), c = n;
      }
      var p = function() {
        var y = c;
        c = [], y.forEach(s);
      }, g = function() {
        return Promise.resolve().then(p);
      };
      g(), n = {
        push: function(y) {
          c.push(y), g();
        },
        filter: function(y) {
          return c = c.filter(y), n;
        }
      };
    }
  };
  return a;
}
function yae(t) {
  t === void 0 && (t = {});
  var e = vae(null);
  return e.options = Fx({ async: !0, ssr: !1 }, t), e;
}
var Cz = function(t) {
  var e = t.sideCar, n = gae(t, ["sideCar"]);
  if (!e)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = e.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return k.createElement(r, Fx({}, n));
};
Cz.isSideCarExport = !0;
function bae(t, e) {
  return t.useMedium(e), Cz;
}
var _z = yae(), xk = function() {
}, I1 = k.forwardRef(function(t, e) {
  var n = k.useRef(null), r = k.useState({
    onScrollCapture: xk,
    onWheelCapture: xk,
    onTouchMoveCapture: xk
  }), a = r[0], s = r[1], c = t.forwardProps, f = t.children, p = t.className, g = t.removeScrollBar, y = t.enabled, v = t.shards, S = t.sideCar, x = t.noIsolation, _ = t.inert, T = t.allowPinchZoom, I = t.as, D = I === void 0 ? "div" : I, N = lae(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]), j = S, L = hae([n, e]), z = Fd(Fd({}, N), a);
  return k.createElement(
    k.Fragment,
    null,
    y && k.createElement(j, { sideCar: _z, removeScrollBar: g, shards: v, noIsolation: x, inert: _, setCallbacks: s, allowPinchZoom: !!T, lockRef: n }),
    c ? k.cloneElement(k.Children.only(f), Fd(Fd({}, z), { ref: L })) : k.createElement(D, Fd({}, z, { className: p, ref: L }), f)
  );
});
I1.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
I1.classNames = {
  fullWidth: hx,
  zeroRight: px
};
var bN, Sae = function() {
  if (bN)
    return bN;
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function wae() {
  if (!document)
    return null;
  var t = document.createElement("style");
  t.type = "text/css";
  var e = Sae();
  return e && t.setAttribute("nonce", e), t;
}
function xae(t, e) {
  t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e));
}
function Eae(t) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(t);
}
var Cae = function() {
  var t = 0, e = null;
  return {
    add: function(n) {
      t == 0 && (e = wae()) && (xae(e, n), Eae(e)), t++;
    },
    remove: function() {
      t--, !t && e && (e.parentNode && e.parentNode.removeChild(e), e = null);
    }
  };
}, _ae = function() {
  var t = Cae();
  return function(e, n) {
    k.useEffect(function() {
      return t.add(e), function() {
        t.remove();
      };
    }, [e && n]);
  };
}, Tz = function() {
  var t = _ae(), e = function(n) {
    var r = n.styles, a = n.dynamic;
    return t(r, a), null;
  };
  return e;
}, Tae = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, Ek = function(t) {
  return parseInt(t || "", 10) || 0;
}, kae = function(t) {
  var e = window.getComputedStyle(document.body), n = e[t === "padding" ? "paddingLeft" : "marginLeft"], r = e[t === "padding" ? "paddingTop" : "marginTop"], a = e[t === "padding" ? "paddingRight" : "marginRight"];
  return [Ek(n), Ek(r), Ek(a)];
}, Pae = function(t) {
  if (t === void 0 && (t = "margin"), typeof window > "u")
    return Tae;
  var e = kae(t), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: e[0],
    top: e[1],
    right: e[2],
    gap: Math.max(0, r - n + e[2] - e[0])
  };
}, Iae = Tz(), Rae = function(t, e, n, r) {
  var a = t.left, s = t.top, c = t.right, f = t.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(uae, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(f, "px ").concat(r, `;
  }
  body {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    e && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(a, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(c, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(f, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(f, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(px, ` {
    right: `).concat(f, "px ").concat(r, `;
  }
  
  .`).concat(hx, ` {
    margin-right: `).concat(f, "px ").concat(r, `;
  }
  
  .`).concat(px, " .").concat(px, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(hx, " .").concat(hx, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body {
    `).concat(dae, ": ").concat(f, `px;
  }
`);
}, $ae = function(t) {
  var e = t.noRelative, n = t.noImportant, r = t.gapMode, a = r === void 0 ? "margin" : r, s = k.useMemo(function() {
    return Pae(a);
  }, [a]);
  return k.createElement(Iae, { styles: Rae(s, !e, a, n ? "" : "!important") });
}, EP = !1;
if (typeof window < "u")
  try {
    var Gw = Object.defineProperty({}, "passive", {
      get: function() {
        return EP = !0, !0;
      }
    });
    window.addEventListener("test", Gw, Gw), window.removeEventListener("test", Gw, Gw);
  } catch {
    EP = !1;
  }
var Ng = EP ? { passive: !1 } : !1, Mae = function(t) {
  return t.tagName === "TEXTAREA";
}, kz = function(t, e) {
  var n = window.getComputedStyle(t);
  return (
    // not-not-scrollable
    n[e] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !Mae(t) && n[e] === "visible")
  );
}, Aae = function(t) {
  return kz(t, "overflowY");
}, Oae = function(t) {
  return kz(t, "overflowX");
}, SN = function(t, e) {
  var n = e;
  do {
    typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host);
    var r = Pz(t, n);
    if (r) {
      var a = Iz(t, n), s = a[1], c = a[2];
      if (s > c)
        return !0;
    }
    n = n.parentNode;
  } while (n && n !== document.body);
  return !1;
}, Dae = function(t) {
  var e = t.scrollTop, n = t.scrollHeight, r = t.clientHeight;
  return [
    e,
    n,
    r
  ];
}, Nae = function(t) {
  var e = t.scrollLeft, n = t.scrollWidth, r = t.clientWidth;
  return [
    e,
    n,
    r
  ];
}, Pz = function(t, e) {
  return t === "v" ? Aae(e) : Oae(e);
}, Iz = function(t, e) {
  return t === "v" ? Dae(e) : Nae(e);
}, Lae = function(t, e) {
  return t === "h" && e === "rtl" ? -1 : 1;
}, jae = function(t, e, n, r, a) {
  var s = Lae(t, window.getComputedStyle(e).direction), c = s * r, f = n.target, p = e.contains(f), g = !1, y = c > 0, v = 0, S = 0;
  do {
    var x = Iz(t, f), _ = x[0], T = x[1], I = x[2], D = T - I - s * _;
    (_ || D) && Pz(t, f) && (v += D, S += _), f = f.parentNode;
  } while (
    // portaled content
    !p && f !== document.body || // self content
    p && (e.contains(f) || e === f)
  );
  return (y && (a && v === 0 || !a && c > v) || !y && (a && S === 0 || !a && -c > S)) && (g = !0), g;
}, Xw = function(t) {
  return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
}, wN = function(t) {
  return [t.deltaX, t.deltaY];
}, xN = function(t) {
  return t && "current" in t ? t.current : t;
}, zae = function(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}, Uae = function(t) {
  return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`);
}, Bae = 0, Lg = [];
function Fae(t) {
  var e = k.useRef([]), n = k.useRef([0, 0]), r = k.useRef(), a = k.useState(Bae++)[0], s = k.useState(function() {
    return Tz();
  })[0], c = k.useRef(t);
  k.useEffect(function() {
    c.current = t;
  }, [t]), k.useEffect(function() {
    if (t.inert) {
      document.body.classList.add("block-interactivity-".concat(a));
      var T = cae([t.lockRef.current], (t.shards || []).map(xN), !0).filter(Boolean);
      return T.forEach(function(I) {
        return I.classList.add("allow-interactivity-".concat(a));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(a)), T.forEach(function(I) {
          return I.classList.remove("allow-interactivity-".concat(a));
        });
      };
    }
  }, [t.inert, t.lockRef.current, t.shards]);
  var f = k.useCallback(function(T, I) {
    if ("touches" in T && T.touches.length === 2)
      return !c.current.allowPinchZoom;
    var D = Xw(T), N = n.current, j = "deltaX" in T ? T.deltaX : N[0] - D[0], L = "deltaY" in T ? T.deltaY : N[1] - D[1], z, F = T.target, K = Math.abs(j) > Math.abs(L) ? "h" : "v";
    if ("touches" in T && K === "h" && F.type === "range")
      return !1;
    var X = SN(K, F);
    if (!X)
      return !0;
    if (X ? z = K : (z = K === "v" ? "h" : "v", X = SN(K, F)), !X)
      return !1;
    if (!r.current && "changedTouches" in T && (j || L) && (r.current = z), !z)
      return !0;
    var se = r.current || z;
    return jae(se, I, T, se === "h" ? j : L, !0);
  }, []), p = k.useCallback(function(T) {
    var I = T;
    if (!(!Lg.length || Lg[Lg.length - 1] !== s)) {
      var D = "deltaY" in I ? wN(I) : Xw(I), N = e.current.filter(function(z) {
        return z.name === I.type && z.target === I.target && zae(z.delta, D);
      })[0];
      if (N && N.should) {
        I.cancelable && I.preventDefault();
        return;
      }
      if (!N) {
        var j = (c.current.shards || []).map(xN).filter(Boolean).filter(function(z) {
          return z.contains(I.target);
        }), L = j.length > 0 ? f(I, j[0]) : !c.current.noIsolation;
        L && I.cancelable && I.preventDefault();
      }
    }
  }, []), g = k.useCallback(function(T, I, D, N) {
    var j = { name: T, delta: I, target: D, should: N };
    e.current.push(j), setTimeout(function() {
      e.current = e.current.filter(function(L) {
        return L !== j;
      });
    }, 1);
  }, []), y = k.useCallback(function(T) {
    n.current = Xw(T), r.current = void 0;
  }, []), v = k.useCallback(function(T) {
    g(T.type, wN(T), T.target, f(T, t.lockRef.current));
  }, []), S = k.useCallback(function(T) {
    g(T.type, Xw(T), T.target, f(T, t.lockRef.current));
  }, []);
  k.useEffect(function() {
    return Lg.push(s), t.setCallbacks({
      onScrollCapture: v,
      onWheelCapture: v,
      onTouchMoveCapture: S
    }), document.addEventListener("wheel", p, Ng), document.addEventListener("touchmove", p, Ng), document.addEventListener("touchstart", y, Ng), function() {
      Lg = Lg.filter(function(T) {
        return T !== s;
      }), document.removeEventListener("wheel", p, Ng), document.removeEventListener("touchmove", p, Ng), document.removeEventListener("touchstart", y, Ng);
    };
  }, []);
  var x = t.removeScrollBar, _ = t.inert;
  return k.createElement(
    k.Fragment,
    null,
    _ ? k.createElement(s, { styles: Uae(a) }) : null,
    x ? k.createElement($ae, { gapMode: "margin" }) : null
  );
}
const Hae = bae(_z, Fae);
var Rz = k.forwardRef(function(t, e) {
  return k.createElement(I1, Fd({}, t, { ref: e, sideCar: Hae }));
});
Rz.classNames = I1.classNames;
const i2 = Rz, CP = [
  "Enter",
  " "
], Vae = [
  "ArrowDown",
  "PageUp",
  "Home"
], $z = [
  "ArrowUp",
  "PageDown",
  "End"
], Yae = [
  ...Vae,
  ...$z
], Kae = {
  ltr: [
    ...CP,
    "ArrowRight"
  ],
  rtl: [
    ...CP,
    "ArrowLeft"
  ]
}, Wae = {
  ltr: [
    "ArrowLeft"
  ],
  rtl: [
    "ArrowRight"
  ]
}, R1 = "Menu", [ob, Gae, Xae] = w1(R1), [Bp, $1] = Oc(R1, [
  Xae,
  P1,
  wz
]), M1 = P1(), Mz = wz(), [Az, uf] = Bp(R1), [qae, Ib] = Bp(R1), Qae = (t) => {
  const { __scopeMenu: e, open: n = !1, children: r, dir: a, onOpenChange: s, modal: c = !0 } = t, f = M1(e), [p, g] = k.useState(null), y = k.useRef(!1), v = Yo(s), S = qI(a);
  return k.useEffect(() => {
    const x = () => {
      y.current = !0, document.addEventListener("pointerdown", _, {
        capture: !0,
        once: !0
      }), document.addEventListener("pointermove", _, {
        capture: !0,
        once: !0
      });
    }, _ = () => y.current = !1;
    return document.addEventListener("keydown", x, {
      capture: !0
    }), () => {
      document.removeEventListener("keydown", x, {
        capture: !0
      }), document.removeEventListener("pointerdown", _, {
        capture: !0
      }), document.removeEventListener("pointermove", _, {
        capture: !0
      });
    };
  }, []), /* @__PURE__ */ k.createElement(t2, f, /* @__PURE__ */ k.createElement(Az, {
    scope: e,
    open: n,
    onOpenChange: v,
    content: p,
    onContentChange: g
  }, /* @__PURE__ */ k.createElement(qae, {
    scope: e,
    onClose: k.useCallback(
      () => v(!1),
      [
        v
      ]
    ),
    isUsingKeyboardRef: y,
    dir: S,
    modal: c
  }, r)));
}, Oz = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeMenu: n, ...r } = t, a = M1(n);
  return /* @__PURE__ */ k.createElement(yz, qe({}, a, r, {
    ref: e
  }));
}), Dz = "MenuPortal", [Zae, Nz] = Bp(Dz, {
  forceMount: void 0
}), Jae = (t) => {
  const { __scopeMenu: e, forceMount: n, children: r, container: a } = t, s = uf(Dz, e);
  return /* @__PURE__ */ k.createElement(Zae, {
    scope: e,
    forceMount: n
  }, /* @__PURE__ */ k.createElement(Ol, {
    present: n || s.open
  }, /* @__PURE__ */ k.createElement(E1, {
    asChild: !0,
    container: a
  }, r)));
}, Rl = "MenuContent", [ese, o2] = Bp(Rl), tse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = Nz(Rl, t.__scopeMenu), { forceMount: r = n.forceMount, ...a } = t, s = uf(Rl, t.__scopeMenu), c = Ib(Rl, t.__scopeMenu);
  return /* @__PURE__ */ k.createElement(ob.Provider, {
    scope: t.__scopeMenu
  }, /* @__PURE__ */ k.createElement(Ol, {
    present: r || s.open
  }, /* @__PURE__ */ k.createElement(ob.Slot, {
    scope: t.__scopeMenu
  }, c.modal ? /* @__PURE__ */ k.createElement(nse, qe({}, a, {
    ref: e
  })) : /* @__PURE__ */ k.createElement(rse, qe({}, a, {
    ref: e
  })))));
}), nse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = uf(Rl, t.__scopeMenu), r = k.useRef(null), a = Rr(e, r);
  return k.useEffect(() => {
    const s = r.current;
    if (s)
      return r2(s);
  }, []), /* @__PURE__ */ k.createElement(a2, qe({}, t, {
    ref: a,
    trapFocus: n.open,
    disableOutsidePointerEvents: n.open,
    disableOutsideScroll: !0,
    onFocusOutside: _t(
      t.onFocusOutside,
      (s) => s.preventDefault(),
      {
        checkForDefaultPrevented: !1
      }
    ),
    onDismiss: () => n.onOpenChange(!1)
  }));
}), rse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = uf(Rl, t.__scopeMenu);
  return /* @__PURE__ */ k.createElement(a2, qe({}, t, {
    ref: e,
    trapFocus: !1,
    disableOutsidePointerEvents: !1,
    disableOutsideScroll: !1,
    onDismiss: () => n.onOpenChange(!1)
  }));
}), a2 = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeMenu: n, loop: r = !1, trapFocus: a, onOpenAutoFocus: s, onCloseAutoFocus: c, disableOutsidePointerEvents: f, onEntryFocus: p, onEscapeKeyDown: g, onPointerDownOutside: y, onFocusOutside: v, onInteractOutside: S, onDismiss: x, disableOutsideScroll: _, ...T } = t, I = uf(Rl, n), D = Ib(Rl, n), N = M1(n), j = Mz(n), L = Gae(n), [z, F] = k.useState(null), K = k.useRef(null), X = Rr(e, K, I.onContentChange), se = k.useRef(0), ue = k.useRef(""), pe = k.useRef(0), Pe = k.useRef(null), ve = k.useRef("right"), Y = k.useRef(0), le = _ ? i2 : k.Fragment, Re = _ ? {
    as: Mp,
    allowPinchZoom: !0
  } : void 0, he = (de) => {
    var W, fe;
    const ce = ue.current + de, xe = L().filter(
      (rt) => !rt.disabled
    ), $e = document.activeElement, Me = (W = xe.find(
      (rt) => rt.ref.current === $e
    )) === null || W === void 0 ? void 0 : W.textValue, re = xe.map(
      (rt) => rt.textValue
    ), Qe = vse(re, ce, Me), ke = (fe = xe.find(
      (rt) => rt.textValue === Qe
    )) === null || fe === void 0 ? void 0 : fe.ref.current;
    (function rt(St) {
      ue.current = St, window.clearTimeout(se.current), St !== "" && (se.current = window.setTimeout(
        () => rt(""),
        1e3
      ));
    })(ce), ke && setTimeout(
      () => ke.focus()
    );
  };
  k.useEffect(() => () => window.clearTimeout(se.current), []), QI();
  const te = k.useCallback((de) => {
    var W, fe;
    return ve.current === ((W = Pe.current) === null || W === void 0 ? void 0 : W.side) && bse(de, (fe = Pe.current) === null || fe === void 0 ? void 0 : fe.area);
  }, []);
  return /* @__PURE__ */ k.createElement(ese, {
    scope: n,
    searchRef: ue,
    onItemEnter: k.useCallback((de) => {
      te(de) && de.preventDefault();
    }, [
      te
    ]),
    onItemLeave: k.useCallback((de) => {
      var W;
      te(de) || ((W = K.current) === null || W === void 0 || W.focus(), F(null));
    }, [
      te
    ]),
    onTriggerLeave: k.useCallback((de) => {
      te(de) && de.preventDefault();
    }, [
      te
    ]),
    pointerGraceTimerRef: pe,
    onPointerGraceIntentChange: k.useCallback((de) => {
      Pe.current = de;
    }, [])
  }, /* @__PURE__ */ k.createElement(le, Re, /* @__PURE__ */ k.createElement(ZI, {
    asChild: !0,
    trapped: a,
    onMountAutoFocus: _t(s, (de) => {
      var W;
      de.preventDefault(), (W = K.current) === null || W === void 0 || W.focus();
    }),
    onUnmountAutoFocus: c
  }, /* @__PURE__ */ k.createElement(x1, {
    asChild: !0,
    disableOutsidePointerEvents: f,
    onEscapeKeyDown: g,
    onPointerDownOutside: y,
    onFocusOutside: v,
    onInteractOutside: S,
    onDismiss: x
  }, /* @__PURE__ */ k.createElement(rae, qe({
    asChild: !0
  }, j, {
    dir: D.dir,
    orientation: "vertical",
    loop: r,
    currentTabStopId: z,
    onCurrentTabStopIdChange: F,
    onEntryFocus: _t(p, (de) => {
      D.isUsingKeyboardRef.current || de.preventDefault();
    })
  }), /* @__PURE__ */ k.createElement(bz, qe({
    role: "menu",
    "aria-orientation": "vertical",
    "data-state": Fz(I.open),
    "data-radix-menu-content": "",
    dir: D.dir
  }, N, T, {
    ref: X,
    style: {
      outline: "none",
      ...T.style
    },
    onKeyDown: _t(T.onKeyDown, (de) => {
      const fe = de.target.closest("[data-radix-menu-content]") === de.currentTarget, ce = de.ctrlKey || de.altKey || de.metaKey, xe = de.key.length === 1;
      fe && (de.key === "Tab" && de.preventDefault(), !ce && xe && he(de.key));
      const $e = K.current;
      if (de.target !== $e || !Yae.includes(de.key))
        return;
      de.preventDefault();
      const re = L().filter(
        (Qe) => !Qe.disabled
      ).map(
        (Qe) => Qe.ref.current
      );
      $z.includes(de.key) && re.reverse(), gse(re);
    }),
    onBlur: _t(t.onBlur, (de) => {
      de.currentTarget.contains(de.target) || (window.clearTimeout(se.current), ue.current = "");
    }),
    onPointerMove: _t(t.onPointerMove, ab((de) => {
      const W = de.target, fe = Y.current !== de.clientX;
      if (de.currentTarget.contains(W) && fe) {
        const ce = de.clientX > Y.current ? "right" : "left";
        ve.current = ce, Y.current = de.clientX;
      }
    }))
  })))))));
}), ise = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeMenu: n, ...r } = t;
  return /* @__PURE__ */ k.createElement(pr.div, qe({
    role: "group"
  }, r, {
    ref: e
  }));
}), _P = "MenuItem", EN = "menu.itemSelect", Lz = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { disabled: n = !1, onSelect: r, ...a } = t, s = k.useRef(null), c = Ib(_P, t.__scopeMenu), f = o2(_P, t.__scopeMenu), p = Rr(e, s), g = k.useRef(!1), y = () => {
    const v = s.current;
    if (!n && v) {
      const S = new CustomEvent(EN, {
        bubbles: !0,
        cancelable: !0
      });
      v.addEventListener(
        EN,
        (x) => r?.(x),
        {
          once: !0
        }
      ), GI(v, S), S.defaultPrevented ? g.current = !1 : c.onClose();
    }
  };
  return /* @__PURE__ */ k.createElement(jz, qe({}, a, {
    ref: p,
    disabled: n,
    onClick: _t(t.onClick, y),
    onPointerDown: (v) => {
      var S;
      (S = t.onPointerDown) === null || S === void 0 || S.call(t, v), g.current = !0;
    },
    onPointerUp: _t(t.onPointerUp, (v) => {
      var S;
      g.current || (S = v.currentTarget) === null || S === void 0 || S.click();
    }),
    onKeyDown: _t(t.onKeyDown, (v) => {
      const S = f.searchRef.current !== "";
      n || S && v.key === " " || CP.includes(v.key) && (v.currentTarget.click(), v.preventDefault());
    })
  }));
}), jz = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeMenu: n, disabled: r = !1, textValue: a, ...s } = t, c = o2(_P, n), f = Mz(n), p = k.useRef(null), g = Rr(e, p), [y, v] = k.useState(!1), [S, x] = k.useState("");
  return k.useEffect(() => {
    const _ = p.current;
    if (_) {
      var T;
      x(((T = _.textContent) !== null && T !== void 0 ? T : "").trim());
    }
  }, [
    s.children
  ]), /* @__PURE__ */ k.createElement(ob.ItemSlot, {
    scope: n,
    disabled: r,
    textValue: a ?? S
  }, /* @__PURE__ */ k.createElement(iae, qe({
    asChild: !0
  }, f, {
    focusable: !r
  }), /* @__PURE__ */ k.createElement(pr.div, qe({
    role: "menuitem",
    "data-highlighted": y ? "" : void 0,
    "aria-disabled": r || void 0,
    "data-disabled": r ? "" : void 0
  }, s, {
    ref: g,
    onPointerMove: _t(t.onPointerMove, ab((_) => {
      r ? c.onItemLeave(_) : (c.onItemEnter(_), _.defaultPrevented || _.currentTarget.focus());
    })),
    onPointerLeave: _t(t.onPointerLeave, ab(
      (_) => c.onItemLeave(_)
    )),
    onFocus: _t(
      t.onFocus,
      () => v(!0)
    ),
    onBlur: _t(
      t.onBlur,
      () => v(!1)
    )
  }))));
}), ose = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { checked: n = !1, onCheckedChange: r, ...a } = t;
  return /* @__PURE__ */ k.createElement(sse, {
    scope: t.__scopeMenu,
    checked: n
  }, /* @__PURE__ */ k.createElement(Lz, qe({
    role: "menuitemcheckbox",
    "aria-checked": Hx(n) ? "mixed" : n
  }, a, {
    ref: e,
    "data-state": Hz(n),
    onSelect: _t(
      a.onSelect,
      () => r?.(Hx(n) ? !0 : !n),
      {
        checkForDefaultPrevented: !1
      }
    )
  })));
}), ase = "MenuRadioGroup";
Bp(ase, {
  value: void 0,
  onValueChange: () => {
  }
});
const zz = "MenuItemIndicator", [sse, lse] = Bp(zz, {
  checked: !1
}), cse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeMenu: n, forceMount: r, ...a } = t, s = lse(zz, n);
  return /* @__PURE__ */ k.createElement(Ol, {
    present: r || Hx(s.checked) || s.checked === !0
  }, /* @__PURE__ */ k.createElement(pr.span, qe({}, a, {
    ref: e,
    "data-state": Hz(s.checked)
  })));
}), Uz = "MenuSub", [use, Bz] = Bp(Uz), dse = (t) => {
  const { __scopeMenu: e, children: n, open: r = !1, onOpenChange: a } = t, s = uf(Uz, e), c = M1(e), [f, p] = k.useState(null), [g, y] = k.useState(null), v = Yo(a);
  return k.useEffect(() => (s.open === !1 && v(!1), () => v(!1)), [
    s.open,
    v
  ]), /* @__PURE__ */ k.createElement(t2, c, /* @__PURE__ */ k.createElement(Az, {
    scope: e,
    open: r,
    onOpenChange: v,
    content: g,
    onContentChange: y
  }, /* @__PURE__ */ k.createElement(use, {
    scope: e,
    contentId: Du(),
    triggerId: Du(),
    trigger: f,
    onTriggerChange: p
  }, n)));
}, qw = "MenuSubTrigger", fse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = uf(qw, t.__scopeMenu), r = Ib(qw, t.__scopeMenu), a = Bz(qw, t.__scopeMenu), s = o2(qw, t.__scopeMenu), c = k.useRef(null), { pointerGraceTimerRef: f, onPointerGraceIntentChange: p } = s, g = {
    __scopeMenu: t.__scopeMenu
  }, y = k.useCallback(() => {
    c.current && window.clearTimeout(c.current), c.current = null;
  }, []);
  return k.useEffect(
    () => y,
    [
      y
    ]
  ), k.useEffect(() => {
    const v = f.current;
    return () => {
      window.clearTimeout(v), p(null);
    };
  }, [
    f,
    p
  ]), /* @__PURE__ */ k.createElement(Oz, qe({
    asChild: !0
  }, g), /* @__PURE__ */ k.createElement(jz, qe({
    id: a.triggerId,
    "aria-haspopup": "menu",
    "aria-expanded": n.open,
    "aria-controls": a.contentId,
    "data-state": Fz(n.open)
  }, t, {
    ref: S1(e, a.onTriggerChange),
    onClick: (v) => {
      var S;
      (S = t.onClick) === null || S === void 0 || S.call(t, v), !(t.disabled || v.defaultPrevented) && (v.currentTarget.focus(), n.open || n.onOpenChange(!0));
    },
    onPointerMove: _t(t.onPointerMove, ab((v) => {
      s.onItemEnter(v), !v.defaultPrevented && !t.disabled && !n.open && !c.current && (s.onPointerGraceIntentChange(null), c.current = window.setTimeout(() => {
        n.onOpenChange(!0), y();
      }, 100));
    })),
    onPointerLeave: _t(t.onPointerLeave, ab((v) => {
      var S;
      y();
      const x = (S = n.content) === null || S === void 0 ? void 0 : S.getBoundingClientRect();
      if (x) {
        var _;
        const T = (_ = n.content) === null || _ === void 0 ? void 0 : _.dataset.side, I = T === "right", D = I ? -5 : 5, N = x[I ? "left" : "right"], j = x[I ? "right" : "left"];
        s.onPointerGraceIntentChange({
          area: [
            // consistently within polygon bounds
            {
              x: v.clientX + D,
              y: v.clientY
            },
            {
              x: N,
              y: x.top
            },
            {
              x: j,
              y: x.top
            },
            {
              x: j,
              y: x.bottom
            },
            {
              x: N,
              y: x.bottom
            }
          ],
          side: T
        }), window.clearTimeout(f.current), f.current = window.setTimeout(
          () => s.onPointerGraceIntentChange(null),
          300
        );
      } else {
        if (s.onTriggerLeave(v), v.defaultPrevented)
          return;
        s.onPointerGraceIntentChange(null);
      }
    })),
    onKeyDown: _t(t.onKeyDown, (v) => {
      const S = s.searchRef.current !== "";
      if (!(t.disabled || S && v.key === " ") && Kae[r.dir].includes(v.key)) {
        var x;
        n.onOpenChange(!0), (x = n.content) === null || x === void 0 || x.focus(), v.preventDefault();
      }
    })
  })));
}), pse = "MenuSubContent", hse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = Nz(Rl, t.__scopeMenu), { forceMount: r = n.forceMount, ...a } = t, s = uf(Rl, t.__scopeMenu), c = Ib(Rl, t.__scopeMenu), f = Bz(pse, t.__scopeMenu), p = k.useRef(null), g = Rr(e, p);
  return /* @__PURE__ */ k.createElement(ob.Provider, {
    scope: t.__scopeMenu
  }, /* @__PURE__ */ k.createElement(Ol, {
    present: r || s.open
  }, /* @__PURE__ */ k.createElement(ob.Slot, {
    scope: t.__scopeMenu
  }, /* @__PURE__ */ k.createElement(a2, qe({
    id: f.contentId,
    "aria-labelledby": f.triggerId
  }, a, {
    ref: g,
    align: "start",
    side: c.dir === "rtl" ? "left" : "right",
    disableOutsidePointerEvents: !1,
    disableOutsideScroll: !1,
    trapFocus: !1,
    onOpenAutoFocus: (y) => {
      var v;
      c.isUsingKeyboardRef.current && ((v = p.current) === null || v === void 0 || v.focus()), y.preventDefault();
    },
    onCloseAutoFocus: (y) => y.preventDefault(),
    onFocusOutside: _t(t.onFocusOutside, (y) => {
      y.target !== f.trigger && s.onOpenChange(!1);
    }),
    onEscapeKeyDown: _t(t.onEscapeKeyDown, (y) => {
      c.onClose(), y.preventDefault();
    }),
    onKeyDown: _t(t.onKeyDown, (y) => {
      const v = y.currentTarget.contains(y.target), S = Wae[c.dir].includes(y.key);
      if (v && S) {
        var x;
        s.onOpenChange(!1), (x = f.trigger) === null || x === void 0 || x.focus(), y.preventDefault();
      }
    })
  })))));
});
function Fz(t) {
  return t ? "open" : "closed";
}
function Hx(t) {
  return t === "indeterminate";
}
function Hz(t) {
  return Hx(t) ? "indeterminate" : t ? "checked" : "unchecked";
}
function gse(t) {
  const e = document.activeElement;
  for (const n of t)
    if (n === e || (n.focus(), document.activeElement !== e))
      return;
}
function mse(t, e) {
  return t.map(
    (n, r) => t[(e + r) % t.length]
  );
}
function vse(t, e, n) {
  const a = e.length > 1 && Array.from(e).every(
    (g) => g === e[0]
  ) ? e[0] : e, s = n ? t.indexOf(n) : -1;
  let c = mse(t, Math.max(s, 0));
  a.length === 1 && (c = c.filter(
    (g) => g !== n
  ));
  const p = c.find(
    (g) => g.toLowerCase().startsWith(a.toLowerCase())
  );
  return p !== n ? p : void 0;
}
function yse(t, e) {
  const { x: n, y: r } = t;
  let a = !1;
  for (let s = 0, c = e.length - 1; s < e.length; c = s++) {
    const f = e[s].x, p = e[s].y, g = e[c].x, y = e[c].y;
    p > r != y > r && n < (g - f) * (r - p) / (y - p) + f && (a = !a);
  }
  return a;
}
function bse(t, e) {
  if (!e)
    return !1;
  const n = {
    x: t.clientX,
    y: t.clientY
  };
  return yse(n, e);
}
function ab(t) {
  return (e) => e.pointerType === "mouse" ? t(e) : void 0;
}
const Vz = Qae, Yz = Oz, Kz = Jae, Wz = tse, Gz = ise, Xz = Lz, qz = ose, Sse = cse, Qz = dse, Zz = fse, Jz = hse, e4 = "ContextMenu", [wse, Wpe] = Oc(e4, [
  $1
]), Dc = $1(), [xse, t4] = wse(e4), Ese = (t) => {
  const { __scopeContextMenu: e, children: n, onOpenChange: r, dir: a, modal: s = !0 } = t, [c, f] = k.useState(!1), p = Dc(e), g = Yo(r), y = k.useCallback((v) => {
    f(v), g(v);
  }, [
    g
  ]);
  return /* @__PURE__ */ k.createElement(xse, {
    scope: e,
    open: c,
    onOpenChange: y,
    modal: s
  }, /* @__PURE__ */ k.createElement(Vz, qe({}, p, {
    dir: a,
    open: c,
    onOpenChange: y,
    modal: s
  }), n));
}, Cse = "ContextMenuTrigger", _se = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeContextMenu: n, disabled: r = !1, ...a } = t, s = t4(Cse, n), c = Dc(n), f = k.useRef({
    x: 0,
    y: 0
  }), p = k.useRef({
    getBoundingClientRect: () => DOMRect.fromRect({
      width: 0,
      height: 0,
      ...f.current
    })
  }), g = k.useRef(0), y = k.useCallback(
    () => window.clearTimeout(g.current),
    []
  ), v = (S) => {
    f.current = {
      x: S.clientX,
      y: S.clientY
    }, s.onOpenChange(!0);
  };
  return k.useEffect(
    () => y,
    [
      y
    ]
  ), k.useEffect(
    () => void (r && y()),
    [
      r,
      y
    ]
  ), /* @__PURE__ */ k.createElement(k.Fragment, null, /* @__PURE__ */ k.createElement(Yz, qe({}, c, {
    virtualRef: p
  })), /* @__PURE__ */ k.createElement(pr.span, qe({
    "data-state": s.open ? "open" : "closed",
    "data-disabled": r ? "" : void 0
  }, a, {
    ref: e,
    style: {
      WebkitTouchCallout: "none",
      ...t.style
    },
    onContextMenu: r ? t.onContextMenu : _t(t.onContextMenu, (S) => {
      y(), v(S), S.preventDefault();
    }),
    onPointerDown: r ? t.onPointerDown : _t(t.onPointerDown, Qw((S) => {
      y(), g.current = window.setTimeout(
        () => v(S),
        700
      );
    })),
    onPointerMove: r ? t.onPointerMove : _t(t.onPointerMove, Qw(y)),
    onPointerCancel: r ? t.onPointerCancel : _t(t.onPointerCancel, Qw(y)),
    onPointerUp: r ? t.onPointerUp : _t(t.onPointerUp, Qw(y))
  })));
}), Tse = (t) => {
  const { __scopeContextMenu: e, ...n } = t, r = Dc(e);
  return /* @__PURE__ */ k.createElement(Kz, qe({}, r, n));
}, kse = "ContextMenuContent", Pse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, a = t4(kse, n), s = Dc(n), c = k.useRef(!1);
  return /* @__PURE__ */ k.createElement(Wz, qe({}, s, r, {
    ref: e,
    side: "right",
    sideOffset: 2,
    align: "start",
    onCloseAutoFocus: (f) => {
      var p;
      (p = t.onCloseAutoFocus) === null || p === void 0 || p.call(t, f), !f.defaultPrevented && c.current && f.preventDefault(), c.current = !1;
    },
    onInteractOutside: (f) => {
      var p;
      (p = t.onInteractOutside) === null || p === void 0 || p.call(t, f), !f.defaultPrevented && !a.modal && (c.current = !0);
    },
    style: {
      ...t.style,
      "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }));
}), Ise = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, a = Dc(n);
  return /* @__PURE__ */ k.createElement(Gz, qe({}, a, r, {
    ref: e
  }));
}), Rse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, a = Dc(n);
  return /* @__PURE__ */ k.createElement(Xz, qe({}, a, r, {
    ref: e
  }));
}), $se = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, a = Dc(n);
  return /* @__PURE__ */ k.createElement(qz, qe({}, a, r, {
    ref: e
  }));
}), Mse = (t) => {
  const { __scopeContextMenu: e, children: n, onOpenChange: r, open: a, defaultOpen: s } = t, c = Dc(e), [f, p] = cf({
    prop: a,
    defaultProp: s,
    onChange: r
  });
  return /* @__PURE__ */ k.createElement(Qz, qe({}, c, {
    open: f,
    onOpenChange: p
  }), n);
}, Ase = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, a = Dc(n);
  return /* @__PURE__ */ k.createElement(Zz, qe({}, a, r, {
    ref: e
  }));
}), Ose = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeContextMenu: n, ...r } = t, a = Dc(n);
  return /* @__PURE__ */ k.createElement(Jz, qe({}, a, r, {
    ref: e,
    style: {
      ...t.style,
      "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }));
});
function Qw(t) {
  return (e) => e.pointerType !== "mouse" ? t(e) : void 0;
}
const Dse = Ese, Nse = _se, TP = Tse, Lse = Pse, kP = Ise, Vx = Rse, jse = $se, n4 = Mse, r4 = Ase, i4 = Ose;
function s2(t) {
  return t.filter((e) => e != null && e !== !1);
}
function wn(t, ...e) {
  const n = s2(e);
  return n.length === 0 ? null : {
    id: t,
    type: "group",
    checkbox: n.every((r) => r.type === "item" && r.actionItem.checkbox),
    disabled: n.every((r) => r.disabled),
    readonlyOk: n.some((r) => r.readonlyOk),
    children: n
  };
}
function Ec(t, e, ...n) {
  const r = s2(n);
  return r.length === 0 ? null : {
    id: t,
    type: "submenu",
    label: e,
    children: r,
    disabled: r.every((a) => a.disabled),
    readonlyOk: r.some((a) => a.readonlyOk)
  };
}
function Yx(t, e = {}) {
  const { readonlyOk: n = !0, disabled: r = !1 } = e;
  return {
    id: t,
    type: "custom",
    disabled: r,
    readonlyOk: n
  };
}
function Ie(t, e = {}) {
  if (!t)
    throw Error("No action item provided to menuItem");
  if (!t.label)
    throw Error("Trying to create menu item for action item that doesn't have a label");
  const { checked: n = !1, disabled: r = !1 } = e;
  return {
    id: t.id,
    type: "item",
    actionItem: t,
    disabled: r,
    checked: n,
    readonlyOk: t.readonlyOk
  };
}
function o4(t) {
  const { selectedIds: e } = t;
  return e.map((r) => t.getShapeById(r)).filter((r) => !(!r || to.is(r) && r.props.start.type === "binding" || to.is(r) && r.props.end.type === "binding"));
}
const a4 = () => {
  const t = Ge();
  return un("threeStackableItems", () => o4(t).length > 2, [t]);
}, l2 = () => {
  const t = Ge();
  return un("allowGroup", () => o4(t).length > 1, [t]);
}, c2 = () => {
  const t = Ge();
  return un(
    "allowUngroup",
    () => t.selectedIds.some((e) => t.getShapeById(e)?.type === "group"),
    []
  );
}, zse = typeof window < "u" && "navigator" in window && !!navigator.clipboard && !!navigator.clipboard.read, My = (t, e, n) => t.meta?.geo ? e === "geo" && n === t.meta?.geo : e === t.id, s4 = "Dialog", [l4, Gpe] = Oc(s4), [Use, zu] = l4(s4), Bse = (t) => {
  const { __scopeDialog: e, children: n, open: r, defaultOpen: a, onOpenChange: s, modal: c = !0 } = t, f = k.useRef(null), p = k.useRef(null), [g = !1, y] = cf({
    prop: r,
    defaultProp: a,
    onChange: s
  });
  return /* @__PURE__ */ k.createElement(Use, {
    scope: e,
    triggerRef: f,
    contentRef: p,
    contentId: Du(),
    titleId: Du(),
    descriptionId: Du(),
    open: g,
    onOpenChange: y,
    onOpenToggle: k.useCallback(
      () => y(
        (v) => !v
      ),
      [
        y
      ]
    ),
    modal: c
  }, n);
}, c4 = "DialogPortal", [Fse, u4] = l4(c4, {
  forceMount: void 0
}), Hse = (t) => {
  const { __scopeDialog: e, forceMount: n, children: r, container: a } = t, s = zu(c4, e);
  return /* @__PURE__ */ k.createElement(Fse, {
    scope: e,
    forceMount: n
  }, k.Children.map(
    r,
    (c) => /* @__PURE__ */ k.createElement(Ol, {
      present: n || s.open
    }, /* @__PURE__ */ k.createElement(E1, {
      asChild: !0,
      container: a
    }, c))
  ));
}, PP = "DialogOverlay", Vse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = u4(PP, t.__scopeDialog), { forceMount: r = n.forceMount, ...a } = t, s = zu(PP, t.__scopeDialog);
  return s.modal ? /* @__PURE__ */ k.createElement(Ol, {
    present: r || s.open
  }, /* @__PURE__ */ k.createElement(Yse, qe({}, a, {
    ref: e
  }))) : null;
}), Yse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDialog: n, ...r } = t, a = zu(PP, n);
  return (
    // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
    // ie. when `Overlay` and `Content` are siblings
    /* @__PURE__ */ k.createElement(i2, {
      as: Mp,
      allowPinchZoom: !0,
      shards: [
        a.contentRef
      ]
    }, /* @__PURE__ */ k.createElement(pr.div, qe({
      "data-state": f4(a.open)
    }, r, {
      ref: e,
      style: {
        pointerEvents: "auto",
        ...r.style
      }
    })))
  );
}), sb = "DialogContent", Kse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = u4(sb, t.__scopeDialog), { forceMount: r = n.forceMount, ...a } = t, s = zu(sb, t.__scopeDialog);
  return /* @__PURE__ */ k.createElement(Ol, {
    present: r || s.open
  }, s.modal ? /* @__PURE__ */ k.createElement(Wse, qe({}, a, {
    ref: e
  })) : /* @__PURE__ */ k.createElement(Gse, qe({}, a, {
    ref: e
  })));
}), Wse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = zu(sb, t.__scopeDialog), r = k.useRef(null), a = Rr(e, n.contentRef, r);
  return k.useEffect(() => {
    const s = r.current;
    if (s)
      return r2(s);
  }, []), /* @__PURE__ */ k.createElement(d4, qe({}, t, {
    ref: a,
    trapFocus: n.open,
    disableOutsidePointerEvents: !0,
    onCloseAutoFocus: _t(t.onCloseAutoFocus, (s) => {
      var c;
      s.preventDefault(), (c = n.triggerRef.current) === null || c === void 0 || c.focus();
    }),
    onPointerDownOutside: _t(t.onPointerDownOutside, (s) => {
      const c = s.detail.originalEvent, f = c.button === 0 && c.ctrlKey === !0;
      (c.button === 2 || f) && s.preventDefault();
    }),
    onFocusOutside: _t(
      t.onFocusOutside,
      (s) => s.preventDefault()
    )
  }));
}), Gse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = zu(sb, t.__scopeDialog), r = k.useRef(!1), a = k.useRef(!1);
  return /* @__PURE__ */ k.createElement(d4, qe({}, t, {
    ref: e,
    trapFocus: !1,
    disableOutsidePointerEvents: !1,
    onCloseAutoFocus: (s) => {
      var c;
      if ((c = t.onCloseAutoFocus) === null || c === void 0 || c.call(t, s), !s.defaultPrevented) {
        var f;
        r.current || (f = n.triggerRef.current) === null || f === void 0 || f.focus(), s.preventDefault();
      }
      r.current = !1, a.current = !1;
    },
    onInteractOutside: (s) => {
      var c, f;
      (c = t.onInteractOutside) === null || c === void 0 || c.call(t, s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (a.current = !0));
      const p = s.target;
      ((f = n.triggerRef.current) === null || f === void 0 ? void 0 : f.contains(p)) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && a.current && s.preventDefault();
    }
  }));
}), d4 = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: a, onCloseAutoFocus: s, ...c } = t, f = zu(sb, n), p = k.useRef(null), g = Rr(e, p);
  return QI(), /* @__PURE__ */ k.createElement(k.Fragment, null, /* @__PURE__ */ k.createElement(ZI, {
    asChild: !0,
    loop: !0,
    trapped: r,
    onMountAutoFocus: a,
    onUnmountAutoFocus: s
  }, /* @__PURE__ */ k.createElement(x1, qe({
    role: "dialog",
    id: f.contentId,
    "aria-describedby": f.descriptionId,
    "aria-labelledby": f.titleId,
    "data-state": f4(f.open)
  }, c, {
    ref: g,
    onDismiss: () => f.onOpenChange(!1)
  }))), !1);
}), Xse = "DialogTitle", qse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDialog: n, ...r } = t, a = zu(Xse, n);
  return /* @__PURE__ */ k.createElement(pr.h2, qe({
    id: a.titleId
  }, r, {
    ref: e
  }));
}), Qse = "DialogClose", Zse = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDialog: n, ...r } = t, a = zu(Qse, n);
  return /* @__PURE__ */ k.createElement(pr.button, qe({
    type: "button"
  }, r, {
    ref: e,
    onClick: _t(
      t.onClick,
      () => a.onOpenChange(!1)
    )
  }));
});
function f4(t) {
  return t ? "open" : "closed";
}
const Jse = Bse, ele = Hse, tle = Vse, nle = Kse;
function rle(t) {
  return /* @__PURE__ */ E.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", ...t, children: /* @__PURE__ */ E.jsxs("g", { strokeWidth: 2, fill: "none", fillRule: "evenodd", children: [
    /* @__PURE__ */ E.jsx("circle", { strokeOpacity: 0.25, cx: 8, cy: 8, r: 7, stroke: "currentColor" }),
    /* @__PURE__ */ E.jsx("path", { strokeLinecap: "round", d: "M15 8c0-4.5-4.5-7-7-7", stroke: "currentColor", children: /* @__PURE__ */ E.jsx(
      "animateTransform",
      {
        attributeName: "transform",
        type: "rotate",
        from: "0 8 8",
        to: "360 8 8",
        dur: "1s",
        repeatCount: "indefinite"
      }
    ) })
  ] }) });
}
const Ya = k.forwardRef(function({ small: e, invertIcon: n, icon: r, className: a, ...s }, c) {
  const f = j1();
  return /* @__PURE__ */ E.jsx(
    "div",
    {
      ref: c,
      ...s,
      className: $n("tlui-icon", { "tlui-icon__small": e }, a),
      style: {
        mask: `url(${f.icons[r]}) center 100% / 100% no-repeat`,
        WebkitMask: `url(${f.icons[r]}) center 100% / 100% no-repeat`,
        backgroundColor: "currentcolor",
        transform: n ? "scale(-1, 1)" : void 0
      }
    }
  );
}), p4 = typeof window > "u" ? !1 : window.navigator.userAgent.toLowerCase().indexOf("mac") > -1, h4 = p4 ? "⌘" : "Ctrl", g4 = p4 ? "⌥" : "Alt";
function ile(t) {
  return t.split(",")[0].split("").map((e) => {
    const n = e.replace(/\$/g, h4).replace(/\?/g, g4).replace(/!/g, "⇧");
    return n[0].toUpperCase() + n.slice(1);
  });
}
function kc(t) {
  return "— " + t.split(",")[0].split("").map((e) => {
    const n = e.replace(/\$/g, h4).replace(/\?/g, g4).replace(/!/g, "⇧");
    return n[0].toUpperCase() + n.slice(1);
  }).join(" ");
}
function A1({ children: t }) {
  return /* @__PURE__ */ E.jsx("kbd", { className: "tlui-kbd", children: ile(t).map((e, n) => /* @__PURE__ */ E.jsx("span", { children: e }, n)) });
}
const At = k.forwardRef(function({
  label: e,
  icon: n,
  invertIcon: r,
  iconLeft: a,
  smallIcon: s,
  kbd: c,
  isChecked: f = !1,
  type: p = "normal",
  children: g,
  spinner: y,
  ...v
}, S) {
  const x = Fn(), _ = e ? x(e) : "";
  return /* @__PURE__ */ E.jsxs(
    "button",
    {
      ref: S,
      draggable: !1,
      type: "button",
      ...v,
      title: v.title ?? _,
      className: $n("tlui-button", `tlui-button__${p}`, v.className),
      children: [
        a && /* @__PURE__ */ E.jsx(Ya, { icon: a, className: "tlui-icon-left", small: !0 }),
        g,
        e && /* @__PURE__ */ E.jsxs("span", { draggable: !1, children: [
          _,
          f && /* @__PURE__ */ E.jsx(Ya, { icon: "check" })
        ] }),
        c && /* @__PURE__ */ E.jsx(A1, { children: c }),
        n && !y && /* @__PURE__ */ E.jsx(Ya, { icon: n, small: !!e || s, invertIcon: r }),
        y && /* @__PURE__ */ E.jsx(rle, {})
      ]
    }
  );
});
function O1({ className: t, children: e }) {
  return /* @__PURE__ */ E.jsx("div", { className: $n("tlui-dialog__header", t), children: e });
}
function D1({ className: t, children: e }) {
  return /* @__PURE__ */ E.jsx(qse, { dir: "ltr", className: $n("tlui-dialog__header__title", t), children: e });
}
function N1() {
  return /* @__PURE__ */ E.jsx("div", { className: "tlui-dialog__header__close", children: /* @__PURE__ */ E.jsx(Zse, { "data-wd": "dialog.close", dir: "ltr", asChild: !0, children: /* @__PURE__ */ E.jsx(At, { "aria-label": "Close", onTouchEnd: (t) => t.target.click(), children: /* @__PURE__ */ E.jsx(Ya, { small: !0, icon: "cross-2" }) }) }) });
}
function lb({
  className: t,
  children: e,
  style: n
}) {
  return /* @__PURE__ */ E.jsx("div", { className: $n("tlui-dialog__body", t), style: n, children: e });
}
function u2({ className: t, children: e }) {
  return /* @__PURE__ */ E.jsx("div", { className: $n("tlui-dialog__footer", t), children: e });
}
const m4 = "DropdownMenu", [ole, Xpe] = Oc(m4, [
  $1
]), Dl = $1(), [ale, v4] = ole(m4), sle = (t) => {
  const { __scopeDropdownMenu: e, children: n, dir: r, open: a, defaultOpen: s, onOpenChange: c, modal: f = !0 } = t, p = Dl(e), g = k.useRef(null), [y = !1, v] = cf({
    prop: a,
    defaultProp: s,
    onChange: c
  });
  return /* @__PURE__ */ k.createElement(ale, {
    scope: e,
    triggerId: Du(),
    triggerRef: g,
    contentId: Du(),
    open: y,
    onOpenChange: v,
    onOpenToggle: k.useCallback(
      () => v(
        (S) => !S
      ),
      [
        v
      ]
    ),
    modal: f
  }, /* @__PURE__ */ k.createElement(Vz, qe({}, p, {
    open: y,
    onOpenChange: v,
    dir: r,
    modal: f
  }), n));
}, lle = "DropdownMenuTrigger", cle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, disabled: r = !1, ...a } = t, s = v4(lle, n), c = Dl(n);
  return /* @__PURE__ */ k.createElement(Yz, qe({
    asChild: !0
  }, c), /* @__PURE__ */ k.createElement(pr.button, qe({
    type: "button",
    id: s.triggerId,
    "aria-haspopup": "menu",
    "aria-expanded": s.open,
    "aria-controls": s.open ? s.contentId : void 0,
    "data-state": s.open ? "open" : "closed",
    "data-disabled": r ? "" : void 0,
    disabled: r
  }, a, {
    ref: S1(e, s.triggerRef),
    onPointerDown: _t(t.onPointerDown, (f) => {
      !r && f.button === 0 && f.ctrlKey === !1 && (s.onOpenToggle(), s.open || f.preventDefault());
    }),
    onKeyDown: _t(t.onKeyDown, (f) => {
      r || ([
        "Enter",
        " "
      ].includes(f.key) && s.onOpenToggle(), f.key === "ArrowDown" && s.onOpenChange(!0), [
        "Enter",
        " ",
        "ArrowDown"
      ].includes(f.key) && f.preventDefault());
    })
  })));
}), ule = (t) => {
  const { __scopeDropdownMenu: e, ...n } = t, r = Dl(e);
  return /* @__PURE__ */ k.createElement(Kz, qe({}, r, n));
}, dle = "DropdownMenuContent", fle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, a = v4(dle, n), s = Dl(n), c = k.useRef(!1);
  return /* @__PURE__ */ k.createElement(Wz, qe({
    id: a.contentId,
    "aria-labelledby": a.triggerId
  }, s, r, {
    ref: e,
    onCloseAutoFocus: _t(t.onCloseAutoFocus, (f) => {
      var p;
      c.current || (p = a.triggerRef.current) === null || p === void 0 || p.focus(), c.current = !1, f.preventDefault();
    }),
    onInteractOutside: _t(t.onInteractOutside, (f) => {
      const p = f.detail.originalEvent, g = p.button === 0 && p.ctrlKey === !0, y = p.button === 2 || g;
      (!a.modal || y) && (c.current = !0);
    }),
    style: {
      ...t.style,
      "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }));
}), ple = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, a = Dl(n);
  return /* @__PURE__ */ k.createElement(Gz, qe({}, a, r, {
    ref: e
  }));
}), hle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, a = Dl(n);
  return /* @__PURE__ */ k.createElement(Xz, qe({}, a, r, {
    ref: e
  }));
}), gle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, a = Dl(n);
  return /* @__PURE__ */ k.createElement(qz, qe({}, a, r, {
    ref: e
  }));
}), mle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, a = Dl(n);
  return /* @__PURE__ */ k.createElement(Sse, qe({}, a, r, {
    ref: e
  }));
}), vle = (t) => {
  const { __scopeDropdownMenu: e, children: n, open: r, onOpenChange: a, defaultOpen: s } = t, c = Dl(e), [f = !1, p] = cf({
    prop: r,
    defaultProp: s,
    onChange: a
  });
  return /* @__PURE__ */ k.createElement(Qz, qe({}, c, {
    open: f,
    onOpenChange: p
  }), n);
}, yle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, a = Dl(n);
  return /* @__PURE__ */ k.createElement(Zz, qe({}, a, r, {
    ref: e
  }));
}), ble = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, a = Dl(n);
  return /* @__PURE__ */ k.createElement(Jz, qe({}, a, r, {
    ref: e,
    style: {
      ...t.style,
      "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
      "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
      "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }));
}), y4 = sle, cb = cle, d2 = ule, b4 = fle, Sle = ple, jg = hle, S4 = gle, wle = mle, xle = vle, Ele = yle, Cle = ble;
function tf({
  id: t,
  open: e,
  children: n,
  modal: r = !1
}) {
  const a = pm(t);
  return /* @__PURE__ */ E.jsx(y4, { open: e, dir: "ltr", modal: r, onOpenChange: a, children: n });
}
function Rb({ children: t, "data-wd": e }) {
  return /* @__PURE__ */ E.jsx(cb, { dir: "ltr", "data-wd": e, asChild: !0, children: t });
}
function nf({
  side: t = "bottom",
  align: e = "start",
  sideOffset: n = 8,
  alignOffset: r = 8,
  children: a
}) {
  const s = ga();
  return /* @__PURE__ */ E.jsx(d2, { dir: "ltr", container: s, children: /* @__PURE__ */ E.jsx(
    b4,
    {
      className: "tlui-menu",
      align: e,
      sideOffset: n,
      side: t,
      alignOffset: r,
      collisionPadding: 4,
      children: a
    }
  ) });
}
function f2({ id: t, children: e, open: n }) {
  const r = pm(t);
  return /* @__PURE__ */ E.jsx(xle, { open: n, onOpenChange: r, children: e });
}
function p2({
  label: t,
  "data-wd": e,
  "data-direction": n
}) {
  return /* @__PURE__ */ E.jsx(Ele, { dir: "ltr", "data-direction": n, "data-wd": e, asChild: !0, children: /* @__PURE__ */ E.jsx(
    At,
    {
      className: "tlui-menu__button tlui-menu__submenu__trigger",
      label: t,
      icon: "chevron-right"
    }
  ) });
}
function h2({
  alignOffset: t = 0,
  sideOffset: e = 5,
  children: n
}) {
  const r = ga();
  return /* @__PURE__ */ E.jsx(d2, { container: r, dir: "ltr", children: /* @__PURE__ */ E.jsx(
    Cle,
    {
      className: "tlui-menu tlui-menu__submenu__content",
      alignOffset: t,
      sideOffset: e,
      collisionPadding: 4,
      children: n
    }
  ) });
}
function Dp({
  children: t,
  size: e = "medium"
}) {
  return /* @__PURE__ */ E.jsx(Sle, { dir: "ltr", className: "tlui-menu__group", "data-size": e, children: t });
}
function Vo({ noClose: t, ...e }) {
  return /* @__PURE__ */ E.jsx(
    jg,
    {
      dir: "ltr",
      asChild: !0,
      onClick: t || e.isChecked !== void 0 ? Gn : void 0,
      children: /* @__PURE__ */ E.jsx(At, { className: "tlui-menu__button", ...e })
    }
  );
}
function _le({ children: t, onSelect: e, ...n }) {
  return /* @__PURE__ */ E.jsxs(
    S4,
    {
      dir: "ltr",
      className: "tlui-button tlui-menu__button tlui-menu__checkbox-item",
      onSelect: (r) => {
        e?.(r), Gn(r);
      },
      ...n,
      children: [
        /* @__PURE__ */ E.jsx(
          "div",
          {
            className: "tlui-menu__checkbox-item__check",
            style: {
              transformOrigin: "75% center",
              transform: `scale(${n.checked ? 1 : 0.5})`,
              opacity: n.checked ? 1 : 0.5
            },
            children: /* @__PURE__ */ E.jsx(Ya, { small: !0, icon: n.checked ? "check" : "checkbox-empty" })
          }
        ),
        t
      ]
    }
  );
}
function Tle({ children: t, onSelect: e, ...n }) {
  return /* @__PURE__ */ E.jsxs(
    S4,
    {
      dir: "ltr",
      className: "tlui-button tlui-menu__button tlui-menu__checkbox-item",
      onSelect: (r) => {
        e?.(r), Gn(r);
      },
      ...n,
      children: [
        /* @__PURE__ */ E.jsx(wle, { dir: "ltr", className: "tlui-menu__checkbox-item__check", children: /* @__PURE__ */ E.jsx(Ya, { icon: "check" }) }),
        t
      ]
    }
  );
}
function kle(t) {
  const {
    items: e,
    title: n,
    styleType: r,
    value: a = null,
    onValueChange: s,
    columns: c = e.length < 4 ? 2 : 4
  } = t, f = Ge(), p = Fn(), g = k.useRef(!1), {
    handleButtonClick: y,
    handleButtonPointerDown: v,
    handleButtonPointerEnter: S,
    handleButtonPointerUp: x
  } = k.useMemo(() => {
    const _ = () => {
      g.current = !1, window.removeEventListener("pointerup", _);
    };
    return {
      handleButtonClick: (j) => {
        const { id: L } = j.currentTarget.dataset;
        a !== L && (f.mark("point picker item"), s(e.find((z) => z.id === L), !1));
      },
      handleButtonPointerDown: (j) => {
        const { id: L } = j.currentTarget.dataset;
        f.mark("point picker item"), s(e.find((z) => z.id === L), !0), g.current = !0, window.addEventListener("pointerup", _);
      },
      handleButtonPointerEnter: (j) => {
        if (!g.current)
          return;
        const { id: L } = j.currentTarget.dataset;
        s(e.find((z) => z.id === L), !0);
      },
      handleButtonPointerUp: (j) => {
        const { id: L } = j.currentTarget.dataset;
        s(e.find((z) => z.id === L), !1);
      }
    };
  }, [f, a, s, e]);
  return /* @__PURE__ */ E.jsx(
    "div",
    {
      className: $n("tlui-button-grid", {
        "tlui-button-grid__two": c === 2,
        "tlui-button-grid__three": c === 3,
        "tlui-button-grid__four": c === 4
      }),
      children: e.map((_) => /* @__PURE__ */ E.jsx(
        At,
        {
          "data-id": _.id,
          "data-wd": `${t["data-wd"]}.${_.id}`,
          "aria-label": _.id,
          "data-state": a === _.id ? "hinted" : void 0,
          title: n + " — " + p(`${r}-style.${_.id}`),
          className: $n("tlui-button-grid__button"),
          style: _.type === "color" ? { color: `var(--palette-${_.id})` } : void 0,
          onPointerEnter: S,
          onPointerDown: v,
          onPointerUp: x,
          onClick: y,
          icon: _.icon
        },
        _.id
      ))
    }
  );
}
const Hg = k.memo(kle), g2 = k.forwardRef(function({
  className: e,
  label: n,
  icon: r,
  iconLeft: a,
  autoselect: s = !1,
  autofocus: c = !1,
  defaultValue: f,
  placeholder: p,
  onComplete: g,
  onValueChange: y,
  onCancel: v,
  shouldManuallyMaintainScrollPositionWhenFocused: S = !1,
  children: x
}, _) {
  const T = k.useRef(null);
  k.useImperativeHandle(_, () => T.current);
  const I = Fn(), D = k.useRef(f ?? ""), N = k.useRef(f ?? ""), [j, L] = k.useState(!1), z = k.useCallback(
    (se) => {
      L(!0);
      const ue = se.currentTarget;
      N.current = ue.value, requestAnimationFrame(() => {
        s && ue.select();
      });
    },
    [s]
  ), F = k.useCallback(
    (se) => {
      const ue = se.currentTarget.value;
      N.current = ue, y?.(ue);
    },
    [y]
  ), K = k.useCallback(
    (se) => {
      switch (se.key) {
        case "Enter": {
          se.currentTarget.blur(), se.stopPropagation(), g?.(se.currentTarget.value);
          break;
        }
        case "Escape": {
          se.currentTarget.value = D.current, se.currentTarget.blur(), se.stopPropagation(), v?.(se.currentTarget.value);
          break;
        }
      }
    },
    [g, v]
  ), X = k.useCallback(() => L(!1), []);
  return k.useEffect(() => {
    const se = window.visualViewport;
    if (j && S && se) {
      const ue = () => {
        T.current?.scrollIntoView({ block: "center" });
      };
      return se.addEventListener("resize", ue), se.addEventListener("scroll", ue), requestAnimationFrame(() => {
        T.current?.scrollIntoView({ block: "center" });
      }), () => {
        se.removeEventListener("resize", ue), se.removeEventListener("scroll", ue);
      };
    }
  }, [j, S]), /* @__PURE__ */ E.jsxs("div", { draggable: !1, className: "tlui-input__wrapper", children: [
    x,
    n && /* @__PURE__ */ E.jsx("label", { children: I(n) }),
    a && /* @__PURE__ */ E.jsx(Ya, { icon: a, className: "tlui-icon-left", small: !0 }),
    /* @__PURE__ */ E.jsx(
      "input",
      {
        ref: T,
        className: $n("tlui-input", e),
        type: "text",
        defaultValue: f,
        onKeyUp: K,
        onChange: F,
        onFocus: z,
        onBlur: X,
        autoFocus: c,
        placeholder: p
      }
    ),
    r && /* @__PURE__ */ E.jsx(Ya, { icon: r, small: !!n })
  ] });
});
function w4(t, [e, n]) {
  return Math.min(n, Math.max(e, t));
}
function Ple(t) {
  const e = k.useRef({
    value: t,
    previous: t
  });
  return k.useMemo(() => (e.current.value !== t && (e.current.previous = e.current.value, e.current.value = t), e.current.previous), [
    t
  ]);
}
const x4 = [
  "PageUp",
  "PageDown"
], E4 = [
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight"
], C4 = {
  "from-left": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowLeft"
  ],
  "from-right": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowRight"
  ],
  "from-bottom": [
    "Home",
    "PageDown",
    "ArrowDown",
    "ArrowLeft"
  ],
  "from-top": [
    "Home",
    "PageDown",
    "ArrowUp",
    "ArrowLeft"
  ]
}, $b = "Slider", [IP, Ile, Rle] = w1($b), [_4, qpe] = Oc($b, [
  Rle
]), [$le, L1] = _4($b), Mle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { name: n, min: r = 0, max: a = 100, step: s = 1, orientation: c = "horizontal", disabled: f = !1, minStepsBetweenThumbs: p = 0, defaultValue: g = [
    r
  ], value: y, onValueChange: v = () => {
  }, onValueCommit: S = () => {
  }, inverted: x = !1, ..._ } = t, [T, I] = k.useState(null), D = Rr(
    e,
    (Y) => I(Y)
  ), N = k.useRef(/* @__PURE__ */ new Set()), j = k.useRef(0), L = c === "horizontal", z = T ? !!T.closest("form") : !0, F = L ? Ale : Ole, [K = [], X] = cf({
    prop: y,
    defaultProp: g,
    onChange: (Y) => {
      var le;
      (le = [
        ...N.current
      ][j.current]) === null || le === void 0 || le.focus(), v(Y);
    }
  }), se = k.useRef(K);
  function ue(Y) {
    const le = Hle(K, Y);
    ve(Y, le);
  }
  function pe(Y) {
    ve(Y, j.current);
  }
  function Pe() {
    const Y = se.current[j.current];
    K[j.current] !== Y && S(K);
  }
  function ve(Y, le, { commit: Re } = {
    commit: !1
  }) {
    const he = Wle(s), te = Gle(Math.round((Y - r) / s) * s + r, he), de = w4(te, [
      r,
      a
    ]);
    X((W = []) => {
      const fe = Ble(W, de, le);
      if (Kle(fe, p * s)) {
        j.current = fe.indexOf(de);
        const ce = String(fe) !== String(W);
        return ce && Re && S(fe), ce ? fe : W;
      } else
        return W;
    });
  }
  return /* @__PURE__ */ k.createElement($le, {
    scope: t.__scopeSlider,
    disabled: f,
    min: r,
    max: a,
    valueIndexToChangeRef: j,
    thumbs: N.current,
    values: K,
    orientation: c
  }, /* @__PURE__ */ k.createElement(IP.Provider, {
    scope: t.__scopeSlider
  }, /* @__PURE__ */ k.createElement(IP.Slot, {
    scope: t.__scopeSlider
  }, /* @__PURE__ */ k.createElement(F, qe({
    "aria-disabled": f,
    "data-disabled": f ? "" : void 0
  }, _, {
    ref: D,
    onPointerDown: _t(_.onPointerDown, () => {
      f || (se.current = K);
    }),
    min: r,
    max: a,
    inverted: x,
    onSlideStart: f ? void 0 : ue,
    onSlideMove: f ? void 0 : pe,
    onSlideEnd: f ? void 0 : Pe,
    onHomeKeyDown: () => !f && ve(r, 0, {
      commit: !0
    }),
    onEndKeyDown: () => !f && ve(a, K.length - 1, {
      commit: !0
    }),
    onStepKeyDown: ({ event: Y, direction: le }) => {
      if (!f) {
        const te = x4.includes(Y.key) || Y.shiftKey && E4.includes(Y.key) ? 10 : 1, de = j.current, W = K[de], fe = s * te * le;
        ve(W + fe, de, {
          commit: !0
        });
      }
    }
  })))), z && K.map(
    (Y, le) => /* @__PURE__ */ k.createElement(Ule, {
      key: le,
      name: n ? n + (K.length > 1 ? "[]" : "") : void 0,
      value: Y
    })
  ));
}), [T4, k4] = _4($b, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), Ale = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { min: n, max: r, dir: a, inverted: s, onSlideStart: c, onSlideMove: f, onSlideEnd: p, onStepKeyDown: g, ...y } = t, [v, S] = k.useState(null), x = Rr(
    e,
    (j) => S(j)
  ), _ = k.useRef(), T = qI(a), I = T === "ltr", D = I && !s || !I && s;
  function N(j) {
    const L = _.current || v.getBoundingClientRect(), z = [
      0,
      L.width
    ], K = m2(z, D ? [
      n,
      r
    ] : [
      r,
      n
    ]);
    return _.current = L, K(j - L.left);
  }
  return /* @__PURE__ */ k.createElement(T4, {
    scope: t.__scopeSlider,
    startEdge: D ? "left" : "right",
    endEdge: D ? "right" : "left",
    direction: D ? 1 : -1,
    size: "width"
  }, /* @__PURE__ */ k.createElement(P4, qe({
    dir: T,
    "data-orientation": "horizontal"
  }, y, {
    ref: x,
    style: {
      ...y.style,
      ["--radix-slider-thumb-transform"]: "translateX(-50%)"
    },
    onSlideStart: (j) => {
      const L = N(j.clientX);
      c?.(L);
    },
    onSlideMove: (j) => {
      const L = N(j.clientX);
      f?.(L);
    },
    onSlideEnd: () => {
      _.current = void 0, p?.();
    },
    onStepKeyDown: (j) => {
      const z = C4[D ? "from-left" : "from-right"].includes(j.key);
      g?.({
        event: j,
        direction: z ? -1 : 1
      });
    }
  })));
}), Ole = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { min: n, max: r, inverted: a, onSlideStart: s, onSlideMove: c, onSlideEnd: f, onStepKeyDown: p, ...g } = t, y = k.useRef(null), v = Rr(e, y), S = k.useRef(), x = !a;
  function _(T) {
    const I = S.current || y.current.getBoundingClientRect(), D = [
      0,
      I.height
    ], j = m2(D, x ? [
      r,
      n
    ] : [
      n,
      r
    ]);
    return S.current = I, j(T - I.top);
  }
  return /* @__PURE__ */ k.createElement(T4, {
    scope: t.__scopeSlider,
    startEdge: x ? "bottom" : "top",
    endEdge: x ? "top" : "bottom",
    size: "height",
    direction: x ? 1 : -1
  }, /* @__PURE__ */ k.createElement(P4, qe({
    "data-orientation": "vertical"
  }, g, {
    ref: v,
    style: {
      ...g.style,
      ["--radix-slider-thumb-transform"]: "translateY(50%)"
    },
    onSlideStart: (T) => {
      const I = _(T.clientY);
      s?.(I);
    },
    onSlideMove: (T) => {
      const I = _(T.clientY);
      c?.(I);
    },
    onSlideEnd: () => {
      S.current = void 0, f?.();
    },
    onStepKeyDown: (T) => {
      const D = C4[x ? "from-bottom" : "from-top"].includes(T.key);
      p?.({
        event: T,
        direction: D ? -1 : 1
      });
    }
  })));
}), P4 = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeSlider: n, onSlideStart: r, onSlideMove: a, onSlideEnd: s, onHomeKeyDown: c, onEndKeyDown: f, onStepKeyDown: p, ...g } = t, y = L1($b, n);
  return /* @__PURE__ */ k.createElement(pr.span, qe({}, g, {
    ref: e,
    onKeyDown: _t(t.onKeyDown, (v) => {
      v.key === "Home" ? (c(v), v.preventDefault()) : v.key === "End" ? (f(v), v.preventDefault()) : x4.concat(E4).includes(v.key) && (p(v), v.preventDefault());
    }),
    onPointerDown: _t(t.onPointerDown, (v) => {
      const S = v.target;
      S.setPointerCapture(v.pointerId), v.preventDefault(), y.thumbs.has(S) ? S.focus() : r(v);
    }),
    onPointerMove: _t(t.onPointerMove, (v) => {
      v.target.hasPointerCapture(v.pointerId) && a(v);
    }),
    onPointerUp: _t(t.onPointerUp, (v) => {
      const S = v.target;
      S.hasPointerCapture(v.pointerId) && (S.releasePointerCapture(v.pointerId), s(v));
    })
  }));
}), Dle = "SliderTrack", Nle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeSlider: n, ...r } = t, a = L1(Dle, n);
  return /* @__PURE__ */ k.createElement(pr.span, qe({
    "data-disabled": a.disabled ? "" : void 0,
    "data-orientation": a.orientation
  }, r, {
    ref: e
  }));
}), CN = "SliderRange", Lle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeSlider: n, ...r } = t, a = L1(CN, n), s = k4(CN, n), c = k.useRef(null), f = Rr(e, c), p = a.values.length, g = a.values.map(
    (S) => I4(S, a.min, a.max)
  ), y = p > 1 ? Math.min(...g) : 0, v = 100 - Math.max(...g);
  return /* @__PURE__ */ k.createElement(pr.span, qe({
    "data-orientation": a.orientation,
    "data-disabled": a.disabled ? "" : void 0
  }, r, {
    ref: f,
    style: {
      ...t.style,
      [s.startEdge]: y + "%",
      [s.endEdge]: v + "%"
    }
  }));
}), _N = "SliderThumb", jle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = Ile(t.__scopeSlider), [r, a] = k.useState(null), s = Rr(
    e,
    (f) => a(f)
  ), c = k.useMemo(
    () => r ? n().findIndex(
      (f) => f.ref.current === r
    ) : -1,
    [
      n,
      r
    ]
  );
  return /* @__PURE__ */ k.createElement(zle, qe({}, t, {
    ref: s,
    index: c
  }));
}), zle = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopeSlider: n, index: r, ...a } = t, s = L1(_N, n), c = k4(_N, n), [f, p] = k.useState(null), g = Rr(
    e,
    (I) => p(I)
  ), y = fz(f), v = s.values[r], S = v === void 0 ? 0 : I4(v, s.min, s.max), x = Fle(r, s.values.length), _ = y?.[c.size], T = _ ? Vle(_, S, c.direction) : 0;
  return k.useEffect(() => {
    if (f)
      return s.thumbs.add(f), () => {
        s.thumbs.delete(f);
      };
  }, [
    f,
    s.thumbs
  ]), /* @__PURE__ */ k.createElement("span", {
    style: {
      transform: "var(--radix-slider-thumb-transform)",
      position: "absolute",
      [c.startEdge]: `calc(${S}% + ${T}px)`
    }
  }, /* @__PURE__ */ k.createElement(IP.ItemSlot, {
    scope: t.__scopeSlider
  }, /* @__PURE__ */ k.createElement(pr.span, qe({
    role: "slider",
    "aria-label": t["aria-label"] || x,
    "aria-valuemin": s.min,
    "aria-valuenow": v,
    "aria-valuemax": s.max,
    "aria-orientation": s.orientation,
    "data-orientation": s.orientation,
    "data-disabled": s.disabled ? "" : void 0,
    tabIndex: s.disabled ? void 0 : 0
  }, a, {
    ref: g,
    style: v === void 0 ? {
      display: "none"
    } : t.style,
    onFocus: _t(t.onFocus, () => {
      s.valueIndexToChangeRef.current = r;
    })
  }))));
}), Ule = (t) => {
  const { value: e, ...n } = t, r = k.useRef(null), a = Ple(e);
  return k.useEffect(() => {
    const s = r.current, c = window.HTMLInputElement.prototype, p = Object.getOwnPropertyDescriptor(c, "value").set;
    if (a !== e && p) {
      const g = new Event("input", {
        bubbles: !0
      });
      p.call(s, e), s.dispatchEvent(g);
    }
  }, [
    a,
    e
  ]), /* @__PURE__ */ k.createElement("input", qe({
    style: {
      display: "none"
    }
  }, n, {
    ref: r,
    defaultValue: e
  }));
};
function Ble(t = [], e, n) {
  const r = [
    ...t
  ];
  return r[n] = e, r.sort(
    (a, s) => a - s
  );
}
function I4(t, e, n) {
  const s = 100 / (n - e) * (t - e);
  return w4(s, [
    0,
    100
  ]);
}
function Fle(t, e) {
  return e > 2 ? `Value ${t + 1} of ${e}` : e === 2 ? [
    "Minimum",
    "Maximum"
  ][t] : void 0;
}
function Hle(t, e) {
  if (t.length === 1)
    return 0;
  const n = t.map(
    (a) => Math.abs(a - e)
  ), r = Math.min(...n);
  return n.indexOf(r);
}
function Vle(t, e, n) {
  const r = t / 2, s = m2([
    0,
    50
  ], [
    0,
    r
  ]);
  return (r - s(e) * n) * n;
}
function Yle(t) {
  return t.slice(0, -1).map(
    (e, n) => t[n + 1] - e
  );
}
function Kle(t, e) {
  if (e > 0) {
    const n = Yle(t);
    return Math.min(...n) >= e;
  }
  return !0;
}
function m2(t, e) {
  return (n) => {
    if (t[0] === t[1] || e[0] === e[1])
      return e[0];
    const r = (e[1] - e[0]) / (t[1] - t[0]);
    return e[0] + r * (n - t[0]);
  };
}
function Wle(t) {
  return (String(t).split(".")[1] || "").length;
}
function Gle(t, e) {
  const n = Math.pow(10, e);
  return Math.round(t * n) / n;
}
const Xle = Mle, qle = Nle, Qle = Lle, Zle = jle;
function Jle(t) {
  const { title: e, steps: n, value: r, label: a, onValueChange: s } = t, c = Ge(), f = Fn(), p = k.useCallback(
    (v) => {
      s(v[0], !0);
    },
    [s]
  ), g = k.useCallback(() => {
    c.mark("click slider");
  }, [c]), y = k.useCallback(() => {
    r && s(r, !1);
  }, [r, s]);
  return /* @__PURE__ */ E.jsx("div", { className: "tlui-slider__container", children: /* @__PURE__ */ E.jsxs(
    Xle,
    {
      "data-wd": t["data-wd"],
      className: "tlui-slider",
      "area-label": "Opacity",
      dir: "ltr",
      min: 0,
      max: n,
      step: 1,
      value: r ? [r] : void 0,
      onPointerDown: g,
      onValueChange: p,
      onPointerUp: y,
      title: e + " — " + f(a),
      children: [
        /* @__PURE__ */ E.jsx(qle, { className: "tlui-slider__track", dir: "ltr", children: r !== null && /* @__PURE__ */ E.jsx(Qle, { className: "tlui-slider__range", dir: "ltr" }) }),
        r !== null && /* @__PURE__ */ E.jsx(Zle, { className: "tlui-slider__thumb", dir: "ltr" })
      ]
    }
  ) });
}
const TN = new RegExp(
  /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:[/?#]\S*)?$/i
);
function Ck(t) {
  return TN.test(t) ? !0 : TN.test("https://" + t) ? "needs protocol" : !1;
}
const ece = dn(function({ onClose: e }) {
  const n = Ge(), r = Fn(), a = n.onlySelectedShape, [s, c] = k.useState(Ck(a?.props.url)), f = k.useRef(a?.props.url), p = k.useRef(a?.props.url), g = k.useCallback((_) => {
    const T = Ck(_.trim());
    c((I) => I === T ? I : T), T && (p.current = _);
  }, []), y = k.useCallback(() => {
    n.setProp("url", "", !1), e();
  }, [n, e]), v = k.useCallback(
    (_) => {
      _ = _.trim();
      const T = Ck(_), I = n.selectedShapes[0];
      if (I) {
        const D = I.props.url, N = T ? T === "needs protocol" ? "https://" + _ : _ : I.type === "bookmark" ? f.current : "";
        D !== void 0 && D !== N && n.setProp("url", N, !1);
      }
      e();
    },
    [n, e]
  ), S = k.useCallback(() => {
    e();
  }, [e]);
  if (!a)
    return e(), null;
  const x = f.current && !s;
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsxs(O1, { children: [
      /* @__PURE__ */ E.jsx(D1, { children: r("edit-link-dialog.title") }),
      /* @__PURE__ */ E.jsx(N1, {})
    ] }),
    /* @__PURE__ */ E.jsx(lb, { children: /* @__PURE__ */ E.jsxs("div", { className: "tlui-edit-link-dialog", children: [
      /* @__PURE__ */ E.jsx(
        g2,
        {
          className: "tlui-edit-link-dialog__input",
          label: "edit-link-dialog.url",
          defaultValue: s ? s === "needs protocol" ? "https://" + a.props.url : a.props.url : "https://",
          autofocus: !0,
          onValueChange: g,
          onComplete: v,
          onCancel: S
        }
      ),
      /* @__PURE__ */ E.jsx("div", { children: r(s ? "edit-link-dialog.detail" : "edit-link-dialog.invalid-url") })
    ] }) }),
    /* @__PURE__ */ E.jsxs(u2, { className: "tlui-dialog__footer__actions", children: [
      /* @__PURE__ */ E.jsx(At, { onClick: S, onTouchEnd: S, children: r("edit-link-dialog.cancel") }),
      x ? /* @__PURE__ */ E.jsx(At, { type: "danger", onTouchEnd: y, onClick: y, children: r("edit-link-dialog.clear") }) : /* @__PURE__ */ E.jsx(
        At,
        {
          type: "primary",
          disabled: !s,
          onTouchEnd: () => v(p.current),
          onClick: () => v(p.current),
          children: r("edit-link-dialog.save")
        }
      )
    ] })
  ] });
});
var v2 = { exports: {} };
v2.exports;
(function(t) {
  var e = function() {
    var n = String.fromCharCode, r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", s = {};
    function c(p, g) {
      if (!s[p]) {
        s[p] = {};
        for (var y = 0; y < p.length; y++)
          s[p][p.charAt(y)] = y;
      }
      return s[p][g];
    }
    var f = {
      compressToBase64: function(p) {
        if (p == null)
          return "";
        var g = f._compress(p, 6, function(y) {
          return r.charAt(y);
        });
        switch (g.length % 4) {
          default:
          case 0:
            return g;
          case 1:
            return g + "===";
          case 2:
            return g + "==";
          case 3:
            return g + "=";
        }
      },
      decompressFromBase64: function(p) {
        return p == null ? "" : p == "" ? null : f._decompress(p.length, 32, function(g) {
          return c(r, p.charAt(g));
        });
      },
      compressToUTF16: function(p) {
        return p == null ? "" : f._compress(p, 15, function(g) {
          return n(g + 32);
        }) + " ";
      },
      decompressFromUTF16: function(p) {
        return p == null ? "" : p == "" ? null : f._decompress(p.length, 16384, function(g) {
          return p.charCodeAt(g) - 32;
        });
      },
      //compress into uint8array (UCS-2 big endian format)
      compressToUint8Array: function(p) {
        for (var g = f.compress(p), y = new Uint8Array(g.length * 2), v = 0, S = g.length; v < S; v++) {
          var x = g.charCodeAt(v);
          y[v * 2] = x >>> 8, y[v * 2 + 1] = x % 256;
        }
        return y;
      },
      //decompress from uint8array (UCS-2 big endian format)
      decompressFromUint8Array: function(p) {
        if (p == null)
          return f.decompress(p);
        for (var g = new Array(p.length / 2), y = 0, v = g.length; y < v; y++)
          g[y] = p[y * 2] * 256 + p[y * 2 + 1];
        var S = [];
        return g.forEach(function(x) {
          S.push(n(x));
        }), f.decompress(S.join(""));
      },
      //compress into a string that is already URI encoded
      compressToEncodedURIComponent: function(p) {
        return p == null ? "" : f._compress(p, 6, function(g) {
          return a.charAt(g);
        });
      },
      //decompress from an output of compressToEncodedURIComponent
      decompressFromEncodedURIComponent: function(p) {
        return p == null ? "" : p == "" ? null : (p = p.replace(/ /g, "+"), f._decompress(p.length, 32, function(g) {
          return c(a, p.charAt(g));
        }));
      },
      compress: function(p) {
        return f._compress(p, 16, function(g) {
          return n(g);
        });
      },
      _compress: function(p, g, y) {
        if (p == null)
          return "";
        var v, S, x = {}, _ = {}, T = "", I = "", D = "", N = 2, j = 3, L = 2, z = [], F = 0, K = 0, X;
        for (X = 0; X < p.length; X += 1)
          if (T = p.charAt(X), Object.prototype.hasOwnProperty.call(x, T) || (x[T] = j++, _[T] = !0), I = D + T, Object.prototype.hasOwnProperty.call(x, I))
            D = I;
          else {
            if (Object.prototype.hasOwnProperty.call(_, D)) {
              if (D.charCodeAt(0) < 256) {
                for (v = 0; v < L; v++)
                  F = F << 1, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++;
                for (S = D.charCodeAt(0), v = 0; v < 8; v++)
                  F = F << 1 | S & 1, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++, S = S >> 1;
              } else {
                for (S = 1, v = 0; v < L; v++)
                  F = F << 1 | S, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++, S = 0;
                for (S = D.charCodeAt(0), v = 0; v < 16; v++)
                  F = F << 1 | S & 1, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++, S = S >> 1;
              }
              N--, N == 0 && (N = Math.pow(2, L), L++), delete _[D];
            } else
              for (S = x[D], v = 0; v < L; v++)
                F = F << 1 | S & 1, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++, S = S >> 1;
            N--, N == 0 && (N = Math.pow(2, L), L++), x[I] = j++, D = String(T);
          }
        if (D !== "") {
          if (Object.prototype.hasOwnProperty.call(_, D)) {
            if (D.charCodeAt(0) < 256) {
              for (v = 0; v < L; v++)
                F = F << 1, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++;
              for (S = D.charCodeAt(0), v = 0; v < 8; v++)
                F = F << 1 | S & 1, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++, S = S >> 1;
            } else {
              for (S = 1, v = 0; v < L; v++)
                F = F << 1 | S, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++, S = 0;
              for (S = D.charCodeAt(0), v = 0; v < 16; v++)
                F = F << 1 | S & 1, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++, S = S >> 1;
            }
            N--, N == 0 && (N = Math.pow(2, L), L++), delete _[D];
          } else
            for (S = x[D], v = 0; v < L; v++)
              F = F << 1 | S & 1, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++, S = S >> 1;
          N--, N == 0 && (N = Math.pow(2, L), L++);
        }
        for (S = 2, v = 0; v < L; v++)
          F = F << 1 | S & 1, K == g - 1 ? (K = 0, z.push(y(F)), F = 0) : K++, S = S >> 1;
        for (; ; )
          if (F = F << 1, K == g - 1) {
            z.push(y(F));
            break;
          } else
            K++;
        return z.join("");
      },
      decompress: function(p) {
        return p == null ? "" : p == "" ? null : f._decompress(p.length, 32768, function(g) {
          return p.charCodeAt(g);
        });
      },
      _decompress: function(p, g, y) {
        var v = [], S = 4, x = 4, _ = 3, T = "", I = [], D, N, j, L, z, F, K, X = { val: y(0), position: g, index: 1 };
        for (D = 0; D < 3; D += 1)
          v[D] = D;
        for (j = 0, z = Math.pow(2, 2), F = 1; F != z; )
          L = X.val & X.position, X.position >>= 1, X.position == 0 && (X.position = g, X.val = y(X.index++)), j |= (L > 0 ? 1 : 0) * F, F <<= 1;
        switch (j) {
          case 0:
            for (j = 0, z = Math.pow(2, 8), F = 1; F != z; )
              L = X.val & X.position, X.position >>= 1, X.position == 0 && (X.position = g, X.val = y(X.index++)), j |= (L > 0 ? 1 : 0) * F, F <<= 1;
            K = n(j);
            break;
          case 1:
            for (j = 0, z = Math.pow(2, 16), F = 1; F != z; )
              L = X.val & X.position, X.position >>= 1, X.position == 0 && (X.position = g, X.val = y(X.index++)), j |= (L > 0 ? 1 : 0) * F, F <<= 1;
            K = n(j);
            break;
          case 2:
            return "";
        }
        for (v[3] = K, N = K, I.push(K); ; ) {
          if (X.index > p)
            return "";
          for (j = 0, z = Math.pow(2, _), F = 1; F != z; )
            L = X.val & X.position, X.position >>= 1, X.position == 0 && (X.position = g, X.val = y(X.index++)), j |= (L > 0 ? 1 : 0) * F, F <<= 1;
          switch (K = j) {
            case 0:
              for (j = 0, z = Math.pow(2, 8), F = 1; F != z; )
                L = X.val & X.position, X.position >>= 1, X.position == 0 && (X.position = g, X.val = y(X.index++)), j |= (L > 0 ? 1 : 0) * F, F <<= 1;
              v[x++] = n(j), K = x - 1, S--;
              break;
            case 1:
              for (j = 0, z = Math.pow(2, 16), F = 1; F != z; )
                L = X.val & X.position, X.position >>= 1, X.position == 0 && (X.position = g, X.val = y(X.index++)), j |= (L > 0 ? 1 : 0) * F, F <<= 1;
              v[x++] = n(j), K = x - 1, S--;
              break;
            case 2:
              return I.join("");
          }
          if (S == 0 && (S = Math.pow(2, _), _++), v[K])
            T = v[K];
          else if (K === x)
            T = N + N.charAt(0);
          else
            return null;
          I.push(T), v[x++] = N + T.charAt(0), S--, N = T, S == 0 && (S = Math.pow(2, _), _++);
        }
      }
    };
    return f;
  }();
  t != null ? t.exports = e : typeof angular < "u" && angular != null && angular.module("LZString", []).factory("LZString", function() {
    return e;
  });
})(v2);
var R4 = v2.exports;
async function _k(t) {
  return new Promise((e, n) => {
    const r = new FileReader();
    r.addEventListener("loadend", () => {
      const a = r.result;
      e(a);
    }), r.addEventListener("error", () => {
      n(r.error);
    }), r.readAsText(t);
  });
}
async function kN(t) {
  return new Promise((e) => {
    t.getAsString((n) => {
      e(n);
    });
  });
}
const tce = ["input", "select", "textarea"];
function Tk(t) {
  const { activeElement: e } = document;
  return t.isMenuOpen || e && (e.getAttribute("contenteditable") || tce.indexOf(e.tagName.toLowerCase()) > -1);
}
function PN(t) {
  const e = document.implementation.createHTMLDocument("");
  return e.documentElement.innerHTML = t, e.body.textContent || e.body.innerText || "";
}
const nce = () => {
  window.navigator.clipboard.writeText("");
}, rce = (t, e) => R4.compressToBase64(
  JSON.stringify({
    type: "application/tldraw",
    kind: e,
    data: t
  })
), $4 = async (t, e, n) => {
  const r = n ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : void 0);
  t.mark("paste"), t.putContent(e, {
    point: r,
    select: !0
  });
}, ice = async (t, e, n) => {
  const r = n ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : t.viewportPageCenter), a = t.getShapeUtilByDef(v1).defaultProps(), { w: s, h: c } = t.textMeasure.measureText({
    ...Yi,
    text: PN(e),
    fontFamily: Wd[a.font],
    fontSize: Bg[a.size],
    width: "fit-content"
  });
  t.mark("paste"), t.createShapes([
    {
      id: no(),
      type: "text",
      x: r.x - s / 2,
      y: r.y - c / 2,
      props: {
        text: PN(e),
        autoSize: !0
      }
    }
  ]);
}, RP = async (t, e, n) => {
  const r = n ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : t.viewportPageCenter);
  try {
    if ((await fetch(e)).headers.get("content-type")?.match(/^image\//)) {
      t.mark("paste"), M4(t, [e]);
      return;
    }
  } catch (s) {
    s.message !== "Failed to fetch" && console.error(s);
  }
  const a = Yd(e);
  a ? (t.mark("paste"), YL(t, a.url, r, a.definition)) : (t.mark("paste"), await yZ(t, e, r));
}, oce = (t, e, n) => {
  const r = n ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : t.viewportPageCenter);
  t.mark("paste"), bZ(t, e, r);
}, M4 = async (t, e, n) => {
  const r = n ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : t.viewportPageCenter), s = (await Promise.all(e.map(async (c) => await (await fetch(c)).blob()))).map(
    (c) => new File([c], "TLdrawFile", {
      type: c.type
    })
  );
  t.mark("paste"), await p1(t, s, r, !1), e.forEach((c) => URL.revokeObjectURL(c));
}, Kx = (t) => {
  const e = t.getContent();
  if (!e) {
    nce();
    return;
  }
  const n = rce(e, "content");
  if (typeof window?.navigator < "u") {
    const r = e.shapes.map((a) => v1.is(a) || wj.is(a) || to.is(a) ? a.props.text : g1.is(a) || tb.is(a) ? a.props.url : null).filter(BG);
    if (navigator.clipboard?.write) {
      const a = new Blob([`<tldraw>${n}</tldraw>`], {
        type: "text/html"
      });
      let s = r.join(" ");
      s === "" && (s = " "), navigator.clipboard.write([
        new ClipboardItem({
          "text/html": a,
          "text/plain": new Blob([s], { type: "text/plain" })
        })
      ]);
    } else
      navigator.clipboard.writeText && navigator.clipboard.writeText(`<tldraw>${n}</tldraw>`);
  }
}, Vg = (t, e, n) => {
  const r = wZ(e);
  if (r)
    for (const a of r)
      RP(t, a, n);
  else
    SZ(e) ? RP(t, e, n) : xZ(e) ? oce(t, e, n) : ice(t, e, n);
};
async function ace(t, e, n) {
  const { elements: r, files: a } = e, s = {
    shapes: [],
    rootShapeIds: [],
    assets: [],
    schema: t.store.schema.serialize()
  }, c = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Map(), p = (Y) => {
    const le = Y / 100;
    return le < 0.2 ? "0.1" : le < 0.4 ? "0.25" : le < 0.6 ? "0.5" : le < 0.8 ? "0.75" : "1";
  }, g = {
    1: "s",
    2: "m",
    3: "l",
    4: "xl"
  }, y = {
    16: "s",
    20: "m",
    28: "l",
    36: "xl"
  };
  function v(Y) {
    const le = y[Y];
    return le ? { size: le, scale: 1 } : Y < 16 ? { size: "s", scale: Y / 16 } : Y > 36 ? { size: "xl", scale: Y / 36 } : { size: "m", scale: 1 };
  }
  const S = {
    1: "draw",
    2: "sans",
    3: "mono"
  }, x = {
    "#ffffff": "grey",
    // Strokes
    "#000000": "black",
    "#343a40": "grey",
    "#495057": "grey",
    "#c92a2a": "red",
    "#a61e4d": "light-red",
    "#862e9c": "violet",
    "#5f3dc4": "light-violet",
    "#364fc7": "blue",
    "#1864ab": "light-blue",
    "#0b7285": "light-green",
    "#087f5b": "light-green",
    "#2b8a3e": "green",
    "#5c940d": "light-green",
    "#e67700": "yellow",
    "#d9480f": "orange",
    // Backgrounds
    "#ced4da": "grey",
    "#868e96": "grey",
    "#fa5252": "light-red",
    "#e64980": "red",
    "#be4bdb": "light-violet",
    "#7950f2": "violet",
    "#4c6ef5": "blue",
    "#228be6": "light-blue",
    "#15aabf": "light-green",
    "#12b886": "green",
    "#40c057": "green",
    "#82c91e": "light-green",
    "#fab005": "yellow",
    "#fd7e14": "orange",
    "#212529": "grey"
  }, _ = {
    solid: "draw",
    dashed: "dashed",
    dotted: "dotted"
  }, T = {
    "cross-hatch": "pattern",
    hachure: "pattern",
    solid: "solid"
  }, I = {
    left: "start",
    center: "middle",
    right: "end"
  }, D = {
    arrow: "arrow",
    dot: "dot",
    triangle: "triangle",
    bar: "pipe"
  };
  function N(Y, le, Re) {
    let he = 0;
    if (Y.points.length > 2) {
      const te = new O(le[0], le[1]), de = new O(Re[0], Re[1]), W = new O(Y.points[1][0], Y.points[1][1]), fe = O.Sub(de, te), ce = O.Per(fe), xe = O.Med(de, te), $e = O.Sub(xe, ce), Me = O.Add(xe, ce), re = O.NearestPointOnLineSegment($e, Me, W, !1);
      he = O.Dist(re, xe), O.Clockwise(re, de, xe) && (he *= -1);
    }
    return he;
  }
  const j = (Y) => {
    let le = _[Y.strokeStyle] ?? "draw";
    return le === "draw" && Y.roughness === 0 && (le = "solid"), le;
  }, L = (Y) => Y.backgroundColor === "transparent" ? "none" : T[Y.fillStyle] ?? "solid", { currentPageId: z } = t;
  let F = "a1";
  const K = /* @__PURE__ */ new Map(), X = [], se = /* @__PURE__ */ new Set();
  r.forEach((Y) => {
    if (K.set(Y.id, t.createShapeId()), Y.boundElements !== null)
      for (const le of Y.boundElements)
        le.type === "text" && se.add(le.id);
  });
  for (const Y of r) {
    if (se.has(Y.id))
      continue;
    const le = K.get(Y.id), Re = {
      id: le,
      typeName: "shape",
      parentId: z,
      index: F,
      x: Y.x,
      y: Y.y,
      rotation: 0,
      isLocked: Y.locked
    };
    switch (Y.angle !== 0 && f.set(le, Y.angle), Y.groupIds && Y.groupIds.length > 0 ? c.has(Y.groupIds[0]) ? c.get(Y.groupIds[0])?.push(le) : c.set(Y.groupIds[0], [le]) : X.push(le), Y.type) {
      case "rectangle":
      case "ellipse":
      case "diamond": {
        let he = "", te = "middle";
        if (Y.boundElements !== null) {
          for (const W of Y.boundElements)
            if (W.type === "text") {
              const fe = r.find((ce) => ce.id === W.id);
              fe && (he = fe.text, te = I[fe.textAlign]);
            }
        }
        const de = Y.backgroundColor === "transparent" ? Y.strokeColor : Y.backgroundColor;
        s.shapes.push({
          ...Re,
          type: "geo",
          props: {
            geo: Y.type,
            opacity: p(Y.opacity),
            url: Y.link ?? "",
            w: Y.width,
            h: Y.height,
            size: g[Y.strokeWidth] ?? "draw",
            color: x[de] ?? "black",
            text: he,
            align: te,
            dash: j(Y),
            fill: L(Y)
          }
        });
        break;
      }
      case "freedraw": {
        s.shapes.push({
          ...Re,
          type: "draw",
          props: {
            dash: j(Y),
            size: g[Y.strokeWidth],
            opacity: p(Y.opacity),
            color: x[Y.strokeColor] ?? "black",
            segments: [
              {
                type: "free",
                points: Y.points.map(([he, te, de = 0.5]) => ({
                  x: he,
                  y: te,
                  z: de
                }))
              }
            ]
          }
        });
        break;
      }
      case "line": {
        const he = Y.points[0], te = Y.points[Y.points.length - 1], de = ZL(Y.points.length);
        s.shapes.push({
          ...Re,
          type: "line",
          props: {
            dash: j(Y),
            size: g[Y.strokeWidth],
            opacity: p(Y.opacity),
            color: x[Y.strokeColor] ?? "black",
            spline: Y.roundness ? "cubic" : "line",
            handles: {
              start: {
                id: "start",
                type: "vertex",
                index: de[0],
                x: he[0],
                y: he[1]
              },
              end: {
                id: "end",
                type: "vertex",
                index: de[de.length - 1],
                x: te[0],
                y: te[1]
              },
              ...Object.fromEntries(
                Y.points.slice(1, -1).map(([W, fe], ce) => {
                  const xe = Ii();
                  return [
                    xe,
                    {
                      id: xe,
                      type: "vertex",
                      index: de[ce + 1],
                      x: W,
                      y: fe
                    }
                  ];
                })
              )
            }
          }
        });
        break;
      }
      case "arrow": {
        let he = "";
        if (Y.boundElements !== null) {
          for (const ce of Y.boundElements)
            if (ce.type === "text") {
              const xe = r.find(($e) => $e.id === ce.id);
              xe && (he = xe.text);
            }
        }
        const te = Y.points[0], de = Y.points[Y.points.length - 1], W = K.get(Y.startBinding?.elementId), fe = K.get(Y.endBinding?.elementId);
        s.shapes.push({
          ...Re,
          type: "arrow",
          props: {
            text: he,
            bend: N(Y, te, de),
            dash: j(Y),
            opacity: p(Y.opacity),
            size: g[Y.strokeWidth] ?? "m",
            color: x[Y.strokeColor] ?? "black",
            start: W ? {
              type: "binding",
              boundShapeId: W,
              normalizedAnchor: { x: 0.5, y: 0.5 },
              isExact: !1
            } : {
              type: "point",
              x: te[0],
              y: te[1]
            },
            end: fe ? {
              type: "binding",
              boundShapeId: fe,
              normalizedAnchor: { x: 0.5, y: 0.5 },
              isExact: !1
            } : {
              type: "point",
              x: de[0],
              y: de[1]
            },
            arrowheadEnd: D[Y.endArrowhead] ?? "none",
            arrowheadStart: D[Y.startArrowhead] ?? "none"
          }
        });
        break;
      }
      case "text": {
        const { size: he, scale: te } = v(Y.fontSize);
        s.shapes.push({
          ...Re,
          type: "text",
          props: {
            size: he,
            scale: te,
            font: S[Y.fontFamily] ?? "draw",
            opacity: p(Y.opacity),
            color: x[Y.strokeColor] ?? "black",
            text: Y.text,
            align: I[Y.textAlign]
          }
        });
        break;
      }
      case "image": {
        const he = a[Y.fileId];
        if (!he)
          break;
        const te = sm.createId();
        s.assets.push({
          id: te,
          typeName: "asset",
          type: "image",
          props: {
            w: Y.width,
            h: Y.height,
            name: Y.id ?? "Untitled",
            isAnimated: !1,
            mimeType: he.mimeType,
            src: he.dataURL
          }
        }), s.shapes.push({
          ...Re,
          type: "image",
          props: {
            opacity: p(Y.opacity),
            w: Y.width,
            h: Y.height,
            assetId: te
          }
        });
      }
    }
    F = Ru(F);
  }
  const ue = n ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : void 0);
  t.mark("paste"), t.putContent(s, {
    point: ue,
    select: !1,
    preserveIds: !0
  });
  for (const Y of c.values())
    if (Y.length > 1) {
      t.groupShapes(Y);
      const le = t.getShapeById(Y[0]);
      le?.parentId && Us(le.parentId) && X.push(le.parentId);
    }
  for (const [Y, le] of f)
    t.select(Y), t.rotateShapesBy([Y], le);
  const pe = Gt(X.map((Y) => t.getShapeById(Y))), Pe = ot.Common(pe.map((Y) => t.getPageBounds(Y))), ve = t.viewportPageBounds.center;
  t.updateShapes(
    pe.map((Y) => {
      const le = {
        x: (Y.x ?? 0) - (Pe.x + Pe.w / 2),
        y: (Y.y ?? 0) - (Pe.y + Pe.h / 2)
      };
      return {
        id: Y.id,
        type: Y.type,
        x: ve.x + le.x,
        y: ve.y + le.y
      };
    })
  ), t.setSelectedIds(X);
}
const A4 = async (t, e, n) => {
  const r = e.map((a) => URL.createObjectURL(a));
  M4(t, r, n);
}, y2 = async (t, e, n) => {
  const r = e.match(/<tldraw[^>]*>(.*)<\/tldraw>/)?.[1];
  if (r)
    try {
      const a = JSON.parse(R4.decompressFromBase64(r));
      a.type === "application/tldraw" ? $4(t, a.data, n) : Vg(t, r, n);
    } catch {
      Vg(t, r, n);
    }
  else {
    const s = new DOMParser().parseFromString(e, "text/html").querySelector("body");
    if (s && Array.from(s.children).filter((f) => f.nodeType === 1).length === 1 && s.firstElementChild && s.firstElementChild.tagName === "A" && s.firstElementChild.hasAttribute("href") && s.firstElementChild.getAttribute("href") !== "") {
      const f = s.firstElementChild.getAttribute("href");
      Vg(t, f, n);
    } else
      Vg(t, e, n);
  }
}, O4 = async (t, e, n) => {
  const r = e.trim();
  if (e.match(/<tldraw[^>]*>(.*)<\/tldraw>/)?.[1])
    y2(t, e);
  else if (r)
    try {
      const s = JSON.parse(r);
      s.type === "application/tldraw" ? $4(t, s.data, n) : s.type === "excalidraw/clipboard" ? ace(t, s, n) : Vg(t, r, n);
    } catch {
      Vg(t, r, n);
    }
}, sce = async (t, e, n) => {
  if (!t.isIn("select.editing") && e) {
    const r = Object.values(e.items), a = r.some((p) => p.kind === "file"), s = r.some((p) => p.type === "text/html"), c = [], f = [];
    r.forEach((p) => {
      if (p.kind === "file") {
        const g = p.getAsFile();
        g && c.push(g);
      } else
        p.kind === "string" && f.push(p);
    }), c.length > 0 && A4(t, c, n);
    for (const p of f)
      !a && p.type === "text/html" ? await y2(t, await kN(p), n) : p.type === "text/plain" && (s || await O4(t, await kN(p), n));
  }
}, D4 = async (t, e, n) => {
  if (t.isIn("select.editing"))
    return;
  const r = (f) => f.types.find((p) => p.match(/^image\//)), a = e.some((f) => r(f)), s = e.some((f) => f.types.includes("text/html")), c = e.filter((f) => !!f.types.find((p) => p.match(/^image\//)));
  await Promise.all(
    c.map(async (f) => {
      const p = f.types.find((g) => g !== "text/plain" && g !== "text/html");
      if (p) {
        const g = await f.getType(p);
        g && await A4(t, [g], n);
      }
    })
  );
  for (const f of e)
    if (f.types.includes("text/html")) {
      if (a)
        break;
      const p = await f.getType("text/html");
      await y2(t, await _k(p), n);
    } else if (f.types.includes("text/uri-list")) {
      if (s)
        break;
      const p = await f.getType("text/uri-list");
      await RP(t, await _k(p), n);
    } else if (f.types.includes("text/plain")) {
      if (s)
        break;
      const p = await f.getType("text/plain");
      await O4(t, await _k(p), n);
    }
};
function b2() {
  const t = Ge(), e = k.useCallback(
    function() {
      t.selectedIds.length !== 0 && Kx(t);
    },
    [t]
  ), n = k.useCallback(
    function() {
      t.selectedIds.length !== 0 && (Kx(t), t.deleteShapes());
    },
    [t]
  ), r = k.useCallback(
    async function(s, c) {
      Array.isArray(s) && s[0] instanceof ClipboardItem ? D4(t, s, c) : navigator.clipboard.read().then((f) => {
        r(f, t.inputs.currentPagePoint);
      });
    },
    [t]
  );
  return {
    copy: e,
    cut: n,
    paste: r
  };
}
function lce() {
  const t = Ge();
  k.useEffect(() => {
    const e = () => {
      t.selectedIds.length === 0 || t.editingId !== null || Tk(t) || Kx(t);
    };
    function n() {
      t.selectedIds.length === 0 || t.editingId !== null || Tk(t) || (Kx(t), t.deleteShapes());
    }
    const r = (a) => {
      t.editingId !== null || Tk(t) || (a.clipboardData && !t.inputs.shiftKey ? sce(t, a.clipboardData) : navigator.clipboard.read().then((s) => {
        Array.isArray(s) && s[0] instanceof ClipboardItem && D4(t, s, t.inputs.currentPagePoint);
      }));
    };
    return document.addEventListener("copy", e), document.addEventListener("cut", n), document.addEventListener("paste", r), () => {
      document.removeEventListener("copy", e), document.removeEventListener("cut", n), document.removeEventListener("paste", r);
    };
  }, [t]);
}
const N4 = k.createContext({});
function cce({ children: t }) {
  const [e, n] = k.useState([]), r = k.useCallback((c) => {
    const f = c.id ?? Ii();
    return n((p) => [...p.filter((g) => g.id !== c.id), { ...c, id: f }]), f;
  }, []), a = k.useCallback((c) => (n((f) => f.filter((p) => p.id !== c)), c), []), s = k.useCallback(() => {
    n(() => []);
  }, []);
  return /* @__PURE__ */ E.jsx(N4.Provider, { value: { toasts: e, addToast: r, removeToast: a, clearToasts: s }, children: t });
}
function Uu() {
  const t = k.useContext(N4);
  if (!t)
    throw new Error("useToasts must be used within a ToastsProvider");
  return t;
}
const $P = {
  "action.convert-to-bookmark": "Convert to Bookmark",
  "action.convert-to-embed": "Convert to Embed",
  "action.open-embed-link": "Open link",
  "action.align-bottom": "Align bottom",
  "action.align-center-horizontal": "Align horizontally",
  "action.align-center-vertical": "Align vertically",
  "action.align-center-horizontal.short": "Align H",
  "action.align-center-vertical.short": "Align V",
  "action.align-left": "Align left",
  "action.align-right": "Align right",
  "action.align-top": "Align top",
  "action.back-to-content": "Back to content",
  "action.bring-forward": "Bring forward",
  "action.bring-to-front": "Bring to front",
  "action.copy-as-json.short": "JSON",
  "action.copy-as-json": "Copy as JSON",
  "action.copy-as-png.short": "PNG",
  "action.copy-as-png": "Copy as PNG",
  "action.copy-as-svg.short": "SVG",
  "action.copy-as-svg": "Copy as SVG",
  "action.copy": "Copy",
  "action.cut": "Cut",
  "action.delete": "Delete",
  "action.distribute-horizontal": "Distribute horizontally",
  "action.distribute-vertical": "Distribute vertically",
  "action.distribute-horizontal.short": "Distribute H",
  "action.distribute-vertical.short": "Distribute V",
  "action.duplicate": "Duplicate",
  "action.edit-link": "Edit link",
  "action.exit-pen-mode": "Exit pen mode",
  "action.export-as-json.short": "JSON",
  "action.export-as-json": "Export as JSON",
  "action.export-as-png.short": "PNG",
  "action.export-as-png": "Export as PNG",
  "action.export-as-svg.short": "SVG",
  "action.export-as-svg": "Export as SVG",
  "action.flip-horizontal": "Flip horizontally",
  "action.flip-vertical": "Flip vertically",
  "action.flip-horizontal.short": "Flip H",
  "action.flip-vertical.short": "Flip V",
  "action.group": "Group",
  "action.insert-media": "Upload media",
  "action.new-shared-project": "New shared project",
  "action.nudge-down": "Nudge down",
  "action.nudge-left": "Nudge left",
  "action.nudge-right": "Nudge right",
  "action.nudge-up": "Nudge up",
  "action.open-file": "Open file",
  "action.pack": "Pack",
  "action.paste": "Paste",
  "action.print": "Print",
  "action.redo": "Redo",
  "action.rotate-ccw": "Rotate counterclockwise",
  "action.rotate-cw": "Rotate clockwise",
  "action.save-copy": "Save a copy",
  "action.select-all": "Select all",
  "action.select-none": "Select none",
  "action.send-backward": "Send backward",
  "action.send-to-back": "Send to back",
  "action.share-project": "Share this project",
  "action.stack-horizontal": "Stack horizontally",
  "action.stack-vertical": "Stack vertically",
  "action.stack-horizontal.short": "Stack H",
  "action.stack-vertical.short": "Stack V",
  "action.stretch-horizontal": "Stretch horizontally",
  "action.stretch-vertical": "Stretch vertically",
  "action.stretch-horizontal.short": "Stretch H",
  "action.stretch-vertical.short": "Stretch V",
  "action.toggle-auto-size": "Toggle auto size",
  "action.toggle-dark-mode.menu": "Dark mode",
  "action.toggle-dark-mode": "Toggle dark mode",
  "action.toggle-debug-mode.menu": "Debug mode",
  "action.toggle-debug-mode": "Toggle debug mode",
  "action.toggle-focus-mode.menu": "Focus mode",
  "action.toggle-focus-mode": "Toggle focus mode",
  "action.toggle-grid.menu": "Show grid",
  "action.toggle-grid": "Toggle grid",
  "action.toggle-snap-mode.menu": "Always snap",
  "action.toggle-snap-mode": "Toggle always snap",
  "action.toggle-tool-lock.menu": "Tool lock",
  "action.toggle-tool-lock": "Toggle tool lock",
  "action.toggle-transparent.context-menu": "Transparent",
  "action.toggle-transparent.menu": "Transparent",
  "action.toggle-transparent": "Toggle transparent background",
  "action.undo": "Undo",
  "action.ungroup": "Ungroup",
  "action.zoom-in": "Zoom in",
  "action.zoom-out": "Zoom out",
  "action.zoom-to-100": "Zoom to 100%",
  "action.zoom-to-fit": "Zoom to fit",
  "action.zoom-to-selection": "Zoom to selection",
  "color-style.black": "Black",
  "color-style.blue": "Blue",
  "color-style.green": "Green",
  "color-style.grey": "Grey",
  "color-style.light-blue": "Light blue",
  "color-style.light-green": "Light green",
  "color-style.light-red": "Light red",
  "color-style.light-violet": "Light violet",
  "color-style.orange": "Orange",
  "color-style.red": "Red",
  "color-style.violet": "Violet",
  "color-style.yellow": "Yellow",
  "fill-style.none": "None",
  "fill-style.semi": "Semi",
  "fill-style.solid": "Solid",
  "fill-style.pattern": "Pattern",
  "dash-style.dashed": "Dashed",
  "dash-style.dotted": "Dotted",
  "dash-style.draw": "Draw",
  "dash-style.solid": "Solid",
  "size-style.s": "Small",
  "size-style.m": "Medium",
  "size-style.l": "Large",
  "size-style.xl": "Extra large",
  "opacity-style.0.1": "10%",
  "opacity-style.0.25": "25%",
  "opacity-style.0.5": "50%",
  "opacity-style.0.75": "75%",
  "opacity-style.1": "100%",
  "font-style.draw": "Draw",
  "font-style.sans": "Sans",
  "font-style.serif": "Serif",
  "font-style.mono": "Mono",
  "align-style.start": "Start",
  "align-style.middle": "Middle",
  "align-style.end": "End",
  "align-style.justify": "Justify",
  "geo-style.arrow-down": "Arrow down",
  "geo-style.arrow-left": "Arrow left",
  "geo-style.arrow-right": "Arrow right",
  "geo-style.arrow-up": "Arrow up",
  "geo-style.diamond": "Diamond",
  "geo-style.ellipse": "Ellipse",
  "geo-style.hexagon": "Hexagon",
  "geo-style.octagon": "Octagon",
  "geo-style.oval": "Oval",
  "geo-style.pentagon": "Pentagon",
  "geo-style.rectangle": "Rectangle",
  "geo-style.rhombus-2": "Rhombus 2",
  "geo-style.rhombus": "Rhombus",
  "geo-style.star": "Star",
  "geo-style.trapezoid": "Trapezoid",
  "geo-style.triangle": "Triangle",
  "geo-style.x-box": "X Box",
  "arrowheadStart-style.none": "None",
  "arrowheadStart-style.arrow": "Arrow",
  "arrowheadStart-style.bar": "Bar",
  "arrowheadStart-style.diamond": "Diamond",
  "arrowheadStart-style.dot": "Dot",
  "arrowheadStart-style.inverted": "Inverted",
  "arrowheadStart-style.pipe": "Pipe",
  "arrowheadStart-style.square": "Square",
  "arrowheadStart-style.triangle": "Triangle",
  "arrowheadEnd-style.none": "None",
  "arrowheadEnd-style.arrow": "Arrow",
  "arrowheadEnd-style.bar": "Bar",
  "arrowheadEnd-style.diamond": "Diamond",
  "arrowheadEnd-style.dot": "Dot",
  "arrowheadEnd-style.inverted": "Inverted",
  "arrowheadEnd-style.pipe": "Pipe",
  "arrowheadEnd-style.square": "Square",
  "arrowheadEnd-style.triangle": "Triangle",
  "spline-style.line": "Line",
  "spline-style.cubic": "Cubic",
  "tool.select": "Select",
  "tool.hand": "Hand",
  "tool.draw": "Draw",
  "tool.eraser": "Eraser",
  "tool.arrow-down": "Arrow down",
  "tool.arrow-left": "Arrow left",
  "tool.arrow-right": "Arrow right",
  "tool.arrow-up": "Arrow up",
  "tool.arrow": "Arrow",
  "tool.diamond": "Diamond",
  "tool.ellipse": "Ellipse",
  "tool.hexagon": "Hexagon",
  "tool.line": "Line",
  "tool.octagon": "Octagon",
  "tool.oval": "Oval",
  "tool.pentagon": "Pentagon",
  "tool.rectangle": "Rectangle",
  "tool.rhombus": "Rhombus",
  "tool.star": "Star",
  "tool.trapezoid": "Trapezoid",
  "tool.triangle": "Triangle",
  "tool.x-box": "X box",
  "tool.asset": "Asset",
  "tool.frame": "Frame",
  "tool.note": "Note",
  "tool.embed": "Embed",
  "tool.text": "Text",
  "menu.title": "Menu",
  "menu.copy-as": "Copy as",
  "menu.edit": "Edit",
  "menu.export-as": "Export as",
  "menu.file": "File",
  "menu.language": "Language",
  "menu.preferences": "Preferences",
  "menu.view": "View",
  "context-menu.arrange": "Arrange",
  "context-menu.copy-as": "Copy as",
  "context-menu.export-as": "Export as",
  "context-menu.move-to-page": "Move to page",
  "context-menu.reorder": "Reorder",
  "page-menu.title": "Pages",
  "page-menu.create-new-page": "Create new page",
  "page-menu.edit-pages": "Edit pages",
  "page-menu.max-page-count-reached": "Max pages reached",
  "page-menu.new-page-initial-name": "Page 1",
  "page-menu.page": "Page",
  "page-menu.edit-start": "Edit",
  "page-menu.edit-done": "Done",
  "page-menu.submenu.rename": "Rename",
  "page-menu.submenu.duplicate-page": "Duplicate",
  "page-menu.submenu.go-to-page": "Go to page",
  "page-menu.submenu.title": "Menu",
  "page-menu.submenu.move-down": "Move down",
  "page-menu.submenu.move-up": "Move up",
  "page-menu.submenu.delete": "Delete",
  "share-menu.title": "Share",
  "share-menu.share-project": "Share this project",
  "share-menu.create-project": "New shared project",
  "share-menu.copy-link": "Copy link",
  "share-menu.readonly-link": "Read-only",
  "share-menu.copy-readonly-link": "Copy read-only link",
  "share-menu.offline-note": "Sharing this project will create a hosted live copy at a new URL. You can share the URL with up to thirty other people to view and edit the project together.",
  "share-menu.copy-link-note": "Anyone with the link will be able to view and edit this project.",
  "share-menu.copy-readonly-link-note": "Anyone with the link will be able to view (but not edit) this project.",
  "share-menu.project-too-large": "Sorry, this project can't be shared because it's too large. We're working on it!",
  "people-menu.title": "People",
  "people-menu.change-name": "Change name",
  "people-menu.change-color": "Change color",
  "people-menu.user": "(You)",
  "people-menu.invite": "Invite others",
  "debug-menu.hard-reset": "Hard reset",
  "debug-menu.create-shapes": "Create 100 shapes",
  "help-menu.title": "Help and resources",
  "help-menu.about": "About",
  "help-menu.discord": "Discord",
  "help-menu.github": "GitHub",
  "help-menu.keyboard-shortcuts": "Keyboard shortcuts",
  "help-menu.twitter": "Twitter",
  "links-menu.about": "About",
  "links-menu.discord": "Discord",
  "links-menu.github": "GitHub",
  "links-menu.twitter": "Twitter",
  "actions-menu.title": "Actions",
  "edit-link-dialog.title": "Edit link",
  "edit-link-dialog.invalid-url": "A link must be a valid URL.",
  "edit-link-dialog.detail": "Links will open in a new tab.",
  "edit-link-dialog.url": "URL",
  "edit-link-dialog.clear": "Clear",
  "edit-link-dialog.save": "Continue",
  "edit-link-dialog.cancel": "Cancel",
  "embed-dialog.title": "Create embed",
  "embed-dialog.url-title": "Create %s embed",
  "embed-dialog.url-label": "Paste URL",
  "embed-dialog.back": "Back",
  "embed-dialog.create": "Create",
  "embed-dialog.cancel": "Cancel",
  "embed-dialog.url": "URL",
  "embed-dialog.instruction": "Paste in the site's URL to create the embed.",
  "embed-dialog.invalid-url": "We could not create an embed from that URL.",
  "edit-pages-dialog.title": "Edit pages",
  "edit-pages-dialog.create-new-page": "Create new page",
  "edit-pages-dialog.delete": "Delete",
  "edit-pages-dialog.duplicate-page": "Duplicate",
  "edit-pages-dialog.go-to-page": "Go to page",
  "edit-pages-dialog.max-page-count-reached": "Max pages reached",
  "edit-pages-dialog.more-menu": "Menu",
  "edit-pages-dialog.move-down": "Move down",
  "edit-pages-dialog.move-up": "Move up",
  "edit-pages-dialog.new-page-initial-name": "Page 1",
  "reload-file-dialog.title": "Continue editing file",
  "reload-file-dialog.description": "You were just editing a file. Would you like to continue editing it?",
  "reload-file-dialog.failure": "Failed to reload file. Try again?",
  "reload-file-dialog.reload": "Continue editing",
  "reload-file-dialog.revert": "No thanks",
  "shortcuts-dialog.title": "Keyboard shortcuts",
  "shortcuts-dialog.edit": "Edit",
  "shortcuts-dialog.file": "File",
  "shortcuts-dialog.preferences": "Preferences",
  "shortcuts-dialog.tools": "Tools",
  "shortcuts-dialog.transform": "Transform",
  "shortcuts-dialog.view": "View",
  "shortcuts-dialog.save": "Continue",
  "style-panel.title": "Styles",
  "style-panel.align": "Align",
  "style-panel.arrowheads": "Arrowheads",
  "style-panel.arrowhead-start": "Start",
  "style-panel.arrowhead-end": "End",
  "style-panel.color": "Color",
  "style-panel.dash": "Dash",
  "style-panel.fill": "Fill",
  "style-panel.font": "Font",
  "style-panel.geo": "Shape",
  "style-panel.label": "Label",
  "style-panel.mixed": "Mixed",
  "style-panel.opacity": "Opacity",
  "style-panel.size": "Size",
  "style-panel.spline": "Spline",
  "style-panel.text": "Text",
  "tool-panel.drawing": "Drawing",
  "tool-panel.geo": "Shape",
  "tool-panel.shapes": "Shapes",
  "tool-panel.things": "Things",
  "tool-panel.tools": "Tools",
  "save-changes-prompt.title": "You have unsaved changes",
  "save-changes-prompt.description": "Would you like to save changes to your current file?",
  "save-changes-prompt.go-back": "Go back",
  "save-changes-prompt.continue": "Continue",
  "navigation-zone.toggle-minimap": "Toggle minimap",
  "navigation-zone.zoom": "Zoom",
  "focus-mode.toggle-focus-mode": "Toggle focus mode",
  "toast.close": "Close",
  "file-system.file-open-error.title": "Could not open file",
  "file-system.file-open-error.not-a-tldraw-file": "The file you tried to open doesn't look like a tldraw file.",
  "file-system.file-open-error.file-format-version-too-new": "The file you tried to open is from a newer version of tldraw. Please reload the page and try again.",
  "file-system.file-open-error.generic-corrupted-file": "The file you tried to open is corrupted.",
  "file-system.confirm-open.title": "Overwrite current project?",
  "file-system.confirm-open.description": "Opening a file will replace your current project and any unsaved changes will be lost. Are you sure you want to continue?",
  "file-system.confirm-open.cancel": "Cancel",
  "file-system.confirm-open.open": "Open file",
  "file-system.confirm-open.dont-show-again": "Don't ask again",
  "file-system.shared-document-file-open-error.title": "Could not open file",
  "file-system.shared-document-file-open-error.description": "Opening files from shared projects is not supported.",
  "toast.error.export-fail.title": "Failed export",
  "toast.error.export-fail.desc": "Failed to export image",
  "toast.error.copy-fail.title": "Failed copy",
  "toast.error.copy-fail.desc": "Failed to copy image",
  "context.pages.new-page": "New page",
  "vscode.file-open.desc": "We've updated this document to work with the current version of tldraw. If you'd like to keep the original version (which will work on old.tldraw.com), click below to create a backup.",
  "vscode.file-open.open": "Continue",
  "vscode.file-open.backup": "Backup",
  "vscode.file-open.backup-saved": "Backup saved",
  "vscode.file-open.backup-failed": "Backup failed: this is not a .tldr file.",
  "vscode.file-open.dont-show-again": "Don't ask again"
}, S2 = [
  { locale: "ar", label: "عربي" },
  { locale: "ca", label: "Català" },
  { locale: "da", label: "Danish" },
  { locale: "de", label: "Deutsch" },
  { locale: "en", label: "English" },
  { locale: "es", label: "Español" },
  { locale: "fa", label: "فارسی" },
  { locale: "fi", label: "Suomi" },
  { locale: "fr", label: "Français" },
  { locale: "gl", label: "Galego" },
  { locale: "he", label: "עברית" },
  { locale: "it", label: "Italiano" },
  { locale: "ja", label: "日本語" },
  { locale: "ko-kr", label: "한국어" },
  { locale: "ku", label: "کوردی" },
  { locale: "hi-in", label: "हिन्दी" },
  { locale: "hu", label: "Magyar" },
  { locale: "my", label: "မြန်မာစာ" },
  { locale: "ne", label: "नेपाली" },
  { locale: "no", label: "Norwegian" },
  { locale: "pl", label: "Polski" },
  { locale: "pt-br", label: "Português - Brasil" },
  { locale: "pt-pt", label: "Português - Europeu" },
  { locale: "ro", label: "Română" },
  { locale: "ru", label: "Russian" },
  { locale: "sv", label: "Svenska" },
  { locale: "te", label: "తెలుగు" },
  { locale: "th", label: "ภาษาไทย" },
  { locale: "tr", label: "Türkçe" },
  { locale: "uk", label: "Ukrainian" },
  { locale: "vi", label: "Tiếng Việt" },
  { locale: "zh-cn", label: "Chinese - Simplified" },
  { locale: "zh-tw", label: "繁體中文 (台灣)" }
], mp = {
  locale: "en",
  label: "English",
  messages: $P
};
async function uce(t, e) {
  if (!(await fetch(e.translations.en)).ok)
    return console.warn("No main translations found."), mp;
  if (t === "en")
    return mp;
  const r = S2.find((f) => f.locale === t);
  if (!r)
    return console.warn(`No translation found for locale ${t}`), mp;
  const s = await (await fetch(e.translations[r.locale])).json();
  if (!s)
    return console.warn(`No messages found for locale ${t}`), mp;
  const c = [];
  for (const f in mp)
    s[f] || c.push(f);
  return c.length > 0 && {}.NODE_ENV === "development" && console.warn(`Language ${t}: missing messages for keys:
${c.join(`
`)}`), { ...mp, messages: { ...mp.messages, ...s } };
}
async function dce(t, e) {
  return await uce(t, e);
}
function L4() {
  const t = Ge();
  return { languages: S2, currentLanguage: t.user.locale };
}
const j4 = k.createContext(null);
function fce({
  assetUrls: t,
  children: e
}) {
  return /* @__PURE__ */ E.jsx(j4.Provider, { value: t, children: e });
}
function j1() {
  const t = k.useContext(j4);
  if (!t)
    throw new Error("useAssetUrls must be used within an AssetUrlsProvider");
  return t;
}
const z4 = k.createContext({}), pce = () => k.useContext(z4), hce = dn(function({
  overrides: e,
  children: n
}) {
  const a = Ge().userSettings.locale, s = j1(), [c, f] = k.useState(() => e && e.en ? {
    locale: "en",
    label: "English",
    messages: { ...$P, ...e.en }
  } : {
    locale: "en",
    label: "English",
    messages: $P
  });
  return k.useEffect(() => {
    let p = !1;
    async function g() {
      const y = a ?? navigator.language.split(/[-_]/)[0], v = await dce(y, s);
      v && !p && (e && e[y] ? f({
        ...v,
        messages: { ...v.messages, ...e[y] }
      }) : f(v));
    }
    return g(), () => {
      p = !0;
    };
  }, [s, a, e]), /* @__PURE__ */ E.jsx(z4.Provider, { value: c, children: n });
});
function Fn() {
  const t = pce();
  return k.useCallback(
    function(n) {
      return t.messages[n] ?? n;
    },
    [t]
  );
}
function gce() {
  const t = Ge(), { addToast: e } = Uu(), n = Fn();
  return k.useCallback(
    // it's important that this function itself isn't async - we need to
    // create the relevant `ClipboardItem`s synchronously to make sure
    // safari knows that the user _wants_ to copy:
    // https://bugs.webkit.org/show_bug.cgi?id=222262
    //
    // this is fine for navigator.clipboard.write, but for fallbacks it's a
    // little awkward.
    function(a = t.selectedIds, s = "svg") {
      if (a.length === 0 && (a = [...t.shapeIds]), a.length !== 0)
        switch (s) {
          case "svg": {
            window.navigator.clipboard && (window.navigator.clipboard.write ? window.navigator.clipboard.write([
              new ClipboardItem({
                "text/plain": mce(t, a)
              })
            ]) : IN(
              async () => zL(await w2(t, a, s))
            ));
            break;
          }
          case "jpeg":
          case "png": {
            const c = s === "jpeg" ? "image/jpeg" : "image/png";
            window.navigator.clipboard.write([
              new ClipboardItem({
                // Note: This needs to use the promise based approach for safari/ios to not bail on a permissions error.
                [c]: vce(t, a, s).then((f) => {
                  if (f) {
                    if (window.navigator.clipboard)
                      return f;
                    throw new Error("Copy not supported");
                  } else
                    throw e({
                      id: "copy-fail",
                      icon: "warning-triangle",
                      title: n("toast.error.copy-fail.title"),
                      description: n("toast.error.copy-fail.desc")
                    }), new Error("Copy not possible");
                })
              })
            ]);
            break;
          }
          case "json": {
            const c = t.getContent(a);
            if (window.navigator.clipboard) {
              const f = JSON.stringify(c);
              window.navigator.clipboard.write ? window.navigator.clipboard.write([
                new ClipboardItem({
                  "text/plain": new Blob([f], { type: "text/plain" })
                })
              ]) : IN(async () => f);
            }
            break;
          }
          default:
            throw new Error(`Copy type ${s} not supported.`);
        }
    },
    [t, e, n]
  );
}
async function w2(t, e, n) {
  const r = await t.getSvg(e, {
    scale: n === "svg" ? 1 : 2,
    background: t.instanceState.exportBackground
  });
  if (!r)
    throw new Error("Could not construct SVG.");
  return r;
}
async function mce(t, e) {
  return new Blob([zL(await w2(t, e, "svg"))], {
    type: "text/plain"
  });
}
async function vce(t, e, n) {
  return await UL(await w2(t, e, n), {
    type: n,
    quality: 1,
    scale: 1
  });
}
async function IN(t) {
  navigator.clipboard.writeText(await t());
}
const U4 = k.createContext({});
function yce({ children: t }) {
  const e = Ge(), [n, r] = k.useState([]), a = k.useCallback(
    (p) => {
      const g = p.id ?? Ii();
      return r((y) => [...y.filter((v) => v.id !== p.id), { ...p, id: g }]), e.openMenus.add(g), g;
    },
    [e]
  ), s = k.useCallback(
    (p, g) => (r(
      (y) => y.map((v) => v.id === p ? {
        ...v,
        ...g
      } : v)
    ), e.openMenus.add(p), p),
    [e]
  ), c = k.useCallback(
    (p) => (r(
      (g) => g.filter((y) => y.id === p ? (y.onClose?.(), !1) : !0)
    ), e.openMenus.delete(p), p),
    [e]
  ), f = k.useCallback(() => {
    r((p) => (p.forEach((g) => {
      g.onClose?.(), e.openMenus.delete(g.id);
    }), []));
  }, [e]);
  return /* @__PURE__ */ E.jsx(
    U4.Provider,
    {
      value: { dialogs: n, addDialog: a, removeDialog: c, clearDialogs: f, updateDialog: s },
      children: t
    }
  );
}
function Fp() {
  const t = k.useContext(U4);
  if (!t)
    throw new Error("useDialogs must be used within a DialogsProvider");
  return t;
}
function bce() {
  const t = Ge(), { addToast: e } = Uu(), n = Fn();
  return k.useCallback(
    async function(a = t.selectedIds, s = "png") {
      if (a.length === 0 && (a = [...t.shapeIds]), a.length === 0)
        return;
      const c = await t.getSvg(a, {
        scale: s === "svg" ? 1 : 2,
        background: t.instanceState.exportBackground
      });
      if (!c)
        throw new Error("Could not construct SVG.");
      const f = a.length === 1 ? t.getShapeById(a[0])?.id.replace(/:/, "_") : "shapes";
      switch (s) {
        case "svg": {
          const p = await BL(c);
          QT(p, `${f || "shapes"}.svg`);
          return;
        }
        case "webp":
        case "png": {
          const p = await UL(c, {
            type: s,
            quality: 1,
            scale: 1
          });
          if (!p) {
            e({
              id: "export-fail",
              // icon: 'error',
              title: n("toast.error.export-fail.title"),
              description: n("toast.error.export-fail.desc")
            });
            return;
          }
          const g = URL.createObjectURL(p);
          QT(g, `${f || "shapes"}.${s}`), URL.revokeObjectURL(g);
          return;
        }
        case "json": {
          const p = t.getContent(a), g = URL.createObjectURL(
            new Blob([JSON.stringify(p, null, 4)], { type: "application/json" })
          );
          QT(g, `${f || "shapes"}.json`), URL.revokeObjectURL(g);
          return;
        }
        default:
          throw new Error(`Export type ${s} not supported.`);
      }
    },
    [t, e, n]
  );
}
function B4() {
  const t = Ge(), e = k.useRef();
  return k.useEffect(() => {
    const n = window.document.createElement("input");
    n.type = "file", n.accept = dZ, n.multiple = !0, e.current = n;
    async function r(a) {
      const s = a.target.files;
      !s || s.length === 0 || (await p1(t, Array.from(s), t.viewportPageBounds.center, !1), n.value = "");
    }
    return n.addEventListener("change", r), () => {
      e.current = void 0, n.removeEventListener("change", r);
    };
  }, [t]), k.useCallback(() => {
    e.current?.click();
  }, [e]);
}
function Sce() {
  const t = Ge(), e = k.useRef(null), n = k.useRef(null);
  return k.useCallback(
    async function() {
      const a = document.createElement("div"), s = document.createElement("style"), c = (D, N) => {
        D && (D.innerHTML = ""), N && document.head.contains(N) && document.head.removeChild(N), D && document.body.contains(D) && document.body.removeChild(D);
      };
      c(e.current, n.current), e.current = a, n.current = s;
      const f = `rs-print-surface-${Ii()}`;
      a.className = f, s.innerHTML = `
			.${f} {
				display: none;
			}

			.${f} svg {
				max-width: 100%;
				height: 100%;
				display: block;
			}

			@media print {				  
				html, body {
					min-height: 100%;
					height: 100%;
					margin: 0;
				}

				body {
					position: relative;
				}

				body > * {
					display: none;
				}

				.${f} {
					display: block !important;
					background: white;
					min-height: 100%;
					height: 100%;
					max-width: 100%;
				}

				.${f}__item {
					padding: 10mm;
					display: flex;
					min-height: 100%;
					flex-direction: column;
					page-break-after: always;
					position: relative;
					overflow: hidden;
					height: 100%;
				}

				.${f}__item__main {
					flex: 1;
					display: flex;
					align-items: center;
					justify-content: center;
					max-height: 100%;
				}

				.${f}__item__header {
					display: none;
				}

				.${f}__item__footer {
					display: none;
					text-align: right;
				}

				.${f}__item__footer__hide {
					display: none;
				}

				
			}

		`;
      const p = () => {
        document.head.appendChild(s), document.body.appendChild(a);
      }, g = () => {
        t.once("change-camera", () => {
          c(a, s);
        });
      };
      window.addEventListener("beforeprint", p), window.addEventListener("afterprint", g);
      function y(D, N, j) {
        try {
          a.innerHTML += `<div class="${f}__item">
        <div class="${f}__item__header">
          ${D.replace(/</g, "&lt;").replace(/>/g, "&gt;")}
        </div>
        <div class="${f}__item__main">
          ${j.outerHTML}
        </div>
        <div class="${f}__item__footer ${f}__item__footer__${N ? "" : "hide"}">
          ${N ?? ""}
        </div>
      </div>`;
        } catch (L) {
          console.error(L);
        }
      }
      function v() {
        t.isSafari ? (p(), document.execCommand("print", !1)) : window.print();
      }
      const { pages: S, currentPageId: x, selectedIds: _ } = t, I = {
        scale: 1,
        background: !1,
        darkMode: !1,
        preserveAspectRatio: "xMidYMid meet"
      };
      if (t.selectedIds.length > 0) {
        const D = await t.getSvg(_, I);
        if (D) {
          const N = S.find((j) => j.id === x);
          y(`tldraw — ${N?.name}`, null, D), v();
        }
      } else {
        const D = t.currentPage, N = await t.getSvg(t.getSortedChildIds(D.id), I);
        N && (y(`tldraw — ${D.name}`, null, N), v());
      }
      window.removeEventListener("beforeprint", p), window.removeEventListener("afterprint", g);
    },
    [t]
  );
}
const F4 = k.createContext({});
function wce(t) {
  return Object.fromEntries(t.map((e) => [e.id, e]));
}
function xce({ overrides: t, children: e }) {
  const n = Ge(), { addDialog: r, clearDialogs: a } = Fp(), { clearToasts: s } = Uu(), c = B4(), f = Sce(), { cut: p, copy: g } = b2(), y = gce(), v = bce(), S = k.useMemo(() => {
    const x = wce([
      // 'new-project': {
      // 	id: 'file.new',
      // 	label: 'file.new',
      // 	onSelect() {
      // 		newFile()
      // 	},
      // },
      // 'open-project': {
      // 	id: 'file.open',
      // 	label: 'file.open',
      // 	kbd: '$o',
      // 	onSelect() {
      // 		openFile()
      // 	},
      // },
      // 'save-project': {
      // 	id: 'file.save',
      // 	label: 'file.save',
      // 	kbd: '$s',
      // 	onSelect() {
      // 		saveFile()
      // 	},
      // },
      // 'save-project-as': {
      // 	id: 'file.save-as',
      // 	label: 'file.save-as',
      // 	kbd: '$!s',
      // 	onSelect() {
      // 		saveFileAs()
      // 	},
      // },
      {
        id: "edit-link",
        label: "action.edit-link",
        icon: "link",
        readonlyOk: !1,
        onSelect() {
          n.mark("edit-link"), r({ component: ece });
        }
      },
      {
        id: "insert-media",
        label: "action.insert-media",
        kbd: "$u",
        readonlyOk: !1,
        onSelect() {
          c();
        }
      },
      {
        id: "undo",
        label: "action.undo",
        icon: "undo",
        kbd: "$z",
        readonlyOk: !1,
        onSelect() {
          n.undo();
        }
      },
      {
        id: "redo",
        label: "action.redo",
        icon: "redo",
        kbd: "$!z",
        readonlyOk: !1,
        onSelect() {
          n.redo();
        }
      },
      {
        id: "export-as-svg",
        label: "action.export-as-svg",
        menuLabel: "action.export-as-svg.short",
        contextMenuLabel: "action.export-as-svg.short",
        readonlyOk: !0,
        onSelect() {
          v(n.selectedIds, "svg");
        }
      },
      {
        id: "export-as-png",
        label: "action.export-as-png",
        menuLabel: "action.export-as-png.short",
        contextMenuLabel: "action.export-as-png.short",
        readonlyOk: !0,
        onSelect() {
          v(n.selectedIds, "png");
        }
      },
      {
        id: "export-as-json",
        label: "action.export-as-json",
        menuLabel: "action.export-as-json.short",
        contextMenuLabel: "action.export-as-json.short",
        readonlyOk: !0,
        onSelect() {
          v(n.selectedIds, "json");
        }
      },
      {
        id: "copy-as-svg",
        label: "action.copy-as-svg",
        menuLabel: "action.copy-as-svg.short",
        contextMenuLabel: "action.copy-as-svg.short",
        kbd: "$!c",
        readonlyOk: !0,
        onSelect() {
          y(n.selectedIds, "svg");
        }
      },
      {
        id: "copy-as-png",
        label: "action.copy-as-png",
        menuLabel: "action.copy-as-png.short",
        contextMenuLabel: "action.copy-as-png.short",
        readonlyOk: !0,
        onSelect() {
          y(n.selectedIds, "png");
        }
      },
      {
        id: "copy-as-json",
        label: "action.copy-as-json",
        menuLabel: "action.copy-as-json.short",
        contextMenuLabel: "action.copy-as-json.short",
        readonlyOk: !0,
        onSelect() {
          y(n.selectedIds, "json");
        }
      },
      {
        id: "toggle-auto-size",
        label: "action.toggle-auto-size",
        readonlyOk: !1,
        onSelect() {
          n.mark(), n.updateShapes(
            n.selectedShapes.filter((_) => _ && _.type === "text" && _.props.autoSize === !1).map((_) => ({
              id: _.id,
              type: _.type,
              props: {
                ..._.props,
                w: 8,
                autoSize: !0
              }
            }))
          );
        }
      },
      {
        id: "open-embed-link",
        label: "action.open-embed-link",
        readonlyOk: !0,
        onSelect() {
          const _ = n.selectedIds, T = "No embed shapes selected";
          if (_.length !== 1) {
            console.error(T);
            return;
          }
          const I = n.getShapeById(_[0]);
          if (!I || !tb.is(I)) {
            console.error(T);
            return;
          }
          DZ(I.props.url, "_blank");
        }
      },
      {
        id: "convert-to-bookmark",
        label: "action.convert-to-bookmark",
        readonlyOk: !1,
        onSelect() {
          const T = n.selectedIds.map((N) => n.getShapeById(N)), I = [], D = [];
          for (const N of T) {
            if (!N || !tb.is(N) || !N.props.url)
              continue;
            const j = new O(N.x, N.y);
            j.rot(-N.rotation), j.add(
              new O(
                N.props.w / 2 - ML / 2,
                N.props.h / 2 - AL / 2
              )
            ), j.rot(N.rotation), I.push({
              id: n.createShapeId(),
              type: "bookmark",
              rotation: N.rotation,
              x: j.x,
              y: j.y,
              props: {
                url: N.props.url,
                opacity: "1"
              }
            }), D.push(N.id);
          }
          n.mark("convert shapes to bookmark"), n.deleteShapes(D), n.createShapes(I);
        }
      },
      {
        id: "convert-to-embed",
        label: "action.convert-to-embed",
        readonlyOk: !1,
        onSelect() {
          const _ = n.selectedIds, T = Gt(_.map((N) => n.getShapeById(N))), I = [], D = [];
          for (const N of T) {
            if (!g1.is(N))
              continue;
            const { url: j } = N.props, L = Yd(N.props.url);
            if (!L || !L.definition)
              continue;
            const { width: z, height: F, doesResize: K } = L.definition, X = new O(N.x, N.y);
            X.rot(-N.rotation), X.add(new O(N.props.w / 2 - z / 2, N.props.h / 2 - F / 2)), X.rot(N.rotation), I.push({
              id: n.createShapeId(),
              type: "embed",
              x: X.x,
              y: X.y,
              rotation: N.rotation,
              props: {
                url: j,
                w: z,
                h: F,
                doesResize: K
              }
            }), D.push(N.id);
          }
          n.mark("convert shapes to embed"), n.deleteShapes(D), n.createShapes(I);
        }
      },
      {
        id: "duplicate",
        kbd: "$d",
        label: "action.duplicate",
        icon: "duplicate",
        readonlyOk: !1,
        onSelect() {
          if (n.currentToolId !== "select")
            return;
          const _ = n.selectedIds, T = ot.Common(Gt(_.map((D) => n.getPageBoundsById(D)))), I = n.canMoveCamera ? {
            x: T.width + 10,
            y: 0
          } : {
            x: 16 / n.camera.z,
            y: 16 / n.camera.z
          };
          n.mark("duplicate shapes"), n.duplicateShapes(_, I);
        }
      },
      {
        id: "ungroup",
        label: "action.ungroup",
        kbd: "$!g",
        icon: "ungroup",
        readonlyOk: !1,
        onSelect() {
          n.mark("ungroup"), n.ungroupShapes(n.selectedIds);
        }
      },
      {
        id: "group",
        label: "action.group",
        kbd: "$g",
        icon: "group",
        readonlyOk: !1,
        onSelect() {
          n.selectedShapes.length === 1 && n.selectedShapes[0].type === "group" ? (n.mark("ungroup"), n.ungroupShapes(n.selectedIds)) : (n.mark("group"), n.groupShapes(n.selectedIds));
        }
      },
      {
        id: "align-left",
        label: "action.align-left",
        kbd: "?A",
        icon: "align-left",
        readonlyOk: !1,
        onSelect() {
          n.mark("align left"), n.alignShapes("left", n.selectedIds);
        }
      },
      {
        id: "align-center-horizontal",
        label: "action.align-center-horizontal",
        contextMenuLabel: "action.align-center-horizontal.short",
        kbd: "?H",
        icon: "align-center-horizontal",
        readonlyOk: !1,
        onSelect() {
          n.mark("align center horizontal"), n.alignShapes("center-horizontal", n.selectedIds);
        }
      },
      {
        id: "align-right",
        label: "action.align-right",
        kbd: "?D",
        icon: "align-right",
        readonlyOk: !1,
        onSelect() {
          n.mark("align right"), n.alignShapes("right", n.selectedIds);
        }
      },
      {
        id: "align-center-vertical",
        label: "action.align-center-vertical",
        contextMenuLabel: "action.align-center-vertical.short",
        kbd: "?V",
        icon: "align-center-vertical",
        readonlyOk: !1,
        onSelect() {
          n.mark("align center vertical"), n.alignShapes("center-vertical", n.selectedIds);
        }
      },
      {
        id: "align-top",
        label: "action.align-top",
        icon: "align-top",
        kbd: "?W",
        readonlyOk: !1,
        onSelect() {
          n.mark("align top"), n.alignShapes("top", n.selectedIds);
        }
      },
      {
        id: "align-bottom",
        label: "action.align-bottom",
        icon: "align-bottom",
        kbd: "?S",
        readonlyOk: !1,
        onSelect() {
          n.mark("align bottom"), n.alignShapes("bottom", n.selectedIds);
        }
      },
      {
        id: "distribute-horizontal",
        label: "action.distribute-horizontal",
        contextMenuLabel: "action.distribute-horizontal.short",
        icon: "distribute-horizontal",
        readonlyOk: !1,
        onSelect() {
          n.mark("distribute horizontal"), n.distributeShapes("horizontal", n.selectedIds);
        }
      },
      {
        id: "distribute-vertical",
        label: "action.distribute-vertical",
        contextMenuLabel: "action.distribute-vertical.short",
        icon: "distribute-vertical",
        readonlyOk: !1,
        onSelect() {
          n.mark("distribute vertical"), n.distributeShapes("vertical", n.selectedIds);
        }
      },
      {
        id: "stretch-horizontal",
        label: "action.stretch-horizontal",
        contextMenuLabel: "action.stretch-horizontal.short",
        icon: "stretch-horizontal",
        readonlyOk: !1,
        onSelect() {
          n.mark("stretch horizontal"), n.stretchShapes("horizontal", n.selectedIds);
        }
      },
      {
        id: "stretch-vertical",
        label: "action.stretch-vertical",
        contextMenuLabel: "action.stretch-vertical.short",
        icon: "stretch-vertical",
        readonlyOk: !1,
        onSelect() {
          n.mark("stretch vertical"), n.stretchShapes("vertical", n.selectedIds);
        }
      },
      {
        id: "flip-horizontal",
        label: "action.flip-horizontal",
        contextMenuLabel: "action.flip-horizontal.short",
        kbd: "!h",
        readonlyOk: !1,
        onSelect() {
          n.mark("flip horizontal"), n.flipShapes("horizontal", n.selectedIds);
        }
      },
      {
        id: "flip-vertical",
        label: "action.flip-vertical",
        contextMenuLabel: "action.flip-vertical.short",
        kbd: "!v",
        readonlyOk: !1,
        onSelect() {
          n.mark("flip vertical"), n.flipShapes("vertical", n.selectedIds);
        }
      },
      {
        id: "pack",
        label: "action.pack",
        icon: "pack",
        readonlyOk: !1,
        onSelect() {
          n.mark("pack"), n.packShapes(n.selectedIds);
        }
      },
      {
        id: "stack-vertical",
        label: "action.stack-vertical",
        contextMenuLabel: "action.stack-vertical.short",
        icon: "stack-vertical",
        readonlyOk: !1,
        onSelect() {
          n.mark("stack-vertical"), n.stackShapes("vertical", n.selectedIds);
        }
      },
      {
        id: "stack-horizontal",
        label: "action.stack-horizontal",
        contextMenuLabel: "action.stack-horizontal.short",
        icon: "stack-horizontal",
        readonlyOk: !1,
        onSelect() {
          n.mark("stack-horizontal"), n.stackShapes("horizontal", n.selectedIds);
        }
      },
      {
        id: "bring-to-front",
        label: "action.bring-to-front",
        kbd: "]",
        icon: "bring-to-front",
        readonlyOk: !1,
        onSelect() {
          n.mark("bring to front"), n.bringToFront();
        }
      },
      {
        id: "bring-forward",
        label: "action.bring-forward",
        icon: "bring-forward",
        kbd: "?]",
        readonlyOk: !1,
        onSelect() {
          n.mark("bring forward"), n.bringForward();
        }
      },
      {
        id: "send-backward",
        label: "action.send-backward",
        icon: "send-backward",
        kbd: "?[",
        readonlyOk: !1,
        onSelect() {
          n.mark("send backward"), n.sendBackward();
        }
      },
      {
        id: "send-to-back",
        label: "action.send-to-back",
        icon: "send-to-back",
        kbd: "[",
        readonlyOk: !1,
        onSelect() {
          n.mark("send to back"), n.sendToBack();
        }
      },
      {
        id: "cut",
        label: "action.cut",
        kbd: "$x",
        readonlyOk: !1,
        onSelect() {
          n.mark("cut"), p();
        }
      },
      {
        id: "copy",
        label: "action.copy",
        kbd: "$c",
        readonlyOk: !0,
        onSelect() {
          g();
        }
      },
      {
        id: "paste",
        label: "action.paste",
        kbd: "$v",
        readonlyOk: !1,
        onSelect() {
        }
      },
      {
        id: "select-all",
        label: "action.select-all",
        kbd: "$a",
        readonlyOk: !0,
        onSelect() {
          n.currentToolId !== "select" && (n.cancel(), n.setSelectedTool("select")), n.mark("select all kbd"), n.selectAll();
        }
      },
      {
        id: "select-none",
        label: "action.select-none",
        readonlyOk: !0,
        onSelect() {
          n.mark("select none"), n.selectNone();
        }
      },
      {
        id: "delete",
        label: "action.delete",
        kbd: "⌫",
        icon: "trash",
        readonlyOk: !1,
        onSelect() {
          n.currentToolId === "select" && (n.mark("delete"), n.deleteShapes());
        }
      },
      {
        id: "rotate-cw",
        label: "action.rotate-cw",
        icon: "rotate-cw",
        readonlyOk: !1,
        onSelect() {
          if (n.selectedIds.length === 0)
            return;
          n.mark("rotate-cw");
          const _ = n.selectionRotation % (cr / 2), T = By(_, 0) || By(_, cr / 2);
          n.rotateShapesBy(n.selectedIds, cr / 2 - (T ? 0 : _));
        }
      },
      {
        id: "rotate-ccw",
        label: "action.rotate-ccw",
        icon: "rotate-ccw",
        readonlyOk: !1,
        onSelect() {
          if (n.selectedIds.length === 0)
            return;
          n.mark("rotate-ccw");
          const _ = n.selectionRotation % (cr / 2), T = By(_, 0);
          n.rotateShapesBy(n.selectedIds, T ? -(cr / 2) : -_);
        }
      },
      {
        id: "zoom-in",
        label: "action.zoom-in",
        kbd: "$=",
        readonlyOk: !0,
        onSelect() {
          n.zoomIn(n.viewportScreenCenter, { duration: $u });
        }
      },
      {
        id: "zoom-out",
        label: "action.zoom-out",
        kbd: "$-",
        readonlyOk: !0,
        onSelect() {
          n.zoomOut(n.viewportScreenCenter, { duration: $u });
        }
      },
      {
        id: "zoom-to-100",
        label: "action.zoom-to-100",
        icon: "reset-zoom",
        kbd: "!0",
        readonlyOk: !0,
        onSelect() {
          n.resetZoom(n.viewportScreenCenter, { duration: $u });
        }
      },
      {
        id: "zoom-to-fit",
        label: "action.zoom-to-fit",
        kbd: "!1",
        readonlyOk: !0,
        onSelect() {
          n.zoomToFit({ duration: $u });
        }
      },
      {
        id: "zoom-to-selection",
        label: "action.zoom-to-selection",
        kbd: "!2",
        readonlyOk: !0,
        onSelect() {
          n.zoomToSelection({ duration: $u });
        }
      },
      {
        id: "toggle-snap-mode",
        label: "action.toggle-snap-mode",
        menuLabel: "action.toggle-snap-mode.menu",
        readonlyOk: !1,
        onSelect() {
          n.updateUserDocumentSettings(
            {
              isSnapMode: !n.userDocumentSettings.isSnapMode
            },
            !0
          );
        },
        checkbox: !0
      },
      {
        id: "toggle-dark-mode",
        label: "action.toggle-dark-mode",
        menuLabel: "action.toggle-dark-mode.menu",
        kbd: "$/",
        readonlyOk: !0,
        onSelect() {
          n.updateUserDocumentSettings(
            {
              isDarkMode: !n.userDocumentSettings.isDarkMode
            },
            !0
          );
        },
        checkbox: !0
      },
      {
        id: "toggle-transparent",
        label: "action.toggle-transparent",
        menuLabel: "action.toggle-transparent.menu",
        contextMenuLabel: "action.toggle-transparent.context-menu",
        readonlyOk: !0,
        onSelect() {
          n.updateInstanceState(
            {
              exportBackground: !n.instanceState.exportBackground
            },
            !0
          );
        },
        checkbox: !0
      },
      {
        id: "toggle-tool-lock",
        label: "action.toggle-tool-lock",
        menuLabel: "action.toggle-tool-lock.menu",
        readonlyOk: !1,
        kbd: "q",
        onSelect() {
          n.updateInstanceState(
            {
              isToolLocked: !n.instanceState.isToolLocked
            },
            !0
          );
        },
        checkbox: !0
      },
      {
        id: "toggle-focus-mode",
        label: "action.toggle-focus-mode",
        menuLabel: "action.toggle-focus-mode.menu",
        readonlyOk: !0,
        kbd: "$.",
        checkbox: !0,
        onSelect() {
          requestAnimationFrame(() => {
            n.batch(() => {
              a(), s(), n.updateInstanceState(
                {
                  isFocusMode: !n.instanceState.isFocusMode
                },
                !0
              );
            });
          });
        }
      },
      {
        id: "toggle-grid",
        label: "action.toggle-grid",
        menuLabel: "action.toggle-grid.menu",
        readonlyOk: !0,
        kbd: "$'",
        onSelect() {
          n.updateUserDocumentSettings(
            {
              isGridMode: !n.userDocumentSettings.isGridMode
            },
            !0
          );
        },
        checkbox: !0
      },
      {
        id: "toggle-debug-mode",
        label: "action.toggle-debug-mode",
        menuLabel: "action.toggle-debug-mode.menu",
        readonlyOk: !0,
        onSelect() {
          n.updateInstanceState(
            {
              isDebugMode: !n.instanceState.isDebugMode
            },
            !0
          );
        },
        checkbox: !0
      },
      {
        id: "print",
        label: "action.print",
        kbd: "$p",
        readonlyOk: !0,
        onSelect() {
          f();
        }
      },
      {
        id: "nudge-left",
        kbd: "left,shift+left",
        label: "action.nudge-left",
        readonlyOk: !1,
        onSelect() {
          n.mark("nudge left"), n.nudgeShapes(n.selectedIds, "left", n.inputs.shiftKey);
        }
      },
      {
        id: "nudge-up",
        kbd: "up,shift+up",
        label: "action.nudge-up",
        readonlyOk: !1,
        onSelect() {
          n.mark("nudge up"), n.nudgeShapes(n.selectedIds, "up", n.inputs.shiftKey);
        }
      },
      {
        id: "nudge-right",
        kbd: "right,shift+right",
        label: "action.nudge-right",
        readonlyOk: !1,
        onSelect() {
          n.mark("nudge right"), n.nudgeShapes(n.selectedIds, "right", n.inputs.shiftKey);
        }
      },
      {
        id: "nudge-down",
        kbd: "down,shift+down",
        label: "action.nudge-down",
        readonlyOk: !1,
        onSelect() {
          n.mark("nudge down"), n.nudgeShapes(n.selectedIds, "down", n.inputs.shiftKey);
        }
      },
      {
        id: "exit-pen-mode",
        label: "action.exit-pen-mode",
        icon: "cross-2",
        readonlyOk: !0,
        onSelect() {
          n.setPenMode(!1);
        }
      },
      {
        id: "back-to-content",
        label: "action.back-to-content",
        icon: "arrow-left",
        readonlyOk: !0,
        onSelect() {
          const _ = n.selectedPageBounds ?? n.allShapesCommonBounds;
          _ && n.zoomToBounds(
            _.minX,
            _.minY,
            _.width,
            _.height,
            Math.min(1, n.camera.z),
            { duration: 220 }
          );
        }
      }
    ]);
    return t ? t(n, x, void 0) : x;
  }, [
    t,
    n,
    r,
    c,
    v,
    y,
    p,
    g,
    a,
    s,
    f
  ]);
  return /* @__PURE__ */ E.jsx(F4.Provider, { value: S, children: e });
}
function va() {
  const t = k.useContext(F4);
  if (!t)
    throw new Error("useTools must be used within a ToolProvider");
  return t;
}
const Ece = [0, 380, 420, 460, 580, 640, 840, 1023], H4 = It.createContext(0);
function Cce({ children: t }) {
  const e = Ge(), n = un(
    "breakpoint",
    () => {
      const { width: r } = e.viewportScreenBounds, a = Ece;
      for (let s = 0; s < a.length - 1; s++)
        if (r > a[s] && r <= a[s + 1])
          return s;
      return a.length;
    },
    [e]
  );
  return /* @__PURE__ */ E.jsx(H4.Provider, { value: n, children: t });
}
function Gs() {
  let t = k.useContext(H4);
  const e = new URL(window.location.href).searchParams.get("layout");
  return e === "desktop" ? t = 7 : e === "mobile" && (t = 1), t;
}
function x2() {
  const t = Ge();
  return un(
    "hasLinkShapeSelected",
    () => {
      const { selectedShapes: e } = t;
      return e.length === 1 && "url" in e[0].props && e[0].type !== "embed";
    },
    [t]
  );
}
const V4 = It.createContext({}), _ce = dn(function({
  overrides: e,
  children: n
}) {
  const r = Ge(), a = va(), s = r.selectedIds.length, c = s > 0, f = s > 1, p = s > 2, g = a4(), y = l2(), v = c2(), S = x2(), x = Gs(), _ = r.camera.z === 1, T = k.useMemo(() => {
    const I = [
      Ie(a["align-left"], { disabled: !f }),
      Ie(a["align-center-horizontal"], { disabled: !f }),
      Ie(a["align-right"], { disabled: !f }),
      Ie(a["stretch-horizontal"], { disabled: !f }),
      Ie(a["align-top"], { disabled: !f }),
      Ie(a["align-center-vertical"], { disabled: !f }),
      Ie(a["align-bottom"], { disabled: !f }),
      Ie(a["stretch-vertical"], { disabled: !f }),
      Ie(a["distribute-horizontal"], { disabled: !p }),
      Ie(a["distribute-vertical"], { disabled: !p }),
      Ie(a["stack-horizontal"], { disabled: !g }),
      Ie(a["stack-vertical"], { disabled: !g }),
      Ie(a["send-to-back"], { disabled: !c }),
      Ie(a["send-backward"], { disabled: !c }),
      Ie(a["bring-forward"], { disabled: !c }),
      Ie(a["bring-to-front"], { disabled: !c }),
      x < 5 ? Ie(a["zoom-to-100"], { disabled: !!_ }) : Ie(a["rotate-ccw"], { disabled: !c }),
      Ie(a["rotate-cw"], { disabled: !c }),
      Ie(a["edit-link"], { disabled: !S }),
      y ? Ie(a.group, { disabled: !f }) : v ? Ie(a.ungroup) : Ie(a.group, { disabled: !f })
    ];
    return e ? e(r, I, { actions: a, oneSelected: c, twoSelected: f, threeSelected: p }) : I;
  }, [
    r,
    _,
    y,
    e,
    a,
    c,
    f,
    p,
    g,
    v,
    S,
    x
  ]);
  return /* @__PURE__ */ E.jsx(V4.Provider, { value: T, children: n });
});
function Tce() {
  const t = It.useContext(V4);
  if (!t)
    throw new Error("useActionsMenuSchema must be used inside of a ActionsMenuSchemaProvider.");
  return t;
}
function kce() {
  const t = Ge(), { addToast: e } = Uu();
  k.useEffect(() => {
    function n({ name: a, count: s }) {
      e({
        title: "Maximum Shapes Reached",
        description: `You've reached the maximum number of shapes allowed on ${a} (${s}). Please delete some shapes or move to a different page to continue.`
      });
    }
    function r({ name: a, fromId: s }) {
      e({
        title: "Changed Page",
        description: `Moved to ${a}.`,
        actions: [
          {
            label: "Go Back",
            type: "primary",
            onClick: () => {
              t.mark("change-page"), t.setCurrentPageId(s);
            }
          }
          // prev page
        ]
      });
    }
    return t.addListener("max-shapes", n), t.addListener("moved-to-page", r), () => {
      t.removeListener("max-shapes", n), t.removeListener("moved-to-page", r);
    };
  }, [t, e]);
}
function Y4() {
  const t = Ge();
  return un("useCanRedo", () => t.canRedo, [t]);
}
function K4() {
  const t = Ge();
  return un("useCanUndo", () => t.canUndo, [t]);
}
function Pce() {
  const t = Ge();
  return un(
    "onlyFlippableShape",
    () => {
      const { selectedShapes: e } = t;
      return e.length === 1 && e.every((n) => n.type === "group" || ire(n));
    },
    [t]
  );
}
function W4() {
  const t = Ge();
  return un(
    "showAutoSizeToggle",
    () => {
      const { selectedShapes: e } = t;
      return e.length === 1 && e[0].type === "text" && e[0].props.autoSize === !1;
    },
    [t]
  );
}
const G4 = It.createContext({}), Ice = typeof window < "u" && "navigator" in window && !!navigator.clipboard && !!navigator.clipboard.read, Rce = dn(function({
  overrides: e,
  children: n
}) {
  const r = Ge(), a = va(), s = W4(), c = Pce(), f = r.selectedIds.length, p = f > 0, g = un(
    "oneEmbedSelected",
    () => r.selectedIds.length !== 1 ? !1 : r.selectedIds.some((z) => {
      const F = r.getShapeById(z);
      return F && tb.is(F) && F.props.url;
    }),
    []
  ), y = un(
    "oneEmbeddableBookmarkSelected",
    () => r.selectedIds.length !== 1 ? !1 : r.selectedIds.some((z) => {
      const F = r.getShapeById(z);
      return F && g1.is(F) && Yd(F.props.url);
    }),
    []
  ), v = f > 1, S = f > 2, x = a4(), _ = un("atLeastOneShapeOnPage", () => r.shapeIds.size > 0, []), T = un("isTransparentBg", () => r.instanceState.exportBackground, []), I = l2(), D = c2(), N = !!window.navigator.clipboard?.write, j = x2(), L = k.useMemo(() => {
    let z = s2([
      wn(
        "selection",
        g && Ie(a["open-embed-link"]),
        g && Ie(a["convert-to-bookmark"]),
        y && Ie(a["convert-to-embed"]),
        s && Ie(a["toggle-auto-size"]),
        j && Ie(a["edit-link"]),
        p && Ie(a.duplicate),
        I && Ie(a.group),
        D && Ie(a.ungroup)
      ),
      wn(
        "modify",
        (v || c) && Ec(
          "arrange",
          "context-menu.arrange",
          v && wn(
            "align",
            Ie(a["align-left"]),
            Ie(a["align-center-horizontal"]),
            Ie(a["align-right"]),
            Ie(a["align-top"]),
            Ie(a["align-center-vertical"]),
            Ie(a["align-bottom"])
          ),
          S && wn(
            "distribute",
            Ie(a["distribute-horizontal"]),
            Ie(a["distribute-vertical"])
          ),
          v && wn(
            "stretch",
            Ie(a["stretch-horizontal"]),
            Ie(a["stretch-vertical"])
          ),
          c && wn(
            "flip",
            Ie(a["flip-horizontal"]),
            Ie(a["flip-vertical"])
          ),
          v && wn(
            "order",
            Ie(a.pack, { disabled: !v }),
            x && Ie(a["stack-vertical"]),
            x && Ie(a["stack-horizontal"])
          )
        ),
        p && Ec(
          "reorder",
          "context-menu.reorder",
          wn(
            "reorder",
            Ie(a["bring-to-front"]),
            Ie(a["bring-forward"]),
            Ie(a["send-backward"]),
            Ie(a["send-to-back"])
          )
        ),
        p && Yx("MOVE_TO_PAGE_MENU", { readonlyOk: !1 })
      ),
      wn(
        "clipboard-group",
        p && Ie(a.cut),
        p && Ie(a.copy),
        Ice && Yx("MENU_PASTE", { readonlyOk: !1 })
      ),
      _ && wn(
        "conversions",
        Ec(
          "copy-as",
          "context-menu.copy-as",
          wn(
            "copy-as-group",
            Ie(a["copy-as-svg"]),
            N && Ie(a["copy-as-png"]),
            Ie(a["copy-as-json"])
          ),
          wn(
            "export-bg",
            Ie(a["toggle-transparent"], { checked: !T })
          )
        ),
        Ec(
          "export-as",
          "context-menu.export-as",
          wn(
            "export-as-group",
            Ie(a["export-as-svg"]),
            Ie(a["export-as-png"]),
            Ie(a["export-as-json"])
          ),
          wn(
            "export-bg,",
            Ie(a["toggle-transparent"], { checked: !T })
          )
        )
      ),
      _ && wn(
        "set-selection-group",
        Ie(a["select-all"]),
        p && Ie(a["select-none"])
      ),
      p && wn("delete-group", Ie(a.delete))
    ]);
    return e && (z = e(r, z, {
      actions: a,
      oneSelected: p,
      twoSelected: v,
      threeSelected: S,
      showAutoSizeToggle: s,
      showUngroup: D,
      onlyFlippableShapeSelected: c
    })), z;
  }, [
    r,
    e,
    a,
    p,
    v,
    S,
    s,
    c,
    _,
    x,
    I,
    D,
    N,
    j,
    g,
    y,
    T
  ]);
  return /* @__PURE__ */ E.jsx(G4.Provider, { value: L, children: n });
});
function X4() {
  const t = It.useContext(G4);
  if (!t)
    throw new Error("useContextMenuSchema must be used inside of a ContextMenuSchemaProvider.");
  return t;
}
const $ce = () => {
  const t = Fn(), e = Bu(), n = Zce();
  function r(a) {
    if (e && !a.readonlyOk)
      return null;
    switch (a.type) {
      case "group":
        return /* @__PURE__ */ E.jsxs("div", { className: "tlui-shortcuts-dialog__group", children: [
          /* @__PURE__ */ E.jsx("h2", { className: "tlui-shortcuts-dialog__group__title", children: t(a.id) }),
          /* @__PURE__ */ E.jsx("div", { className: "tlui-shortcuts-dialog__group__content", children: a.children.filter((s) => s.type === "item" && s.actionItem.kbd).map(r) })
        ] }, a.id);
      case "item": {
        const { id: s, label: c, shortcutsLabel: f, kbd: p } = a.actionItem;
        return /* @__PURE__ */ E.jsxs("div", { className: "tlui-shortcuts-dialog__key-pair", children: [
          /* @__PURE__ */ E.jsx("div", { className: "tlui-shortcuts-dialog__key-pair__key", children: t(f ?? c) }),
          /* @__PURE__ */ E.jsx("div", { className: "tlui-shortcuts-dialog__key-pair__value", children: /* @__PURE__ */ E.jsx(A1, { children: p }) })
        ] }, s);
      }
    }
  }
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsxs(O1, { className: "tlui-shortcuts-dialog__header", children: [
      /* @__PURE__ */ E.jsx(D1, { children: t("shortcuts-dialog.title") }),
      /* @__PURE__ */ E.jsx(N1, {})
    ] }),
    /* @__PURE__ */ E.jsx(lb, { className: "tlui-shortcuts-dialog__body", children: n.map(r) }),
    /* @__PURE__ */ E.jsx("div", { className: "tlui-dialog__scrim" })
  ] });
}, q4 = It.createContext({}), Mce = dn(function({
  overrides: e,
  children: n
}) {
  const r = Ge(), a = va(), s = r.selectedIds.length, c = s > 0, f = s > 1, p = s > 2, { languages: g, currentLanguage: y } = L4(), { addDialog: v } = Fp(), S = k.useMemo(() => {
    const x = Gt([
      wn(
        "top",
        Yx("LANGUAGE_MENU", { readonlyOk: !0 }),
        Ie({
          id: "keyboard-shortcuts",
          label: "help-menu.keyboard-shortcuts",
          readonlyOk: !0,
          onSelect() {
            v({ component: $ce });
          }
        })
      )
    ]);
    return e ? e(r, x, {
      actions: a,
      currentLanguage: y,
      languages: g,
      oneSelected: c,
      twoSelected: f,
      threeSelected: p
    }) : x;
  }, [
    r,
    e,
    g,
    a,
    c,
    f,
    p,
    y,
    v
  ]);
  return /* @__PURE__ */ E.jsx(q4.Provider, { value: S, children: n });
});
function Ace() {
  const t = It.useContext(q4);
  if (!t)
    throw new Error("useHelpMenuSchema must be used inside of a helpMenuSchemaProvider.");
  return t;
}
var kk = typeof navigator < "u" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : !1;
function Pk(t, e, n, r) {
  t.addEventListener ? t.addEventListener(e, n, r) : t.attachEvent && t.attachEvent("on".concat(e), function() {
    n(window.event);
  });
}
function Q4(t, e) {
  for (var n = e.slice(0, e.length - 1), r = 0; r < n.length; r++)
    n[r] = t[n[r].toLowerCase()];
  return n;
}
function Z4(t) {
  typeof t != "string" && (t = ""), t = t.replace(/\s/g, "");
  for (var e = t.split(","), n = e.lastIndexOf(""); n >= 0; )
    e[n - 1] += ",", e.splice(n, 1), n = e.lastIndexOf("");
  return e;
}
function Oce(t, e) {
  for (var n = t.length >= e.length ? t : e, r = t.length >= e.length ? e : t, a = !0, s = 0; s < n.length; s++)
    r.indexOf(n[s]) === -1 && (a = !1);
  return a;
}
var ub = {
  backspace: 8,
  "⌫": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "↩": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "⇪": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": kk ? 173 : 189,
  "=": kk ? 61 : 187,
  ";": kk ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
}, Pc = {
  // shiftKey
  "⇧": 16,
  shift: 16,
  // altKey
  "⌥": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "⌃": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "⌘": 91,
  cmd: 91,
  command: 91
}, MP = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
}, wo = {
  16: !1,
  18: !1,
  17: !1,
  91: !1
}, Pi = {};
for (var Zw = 1; Zw < 20; Zw++)
  ub["f".concat(Zw)] = 111 + Zw;
var jr = [], RN = !1, J4 = "all", e5 = [], z1 = function(e) {
  return ub[e.toLowerCase()] || Pc[e.toLowerCase()] || e.toUpperCase().charCodeAt(0);
}, Dce = function(e) {
  return Object.keys(ub).find(function(n) {
    return ub[n] === e;
  });
}, Nce = function(e) {
  return Object.keys(Pc).find(function(n) {
    return Pc[n] === e;
  });
};
function t5(t) {
  J4 = t || "all";
}
function db() {
  return J4 || "all";
}
function Lce() {
  return jr.slice(0);
}
function jce() {
  return jr.map(function(t) {
    return Dce(t) || Nce(t) || String.fromCharCode(t);
  });
}
function zce(t) {
  var e = t.target || t.srcElement, n = e.tagName, r = !0;
  return (e.isContentEditable || (n === "INPUT" || n === "TEXTAREA" || n === "SELECT") && !e.readOnly) && (r = !1), r;
}
function Uce(t) {
  return typeof t == "string" && (t = z1(t)), jr.indexOf(t) !== -1;
}
function Bce(t, e) {
  var n, r;
  t || (t = db());
  for (var a in Pi)
    if (Object.prototype.hasOwnProperty.call(Pi, a))
      for (n = Pi[a], r = 0; r < n.length; )
        n[r].scope === t ? n.splice(r, 1) : r++;
  db() === t && t5(e || "all");
}
function Fce(t) {
  var e = t.keyCode || t.which || t.charCode, n = jr.indexOf(e);
  if (n >= 0 && jr.splice(n, 1), t.key && t.key.toLowerCase() === "meta" && jr.splice(0, jr.length), (e === 93 || e === 224) && (e = 91), e in wo) {
    wo[e] = !1;
    for (var r in Pc)
      Pc[r] === e && (la[r] = !1);
  }
}
function Hce(t) {
  if (typeof t > "u")
    Object.keys(Pi).forEach(function(c) {
      return delete Pi[c];
    });
  else if (Array.isArray(t))
    t.forEach(function(c) {
      c.key && Ik(c);
    });
  else if (typeof t == "object")
    t.key && Ik(t);
  else if (typeof t == "string") {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
      n[r - 1] = arguments[r];
    var a = n[0], s = n[1];
    typeof a == "function" && (s = a, a = ""), Ik({
      key: t,
      scope: a,
      method: s,
      splitKey: "+"
    });
  }
}
var Ik = function(e) {
  var n = e.key, r = e.scope, a = e.method, s = e.splitKey, c = s === void 0 ? "+" : s, f = Z4(n);
  f.forEach(function(p) {
    var g = p.split(c), y = g.length, v = g[y - 1], S = v === "*" ? "*" : z1(v);
    if (Pi[S]) {
      r || (r = db());
      var x = y > 1 ? Q4(Pc, g) : [];
      Pi[S] = Pi[S].filter(function(_) {
        var T = a ? _.method === a : !0;
        return !(T && _.scope === r && Oce(_.mods, x));
      });
    }
  });
};
function $N(t, e, n, r) {
  if (e.element === r) {
    var a;
    if (e.scope === n || e.scope === "all") {
      a = e.mods.length > 0;
      for (var s in wo)
        Object.prototype.hasOwnProperty.call(wo, s) && (!wo[s] && e.mods.indexOf(+s) > -1 || wo[s] && e.mods.indexOf(+s) === -1) && (a = !1);
      (e.mods.length === 0 && !wo[16] && !wo[18] && !wo[17] && !wo[91] || a || e.shortcut === "*") && e.method(t, e) === !1 && (t.preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation && t.stopPropagation(), t.cancelBubble && (t.cancelBubble = !0));
    }
  }
}
function MN(t, e) {
  var n = Pi["*"], r = t.keyCode || t.which || t.charCode;
  if (la.filter.call(this, t)) {
    if ((r === 93 || r === 224) && (r = 91), jr.indexOf(r) === -1 && r !== 229 && jr.push(r), ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(_) {
      var T = MP[_];
      t[_] && jr.indexOf(T) === -1 ? jr.push(T) : !t[_] && jr.indexOf(T) > -1 ? jr.splice(jr.indexOf(T), 1) : _ === "metaKey" && t[_] && jr.length === 3 && (t.ctrlKey || t.shiftKey || t.altKey || (jr = jr.slice(jr.indexOf(T))));
    }), r in wo) {
      wo[r] = !0;
      for (var a in Pc)
        Pc[a] === r && (la[a] = !0);
      if (!n)
        return;
    }
    for (var s in wo)
      Object.prototype.hasOwnProperty.call(wo, s) && (wo[s] = t[MP[s]]);
    t.getModifierState && !(t.altKey && !t.ctrlKey) && t.getModifierState("AltGraph") && (jr.indexOf(17) === -1 && jr.push(17), jr.indexOf(18) === -1 && jr.push(18), wo[17] = !0, wo[18] = !0);
    var c = db();
    if (n)
      for (var f = 0; f < n.length; f++)
        n[f].scope === c && (t.type === "keydown" && n[f].keydown || t.type === "keyup" && n[f].keyup) && $N(t, n[f], c, e);
    if (r in Pi) {
      for (var p = 0; p < Pi[r].length; p++)
        if ((t.type === "keydown" && Pi[r][p].keydown || t.type === "keyup" && Pi[r][p].keyup) && Pi[r][p].key) {
          for (var g = Pi[r][p], y = g.splitKey, v = g.key.split(y), S = [], x = 0; x < v.length; x++)
            S.push(z1(v[x]));
          S.sort().join("") === jr.sort().join("") && $N(t, g, c, e);
        }
    }
  }
}
function Vce(t) {
  return e5.indexOf(t) > -1;
}
function la(t, e, n) {
  jr = [];
  var r = Z4(t), a = [], s = "all", c = document, f = 0, p = !1, g = !0, y = "+", v = !1;
  for (n === void 0 && typeof e == "function" && (n = e), Object.prototype.toString.call(e) === "[object Object]" && (e.scope && (s = e.scope), e.element && (c = e.element), e.keyup && (p = e.keyup), e.keydown !== void 0 && (g = e.keydown), e.capture !== void 0 && (v = e.capture), typeof e.splitKey == "string" && (y = e.splitKey)), typeof e == "string" && (s = e); f < r.length; f++)
    t = r[f].split(y), a = [], t.length > 1 && (a = Q4(Pc, t)), t = t[t.length - 1], t = t === "*" ? "*" : z1(t), t in Pi || (Pi[t] = []), Pi[t].push({
      keyup: p,
      keydown: g,
      scope: s,
      mods: a,
      shortcut: r[f],
      method: n,
      key: r[f],
      splitKey: y,
      element: c
    });
  typeof c < "u" && !Vce(c) && window && (e5.push(c), Pk(c, "keydown", function(S) {
    MN(S, c);
  }, v), RN || (RN = !0, Pk(window, "focus", function() {
    jr = [];
  }, v)), Pk(c, "keyup", function(S) {
    MN(S, c), Fce(S);
  }, v));
}
function Yce(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(Pi).forEach(function(n) {
    var r = Pi[n].filter(function(a) {
      return a.scope === e && a.shortcut === t;
    });
    r.forEach(function(a) {
      a && a.method && a.method();
    });
  });
}
var Rk = {
  getPressedKeyString: jce,
  setScope: t5,
  getScope: db,
  deleteScope: Bce,
  getPressedKeyCodes: Lce,
  isPressed: Uce,
  filter: zce,
  trigger: Yce,
  unbind: Hce,
  keyMap: ub,
  modifier: Pc,
  modifierMap: MP
};
for (var $k in Rk)
  Object.prototype.hasOwnProperty.call(Rk, $k) && (la[$k] = Rk[$k]);
if (typeof window < "u") {
  var Kce = window.hotkeys;
  la.noConflict = function(t) {
    return t && window.hotkeys === la && (window.hotkeys = Kce), la;
  }, window.hotkeys = la;
}
function Bu() {
  const t = Ge();
  return un("isReadOnlyMode", () => t.isReadOnly, [t]);
}
const Wce = dn(function({ onClose: e }) {
  const n = Ge(), r = Fn(), a = j1(), [s, c] = k.useState(null), [f, p] = k.useState(""), [g, y] = k.useState(null), [v, S] = k.useState(!1), x = k.useRef(-1);
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsxs(O1, { children: [
      /* @__PURE__ */ E.jsx(D1, { children: s ? `${r("embed-dialog.title")} — ${s.title}` : r("embed-dialog.title") }),
      /* @__PURE__ */ E.jsx(N1, {})
    ] }),
    s ? /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(lb, { className: "tlui-embed-dialog__enter", children: /* @__PURE__ */ E.jsxs("div", { className: "tlui-embed-dialog", children: [
        /* @__PURE__ */ E.jsx(
          g2,
          {
            className: "tlui-embed-dialog__input",
            label: "embed-dialog.url",
            placeholder: "http://example.com",
            autofocus: !0,
            onValueChange: (_) => {
              p(_);
              const T = Yd(_);
              y(
                T && T.definition.type === s.type ? T : null
              ), S(!1), clearTimeout(x.current), x.current = setTimeout(() => S(!T), 320);
            }
          }
        ),
        f === "" ? /* @__PURE__ */ E.jsxs("div", { className: "tlui-embed-dialog__instruction", children: [
          /* @__PURE__ */ E.jsx("span", { children: r("embed-dialog.instruction") }),
          " ",
          s.instructionLink && /* @__PURE__ */ E.jsxs(
            "a",
            {
              target: "_blank",
              rel: "noopener noreferrer",
              href: s.instructionLink,
              className: "tlui-embed-dialog__instruction__link",
              children: [
                "Learn more.",
                /* @__PURE__ */ E.jsx(Ya, { icon: "external-link", small: !0 })
              ]
            }
          )
        ] }) : /* @__PURE__ */ E.jsx("div", { className: "tlui-embed-dialog__warning", children: v ? r("embed-dialog.invalid-url") : " " })
      ] }) }),
      /* @__PURE__ */ E.jsxs(u2, { className: "tlui-dialog__footer__actions", children: [
        /* @__PURE__ */ E.jsx(
          At,
          {
            onClick: () => {
              c(null), y(null), p("");
            },
            label: "embed-dialog.back"
          }
        ),
        /* @__PURE__ */ E.jsx("div", { className: "tlui-spacer" }),
        /* @__PURE__ */ E.jsx(At, { label: "embed-dialog.cancel", onClick: e }),
        /* @__PURE__ */ E.jsx(
          At,
          {
            type: "primary",
            disabled: !g,
            label: "embed-dialog.create",
            onClick: () => {
              g && (YL(n, f, n.viewportPageCenter, {
                width: g.definition.width,
                height: g.definition.height,
                doesResize: g.definition.doesResize
              }), e());
            }
          }
        )
      ] })
    ] }) : /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(lb, { className: "tlui-embed-dialog__list", children: Qg.map((_) => /* @__PURE__ */ E.jsxs(
        "button",
        {
          className: "tlui-embed-dialog__item",
          onClick: () => c(_),
          children: [
            /* @__PURE__ */ E.jsx("div", { className: "tlui-embed-dialog__item__image", children: /* @__PURE__ */ E.jsx(
              "div",
              {
                className: "tlui-embed-dialog__item__image__img",
                style: {
                  backgroundImage: `url(${a.embedIcons[_.type]})`
                }
              }
            ) }),
            /* @__PURE__ */ E.jsx("div", { className: "tlui-embed-dialog__item__title", children: _.title })
          ]
        },
        _.type
      )) }),
      /* @__PURE__ */ E.jsx("div", { className: "tlui-dialog__scrim" })
    ] })
  ] });
}), n5 = k.createContext({});
function Gce({ overrides: t, children: e }) {
  const n = Ge(), { addDialog: r } = Fp(), a = B4(), s = k.useMemo(() => {
    const c = Xce([
      {
        id: "select",
        label: "tool.select",
        icon: "tool-pointer",
        kbd: "v",
        readonlyOk: !0,
        onSelect() {
          n.setSelectedTool("select");
        }
      },
      {
        id: "hand",
        label: "tool.hand",
        icon: "tool-hand",
        kbd: "h",
        readonlyOk: !0,
        onSelect() {
          n.setSelectedTool("hand");
        }
      },
      {
        id: "eraser",
        label: "tool.eraser",
        icon: "tool-eraser",
        kbd: "e",
        readonlyOk: !0,
        onSelect() {
          n.setSelectedTool("eraser");
        }
      },
      {
        id: "draw",
        label: "tool.draw",
        readonlyOk: !0,
        icon: "tool-pencil",
        kbd: "d,b,x",
        onSelect() {
          n.setSelectedTool("draw");
        }
      },
      ...[...yL].map((f) => ({
        id: f,
        label: `tool.${f}`,
        readonlyOk: !0,
        meta: {
          geo: f
        },
        kbd: f === "rectangle" ? "r" : f === "ellipse" ? "o" : void 0,
        icon: "geo-" + f,
        onSelect() {
          n.batch(() => {
            n.updateInstanceState(
              { propsForNextShape: { ...n.instanceState.propsForNextShape, geo: f } },
              !0
            ), n.setSelectedTool("geo");
          });
        }
      })),
      {
        id: "arrow",
        label: "tool.arrow",
        readonlyOk: !0,
        icon: "tool-arrow",
        kbd: "a",
        onSelect() {
          n.setSelectedTool("arrow");
        }
      },
      {
        id: "line",
        label: "tool.line",
        readonlyOk: !0,
        icon: "tool-line",
        kbd: "l",
        onSelect() {
          n.setSelectedTool("line");
        }
      },
      {
        id: "frame",
        label: "tool.frame",
        readonlyOk: !0,
        icon: "tool-frame",
        kbd: "f",
        onSelect() {
          n.setSelectedTool("frame");
        }
      },
      {
        id: "text",
        label: "tool.text",
        readonlyOk: !0,
        icon: "tool-text",
        kbd: "t",
        onSelect() {
          n.setSelectedTool("text");
        }
      },
      {
        id: "asset",
        label: "tool.asset",
        readonlyOk: !0,
        icon: "tool-media",
        kbd: "$u",
        onSelect() {
          a();
        }
      },
      {
        id: "note",
        label: "tool.note",
        readonlyOk: !0,
        icon: "tool-note",
        kbd: "n",
        onSelect() {
          n.setSelectedTool("note");
        }
      },
      {
        id: "embed",
        label: "tool.embed",
        readonlyOk: !0,
        icon: "tool-embed",
        onSelect() {
          r({ component: Wce });
        }
      }
    ]);
    return t ? t(n, c, { insertMedia: a }) : c;
  }, [n, t, a, r]);
  return /* @__PURE__ */ E.jsx(n5.Provider, { value: s, children: e });
}
function Xce(t) {
  return Object.fromEntries(t.map((e) => [e.id, e]));
}
function E2() {
  const t = k.useContext(n5);
  if (!t)
    throw new Error("useTools must be used within a ToolProvider");
  return t;
}
const AN = [
  // we set these in useNativeClipboardEvents instead
  "copy",
  "cut",
  "paste",
  // There's also an upload asset action, so we don't want to set the kbd twice
  "asset"
];
function qce() {
  const t = Ge(), e = Bu(), n = va(), r = E2();
  k.useEffect(() => {
    const a = () => t.isMenuOpen || t.editingId !== null || t.crashingError;
    for (const s of Object.values(n))
      s.kbd && (e && !s.readonlyOk || AN.includes(s.id) || la(ON(s.kbd), (c) => {
        a() || (Gn(c), s.onSelect());
      }));
    for (const s of Object.values(r))
      s.kbd && (AN.includes(s.id) || la(ON(s.kbd), (c) => {
        a() || (Gn(c), s.onSelect());
      }));
    return la("g", () => {
      a() || t.setSelectedTool("geo");
    }), la("backspace,del", () => {
      a() || n.delete.onSelect();
    }), la("=", () => {
      a() || n["zoom-in"].onSelect();
    }), la("-", () => {
      a() || n["zoom-out"].onSelect();
    }), () => {
      la.unbind();
    };
  }, [n, r, e, t]);
}
function ON(t) {
  let e = "";
  const n = t.split("");
  return n.length === 1 ? e = n[0] : n[0] === "!" ? e = `shift+${n[1]}` : n[0] === "?" ? e = `alt+${n[1]}` : n[0] === "$" ? n[1] === "!" ? e = `cmd+shift+${n[2]},ctrl+shift+${n[2]}` : n[1] === "?" ? e = `cmd+⌥+${n[2]},ctrl+alt+${n[2]}` : e = `cmd+${n[1]},ctrl+${n[1]}` : e = t, e;
}
const r5 = It.createContext(
  {}
), Qce = dn(function({
  overrides: e,
  children: n
}) {
  const r = Ge(), a = E2(), s = va(), c = k.useMemo(() => {
    const f = Gt([
      wn(
        "shortcuts-dialog.tools",
        Ie(s["toggle-tool-lock"]),
        Ie(a.select),
        Ie(a.draw),
        Ie(a.eraser),
        Ie(a.hand),
        Ie(a.rectangle),
        Ie(a.ellipse),
        Ie(a.arrow),
        Ie(a.line),
        Ie(a.text),
        Ie(a.frame),
        Ie(a.note)
      ),
      wn(
        "shortcuts-dialog.file",
        Ie(s["insert-media"]),
        Ie(s.print)
      ),
      wn(
        "shortcuts-dialog.preferences",
        Ie(s["toggle-dark-mode"]),
        Ie(s["toggle-focus-mode"]),
        Ie(s["toggle-grid"])
      ),
      wn(
        "shortcuts-dialog.edit",
        Ie(s.undo),
        Ie(s.redo),
        Ie(s.cut),
        Ie(s.copy),
        Ie(s.paste),
        Ie(s["select-all"]),
        Ie(s.delete),
        Ie(s.duplicate),
        Ie(s["export-as-svg"]),
        Ie(s["export-as-png"])
      ),
      wn(
        "shortcuts-dialog.view",
        Ie(s["zoom-in"]),
        Ie(s["zoom-out"]),
        Ie(s["zoom-to-100"]),
        Ie(s["zoom-to-fit"]),
        Ie(s["zoom-to-selection"])
      ),
      wn(
        "shortcuts-dialog.transform",
        Ie(s["bring-to-front"]),
        Ie(s["bring-forward"]),
        Ie(s["send-backward"]),
        Ie(s["send-to-back"]),
        Ie(s.group),
        Ie(s.ungroup),
        Ie(s["flip-horizontal"]),
        Ie(s["flip-vertical"]),
        Ie(s["align-top"]),
        Ie(s["align-center-vertical"]),
        Ie(s["align-bottom"]),
        Ie(s["align-left"]),
        Ie(s["align-center-horizontal"]),
        Ie(s["align-right"])
      )
    ]);
    return e ? e(r, f, { tools: a, actions: s }) : f;
  }, [r, e, s, a]);
  return /* @__PURE__ */ E.jsx(r5.Provider, { value: c, children: n });
});
function Zce() {
  const t = It.useContext(r5);
  if (!t)
    throw new Error("Shortcuts must be used inside of a ShortcutsProvider.");
  return t;
}
function Jce(t, e) {
  const [n, r] = It.useState(e);
  It.useLayoutEffect(() => {
    const s = localStorage.getItem(t);
    if (s)
      try {
        r(JSON.parse(s));
      } catch {
        console.error(`Could not restore value ${t} from local storage.`);
      }
  }, [t]);
  const a = It.useCallback(
    (s) => {
      r((c) => {
        const f = typeof s == "function" ? s(c) : s;
        return localStorage.setItem(t, JSON.stringify(f)), f;
      });
    },
    [t]
  );
  return [n, a];
}
function pm(t, e) {
  const n = Ge(), r = k.useRef(!1), a = k.useCallback(
    (s) => {
      r.current = s, s ? (n.complete(), n.openMenus.add(t)) : (n.openMenus.delete(t), n.openMenus.forEach((c) => {
        c.startsWith(t) && n.openMenus.delete(c);
      })), e?.(s);
    },
    [n, t, e]
  );
  return k.useEffect(() => (r.current && n.openMenus.add(t), () => {
    r.current && (n.openMenus.delete(t), n.openMenus.forEach((s) => {
      s.startsWith(t) && n.openMenus.delete(s);
    }), r.current = !1);
  }), [n, t]), a;
}
const i5 = It.createContext({});
function eue({ overrides: t, children: e }) {
  const n = Ge(), r = va(), s = Gs() < 5, c = un("isDarkMode", () => n.userDocumentSettings.isDarkMode, [n]), f = un("isGridMode", () => n.userDocumentSettings.isGridMode, [n]), p = un("isSnapMode", () => n.userDocumentSettings.isSnapMode, [n]), g = un("isToolLock", () => n.instanceState.isToolLocked, [n]), y = un("isFocusMode", () => n.instanceState.isFocusMode, [n]), v = un("isDebugMode", () => n.instanceState.isDebugMode, [n]), S = un("exportBackground", () => n.instanceState.exportBackground, [
    n
  ]), x = un("emptyPage", () => n.shapeIds.size === 0, [n]), _ = un("selectedCount", () => n.selectedIds.length, [n]), T = _ === 0, I = _ > 0, D = _ > 1, N = _ > 2, j = !!window.navigator.clipboard?.write, L = x2(), z = W4(), F = l2(), K = c2(), X = K4(), se = Y4(), ue = un("isZoomedTo100", () => n.camera.z === 1, [n]), pe = k.useMemo(() => {
    const Pe = Gt([
      wn(
        "menu",
        Ec(
          "file",
          "menu.file",
          wn("print", Ie(r.print, { disabled: x }))
        ),
        Ec(
          "edit",
          "menu.edit",
          wn(
            "undo-actions",
            Ie(r.undo, { disabled: !X }),
            Ie(r.redo, { disabled: !se })
          ),
          wn(
            "clipboard-actions",
            Ie(r.cut, { disabled: T }),
            Ie(r.copy, { disabled: T }),
            {
              id: "MENU_PASTE",
              type: "custom",
              disabled: !zse,
              readonlyOk: !1
            }
          ),
          wn(
            "conversions",
            Ec(
              "copy-as",
              "menu.copy-as",
              wn(
                "copy-as-group",
                Ie(r["copy-as-svg"], { disabled: x }),
                Ie(r["copy-as-png"], { disabled: x || !j }),
                Ie(r["copy-as-json"], { disabled: x })
              ),
              wn(
                "export-bg",
                Ie(r["toggle-transparent"], { checked: !S })
              )
            ),
            Ec(
              "export-as",
              "menu.export-as",
              wn(
                "export-as-group",
                Ie(r["export-as-svg"], { disabled: x }),
                Ie(r["export-as-png"], { disabled: x }),
                Ie(r["export-as-json"], { disabled: x })
              ),
              wn(
                "export-bg",
                Ie(r["toggle-transparent"], { checked: !S })
              )
            )
          ),
          wn(
            "set-selection-group",
            Ie(r["select-all"], { disabled: x }),
            Ie(r["select-none"], { disabled: !I })
          ),
          wn(
            "selection",
            z && Ie(r["toggle-auto-size"]),
            L && Ie(r["edit-link"]),
            Ie(r.duplicate, { disabled: !I }),
            F && Ie(r.group),
            K && Ie(r.ungroup)
          ),
          wn("delete-group", Ie(r.delete, { disabled: !I }))
        ),
        Ec(
          "view",
          "menu.view",
          wn(
            "view-actions",
            Ie(r["zoom-in"]),
            Ie(r["zoom-out"]),
            Ie(r["zoom-to-100"], { disabled: ue }),
            Ie(r["zoom-to-fit"], { disabled: x }),
            Ie(r["zoom-to-selection"], { disabled: x || !I })
          )
        ),
        Ie(r["insert-media"])
      ),
      wn(
        "preferences",
        Ec(
          "preferences",
          "menu.preferences",
          wn(
            "preferences-actions",
            Ie(r["toggle-snap-mode"], { checked: p }),
            Ie(r["toggle-tool-lock"], { checked: g }),
            Ie(r["toggle-grid"], { checked: f }),
            Ie(r["toggle-dark-mode"], { checked: c }),
            Ie(r["toggle-focus-mode"], { checked: y }),
            Ie(r["toggle-debug-mode"], { checked: v })
          )
        ),
        s && Yx("LANGUAGE_MENU", { readonlyOk: !0 })
      )
    ]);
    return t ? t(n, Pe, {
      actions: r,
      noneSelected: T,
      oneSelected: I,
      twoSelected: D,
      threeSelected: N
    }) : Pe;
  }, [
    n,
    t,
    r,
    I,
    D,
    N,
    x,
    s,
    F,
    K,
    L,
    j,
    z,
    T,
    X,
    se,
    c,
    f,
    p,
    g,
    y,
    S,
    v,
    ue
  ]);
  return /* @__PURE__ */ E.jsx(i5.Provider, { value: pe, children: e });
}
function tue() {
  const t = It.useContext(i5);
  if (!t)
    throw new Error("useMenuSchema must be used inside of a MenuSchemaProvider.");
  return t;
}
function wr(t) {
  return {
    id: t.id,
    type: "item",
    readonlyOk: t.readonlyOk,
    toolItem: t
  };
}
const o5 = It.createContext([]);
function nue({ overrides: t, children: e }) {
  const n = Ge(), r = E2(), a = It.useMemo(() => {
    const s = [
      wr(r.select),
      wr(r.hand),
      wr(r.draw),
      wr(r.eraser),
      wr(r.arrow),
      wr(r.text),
      wr(r.note),
      wr(r.asset),
      wr(r.rectangle),
      wr(r.ellipse),
      wr(r.diamond),
      wr(r.triangle),
      wr(r.trapezoid),
      wr(r.rhombus),
      wr(r.pentagon),
      wr(r.hexagon),
      wr(r.octagon),
      wr(r.star),
      wr(r.oval),
      wr(r["x-box"]),
      wr(r["arrow-right"]),
      wr(r["arrow-left"]),
      wr(r["arrow-up"]),
      wr(r["arrow-down"]),
      wr(r.line),
      wr(r.frame),
      wr(r.embed)
    ];
    return t ? t(n, s, { tools: r }) : s;
  }, [n, t, r]);
  return /* @__PURE__ */ E.jsx(o5.Provider, { value: a, children: e });
}
function rue() {
  const t = It.useContext(o5);
  if (!t)
    throw new Error("useToolbarSchema must be used within a ToolbarSchemaProvider");
  return t;
}
const iue = dn(function() {
  const e = Ge(), n = ga(), r = e.pages, a = e.currentPageId, s = Fn();
  return /* @__PURE__ */ E.jsxs(n4, { children: [
    /* @__PURE__ */ E.jsx(r4, { dir: "ltr", asChild: !0, children: /* @__PURE__ */ E.jsx(
      At,
      {
        className: "tlui-menu__button",
        label: "context-menu.move-to-page",
        "data-wd": "menu-item.move-to-page",
        icon: "chevron-right"
      }
    ) }),
    /* @__PURE__ */ E.jsx(TP, { container: n, dir: "ltr", children: /* @__PURE__ */ E.jsxs(i4, { className: "tlui-menu", sideOffset: -4, collisionPadding: 4, children: [
      /* @__PURE__ */ E.jsx(
        kP,
        {
          dir: "ltr",
          className: "tlui-menu__group",
          "data-wd": "menu-item.pages",
          children: r.map((c) => /* @__PURE__ */ E.jsx(
            Vx,
            {
              disabled: a === c.id,
              onSelect: () => {
                e.mark("move_shapes_to_page"), e.moveShapesToPage(e.selectedIds, c.id);
              },
              asChild: !0,
              children: /* @__PURE__ */ E.jsx(
                At,
                {
                  title: c.name,
                  className: "tlui-menu__button tlui-context-menu__move-to-page__name",
                  children: /* @__PURE__ */ E.jsx("span", { children: c.name })
                }
              )
            },
            c.id
          ))
        },
        "pages"
      ),
      /* @__PURE__ */ E.jsx(
        kP,
        {
          dir: "ltr",
          className: "tlui-menu__group",
          "data-wd": "menu-item.new-page",
          children: /* @__PURE__ */ E.jsx(
            Vx,
            {
              onSelect: () => {
                e.mark("move_shapes_to_page");
                const c = fr.createId(), f = e.selectedIds, p = e.currentPageId;
                e.batch(() => {
                  e.createPage("Page 1", c), e.setCurrentPageId(p), e.moveShapesToPage(f, c);
                });
              },
              asChild: !0,
              children: /* @__PURE__ */ E.jsx(
                At,
                {
                  title: s("context.pages.new-page"),
                  className: "tlui-menu__button tlui-context-menu__move-to-page__name",
                  children: s("context.pages.new-page")
                }
              )
            },
            "new-page"
          )
        },
        "new-page"
      )
    ] }) })
  ] });
}), oue = function({ children: e }) {
  const n = Ge(), r = X4(), a = pm("context menu"), s = Bu(), c = r.length === 0 || s && r.every((g) => !g.readonlyOk), p = !un("isSelectToolActive", () => n.currentToolId === "select", [
    n
  ]) || c;
  return /* @__PURE__ */ E.jsxs(Dse, { dir: "ltr", onOpenChange: a, children: [
    /* @__PURE__ */ E.jsx(
      Nse,
      {
        onContextMenu: p ? Gn : void 0,
        dir: "ltr",
        disabled: p,
        children: e
      }
    ),
    /* @__PURE__ */ E.jsx(aue, {})
  ] });
};
function aue() {
  const t = Ge(), e = Fn(), n = X4(), r = pm("context menu sub"), a = Bu(), { paste: s } = b2(), c = Gs(), f = ga(), [p, g] = k.useState(!1);
  function y(v, S, x, _) {
    if (a && !S.readonlyOk)
      return null;
    switch (S.type) {
      case "custom": {
        switch (S.id) {
          case "MENU_PASTE":
            return /* @__PURE__ */ E.jsx(Vx, { children: /* @__PURE__ */ E.jsx(
              At,
              {
                className: "tlui-menu__button",
                "data-wd": `menu-item.${S.id}`,
                kbd: "$v",
                label: "action.paste",
                disabled: S.disabled,
                onClick: () => {
                  (!v.isSafari || v.isSafari && v.isIos) && navigator.clipboard.read().then((T) => {
                    s(T, v.inputs.currentPagePoint);
                  });
                },
                onMouseDown: () => {
                  v.isSafari && !v.isIos && navigator.clipboard.read().then((T) => {
                    s(T, v.inputs.currentPagePoint);
                  });
                }
              }
            ) }, S.id);
          case "MOVE_TO_PAGE_MENU":
            return /* @__PURE__ */ E.jsx(iue, {}, S.id);
        }
        break;
      }
      case "group":
        return /* @__PURE__ */ E.jsx(
          kP,
          {
            dir: "ltr",
            className: $n("tlui-menu__group", {
              "tlui-menu__group__small": x?.type === "submenu"
            }),
            "data-wd": `menu-item.${S.id}`,
            children: S.children.map((T) => y(v, T, S, _ + 1))
          },
          S.id
        );
      case "submenu":
        return /* @__PURE__ */ E.jsxs(n4, { onOpenChange: r, children: [
          /* @__PURE__ */ E.jsx(r4, { dir: "ltr", disabled: S.disabled, asChild: !0, children: /* @__PURE__ */ E.jsx(
            At,
            {
              className: "tlui-menu__button",
              label: S.label,
              "data-wd": `menu-item.${S.id}`,
              icon: "chevron-right"
            }
          ) }),
          /* @__PURE__ */ E.jsx(TP, { container: f, dir: "ltr", children: /* @__PURE__ */ E.jsx(i4, { className: "tlui-menu", sideOffset: -4, collisionPadding: 4, children: S.children.map((T) => y(v, T, S, _ + 1)) }) })
        ] }, S.id);
      case "item": {
        if (a && !S.readonlyOk)
          return null;
        const { id: T, checkbox: I, contextMenuLabel: D, label: N, onSelect: j, kbd: L, icon: z } = S.actionItem, F = D ?? N, K = F ? e(F) : void 0;
        return I ? /* @__PURE__ */ E.jsxs(
          jse,
          {
            className: "tlui-button tlui-menu__button tlui-menu__checkbox-item",
            dir: "ltr",
            disabled: S.disabled,
            onSelect: (X) => {
              j(), Gn(X);
            },
            title: K || void 0,
            checked: S.checked,
            children: [
              /* @__PURE__ */ E.jsx(
                "div",
                {
                  className: "tlui-menu__checkbox-item__check",
                  style: {
                    transformOrigin: "75% center",
                    transform: `scale(${S.checked ? 1 : 0.5})`,
                    opacity: S.checked ? 1 : 0.5
                  },
                  children: /* @__PURE__ */ E.jsx(Ya, { small: !0, icon: S.checked ? "check" : "checkbox-empty" })
                }
              ),
              K && /* @__PURE__ */ E.jsx("span", { children: K }),
              L && /* @__PURE__ */ E.jsx(A1, { children: L })
            ]
          },
          T
        ) : /* @__PURE__ */ E.jsx(Vx, { dir: "ltr", asChild: !0, children: /* @__PURE__ */ E.jsx(
          At,
          {
            className: "tlui-menu__button",
            "data-wd": `menu-item.${T}`,
            kbd: L,
            label: F,
            disabled: S.disabled,
            iconLeft: c < 3 && _ > 2 ? z : void 0,
            onClick: () => {
              p ? g(!1) : j();
            }
          }
        ) }, T);
      }
    }
  }
  return /* @__PURE__ */ E.jsx(TP, { dir: "ltr", container: f, children: /* @__PURE__ */ E.jsx(
    Lse,
    {
      className: "tlui-menu scrollable",
      alignOffset: -4,
      collisionPadding: 4,
      onContextMenu: Gn,
      children: n.map((v) => y(t, v, null, 0))
    }
  ) });
}
let DN = 0;
function sue(t, e) {
  const n = Array(e), r = Math.floor(Math.sqrt(e));
  for (let a = 0; a < e; a++)
    DN++, n[a] = {
      id: t.createShapeId("box" + DN),
      type: "geo",
      x: a % r * 132,
      y: Math.floor(a / r) * 132
    };
  t.batch(() => {
    t.createShapes(n).setSelectedIds(n.map((a) => a.id));
  });
}
const lue = k.memo(function({
  renderDebugMenuItems: e
}) {
  return /* @__PURE__ */ E.jsxs("div", { className: "tlui-debug-panel", children: [
    /* @__PURE__ */ E.jsx(cue, {}),
    /* @__PURE__ */ E.jsx(uue, {}),
    /* @__PURE__ */ E.jsxs(tf, { id: "debug", children: [
      /* @__PURE__ */ E.jsx(Rb, { children: /* @__PURE__ */ E.jsx(At, { icon: "dots-horizontal" }) }),
      /* @__PURE__ */ E.jsx(nf, { side: "top", align: "end", alignOffset: 0, children: /* @__PURE__ */ E.jsx(due, { renderDebugMenuItems: e }) })
    ] })
  ] });
}), cue = dn(function() {
  const e = Ge();
  return /* @__PURE__ */ E.jsx("div", { className: "tlui-debug-panel__current-state", children: e.root.path.value });
}), uue = dn(function() {
  const e = Ge();
  return /* @__PURE__ */ E.jsxs("div", { children: [
    e.renderingShapes.length,
    " Shapes"
  ] });
});
function due({
  renderDebugMenuItems: t
}) {
  const e = Ge(), { addToast: n } = Uu(), { addDialog: r } = Fp(), [a, s] = k.useState(!1);
  return /* @__PURE__ */ E.jsxs(Dp, { children: [
    (() => {
      if (a)
        throw Error("oh no!");
    })(),
    /* @__PURE__ */ E.jsx(
      Vo,
      {
        onClick: () => {
          s(!0);
        },
        children: /* @__PURE__ */ E.jsx("span", { children: "Throw Error" })
      }
    ),
    /* @__PURE__ */ E.jsx(
      Vo,
      {
        onClick: () => {
          n({
            id: Ii(),
            title: "Something happened",
            description: "Hey, attend to this thing over here. It might be important!"
            // icon?: string
            // title?: string
            // description?: string
            // actions?: TLToastAction[]
          });
        },
        children: /* @__PURE__ */ E.jsx("span", { children: "Show Toast" })
      }
    ),
    /* @__PURE__ */ E.jsx(
      Vo,
      {
        onClick: () => {
          r({
            component: ({ onClose: c }) => /* @__PURE__ */ E.jsx(
              fue,
              {
                onCancel: () => {
                  c();
                },
                onContinue: () => {
                  c();
                }
              }
            ),
            onClose: () => {
            }
          });
        },
        children: "Show Dialog"
      }
    ),
    /* @__PURE__ */ E.jsx(
      Vo,
      {
        onClick: () => {
          e.updateUserDocumentSettings({ isReadOnly: !e.isReadOnly });
        },
        children: /* @__PURE__ */ E.jsx("span", { children: "Toggle Read Only" })
      }
    ),
    /* @__PURE__ */ E.jsx(
      Vo,
      {
        onClick: () => {
          fs.peopleMenu.set(!fs.peopleMenu.value);
        },
        children: /* @__PURE__ */ E.jsx("span", { children: "Toggle People Menu" })
      }
    ),
    /* @__PURE__ */ E.jsx(
      Vo,
      {
        label: "debug-menu.hard-reset",
        onClick: () => {
          window.__tldraw__hardReset();
        }
      }
    ),
    /* @__PURE__ */ E.jsx(Vo, { label: "debug-menu.create-shapes", onClick: () => sue(e, 100) }),
    /* @__PURE__ */ E.jsx(
      Vo,
      {
        onClick: () => {
          function c({ children: v }) {
            let S = 0;
            if (!v.length)
              return 0;
            for (const x of [...v])
              S++, S += c(x);
            return S;
          }
          const { selectedShapes: f } = e, p = f.length === 0 ? e.renderingShapes : f, g = p.map(
            (v) => document.getElementById(v.id).parentElement
          );
          let y = g.length;
          for (const v of g)
            y += c(v);
          window.alert(`Shapes ${p.length}, DOM nodes:${y}`);
        },
        children: /* @__PURE__ */ E.jsx("span", { children: "Count Shapes and Nodes" })
      }
    ),
    t?.()
  ] });
}
function fue({ onCancel: t, onContinue: e }) {
  const [n, r] = k.useState(!1);
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsxs(O1, { children: [
      /* @__PURE__ */ E.jsx(D1, { children: "Hello" }),
      /* @__PURE__ */ E.jsx(N1, {})
    ] }),
    /* @__PURE__ */ E.jsx(lb, { style: { maxWidth: 350 }, children: "Hello Hello Hello" }),
    /* @__PURE__ */ E.jsxs(u2, { className: "tlui-dialog__footer__actions", children: [
      /* @__PURE__ */ E.jsx(
        At,
        {
          onClick: () => r(!n),
          iconLeft: n ? "checkbox-checked" : "checkbox-empty",
          style: { marginRight: "auto" },
          children: "Don't show again"
        }
      ),
      /* @__PURE__ */ E.jsx(At, { onClick: t, children: "Cancel" }),
      /* @__PURE__ */ E.jsx(
        At,
        {
          type: "primary",
          onClick: async () => {
            e();
          },
          children: "Continue"
        }
      )
    ] })
  ] });
}
dn(function() {
  const e = Ge(), n = k.useRef(null), r = e.camera, a = e.shapesArray;
  if (n.current) {
    const s = n.current, c = s.getContext("2d");
    c.resetTransform(), c.clearRect(0, 0, s.width, s.height);
    const f = new Path2D();
    c.translate(r.x, r.y);
    for (const p of a) {
      const g = e.getPageBounds(p);
      f.rect(g.minX, g.minY, g.width, g.height);
    }
    c.fillStyle = "#cccccc", c.fill(f);
    for (const p of a)
      c.save(), e.getPageCorners(p).forEach((y) => pue(c, y.x, y.y, "red")), c.restore();
  }
  return /* @__PURE__ */ E.jsx(
    "canvas",
    {
      ref: n,
      width: e.viewportScreenBounds.width,
      height: e.viewportScreenBounds.height,
      style: { width: "100%", height: "100%" }
    }
  );
});
function pue(t, e, n, r = "#000") {
  t.save(), t.beginPath(), t.ellipse(e, n, 4, 4, 0, 0, Math.PI * 2), t.fillStyle = r, t.fill(), t.restore();
}
function a5() {
  const t = Ge(), { languages: e, currentLanguage: n } = L4(), r = k.useCallback(
    (a) => {
      t.updateUser({ locale: a });
    },
    [t]
  );
  return /* @__PURE__ */ E.jsxs(f2, { id: "help menu language", children: [
    /* @__PURE__ */ E.jsx(p2, { label: "menu.language", "data-direction": "left" }),
    /* @__PURE__ */ E.jsx(h2, { sideOffset: -4, children: /* @__PURE__ */ E.jsx(Dp, { children: e.map(({ locale: a, label: s }) => /* @__PURE__ */ E.jsx(
      Tle,
      {
        title: a,
        checked: a === n,
        onSelect: () => r(a),
        children: /* @__PURE__ */ E.jsx("span", { children: s })
      },
      a
    )) }) })
  ] });
}
const hue = k.memo(function() {
  const e = ga(), n = Fn(), r = pm("help menu");
  return /* @__PURE__ */ E.jsx("div", { className: "tlui-help-menu", children: /* @__PURE__ */ E.jsxs(y4, { dir: "ltr", onOpenChange: r, modal: !1, children: [
    /* @__PURE__ */ E.jsx(
      cb,
      {
        className: "tlui-button tlui-help-menu__button",
        dir: "ltr",
        title: n("help-menu.title"),
        children: /* @__PURE__ */ E.jsx(Ya, { icon: "question-mark" })
      }
    ),
    /* @__PURE__ */ E.jsx(d2, { container: e, dir: "ltr", children: /* @__PURE__ */ E.jsx(
      b4,
      {
        className: "tlui-menu",
        side: "top",
        sideOffset: 8,
        align: "end",
        alignOffset: 0,
        collisionPadding: 4,
        children: /* @__PURE__ */ E.jsx(gue, {})
      }
    ) })
  ] }) });
});
function gue() {
  const t = Ace(), e = Bu();
  function n(r) {
    if (e && !r.readonlyOk)
      return null;
    switch (r.type) {
      case "custom": {
        if (r.id === "LANGUAGE_MENU")
          return /* @__PURE__ */ E.jsx(a5, {}, "item");
        break;
      }
      case "group":
        return /* @__PURE__ */ E.jsx(Dp, { size: "small", children: r.children.map(n) }, r.id);
      case "submenu":
        return /* @__PURE__ */ E.jsxs(f2, { id: `help menu ${r.id}`, children: [
          /* @__PURE__ */ E.jsx(p2, { label: r.label }),
          /* @__PURE__ */ E.jsx(h2, { children: r.children.map(n) })
        ] }, r.id);
      case "item": {
        const { id: a, kbd: s, label: c, onSelect: f, icon: p } = r.actionItem;
        return /* @__PURE__ */ E.jsx(Vo, { kbd: s, label: c, onClick: f, iconLeft: p }, a);
      }
    }
  }
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: t.map(n) });
}
class Yy {
  constructor(e, n) {
    this.app = e, this.dpr = n;
  }
  colors = {
    shapeFill: "rgba(144, 144, 144, .1)",
    selectFill: "#2f80ed",
    viewportFill: "rgba(144, 144, 144, .1)"
  };
  id = Ii();
  cvs = null;
  pageBounds = [];
  collaborators = [];
  canvasScreenBounds = new ot();
  canvasPageBounds = new ot();
  contentPageBounds = new ot();
  contentScreenBounds = new ot();
  originPagePoint = new O();
  originPageCenter = new O();
  isInViewport = !1;
  debug = !1;
  setDpr(e) {
    this.dpr = +e.toFixed(2);
  }
  updateContentScreenBounds = () => {
    const { contentScreenBounds: e, contentPageBounds: n, canvasScreenBounds: r } = this;
    let { x: a, y: s, w: c, h: f } = e;
    if (n.w > n.h) {
      const p = r.w / (n.w / n.h);
      p > r.h ? (a = (r.w - r.w * (r.h / p)) / 2, s = 0, c = r.w * (r.h / p), f = r.h) : (a = 0, s = (r.h - p) / 2, c = r.w, f = p);
    } else if (n.w < n.h) {
      const p = r.h / (n.h / n.w);
      a = (r.w - p) / 2, s = 0, c = p, f = r.h;
    } else
      a = r.h / 2, s = 0, c = r.h, f = r.h;
    e.set(a, s, c, f);
  };
  /**
   * Get the canvas's true bounds converted to page bounds.
   */
  updateCanvasPageBounds = () => {
    const { canvasPageBounds: e, canvasScreenBounds: n, contentPageBounds: r, contentScreenBounds: a } = this;
    e.set(
      0,
      0,
      r.width / (a.width / n.width),
      r.height / (a.height / n.height)
    ), e.center = r.center;
  };
  getScreenPoint = (e, n) => {
    const { canvasScreenBounds: r } = this, a = (e - r.minX) * this.dpr, s = (n - r.minY) * this.dpr;
    return { x: a, y: s };
  };
  getPagePoint = (e, n) => {
    const { contentPageBounds: r, contentScreenBounds: a, canvasPageBounds: s } = this, { x: c, y: f } = this.getScreenPoint(e, n);
    return {
      x: s.minX + c * r.width / a.width,
      y: s.minY + f * r.height / a.height,
      z: 1
    };
  };
  minimapScreenPointToPagePoint = (e, n, r = !1, a = !1) => {
    const { app: s } = this, { viewportPageBounds: c } = s;
    let { x: f, y: p } = this.getPagePoint(e, n);
    if (a) {
      const g = this.app.allShapesCommonBounds, y = c, v = (g?.minX ?? 0) - y.width / 2, S = (g?.maxX ?? 0) + y.width / 2, x = (g?.minY ?? 0) - y.height / 2, _ = (g?.maxY ?? 0) + y.height / 2, T = Math.max(0, v + y.width - f), I = Math.max(0, -(S - y.width - f)), D = Math.max(0, x + y.height - p), N = Math.max(0, -(_ - y.height - p)), j = Math.max(0, T - I), L = Math.max(0, I - T), z = Math.max(0, D - N), F = Math.max(0, N - D);
      j && j > L ? f += j / 2 : L && (f -= L / 2), z && z > F ? p += z / 2 : F && (p -= F / 2), f = Iu(f, v, S), p = Iu(p, x, _);
    }
    if (r) {
      const { originPagePoint: g } = this, y = Math.abs(f - g.x), v = Math.abs(p - g.y);
      y > v ? p = g.y : f = g.x;
    }
    return { x: f, y: p };
  };
  render = () => {
    const { cvs: e, pageBounds: n } = this;
    this.updateCanvasPageBounds();
    const { app: r, canvasScreenBounds: a, canvasPageBounds: s, contentPageBounds: c, contentScreenBounds: f } = this, { width: p, height: g } = a, { viewportPageBounds: y, selectedIds: v } = r;
    if (!e || !n)
      return;
    const S = e.getContext("2d");
    if (!S)
      throw new Error("Minimap (shapes): Could not get context");
    S.resetTransform(), S.globalAlpha = 1, S.clearRect(0, 0, p, g);
    const x = f.width / c.width, _ = f.height / c.height;
    S.translate((p - f.width) / 2, (g - f.height) / 2), S.scale(x, _), S.translate(-c.minX, -c.minY);
    const T = 8 / x, I = 8 / x, D = 1 / x, N = 1 / x, j = T / 4, L = I / 4, z = new Path2D(), F = new Path2D(), { shapeFill: K, selectFill: X, viewportFill: se } = this.colors;
    let ue;
    for (let le = 0, Re = n.length; le < Re; le++)
      ue = n[le], Yy.roundedRect(
        v.includes(ue.id) ? F : z,
        ue.minX,
        ue.minY,
        ue.width,
        ue.height,
        Iu(T, D, ue.width / j),
        Iu(I, N, ue.height / L)
      );
    if (S.fillStyle = K, S.fill(z), S.fillStyle = X, S.fill(F), this.debug) {
      const le = ot.Common(n), { minX: Re, minY: he, width: te, height: de } = le;
      S.strokeStyle = "green", S.lineWidth = 2 / x, S.strokeRect(Re + 1 / x, he + 1 / _, te - 2 / x, de - 2 / _);
    }
    {
      const { brush: le } = r;
      if (le) {
        const { x: Re, y: he, w: te, h: de } = le;
        S.beginPath(), Yy.sharpRect(S, Re, he, te, de), S.closePath(), S.fillStyle = se, S.fill();
      }
    }
    {
      const { minX: le, minY: Re, width: he, height: te } = y;
      S.beginPath();
      const de = 12 / x, W = 12 / x;
      Yy.roundedRect(
        S,
        le,
        Re,
        he,
        te,
        Math.min(he / 4, de),
        Math.min(te / 4, W)
      ), S.closePath(), S.fillStyle = se, S.fill(), this.debug && (S.strokeStyle = "orange", S.strokeRect(le + 1 / x, Re + 1 / _, he - 2 / x, te - 2 / _));
    }
    const pe = 2.5 / x, Pe = 2.5 / _, { currentPageId: ve } = r;
    let Y;
    for (let le = 0; le < this.collaborators.length; le++)
      Y = this.collaborators[le], (Y.lastUsedInstanceId ? r.store.get(Y.lastUsedInstanceId) : null)?.currentPageId === ve && (S.beginPath(), S.ellipse(
        Iu(Y.cursor.x, s.minX + pe, s.maxX - pe),
        Iu(Y.cursor.y, s.minY + Pe, s.maxY - Pe),
        5 / x,
        5 / _,
        0,
        0,
        Kr
      ), S.fillStyle = Y.color, S.fill());
    if (this.debug) {
      S.lineWidth = 2 / x;
      {
        const { minX: le, minY: Re, width: he, height: te } = c;
        S.strokeStyle = "red", S.strokeRect(le + 1 / x, Re + 1 / _, he - 2 / x, te - 2 / _);
      }
      {
        const { minX: le, minY: Re, width: he, height: te } = s;
        S.strokeStyle = "blue", S.strokeRect(le + 1 / x, Re + 1 / _, he - 2 / x, te - 2 / _);
      }
    }
  };
  static roundedRect(e, n, r, a, s, c, f) {
    if (c < 1 && f < 1) {
      e.rect(n, r, a, s);
      return;
    }
    e.moveTo(n + c, r), e.lineTo(n + a - c, r), e.quadraticCurveTo(n + a, r, n + a, r + f), e.lineTo(n + a, r + s - f), e.quadraticCurveTo(n + a, r + s, n + a - c, r + s), e.lineTo(n + c, r + s), e.quadraticCurveTo(n, r + s, n, r + s - f), e.lineTo(n, r + f), e.quadraticCurveTo(n, r, n + c, r);
  }
  static sharpRect(e, n, r, a, s, c, f) {
    e.rect(n, r, a, s);
  }
}
const mue = 1e4, vue = () => {
  const t = Ge(), e = OL("time", Date.now());
  return k.useEffect(() => {
    const n = setInterval(() => e.set(Date.now()), 5e3);
    return () => clearInterval(n);
  }, [e]), k.useMemo(
    () => t.store.query.records("user_presence", () => ({
      lastActivityTimestamp: { gt: e.value - mue },
      userId: { neq: t.userId }
    })),
    [t, e]
  );
}, yue = dn(function({
  shapeFill: e,
  selectFill: n,
  viewportFill: r
}) {
  const a = Ge(), s = k.useRef(null), c = ga(), f = k.useRef(!1), p = k.useMemo(() => new Yy(a, a.devicePixelRatio), [a]), g = a.userDocumentSettings.isDarkMode;
  k.useEffect(() => {
    const I = requestAnimationFrame(() => {
      const D = getComputedStyle(c);
      p.colors = {
        shapeFill: D.getPropertyValue(e).trim(),
        selectFill: D.getPropertyValue(n).trim(),
        viewportFill: D.getPropertyValue(r).trim()
      }, p.render();
    });
    return () => {
      cancelAnimationFrame(I);
    };
  }, [c, n, e, r, p, g]);
  const y = k.useCallback(
    (I) => {
      if (!a.shapeIds.size)
        return;
      const { x: D, y: N } = p.minimapScreenPointToPagePoint(I.clientX, I.clientY, !1, !1), j = p.minimapScreenPointToPagePoint(I.clientX, I.clientY, !1, !0);
      p.originPagePoint.setTo(j), p.originPageCenter.setTo(a.viewportPageBounds.center), a.centerOnPoint(D, N, { duration: $u });
    },
    [a, p]
  ), v = k.useCallback(
    (I) => {
      if (I.currentTarget.setPointerCapture(I.pointerId), !a.shapeIds.size)
        return;
      f.current = !0, p.isInViewport = !1;
      const { x: D, y: N } = p.minimapScreenPointToPagePoint(I.clientX, I.clientY, !1, !1), j = p.minimapScreenPointToPagePoint(I.clientX, I.clientY, !1, !0), L = a.viewportPageBounds;
      p.originPagePoint.setTo(j), p.originPageCenter.setTo(L.center), p.isInViewport = L.containsPoint(j), p.isInViewport || a.centerOnPoint(D, N, { duration: $u });
    },
    [a, p]
  ), S = k.useCallback(
    (I) => {
      if (f.current) {
        const { x: L, y: z } = p.minimapScreenPointToPagePoint(
          I.clientX,
          I.clientY,
          I.shiftKey,
          !0
        );
        if (p.isInViewport) {
          const F = O.Sub({ x: L, y: z }, p.originPagePoint), K = O.Add(p.originPageCenter, F);
          a.centerOnPoint(K.x, K.y);
          return;
        }
        a.centerOnPoint(L, z);
      }
      const D = p.getPagePoint(I.clientX, I.clientY), N = a.pageToScreen(D.x, D.y), j = {
        type: "pointer",
        target: "canvas",
        name: "pointer_move",
        ...bue(I),
        point: N,
        isPen: a.isPenMode
      };
      a.dispatch(j);
    },
    [a, p]
  ), x = k.useCallback((I) => {
    f.current = !1;
  }, []), _ = k.useCallback(
    (I) => {
      const D = lj(I);
      a.dispatch({
        type: "wheel",
        name: "wheel",
        delta: D,
        shiftKey: I.shiftKey,
        altKey: I.altKey,
        ctrlKey: I.metaKey || I.ctrlKey
      });
    },
    [a]
  );
  kp(
    "update dpr",
    () => {
      const { devicePixelRatio: I } = a;
      p.setDpr(I);
      const D = s.current, N = D.getBoundingClientRect(), j = N.width * I, L = N.height * I;
      D.width = j, D.height = L, p.canvasScreenBounds.set(N.x, N.y, j, L), p.cvs = s.current;
    },
    [a, p]
  );
  const T = vue();
  return kp(
    "minimap render when pagebounds or collaborators changes",
    () => {
      const { devicePixelRatio: I, viewportPageBounds: D, allShapesCommonBounds: N } = a;
      p.contentPageBounds = N ? ot.Expand(N, D) : D, p.updateContentScreenBounds();
      const j = [];
      a.shapeIds.forEach((L) => {
        let z = a.getPageBoundsById(L);
        const F = a.getPageMaskById(L);
        if (F) {
          const K = oP(F, z.corners);
          if (!K)
            return;
          z = ot.FromPoints(K);
        }
        z && (z.id = L, j.push(z));
      }), p.pageBounds = j, p.collaborators = T.value, p.render();
    },
    [a, p]
  ), /* @__PURE__ */ E.jsx("div", { className: "tlui-minimap", children: /* @__PURE__ */ E.jsx(
    "canvas",
    {
      ref: s,
      className: "tlui-minimap__canvas",
      onDoubleClick: y,
      onPointerMove: S,
      onPointerDown: v,
      onPointerUp: x,
      onWheel: _
    }
  ) });
});
function bue(t) {
  return t.isKilled = !0, {
    point: {
      x: t.clientX,
      y: t.clientY,
      z: t.pressure
    },
    shiftKey: t.shiftKey,
    altKey: t.altKey,
    ctrlKey: t.metaKey || t.ctrlKey,
    pointerId: t.pointerId,
    button: t.button,
    isPen: t.pointerType === "pen"
  };
}
const Mk = dn(function() {
  const e = Ge(), n = Fn(), r = Gs(), a = e.zoomLevel, s = e.shapeIds.size > 0, c = e.selectedIds.length > 0, f = e.camera.z === 1, p = k.useCallback(() => {
    e.resetZoom(e.viewportScreenCenter, { duration: $u });
  }, [e]);
  return /* @__PURE__ */ E.jsxs(tf, { id: "zoom", children: [
    /* @__PURE__ */ E.jsx(Rb, { children: /* @__PURE__ */ E.jsx(
      At,
      {
        title: `${n("navigation-zone.zoom")}`,
        "data-wd": "minimap.zoom-menu",
        className: r < 5 ? "tlui-zoom-menu__button" : "tlui-zoom-menu__button__pct",
        onDoubleClick: p,
        icon: r < 4 ? "zoom-in" : void 0,
        children: r < 4 ? null : /* @__PURE__ */ E.jsxs("span", { style: { flexGrow: 0, textAlign: "center" }, children: [
          Math.floor(a * 100),
          "%"
        ] })
      }
    ) }),
    /* @__PURE__ */ E.jsx(nf, { side: "top", align: "start", alignOffset: 0, children: /* @__PURE__ */ E.jsxs(Dp, { children: [
      /* @__PURE__ */ E.jsx(Ay, { action: "zoom-in", "data-wd": "minimap.zoom-menu.zoom-in", noClose: !0 }),
      /* @__PURE__ */ E.jsx(Ay, { action: "zoom-out", "data-wd": "minimap.zoom-menu.zoom-out", noClose: !0 }),
      /* @__PURE__ */ E.jsx(
        Ay,
        {
          action: "zoom-to-100",
          "data-wd": "minimap.zoom-menu.zoom-to-100",
          noClose: !0,
          disabled: f
        }
      ),
      /* @__PURE__ */ E.jsx(
        Ay,
        {
          action: "zoom-to-fit",
          disabled: !s,
          "data-wd": "minimap.zoom-menu.zoom-to-fit",
          noClose: !0
        }
      ),
      /* @__PURE__ */ E.jsx(
        Ay,
        {
          action: "zoom-to-selection",
          disabled: !c,
          "data-wd": "minimap.zoom-menu.zoom-to-selection",
          noClose: !0
        }
      )
    ] }) })
  ] });
});
function Ay(t) {
  const { action: e, disabled: n = !1, noClose: r = !1 } = t, a = va();
  return /* @__PURE__ */ E.jsx(
    Vo,
    {
      label: a[e].label,
      kbd: a[e].kbd,
      "data-wd": t["data-wd"],
      onClick: a[e].onSelect,
      noClose: r,
      disabled: n
    }
  );
}
const Sue = k.memo(function() {
  const e = va(), n = Fn(), r = Gs(), [a, s] = Jce("minimap", !0), c = k.useCallback(() => {
    s((f) => !f);
  }, [s]);
  return r < 4 ? null : /* @__PURE__ */ E.jsxs("div", { className: "tlui-navigation-zone", children: [
    /* @__PURE__ */ E.jsx("div", { className: "tlui-navigation-zone__controls", children: r < 6 ? /* @__PURE__ */ E.jsx(Mk, {}) : a ? /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(Mk, {}),
      /* @__PURE__ */ E.jsx(
        At,
        {
          title: n("navigation-zone.toggle-minimap"),
          className: "tlui-navigation-zone__toggle",
          "data-wd": "minimap.toggle",
          onClick: c,
          icon: a ? "chevrons-ne" : "chevrons-sw"
        }
      )
    ] }) : /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx(
        At,
        {
          icon: "minus",
          "data-wd": "minimap.zoom-out",
          title: `${n(e["zoom-out"].label)} ${kc(e["zoom-out"].kbd)}`,
          onClick: e["zoom-out"].onSelect
        }
      ),
      /* @__PURE__ */ E.jsx(Mk, {}),
      /* @__PURE__ */ E.jsx(
        At,
        {
          icon: "plus",
          "data-wd": "minimap.zoom-in",
          title: `${n(e["zoom-in"].label)} ${kc(e["zoom-in"].kbd)}`,
          onClick: e["zoom-in"].onSelect
        }
      ),
      /* @__PURE__ */ E.jsx(
        At,
        {
          title: n("navigation-zone.toggle-minimap"),
          className: "tlui-navigation-zone__toggle",
          onClick: c,
          icon: a ? "chevrons-ne" : "chevrons-sw"
        }
      )
    ] }) }),
    r >= 6 && !a && /* @__PURE__ */ E.jsx(
      yue,
      {
        viewportFill: "--color-muted-1",
        selectFill: "--color-selected",
        shapeFill: "--color-text-3"
      }
    )
  ] });
}), wue = k.memo(function({
  "data-wd": e,
  label: n,
  labelA: r,
  labelB: a,
  itemsA: s,
  itemsB: c,
  styleTypeA: f,
  styleTypeB: p,
  valueA: g,
  valueB: y,
  onValueChange: v
}) {
  const S = Fn(), x = k.useMemo(
    () => s.find((D) => D.id === g)?.icon ?? "mixed",
    [s, g]
  ), _ = k.useMemo(
    () => c.find((D) => D.id === y)?.icon ?? "mixed",
    [c, y]
  );
  if (g === void 0 && y === void 0)
    return null;
  const T = `${e}.start`, I = `${e}.end`;
  return /* @__PURE__ */ E.jsxs("div", { className: "tlui-style-panel__double-select-picker", children: [
    /* @__PURE__ */ E.jsx("div", { title: S(n), className: "tlui-style-panel__double-select-picker-label", children: S(n) }),
    /* @__PURE__ */ E.jsxs(tf, { id: `style panel ${f}`, children: [
      /* @__PURE__ */ E.jsx(cb, { asChild: !0, children: /* @__PURE__ */ E.jsx(
        At,
        {
          "data-wd": T,
          title: S(r) + " — " + S(g === null ? "style-panel.mixed" : `${f}-style.${g}`),
          icon: x,
          invertIcon: !0,
          smallIcon: !0
        }
      ) }),
      /* @__PURE__ */ E.jsx(nf, { side: "bottom", align: "end", sideOffset: 0, alignOffset: -2, children: /* @__PURE__ */ E.jsx(
        "div",
        {
          className: $n("tlui-button-grid", {
            "tlui-button-grid__two": s.length < 4,
            "tlui-button-grid__four": s.length >= 4
          }),
          children: s.map((D) => /* @__PURE__ */ E.jsx(
            Vo,
            {
              className: "tlui-button-grid__button",
              title: S(r) + " — " + S(`${f}-style.${D.id}`),
              "data-wd": `${T}.${D.id}`,
              icon: D.icon,
              onClick: () => v(D, !1),
              invertIcon: !0
            },
            D.id
          ))
        }
      ) })
    ] }),
    /* @__PURE__ */ E.jsxs(tf, { id: `style panel ${p}`, children: [
      /* @__PURE__ */ E.jsx(cb, { asChild: !0, children: /* @__PURE__ */ E.jsx(
        At,
        {
          "data-wd": I,
          title: S(a) + " — " + S(y === null ? "style-panel.mixed" : `${p}-style.${y}`),
          icon: _,
          smallIcon: !0
        }
      ) }),
      /* @__PURE__ */ E.jsx(nf, { side: "bottom", align: "end", sideOffset: 0, alignOffset: -2, children: /* @__PURE__ */ E.jsx(
        "div",
        {
          className: $n("tlui-button-grid", {
            "tlui-button-grid__two": s.length < 4,
            "tlui-button-grid__four": s.length >= 4
          }),
          children: c.map((D) => /* @__PURE__ */ E.jsx(
            Vo,
            {
              className: "tlui-button-grid__button",
              title: S(a) + " — " + S(`${p}-style.${D.id}`),
              "data-wd": `${I}.${D.id}`,
              icon: D.icon,
              onClick: () => v(D, !1)
            },
            D.id
          ))
        }
      ) })
    ] })
  ] });
}), s5 = k.memo(function({
  id: e,
  items: n,
  styleType: r,
  label: a,
  value: s,
  onValueChange: c,
  "data-wd": f
}) {
  const p = Fn(), g = k.useMemo(() => n.find((y) => y.id === s)?.icon, [n, s]);
  return /* @__PURE__ */ E.jsxs(tf, { id: `style panel ${e}`, children: [
    /* @__PURE__ */ E.jsx(cb, { asChild: !0, children: /* @__PURE__ */ E.jsx(
      At,
      {
        "data-wd": f,
        title: p(s === null ? "style-panel.mixed" : `${r}-style.${s}`),
        label: a,
        icon: g ?? "mixed"
      }
    ) }),
    /* @__PURE__ */ E.jsx(nf, { side: "left", align: "center", alignOffset: 0, children: /* @__PURE__ */ E.jsx(
      "div",
      {
        className: $n("tlui-button-grid", {
          "tlui-button-grid__two": n.length < 4,
          "tlui-button-grid__four": n.length >= 4
        }),
        children: n.map((y) => /* @__PURE__ */ E.jsx(
          Vo,
          {
            className: "tlui-button-grid__button",
            "data-wd": `${f}.${y.id}`,
            title: p(`${r}-style.${y.id}`),
            icon: y.icon,
            onClick: () => c(y, !1)
          },
          y.id
        ))
      }
    ) })
  ] });
}), l5 = dn(function({ isMobile: e }) {
  const n = Ge(), r = n.props, a = k.useCallback(() => {
    e || (n.isChangingStyle = !1);
  }, [n, e]);
  if (!r)
    return null;
  const { geo: s, arrowheadEnd: c, arrowheadStart: f, spline: p, font: g } = r, y = s === void 0, v = c === void 0 && f === void 0, S = p === void 0, x = g === void 0;
  return /* @__PURE__ */ E.jsxs("div", { className: "tlui-style-panel", "data-ismobile": e, onPointerLeave: a, children: [
    /* @__PURE__ */ E.jsx(xue, { props: r }),
    !x && /* @__PURE__ */ E.jsx(Eue, { props: r }),
    !(y && v && S) && /* @__PURE__ */ E.jsxs("div", { className: "tlui-style-panel__section", "aria-label": "style panel styles", children: [
      /* @__PURE__ */ E.jsx(Cue, { props: r }),
      /* @__PURE__ */ E.jsx(Tue, { props: r }),
      /* @__PURE__ */ E.jsx(_ue, { props: r })
    ] })
  ] });
}), { styles: Va } = en;
function Mb() {
  const t = Ge();
  return It.useCallback(
    (e, n) => {
      t.batch(() => {
        t.setProp(e.type, e.id, !1, n), t.isChangingStyle = !0;
      });
    },
    [t]
  );
}
function xue({ props: t }) {
  const e = Ge(), n = Fn(), r = Mb(), a = It.useCallback(
    (S, x) => {
      const _ = Va.opacity[S];
      e.setProp(_.type, _.id, x), e.isChangingStyle = !0;
    },
    [e]
  ), { color: s, fill: c, dash: f, size: p, opacity: g } = t;
  if (s === void 0 && c === void 0 && f === void 0 && p === void 0 && g === void 0)
    return null;
  const y = c || f || p, v = Va.opacity.findIndex((S) => S.id === g);
  return /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    /* @__PURE__ */ E.jsxs("div", { className: "tlui-style-panel__section__common", "aria-label": "style panel styles", children: [
      s === void 0 ? null : /* @__PURE__ */ E.jsx(
        Hg,
        {
          title: n("style-panel.color"),
          styleType: "color",
          "data-wd": "style.color",
          items: Va.color,
          value: s,
          onValueChange: r
        }
      ),
      g === void 0 ? null : /* @__PURE__ */ E.jsx(
        Jle,
        {
          "data-wd": "style.opacity",
          value: v >= 0 ? v : Va.opacity.length - 1,
          label: g ? `opacity-style.${g}` : "style-panel.mixed",
          onValueChange: a,
          steps: Va.opacity.length - 1,
          title: n("style-panel.opacity")
        }
      )
    ] }),
    y && /* @__PURE__ */ E.jsxs("div", { className: "tlui-style-panel__section", "aria-label": "style panel styles", children: [
      c === void 0 ? null : /* @__PURE__ */ E.jsx(
        Hg,
        {
          title: n("style-panel.fill"),
          styleType: "fill",
          "data-wd": "style.fill",
          items: Va.fill,
          value: c,
          onValueChange: r
        }
      ),
      f === void 0 ? null : /* @__PURE__ */ E.jsx(
        Hg,
        {
          title: n("style-panel.dash"),
          styleType: "dash",
          "data-wd": "style.dash",
          items: Va.dash,
          value: f,
          onValueChange: r
        }
      ),
      p === void 0 ? null : /* @__PURE__ */ E.jsx(
        Hg,
        {
          title: n("style-panel.size"),
          styleType: "size",
          "data-wd": "style.size",
          items: Va.size,
          value: p,
          onValueChange: r
        }
      )
    ] })
  ] });
}
function Eue({ props: t }) {
  const e = Fn(), n = Mb(), { font: r, align: a } = t;
  return r === void 0 && a === void 0 ? null : /* @__PURE__ */ E.jsxs("div", { className: "tlui-style-panel__section", "aria-label": "style panel text", children: [
    r === void 0 ? null : /* @__PURE__ */ E.jsx(
      Hg,
      {
        title: e("style-panel.font"),
        styleType: "font",
        "data-wd": "font",
        items: Va.font,
        value: r,
        onValueChange: n
      }
    ),
    a === void 0 ? null : /* @__PURE__ */ E.jsx(
      Hg,
      {
        title: e("style-panel.align"),
        styleType: "align",
        "data-wd": "align",
        items: Va.align,
        value: a,
        onValueChange: n
      }
    )
  ] });
}
function Cue({ props: t }) {
  const e = Mb(), { geo: n } = t;
  return n === void 0 ? null : /* @__PURE__ */ E.jsx(
    s5,
    {
      id: "geo",
      label: "style-panel.geo",
      styleType: "geo",
      "data-wd": "style-panel.geo",
      items: Va.geo,
      value: n,
      onValueChange: e
    }
  );
}
function _ue({ props: t }) {
  const e = Mb(), { spline: n } = t;
  return n === void 0 ? null : /* @__PURE__ */ E.jsx(
    s5,
    {
      id: "spline",
      label: "style-panel.spline",
      styleType: "spline",
      "data-wd": "style.spline",
      items: Va.spline,
      value: n,
      onValueChange: e
    }
  );
}
function Tue({ props: t }) {
  const e = Mb(), { arrowheadEnd: n, arrowheadStart: r } = t;
  return n === void 0 && r === void 0 ? null : /* @__PURE__ */ E.jsx(
    wue,
    {
      label: "style-panel.arrowheads",
      styleTypeA: "arrowheadStart",
      "data-wd": "style.arrowheads",
      itemsA: Va.arrowheadStart,
      valueA: r,
      styleTypeB: "arrowheadEnd",
      itemsB: Va.arrowheadEnd,
      valueB: n,
      onValueChange: e,
      labelA: "style-panel.arrowhead-start",
      labelB: "style-panel.arrowhead-end"
    }
  );
}
function kue() {
  const t = Ge(), n = va()["back-to-content"], [r, a] = k.useState(!1);
  return k.useEffect(() => {
    let s = !1;
    const c = setInterval(() => {
      const { renderingShapes: f } = t, g = f.filter((y) => y.isInViewport).length === 0 && t.shapesArray.length > 0;
      s !== g && (a(g), s = g);
    }, 1e3);
    return () => {
      clearInterval(c);
    };
  }, [t]), r ? /* @__PURE__ */ E.jsx(
    At,
    {
      iconLeft: n.icon,
      label: n.label,
      onClick: () => {
        n.onSelect(), a(!1);
      }
    }
  ) : null;
}
const Pue = ({ id: t, component: e, onClose: n }) => {
  const { removeDialog: r } = Fp(), a = ga(), s = k.useCallback(
    (c) => {
      if (!c) {
        if (n)
          try {
            n();
          } catch (f) {
            console.warn(f);
          }
        r(t);
      }
    },
    [t, n, r]
  );
  return /* @__PURE__ */ E.jsx(Jse, { onOpenChange: s, defaultOpen: !0, children: /* @__PURE__ */ E.jsx(ele, { container: a, children: /* @__PURE__ */ E.jsx(tle, { dir: "ltr", className: "tlui-dialog__overlay", children: /* @__PURE__ */ E.jsx(nle, { dir: "ltr", className: "tlui-dialog__content", children: /* @__PURE__ */ E.jsx(e, { onClose: () => s(!1) }) }) }) }) });
};
function Iue() {
  const { dialogs: t } = Fp();
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: t.map((e) => /* @__PURE__ */ E.jsx(Pue, { ...e }, e.id)) });
}
const Rue = It.memo(Iue), $ue = dn(function() {
  const n = Ge().isPenMode, r = va();
  if (!n)
    return null;
  const a = r["exit-pen-mode"];
  return /* @__PURE__ */ E.jsx(At, { label: a.label, iconLeft: a.icon, onClick: a.onSelect });
}), c5 = "Popover", [u5, Qpe] = Oc(c5, [
  P1
]), C2 = P1(), [Mue, hm] = u5(c5), Aue = (t) => {
  const { __scopePopover: e, children: n, open: r, defaultOpen: a, onOpenChange: s, modal: c = !1 } = t, f = C2(e), p = k.useRef(null), [g, y] = k.useState(!1), [v = !1, S] = cf({
    prop: r,
    defaultProp: a,
    onChange: s
  });
  return /* @__PURE__ */ k.createElement(t2, f, /* @__PURE__ */ k.createElement(Mue, {
    scope: e,
    contentId: Du(),
    triggerRef: p,
    open: v,
    onOpenChange: S,
    onOpenToggle: k.useCallback(
      () => S(
        (x) => !x
      ),
      [
        S
      ]
    ),
    hasCustomAnchor: g,
    onCustomAnchorAdd: k.useCallback(
      () => y(!0),
      []
    ),
    onCustomAnchorRemove: k.useCallback(
      () => y(!1),
      []
    ),
    modal: c
  }, n));
}, Oue = "PopoverTrigger", Due = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopePopover: n, ...r } = t, a = hm(Oue, n), s = C2(n), c = Rr(e, a.triggerRef), f = /* @__PURE__ */ k.createElement(pr.button, qe({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": a.open,
    "aria-controls": a.contentId,
    "data-state": p5(a.open)
  }, r, {
    ref: c,
    onClick: _t(t.onClick, a.onOpenToggle)
  }));
  return a.hasCustomAnchor ? f : /* @__PURE__ */ k.createElement(yz, qe({
    asChild: !0
  }, s), f);
}), d5 = "PopoverPortal", [Nue, Lue] = u5(d5, {
  forceMount: void 0
}), jue = (t) => {
  const { __scopePopover: e, forceMount: n, children: r, container: a } = t, s = hm(d5, e);
  return /* @__PURE__ */ k.createElement(Nue, {
    scope: e,
    forceMount: n
  }, /* @__PURE__ */ k.createElement(Ol, {
    present: n || s.open
  }, /* @__PURE__ */ k.createElement(E1, {
    asChild: !0,
    container: a
  }, r)));
}, fb = "PopoverContent", zue = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = Lue(fb, t.__scopePopover), { forceMount: r = n.forceMount, ...a } = t, s = hm(fb, t.__scopePopover);
  return /* @__PURE__ */ k.createElement(Ol, {
    present: r || s.open
  }, s.modal ? /* @__PURE__ */ k.createElement(Uue, qe({}, a, {
    ref: e
  })) : /* @__PURE__ */ k.createElement(Bue, qe({}, a, {
    ref: e
  })));
}), Uue = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = hm(fb, t.__scopePopover), r = k.useRef(null), a = Rr(e, r), s = k.useRef(!1);
  return k.useEffect(() => {
    const c = r.current;
    if (c)
      return r2(c);
  }, []), /* @__PURE__ */ k.createElement(i2, {
    as: Mp,
    allowPinchZoom: !0
  }, /* @__PURE__ */ k.createElement(f5, qe({}, t, {
    ref: a,
    trapFocus: n.open,
    disableOutsidePointerEvents: !0,
    onCloseAutoFocus: _t(t.onCloseAutoFocus, (c) => {
      var f;
      c.preventDefault(), s.current || (f = n.triggerRef.current) === null || f === void 0 || f.focus();
    }),
    onPointerDownOutside: _t(t.onPointerDownOutside, (c) => {
      const f = c.detail.originalEvent, p = f.button === 0 && f.ctrlKey === !0, g = f.button === 2 || p;
      s.current = g;
    }, {
      checkForDefaultPrevented: !1
    }),
    onFocusOutside: _t(
      t.onFocusOutside,
      (c) => c.preventDefault(),
      {
        checkForDefaultPrevented: !1
      }
    )
  })));
}), Bue = /* @__PURE__ */ k.forwardRef((t, e) => {
  const n = hm(fb, t.__scopePopover), r = k.useRef(!1), a = k.useRef(!1);
  return /* @__PURE__ */ k.createElement(f5, qe({}, t, {
    ref: e,
    trapFocus: !1,
    disableOutsidePointerEvents: !1,
    onCloseAutoFocus: (s) => {
      var c;
      if ((c = t.onCloseAutoFocus) === null || c === void 0 || c.call(t, s), !s.defaultPrevented) {
        var f;
        r.current || (f = n.triggerRef.current) === null || f === void 0 || f.focus(), s.preventDefault();
      }
      r.current = !1, a.current = !1;
    },
    onInteractOutside: (s) => {
      var c, f;
      (c = t.onInteractOutside) === null || c === void 0 || c.call(t, s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (a.current = !0));
      const p = s.target;
      ((f = n.triggerRef.current) === null || f === void 0 ? void 0 : f.contains(p)) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && a.current && s.preventDefault();
    }
  }));
}), f5 = /* @__PURE__ */ k.forwardRef((t, e) => {
  const { __scopePopover: n, trapFocus: r, onOpenAutoFocus: a, onCloseAutoFocus: s, disableOutsidePointerEvents: c, onEscapeKeyDown: f, onPointerDownOutside: p, onFocusOutside: g, onInteractOutside: y, ...v } = t, S = hm(fb, n), x = C2(n);
  return QI(), /* @__PURE__ */ k.createElement(ZI, {
    asChild: !0,
    loop: !0,
    trapped: r,
    onMountAutoFocus: a,
    onUnmountAutoFocus: s
  }, /* @__PURE__ */ k.createElement(x1, {
    asChild: !0,
    disableOutsidePointerEvents: c,
    onInteractOutside: y,
    onEscapeKeyDown: f,
    onPointerDownOutside: p,
    onFocusOutside: g,
    onDismiss: () => S.onOpenChange(!1)
  }, /* @__PURE__ */ k.createElement(bz, qe({
    "data-state": p5(S.open),
    role: "dialog",
    id: S.contentId
  }, x, v, {
    ref: e,
    style: {
      ...v.style,
      "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
      "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
      "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
      "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
      "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
    }
  }))));
});
function p5(t) {
  return t ? "open" : "closed";
}
const Fue = Aue, Hue = Due, h5 = jue, g5 = zue, _2 = ({ id: t, open: e, children: n, onOpenChange: r }) => {
  const a = pm(t, r);
  return /* @__PURE__ */ E.jsx(Fue, { onOpenChange: a, open: e, children: /* @__PURE__ */ E.jsx("div", { className: "tlui-popover", children: n }) });
}, T2 = ({ children: t, disabled: e, "data-wd": n }) => /* @__PURE__ */ E.jsx(Hue, { "data-wd": n, disabled: e, asChild: !0, dir: "ltr", children: t }), m5 = ({ side: t, children: e, align: n = "center", sideOffset: r = 8, alignOffset: a = 0 }) => {
  const s = ga();
  return /* @__PURE__ */ E.jsx(h5, { dir: "ltr", container: s, children: /* @__PURE__ */ E.jsx(
    g5,
    {
      className: "tlui-popover__content",
      side: t,
      sideOffset: r,
      align: n,
      alignOffset: a,
      dir: "ltr",
      children: e
    }
  ) });
}, v5 = k.memo(function() {
  const e = Fn(), n = ga(), r = Tce(), a = Bu();
  function s(c) {
    if (a && !c.readonlyOk)
      return null;
    switch (c.type) {
      case "item": {
        const { id: f, icon: p, label: g, kbd: y, onSelect: v } = c.actionItem;
        return /* @__PURE__ */ E.jsx(
          At,
          {
            className: "tlui-button-grid__button",
            "data-wd": `menu-item.${c.id}`,
            icon: p,
            title: g ? y ? `${e(g)} ${kc(y)}` : `${e(g)}` : y ? `${kc(y)}` : "",
            onClick: v,
            disabled: c.disabled
          },
          f
        );
      }
    }
  }
  return /* @__PURE__ */ E.jsxs(_2, { id: "actions menu", children: [
    /* @__PURE__ */ E.jsx(T2, { children: /* @__PURE__ */ E.jsx(
      At,
      {
        className: "tlui-menu__trigger",
        "data-wd": "main.action-menu",
        icon: "dots-vertical",
        title: e("actions-menu.title"),
        smallIcon: !0
      }
    ) }),
    /* @__PURE__ */ E.jsx(h5, { dir: "ltr", container: n, children: /* @__PURE__ */ E.jsx(
      g5,
      {
        className: "tlui-popover__content",
        side: "bottom",
        dir: "ltr",
        sideOffset: 6,
        children: /* @__PURE__ */ E.jsx("div", { className: "tlui-actions-menu tlui-button-grid__four", children: r.map(s) })
      }
    ) })
  ] });
}), y5 = dn(function() {
  const e = Ge(), n = va(), r = Fn(), a = n.duplicate, s = e.selectedIds.length <= 0;
  return /* @__PURE__ */ E.jsx(
    At,
    {
      icon: a.icon,
      onClick: a.onSelect,
      disabled: s,
      title: `${r(a.label)} ${kc(a.kbd)}`,
      smallIcon: !0
    }
  );
}), Vue = k.memo(function() {
  const e = Fn();
  return /* @__PURE__ */ E.jsxs(tf, { id: "main menu", children: [
    /* @__PURE__ */ E.jsx(Rb, { children: /* @__PURE__ */ E.jsx(
      At,
      {
        className: "tlui-menu__trigger",
        "data-wd": "main.menu",
        title: e("menu.title"),
        icon: "menu"
      }
    ) }),
    /* @__PURE__ */ E.jsx(nf, { alignOffset: 0, sideOffset: 6, children: /* @__PURE__ */ E.jsx(Yue, {}) })
  ] });
});
function Yue() {
  const t = Ge(), e = Fn(), n = tue(), r = Gs(), a = Bu(), { paste: s } = b2();
  function c(f, p, g, y) {
    switch (p.type) {
      case "custom":
        return a && !p.readonlyOk ? null : p.id === "LANGUAGE_MENU" ? /* @__PURE__ */ E.jsx(a5, {}, "item") : p.id === "MENU_PASTE" ? /* @__PURE__ */ E.jsx(
          Vo,
          {
            "data-wd": `menu-item.${p.id}`,
            kbd: "$v",
            label: "action.paste",
            disabled: p.disabled,
            onMouseDown: () => {
              f.isSafari && navigator.clipboard?.read && navigator.clipboard.read().then((v) => {
                s(v);
              });
            },
            onClick: () => {
              f.isSafari || navigator.clipboard?.read && navigator.clipboard.read().then((v) => {
                s(v);
              });
            },
            onPointerUp: Gn
          },
          p.id
        ) : null;
      case "group":
        return a && !p.readonlyOk ? null : /* @__PURE__ */ E.jsx(
          Dp,
          {
            size: y <= 1 ? "medium" : r < 3 || g?.type === "submenu" && y > 2 ? "tiny" : "medium",
            children: p.children.map((v) => c(f, v, p, y + 1))
          },
          p.id
        );
      case "submenu":
        return a && !p.readonlyOk ? null : /* @__PURE__ */ E.jsxs(f2, { id: `main menu ${g ? g.id + " " : ""}${p.id}`, children: [
          /* @__PURE__ */ E.jsx(p2, { label: p.label, "data-wd": `menu-item.${p.id}` }),
          /* @__PURE__ */ E.jsx(h2, { sideOffset: -4, alignOffset: -1, children: p.children.map((v) => c(f, v, p, y + 1)) })
        ] }, p.id);
      case "item": {
        if (a && !p.readonlyOk)
          return null;
        const { id: v, checkbox: S, menuLabel: x, label: _, onSelect: T, kbd: I } = p.actionItem, D = x ?? _, N = D ? e(D) : void 0;
        return S ? /* @__PURE__ */ E.jsxs(
          _le,
          {
            onSelect: T,
            title: N || "",
            checked: p.checked,
            disabled: p.disabled,
            children: [
              N && /* @__PURE__ */ E.jsx("span", { children: N }),
              I && /* @__PURE__ */ E.jsx(A1, { children: I })
            ]
          },
          v
        ) : /* @__PURE__ */ E.jsx(
          Vo,
          {
            "data-wd": `menu-item.${p.id}`,
            kbd: I,
            label: D,
            onClick: T,
            disabled: p.disabled
          },
          v
        );
      }
    }
  }
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: n.map((f) => c(t, f, null, 0)) });
}
const Kue = function({
  name: e,
  id: n,
  isCurrentPage: r
}) {
  const a = Ge(), s = k.useRef(null), c = k.useCallback(
    (p) => {
      a.renamePage(n, p || "New Page", !0);
    },
    [a, n]
  ), f = k.useCallback(
    (p) => {
      a.mark("rename page"), a.renamePage(n, p || "New Page", !1);
    },
    [a, n]
  );
  return /* @__PURE__ */ E.jsx(
    g2,
    {
      className: "tlui-page-menu__item__input",
      ref: (p) => s.current = p,
      defaultValue: e,
      onValueChange: c,
      onComplete: f,
      onCancel: f,
      shouldManuallyMaintainScrollPositionWhenFocused: !0,
      autofocus: r,
      autoselect: !0
    }
  );
}, AP = (t, e, n, r) => {
  let a;
  const s = t.pages, c = n > r ? s[r - 1] : s[r], f = n > r ? s[r] : s[r + 1];
  c && !f ? a = Ru(c.index) : !c && f ? a = $Z(s[0].index) : a = Fy(c.index, f.index), a !== s[n].index && (t.mark("moving page"), t.updatePage({
    id: e,
    index: a
  }));
}, NN = dn(function({
  index: e,
  listSize: n,
  item: r,
  onRename: a
}) {
  const s = Ge(), c = Fn(), f = s.pages, p = k.useCallback(() => {
    s.mark("creating page");
    const S = fr.createId();
    s.duplicatePage(r.id, S);
  }, [s, r]), g = k.useCallback(() => {
    AP(s, r.id, e, e - 1);
  }, [s, r, e]), y = k.useCallback(() => {
    AP(s, r.id, e, e + 1);
  }, [s, r, e]), v = k.useCallback(() => {
    s.mark("deleting page"), s.deletePage(r.id);
  }, [s, r]);
  return /* @__PURE__ */ E.jsxs(tf, { id: "page item submenu", children: [
    /* @__PURE__ */ E.jsx(Rb, { children: /* @__PURE__ */ E.jsx(At, { title: c("page-menu.submenu.title"), icon: "dots-vertical" }) }),
    /* @__PURE__ */ E.jsxs(nf, { alignOffset: 0, children: [
      /* @__PURE__ */ E.jsxs(Dp, { children: [
        a && /* @__PURE__ */ E.jsx(jg, { dir: "ltr", onSelect: a, asChild: !0, children: /* @__PURE__ */ E.jsx(At, { className: "tlui-menu__button", label: "page-menu.submenu.rename" }) }),
        /* @__PURE__ */ E.jsx(
          jg,
          {
            dir: "ltr",
            onSelect: p,
            disabled: f.length >= Ix,
            asChild: !0,
            children: /* @__PURE__ */ E.jsx(At, { className: "tlui-menu__button", label: "page-menu.submenu.duplicate-page" })
          }
        ),
        e > 0 && /* @__PURE__ */ E.jsx(jg, { dir: "ltr", onSelect: g, asChild: !0, children: /* @__PURE__ */ E.jsx(At, { className: "tlui-menu__button", label: "page-menu.submenu.move-up" }) }),
        e < n - 1 && /* @__PURE__ */ E.jsx(jg, { dir: "ltr", onSelect: y, asChild: !0, children: /* @__PURE__ */ E.jsx(At, { className: "tlui-menu__button", label: "page-menu.submenu.move-down" }) })
      ] }),
      n > 1 && /* @__PURE__ */ E.jsx(Dp, { children: /* @__PURE__ */ E.jsx(jg, { dir: "ltr", onSelect: v, asChild: !0, children: /* @__PURE__ */ E.jsx(At, { className: "tlui-menu__button", label: "page-menu.submenu.delete" }) }) })
    ] })
  ] });
}), Wue = dn(function() {
  const e = Ge(), n = Fn(), r = Gs(), a = r < 5 ? 36 : 40, s = k.useRef(null), { pages: c, currentPage: f } = e, p = e.isReadOnly, g = e.pages.length >= Ix, [y, v] = k.useState(!1), S = k.useCallback(() => {
    p || v((X) => !X);
  }, [p]), [x, _] = k.useState(!1), T = k.useCallback((X) => {
    _(X), v(!1);
  }, []), I = k.useRef({
    isPointing: !1,
    status: "idle",
    pointing: null,
    startY: 0,
    startIndex: 0,
    dragIndex: 0
  }), [D, N] = k.useState(
    Object.fromEntries(
      c.map((X, se) => [X.id, { y: se * a, offsetY: 0, isSelected: !1 }])
    )
  );
  k.useLayoutEffect(() => {
    N(
      Object.fromEntries(
        c.map((X, se) => [X.id, { y: se * a, offsetY: 0, isSelected: !1 }])
      )
    );
  }, [a, c]), k.useEffect(() => {
    x && requestAnimationFrame(() => {
      const X = document.querySelector(
        `[data-wd="page-menu-item-${f.id}"]`
      );
      if (X) {
        const se = s.current;
        if (!se)
          return;
        const ue = X.offsetTop, pe = se.scrollTop;
        ue < pe && se.scrollTo({ top: ue });
        const Pe = ue + a, ve = se.scrollTop + se.offsetHeight;
        Pe > ve && se.scrollTo({ top: Pe - se.offsetHeight });
      }
    });
  }, [a, f, x]);
  const j = k.useCallback(
    (X) => {
      const { clientY: se, currentTarget: ue } = X, {
        dataset: { id: pe, index: Pe }
      } = ue;
      if (!pe || !Pe)
        return;
      const ve = I.current;
      X.currentTarget.setPointerCapture(X.pointerId), ve.status = "pointing", ve.pointing = { id: pe, index: +Pe };
      const le = D[pe].y;
      ve.startY = se, ve.startIndex = Math.max(0, Math.min(Math.round(le / a), c.length - 1));
    },
    [a, c.length, D]
  ), L = k.useCallback(
    (X) => {
      const se = I.current;
      if (se.status === "pointing") {
        const { clientY: ue } = X, pe = ue - se.startY;
        Math.abs(pe) > 5 && (se.status = "dragging");
      }
      if (se.status === "dragging") {
        const { clientY: ue } = X, pe = ue - se.startY, Pe = D[se.pointing.id], { startIndex: ve, pointing: Y } = se, le = Pe.y + pe, Re = Math.max(0, Math.min(Math.round(le / a), c.length - 1)), he = { ...D };
        if (he[Y.id] = {
          y: Pe.y,
          offsetY: pe,
          isSelected: !0
        }, Re !== se.dragIndex) {
          se.dragIndex = Re;
          for (let te = 0; te < c.length; te++) {
            const de = c[te];
            if (de.id === se.pointing.id)
              continue;
            let { y: W } = he[de.id];
            Re === ve ? W = te * a : Re < ve ? Re <= te && te < ve ? W = (te + 1) * a : W = te * a : Re > ve && (Re >= te && te > ve ? W = (te - 1) * a : W = te * a), W !== he[de.id].y && (he[de.id] = { y: W, offsetY: 0, isSelected: !0 });
          }
        }
        N(he);
      }
    },
    [a, c, D]
  ), z = k.useCallback(
    (X) => {
      const se = I.current;
      if (se.status === "dragging") {
        const { id: ue, index: pe } = se.pointing;
        AP(e, ue, pe, se.dragIndex);
      }
      X.currentTarget.releasePointerCapture(X.pointerId), se.status = "idle";
    },
    [e]
  ), F = k.useCallback(
    (X) => {
      const se = I.current;
      X.key === "Escape" && (se.status === "dragging" && N(
        Object.fromEntries(
          c.map((ue, pe) => [
            ue.id,
            { y: pe * a, offsetY: 0, isSelected: !1 }
          ])
        )
      ), se.status = "idle");
    },
    [a, c]
  ), K = k.useCallback(() => {
    if (p)
      return;
    e.mark("creating page");
    const X = fr.createId();
    e.createPage(n("page-menu.new-page-initial-name"), X), v(!0);
  }, [e, n, p]);
  return /* @__PURE__ */ E.jsxs(_2, { id: "page menu", onOpenChange: T, open: x, children: [
    /* @__PURE__ */ E.jsx(T2, { children: /* @__PURE__ */ E.jsx(
      At,
      {
        className: "tlui-page-menu__trigger tlui-menu__trigger",
        "data-wd": "main.page-menu",
        icon: "chevron-down",
        title: f.name,
        children: /* @__PURE__ */ E.jsx("div", { className: "tlui-page-menu__name", children: f.name })
      }
    ) }),
    /* @__PURE__ */ E.jsx(m5, { side: "bottom", align: "start", sideOffset: 6, children: /* @__PURE__ */ E.jsxs("div", { className: "tlui-page-menu__wrapper", children: [
      /* @__PURE__ */ E.jsxs("div", { className: "tlui-page-menu__header", children: [
        /* @__PURE__ */ E.jsx("div", { className: "tlui-page-menu__header__title", children: n("page-menu.title") }),
        !p && /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
          /* @__PURE__ */ E.jsx(
            At,
            {
              "data-wd": "page-menu.edit",
              title: n(y ? "page-menu.edit-done" : "page-menu.edit-start"),
              icon: y ? "check" : "edit",
              onClick: S
            }
          ),
          /* @__PURE__ */ E.jsx(
            At,
            {
              "data-wd": "page-menu.create",
              icon: "plus",
              title: n(
                g ? "page-menu.max-page-count-reached" : "page-menu.create-new-page"
              ),
              disabled: g,
              onClick: K
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ E.jsx(
        "div",
        {
          className: "tlui-page-menu__list tlui-menu__group",
          style: { height: a * c.length + 4 },
          ref: s,
          children: c.map((X, se) => {
            const ue = D[X.id] ?? {
              position: se * 40,
              offsetY: 0
            };
            return y ? /* @__PURE__ */ E.jsxs(
              "div",
              {
                "data-wd": `page-menu-item-${X.id}`,
                className: "tlui-page_menu__item__sortable",
                style: {
                  zIndex: X.id === f.id ? 888 : se,
                  transform: `translate(0px, ${ue.y + ue.offsetY}px)`
                },
                children: [
                  /* @__PURE__ */ E.jsx(
                    At,
                    {
                      tabIndex: -1,
                      className: "tlui-page_menu__item__sortable__handle",
                      icon: "drag-handle-dots",
                      onPointerDown: j,
                      onPointerUp: z,
                      onPointerMove: L,
                      onKeyDown: F,
                      "data-id": X.id,
                      "data-index": se
                    }
                  ),
                  r < 5 && e.isCoarsePointer ? (
                    // sigh, this is a workaround for iOS Safari
                    // because the device and the radix popover seem
                    // to be fighting over scroll position. Nothing
                    // else seems to work!
                    /* @__PURE__ */ E.jsx(At, {
                      className: "tlui-page-menu__item__button",
                      onClick: () => {
                        const pe = window.prompt("Rename page", X.name);
                        pe && pe !== X.name && e.renamePage(X.id, pe);
                      },
                      onDoubleClick: S,
                      isChecked: X.id === f.id,
                      children: /* @__PURE__ */ E.jsx("span", { children: X.name })
                    })
                  ) : /* @__PURE__ */ E.jsx(
                    "div",
                    {
                      id: `page-menu-item-${X.id}`,
                      "data-wd": `page-menu-item-${X.id}`,
                      className: "tlui-page_menu__item__sortable__title",
                      style: { height: a },
                      children: /* @__PURE__ */ E.jsx(
                        Kue,
                        {
                          id: X.id,
                          name: X.name,
                          isCurrentPage: X.id === f.id
                        }
                      )
                    }
                  ),
                  !p && /* @__PURE__ */ E.jsx("div", { className: "tlui-page_menu__item__submenu", "data-isediting": y, children: /* @__PURE__ */ E.jsx(NN, { index: se, item: X, listSize: c.length }) })
                ]
              },
              X.id + "_editing"
            ) : /* @__PURE__ */ E.jsxs(
              "div",
              {
                "data-wd": `page-menu-item-${X.id}`,
                className: "tlui-page-menu__item",
                children: [
                  /* @__PURE__ */ E.jsxs(
                    At,
                    {
                      className: "tlui-page-menu__item__button tlui-page-menu__item__button__checkbox",
                      onClick: () => e.setCurrentPageId(X.id),
                      onDoubleClick: S,
                      isChecked: X.id === f.id,
                      children: [
                        /* @__PURE__ */ E.jsx("div", { className: "tlui-page-menu__item__button__check", children: X.id === f.id && /* @__PURE__ */ E.jsx(Ya, { icon: "check" }) }),
                        /* @__PURE__ */ E.jsx("span", { children: X.name })
                      ]
                    }
                  ),
                  !p && /* @__PURE__ */ E.jsx("div", { className: "tlui-page_menu__item__submenu", children: /* @__PURE__ */ E.jsx(
                    NN,
                    {
                      index: se,
                      item: X,
                      listSize: c.length,
                      onRename: () => {
                        if (e.isIos) {
                          const pe = window.prompt("Rename page", X.name);
                          pe && pe !== X.name && e.renamePage(X.id, pe);
                        } else
                          v(!0), e.setCurrentPageId(X.id);
                      }
                    }
                  ) })
                ]
              },
              X.id
            );
          })
        }
      )
    ] }) })
  ] });
}), b5 = k.memo(function() {
  const e = Fn(), n = Y4(), a = va().redo;
  return /* @__PURE__ */ E.jsx(
    At,
    {
      "data-wd": "main.redo",
      icon: a.icon,
      title: `${e(a.label)} ${kc(a.kbd)}`,
      disabled: !n,
      onClick: a.onSelect,
      smallIcon: !0
    }
  );
}), S5 = dn(function() {
  const e = Ge(), n = va(), r = Fn(), a = n.delete;
  if (Bu())
    return null;
  const c = e.selectedIds.length <= 0;
  return /* @__PURE__ */ E.jsx(
    At,
    {
      icon: a.icon,
      onClick: a.onSelect,
      disabled: c,
      title: `${r(a.label)} ${kc(a.kbd)}`,
      smallIcon: !0
    }
  );
}), w5 = k.memo(function() {
  const e = Fn(), n = K4(), a = va().undo;
  return /* @__PURE__ */ E.jsx(
    At,
    {
      "data-wd": "main.undo",
      icon: a.icon,
      title: `${e(a.label)} ${kc(a.kbd)}`,
      disabled: !n,
      onClick: a.onSelect,
      smallIcon: !0
    }
  );
}), Gue = dn(function() {
  const e = Gs(), n = Bu();
  return /* @__PURE__ */ E.jsx("div", { className: "tlui-menu-zone", children: /* @__PURE__ */ E.jsxs("div", { className: "tlui-menu-zone__controls", children: [
    /* @__PURE__ */ E.jsx(Vue, {}),
    /* @__PURE__ */ E.jsx("div", { className: "tlui-menu-zone__divider" }),
    /* @__PURE__ */ E.jsx(Wue, {}),
    e >= 5 && !n && /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsx("div", { className: "tlui-menu-zone__divider" }),
      /* @__PURE__ */ E.jsx(w5, {}),
      /* @__PURE__ */ E.jsx(b5, {}),
      /* @__PURE__ */ E.jsx(S5, {}),
      /* @__PURE__ */ E.jsx(y5, {}),
      /* @__PURE__ */ E.jsx(v5, {})
    ] })
  ] }) });
});
function Xue({ toast: t }) {
  const { removeToast: e } = Uu(), n = Fn(), r = (s) => {
    s || e(t.id);
  }, a = t.actions && t.actions.length > 0;
  return /* @__PURE__ */ E.jsxs(
    aoe,
    {
      onOpenChange: r,
      className: "tlui-toast__container",
      duration: t.keepOpen ? 1 / 0 : 5e3,
      children: [
        t.icon && /* @__PURE__ */ E.jsx("div", { className: "tlui-toast__icon", children: /* @__PURE__ */ E.jsx(Ya, { icon: t.icon }) }),
        /* @__PURE__ */ E.jsxs("div", { className: "tlui-toast__main", children: [
          /* @__PURE__ */ E.jsxs("div", { className: "tlui-toast__content", children: [
            /* @__PURE__ */ E.jsx(soe, { className: "tlui-toast__title", children: t.title }),
            /* @__PURE__ */ E.jsx(loe, { className: "tlui-toast__description", children: t.description })
          ] }),
          t.actions && /* @__PURE__ */ E.jsxs("div", { className: "tlui-toast__actions", children: [
            t.actions.map((s, c) => /* @__PURE__ */ E.jsx(coe, { altText: s.label, asChild: !0, onClick: s.onClick, children: /* @__PURE__ */ E.jsx(
              At,
              {
                className: s.type === "warn" ? "tlui-button__warning" : "tlui-button__primary",
                children: s.label
              }
            ) }, c)),
            a && /* @__PURE__ */ E.jsx(tN, { asChild: !0, children: /* @__PURE__ */ E.jsx(At, { className: "tlui-toast__close", style: { marginLeft: "auto" }, children: t.closeLabel ?? n("toast.close") }) })
          ] })
        ] }),
        !a && /* @__PURE__ */ E.jsx(tN, { asChild: !0, children: /* @__PURE__ */ E.jsx(At, { className: "tlui-toast__close", children: t.closeLabel ?? n("toast.close") }) })
      ]
    }
  );
}
function que() {
  const { toasts: t } = Uu();
  return /* @__PURE__ */ E.jsx(E.Fragment, { children: t.map((e) => /* @__PURE__ */ E.jsx(Xue, { toast: e }, e.id)) });
}
const Que = k.memo(que);
function Zue() {
  const { toasts: t } = Uu(), [e, n] = k.useState(!1);
  return k.useEffect(() => {
    let r = !1;
    return t.length ? n(!0) : setTimeout(() => {
      r || n(!1);
    }, 1e3), () => {
      r = !0;
    };
  }, [t.length, n]), e ? /* @__PURE__ */ E.jsx(Hie, { className: "tlui-toast__viewport" }) : null;
}
function Jue() {
  const t = Ge(), e = un(
    "current color",
    () => {
      const { props: a } = t;
      return a ? a.color ? t.getCssColor(a.color) : null : "var(--color-muted-1)";
    },
    [t]
  ), n = un(
    "isHandOrEraserToolActive",
    () => t.currentToolId === "hand" || t.currentToolId === "eraser",
    [t]
  ), r = k.useCallback(
    (a) => {
      a || (t.isChangingStyle = !1);
    },
    [t]
  );
  return /* @__PURE__ */ E.jsxs(_2, { id: "style menu", onOpenChange: r, children: [
    /* @__PURE__ */ E.jsx(T2, { disabled: n, children: /* @__PURE__ */ E.jsx(
      At,
      {
        className: "tlui-toolbar__tools__button tlui-toolbar__styles__button tlui-popover__trigger",
        "data-wd": "mobile.styles",
        style: { color: e ?? "var(--color-text)" },
        children: /* @__PURE__ */ E.jsx(Ya, { icon: e ? "blob" : "mixed" })
      }
    ) }),
    /* @__PURE__ */ E.jsx(m5, { side: "top", align: "end", children: /* @__PURE__ */ E.jsx(l5, { isMobile: !0 }) })
  ] });
}
const ede = dn(function({
  activeToolId: e
}) {
  const n = Ge(), r = Gs(), a = Fn(), {
    instanceState: { isToolLocked: s }
  } = n;
  return e === "select" || e === "hand" || e === "draw" || e === "eraser" || e === "text" ? null : /* @__PURE__ */ E.jsx(
    At,
    {
      title: a("action.toggle-tool-lock"),
      className: $n("tlui-toolbar__lock-button", {
        "tlui-toolbar__lock-button__mobile": r < 5
      }),
      icon: n.instanceState.isToolLocked ? "lock" : "unlock",
      onClick: () => n.updateInstanceState({ isToolLocked: !s }),
      smallIcon: !0
    }
  );
}), tde = dn(function() {
  const e = Ge(), n = Fn(), r = Gs(), a = It.useRef(void 0), s = e.isReadOnly, c = rue(), f = e.currentToolId, p = e.props ? e.props.geo : void 0, g = (_) => _.label ? `${n(_.label)} ${_.kbd ? kc(_.kbd) : ""}` : "", y = c.find((_) => My(_.toolItem, f, p)), { itemsInPanel: v, itemsInDropdown: S, dropdownFirstItem: x } = It.useMemo(() => {
    const _ = [], T = [];
    let I;
    const D = Math.min(8, 5 + r);
    for (let N = 4; N < c.length; N++) {
      const j = c[N];
      N < D ? _.push(j) : (j === y && (I = j), T.push(j));
    }
    return I || (a.current || (a.current = T[0]), I = a.current, T.includes(I) || (I = T[0])), a.current = I, T.length <= 2 && (_.push(...T), T.length = 0), { itemsInPanel: _, itemsInDropdown: T, dropdownFirstItem: I };
  }, [c, y, r]);
  return /* @__PURE__ */ E.jsx("div", { className: "tlui-toolbar", children: /* @__PURE__ */ E.jsxs("div", { className: "tlui-toolbar__inner", children: [
    /* @__PURE__ */ E.jsxs("div", { className: "tlui-toolbar__left", children: [
      !s && /* @__PURE__ */ E.jsxs("div", { className: "tlui-toolbar__extras", children: [
        r < 5 && /* @__PURE__ */ E.jsxs("div", { className: "tlui-toolbar__extras__controls", children: [
          /* @__PURE__ */ E.jsx(w5, {}),
          /* @__PURE__ */ E.jsx(b5, {}),
          /* @__PURE__ */ E.jsx(S5, {}),
          /* @__PURE__ */ E.jsx(y5, {}),
          /* @__PURE__ */ E.jsx(v5, {})
        ] }),
        /* @__PURE__ */ E.jsx(ede, { activeToolId: f })
      ] }),
      /* @__PURE__ */ E.jsxs(
        "div",
        {
          className: $n("tlui-toolbar__tools", {
            "tlui-toolbar__tools__mobile": r < 5
          }),
          children: [
            c.slice(0, 2).map(({ toolItem: _ }) => /* @__PURE__ */ E.jsx(
              Jw,
              {
                item: _,
                title: g(_),
                isSelected: My(_, f, p)
              },
              _.id
            )),
            !s && /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
              /* @__PURE__ */ E.jsx("div", { className: "tlui-toolbar__divider" }),
              c.slice(2, 4).map(({ toolItem: _ }) => /* @__PURE__ */ E.jsx(
                Jw,
                {
                  item: _,
                  title: g(_),
                  isSelected: My(_, f, p)
                },
                _.id
              )),
              /* @__PURE__ */ E.jsx("div", { className: "tlui-toolbar__divider" }),
              v.map(({ toolItem: _ }) => /* @__PURE__ */ E.jsx(
                Jw,
                {
                  item: _,
                  title: g(_),
                  isSelected: My(_, f, p)
                },
                _.id
              )),
              S.length ? /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
                /* @__PURE__ */ E.jsx(
                  Jw,
                  {
                    item: x.toolItem,
                    title: g(x.toolItem),
                    isSelected: My(
                      x.toolItem,
                      f,
                      p
                    )
                  },
                  x.toolItem.id
                ),
                /* @__PURE__ */ E.jsxs(tf, { id: "toolbar overflow", modal: !1, children: [
                  /* @__PURE__ */ E.jsx(Rb, { children: /* @__PURE__ */ E.jsx(
                    At,
                    {
                      className: "tlui-toolbar__tools__button tlui-toolbar__overflow",
                      icon: "chevron-up",
                      "data-wd": "tools.more"
                    }
                  ) }),
                  /* @__PURE__ */ E.jsx(nf, { side: "top", align: "center", children: /* @__PURE__ */ E.jsx(nde, { toolbarItems: S }) })
                ] })
              ] }) : null
            ] })
          ]
        }
      )
    ] }),
    r < 5 && !s && /* @__PURE__ */ E.jsx("div", { className: "tlui-toolbar__tools", children: /* @__PURE__ */ E.jsx(Jue, {}) })
  ] }) });
}), nde = dn(function({
  toolbarItems: e
}) {
  const n = Fn();
  return /* @__PURE__ */ E.jsx("div", { className: "tlui-button-grid__four tlui-button-grid__reverse", children: e.map(({ toolItem: { id: r, meta: a, kbd: s, label: c, onSelect: f, icon: p } }) => /* @__PURE__ */ E.jsx(
    Vo,
    {
      className: "tlui-button-grid__button",
      "data-wd": `tools.${r}`,
      "data-tool": r,
      "data-geo": a?.geo ?? "",
      "aria-label": c,
      onClick: f,
      title: c ? `${n(c)} ${s ? kc(s) : ""}` : "",
      icon: p
    },
    r
  )) });
});
function Jw({
  item: t,
  title: e,
  isSelected: n
}) {
  return /* @__PURE__ */ E.jsx(
    At,
    {
      className: "tlui-toolbar__tools__button",
      "data-wd": `tools.${t.id}`,
      "data-tool": t.id,
      "data-geo": t.meta?.geo ?? "",
      "aria-label": t.label,
      title: e,
      icon: t.icon,
      "data-state": n ? "selected" : void 0,
      onClick: t.onSelect,
      onTouchStart: (r) => {
        r.preventDefault(), t.onSelect();
      }
    },
    t.id
  );
}
const x5 = [
  "align-bottom",
  "align-center-horizontal",
  "align-center-vertical",
  "align-left",
  "align-right",
  "align-top",
  "arrow-left",
  "arrowhead-arrow",
  "arrowhead-bar",
  "arrowhead-diamond",
  "arrowhead-dot",
  "arrowhead-none",
  "arrowhead-square",
  "arrowhead-triangle-inverted",
  "arrowhead-triangle",
  "aspect-ratio",
  "avatar",
  "blob",
  "bring-forward",
  "bring-to-front",
  "check",
  "checkbox-checked",
  "checkbox-empty",
  "chevron-down",
  "chevron-left",
  "chevron-right",
  "chevron-up",
  "chevrons-ne",
  "chevrons-sw",
  "clipboard-copy",
  "code",
  "collab",
  "color",
  "comment",
  "cross-2",
  "cross",
  "dash-dashed",
  "dash-dotted",
  "dash-draw",
  "dash-solid",
  "discord",
  "distribute-horizontal",
  "distribute-vertical",
  "dot",
  "dots-horizontal",
  "dots-vertical",
  "drag-handle-dots",
  "duplicate",
  "edit",
  "external-link",
  "file",
  "fill-none",
  "fill-pattern",
  "fill-semi",
  "fill-solid",
  "font-draw",
  "font-mono",
  "font-sans",
  "font-serif",
  "geo-arrow-down",
  "geo-arrow-left",
  "geo-arrow-right",
  "geo-arrow-up",
  "geo-diamond",
  "geo-ellipse",
  "geo-hexagon",
  "geo-octagon",
  "geo-oval",
  "geo-pentagon",
  "geo-rectangle",
  "geo-rhombus-2",
  "geo-rhombus",
  "geo-star",
  "geo-trapezoid",
  "geo-triangle",
  "geo-x-box",
  "github",
  "group",
  "hidden",
  "image",
  "info-circle",
  "link",
  "lock-small",
  "lock",
  "menu",
  "minus",
  "mixed",
  "pack",
  "page",
  "plus",
  "question-mark-circle",
  "question-mark",
  "redo",
  "reset-zoom",
  "rotate-ccw",
  "rotate-cw",
  "ruler",
  "search",
  "send-backward",
  "send-to-back",
  "settings-horizontal",
  "settings-vertical-1",
  "settings-vertical",
  "share-1",
  "share-2",
  "size-extra-large",
  "size-large",
  "size-medium",
  "size-small",
  "spline-cubic",
  "spline-line",
  "stack-horizontal",
  "stack-vertical",
  "stretch-horizontal",
  "stretch-vertical",
  "text-align-center",
  "text-align-justify",
  "text-align-left",
  "text-align-right",
  "tool-arrow",
  "tool-embed",
  "tool-eraser",
  "tool-frame",
  "tool-hand",
  "tool-highlighter",
  "tool-line",
  "tool-media",
  "tool-note",
  "tool-pencil",
  "tool-pointer",
  "tool-text",
  "trash",
  "triangle-down",
  "triangle-up",
  "twitter",
  "undo",
  "ungroup",
  "unlock-small",
  "unlock",
  "visible",
  "warning-triangle",
  "zoom-in",
  "zoom-out"
];
function rde() {
  const [t, e] = k.useState(!1), n = j1();
  return k.useEffect(() => {
    let r = !1;
    async function a() {
      await Promise.allSettled(
        x5.map((s) => {
          const c = new Image();
          return c.src = n.icons[s], c.decode();
        })
      ), !r && e(!0);
    }
    return a(), () => {
      r = !0;
    };
  }, [t, n]), t;
}
const ide = {
  ...Mj,
  icons: Object.fromEntries(
    x5.map((t) => [t, `/icons/icon/${t}.svg`])
  ),
  translations: Object.fromEntries(
    S2.map((t) => [t.locale, `/translations/${t.locale}.json`])
  ),
  embedIcons: Object.fromEntries(
    Qg.map((t) => [t.type, `/embed-icons/${t.type}.png`])
  )
};
function ode() {
  const { addToast: t, removeToast: e, clearToasts: n } = Uu(), { addDialog: r, clearDialogs: a, removeDialog: s, updateDialog: c } = Fp(), p = Gs() < 5, g = Fn();
  return k.useMemo(
    () => ({
      addToast: t,
      removeToast: e,
      clearToasts: n,
      addDialog: r,
      clearDialogs: a,
      removeDialog: s,
      updateDialog: c,
      msg: g,
      isMobile: p
    }),
    [
      r,
      t,
      a,
      n,
      g,
      s,
      e,
      c,
      p
    ]
  );
}
function ade(t, e) {
  const n = {};
  for (const r of t)
    if (r.translations)
      for (const [a, s] of rL(r.translations)) {
        let c = n[a];
        c || (c = n[a] = {}), Object.assign(c, s);
      }
  return {
    actionsMenu: (r, a, s) => {
      for (const c of t)
        c.actionsMenu && (a = c.actionsMenu(r, a, { ...e, ...s }));
      return a;
    },
    actions: (r, a) => {
      for (const s of t)
        s.actions && (a = s.actions(r, a, e));
      return a;
    },
    contextMenu: (r, a, s) => {
      for (const c of t)
        c.contextMenu && (a = c.contextMenu(r, a, { ...e, ...s }));
      return a;
    },
    helpMenu: (r, a, s) => {
      for (const c of t)
        c.helpMenu && (a = c.helpMenu(r, a, { ...e, ...s }));
      return a;
    },
    menu: (r, a, s) => {
      for (const c of t)
        c.menu && (a = c.menu(r, a, { ...e, ...s }));
      return a;
    },
    toolbar: (r, a, s) => {
      for (const c of t)
        c.toolbar && (a = c.toolbar(r, a, { ...e, ...s }));
      return a;
    },
    keyboardShortcutsMenu: (r, a, s) => {
      for (const c of t)
        c.keyboardShortcutsMenu && (a = c.keyboardShortcutsMenu(r, a, { ...e, ...s }));
      return a;
    },
    tools: (r, a, s) => {
      for (const c of t)
        c.tools && (a = c.tools(r, a, { ...e, ...s }));
      return a;
    },
    translations: n
  };
}
function E5(t) {
  return k.useMemo(() => t, t);
}
function sde(t) {
  const e = E5(
    t == null ? [] : Array.isArray(t) ? t : [t]
  );
  return k.useMemo(() => {
    const n = {};
    for (const r of e)
      if (r.translations)
        for (const [a, s] of rL(r.translations)) {
          let c = n[a];
          c || (c = n[a] = {}), Object.assign(c, s);
        }
    return n;
  }, [e]);
}
function lde(t) {
  const e = ode(), n = E5(
    t == null ? [] : Array.isArray(t) ? t : [t]
  );
  return k.useMemo(
    () => ade(n, e),
    [n, e]
  );
}
function cde({
  overrides: t,
  assetUrls: e,
  children: n
}) {
  return /* @__PURE__ */ E.jsx(fce, { assetUrls: e ?? ide, children: /* @__PURE__ */ E.jsx(hce, { overrides: sde(t), children: /* @__PURE__ */ E.jsx(cce, { children: /* @__PURE__ */ E.jsx(yce, { children: /* @__PURE__ */ E.jsx(Cce, { children: /* @__PURE__ */ E.jsx(ude, { overrides: t, children: n }) }) }) }) }) });
}
function ude({
  overrides: t,
  children: e
}) {
  const n = lde(t);
  return /* @__PURE__ */ E.jsx(xce, { overrides: n.actions, children: /* @__PURE__ */ E.jsx(Gce, { overrides: n.tools, children: /* @__PURE__ */ E.jsx(nue, { overrides: n.toolbar, children: /* @__PURE__ */ E.jsx(_ce, { overrides: n.actionsMenu, children: /* @__PURE__ */ E.jsx(Qce, { overrides: n.keyboardShortcutsMenu, children: /* @__PURE__ */ E.jsx(Rce, { overrides: n.contextMenu, children: /* @__PURE__ */ E.jsx(Mce, { overrides: n.helpMenu, children: /* @__PURE__ */ E.jsx(eue, { overrides: n.menu, children: e }) }) }) }) }) }) }) });
}
const dde = It.memo(function({
  shareZone: e,
  renderDebugMenuItems: n,
  children: r,
  ...a
}) {
  return /* @__PURE__ */ E.jsx(cde, { ...a, children: /* @__PURE__ */ E.jsx(fde, { shareZone: e, renderDebugMenuItems: n, children: r }) });
}), fde = It.memo(function({
  children: e,
  ...n
}) {
  return rde() ? /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
    e,
    /* @__PURE__ */ E.jsx(pde, { ...n })
  ] }) : /* @__PURE__ */ E.jsx(uP, { children: "Loading assets..." });
}), pde = It.memo(function({
  shareZone: e,
  renderDebugMenuItems: n
}) {
  const r = Ge(), a = Fn(), s = Gs(), c = un("isReadOnlyMode", () => r.isReadOnly, []), f = un("isFocusMode", () => r.instanceState.isFocusMode, []), p = un("isDebugMode", () => r.instanceState.isDebugMode, []);
  qce(), lce(), kce();
  const { "toggle-focus-mode": g } = va();
  return /* @__PURE__ */ E.jsx(Wj, { children: /* @__PURE__ */ E.jsx(
    "main",
    {
      "data-wd": "desktop-ui",
      className: $n("tlui-layout", { "tlui-layout__mobile": s < 5 }),
      children: f ? /* @__PURE__ */ E.jsx("div", { className: "tlui-layout__top", children: /* @__PURE__ */ E.jsx(
        At,
        {
          className: "tlui-focus-button",
          title: `${a("focus-mode.toggle-focus-mode")}`,
          icon: "dot",
          onClick: g.onSelect
        }
      ) }) : /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
        /* @__PURE__ */ E.jsxs("div", { className: "tlui-layout__top", children: [
          /* @__PURE__ */ E.jsx(Gue, {}),
          /* @__PURE__ */ E.jsx("div", { className: "tlui-spacer" }),
          /* @__PURE__ */ E.jsx("div", { className: "tlui-share-zone", draggable: !1, children: e })
        ] }),
        /* @__PURE__ */ E.jsxs(
          "div",
          {
            className: "tlui-layout__middle",
            "data-wd": "active-area",
            "data-tldraw-area": "active-drawing",
            children: [
              /* @__PURE__ */ E.jsxs("div", { className: "tlui-helper-buttons", children: [
                /* @__PURE__ */ E.jsx($ue, {}),
                /* @__PURE__ */ E.jsx(kue, {})
              ] }),
              s >= 5 && !c && /* @__PURE__ */ E.jsx("div", { className: "tlui-style-panel__wrapper", children: /* @__PURE__ */ E.jsx(l5, {}) })
            ]
          }
        ),
        /* @__PURE__ */ E.jsxs("div", { className: "tlui-layout__bottom", children: [
          /* @__PURE__ */ E.jsxs("div", { className: "tlui-layout__bottom__main", children: [
            /* @__PURE__ */ E.jsx(Sue, {}),
            /* @__PURE__ */ E.jsx(tde, {}),
            s >= 4 && /* @__PURE__ */ E.jsx(hue, {})
          ] }),
          p && /* @__PURE__ */ E.jsx(lue, { renderDebugMenuItems: n ?? null })
        ] }),
        /* @__PURE__ */ E.jsx(Que, {}),
        /* @__PURE__ */ E.jsx(Rue, {}),
        /* @__PURE__ */ E.jsx(Zue, {})
      ] })
    }
  ) });
});
const me = (t) => `modules/${Tp}/${t}`, hde = () => ({
  fonts: {
    monospace: me("fonts/IBMPlexMono-Medium.woff2"),
    sansSerif: me("fonts/IBMPlexSans-Medium.woff2"),
    serif: me("fonts/IBMPlexSerif-Medium.woff2"),
    draw: me("fonts/Shantell_Sans-Normal-SemiBold.woff2")
  }
}), gde = () => ({
  icons: {
    "align-bottom-center": me("icons/align-bottom-center.svg"),
    "align-bottom-left": me("icons/align-bottom-left.svg"),
    "align-bottom-right": me("icons/align-bottom-right.svg"),
    "align-bottom": me("icons/align-bottom.svg"),
    "align-center-center": me("icons/align-center-center.svg"),
    "align-center-horizontal": me("icons/align-center-horizontal.svg"),
    "align-center-left": me("icons/align-center-left.svg"),
    "align-center-right": me("icons/align-center-right.svg"),
    "align-center-vertical": me("icons/align-center-vertical.svg"),
    "align-left": me("icons/align-left.svg"),
    "align-right": me("icons/align-right.svg"),
    "align-top-center": me("icons/align-top-center.svg"),
    "align-top-left": me("icons/align-top-left.svg"),
    "align-top-right": me("icons/align-top-right.svg"),
    "align-top": me("icons/align-top.svg"),
    "arrow-left": me("icons/arrow-left.svg"),
    "arrowhead-arrow": me("icons/arrowhead-arrow.svg"),
    "arrowhead-bar": me("icons/arrowhead-bar.svg"),
    "arrowhead-diamond": me("icons/arrowhead-diamond.svg"),
    "arrowhead-dot": me("icons/arrowhead-dot.svg"),
    "arrowhead-none": me("icons/arrowhead-none.svg"),
    "arrowhead-square": me("icons/arrowhead-square.svg"),
    "arrowhead-triangle-inverted": me("icons/arrowhead-triangle-inverted.svg"),
    "arrowhead-triangle": me("icons/arrowhead-triangle.svg"),
    "aspect-ratio": me("icons/aspect-ratio.svg"),
    avatar: me("icons/avatar.svg"),
    blob: me("icons/blob.svg"),
    "bring-forward": me("icons/bring-forward.svg"),
    "bring-to-front": me("icons/bring-to-front.svg"),
    check: me("icons/check.svg"),
    "checkbox-checked": me("icons/checkbox-checked.svg"),
    "checkbox-empty": me("icons/checkbox-empty.svg"),
    "chevron-down": me("icons/chevron-down.svg"),
    "chevron-left": me("icons/chevron-left.svg"),
    "chevron-right": me("icons/chevron-right.svg"),
    "chevron-up": me("icons/chevron-up.svg"),
    "chevrons-ne": me("icons/chevrons-ne.svg"),
    "chevrons-sw": me("icons/chevrons-sw.svg"),
    "clipboard-copied": me("icons/clipboard-copied.svg"),
    "clipboard-copy": me("icons/clipboard-copy.svg"),
    code: me("icons/code.svg"),
    collab: me("icons/collab.svg"),
    color: me("icons/color.svg"),
    comment: me("icons/comment.svg"),
    "cross-2": me("icons/cross-2.svg"),
    cross: me("icons/cross.svg"),
    "dash-dashed": me("icons/dash-dashed.svg"),
    "dash-dotted": me("icons/dash-dotted.svg"),
    "dash-draw": me("icons/dash-draw.svg"),
    "dash-solid": me("icons/dash-solid.svg"),
    discord: me("icons/discord.svg"),
    "distribute-horizontal": me("icons/distribute-horizontal.svg"),
    "distribute-vertical": me("icons/distribute-vertical.svg"),
    dot: me("icons/dot.svg"),
    "dots-horizontal": me("icons/dots-horizontal.svg"),
    "dots-vertical": me("icons/dots-vertical.svg"),
    "drag-handle-dots": me("icons/drag-handle-dots.svg"),
    duplicate: me("icons/duplicate.svg"),
    edit: me("icons/edit.svg"),
    "external-link": me("icons/external-link.svg"),
    file: me("icons/file.svg"),
    "fill-none": me("icons/fill-none.svg"),
    "fill-pattern": me("icons/fill-pattern.svg"),
    "fill-semi": me("icons/fill-semi.svg"),
    "fill-solid": me("icons/fill-solid.svg"),
    follow: me("icons/follow.svg"),
    following: me("icons/following.svg"),
    "font-draw": me("icons/font-draw.svg"),
    "font-mono": me("icons/font-mono.svg"),
    "font-sans": me("icons/font-sans.svg"),
    "font-serif": me("icons/font-serif.svg"),
    "geo-arrow-down": me("icons/geo-arrow-down.svg"),
    "geo-arrow-left": me("icons/geo-arrow-left.svg"),
    "geo-arrow-right": me("icons/geo-arrow-right.svg"),
    "geo-arrow-up": me("icons/geo-arrow-up.svg"),
    "geo-check-box": me("icons/geo-check-box.svg"),
    "geo-diamond": me("icons/geo-diamond.svg"),
    "geo-ellipse": me("icons/geo-ellipse.svg"),
    "geo-hexagon": me("icons/geo-hexagon.svg"),
    "geo-octagon": me("icons/geo-octagon.svg"),
    "geo-oval": me("icons/geo-oval.svg"),
    "geo-pentagon": me("icons/geo-pentagon.svg"),
    "geo-rectangle": me("icons/geo-rectangle.svg"),
    "geo-rhombus-2": me("icons/geo-rhombus-2.svg"),
    "geo-rhombus": me("icons/geo-rhombus.svg"),
    "geo-star": me("icons/geo-star.svg"),
    "geo-trapezoid": me("icons/geo-trapezoid.svg"),
    "geo-triangle": me("icons/geo-triangle.svg"),
    "geo-x-box": me("icons/geo-x-box.svg"),
    github: me("icons/github.svg"),
    group: me("icons/group.svg"),
    hidden: me("icons/hidden.svg"),
    image: me("icons/image.svg"),
    "info-circle": me("icons/info-circle.svg"),
    leading: me("icons/leading.svg"),
    link: me("icons/link.svg"),
    "lock-small": me("icons/lock-small.svg"),
    lock: me("icons/lock.svg"),
    menu: me("icons/menu.svg"),
    minus: me("icons/minus.svg"),
    mixed: me("icons/mixed.svg"),
    pack: me("icons/pack.svg"),
    page: me("icons/page.svg"),
    plus: me("icons/plus.svg"),
    "question-mark-circle": me("icons/question-mark-circle.svg"),
    "question-mark": me("icons/question-mark.svg"),
    redo: me("icons/redo.svg"),
    "reset-zoom": me("icons/reset-zoom.svg"),
    "rotate-ccw": me("icons/rotate-ccw.svg"),
    "rotate-cw": me("icons/rotate-cw.svg"),
    ruler: me("icons/ruler.svg"),
    search: me("icons/search.svg"),
    "send-backward": me("icons/send-backward.svg"),
    "send-to-back": me("icons/send-to-back.svg"),
    "settings-horizontal": me("icons/settings-horizontal.svg"),
    "settings-vertical-1": me("icons/settings-vertical-1.svg"),
    "settings-vertical": me("icons/settings-vertical.svg"),
    "share-1": me("icons/share-1.svg"),
    "share-2": me("icons/share-2.svg"),
    "size-extra-large": me("icons/size-extra-large.svg"),
    "size-large": me("icons/size-large.svg"),
    "size-medium": me("icons/size-medium.svg"),
    "size-small": me("icons/size-small.svg"),
    "spline-cubic": me("icons/spline-cubic.svg"),
    "spline-line": me("icons/spline-line.svg"),
    "stack-horizontal": me("icons/stack-horizontal.svg"),
    "stack-vertical": me("icons/stack-vertical.svg"),
    "stretch-horizontal": me("icons/stretch-horizontal.svg"),
    "stretch-vertical": me("icons/stretch-vertical.svg"),
    "text-align-center": me("icons/text-align-center.svg"),
    "text-align-justify": me("icons/text-align-justify.svg"),
    "text-align-left": me("icons/text-align-left.svg"),
    "text-align-right": me("icons/text-align-right.svg"),
    "tool-arrow": me("icons/tool-arrow.svg"),
    "tool-embed": me("icons/tool-embed.svg"),
    "tool-eraser": me("icons/tool-eraser.svg"),
    "tool-frame": me("icons/tool-frame.svg"),
    "tool-hand": me("icons/tool-hand.svg"),
    "tool-highlighter": me("icons/tool-highlighter.svg"),
    "tool-laser": me("icons/tool-laser.svg"),
    "tool-line": me("icons/tool-line.svg"),
    "tool-media": me("icons/tool-media.svg"),
    "tool-note": me("icons/tool-note.svg"),
    "tool-pencil": me("icons/tool-pencil.svg"),
    "tool-pointer": me("icons/tool-pointer.svg"),
    "tool-text": me("icons/tool-text.svg"),
    trash: me("icons/trash.svg"),
    "triangle-down": me("icons/triangle-down.svg"),
    "triangle-up": me("icons/triangle-up.svg"),
    twitter: me("icons/twitter.svg"),
    undo: me("icons/undo.svg"),
    ungroup: me("icons/ungroup.svg"),
    "unlock-small": me("icons/unlock-small.svg"),
    unlock: me("icons/unlock.svg"),
    "vertical-align-center": me("icons/vertical-align-center.svg"),
    "vertical-align-end": me("icons/vertical-align-end.svg"),
    "vertical-align-start": me("icons/vertical-align-start.svg"),
    visible: me("icons/visible.svg"),
    "warning-triangle": me("icons/warning-triangle.svg"),
    "zoom-in": me("icons/zoom-in.svg"),
    "zoom-out": me("icons/zoom-out.svg")
  },
  translations: {
    en: me("lang/tldraw-en.json")
  }
}), mde = async (t) => {
  const e = await (await fetch(t)).blob();
  return new File([e], t, {
    lastModified: (/* @__PURE__ */ new Date()).getTime(),
    type: e.type
  });
}, vde = async (t) => {
  new FilePicker({
    type: "imagevideo",
    displayMode: "tiles",
    async callback(n) {
      p1(t, [await mde(n)], t.viewportPageBounds.center, !1);
    }
  }).render();
}, yde = {
  contextMenu: (t, e, n) => (Sde(e), bde(e), wde(t, e, n), xde(t, e), e),
  toolbar(t, e, n) {
    e.splice(
      e.findIndex((a) => a.id === "embed"),
      1
    );
    const r = e.findIndex((a) => a.id === "asset");
    return e[r] = {
      ...e[r],
      toolItem: {
        ...e[r].toolItem,
        onSelect: async () => {
          await vde(t);
        }
      }
    }, e;
  }
};
function bde(t) {
  const e = t.find((n) => n.id === "modify");
  e && e.children.splice(
    e.children.findIndex((n) => n.id === "MOVE_TO_PAGE_MENU"),
    1
  );
}
function Sde(t) {
  t.splice(
    t.findIndex((e) => e.id === "conversions"),
    1
  );
}
function wde(t, e, n) {
  n.oneSelected || e.push({
    id: "preferences-group",
    type: "group",
    checkbox: !1,
    disabled: !1,
    readonlyOk: !0,
    children: [
      {
        id: "toggle-grid",
        type: "item",
        actionItem: {
          id: "action.toggle-grid",
          label: "action.toggle-grid.menu",
          kbd: "$'",
          readonlyOk: !0,
          onSelect: () => {
            t.setGridMode(!t.isGridMode);
          }
        },
        checked: !0,
        readonlyOk: !0,
        disabled: !1
      }
    ]
  });
}
function xde(t, e, n) {
  const r = t.selectedShapes, a = r?.[0];
  if (!a || r.length !== 1)
    return;
  const s = t.getShapeUtil(a);
  s.getContextMenuItems && e.unshift(s.getContextMenuItems(a));
}
var OP = { exports: {} }, tr = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var LN;
function Ede() {
  if (LN)
    return tr;
  LN = 1;
  var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), c = Symbol.for("react.context"), f = Symbol.for("react.server_context"), p = Symbol.for("react.forward_ref"), g = Symbol.for("react.suspense"), y = Symbol.for("react.suspense_list"), v = Symbol.for("react.memo"), S = Symbol.for("react.lazy"), x = Symbol.for("react.offscreen"), _;
  _ = Symbol.for("react.module.reference");
  function T(I) {
    if (typeof I == "object" && I !== null) {
      var D = I.$$typeof;
      switch (D) {
        case t:
          switch (I = I.type, I) {
            case n:
            case a:
            case r:
            case g:
            case y:
              return I;
            default:
              switch (I = I && I.$$typeof, I) {
                case f:
                case c:
                case p:
                case S:
                case v:
                case s:
                  return I;
                default:
                  return D;
              }
          }
        case e:
          return D;
      }
    }
  }
  return tr.ContextConsumer = c, tr.ContextProvider = s, tr.Element = t, tr.ForwardRef = p, tr.Fragment = n, tr.Lazy = S, tr.Memo = v, tr.Portal = e, tr.Profiler = a, tr.StrictMode = r, tr.Suspense = g, tr.SuspenseList = y, tr.isAsyncMode = function() {
    return !1;
  }, tr.isConcurrentMode = function() {
    return !1;
  }, tr.isContextConsumer = function(I) {
    return T(I) === c;
  }, tr.isContextProvider = function(I) {
    return T(I) === s;
  }, tr.isElement = function(I) {
    return typeof I == "object" && I !== null && I.$$typeof === t;
  }, tr.isForwardRef = function(I) {
    return T(I) === p;
  }, tr.isFragment = function(I) {
    return T(I) === n;
  }, tr.isLazy = function(I) {
    return T(I) === S;
  }, tr.isMemo = function(I) {
    return T(I) === v;
  }, tr.isPortal = function(I) {
    return T(I) === e;
  }, tr.isProfiler = function(I) {
    return T(I) === a;
  }, tr.isStrictMode = function(I) {
    return T(I) === r;
  }, tr.isSuspense = function(I) {
    return T(I) === g;
  }, tr.isSuspenseList = function(I) {
    return T(I) === y;
  }, tr.isValidElementType = function(I) {
    return typeof I == "string" || typeof I == "function" || I === n || I === a || I === r || I === g || I === y || I === x || typeof I == "object" && I !== null && (I.$$typeof === S || I.$$typeof === v || I.$$typeof === s || I.$$typeof === c || I.$$typeof === p || I.$$typeof === _ || I.getModuleId !== void 0);
  }, tr.typeOf = T, tr;
}
var nr = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jN;
function Cde() {
  return jN || (jN = 1, {}.NODE_ENV !== "production" && function() {
    var t = Symbol.for("react.element"), e = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), c = Symbol.for("react.context"), f = Symbol.for("react.server_context"), p = Symbol.for("react.forward_ref"), g = Symbol.for("react.suspense"), y = Symbol.for("react.suspense_list"), v = Symbol.for("react.memo"), S = Symbol.for("react.lazy"), x = Symbol.for("react.offscreen"), _ = !1, T = !1, I = !1, D = !1, N = !1, j;
    j = Symbol.for("react.module.reference");
    function L(Ke) {
      return !!(typeof Ke == "string" || typeof Ke == "function" || Ke === n || Ke === a || N || Ke === r || Ke === g || Ke === y || D || Ke === x || _ || T || I || typeof Ke == "object" && Ke !== null && (Ke.$$typeof === S || Ke.$$typeof === v || Ke.$$typeof === s || Ke.$$typeof === c || Ke.$$typeof === p || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Ke.$$typeof === j || Ke.getModuleId !== void 0));
    }
    function z(Ke) {
      if (typeof Ke == "object" && Ke !== null) {
        var yt = Ke.$$typeof;
        switch (yt) {
          case t:
            var Xt = Ke.type;
            switch (Xt) {
              case n:
              case a:
              case r:
              case g:
              case y:
                return Xt;
              default:
                var kt = Xt && Xt.$$typeof;
                switch (kt) {
                  case f:
                  case c:
                  case p:
                  case S:
                  case v:
                  case s:
                    return kt;
                  default:
                    return yt;
                }
            }
          case e:
            return yt;
        }
      }
    }
    var F = c, K = s, X = t, se = p, ue = n, pe = S, Pe = v, ve = e, Y = a, le = r, Re = g, he = y, te = !1, de = !1;
    function W(Ke) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function fe(Ke) {
      return de || (de = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function ce(Ke) {
      return z(Ke) === c;
    }
    function xe(Ke) {
      return z(Ke) === s;
    }
    function $e(Ke) {
      return typeof Ke == "object" && Ke !== null && Ke.$$typeof === t;
    }
    function Me(Ke) {
      return z(Ke) === p;
    }
    function re(Ke) {
      return z(Ke) === n;
    }
    function Qe(Ke) {
      return z(Ke) === S;
    }
    function ke(Ke) {
      return z(Ke) === v;
    }
    function rt(Ke) {
      return z(Ke) === e;
    }
    function St(Ke) {
      return z(Ke) === a;
    }
    function Tt(Ke) {
      return z(Ke) === r;
    }
    function Le(Ke) {
      return z(Ke) === g;
    }
    function Nt(Ke) {
      return z(Ke) === y;
    }
    nr.ContextConsumer = F, nr.ContextProvider = K, nr.Element = X, nr.ForwardRef = se, nr.Fragment = ue, nr.Lazy = pe, nr.Memo = Pe, nr.Portal = ve, nr.Profiler = Y, nr.StrictMode = le, nr.Suspense = Re, nr.SuspenseList = he, nr.isAsyncMode = W, nr.isConcurrentMode = fe, nr.isContextConsumer = ce, nr.isContextProvider = xe, nr.isElement = $e, nr.isForwardRef = Me, nr.isFragment = re, nr.isLazy = Qe, nr.isMemo = ke, nr.isPortal = rt, nr.isProfiler = St, nr.isStrictMode = Tt, nr.isSuspense = Le, nr.isSuspenseList = Nt, nr.isValidElementType = L, nr.typeOf = z;
  }()), nr;
}
({}).NODE_ENV === "production" ? OP.exports = Ede() : OP.exports = Cde();
var k2 = OP.exports;
function _de(t) {
  function e(ce, xe, $e, Me, re) {
    for (var Qe = 0, ke = 0, rt = 0, St = 0, Tt, Le, Nt = 0, Ke = 0, yt, Xt = yt = Tt = 0, kt = 0, yn = 0, Er = 0, tn = 0, Mr = $e.length, zr = Mr - 1, Hn, xt = "", cn = "", ti = "", An = "", qn; kt < Mr; ) {
      if (Le = $e.charCodeAt(kt), kt === zr && ke + St + rt + Qe !== 0 && (ke !== 0 && (Le = ke === 47 ? 10 : 47), St = rt = Qe = 0, Mr++, zr++), ke + St + rt + Qe === 0) {
        if (kt === zr && (0 < yn && (xt = xt.replace(S, "")), 0 < xt.trim().length)) {
          switch (Le) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;
            default:
              xt += $e.charAt(kt);
          }
          Le = 59;
        }
        switch (Le) {
          case 123:
            for (xt = xt.trim(), Tt = xt.charCodeAt(0), yt = 1, tn = ++kt; kt < Mr; ) {
              switch (Le = $e.charCodeAt(kt)) {
                case 123:
                  yt++;
                  break;
                case 125:
                  yt--;
                  break;
                case 47:
                  switch (Le = $e.charCodeAt(kt + 1)) {
                    case 42:
                    case 47:
                      e: {
                        for (Xt = kt + 1; Xt < zr; ++Xt)
                          switch ($e.charCodeAt(Xt)) {
                            case 47:
                              if (Le === 42 && $e.charCodeAt(Xt - 1) === 42 && kt + 2 !== Xt) {
                                kt = Xt + 1;
                                break e;
                              }
                              break;
                            case 10:
                              if (Le === 47) {
                                kt = Xt + 1;
                                break e;
                              }
                          }
                        kt = Xt;
                      }
                  }
                  break;
                case 91:
                  Le++;
                case 40:
                  Le++;
                case 34:
                case 39:
                  for (; kt++ < zr && $e.charCodeAt(kt) !== Le; )
                    ;
              }
              if (yt === 0)
                break;
              kt++;
            }
            switch (yt = $e.substring(tn, kt), Tt === 0 && (Tt = (xt = xt.replace(v, "").trim()).charCodeAt(0)), Tt) {
              case 64:
                switch (0 < yn && (xt = xt.replace(S, "")), Le = xt.charCodeAt(1), Le) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    yn = xe;
                    break;
                  default:
                    yn = Re;
                }
                if (yt = e(xe, yn, yt, Le, re + 1), tn = yt.length, 0 < te && (yn = n(Re, xt, Er), qn = f(3, yt, yn, xe, ve, Pe, tn, Le, re, Me), xt = yn.join(""), qn !== void 0 && (tn = (yt = qn.trim()).length) === 0 && (Le = 0, yt = "")), 0 < tn)
                  switch (Le) {
                    case 115:
                      xt = xt.replace(F, c);
                    case 100:
                    case 109:
                    case 45:
                      yt = xt + "{" + yt + "}";
                      break;
                    case 107:
                      xt = xt.replace(N, "$1 $2"), yt = xt + "{" + yt + "}", yt = le === 1 || le === 2 && s("@" + yt, 3) ? "@-webkit-" + yt + "@" + yt : "@" + yt;
                      break;
                    default:
                      yt = xt + yt, Me === 112 && (yt = (cn += yt, ""));
                  }
                else
                  yt = "";
                break;
              default:
                yt = e(xe, n(xe, xt, Er), yt, Me, re + 1);
            }
            ti += yt, yt = Er = yn = Xt = Tt = 0, xt = "", Le = $e.charCodeAt(++kt);
            break;
          case 125:
          case 59:
            if (xt = (0 < yn ? xt.replace(S, "") : xt).trim(), 1 < (tn = xt.length))
              switch (Xt === 0 && (Tt = xt.charCodeAt(0), Tt === 45 || 96 < Tt && 123 > Tt) && (tn = (xt = xt.replace(" ", ":")).length), 0 < te && (qn = f(1, xt, xe, ce, ve, Pe, cn.length, Me, re, Me)) !== void 0 && (tn = (xt = qn.trim()).length) === 0 && (xt = "\0\0"), Tt = xt.charCodeAt(0), Le = xt.charCodeAt(1), Tt) {
                case 0:
                  break;
                case 64:
                  if (Le === 105 || Le === 99) {
                    An += xt + $e.charAt(kt);
                    break;
                  }
                default:
                  xt.charCodeAt(tn - 1) !== 58 && (cn += a(xt, Tt, Le, xt.charCodeAt(2)));
              }
            Er = yn = Xt = Tt = 0, xt = "", Le = $e.charCodeAt(++kt);
        }
      }
      switch (Le) {
        case 13:
        case 10:
          ke === 47 ? ke = 0 : 1 + Tt === 0 && Me !== 107 && 0 < xt.length && (yn = 1, xt += "\0"), 0 < te * W && f(0, xt, xe, ce, ve, Pe, cn.length, Me, re, Me), Pe = 1, ve++;
          break;
        case 59:
        case 125:
          if (ke + St + rt + Qe === 0) {
            Pe++;
            break;
          }
        default:
          switch (Pe++, Hn = $e.charAt(kt), Le) {
            case 9:
            case 32:
              if (St + Qe + ke === 0)
                switch (Nt) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    Hn = "";
                    break;
                  default:
                    Le !== 32 && (Hn = " ");
                }
              break;
            case 0:
              Hn = "\\0";
              break;
            case 12:
              Hn = "\\f";
              break;
            case 11:
              Hn = "\\v";
              break;
            case 38:
              St + ke + Qe === 0 && (yn = Er = 1, Hn = "\f" + Hn);
              break;
            case 108:
              if (St + ke + Qe + Y === 0 && 0 < Xt)
                switch (kt - Xt) {
                  case 2:
                    Nt === 112 && $e.charCodeAt(kt - 3) === 58 && (Y = Nt);
                  case 8:
                    Ke === 111 && (Y = Ke);
                }
              break;
            case 58:
              St + ke + Qe === 0 && (Xt = kt);
              break;
            case 44:
              ke + rt + St + Qe === 0 && (yn = 1, Hn += "\r");
              break;
            case 34:
            case 39:
              ke === 0 && (St = St === Le ? 0 : St === 0 ? Le : St);
              break;
            case 91:
              St + ke + rt === 0 && Qe++;
              break;
            case 93:
              St + ke + rt === 0 && Qe--;
              break;
            case 41:
              St + ke + Qe === 0 && rt--;
              break;
            case 40:
              if (St + ke + Qe === 0) {
                if (Tt === 0)
                  switch (2 * Nt + 3 * Ke) {
                    case 533:
                      break;
                    default:
                      Tt = 1;
                  }
                rt++;
              }
              break;
            case 64:
              ke + rt + St + Qe + Xt + yt === 0 && (yt = 1);
              break;
            case 42:
            case 47:
              if (!(0 < St + Qe + rt))
                switch (ke) {
                  case 0:
                    switch (2 * Le + 3 * $e.charCodeAt(kt + 1)) {
                      case 235:
                        ke = 47;
                        break;
                      case 220:
                        tn = kt, ke = 42;
                    }
                    break;
                  case 42:
                    Le === 47 && Nt === 42 && tn + 2 !== kt && ($e.charCodeAt(tn + 2) === 33 && (cn += $e.substring(tn, kt + 1)), Hn = "", ke = 0);
                }
          }
          ke === 0 && (xt += Hn);
      }
      Ke = Nt, Nt = Le, kt++;
    }
    if (tn = cn.length, 0 < tn) {
      if (yn = xe, 0 < te && (qn = f(2, cn, yn, ce, ve, Pe, tn, Me, re, Me), qn !== void 0 && (cn = qn).length === 0))
        return An + cn + ti;
      if (cn = yn.join(",") + "{" + cn + "}", le * Y !== 0) {
        switch (le !== 2 || s(cn, 2) || (Y = 0), Y) {
          case 111:
            cn = cn.replace(L, ":-moz-$1") + cn;
            break;
          case 112:
            cn = cn.replace(j, "::-webkit-input-$1") + cn.replace(j, "::-moz-$1") + cn.replace(j, ":-ms-input-$1") + cn;
        }
        Y = 0;
      }
    }
    return An + cn + ti;
  }
  function n(ce, xe, $e) {
    var Me = xe.trim().split(I);
    xe = Me;
    var re = Me.length, Qe = ce.length;
    switch (Qe) {
      case 0:
      case 1:
        var ke = 0;
        for (ce = Qe === 0 ? "" : ce[0] + " "; ke < re; ++ke)
          xe[ke] = r(ce, xe[ke], $e).trim();
        break;
      default:
        var rt = ke = 0;
        for (xe = []; ke < re; ++ke)
          for (var St = 0; St < Qe; ++St)
            xe[rt++] = r(ce[St] + " ", Me[ke], $e).trim();
    }
    return xe;
  }
  function r(ce, xe, $e) {
    var Me = xe.charCodeAt(0);
    switch (33 > Me && (Me = (xe = xe.trim()).charCodeAt(0)), Me) {
      case 38:
        return xe.replace(D, "$1" + ce.trim());
      case 58:
        return ce.trim() + xe.replace(D, "$1" + ce.trim());
      default:
        if (0 < 1 * $e && 0 < xe.indexOf("\f"))
          return xe.replace(D, (ce.charCodeAt(0) === 58 ? "" : "$1") + ce.trim());
    }
    return ce + xe;
  }
  function a(ce, xe, $e, Me) {
    var re = ce + ";", Qe = 2 * xe + 3 * $e + 4 * Me;
    if (Qe === 944) {
      ce = re.indexOf(":", 9) + 1;
      var ke = re.substring(ce, re.length - 1).trim();
      return ke = re.substring(0, ce).trim() + ke + ";", le === 1 || le === 2 && s(ke, 1) ? "-webkit-" + ke + ke : ke;
    }
    if (le === 0 || le === 2 && !s(re, 1))
      return re;
    switch (Qe) {
      case 1015:
        return re.charCodeAt(10) === 97 ? "-webkit-" + re + re : re;
      case 951:
        return re.charCodeAt(3) === 116 ? "-webkit-" + re + re : re;
      case 963:
        return re.charCodeAt(5) === 110 ? "-webkit-" + re + re : re;
      case 1009:
        if (re.charCodeAt(4) !== 100)
          break;
      case 969:
      case 942:
        return "-webkit-" + re + re;
      case 978:
        return "-webkit-" + re + "-moz-" + re + re;
      case 1019:
      case 983:
        return "-webkit-" + re + "-moz-" + re + "-ms-" + re + re;
      case 883:
        if (re.charCodeAt(8) === 45)
          return "-webkit-" + re + re;
        if (0 < re.indexOf("image-set(", 11))
          return re.replace(pe, "$1-webkit-$2") + re;
        break;
      case 932:
        if (re.charCodeAt(4) === 45)
          switch (re.charCodeAt(5)) {
            case 103:
              return "-webkit-box-" + re.replace("-grow", "") + "-webkit-" + re + "-ms-" + re.replace("grow", "positive") + re;
            case 115:
              return "-webkit-" + re + "-ms-" + re.replace("shrink", "negative") + re;
            case 98:
              return "-webkit-" + re + "-ms-" + re.replace("basis", "preferred-size") + re;
          }
        return "-webkit-" + re + "-ms-" + re + re;
      case 964:
        return "-webkit-" + re + "-ms-flex-" + re + re;
      case 1023:
        if (re.charCodeAt(8) !== 99)
          break;
        return ke = re.substring(re.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify"), "-webkit-box-pack" + ke + "-webkit-" + re + "-ms-flex-pack" + ke + re;
      case 1005:
        return _.test(re) ? re.replace(x, ":-webkit-") + re.replace(x, ":-moz-") + re : re;
      case 1e3:
        switch (ke = re.substring(13).trim(), xe = ke.indexOf("-") + 1, ke.charCodeAt(0) + ke.charCodeAt(xe)) {
          case 226:
            ke = re.replace(z, "tb");
            break;
          case 232:
            ke = re.replace(z, "tb-rl");
            break;
          case 220:
            ke = re.replace(z, "lr");
            break;
          default:
            return re;
        }
        return "-webkit-" + re + "-ms-" + ke + re;
      case 1017:
        if (re.indexOf("sticky", 9) === -1)
          break;
      case 975:
        switch (xe = (re = ce).length - 10, ke = (re.charCodeAt(xe) === 33 ? re.substring(0, xe) : re).substring(ce.indexOf(":", 7) + 1).trim(), Qe = ke.charCodeAt(0) + (ke.charCodeAt(7) | 0)) {
          case 203:
            if (111 > ke.charCodeAt(8))
              break;
          case 115:
            re = re.replace(ke, "-webkit-" + ke) + ";" + re;
            break;
          case 207:
          case 102:
            re = re.replace(ke, "-webkit-" + (102 < Qe ? "inline-" : "") + "box") + ";" + re.replace(ke, "-webkit-" + ke) + ";" + re.replace(ke, "-ms-" + ke + "box") + ";" + re;
        }
        return re + ";";
      case 938:
        if (re.charCodeAt(5) === 45)
          switch (re.charCodeAt(6)) {
            case 105:
              return ke = re.replace("-items", ""), "-webkit-" + re + "-webkit-box-" + ke + "-ms-flex-" + ke + re;
            case 115:
              return "-webkit-" + re + "-ms-flex-item-" + re.replace(X, "") + re;
            default:
              return "-webkit-" + re + "-ms-flex-line-pack" + re.replace("align-content", "").replace(X, "") + re;
          }
        break;
      case 973:
      case 989:
        if (re.charCodeAt(3) !== 45 || re.charCodeAt(4) === 122)
          break;
      case 931:
      case 953:
        if (ue.test(ce) === !0)
          return (ke = ce.substring(ce.indexOf(":") + 1)).charCodeAt(0) === 115 ? a(ce.replace("stretch", "fill-available"), xe, $e, Me).replace(":fill-available", ":stretch") : re.replace(ke, "-webkit-" + ke) + re.replace(ke, "-moz-" + ke.replace("fill-", "")) + re;
        break;
      case 962:
        if (re = "-webkit-" + re + (re.charCodeAt(5) === 102 ? "-ms-" + re : "") + re, $e + Me === 211 && re.charCodeAt(13) === 105 && 0 < re.indexOf("transform", 10))
          return re.substring(0, re.indexOf(";", 27) + 1).replace(T, "$1-webkit-$2") + re;
    }
    return re;
  }
  function s(ce, xe) {
    var $e = ce.indexOf(xe === 1 ? ":" : "{"), Me = ce.substring(0, xe !== 3 ? $e : 10);
    return $e = ce.substring($e + 1, ce.length - 1), de(xe !== 2 ? Me : Me.replace(se, "$1"), $e, xe);
  }
  function c(ce, xe) {
    var $e = a(xe, xe.charCodeAt(0), xe.charCodeAt(1), xe.charCodeAt(2));
    return $e !== xe + ";" ? $e.replace(K, " or ($1)").substring(4) : "(" + xe + ")";
  }
  function f(ce, xe, $e, Me, re, Qe, ke, rt, St, Tt) {
    for (var Le = 0, Nt = xe, Ke; Le < te; ++Le)
      switch (Ke = he[Le].call(y, ce, Nt, $e, Me, re, Qe, ke, rt, St, Tt)) {
        case void 0:
        case !1:
        case !0:
        case null:
          break;
        default:
          Nt = Ke;
      }
    if (Nt !== xe)
      return Nt;
  }
  function p(ce) {
    switch (ce) {
      case void 0:
      case null:
        te = he.length = 0;
        break;
      default:
        if (typeof ce == "function")
          he[te++] = ce;
        else if (typeof ce == "object")
          for (var xe = 0, $e = ce.length; xe < $e; ++xe)
            p(ce[xe]);
        else
          W = !!ce | 0;
    }
    return p;
  }
  function g(ce) {
    return ce = ce.prefix, ce !== void 0 && (de = null, ce ? typeof ce != "function" ? le = 1 : (le = 2, de = ce) : le = 0), g;
  }
  function y(ce, xe) {
    var $e = ce;
    if (33 > $e.charCodeAt(0) && ($e = $e.trim()), fe = $e, $e = [fe], 0 < te) {
      var Me = f(-1, xe, $e, $e, ve, Pe, 0, 0, 0, 0);
      Me !== void 0 && typeof Me == "string" && (xe = Me);
    }
    var re = e(Re, $e, xe, 0, 0);
    return 0 < te && (Me = f(-2, re, $e, $e, ve, Pe, re.length, 0, 0, 0), Me !== void 0 && (re = Me)), fe = "", Y = 0, Pe = ve = 1, re;
  }
  var v = /^\0+/g, S = /[\0\r\f]/g, x = /: */g, _ = /zoo|gra/, T = /([,: ])(transform)/g, I = /,\r+?/g, D = /([\t\r\n ])*\f?&/g, N = /@(k\w+)\s*(\S*)\s*/, j = /::(place)/g, L = /:(read-only)/g, z = /[svh]\w+-[tblr]{2}/, F = /\(\s*(.*)\s*\)/g, K = /([\s\S]*?);/g, X = /-self|flex-/g, se = /[^]*?(:[rp][el]a[\w-]+)[^]*/, ue = /stretch|:\s*\w+\-(?:conte|avail)/, pe = /([^-])(image-set\()/, Pe = 1, ve = 1, Y = 0, le = 1, Re = [], he = [], te = 0, de = null, W = 0, fe = "";
  return y.use = p, y.set = g, t !== void 0 && g(t), y;
}
var Tde = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
function kde(t) {
  var e = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return e[n] === void 0 && (e[n] = t(n)), e[n];
  };
}
var Pde = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, zN = /* @__PURE__ */ kde(
  function(t) {
    return Pde.test(t) || t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && t.charCodeAt(2) < 91;
  }
  /* Z+1 */
), DP = { exports: {} }, rr = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var UN;
function Ide() {
  if (UN)
    return rr;
  UN = 1;
  var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, r = t ? Symbol.for("react.fragment") : 60107, a = t ? Symbol.for("react.strict_mode") : 60108, s = t ? Symbol.for("react.profiler") : 60114, c = t ? Symbol.for("react.provider") : 60109, f = t ? Symbol.for("react.context") : 60110, p = t ? Symbol.for("react.async_mode") : 60111, g = t ? Symbol.for("react.concurrent_mode") : 60111, y = t ? Symbol.for("react.forward_ref") : 60112, v = t ? Symbol.for("react.suspense") : 60113, S = t ? Symbol.for("react.suspense_list") : 60120, x = t ? Symbol.for("react.memo") : 60115, _ = t ? Symbol.for("react.lazy") : 60116, T = t ? Symbol.for("react.block") : 60121, I = t ? Symbol.for("react.fundamental") : 60117, D = t ? Symbol.for("react.responder") : 60118, N = t ? Symbol.for("react.scope") : 60119;
  function j(z) {
    if (typeof z == "object" && z !== null) {
      var F = z.$$typeof;
      switch (F) {
        case e:
          switch (z = z.type, z) {
            case p:
            case g:
            case r:
            case s:
            case a:
            case v:
              return z;
            default:
              switch (z = z && z.$$typeof, z) {
                case f:
                case y:
                case _:
                case x:
                case c:
                  return z;
                default:
                  return F;
              }
          }
        case n:
          return F;
      }
    }
  }
  function L(z) {
    return j(z) === g;
  }
  return rr.AsyncMode = p, rr.ConcurrentMode = g, rr.ContextConsumer = f, rr.ContextProvider = c, rr.Element = e, rr.ForwardRef = y, rr.Fragment = r, rr.Lazy = _, rr.Memo = x, rr.Portal = n, rr.Profiler = s, rr.StrictMode = a, rr.Suspense = v, rr.isAsyncMode = function(z) {
    return L(z) || j(z) === p;
  }, rr.isConcurrentMode = L, rr.isContextConsumer = function(z) {
    return j(z) === f;
  }, rr.isContextProvider = function(z) {
    return j(z) === c;
  }, rr.isElement = function(z) {
    return typeof z == "object" && z !== null && z.$$typeof === e;
  }, rr.isForwardRef = function(z) {
    return j(z) === y;
  }, rr.isFragment = function(z) {
    return j(z) === r;
  }, rr.isLazy = function(z) {
    return j(z) === _;
  }, rr.isMemo = function(z) {
    return j(z) === x;
  }, rr.isPortal = function(z) {
    return j(z) === n;
  }, rr.isProfiler = function(z) {
    return j(z) === s;
  }, rr.isStrictMode = function(z) {
    return j(z) === a;
  }, rr.isSuspense = function(z) {
    return j(z) === v;
  }, rr.isValidElementType = function(z) {
    return typeof z == "string" || typeof z == "function" || z === r || z === g || z === s || z === a || z === v || z === S || typeof z == "object" && z !== null && (z.$$typeof === _ || z.$$typeof === x || z.$$typeof === c || z.$$typeof === f || z.$$typeof === y || z.$$typeof === I || z.$$typeof === D || z.$$typeof === N || z.$$typeof === T);
  }, rr.typeOf = j, rr;
}
var ir = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var BN;
function Rde() {
  return BN || (BN = 1, {}.NODE_ENV !== "production" && function() {
    var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, r = t ? Symbol.for("react.fragment") : 60107, a = t ? Symbol.for("react.strict_mode") : 60108, s = t ? Symbol.for("react.profiler") : 60114, c = t ? Symbol.for("react.provider") : 60109, f = t ? Symbol.for("react.context") : 60110, p = t ? Symbol.for("react.async_mode") : 60111, g = t ? Symbol.for("react.concurrent_mode") : 60111, y = t ? Symbol.for("react.forward_ref") : 60112, v = t ? Symbol.for("react.suspense") : 60113, S = t ? Symbol.for("react.suspense_list") : 60120, x = t ? Symbol.for("react.memo") : 60115, _ = t ? Symbol.for("react.lazy") : 60116, T = t ? Symbol.for("react.block") : 60121, I = t ? Symbol.for("react.fundamental") : 60117, D = t ? Symbol.for("react.responder") : 60118, N = t ? Symbol.for("react.scope") : 60119;
    function j(Le) {
      return typeof Le == "string" || typeof Le == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      Le === r || Le === g || Le === s || Le === a || Le === v || Le === S || typeof Le == "object" && Le !== null && (Le.$$typeof === _ || Le.$$typeof === x || Le.$$typeof === c || Le.$$typeof === f || Le.$$typeof === y || Le.$$typeof === I || Le.$$typeof === D || Le.$$typeof === N || Le.$$typeof === T);
    }
    function L(Le) {
      if (typeof Le == "object" && Le !== null) {
        var Nt = Le.$$typeof;
        switch (Nt) {
          case e:
            var Ke = Le.type;
            switch (Ke) {
              case p:
              case g:
              case r:
              case s:
              case a:
              case v:
                return Ke;
              default:
                var yt = Ke && Ke.$$typeof;
                switch (yt) {
                  case f:
                  case y:
                  case _:
                  case x:
                  case c:
                    return yt;
                  default:
                    return Nt;
                }
            }
          case n:
            return Nt;
        }
      }
    }
    var z = p, F = g, K = f, X = c, se = e, ue = y, pe = r, Pe = _, ve = x, Y = n, le = s, Re = a, he = v, te = !1;
    function de(Le) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), W(Le) || L(Le) === p;
    }
    function W(Le) {
      return L(Le) === g;
    }
    function fe(Le) {
      return L(Le) === f;
    }
    function ce(Le) {
      return L(Le) === c;
    }
    function xe(Le) {
      return typeof Le == "object" && Le !== null && Le.$$typeof === e;
    }
    function $e(Le) {
      return L(Le) === y;
    }
    function Me(Le) {
      return L(Le) === r;
    }
    function re(Le) {
      return L(Le) === _;
    }
    function Qe(Le) {
      return L(Le) === x;
    }
    function ke(Le) {
      return L(Le) === n;
    }
    function rt(Le) {
      return L(Le) === s;
    }
    function St(Le) {
      return L(Le) === a;
    }
    function Tt(Le) {
      return L(Le) === v;
    }
    ir.AsyncMode = z, ir.ConcurrentMode = F, ir.ContextConsumer = K, ir.ContextProvider = X, ir.Element = se, ir.ForwardRef = ue, ir.Fragment = pe, ir.Lazy = Pe, ir.Memo = ve, ir.Portal = Y, ir.Profiler = le, ir.StrictMode = Re, ir.Suspense = he, ir.isAsyncMode = de, ir.isConcurrentMode = W, ir.isContextConsumer = fe, ir.isContextProvider = ce, ir.isElement = xe, ir.isForwardRef = $e, ir.isFragment = Me, ir.isLazy = re, ir.isMemo = Qe, ir.isPortal = ke, ir.isProfiler = rt, ir.isStrictMode = St, ir.isSuspense = Tt, ir.isValidElementType = j, ir.typeOf = L;
  }()), ir;
}
({}).NODE_ENV === "production" ? DP.exports = Ide() : DP.exports = Rde();
var $de = DP.exports, P2 = $de, Mde = {
  childContextTypes: !0,
  contextType: !0,
  contextTypes: !0,
  defaultProps: !0,
  displayName: !0,
  getDefaultProps: !0,
  getDerivedStateFromError: !0,
  getDerivedStateFromProps: !0,
  mixins: !0,
  propTypes: !0,
  type: !0
}, Ade = {
  name: !0,
  length: !0,
  prototype: !0,
  caller: !0,
  callee: !0,
  arguments: !0,
  arity: !0
}, Ode = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, C5 = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, I2 = {};
I2[P2.ForwardRef] = Ode;
I2[P2.Memo] = C5;
function FN(t) {
  return P2.isMemo(t) ? C5 : I2[t.$$typeof] || Mde;
}
var Dde = Object.defineProperty, Nde = Object.getOwnPropertyNames, HN = Object.getOwnPropertySymbols, Lde = Object.getOwnPropertyDescriptor, jde = Object.getPrototypeOf, VN = Object.prototype;
function _5(t, e, n) {
  if (typeof e != "string") {
    if (VN) {
      var r = jde(e);
      r && r !== VN && _5(t, r, n);
    }
    var a = Nde(e);
    HN && (a = a.concat(HN(e)));
    for (var s = FN(t), c = FN(e), f = 0; f < a.length; ++f) {
      var p = a[f];
      if (!Ade[p] && !(n && n[p]) && !(c && c[p]) && !(s && s[p])) {
        var g = Lde(e, p);
        try {
          Dde(t, p, g);
        } catch {
        }
      }
    }
  }
  return t;
}
var zde = _5;
const Ude = /* @__PURE__ */ Np(zde);
function Au() {
  return (Au = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
    }
    return t;
  }).apply(this, arguments);
}
var YN = function(t, e) {
  for (var n = [t[0]], r = 0, a = e.length; r < a; r += 1)
    n.push(e[r], t[r + 1]);
  return n;
}, NP = function(t) {
  return t !== null && typeof t == "object" && (t.toString ? t.toString() : Object.prototype.toString.call(t)) === "[object Object]" && !k2.typeOf(t);
}, Wx = Object.freeze([]), qd = Object.freeze({});
function pb(t) {
  return typeof t == "function";
}
function LP(t) {
  return {}.NODE_ENV !== "production" && typeof t == "string" && t || t.displayName || t.name || "Component";
}
function R2(t) {
  return t && typeof t.styledComponentId == "string";
}
var Jg = typeof process < "u" && {} !== void 0 && ({}.REACT_APP_SC_ATTR || {}.SC_ATTR) || "data-styled", $2 = typeof window < "u" && "HTMLElement" in window, Bde = !!(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && {} !== void 0 && ({}.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && {}.REACT_APP_SC_DISABLE_SPEEDY !== "" ? {}.REACT_APP_SC_DISABLE_SPEEDY !== "false" && {}.REACT_APP_SC_DISABLE_SPEEDY : {}.SC_DISABLE_SPEEDY !== void 0 && {}.SC_DISABLE_SPEEDY !== "" ? {}.SC_DISABLE_SPEEDY !== "false" && {}.SC_DISABLE_SPEEDY : {}.NODE_ENV !== "production")), Fde = {}.NODE_ENV !== "production" ? { 1: `Cannot create styled-component for component: %s.

`, 2: `Can't collect styles once you've consumed a \`ServerStyleSheet\`'s styles! \`ServerStyleSheet\` is a one off instance for each server-side render cycle.

- Are you trying to reuse it across renders?
- Are you accidentally calling collectStyles twice?

`, 3: `Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.

`, 4: `The \`StyleSheetManager\` expects a valid target or sheet prop!

- Does this error occur on the client and is your target falsy?
- Does this error occur on the server and is the sheet falsy?

`, 5: `The clone method cannot be used on the client!

- Are you running in a client-like environment on the server?
- Are you trying to run SSR on the client?

`, 6: `Trying to insert a new style tag, but the given Node is unmounted!

- Are you using a custom target that isn't mounted?
- Does your document not have a valid head element?
- Have you accidentally removed a style tag manually?

`, 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: `ThemeProvider: Please make your "theme" prop an object.

`, 9: "Missing document `<head>`\n\n", 10: `Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021

`, 11: `_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.

`, 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: `%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.

`, 14: `ThemeProvider: "theme" prop is required.

`, 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: `Reached the limit of how many styled components may be created at group %s.
You may only create up to 1,073,741,824 components. If you're creating components dynamically,
as for instance in your render method then you may be running into this limitation.

`, 17: `CSSStyleSheet could not be found on HTMLStyleElement.
Has styled-components' style tag been unmounted or altered by another script?
` } : {};
function Hde() {
  for (var t = arguments.length <= 0 ? void 0 : arguments[0], e = [], n = 1, r = arguments.length; n < r; n += 1)
    e.push(n < 0 || arguments.length <= n ? void 0 : arguments[n]);
  return e.forEach(function(a) {
    t = t.replace(/%[a-z]/, a);
  }), t;
}
function gm(t) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    n[r - 1] = arguments[r];
  throw {}.NODE_ENV === "production" ? new Error("An error occurred. See https://git.io/JUIaE#" + t + " for more information." + (n.length > 0 ? " Args: " + n.join(", ") : "")) : new Error(Hde.apply(void 0, [Fde[t]].concat(n)).trim());
}
var Vde = function() {
  function t(n) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = n;
  }
  var e = t.prototype;
  return e.indexOfGroup = function(n) {
    for (var r = 0, a = 0; a < n; a++)
      r += this.groupSizes[a];
    return r;
  }, e.insertRules = function(n, r) {
    if (n >= this.groupSizes.length) {
      for (var a = this.groupSizes, s = a.length, c = s; n >= c; )
        (c <<= 1) < 0 && gm(16, "" + n);
      this.groupSizes = new Uint32Array(c), this.groupSizes.set(a), this.length = c;
      for (var f = s; f < c; f++)
        this.groupSizes[f] = 0;
    }
    for (var p = this.indexOfGroup(n + 1), g = 0, y = r.length; g < y; g++)
      this.tag.insertRule(p, r[g]) && (this.groupSizes[n]++, p++);
  }, e.clearGroup = function(n) {
    if (n < this.length) {
      var r = this.groupSizes[n], a = this.indexOfGroup(n), s = a + r;
      this.groupSizes[n] = 0;
      for (var c = a; c < s; c++)
        this.tag.deleteRule(a);
    }
  }, e.getGroup = function(n) {
    var r = "";
    if (n >= this.length || this.groupSizes[n] === 0)
      return r;
    for (var a = this.groupSizes[n], s = this.indexOfGroup(n), c = s + a, f = s; f < c; f++)
      r += this.tag.getRule(f) + `/*!sc*/
`;
    return r;
  }, t;
}(), gx = /* @__PURE__ */ new Map(), Gx = /* @__PURE__ */ new Map(), Ky = 1, ex = function(t) {
  if (gx.has(t))
    return gx.get(t);
  for (; Gx.has(Ky); )
    Ky++;
  var e = Ky++;
  return {}.NODE_ENV !== "production" && ((0 | e) < 0 || e > 1 << 30) && gm(16, "" + e), gx.set(t, e), Gx.set(e, t), e;
}, Yde = function(t) {
  return Gx.get(t);
}, Kde = function(t, e) {
  e >= Ky && (Ky = e + 1), gx.set(t, e), Gx.set(e, t);
}, Wde = "style[" + Jg + '][data-styled-version="5.3.11"]', Gde = new RegExp("^" + Jg + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'), Xde = function(t, e, n) {
  for (var r, a = n.split(","), s = 0, c = a.length; s < c; s++)
    (r = a[s]) && t.registerName(e, r);
}, qde = function(t, e) {
  for (var n = (e.textContent || "").split(`/*!sc*/
`), r = [], a = 0, s = n.length; a < s; a++) {
    var c = n[a].trim();
    if (c) {
      var f = c.match(Gde);
      if (f) {
        var p = 0 | parseInt(f[1], 10), g = f[2];
        p !== 0 && (Kde(g, p), Xde(t, g, f[3]), t.getTag().insertRules(p, r)), r.length = 0;
      } else
        r.push(c);
    }
  }
}, Qde = function() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
}, T5 = function(t) {
  var e = document.head, n = t || e, r = document.createElement("style"), a = function(f) {
    for (var p = f.childNodes, g = p.length; g >= 0; g--) {
      var y = p[g];
      if (y && y.nodeType === 1 && y.hasAttribute(Jg))
        return y;
    }
  }(n), s = a !== void 0 ? a.nextSibling : null;
  r.setAttribute(Jg, "active"), r.setAttribute("data-styled-version", "5.3.11");
  var c = Qde();
  return c && r.setAttribute("nonce", c), n.insertBefore(r, s), r;
}, Zde = function() {
  function t(n) {
    var r = this.element = T5(n);
    r.appendChild(document.createTextNode("")), this.sheet = function(a) {
      if (a.sheet)
        return a.sheet;
      for (var s = document.styleSheets, c = 0, f = s.length; c < f; c++) {
        var p = s[c];
        if (p.ownerNode === a)
          return p;
      }
      gm(17);
    }(r), this.length = 0;
  }
  var e = t.prototype;
  return e.insertRule = function(n, r) {
    try {
      return this.sheet.insertRule(r, n), this.length++, !0;
    } catch {
      return !1;
    }
  }, e.deleteRule = function(n) {
    this.sheet.deleteRule(n), this.length--;
  }, e.getRule = function(n) {
    var r = this.sheet.cssRules[n];
    return r !== void 0 && typeof r.cssText == "string" ? r.cssText : "";
  }, t;
}(), Jde = function() {
  function t(n) {
    var r = this.element = T5(n);
    this.nodes = r.childNodes, this.length = 0;
  }
  var e = t.prototype;
  return e.insertRule = function(n, r) {
    if (n <= this.length && n >= 0) {
      var a = document.createTextNode(r), s = this.nodes[n];
      return this.element.insertBefore(a, s || null), this.length++, !0;
    }
    return !1;
  }, e.deleteRule = function(n) {
    this.element.removeChild(this.nodes[n]), this.length--;
  }, e.getRule = function(n) {
    return n < this.length ? this.nodes[n].textContent : "";
  }, t;
}(), efe = function() {
  function t(n) {
    this.rules = [], this.length = 0;
  }
  var e = t.prototype;
  return e.insertRule = function(n, r) {
    return n <= this.length && (this.rules.splice(n, 0, r), this.length++, !0);
  }, e.deleteRule = function(n) {
    this.rules.splice(n, 1), this.length--;
  }, e.getRule = function(n) {
    return n < this.length ? this.rules[n] : "";
  }, t;
}(), KN = $2, tfe = { isServer: !$2, useCSSOMInjection: !Bde }, k5 = function() {
  function t(n, r, a) {
    n === void 0 && (n = qd), r === void 0 && (r = {}), this.options = Au({}, tfe, {}, n), this.gs = r, this.names = new Map(a), this.server = !!n.isServer, !this.server && $2 && KN && (KN = !1, function(s) {
      for (var c = document.querySelectorAll(Wde), f = 0, p = c.length; f < p; f++) {
        var g = c[f];
        g && g.getAttribute(Jg) !== "active" && (qde(s, g), g.parentNode && g.parentNode.removeChild(g));
      }
    }(this));
  }
  t.registerId = function(n) {
    return ex(n);
  };
  var e = t.prototype;
  return e.reconstructWithOptions = function(n, r) {
    return r === void 0 && (r = !0), new t(Au({}, this.options, {}, n), this.gs, r && this.names || void 0);
  }, e.allocateGSInstance = function(n) {
    return this.gs[n] = (this.gs[n] || 0) + 1;
  }, e.getTag = function() {
    return this.tag || (this.tag = (a = (r = this.options).isServer, s = r.useCSSOMInjection, c = r.target, n = a ? new efe(c) : s ? new Zde(c) : new Jde(c), new Vde(n)));
    var n, r, a, s, c;
  }, e.hasNameForId = function(n, r) {
    return this.names.has(n) && this.names.get(n).has(r);
  }, e.registerName = function(n, r) {
    if (ex(n), this.names.has(n))
      this.names.get(n).add(r);
    else {
      var a = /* @__PURE__ */ new Set();
      a.add(r), this.names.set(n, a);
    }
  }, e.insertRules = function(n, r, a) {
    this.registerName(n, r), this.getTag().insertRules(ex(n), a);
  }, e.clearNames = function(n) {
    this.names.has(n) && this.names.get(n).clear();
  }, e.clearRules = function(n) {
    this.getTag().clearGroup(ex(n)), this.clearNames(n);
  }, e.clearTag = function() {
    this.tag = void 0;
  }, e.toString = function() {
    return function(n) {
      for (var r = n.getTag(), a = r.length, s = "", c = 0; c < a; c++) {
        var f = Yde(c);
        if (f !== void 0) {
          var p = n.names.get(f), g = r.getGroup(c);
          if (p && g && p.size) {
            var y = Jg + ".g" + c + '[id="' + f + '"]', v = "";
            p !== void 0 && p.forEach(function(S) {
              S.length > 0 && (v += S + ",");
            }), s += "" + g + y + '{content:"' + v + `"}/*!sc*/
`;
          }
        }
      }
      return s;
    }(this);
  }, t;
}(), nfe = /(a)(d)/gi, WN = function(t) {
  return String.fromCharCode(t + (t > 25 ? 39 : 97));
};
function jP(t) {
  var e, n = "";
  for (e = Math.abs(t); e > 52; e = e / 52 | 0)
    n = WN(e % 52) + n;
  return (WN(e % 52) + n).replace(nfe, "$1-$2");
}
var wp = function(t, e) {
  for (var n = e.length; n; )
    t = 33 * t ^ e.charCodeAt(--n);
  return t;
}, P5 = function(t) {
  return wp(5381, t);
};
function rfe(t) {
  for (var e = 0; e < t.length; e += 1) {
    var n = t[e];
    if (pb(n) && !R2(n))
      return !1;
  }
  return !0;
}
var ife = P5("5.3.11"), ofe = function() {
  function t(e, n, r) {
    this.rules = e, this.staticRulesId = "", this.isStatic = {}.NODE_ENV === "production" && (r === void 0 || r.isStatic) && rfe(e), this.componentId = n, this.baseHash = wp(ife, n), this.baseStyle = r, k5.registerId(n);
  }
  return t.prototype.generateAndInjectStyles = function(e, n, r) {
    var a = this.componentId, s = [];
    if (this.baseStyle && s.push(this.baseStyle.generateAndInjectStyles(e, n, r)), this.isStatic && !r.hash)
      if (this.staticRulesId && n.hasNameForId(a, this.staticRulesId))
        s.push(this.staticRulesId);
      else {
        var c = em(this.rules, e, n, r).join(""), f = jP(wp(this.baseHash, c) >>> 0);
        if (!n.hasNameForId(a, f)) {
          var p = r(c, "." + f, void 0, a);
          n.insertRules(a, f, p);
        }
        s.push(f), this.staticRulesId = f;
      }
    else {
      for (var g = this.rules.length, y = wp(this.baseHash, r.hash), v = "", S = 0; S < g; S++) {
        var x = this.rules[S];
        if (typeof x == "string")
          v += x, {}.NODE_ENV !== "production" && (y = wp(y, x + S));
        else if (x) {
          var _ = em(x, e, n, r), T = Array.isArray(_) ? _.join("") : _;
          y = wp(y, T + S), v += T;
        }
      }
      if (v) {
        var I = jP(y >>> 0);
        if (!n.hasNameForId(a, I)) {
          var D = r(v, "." + I, void 0, a);
          n.insertRules(a, I, D);
        }
        s.push(I);
      }
    }
    return s.join(" ");
  }, t;
}(), afe = /^\s*\/\/.*$/gm, sfe = [":", "[", ".", "#"];
function lfe(t) {
  var e, n, r, a, s = t === void 0 ? qd : t, c = s.options, f = c === void 0 ? qd : c, p = s.plugins, g = p === void 0 ? Wx : p, y = new _de(f), v = [], S = function(T) {
    function I(D) {
      if (D)
        try {
          T(D + "}");
        } catch {
        }
    }
    return function(D, N, j, L, z, F, K, X, se, ue) {
      switch (D) {
        case 1:
          if (se === 0 && N.charCodeAt(0) === 64)
            return T(N + ";"), "";
          break;
        case 2:
          if (X === 0)
            return N + "/*|*/";
          break;
        case 3:
          switch (X) {
            case 102:
            case 112:
              return T(j[0] + N), "";
            default:
              return N + (ue === 0 ? "/*|*/" : "");
          }
        case -2:
          N.split("/*|*/}").forEach(I);
      }
    };
  }(function(T) {
    v.push(T);
  }), x = function(T, I, D) {
    return I === 0 && sfe.indexOf(D[n.length]) !== -1 || D.match(a) ? T : "." + e;
  };
  function _(T, I, D, N) {
    N === void 0 && (N = "&");
    var j = T.replace(afe, ""), L = I && D ? D + " " + I + " { " + j + " }" : j;
    return e = N, n = I, r = new RegExp("\\" + n + "\\b", "g"), a = new RegExp("(\\" + n + "\\b){2,}"), y(D || !I ? "" : I, L);
  }
  return y.use([].concat(g, [function(T, I, D) {
    T === 2 && D.length && D[0].lastIndexOf(n) > 0 && (D[0] = D[0].replace(r, x));
  }, S, function(T) {
    if (T === -2) {
      var I = v;
      return v = [], I;
    }
  }])), _.hash = g.length ? g.reduce(function(T, I) {
    return I.name || gm(15), wp(T, I.name);
  }, 5381).toString() : "", _;
}
var I5 = It.createContext();
I5.Consumer;
var R5 = It.createContext(), cfe = (R5.Consumer, new k5()), zP = lfe();
function ufe() {
  return k.useContext(I5) || cfe;
}
function dfe() {
  return k.useContext(R5) || zP;
}
var ffe = function() {
  function t(e, n) {
    var r = this;
    this.inject = function(a, s) {
      s === void 0 && (s = zP);
      var c = r.name + s.hash;
      a.hasNameForId(r.id, c) || a.insertRules(r.id, c, s(r.rules, c, "@keyframes"));
    }, this.toString = function() {
      return gm(12, String(r.name));
    }, this.name = e, this.id = "sc-keyframes-" + e, this.rules = n;
  }
  return t.prototype.getName = function(e) {
    return e === void 0 && (e = zP), this.name + e.hash;
  }, t;
}(), pfe = /([A-Z])/, hfe = /([A-Z])/g, gfe = /^ms-/, mfe = function(t) {
  return "-" + t.toLowerCase();
};
function GN(t) {
  return pfe.test(t) ? t.replace(hfe, mfe).replace(gfe, "-ms-") : t;
}
var XN = function(t) {
  return t == null || t === !1 || t === "";
};
function em(t, e, n, r) {
  if (Array.isArray(t)) {
    for (var a, s = [], c = 0, f = t.length; c < f; c += 1)
      (a = em(t[c], e, n, r)) !== "" && (Array.isArray(a) ? s.push.apply(s, a) : s.push(a));
    return s;
  }
  if (XN(t))
    return "";
  if (R2(t))
    return "." + t.styledComponentId;
  if (pb(t)) {
    if (typeof (g = t) != "function" || g.prototype && g.prototype.isReactComponent || !e)
      return t;
    var p = t(e);
    return {}.NODE_ENV !== "production" && k2.isElement(p) && console.warn(LP(t) + " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."), em(p, e, n, r);
  }
  var g;
  return t instanceof ffe ? n ? (t.inject(n, r), t.getName(r)) : t : NP(t) ? function y(v, S) {
    var x, _, T = [];
    for (var I in v)
      v.hasOwnProperty(I) && !XN(v[I]) && (Array.isArray(v[I]) && v[I].isCss || pb(v[I]) ? T.push(GN(I) + ":", v[I], ";") : NP(v[I]) ? T.push.apply(T, y(v[I], I)) : T.push(GN(I) + ": " + (x = I, (_ = v[I]) == null || typeof _ == "boolean" || _ === "" ? "" : typeof _ != "number" || _ === 0 || x in Tde || x.startsWith("--") ? String(_).trim() : _ + "px") + ";"));
    return S ? [S + " {"].concat(T, ["}"]) : T;
  }(t) : t.toString();
}
var qN = function(t) {
  return Array.isArray(t) && (t.isCss = !0), t;
};
function $5(t) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    n[r - 1] = arguments[r];
  return pb(t) || NP(t) ? qN(em(YN(Wx, [t].concat(n)))) : n.length === 0 && t.length === 1 && typeof t[0] == "string" ? t : qN(em(YN(t, n)));
}
var QN = /invalid hook call/i, tx = /* @__PURE__ */ new Set(), vfe = function(t, e) {
  if ({}.NODE_ENV !== "production") {
    var n = "The component " + t + (e ? ' with the id of "' + e + '"' : "") + ` has been created dynamically.
You may see this warning because you've called styled inside another component.
To resolve this only create new StyledComponents outside of any render method and function component.`, r = console.error;
    try {
      var a = !0;
      console.error = function(s) {
        if (QN.test(s))
          a = !1, tx.delete(n);
        else {
          for (var c = arguments.length, f = new Array(c > 1 ? c - 1 : 0), p = 1; p < c; p++)
            f[p - 1] = arguments[p];
          r.apply(void 0, [s].concat(f));
        }
      }, k.useRef(), a && !tx.has(n) && (console.warn(n), tx.add(n));
    } catch (s) {
      QN.test(s.message) && tx.delete(n);
    } finally {
      console.error = r;
    }
  }
}, yfe = function(t, e, n) {
  return n === void 0 && (n = qd), t.theme !== n.theme && t.theme || e || n.theme;
}, bfe = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, Sfe = /(^-|-$)/g;
function Ak(t) {
  return t.replace(bfe, "-").replace(Sfe, "");
}
var wfe = function(t) {
  return jP(P5(t) >>> 0);
};
function nx(t) {
  return typeof t == "string" && ({}.NODE_ENV === "production" || t.charAt(0) === t.charAt(0).toLowerCase());
}
var UP = function(t) {
  return typeof t == "function" || typeof t == "object" && t !== null && !Array.isArray(t);
}, xfe = function(t) {
  return t !== "__proto__" && t !== "constructor" && t !== "prototype";
};
function Efe(t, e, n) {
  var r = t[n];
  UP(e) && UP(r) ? M5(r, e) : t[n] = e;
}
function M5(t) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    n[r - 1] = arguments[r];
  for (var a = 0, s = n; a < s.length; a++) {
    var c = s[a];
    if (UP(c))
      for (var f in c)
        xfe(f) && Efe(t, c[f], f);
  }
  return t;
}
var A5 = It.createContext();
A5.Consumer;
var Ok = {};
function O5(t, e, n) {
  var r = R2(t), a = !nx(t), s = e.attrs, c = s === void 0 ? Wx : s, f = e.componentId, p = f === void 0 ? function(N, j) {
    var L = typeof N != "string" ? "sc" : Ak(N);
    Ok[L] = (Ok[L] || 0) + 1;
    var z = L + "-" + wfe("5.3.11" + L + Ok[L]);
    return j ? j + "-" + z : z;
  }(e.displayName, e.parentComponentId) : f, g = e.displayName, y = g === void 0 ? function(N) {
    return nx(N) ? "styled." + N : "Styled(" + LP(N) + ")";
  }(t) : g, v = e.displayName && e.componentId ? Ak(e.displayName) + "-" + e.componentId : e.componentId || p, S = r && t.attrs ? Array.prototype.concat(t.attrs, c).filter(Boolean) : c, x = e.shouldForwardProp;
  r && t.shouldForwardProp && (x = e.shouldForwardProp ? function(N, j, L) {
    return t.shouldForwardProp(N, j, L) && e.shouldForwardProp(N, j, L);
  } : t.shouldForwardProp);
  var _, T = new ofe(n, v, r ? t.componentStyle : void 0), I = T.isStatic && c.length === 0, D = function(N, j) {
    return function(L, z, F, K) {
      var X = L.attrs, se = L.componentStyle, ue = L.defaultProps, pe = L.foldedComponentIds, Pe = L.shouldForwardProp, ve = L.styledComponentId, Y = L.target, le = function(Me, re, Qe) {
        Me === void 0 && (Me = qd);
        var ke = Au({}, re, { theme: Me }), rt = {};
        return Qe.forEach(function(St) {
          var Tt, Le, Nt, Ke = St;
          for (Tt in pb(Ke) && (Ke = Ke(ke)), Ke)
            ke[Tt] = rt[Tt] = Tt === "className" ? (Le = rt[Tt], Nt = Ke[Tt], Le && Nt ? Le + " " + Nt : Le || Nt) : Ke[Tt];
        }), [ke, rt];
      }(yfe(z, k.useContext(A5), ue) || qd, z, X), Re = le[0], he = le[1], te = function(Me, re, Qe, ke) {
        var rt = ufe(), St = dfe(), Tt = re ? Me.generateAndInjectStyles(qd, rt, St) : Me.generateAndInjectStyles(Qe, rt, St);
        return {}.NODE_ENV !== "production" && !re && ke && ke(Tt), Tt;
      }(se, K, Re, {}.NODE_ENV !== "production" ? L.warnTooManyClasses : void 0), de = F, W = he.$as || z.$as || he.as || z.as || Y, fe = nx(W), ce = he !== z ? Au({}, z, {}, he) : z, xe = {};
      for (var $e in ce)
        $e[0] !== "$" && $e !== "as" && ($e === "forwardedAs" ? xe.as = ce[$e] : (Pe ? Pe($e, zN, W) : !fe || zN($e)) && (xe[$e] = ce[$e]));
      return z.style && he.style !== z.style && (xe.style = Au({}, z.style, {}, he.style)), xe.className = Array.prototype.concat(pe, ve, te !== ve ? te : null, z.className, he.className).filter(Boolean).join(" "), xe.ref = de, k.createElement(W, xe);
    }(_, N, j, I);
  };
  return D.displayName = y, (_ = It.forwardRef(D)).attrs = S, _.componentStyle = T, _.displayName = y, _.shouldForwardProp = x, _.foldedComponentIds = r ? Array.prototype.concat(t.foldedComponentIds, t.styledComponentId) : Wx, _.styledComponentId = v, _.target = r ? t.target : t, _.withComponent = function(N) {
    var j = e.componentId, L = function(F, K) {
      if (F == null)
        return {};
      var X, se, ue = {}, pe = Object.keys(F);
      for (se = 0; se < pe.length; se++)
        X = pe[se], K.indexOf(X) >= 0 || (ue[X] = F[X]);
      return ue;
    }(e, ["componentId"]), z = j && j + "-" + (nx(N) ? N : Ak(LP(N)));
    return O5(N, Au({}, L, { attrs: S, componentId: z }), n);
  }, Object.defineProperty(_, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(N) {
    this._foldedDefaultProps = r ? M5({}, t.defaultProps, N) : N;
  } }), {}.NODE_ENV !== "production" && (vfe(y, v), _.warnTooManyClasses = function(N, j) {
    var L = {}, z = !1;
    return function(F) {
      if (!z && (L[F] = !0, Object.keys(L).length >= 200)) {
        var K = j ? ' with the id of "' + j + '"' : "";
        console.warn("Over 200 classes were generated for component " + N + K + `.
Consider using the attrs method, together with a style object for frequently changed styles.
Example:
  const Component = styled.div.attrs(props => ({
    style: {
      background: props.background,
    },
  }))\`width: 100%;\`

  <Component />`), z = !0, L = {};
      }
    };
  }(y, v)), Object.defineProperty(_, "toString", { value: function() {
    return "." + _.styledComponentId;
  } }), a && Ude(_, t, { attrs: !0, componentStyle: !0, displayName: !0, foldedComponentIds: !0, shouldForwardProp: !0, styledComponentId: !0, target: !0, withComponent: !0 }), _;
}
var BP = function(t) {
  return function e(n, r, a) {
    if (a === void 0 && (a = qd), !k2.isValidElementType(r))
      return gm(1, String(r));
    var s = function() {
      return n(r, a, $5.apply(void 0, arguments));
    };
    return s.withConfig = function(c) {
      return e(n, r, Au({}, a, {}, c));
    }, s.attrs = function(c) {
      return e(n, r, Au({}, a, { attrs: Array.prototype.concat(a.attrs, c).filter(Boolean) }));
    }, s;
  }(O5, t);
};
["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(t) {
  BP[t] = BP(t);
});
({}).NODE_ENV !== "production" && typeof navigator < "u" && navigator.product === "ReactNative" && console.warn(`It looks like you've imported 'styled-components' on React Native.
Perhaps you're looking to import 'styled-components/native'?
Read more about this at https://www.styled-components.com/docs/basics#react-native`), {}.NODE_ENV !== "production" && {}.NODE_ENV !== "test" && typeof window < "u" && (window["__styled-components-init__"] = window["__styled-components-init__"] || 0, window["__styled-components-init__"] === 1 && console.warn(`It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.

See https://s-c.sh/2BAXzed for more info.`), window["__styled-components-init__"] += 1);
const $r = BP, Cfe = {
  data: {
    cssClass: "",
    editable: !1,
    document: null,
    data: null,
    limited: !1,
    options: {
      baseApplication: null,
      width: 0,
      height: 0,
      top: 0,
      left: 0,
      scale: 0,
      popOut: !1,
      minimizable: !1,
      resizable: !1,
      id: "",
      classes: [],
      dragDrop: [],
      tabs: [],
      filters: [],
      title: "",
      template: "",
      scrollY: [],
      closeOnSubmit: !1,
      editable: !1,
      sheetConfig: !1,
      submitOnChange: !1,
      submitOnClose: !1,
      viewPermission: 0,
      secrets: [],
      viewClasses: [],
      includeTOC: !1
    },
    owner: !1,
    title: "",
    headingLevels: {},
    id: ""
  },
  sheet: {},
  useDropEffect() {
    throw new Error("Not Implemented");
  },
  useCloseEffect() {
    throw new Error("Not Implemented");
  }
}, D5 = k.createContext(Cfe), _fe = () => k.useContext(D5), Tfe = ({ data: t, form: e, sheet: n, addCloseListener: r, children: a }) => {
  const s = (f, p) => k.useEffect(() => {
    if (t.editable)
      return $(e).on("drop", ({ originalEvent: g }) => {
        let y;
        try {
          y = JSON.parse(g?.dataTransfer?.getData("text/plain") ?? ""), f(y);
        } catch {
          console.error(`${zy} | Not allowed: `, g?.dataTransfer?.getData("text/plain") ?? g);
        }
      }), () => {
        $(e).off("drop");
      };
  }, [e, t.editable, ...p]), c = (f, p) => k.useEffect(() => {
    r(f);
  }, [n, ...p]);
  return /* @__PURE__ */ E.jsx(D5.Provider, { value: { data: t, sheet: n, useDropEffect: s, useCloseEffect: c }, children: a });
};
class ZN {
  constructor() {
    this.stores = /* @__PURE__ */ new Map();
  }
  activateSocketListeners(e) {
    this.socket = e, this.socket.register("connectUser", this.handleConnectUser.bind(this)), this.socket.register("disconnectUser", this.handleDisconnectUser.bind(this)), this.socket.register("updateUsers", this.handleUpdateUsers.bind(this)), this.socket.register("getRemoteSnapshot", this.handleGetRemoteSnapshot.bind(this)), this.socket.register("events", this.handleEvents.bind(this));
  }
  registerStore(e, n) {
    this.stores.set(e, n);
  }
  getStore(e) {
    const n = this.stores.get(e);
    if (!n)
      throw new Error(`No store found for instance ${e}`);
    return n;
  }
  connectUser(e) {
    this.socket.executeForOthers("connectUser", e);
  }
  disconnectUser(e, n) {
    this.socket.executeForOthers("disconnectUser", e, n);
  }
  handleDisconnectUser(e, n) {
    let r;
    try {
      r = this.getStore(e);
    } catch {
      return;
    }
    r.mergeRemoteChanges(() => {
      r.remove([n]);
    });
  }
  handleConnectUser(e) {
    let n;
    try {
      n = this.getStore(e);
    } catch {
      return;
    }
    const r = n.serialize((a) => ["user", "user_presence"].includes(a.typeName));
    this.socket.executeForOthers("updateUsers", e, r);
  }
  handleUpdateUsers(e, n) {
    const r = this.getStore(e);
    r.mergeRemoteChanges(() => {
      r.put(Object.values(n));
    });
  }
  handleEvents(e) {
    let n;
    try {
      n = this.getStore(e.instanceId);
    } catch {
      return;
    }
    const r = oX(n.schema.serialize(), e.schema);
    if (r === -1) {
      console.error(`${zy} | Schema mismatch. Can't apply changes.`);
      return;
    } else
      r === 1 && console.warn(`${zy} | Schema mismatch. Applying changes anyway.`);
    n.mergeRemoteChanges(() => {
      n.applyDiff(e.changes);
    });
  }
  async restoreFromRemote(e) {
    const n = await this.socket.executeAsGM(
      "getRemoteSnapshot",
      e
    );
    if (!n)
      return;
    const r = this.getStore(e), a = r.schema.migrateStoreSnapshot(n.store, n.schema);
    a.type !== "error" && r.mergeRemoteChanges(() => {
      r.put(Object.values(a.value));
    });
  }
  handleGetRemoteSnapshot(e) {
    const n = this.getStore(e);
    return {
      store: n.serialize((s) => ![
        "instance",
        "camera",
        "instance_page_state",
        "instance_presence",
        "user_document"
      ].includes(s.typeName)),
      schema: n.schema.serialize()
    };
  }
  getSnapshot(e) {
    const n = this.getStore(e);
    return {
      store: n.serialize((s) => ![
        "instance",
        "camera",
        "instance_page_state",
        "user",
        "instance_presence",
        "user_document",
        "user_presence"
      ].includes(s.typeName)),
      schema: n.schema.serialize()
    };
  }
  restoreSnapshot(e, n) {
    const r = this.getStore(e), a = r.schema.migrateStoreSnapshot(n.store, n.schema);
    if (a.type === "error") {
      console.error(`${zy} | Failed to migrate snapshot: ${a.reason}`);
      return;
    }
    r.deserialize(a.value);
  }
  put(e, n, r) {
    if (r !== "user")
      return;
    const a = this.getStore(e);
    this.socket.executeForEveryone("events", {
      instanceId: e,
      changes: n,
      schema: a.schema.serialize()
    });
  }
  listen(e, n) {
    return this.getStore(e).listen(n);
  }
  getConcurrentUsers(e) {
    const n = this.getStore(e), r = n.serialize((c) => ["user"].includes(c.typeName)), a = n.serialize((c) => ["user_presence"].includes(c.typeName)), s = {};
    for (const [c, f] of Object.entries(r)) {
      const p = Object.values(a).find((g) => g.userId === c);
      s[f.id] = {
        name: f.name,
        id: c,
        color: p?.color
      };
    }
    return Object.values(s);
  }
  isCollaborativeMode() {
    return game.modules.get("socketlib")?.active;
  }
}
let Hi;
const kfe = {
  hooks: {
    init() {
      Hi || (Hi = new ZN());
    },
    socketlib() {
      const t = socketlib.registerModule(Tp);
      Hi || (Hi = new ZN()), Hi.activateSocketListeners(t);
    }
  }
}, Pfe = {
  app: null,
  setApp: (t) => null,
  save: () => null,
  concurrentUsers: []
}, N5 = k.createContext(Pfe), M2 = () => k.useContext(N5), Ife = ({ instanceId: t, onSave: e, children: n }) => {
  const [r, a] = k.useState(null), s = k.useRef(), [c, f] = k.useState([]);
  return k.useEffect(() => {
    if (!(!r || !Hi.isCollaborativeMode()))
      return s.current = Hi.listen(t, () => {
        const p = Hi.getConcurrentUsers(t);
        foundry.utils.objectsEqual(c.map((g) => g.id), p.map((g) => g.id)) || f(p);
      }), () => {
        s.current();
      };
  }, [r?.store, c, f, Hi.isCollaborativeMode()]), /* @__PURE__ */ E.jsx(N5.Provider, { value: { app: r, setApp: a, save: e, concurrentUsers: c }, children: n });
}, Rfe = () => {
  const { concurrentUsers: t } = M2();
  return t.length < 2 ? null : /* @__PURE__ */ E.jsxs($fe, { "data-tooltip": t.map((e) => e.name).join(", "), children: [
    /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-user-group" }),
    t.map((e) => /* @__PURE__ */ E.jsxs(Mfe, { color: e.color, children: [
      " ",
      e.name?.[0],
      " "
    ] }, e.id))
  ] });
}, $fe = $r.li`
    justify-content: center;
    align-items: center;
    padding: 0 6px;
    background: #d9d8c8;
    border: 1px solid #ff6400;
    border-radius: 3px;
    box-shadow: 0 0 4px #ff6400;
    display: flex;
`, Mfe = $r.span`
    background: ${(t) => t.color};
    border: 1px solid ${(t) => t.color};
    width: 14px;
    height: 15px;
    border-radius: 50%;
    margin-right: -3px;
    line-height: 0.75rem;
    font-size: 0.625rem;
    text-align: center;
    color: black;
    font-weight: 700;
`, Afe = () => {
  const { app: t, save: e } = M2(), [n, r] = k.useState(t?.isGridMode), a = k.useCallback(() => {
    e();
  }, [t]), s = k.useCallback(() => {
    !t || t.currentToolId !== "select" || (t.setGridMode(!t.isGridMode), r(t.isGridMode));
  }, [t]), c = k.useCallback(() => {
    if (!t || t.currentToolId !== "select")
      return;
    const T = t.selectedIds, I = ot.Common(Gt(T.map((N) => t.getPageBoundsById(N)))), D = t.canMoveCamera ? {
      x: I.width + 10,
      y: 0
    } : {
      x: 16 / t.zoomLevel,
      y: 16 / t.zoomLevel
    };
    t.mark("duplicate shapes"), t.duplicateShapes(T, D);
  }, [t]), f = k.useCallback(() => {
    !t || t.currentToolId !== "select" || (t.mark("align left"), t.alignShapes("left", t.selectedIds));
  }, [t]), p = k.useCallback(() => {
    !t || t.currentToolId !== "select" || (t.mark("align center horizontal"), t.alignShapes("center-horizontal", t.selectedIds));
  }, [t]), g = k.useCallback(() => {
    !t || t.currentToolId !== "select" || (t.mark("align right"), t.alignShapes("right", t.selectedIds));
  }, [t]), y = k.useCallback(() => {
    !t || t.currentToolId !== "select" || (t.mark("align top"), t.alignShapes("top", t.selectedIds));
  }, [t]), v = k.useCallback(() => {
    !t || t.currentToolId !== "select" || (t.mark("align center vertical"), t.alignShapes("center-vertical", t.selectedIds));
  }, [t]), S = k.useCallback(() => {
    !t || t.currentToolId !== "select" || (t.mark("align bottom"), t.alignShapes("bottom", t.selectedIds));
  }, [t]), x = k.useCallback(() => {
    !t || t.currentToolId !== "select" || (t.mark("distribute horizontal"), t.distributeShapes("horizontal", t.selectedIds));
  }, [t]), _ = k.useCallback(() => {
    !t || t.currentToolId !== "select" || (t.mark("distribute vertical"), t.distributeShapes("vertical", t.selectedIds));
  }, [t]);
  return /* @__PURE__ */ E.jsxs(Ofe, { children: [
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Tl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("JW.ShowGrid"),
        onClick: s,
        active: n,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-grid" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Tl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("JW.AlignLeft"),
        onClick: f,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-objects-align-left" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Tl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("JW.AlignHorizontally"),
        onClick: p,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-objects-align-center-horizontal" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Tl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("JW.AlignRight"),
        onClick: g,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-objects-align-right" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Tl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("JW.AlignTop"),
        onClick: y,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-objects-align-top" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Tl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("JW.AlignVertically"),
        onClick: v,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-objects-align-center-vertical" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Tl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("JW.AlignBottom"),
        onClick: S,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-objects-align-bottom" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Tl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("JW.DistributeHorizontally"),
        onClick: x,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-distribute-spacing-horizontal" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Tl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("JW.DistributeVertically"),
        onClick: _,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-distribute-spacing-vertical" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Tl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("Duplicate"),
        onClick: c,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-clone" })
      }
    ) }),
    /* @__PURE__ */ E.jsx("li", { children: /* @__PURE__ */ E.jsx(
      Tl,
      {
        type: "button",
        "data-tooltip": game.i18n.localize("Save Changes"),
        onClick: a,
        children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-save" })
      }
    ) }),
    /* @__PURE__ */ E.jsx(Rfe, {})
  ] });
}, Ofe = $r.menu`
    display: flex;
    margin: 0;
    padding: 2px 8px;
    background: rgba(0, 0, 0, 0.1);
    flex-wrap: wrap;
    flex: none;
    list-style: none;

    & > li {
        margin: 6px 2px;
    }
    /* height: 42px; */
`, Tl = $r.button`
    background: transparent;
    cursor: pointer;
    padding: 0 5px;
    margin: 0 1px;
    line-height: 26px;
    border: none;
    border-radius: 4px;
    font-size: 0.875rem;
    font-family: 'Signika', sans-serif;
    width: 100%;
    box-sizing: border-box;
    ${(t) => t.active && $5`
            box-shadow: none;
            background: #f0f0e0;
            color: black;
        `}

    &:hover {
        box-shadow: none;
        background: #f0f0e0;
        color: black;
    }

    i {
        margin: 0;
        font-size: 14px;
    }
`, U1 = [], Tu = (t) => {
  U1.push(t);
}, Dfe = () => U1.map((t) => t.shape), Nfe = () => U1.map((t) => t.tool), Lfe = (t) => U1.find((e) => e.dataTransferType === t)?.shape, jfe = hde(), zfe = gde(), Ufe = 1e3, Bfe = ({
  store: t,
  config: e,
  onMount: n,
  userId: r,
  instanceId: a
}) => {
  const { data: s, sheet: c, useDropEffect: f, useCloseEffect: p } = _fe(), g = k.useCallback(cI(async (T, I) => {
    if (T)
      return await c.document.update(T, I);
  }, Ufe), [c?.document]), [y, v] = It.useState(s?.data?.title?.show), { app: S, setApp: x } = M2(), _ = k.useCallback((T) => {
    x(T), n(T);
  }, [n]);
  return f((T) => {
    if (!S)
      return;
    const I = Lfe(T?.type);
    if (!I)
      return;
    const D = S.createShapeId();
    S.createShapes([
      {
        id: D,
        type: I.type,
        x: S.viewportPageBounds.center.x,
        y: S.viewportPageBounds.center.y,
        props: {
          id: T.uuid,
          type: T.type
        }
      }
    ]), S.setSelectedIds([D]), S.setSelectedTool("select.idle");
  }, [S]), p(() => {
    Hi.isCollaborativeMode() && Hi.disconnectUser(a, r);
  }, [Hi, a, r]), /* @__PURE__ */ E.jsxs(Ffe, { className: s.cssClass, children: [
    s?.editable && /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
      /* @__PURE__ */ E.jsxs("header", { className: "journal-header", children: [
        /* @__PURE__ */ E.jsx(
          "input",
          {
            className: "title",
            type: "text",
            defaultValue: s?.data?.name,
            onChange: (T) => {
              g({ name: T.target.value });
            },
            placeholder: "Page Name"
          },
          s.id
        ),
        /* @__PURE__ */ E.jsxs("aside", { className: "page-level flexcol", children: [
          /* @__PURE__ */ E.jsxs("div", { className: "heading-level flexrow", children: [
            /* @__PURE__ */ E.jsx("label", { className: "flex0", "data-tooltip": "Heading Level", children: /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-list-tree" }) }),
            /* @__PURE__ */ E.jsx(
              "select",
              {
                name: "title.level",
                onChange: ({ currentTarget: T }) => {
                  s.document.update(
                    { title: { level: T.value } },
                    { render: !1 }
                  );
                },
                value: s.data.title.level,
                children: Object.entries(s.headingLevels).map(([T, I]) => /* @__PURE__ */ E.jsx("option", { value: T, children: I }, T))
              }
            )
          ] }),
          /* @__PURE__ */ E.jsx("div", { className: "show-title", children: /* @__PURE__ */ E.jsxs("label", { className: "checkbox", children: [
            "Display Page Title",
            /* @__PURE__ */ E.jsx(
              "input",
              {
                type: "checkbox",
                name: "title.show",
                checked: y,
                onChange: ({ currentTarget: T }) => {
                  s.document.update(
                    { title: { show: T.checked } },
                    { render: !1 }
                  ), v(T.checked);
                }
              }
            )
          ] }) })
        ] })
      ] }),
      /* @__PURE__ */ E.jsx(Afe, {})
    ] }),
    y && !s?.editable && /* @__PURE__ */ E.jsx("header", { className: "journal-page-header", children: /* @__PURE__ */ E.jsx("h1", { children: s?.data?.name }) }),
    /* @__PURE__ */ E.jsx(
      qre,
      {
        assetUrls: jfe,
        config: e,
        store: t,
        onMount: _,
        userId: r,
        instanceId: a,
        children: /* @__PURE__ */ E.jsx(dde, { assetUrls: zfe, overrides: yde, children: /* @__PURE__ */ E.jsx(oue, { children: /* @__PURE__ */ E.jsx(Oj, {}) }) })
      }
    )
  ] });
}, Ffe = $r.div`
    display: flex;
    flex-direction: column;
    height: 100%;
`;
var FP, rx = dm;
if ({}.NODE_ENV === "production")
  FP = rx.createRoot, rx.hydrateRoot;
else {
  var JN = rx.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  FP = function(t, e) {
    JN.usingClientEntryPoint = !0;
    try {
      return rx.createRoot(t, e);
    } finally {
      JN.usingClientEntryPoint = !1;
    }
  };
}
class Hfe extends JournalPageSheet {
  constructor() {
    super(...arguments), this.root = null, this._onCloseListeners = [], this.addCloseListener = (e) => {
      this._onCloseListeners.push(e);
    };
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      submitOnClose: !1,
      submitOnChange: !1
    });
  }
  async _renderInner(e) {
    return this.createForm(), this.componentDidMount(e), this.createReactRoot(e), $(this.form);
  }
  createForm() {
    this.form || (this.form = document.createElement("form"), this.form.setAttribute("autocomplete", "off"));
  }
  createReactRoot(e) {
    this.root || (this.root = FP(this.form)), this.root.render(
      /* @__PURE__ */ E.jsx(Tfe, { data: e, form: $(this.form), sheet: this, addCloseListener: this.addCloseListener, children: this.reactComponent() })
    );
  }
  async _render(e = !1, n = {}) {
    if (!e && this._state === Application.RENDER_STATES.RENDERED && !n?.data?.system) {
      this.refreshWindowTitle();
      return;
    }
    return console.log(`${zy} | render`, { appId: this.appId, force: e, action: n.action, state: this._state, rendered: this._state === Application.RENDER_STATES.RENDERED }), super._render(e, n);
  }
  refreshWindowTitle() {
    let e = this.element.find(".window-title")[0];
    e && (e.hasChildNodes() && (e = e.childNodes[0]), e.textContent = this.title);
  }
  async close() {
    this.root?.unmount(), this.root = null;
    for (const e of this._onCloseListeners)
      e();
    return this._onCloseListeners = [], await super.close();
  }
  deactivateListeners(e) {
    e.find("img[data-edit]").off("click"), e.find("input,select,textarea").off("change"), e.find("button.file-picker").off("click");
  }
  activateListeners(e) {
    this.deactivateListeners(e), super.activateListeners(e);
  }
  _activateEditor(e) {
  }
  async saveEditor(e, n = {}) {
  }
}
class Vfe extends Hfe {
  constructor() {
    super(...arguments), this.handleMount = async (e) => {
      if (this.tldrawApp = e, Dk.theme === "dark" ? this.tldrawApp.setDarkMode(!0) : this.tldrawApp.setDarkMode(!1), !this.isEditable) {
        this.tldrawApp.enableReadOnlyMode();
        return;
      }
      await this.enableCollaborativeEditing(e), this.enableAutoSave(), e.updateUser(this.user), e.updateUserPresence({ color: game.user.color });
    };
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      width: 960,
      height: 800,
      classes: ["sheet", "journal-entry-page", "journal-sheet", "journal-whiteboard.whiteboard"]
    });
  }
  componentDidMount(e) {
    this.tldrawConfig = new Tb({
      shapes: Dfe(),
      tools: Nfe(),
      allowUnknownShapes: !0
    }), this.userId = Ip.createCustomId(game.user.id), this.user = Ip.create({
      id: this.userId,
      name: game.user.name
    }), this.instanceId = Pp.createCustomId(this.object.id), this.pageId = fr.createCustomId(this.object.id), this.page = fr.create({ id: this.pageId, name: e.title, index: "a0" }), this.store = this.tldrawConfig.createStore({
      initialData: {
        [this.pageId]: this.page,
        [this.userId]: this.user
      },
      userId: this.userId,
      instanceId: this.instanceId
    }), Hi.registerStore(this.instanceId, this.store);
    const n = this.object.system?.whiteboard;
    n && Hi.restoreSnapshot(this.instanceId, n);
  }
  async enableCollaborativeEditing(e) {
    !Hi.isCollaborativeMode() || !this.isEditable || this?.removeStoreListener || (await Hi.restoreFromRemote(this.instanceId), Hi.connectUser(this.instanceId), this.removeStoreListener = e.store.listen((n) => {
      Hi.put(this.instanceId, n.changes, n.source);
    }));
  }
  reactComponent() {
    return /* @__PURE__ */ E.jsx(Ife, { instanceId: this.instanceId, onSave: this.saveSnapshot.bind(this), children: /* @__PURE__ */ E.jsx(
      Bfe,
      {
        store: this.store,
        config: this.tldrawConfig,
        onMount: this.handleMount,
        userId: this.userId,
        instanceId: this.instanceId
      }
    ) });
  }
  async enableAutoSave() {
    if (!this.rendered || !this.isEditable || this?.autoSaveInterval)
      return;
    const e = game.settings.get("core", "editorAutosaveSecs");
    this.autoSaveInterval = setInterval(async () => {
      await this.saveSnapshot();
    }, e * 1e3);
  }
  async saveSnapshot() {
    const e = Hi.getSnapshot(this.instanceId);
    await this.object.update(
      { ["system.whiteboard"]: e },
      { diff: !1, recursive: !0 }
    );
  }
  async close() {
    return this.isEditable && await this.saveSnapshot(), this?.removeStoreListener && this?.removeStoreListener(), await super.close();
  }
}
const Yfe = {
  hooks: {
    async init() {
      Object.assign(CONFIG.JournalEntryPage.dataModels, {
        [`${Tp}.whiteboard`]: j7
      }), DocumentSheetConfig.registerSheet(
        JournalEntryPage,
        Tp,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        Vfe,
        {
          types: [`${Tp}.whiteboard`],
          label: game.i18n.localize("TYPES.JournalEntryPage.journal-whiteboard.whiteboard"),
          makeDefault: !0
        }
      );
    }
  }
}, Kfe = pi({
  type: "actor",
  getShapeUtil: () => L5
});
class L5 extends ma {
  constructor() {
    super(...arguments), this.isAspectRatioLocked = (e) => !1, this.canResize = (e) => !0, this.canBind = (e) => !0, this.getContextMenuItems = (e) => ({
      id: "actor-context-menu",
      type: "group",
      checkbox: !1,
      disabled: !1,
      readonlyOk: !0,
      children: [
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "render-sheet",
            label: game.i18n.localize("Sheet"),
            readonlyOk: !0,
            onSelect: async (...n) => {
              (await fromUuid(e.props.id)).sheet.render(!0);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        }
      ]
    });
  }
  // Default props — used for shapes created with the tool
  defaultProps() {
    return {
      opacity: "1",
      w: 100,
      h: 100,
      id: ""
    };
  }
  // Render method — the React component that will be rendered for the shape
  render(e) {
    const [n, r] = k.useState({
      img: foundry.CONST.DEFAULT_TOKEN,
      name: "Actor"
    });
    return k.useEffect(() => {
      async function a() {
        const s = await fromUuid(e.props.id);
        r(s);
      }
      a();
    }, [e.props.id]), /* @__PURE__ */ E.jsx(
      fa,
      {
        id: e.id,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          pointerEvents: "all"
        },
        children: /* @__PURE__ */ E.jsx(Wfe, { src: n.img, "data-edit": "img", alt: n.name })
      }
    );
  }
  // Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: e.props.w, height: e.props.h });
  }
}
L5.type = "actor";
const Wfe = $r.img`
    width: 100px;
    height: 100px;
    border: none;
`;
class Xx extends Ac {
  constructor() {
    super(...arguments), this.shapeType = "actor";
  }
}
Xx.id = "actor";
Xx.initial = "idle";
const Gfe = "/icons/svg/item-bag.svg", Ab = "item", Xfe = pi({
  type: Ab,
  getShapeUtil: () => j5
});
class j5 extends ma {
  constructor() {
    super(...arguments), this.isAspectRatioLocked = (e) => !1, this.canResize = (e) => !0, this.canBind = (e) => !0, this.getContextMenuItems = (e) => ({
      id: "item-context-menu",
      type: "group",
      checkbox: !1,
      disabled: !1,
      readonlyOk: !0,
      children: [
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "render-sheet",
            label: game.i18n.localize("Sheet"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id)).sheet.render(!0);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        }
      ]
    });
  }
  // Default props — used for shapes created with the tool
  defaultProps() {
    return {
      opacity: "1",
      w: 200,
      h: 48,
      id: ""
    };
  }
  // Render method — the React component that will be rendered for the shape
  render(e) {
    const [n, r] = k.useState({
      name: Ab,
      img: Gfe
    });
    return k.useEffect(() => {
      async function a() {
        const s = await fromUuid(e.props.id);
        r(s);
      }
      a();
    }, [e.props.id]), /* @__PURE__ */ E.jsxs(
      fa,
      {
        id: e.id,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "start",
          pointerEvents: "all"
        },
        children: [
          /* @__PURE__ */ E.jsx(Qfe, { src: n.img }),
          /* @__PURE__ */ E.jsx(qfe, { children: n.name })
        ]
      }
    );
  }
  // Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: e.props.w, height: e.props.h });
  }
}
j5.type = Ab;
const qfe = $r.div`
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
`, Qfe = $r.img`
    width: 36px;
    height: 36px;
    margin-left: 8px;
    margin-right: 8px;
    border: none;
`;
let z5 = class extends Ac {
  constructor() {
    super(...arguments), this.shapeType = Ab;
  }
};
z5.id = Ab;
z5.initial = "idle";
const B1 = "journal_entry", Zfe = pi({
  type: B1,
  getShapeUtil: () => U5
});
class U5 extends ma {
  constructor() {
    super(...arguments), this.isAspectRatioLocked = (e) => !1, this.canResize = (e) => !0, this.canBind = (e) => !0, this.getContextMenuItems = (e) => ({
      id: "journal-entry-context-menu",
      type: "group",
      checkbox: !1,
      disabled: !1,
      readonlyOk: !0,
      children: [
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "render-sheet",
            label: game.i18n.localize("DOCUMENT.JournalEntry"),
            readonlyOk: !0,
            onSelect: async (...n) => {
              (await fromUuid(e.props.id)).sheet.render(!0);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        }
      ]
    });
  }
  // Default props — used for shapes created with the tool
  defaultProps() {
    return {
      opacity: "1",
      w: 200,
      h: 48,
      id: ""
    };
  }
  // Render method — the React component that will be rendered for the shape
  render(e) {
    const [n, r] = k.useState({
      name: "Journal Entry"
    });
    return k.useEffect(() => {
      async function a() {
        const s = await fromUuid(e.props.id);
        r(s);
      }
      a();
    }, [e.props.id]), /* @__PURE__ */ E.jsxs(
      fa,
      {
        id: e.id,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "start",
          pointerEvents: "all"
        },
        children: [
          /* @__PURE__ */ E.jsx(epe, { children: /* @__PURE__ */ E.jsx("i", { className: "fas fa-book-open" }) }),
          /* @__PURE__ */ E.jsx(Jfe, { children: n.name })
        ]
      }
    );
  }
  // Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: e.props.w, height: e.props.h });
  }
}
U5.type = B1;
const Jfe = $r.div`
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
`, epe = $r.div`
    font-size: 24px;
    padding: 8px;
    padding-left: 16px;
`;
class A2 extends Ac {
  constructor() {
    super(...arguments), this.shapeType = B1;
  }
}
A2.id = B1;
A2.initial = "idle";
const F1 = "journal_entry_page", tpe = pi({
  type: F1,
  getShapeUtil: () => B5
}), npe = 100;
class B5 extends ma {
  constructor() {
    super(...arguments), this.isAspectRatioLocked = (e) => !1, this.canResize = (e) => !0, this.canBind = (e) => !0, this.getContextMenuItems = (e) => ({
      id: "journal-entry-page-context-menu",
      type: "group",
      checkbox: !1,
      disabled: !1,
      readonlyOk: !0,
      children: [
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "render-sheet",
            label: game.i18n.localize("DOCUMENT.JournalEntryPage"),
            readonlyOk: !0,
            onSelect: async (...n) => {
              (await fromUuid(e.props.id)).sheet.render(!0);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        }
      ]
    });
  }
  // Default props — used for shapes created with the tool
  defaultProps() {
    return {
      opacity: "1",
      w: 200,
      h: 48,
      id: ""
    };
  }
  // Render method — the React component that will be rendered for the shape
  render(e) {
    const n = It.useRef(null), [r, a] = k.useState({
      name: "Journal Entry"
    }), [s, c] = k.useState("");
    k.useEffect(() => {
      async function p() {
        const g = await fromUuid(e.props.id);
        a(g);
        const y = await TextEditor.enrichHTML(g.text.content, {
          secrets: g.isOwner,
          relativeTo: g,
          async: !0
        });
        c(y);
      }
      p();
    }, [e.props.id]);
    const f = this.bounds(e);
    return /* @__PURE__ */ E.jsx(
      fa,
      {
        id: e.id,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "start",
          pointerEvents: "all"
        },
        children: f.h > npe ? /* @__PURE__ */ E.jsxs(rpe, { children: [
          /* @__PURE__ */ E.jsx(ipe, { children: r.name }),
          /* @__PURE__ */ E.jsx(ope, { ref: n, dangerouslySetInnerHTML: { __html: s } })
        ] }) : /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
          /* @__PURE__ */ E.jsx(spe, { children: /* @__PURE__ */ E.jsx("i", { className: "fas fa-book-open" }) }),
          /* @__PURE__ */ E.jsx(ape, { children: r.name })
        ] })
      }
    );
  }
  // Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: e.props.w, height: e.props.h });
  }
}
B5.type = F1;
const rpe = $r.div`
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
    color: var(--color-text-dark-primary);
    background: url(../ui/parchment.jpg) repeat;
    border: 2px solid #000;
    width: 100%;
    height: 100%;
    overflow-y: auto;
    overflow-x: hidden;
    padding: 8px;
`, ipe = $r.h1`
    user-select: text;
    pointer-events: all;
    touch-action: auto;
    overscroll-behavior: none;
`, ope = $r.section`
    user-select: text;
    pointer-events: all;
    touch-action: auto;
    overscroll-behavior: none;
`, ape = $r.div`
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
`, spe = $r.div`
    font-size: 24px;
    padding: 8px;
    padding-left: 16px;
`;
class O2 extends Ac {
  constructor() {
    super(...arguments), this.shapeType = F1;
  }
}
O2.id = F1;
O2.initial = "idle";
const lpe = "/icons/svg/dice-target.svg", cpe = pi({
  type: "macro",
  getShapeUtil: () => F5
});
class F5 extends ma {
  constructor() {
    super(...arguments), this.isAspectRatioLocked = (e) => !1, this.canResize = (e) => !0, this.canBind = (e) => !0, this.getContextMenuItems = (e) => ({
      id: "macro-context-menu",
      type: "group",
      checkbox: !1,
      disabled: !1,
      readonlyOk: !0,
      children: [
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "execute-macro",
            label: game.i18n.localize("Executar Macro"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id))?.execute();
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        },
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "render-sheet",
            label: game.i18n.localize("MACRO.Edit"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id)).sheet.render(!0);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        }
      ]
    });
  }
  // Default props — used for shapes created with the tool
  defaultProps() {
    return {
      opacity: "1",
      w: 200,
      h: 48,
      id: ""
    };
  }
  // Render method — the React component that will be rendered for the shape
  render(e) {
    const [n, r] = k.useState({
      name: "Macro",
      img: lpe
    });
    return k.useEffect(() => {
      async function a() {
        const s = await fromUuid(e.props.id);
        r(s);
      }
      a();
    }, [e.props.id]), /* @__PURE__ */ E.jsxs(
      fa,
      {
        id: e.id,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "start",
          pointerEvents: "all"
        },
        children: [
          /* @__PURE__ */ E.jsx(dpe, { src: n.img }),
          /* @__PURE__ */ E.jsx(upe, { children: n.name })
        ]
      }
    );
  }
  // Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: e.props.w, height: e.props.h });
  }
}
F5.type = "macro";
const upe = $r.div`
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
`, dpe = $r.img`
    width: 36px;
    height: 36px;
    margin-left: 8px;
    margin-right: 8px;
    border: none;
`;
class D2 extends Ac {
  constructor() {
    super(...arguments), this.shapeType = "macro";
  }
}
D2.id = "macro";
D2.initial = "idle";
const H1 = "playlist", fpe = pi({
  type: H1,
  getShapeUtil: () => H5
});
class H5 extends ma {
  constructor() {
    super(...arguments), this.isAspectRatioLocked = (e) => !1, this.canResize = (e) => !0, this.canBind = (e) => !0, this.getContextMenuItems = (e) => {
      const n = fromUuidSync(e.props.id), r = [
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "render-sheet",
            label: game.i18n.localize("Configure"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id)).sheet.render(!0);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        }
      ];
      return n.playing ? r.unshift(
        {
          id: "playlist-stop",
          type: "item",
          actionItem: {
            id: "playlist-stop",
            label: game.i18n.localize("PLAYLIST.SoundStop"),
            readonlyOk: !0,
            onSelect: async () => {
              n.stopAll();
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !1
        }
      ) : r.unshift(
        {
          id: "playlist-play",
          type: "item",
          actionItem: {
            id: "playlist-play",
            label: game.i18n.localize("PLAYLIST.SoundPlay"),
            readonlyOk: !0,
            onSelect: async () => {
              n.playAll();
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !1
        }
      ), {
        id: "playlist-context-menu",
        type: "group",
        checkbox: !1,
        disabled: !1,
        readonlyOk: !0,
        children: r
      };
    };
  }
  // Default props — used for shapes created with the tool
  defaultProps() {
    return {
      opacity: "1",
      w: 200,
      h: 48,
      id: ""
    };
  }
  // Render method — the React component that will be rendered for the shape
  render(e) {
    const [n, r] = k.useState({
      name: "Playlit Sound",
      playing: !1,
      sound: null
    });
    return k.useEffect(() => {
      async function a() {
        const s = await fromUuid(e.props.id);
        r(s);
        for (const c of s.sounds)
          c.sound.on("start", async () => {
            const f = await fromUuid(e.props.id);
            r((p) => ({ ...p, playing: f.playing }));
          }), c.sound.on("stop", async () => {
            const f = await fromUuid(e.props.id);
            r((p) => ({ ...p, playing: f.playing }));
          });
      }
      a();
    }, [e.props.id]), /* @__PURE__ */ E.jsxs(
      fa,
      {
        id: e.id,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "start",
          pointerEvents: "all"
        },
        children: [
          /* @__PURE__ */ E.jsx(hpe, { playing: n.playing, children: n.playing ? /* @__PURE__ */ E.jsx("i", { className: "fas fa-square" }) : /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-play" }) }),
          /* @__PURE__ */ E.jsx(ppe, { children: n.name })
        ]
      }
    );
  }
  // Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: e.props.w, height: e.props.h });
  }
}
H5.type = H1;
const ppe = $r.div`
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
`, hpe = $r.div`
    font-size: 24px;
    padding: 8px;
    padding-left: 16px;
    color: ${(t) => t.playing ? "var(--color-text-hyperlink)" : "var(--color-text)"};
`;
class N2 extends Ac {
  constructor() {
    super(...arguments), this.shapeType = H1;
  }
}
N2.id = H1;
N2.initial = "idle";
const gpe = pi({
  type: "playlist_sound",
  getShapeUtil: () => V5
});
class V5 extends ma {
  constructor() {
    super(...arguments), this.isAspectRatioLocked = (e) => !1, this.canResize = (e) => !0, this.canBind = (e) => !0, this.getContextMenuItems = (e) => {
      const n = fromUuidSync(e.props.id), r = [
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "render-sheet",
            label: game.i18n.localize("Configure"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id)).sheet.render(!0);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        }
      ];
      return n.sound.playing ? r.unshift(
        {
          id: "playlist-sound-stop",
          type: "item",
          actionItem: {
            id: "playlist-sound-stop",
            label: game.i18n.localize("PLAYLIST.SoundStop"),
            readonlyOk: !0,
            onSelect: async () => {
              n.parent.stopSound(n);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !1
        },
        {
          id: "playlist-sound-pause",
          type: "item",
          actionItem: {
            id: "playlist-sound-pause",
            label: game.i18n.localize("PLAYLIST.SoundPause"),
            readonlyOk: !0,
            onSelect: async () => {
              n.update({ playing: !1, pausedTime: n.sound.currentTime });
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !1
        }
      ) : r.unshift(
        {
          id: "playlist-sound-play",
          type: "item",
          actionItem: {
            id: "playlist-sound-play",
            label: game.i18n.localize("PLAYLIST.SoundPlay"),
            readonlyOk: !0,
            onSelect: async () => {
              n.parent.playSound(n);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !1
        }
      ), {
        id: "playlist-sound-context-menu",
        type: "group",
        checkbox: !1,
        disabled: !1,
        readonlyOk: !0,
        children: r
      };
    };
  }
  // Default props — used for shapes created with the tool
  defaultProps() {
    return {
      opacity: "1",
      w: 200,
      h: 48,
      id: ""
    };
  }
  // Render method — the React component that will be rendered for the shape
  render(e) {
    const [n, r] = k.useState({
      name: "Playlit Sound",
      playing: !1,
      sound: null
    });
    return k.useEffect(() => {
      async function a() {
        const s = await fromUuid(e.props.id);
        r(s), s.sound.on("start", async () => {
          r((c) => ({ ...c, playing: !0 }));
        }), s.sound.on("stop", async () => {
          r((c) => ({ ...c, playing: !1 }));
        });
      }
      a();
    }, [e.props.id]), /* @__PURE__ */ E.jsxs(
      fa,
      {
        id: e.id,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "start",
          pointerEvents: "all"
        },
        children: [
          /* @__PURE__ */ E.jsx(vpe, { playing: n.playing, children: n.playing ? /* @__PURE__ */ E.jsx("i", { className: "fas fa-square" }) : /* @__PURE__ */ E.jsx("i", { className: "fa-solid fa-play" }) }),
          /* @__PURE__ */ E.jsx(mpe, { children: n.name })
        ]
      }
    );
  }
  // Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: e.props.w, height: e.props.h });
  }
}
V5.type = "playlist_sound";
const mpe = $r.div`
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
`, vpe = $r.div`
    font-size: 24px;
    padding: 8px;
    padding-left: 16px;
    color: ${(t) => t.playing ? "var(--color-text-hyperlink)" : "var(--color-text)"};
`;
class L2 extends Ac {
  constructor() {
    super(...arguments), this.shapeType = "playlist_sound";
  }
}
L2.id = "playlist_sound";
L2.initial = "idle";
const ype = "/icons/svg/dice-target.svg", Ob = "rolltable", bpe = pi({
  type: Ob,
  getShapeUtil: () => Y5
});
class Y5 extends ma {
  constructor() {
    super(...arguments), this.isAspectRatioLocked = (e) => !1, this.canResize = (e) => !0, this.canBind = (e) => !0, this.getContextMenuItems = (e) => ({
      id: "rolltable-context-menu",
      type: "group",
      checkbox: !1,
      disabled: !1,
      readonlyOk: !0,
      children: [
        {
          id: "draw",
          type: "item",
          actionItem: {
            id: "draw",
            label: game.i18n.localize("Roll"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id))?.draw();
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        },
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "render-sheet",
            label: game.i18n.localize("Configure"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id)).sheet.render(!0);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        }
      ]
    });
  }
  // Default props — used for shapes created with the tool
  defaultProps() {
    return {
      opacity: "1",
      w: 200,
      h: 48,
      id: ""
    };
  }
  // Render method — the React component that will be rendered for the shape
  render(e) {
    const [n, r] = k.useState({
      name: Ob,
      img: ype
    });
    return k.useEffect(() => {
      async function a() {
        const s = await fromUuid(e.props.id);
        r(s);
      }
      a();
    }, [e.props.id]), /* @__PURE__ */ E.jsxs(
      fa,
      {
        id: e.id,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "start",
          pointerEvents: "all"
        },
        children: [
          /* @__PURE__ */ E.jsx(wpe, { src: n.img }),
          /* @__PURE__ */ E.jsx(Spe, { children: n.name })
        ]
      }
    );
  }
  // Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: e.props.w, height: e.props.h });
  }
}
Y5.type = Ob;
const Spe = $r.div`
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
`, wpe = $r.img`
    width: 36px;
    height: 36px;
    margin-left: 8px;
    margin-right: 8px;
    border: none;
`;
class j2 extends Ac {
  constructor() {
    super(...arguments), this.shapeType = Ob;
  }
}
j2.id = Ob;
j2.initial = "idle";
const Db = "scene", xpe = pi({
  type: Db,
  getShapeUtil: () => K5
});
class K5 extends ma {
  constructor() {
    super(...arguments), this.isAspectRatioLocked = (e) => !1, this.canResize = (e) => !0, this.canBind = (e) => !0, this.getContextMenuItems = (e) => ({
      id: "rolltable-context-menu",
      type: "group",
      checkbox: !1,
      disabled: !1,
      readonlyOk: !0,
      children: [
        {
          id: "scene-activate",
          type: "item",
          actionItem: {
            id: "scene-activate",
            label: game.i18n.localize("Activate"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id)).activate();
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        },
        {
          id: "scene-view",
          type: "item",
          actionItem: {
            id: "scene-view",
            label: game.i18n.localize("SCENES.View"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id)).view();
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        },
        {
          id: "render-sheet",
          type: "item",
          actionItem: {
            id: "render-sheet",
            label: game.i18n.localize("Configure"),
            readonlyOk: !0,
            onSelect: async () => {
              (await fromUuid(e.props.id)).sheet.render(!0);
            }
          },
          checked: !0,
          readonlyOk: !0,
          disabled: !e?.props?.id
        }
      ]
    });
  }
  // Default props — used for shapes created with the tool
  defaultProps() {
    return {
      opacity: "1",
      w: 200,
      h: 48,
      id: ""
    };
  }
  // Render method — the React component that will be rendered for the shape
  render(e) {
    const [n, r] = k.useState({
      name: Db,
      thumb: ""
    });
    k.useEffect(() => {
      async function s() {
        const c = await fromUuid(e.props.id);
        r(c);
      }
      s();
    }, [e.props.id]);
    const a = this.bounds(e);
    return /* @__PURE__ */ E.jsx(
      fa,
      {
        id: e.id,
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "start",
          pointerEvents: "all"
        },
        children: a.h > 100 ? /* @__PURE__ */ E.jsx(Epe, { backgroundImage: n.thumb, children: /* @__PURE__ */ E.jsx(e3, { children: n.name }) }) : /* @__PURE__ */ E.jsxs(E.Fragment, { children: [
          /* @__PURE__ */ E.jsx(Cpe, { children: /* @__PURE__ */ E.jsx("i", { className: "fas fa-map" }) }),
          /* @__PURE__ */ E.jsx(e3, { children: n.name })
        ] })
      }
    );
  }
  // Indicator — used when hovering over a shape or when it's selected; must return only SVG elements here
  indicator(e) {
    return /* @__PURE__ */ E.jsx("rect", { width: e.props.w, height: e.props.h });
  }
}
K5.type = Db;
const e3 = $r.div`
    text-overflow: ellipsis;
    overflow: hidden;
    white-space: nowrap;
`, Epe = $r.div`
    border: none;
    background-image: url(${(t) => t.backgroundImage});
    display: flex;
    justify-content: center;
    align-items: center;    font-size: 1.5em;
    font-weight: normal;
    text-shadow: 1px 1px 3px var(--color-shadow-dark);
    background-position: 50% 50%;
    background-size: cover;
    background-repeat: no-repeat;
    width: 100%;
    height: 100%;
    color: var(--color-text-light-highlight);
`, Cpe = $r.div`
    font-size: 24px;
    padding: 8px;
    padding-left: 16px;
`;
class z2 extends Ac {
  constructor() {
    super(...arguments), this.shapeType = Db;
  }
}
z2.id = Db;
z2.initial = "idle";
const _pe = {
  hooks: {
    init() {
      Tu({
        shape: Kfe,
        tool: Xx,
        dataTransferType: "Actor"
      }), Tu({
        shape: cpe,
        tool: D2,
        dataTransferType: "Macro"
      }), Tu({
        shape: fpe,
        tool: N2,
        dataTransferType: "Playlist"
      }), Tu({
        shape: gpe,
        tool: L2,
        dataTransferType: "PlaylistSound"
      }), Tu({
        shape: bpe,
        tool: j2,
        dataTransferType: "RollTable"
      }), Tu({
        shape: xpe,
        tool: z2,
        dataTransferType: "Scene"
      }), Tu({
        shape: Xfe,
        tool: Xx,
        dataTransferType: "Item"
      }), Tu({
        shape: Zfe,
        tool: A2,
        dataTransferType: "JournalEntry"
      }), Tu({
        shape: tpe,
        tool: O2,
        dataTransferType: "JournalEntryPage"
      });
    }
  }
}, U2 = [kfe, L7, _pe, Yfe];
Hooks.on("init", async () => {
  for (const t of U2)
    t?.hooks?.init && await t.hooks.init();
});
Hooks.on("ready", async () => {
  for (const t of U2)
    t?.hooks?.ready && await t.hooks.ready();
});
Hooks.once("socketlib.ready", async () => {
  for (const t of U2)
    t?.hooks?.socketlib && await t.hooks.socketlib();
});
//# sourceMappingURL=journal-whiteboard.js.map
