{"version":3,"file":"index.js","sources":["../../src/utils/game.ts","../../src/utils/log.ts","../../src/types/index.ts","../../src/settings/ModuleSettings.ts","../../src/autocomplete/autocompleter.ts","../../src/hooks/i18Init.ts","../../src/hooks/init.ts","../../src/handlebars/add.ts","../../src/handlebars/index.ts","../../src/hooks/ready.ts","../../src/hooks/index.ts","../../src/main.ts"],"sourcesContent":["// some helpers to simplify various repetitive tasks\n\n// return the game object\nconst getGame = function(): Game {\n  if(!(game instanceof Game)) {\n    throw new Error('Game is not initialized yet!');\n  }\n  return game;\n}\n\n// is the current client the GM?\nconst isClientGM = (): boolean => (getGame()?.user?.isGM || false);\n\n// localize a string\nconst localize = (stringId: string) => getGame().i18n.localize(stringId);\n\nexport { \n  getGame,\n  isClientGM,\n  localize,\n};","import { getGame } from '@/utils/game';\n\nconst messagePrefix = 'autocomplete-mentions | ';\n\n// log the given text, so long as our current log level is at least the one given\nexport function log(force: boolean, ...args): void {\n  try {\n    const isDebugging = getGame().modules.get('_dev-mode')?.api?.getPackageDebugValue('autocomplete-mentions') || false;\n\n    if (force || isDebugging) {\n      console.log(messagePrefix, ...args);\n    }\n  } catch (e) {\n    // eslint-ignore-next-line\n    console.log('ERROR IN LOG FUNCTION:' + e);\n  }\n}\n\n\n","import EmbeddedCollection from '@league-of-foundry-developers/foundry-vtt-types/src/foundry/common/abstract/embedded-collection.mjs';\n\nexport enum AutocompleteMode {\n  singleAtWaiting,  // entered a single @ and waiting for next char to determine what type of search (this is the default when we open it)\n  docSearch, // entered a single @ plus a valid document search type\n  journalPageSearch,  // entered a single @, picked journal type, selected a journal, and are now picking pages\n}\n\n// we can't use foundry's setPosition() because it doesn't work for fixed size, non popout windows\nexport type WindowPosition = {\n  left: number;\n  top: number;\n}\n\nexport type SearchResult = {\n  uuid: string;\n  name: string;\n  pages: EmbeddedCollection<any, any> | null;\n}\n\nexport enum ValidDocType {\n  Actor,\n  Item,\n  Journal,\n  RollTable,\n  Scene,\n}\n\nexport type DocumentType = Actor | Scene | Journal | RollTable | Item;\n\nexport enum EditorType {\n  ProseMirror,\n  TinyMCE\n}","import { getGame, localize } from '@/utils/game';\nimport moduleJson from '@module';\n\nexport enum SettingKeys {\n  // displayed in settings\n  resultLength = 'resultLength',\n\n  // internal only\n}\n\ntype SettingType<K extends SettingKeys> =\n    K extends SettingKeys.resultLength ? number :\n    never;  \n\n// the solo instance\nexport let moduleSettings: ModuleSettings;\n\n// set the main application; should only be called once\nexport function updateModuleSettings(settings: ModuleSettings): void {\n  moduleSettings = settings;\n}\n\nexport class ModuleSettings {\n  constructor() {\n    this.registerSettings();\n  }\n\n  public isSettingValueEmpty(setting: any): boolean {\n    return Object.keys(setting).length === 0 || setting === null || setting === undefined;\n  }\n\n  public get<T extends SettingKeys>(setting: T): SettingType<T> {\n    return getGame().settings.get(moduleJson.id, setting) as SettingType<T>;\n  }\n\n  public async set<T extends SettingKeys>(setting: T, value: SettingType<T>): Promise<void> {\n    await getGame().settings.set(moduleJson.id, setting, value);\n  }\n\n  private register(settingKey: string, settingConfig: ClientSettings.PartialSettingConfig) {\n    getGame().settings.register(moduleJson.id, settingKey, settingConfig);\n  }\n\n  private registerMenu(settingKey: string, settingConfig: ClientSettings.PartialSettingSubmenuConfig) {\n    getGame().settings.registerMenu(moduleJson.id, settingKey, settingConfig);\n  }\n\n  // these are local menus (shown at top)\n  private localMenuParams: (ClientSettings.PartialSettingSubmenuConfig & { settingID: string })[] = [\n  ];\n\n  // these are globals shown in the options\n  // name and hint should be the id of a localization string\n  private displayParams: (ClientSettings.PartialSettingConfig & { settingID: string })[] = [\n    {\n      settingID: SettingKeys.resultLength,\n      name: 'acm.settings.resultLength',\n      hint: 'acm.settings.resultLengthHelp',\n      default: 5,\n      type: Number,\n    },\n  ];\n\n  // these are client-specific and displayed in settings\n  private localDisplayParams: (ClientSettings.PartialSettingConfig & { settingID: string })[] = [\n  ];\n\n  // these are globals only used internally\n  private internalParams: (ClientSettings.PartialSettingConfig & { settingID: string })[] = [\n  ];\n  \n  // these are client-specfic only used internally\n  private localInternalParams: (ClientSettings.PartialSettingConfig & { settingID: string })[] = [\n  ];\n\n  private registerSettings(): void {\n    for (let i=0; i<this.localMenuParams.length; i++) {\n      const { settingID, ...settings} = this.localMenuParams[i];\n      this.registerMenu(settingID, {\n        ...settings,\n        name: settings.name ? localize(settings.name) : '',\n        hint: settings.hint ? localize(settings.hint) : '',\n        restricted: true,\n      });\n    }\n\n    for (let i=0; i<this.displayParams.length; i++) {\n      const { settingID, ...settings} = this.displayParams[i];\n      this.register(settingID, {\n        ...settings,\n        name: settings.name ? localize(settings.name) : '',\n        hint: settings.hint ? localize(settings.hint) : '',\n        scope: 'world',\n        config: true,\n      });\n    }\n\n    for (let i=0; i<this.localDisplayParams.length; i++) {\n      const { settingID, ...settings} = this.localDisplayParams[i];\n      this.register(settingID, {\n        ...settings,\n        name: settings.name ? localize(settings.name) : '',\n        hint: settings.hint ? localize(settings.hint) : '',\n        scope: 'client',\n        config: true,\n      });\n    }\n\n    for (let i=0; i<this.internalParams.length; i++) {\n      const { settingID, ...settings} = this.internalParams[i];\n      this.register(settingID, {\n        ...settings,\n        scope: 'world',\n        config: false,\n      });\n    }\n\n    for (let i=0; i<this.localInternalParams.length; i++) {\n      const { settingID, ...settings} = this.localInternalParams[i];\n      this.register(settingID, {\n        ...settings,\n        scope: 'client',\n        config: false,\n      });\n    }\n  }\n}\n","import moduleJson from '@module';\nimport { log } from '@/utils/log';\nimport { getGame, localize } from '@/utils/game';\nimport { DocumentType, ValidDocType, WindowPosition, SearchResult, AutocompleteMode, EditorType } from '@/types';\nimport { moduleSettings, SettingKeys } from '@/settings/ModuleSettings';\n\n  /* so here's the flow...\n      press @\n      Get a menu of Actors, JournalEntries (which will then offer link to parent or pick a page), Items, Scenes, Roll Table\n      Press the 1st letter of what you want\n      Have an option to create a new one (???) + options for 1st n choices\n      As you type more letters, choices filter down\n\n      note: if you pick journalentries, once you pick the entry, you get a followup item with a choice to pick the entry + a list of pages (which\n          then filter like the document choices)\n  */\n\n\n// keypress and title show in the menu to pick a type\n// type is the internal doctype\n// searchName shows in the search screen (\"Searching ___ for: \")\n// collectionName is the foundry collection\n// referenceText is the text inserted into the editor @___[name]\nlet docTypes = [] as { type: ValidDocType, keypress: string, title: string, searchName: string, collectionName: string, referenceText: string, }[];\n\n// load i18n strings after the game has loaded\nexport function initializeLocalizedText(): void {\n  log(false, 'Loading localized document text');\n\n  docTypes = [\n    { type: ValidDocType.Actor, keypress: localize('acm.documents.keys.actors'), title: localize('acm.documents.titles.actors'), searchName: 'Actors', collectionName: 'actors', referenceText: 'Actor', },\n    { type: ValidDocType.Item, keypress: localize('acm.documents.keys.items'), title: localize('acm.documents.titles.items'), searchName: 'Items', collectionName: 'items', referenceText: 'Item', },\n    { type: ValidDocType.Journal, keypress: localize('acm.documents.keys.journals'), title: localize('acm.documents.titles.journals'), searchName: 'Journals', collectionName: 'journal', referenceText: 'JournalEntry', },\n    { type: ValidDocType.RollTable, keypress: localize('acm.documents.keys.rollTables'), title: localize('acm.documents.titles.rollTables'), searchName: 'Roll Tables', collectionName: 'tables', referenceText: 'RollTable', },\n    { type: ValidDocType.Scene, keypress: localize('acm.documents.keys.scenes'), title: localize('acm.documents.titles.scenes'), searchName: 'Scenes', collectionName: 'scenes', referenceText: 'Scene', },\n  ];\n}\n\nexport class Autocompleter extends Application {\n  private _onClose: ()=>void;      // function to call when we close\n  private _onPointerDown: (event: MouseEvent)=>void;      // this is the listener on document; need to remove it when we close\n  private _location: WindowPosition;   // location of the popup\n  private _editor: HTMLElement;    // the editor element\n  private _editorType: EditorType;   // the type of editor we're supporting\n\n  // status\n  private _currentMode: AutocompleteMode;\n  private _focusedMenuKey = 0 as number;\n  private _searchDocType = null as ValidDocType | null;   // if we're in doc search mode, the key of the docType to search\n  private _selectedJournal: SearchResult;   // name of the selected journal when we're looking for pages\n  private _shownFilter = '' as string;    // current filter for doc search\n\n  // search results\n  private _lastPulledSearchResults = [] as SearchResult[];  // all of the results we got back last time\n  private _lastPulledFilter = '' as string;      // the filter we last searched the database for\n  private _lastPulledType = null as ValidDocType | null;     // the key of the doctype we last searched the database for\n  private _lastPulledRowCount = 0 as number;   // the number of rows the last query returned\n  private _filteredSearchResults = [] as SearchResult[];   // the currently shown search results\n\n  constructor(target: HTMLElement, editorType: EditorType, onClose: ()=>void) {\n    super();\n\n    log(false, 'Autocompleter construction');\n\n    this._editor = target;\n    this._editorType = editorType;\n    this._currentMode = AutocompleteMode.singleAtWaiting;\n    this._onClose = onClose;\n\n    this._location = this._getSelectionCoords(10, 0) || { left: 0, top: 0 };\n\n    this.render();\n  }\n\n  static get defaultOptions(): ApplicationOptions {\n    const options = super.defaultOptions;\n\n    options.classes = ['acm-autocomplete'];\n    options.template = `modules/${moduleJson.id}/templates/autocompleter.hbs`,\n    options.popOut = false;\n    options.resizable = false;\n    options.height = 'auto';\n\n    return options;\n  }\n\n  // moves this to a new target (in the case of a re-render, for instance)\n  retarget(newTarget) {\n    this._editor = newTarget;\n    this.render();\n  }\n\n  // this provides fields that will be available in the template; called by parent class\n  public async getData(): Promise<any> {\n    const data = {\n        ...(await super.getData()),\n        location: this._location,\n        docTypes: docTypes,\n        singleAtWaiting: this._currentMode===AutocompleteMode.singleAtWaiting,\n        docSearch: this._currentMode===AutocompleteMode.docSearch,\n        journalPageSearch: this._currentMode===AutocompleteMode.journalPageSearch,\n        journalName: this._selectedJournal?.name,\n        docType: docTypes.find((dt)=>(dt.type===this._searchDocType))?.searchName,\n        highlightedEntry: this._focusedMenuKey,\n        searchResults: this._filteredSearchResults,\n        shownFilter: this._shownFilter,\n        hasMore: (this._lastPulledRowCount || 0) > (this._filteredSearchResults?.length || 0),\n    };\n    //log(false, data);\n\n    return data;\n  }\n\n  activateListeners($html: JQuery) {\n    super.activateListeners($html);\n\n    const html = $html[0];\n\n    // set the focus to the control\n    const wrapper = html.querySelector('#acm-wrapper') as HTMLDivElement;\n    wrapper.focus();\n\n    // take keystrokes\n    wrapper.addEventListener('keydown', this._onKeydown);\n\n    // watch for mouseover and clicks on menu items\n    const menuItems = html.querySelectorAll('.acm-data-entry') as NodeListOf<HTMLLIElement>;\n    for (let i=0; i<menuItems.length; i++) {\n      menuItems[i].addEventListener('click', this._onListClick);\n      menuItems[i].addEventListener('mouseover', this._onListMouseover);\n    }\n\n    // for some reason, if instead of putting focus elsewhere we drag the window, focusout never gets called\n    // so, we listen for pointerdown events, too (this doesn't seem super safe because foundry could change the event they use...)\n    // note for future versions of foundry - make sure this still works\n\n    const onPointerDown = (event: MouseEvent): void => { \n      // find the wrapper \n      const wrapper = document.querySelector('#acm-wrapper') as HTMLDivElement;\n      if (!wrapper) {\n        // should never happen... if it does, it probably means we somehow failed to remove the listener\n        document.removeEventListener('pointerdown', this._onPointerDown);\n        if (this._editorType===EditorType.TinyMCE) {\n          this._editor.ownerDocument.removeEventListener('pointerdown', this._onPointerDown);\n        }\n      } else if (!wrapper.contains(event.target as Node)) {\n        this.close(); \n      }\n    }\n\n    // activateListeners happens every time we rerender, so if we've set the event listener before, we\n    //    need to remove the old one and replace it with the new one (which ties to the new DOM elements)\n    if (this._onPointerDown) {\n      document.removeEventListener('pointerdown', this._onPointerDown);\n      if (this._editorType===EditorType.TinyMCE) {\n        this._editor.ownerDocument.removeEventListener('pointerdown', this._onPointerDown);\n      }\n    }\n\n    this._onPointerDown = onPointerDown;\n    document.addEventListener('pointerdown', onPointerDown);  \n\n    if (this._editorType===EditorType.TinyMCE) {\n      this._editor.ownerDocument.addEventListener('pointerdown', onPointerDown);\n    }\n}\n\n  public async render(force?: boolean) {\n    const result = await super.render(force);\n    \n    return result;\n  }\n\n  async close(options = {}): Promise<void> {\n    // turn off visibility immediately so we don't have to wait for the animation\n    // NOTE: the application is rendered into the parent application, even if we're in an iframe for TinyMCE\n    const wrapper = document.querySelector(`.acm-autocomplete`) as HTMLElement;\n    if (wrapper)\n      wrapper.style.display = 'none';\n\n    // remove the listener\n    document.removeEventListener('pointerdown', this._onPointerDown);\n    if (this._editorType===EditorType.TinyMCE) {\n      this._editor.ownerDocument.removeEventListener('pointerdown', this._onPointerDown);\n    }\n\n    // call the callback, if present\n    if (this._onClose)\n      this._onClose();\n\n    // force: true closes immediately without animation\n    return super.close(options);\n  }\n\n  private _onListClick = async(event: MouseEvent): Promise<void> => {\n    if (!event?.currentTarget)\n      return;\n\n    const index = (event.currentTarget as HTMLLIElement).attributes['data-acm-index'].nodeValue;\n\n    // pretend we clicked in\n    this._focusedMenuKey = Number.parseInt(index);\n    this._onKeydown({key: 'Enter', preventDefault: ()=>{}, stopPropagation: ()=>{}} as KeyboardEvent);\n  }\n\n  private _onListMouseover = async(event: MouseEvent): Promise<void> => {\n    if (!event?.currentTarget)\n      return;\n\n    const index = Number.parseInt((event.currentTarget as HTMLLIElement).attributes['data-acm-index'].nodeValue);\n\n    // pretend we clicked in\n    if (this._focusedMenuKey!==index) {\n      this._focusedMenuKey = index;\n      this.render();\n    }\n  }\n\n\n  // we render at the end, so can return for cases that don't require it to save that step\n  private _onKeydown = async (event: KeyboardEvent): Promise<void> => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    // for various other keys, it depends on the model\n    switch (this._currentMode) {\n      case AutocompleteMode.singleAtWaiting: {\n        switch (event.key) {\n          case 'Enter': {\n            // select the item\n            if (!docTypes[this._focusedMenuKey]) return;\n\n            const dt = docTypes[this._focusedMenuKey].type;\n\n            // move to the next menu\n            await this._moveToDocSearch(dt);\n\n            break;\n          }\n\n          case \"Escape\": {\n            // if we're on the first menu, then we want to insert a @ symbol\n            this._insertTextAndClose('@');\n            break;\n          }\n\n          case 'Backspace': {\n            // close the menu\n            this.close();\n            return;\n          }\n\n          case \"ArrowUp\": {\n            this._focusedMenuKey = (this._focusedMenuKey - 1 + docTypes.length) % docTypes.length;\n            \n            break;\n          }\n          case \"ArrowDown\": {\n            this._focusedMenuKey = (this._focusedMenuKey + 1) % docTypes.length;\n    \n            break;\n          }\n\n          default:\n            // see if it's one of the valid keypresses\n            const match = docTypes.find((dt)=>(dt.keypress.toLocaleLowerCase()===event.key.toLocaleLowerCase()));\n\n            if (match) {\n              // finalize search mode and select the item type\n              await this._moveToDocSearch(match.type);\n\n              break;\n            } else {\n              // ignore\n              return;\n            }\n\n            break;\n        }\n        break;\n      }\n\n      case AutocompleteMode.docSearch: \n      case AutocompleteMode.journalPageSearch: {\n        // if it's a regular character, update the filter string\n        if (event.key.length===1) {\n          this._shownFilter += event.key;\n\n          await this._refreshSearch();\n        } else {\n          // handle special keys\n          switch (event.key) {\n            case 'Enter': {\n              if (this._currentMode===AutocompleteMode.docSearch) {\n                if (this._searchDocType === null) return;\n\n                // if it's 0, pop up the add item dialog\n                if (!this._focusedMenuKey) {\n                  this._createDocument(this._searchDocType);\n                } else if (this._searchDocType===ValidDocType.Journal) {\n                  // for journal, we have to go into journal mode\n                  this._currentMode = AutocompleteMode.journalPageSearch;\n\n                  // get the clicked journal\n                  const journal = this._filteredSearchResults[this._focusedMenuKey-1];\n                  this._selectedJournal = {...journal};\n\n                  // reset search\n                  this._shownFilter = '';\n                  this._focusedMenuKey = 0;   // use whole journal\n                  await this._refreshSearch();\n                } else {\n                  // get the clicked item\n                  const item = this._filteredSearchResults[this._focusedMenuKey-1];\n\n                  // insert the appropriate text\n                  if (item) {\n                    const docType = docTypes.find((dt)=>(dt.type===this._searchDocType));\n                    this._insertReferenceAndClose(item.uuid);\n                  }\n                }\n              } else {\n                // handle journal page select\n                // if it's 0, we just add a reference to the whole journal\n                if (!this._focusedMenuKey) {\n                  this._insertReferenceAndClose(this._selectedJournal.uuid);\n                } else {\n                  // pages have to be entered as a UUID\n                  // get the clicked item\n                  const item = this._filteredSearchResults[this._focusedMenuKey-1];\n\n                  // insert the appropriate text\n                  if (item) {\n                    const docType = docTypes.find((dt)=>(dt.type===this._searchDocType));\n                    this._insertReferenceAndClose(item.uuid);\n                  }\n                }\n              }\n              break;\n            }\n\n            case 'Backspace': {\n              // if the shownfilter is empty, go back to singleAtWaiting mode\n              if (this._shownFilter.length === 0) {\n                if (this._currentMode===AutocompleteMode.docSearch) {\n                  this._currentMode = AutocompleteMode.singleAtWaiting;\n                } else {\n                  // journal search\n                  this._currentMode = AutocompleteMode.docSearch;\n                  this._shownFilter = '';\n                  await this._refreshSearch();\n                }\n                this._focusedMenuKey = 0;\n              } else {\n                // otherwise delete a character\n                this._shownFilter = this._shownFilter.slice(0, -1);\n                await this._refreshSearch();\n                this._focusedMenuKey = 0;\n              }\n\n              break;\n            }\n            \n            case \"Escape\": {\n              // just close the whole menu (without inserting @, because it's more likely we just changed our mind)\n              this.close();\n              return;\n            }\n\n            case \"ArrowUp\": {\n              this._focusedMenuKey = (this._focusedMenuKey - 1 + this._filteredSearchResults.length+1) % (this._filteredSearchResults.length+1);\n              break;\n            }\n            case \"ArrowDown\": {\n              this._focusedMenuKey = (this._focusedMenuKey + 1) % (this._filteredSearchResults.length+1);\n              break;\n            }\n\n            default:\n              // ignore\n              return;\n          }\n        }\n\n        break;\n      }\n      default: \n        return;\n    }\n\n    await this.render();\n  }\n          \n  private _getSelectionCoords = function(paddingLeft: number, paddingTop: number): WindowPosition | null {\n    const sel = this._editor.ownerDocument.getSelection();\n\n    // check if selection exists\n    if (!sel || !sel.rangeCount) return null;\n\n    // get range\n    const range = sel.getRangeAt(0).cloneRange();\n    if (!range.getClientRects()) return null;\n\n    // get client rect\n    range.collapse(false);\n    let rects = range.getClientRects();\n\n    // if we don't have any, it's probably the beginning of a newline, which works strange\n    if(!rects.length) {\n      if(range.startContainer && range.collapsed) {\n        // explicitely select the contents\n        range.selectNodeContents(range.startContainer);\n      }\n      rects = range.getClientRects();\n    }\n    if (rects.length <= 0) return null;\n\n    // get editor position\n    const editorRect = this._editor?.getBoundingClientRect();\n    if (!editorRect) return null;\n\n    const rect = rects[0];  // this is the location of the cursor\n\n    let adjustmentRect = { left: 0, top: 0 };\n\n    // if it's TinyMCE, we have to adjust for the location of the iframe it's in\n    if (this._editorType===EditorType.TinyMCE) {\n      const iframe = this._editor.ownerDocument.defaultView.frameElement;\n      if (!iframe)\n        throw 'Error locating TinyMCE - is it not in an iframe???';\n\n      adjustmentRect = iframe.getBoundingClientRect();      \n    }\n\n    // return coord\n    //return { x: rect.x - editorRect.left + paddingLeft, y: rect.y - editorRect.top + paddingTop };    \n    return { left: rect.left + adjustmentRect.left + paddingLeft, top: rect.top + adjustmentRect.top + paddingTop }\n  }\n\n  // _lastPulledSearchResults contains the full set of what we got back last time we pulled\n  private _getFilteredSearchResults(): SearchResult[] {\n    const FULL_TEXT_SEARCH = true; // TODO (for now, only name is searchable anyway)\n    const RESULT_LENGTH = moduleSettings.get(SettingKeys.resultLength);\n\n    let retval: SearchResult[];\n\n    if (FULL_TEXT_SEARCH) { // TODO\n      retval = this._lastPulledSearchResults;  // we don't know enough to filter any more (other than length of list)\n    } else {\n      //retval = this._lastPulledSearchResults.filter((i)=>(i.name.toLowerCase().includes(this._shownFilter.toLowerCase())));\n    }\n\n    return retval.slice(0, RESULT_LENGTH);  \n  }\n\n  // refresh the search results, if needed\n  // has the filter changed in a way that we need to refresh the search results?\n  // we only refresh the results if a) the active filter isn't an extension of the last searched one or\n  //    b) the last search told us there were more rows than we pulled for the prior search\n  private _refreshSearch = async function(): Promise<void> {\n    // when do we NOT need to refresh the main search results?\n    //   * we're not using full text (because we don't have a way to further filter here)\n    //   * we're searching the same type we did last time\n    //   * the new search results are a subset of the old ones - meaning the new filter starts with the old filter \n    const FULL_TEXT_SEARCH = true; //TODO: pull from settings\n\n    if (FULL_TEXT_SEARCH || (this._lastPulledType !== this._searchDocType) ||\n        (!this._lastPulledFilter || !this._shownfilter.toLowerCase().startsWith(this._lastPulledFilter.toLowerCase()))) {\n      // we need to refresh\n      // clear the current results so they don't show while we're waiting\n      this._filteredSearchResults = [];\n\n      if (this._currentMode===AutocompleteMode.journalPageSearch)\n        await this._pullJournalData();\n      else  \n        await this._pullData();\n    }\n\n    // if there's at least one result, select it  \n    this._filteredSearchResults = this._getFilteredSearchResults();\n    if (this._filteredSearchResults.length >=1) {\n      this._focusedMenuKey = 1;\n    } else {\n      // select create/whole journal option\n      this._focusedMenuKey = 0;\n    }\n  }\n\n  // pull the new data from the database\n  private async _pullData(): Promise<void> {\n    if (this._searchDocType === null) {\n      this._lastPulledFilter = '';\n      this._lastPulledType = null;\n      this._lastPulledSearchResults = [];\n      this._lastPulledRowCount = 0;\n      return;\n    }\n\n    this._lastPulledFilter = this._shownFilter;\n    this._lastPulledType = this._searchDocType;  \n\n    const docType = docTypes.find((d)=>(d.type===this._searchDocType));\n    if (!docType?.collectionName) {\n      this._lastPulledFilter = '';\n      this._lastPulledType = null;\n      this._lastPulledSearchResults = [];\n      return;\n    }\n\n    const collection = getGame()[docType.collectionName] as DocumentType;\n\n    // note that current typescript definitions don't know about search() function\n    let results: DocumentType[];\n    const FULL_TEXT_SEARCH = true;   // TODO: pull from settings; at the moment, only name seems to be searchable\n    if (FULL_TEXT_SEARCH) {\n      results = collection.search({query: this._shownFilter, filters:[]}) as DocumentType[];\n    } else {\n      results=[];\n      //results = collection.search({query: this._shownFilter, filters: [nameFilter]});\n    }\n\n    // remove any null names (which Foundry allows)\n    results = results.filter((item)=>(item.name));\n\n    this._lastPulledRowCount = results.length;\n\n    // uuid, and pages are OK here despite typescript\n    this._lastPulledSearchResults = results.map((item)=>({uuid: item.uuid, name: item.name, pages: this._searchDocType===ValidDocType.Journal ? item.pages : undefined})) as SearchResult[];  \n    return;\n  }\n\n  private async _pullJournalData(): Promise<void> {\n    if (this._currentMode!==AutocompleteMode.journalPageSearch) {\n      this._lastPulledFilter = '';\n      this._lastPulledType = null;\n      this._lastPulledSearchResults = [];\n      this._lastPulledRowCount = 0;\n      return;\n    }\n\n    this._lastPulledFilter = this._shownFilter;\n    this._lastPulledType = null;  \n\n    const collection = this._selectedJournal.pages;\n    if (!collection)\n      return;\n\n    // note that current typescript definitions don't know about search() function\n    let results: DocumentType[];\n    const FULL_TEXT_SEARCH = true;   // TODO: pull from settings; for now it doesn't seem to matter\n    if (FULL_TEXT_SEARCH) {\n      results = collection.search({query: this._shownFilter, filters:[]}) as DocumentType[];\n    } else {\n      results=[];\n      //results = collection.search({query: this._shownFilter, filters: [nameFilter]});\n    }\n\n    // remove any null names (which Foundry allows)\n    results = results.filter((item)=>(item.name));\n\n    this._lastPulledRowCount = results.length;\n\n    // uuid ok here despite typescript\n    this._lastPulledSearchResults = results.map((item)=>({ uuid: item.uuid, name: item.name, pages: null})) as SearchResult[];\n\n    return;\n  }\n\n  private async _moveToDocSearch(docType: ValidDocType) {\n    this._currentMode = AutocompleteMode.docSearch\n    this._searchDocType = docType;\n    this._shownFilter = '';\n    this._focusedMenuKey = 0;\n    await this._refreshSearch();\n  }\n\n  private _insertReferenceAndClose(uuid: string): void {\n    this._insertTextAndClose(`@UUID[${uuid}]`);\n  }\n\n  private _insertTextAndClose(text: string): void {\n    this._editor.focus();  \n    this._editor.ownerDocument.execCommand('insertText', false, text);\n    this.close();\n  }\n\n  private async _createDocument(docType: ValidDocType): Promise<void> {\n    const docTypeInfo = docTypes.find((dt)=>(dt.type===docType));\n    if (!docTypeInfo)\n      return;\n\n    const collection = getGame()[docTypeInfo.collectionName] as DocumentType;\n\n    // TODO: maybe default the folder to what's currently open?\n    const data = {folder: undefined };\n    const options = {width: 320, left: 300, top: 300 };\n\n    // register the hook to catch after the document is made\n    // we need to save the current editor selection because it goes away when the new boxes pop up\n    const selection = this._editor.ownerDocument.getSelection();\n    const range = selection?.rangeCount ? selection?.getRangeAt(0) : null;\n\n    //if ( this.collection instanceof CompendiumCollection ) options.pack = this.collection.collection;\n\n    const cls = getDocumentClass(collection.documentName);\n    cls.createDialog(data, options).then((result) => {\n      if (result) {\n        // it was created\n        if (range) {\n          selection?.removeAllRanges();\n          selection?.addRange(range);\n        }\n        this._insertReferenceAndClose(result.uuid);\n      } else {\n        // dialog was canceled; nothing to do      \n      }\n    });\n\n    this.close();\n  }\n}","import { initializeLocalizedText } from '@/autocomplete/autocompleter';\n\nexport function registerFori18nInitHook() {\n  Hooks.once('i18nInit', i18nInit);\n}\n\nasync function i18nInit(): Promise<void> {\n  // load the text\n  initializeLocalizedText();\n}\n\n","import { Autocompleter } from '@/autocomplete/autocompleter';\nimport { ModuleSettings, updateModuleSettings } from '@/settings/ModuleSettings';\nimport { EditorType } from '@/types';\n\nlet autocompleter = null as Autocompleter | null;\n\nexport function registerForInitHook() {\n  Hooks.once('init', init);\n}\n\nasync function init(): Promise<void> {\n  // initialize settings first, so other things can use them\n  updateModuleSettings(new ModuleSettings());\n\n  registerKeyListeners();\n}\n\n// register the main listener\nfunction registerKeyListeners() {\n  jQuery(document).on('keydown', '.ProseMirror.editor-content[contenteditable=\"true\"]', { editorType: EditorType.ProseMirror }, onKeydown);\n\n  // MCE editors are inside an iframe :(\n  // it really seems like there should be a better way to do this, but just putting a keydown on \n  //    iframes didn't work... I don't think the keys are bubbling up that high\n  // ideally there'd be a hook or something that tells us when a new editor is opened, but the only\n  //    one I can find is only called for ProseEditors\n  var observer = new MutationObserver(function(mutations) {\n      mutations.forEach(function(mutation) {\n        for (let i=0; i<mutation.addedNodes.length; i++) {\n          if (mutation.addedNodes[i].nodeName==='IFRAME') {\n            // for some reason I can't figure out, this only works if there's a delay here\n            // either way, it successfully attaches - I can see the event on the document - but it never executes\n            //   unless I wrap in this delay\n            setTimeout(()=> {\n              jQuery((mutation.addedNodes[i] as any).contentDocument).on('keydown', 'body#tinymce.mce-content-body[contenteditable=\"true\"]', { editorType: EditorType.TinyMCE }, onKeydown);\n            }, 100);\n          }\n        }\n      })\n  });\n  observer.observe(document, {\n      subtree: true,\n      childList: true\n  });\n\n}\n\nfunction onKeydown(event: KeyboardEvent) {\n  // watch for the @\n  if (event.key === '@') {\n      event.preventDefault();\n\n    let editorType: EditorType;\n    editorType=event.data.editorType;\n\n    activateAutocompleter(event.target, editorType);\n  }\n}\n\nfunction activateAutocompleter(targetElement, editorType) {\n  autocompleter?.close();\n\n  // Otherwise, create a new autocompleter\n  autocompleter = new Autocompleter(targetElement, editorType,  () => {\n      // When this Autocompleter gets closed, clean up the registration for this element.\n      autocompleter = null;\n  });\n  \n  autocompleter.render(true);\n}","\nexport default function(num1: number, num2: number): number {\n  return typeof num1 === 'number' && typeof num2 === 'number' ? \n    num1 + num2 :\n    num1;\n}","import add from './add';\n\nconst prefix = 'acm';\n\nexport function registerHelpers() {\n  Handlebars.registerHelper(`${prefix}-add`, add);\n}","import { registerHelpers } from '@/handlebars';\n\nexport function registerForReadyHook() {\n  Hooks.once('ready', ready);\n}\n\nasync function ready(): Promise<void> {\n  registerHelpers();\n}\n\n","import { registerFori18nInitHook } from './i18Init';\nimport { registerForInitHook } from './init';\nimport { registerForReadyHook } from './ready';\n\nexport function registerForHooks() {\n    registerForInitHook();\n    registerForReadyHook();\n    registerFori18nInitHook();\n}\n","import '@/../styles/autocomplete-mentions.scss';\n\nimport { registerForHooks } from '@/hooks';\n\n// track which modules we have\nlet validSimpleCalendar = false;\n\n/**\n* Register module in Developer Mode module (https://github.com/League-of-Foundry-Developers/foundryvtt-devMode)\n* No need to spam the console more than it already is, we hide them between a flag.\n*/\n// note: for the logs to actually work, you have to activate it in the UI under the config for the developer mode module\nHooks.once('devModeReady', async ({ registerPackageDebugFlag: registerPackageDebugFlag }: DevModeApi) => {\n  registerPackageDebugFlag('autocomplete-mentions', 'boolean');\n  //CONFIG.debug.hooks = true;\n});\n\nregisterForHooks();\n\n"],"names":["getGame","localize","stringId","messagePrefix","log","force","args","isDebugging","_b","_a","e","AutocompleteMode","AutocompleteMode2","ValidDocType","ValidDocType2","EditorType","EditorType2","SettingKeys","moduleSettings","updateModuleSettings","settings","ModuleSettings","setting","moduleJson","value","settingKey","settingConfig","i","settingID","docTypes","initializeLocalizedText","Autocompleter","target","editorType","onClose","event","index","dt","match","journal","item","paddingLeft","paddingTop","sel","range","rects","rect","adjustmentRect","iframe","options","newTarget","_c","$html","html","wrapper","menuItems","onPointerDown","RESULT_LENGTH","retval","docType","d","collection","results","uuid","text","docTypeInfo","data","selection","result","registerFori18nInitHook","i18nInit","autocompleter","registerForInitHook","init","registerKeyListeners","onKeydown","observer","mutations","mutation","activateAutocompleter","targetElement","add","num1","num2","prefix","registerHelpers","registerForReadyHook","ready","registerForHooks","registerPackageDebugFlag"],"mappings":"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"}